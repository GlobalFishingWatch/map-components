{"version":3,"sources":["webpack:///./src/map/glmap/map.css","webpack:///./src/map/lib/Pack.js","webpack:///./src/map/lib/pelagosClient.js","webpack:///./src/map/proptypes/tracks.js","webpack:///./src/map/proptypes/layers.js","webpack:///./src/map/proptypes/shared.js","webpack:///./src/map/config.js","webpack:///./src/map/module/module.actions.js","webpack:///./src/map/module/module.selectors.js","webpack:///./src/map/tracks/tracks.selectors.js","webpack:///./src/map/constants.js","webpack:///./src/map/utils/getPBFTile.js","webpack:///./src/map/utils/heatmapTileData.js","webpack:///./src/map/utils/buildEndpoint.js","webpack:///./src/map/heatmap/heatmapTiles.actions.js","webpack:///./src/map/heatmap/heatmap.actions.js","webpack:///./src/map/glmap/viewport.actions.js","webpack:///./src/map/glmap/interaction.actions.js","webpack:///./src/map/utils/map-colors.js","webpack:///./src/map/heatmap/HeatmapSubLayer.js","webpack:///./src/map/heatmap/HeatmapLayer.js","webpack:///./src/map/tracks/TracksLayer.js","webpack:///./src/map/activity/ActivityLayers.js","webpack:///./src/map/activity/ActivityLayers.container.js","webpack:///./src/map/glmap/Map.js","webpack:///./src/map/glmap/Map.container.js","webpack:///./src/map/utils/getMainGeomType.js","webpack:///./src/map/glmap/style.actions.js","webpack:///./src/map/tracks/tracks.actions.js","webpack:///./src/map/utils/withReducerTypes.js","webpack:///./src/map/module/module.reducer.js","webpack:///./src/map/tracks/tracks.reducer.js","webpack:///./src/map/heatmap/heatmap.reducer.js","webpack:///./src/map/heatmap/heatmapTiles.reducer.js","webpack:///./src/map/glmap/viewport.reducer.js","webpack:///./src/map/glmap/style.reducer.js","webpack:///./src/map/glmap/interaction.reducer.js","webpack:///./src/map/map.js","webpack:///./src/map/map.mdx"],"names":["module","exports","map","googleLogo","byname","Uint8","size","Uint8Array","BYTES_PER_ELEMENT","array","getter","setter","Int8","Int8Array","Uint16","Uint16Array","Int16","Int16Array","Uint32","Uint32Array","Int32","Int32Array","Float32","Float32Array","Float64","Float64Array","writeStringToArrayBuffer","str","start","end","buf","bufstart","undefined","length","i","charCodeAt","arrayBufferToString","String","fromCharCode","apply","Pack","typemap","byarray","pack","typespec","value","littleendian","ArrayBuffer","DataView","stringToArrayBuffer","res","Uint8ClampedArray","buffer","name","spec","PelagosClient","_classCallCheck","this","MAGIC_COOKIE","url","token","Promise","resolve","reject","request","XMLHttpRequest","open","setRequestHeader","concat","responseType","onload","handleData","bind","onerror","send","self","error","readyState","success","status","isFileUri","response","byteLength","dataView","headerLen","cookie","slice","getInt32","offset","headerIsLoaded","header","JSON","parse","rowLen","colsByName","colidx","cols","col","idx","type","multiplier","min","max","orientation","errorLoading","toString","allLoaded","result","rowidx","row","val","colValues","eval","trackTypes","id","PropTypes","string","isRequired","data","object","color","oneOf","layerTemporalExtents","arrayOf","number","fitBoundsOnLoad","bool","shape","hue","filterValues","endpoints","isPBF","temporalExtents","temporalExtentsLess","field","values","node","VESSELS_BASE_RADIUS","MAX_SPRITES_PER_LAYER","startLoader","dispatch","state","loaderId","Date","getTime","payload","onLoadStart","completeLoader","getState","loaders","Object","assign","onLoadComplete","setHighlightTemporalExtent","highlightTemporalExtent","getTemporalExtent","temporalExtent","getHighlightTemporalExtent","getGeojsonTracks","createSelector","tracks","filter","t","getGeojsonTracksReady","mergeStyles","style1","style2","sources","_objectSpread","layers","_toConsumableArray","filterGeojsonByTimerange","geojson","_ref","features","featuresFiltered","reduce","filteredFeatures","feature","properties","coordinateProperties","times","filtered","geometry","coordinates","filteredCoordinates","coordinate","index","timeCoordinate","push","filteredFeature","getFullTracksStyles","hasTemporalExtent","hasTracks","timerange","acc","track","source","style","_defineProperty","paint","line-width","line-color","circle-radius","circle-color","getHighlightedTrackStyles","getTracksStyles","trackStyles","highlightedTrackStyles","TRANSITION_TYPE","BRUSH_RENDERING_STYLE","NORMAL","BULLSEYE","BRUSH_ZOOM_RENDERING_STYLE","CUSTOM_LAYERS_SUBTYPES","getPBFTile","tileUrl","fetch","headers","Authorization","then","ok","Error","blob","reader","FileReader","addEventListener","pbf","Pbf","vectorTile","VectorTile","readAsArrayBuffer","catch","e","console","warn","getTemporalTileURLs","urlTemplate","params","urls","forEach","extent","urlParams","seriesgroup","startTimeISO","toISOString","endTimeISO","tileCoordinates","x","y","z","zoom","templateSettings","interpolate","template","urlTemplateCompiled","buildEndpoint","temporalExtentsIndices","indexOf","getTilePromises","tilesetUrl","promises","urlIndex","obtainTile","getCleanVectorArrays","rawTileData","vectorArray","groupData","cleanVectorArrays","columns","currentArray","totalVectorArraysLength","sumBy","a","longitude","filteredColumns","column","key","cumulatedOffsets","appendValues","set","getTilePlaybackData","prevPlaybackData","tilePlaybackData","zoomFactorRadius","convert","getZoomFactorRadius","zoomFactorRadiusRenderingMode","getZoomFactorRadiusRenderingMode","zoomFactorOpacity","getZoomFactorOpacity","columnsArr","keys","c","storedColumns","sigma","weight","hidden","pull","uniq","_loop","point","geom","toGeoJSON","latitude","timeIndex","getOffsetedTimeAtPrecision","datetime","_lngLatToWorld2","_slicedToArray","lngLatToWorld","worldX","worldY","radius","sigmaToRadius","opacity","weightToOpacity","series","frame","addTracksPointsRenderingData","hasFishing","_lngLatToWorld4","getTracksPlaybackData","playbackData","vesselSatisfiesFilters","every","selectVesselsAt","tileData","tileQuery","startIndex","endIndex","currentFilters","vessels","toleranceRadiusInWorldUnits","_loop2","f","_loop3","wx","wy","filters","pass","some","vesselSatisfiesAllFilters","vessel","getTilecoverLimits","viewportZoom","Math","ceil","tilesAvailable","min_zoom","max_zoom","flushToReleaseTiles","heatmapTiles","currentToLoadTileUids","currentTilesToReleaseUids","currentToReleaseTileUids","releaseTiles","markTileAsLoaded","tileUids","flushTileState","forceLoadingAllVisibleTiles","arguments","currentVisibleTiles","tilesToLoad","tilesToReleaseUids","currentLoadedTiles","visibleTile","find","uid","loadedTile","tilesToLoadUids","tile","referenceTile","ADD_REFERENCE_TILE","visibleHeatmapLayers","heatmap","heatmapLayers","visibleHeatmapLayersIds","visible","getTiles","updateLoadedTiles","debouncedFlushState","debounce","updateHeatmapTilesFromViewport","mapViewport","viewport","currentTransition","boundsViewport","PerspectiveMercatorViewport","bounds","unproject","width","height","wn","es","w","s","n","boundsPolygonsCoordinates","limits","w1","e2","viewportTilesCoords","tilecover","tiles","viewportTilesIndexes","indexes","visibleTiles","coords","prevZoom","queryHeatmapVessels","temporalExtentIndexes","uids","_queryHeatmap2","_queryHeatmap","layer","isEmpty","isCluster","isMouseCluster","foundVessels","highlightedVessels","layerId","HIGHLIGHT_VESSELS","tilesetId","subtype","clickableCluster","highlightableCluster","clearHighlightedVessels","highlightVesselFromHeatmap","heatmapTiles_actions_objectSpread","UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES","UPDATE_HEATMAP_TILE","getTemporalExtentsVisibleIndices","loadTemporalExtent","currentExtentStart","currentExtentEnd","indices","temporalExtentStart","layerIds","referenceTiles","newTemporalExtentsToLoad","loaderID","tilesByLayer","heatmap_actions_toConsumableArray","allPromises","heatmapLayerHeader","_heatmapLayerHeader","heatmap_actions_objectSpread","temporalExtentsIndicesLoaded","queriedTemporalExtentsIndices","visibleTemporalExtentsIndices","temporalExtentsIndicesToLoad","difference","tilePromise","pelagosPromises","allLayerPromises","all","loadedLayerId","loadLayerTile","_ref2","points","parseLayerTile","loadAllTilesForLayer","layersVessels","availableTiles","bestTile","layerVesselsResult","layersVesselsResults","layerVessels","hasEncounters","layerVessel","v","uniqBy","updateHeatmapLayers","newLayers","currentLoadTemporalExtent","prevLayersDict","newLayer","prevLayer","interactive","prevLayerId","l","transitionTo","increment","callback","onViewportChange","center","canZoomIn","canZoomOut","mouseLatLong","getFeatureMetaFields","staticLayerId","mapStyle","toJS","metadata","getStaticLayerIdFromGlFeature","glFeature","findFeature","glFeatures","mapClick","cluster","currentActivityLayersInteractionData","event","fields","metaFields","metaField","pow","area","toLocaleString","maximumFractionDigits","title","label","isLink","target","zoomIntoVesselCenter","onClick","interaction_actions_objectSpread","hsvToRgb","h_","s_","v_","h","parseFloat","floor","p","q","mod","r","g","b","round","hueToRgbDefaults","hueToRgbString","rgb","hexToRgb","hex","exec","parseInt","hueIncrementToHue","hueIncrement","wrapHue","HeatmapSubLayer","baseTexture","renderingStyleIndex","useNormalBlendMode","stage","PIXI","particles","ParticleContainer","scale","alpha","position","uvs","blendMode","BLEND_MODES","SCREEN","spritesPool","initialTextureFrame","Rectangle","mainVesselTexture","Texture","_setTextureFrame","clearSpriteProps","spritesProps","spritesPropsCount","destroy","children","textureFrame","clone","hueToHueIncrement","VESSELS_HUES_INCREMENTS_NUM","update","numProps","resizeSpritesPool","sprite","setTransform","numSprites","delta","toRemove","removeChildAt","toAdd","_addSprites","num","Sprite","anchor","addChild","worldToPixelsSimple","m","HeatmapLayer","React","Component","_build","_destroy","_redraw","nextProps","useRadialGradientStyle","props","setBrushZoomRenderingStyle","_this$props","rootStage","customRenderingStyle","subLayers","renderingStyle","rendering","setBrushRenderingStyle","brushRenderingStyle","toUpperCase","_setBrushRenderingStyleIndex","brushZoomRenderingStyle","_this","cappedZoomRenderingStyle","newStyleIndex","subLayer","setRenderingStyleIndex","_this2","_this$props2","defaultHue","allHuesToRender","currentlyUsedHues","allHues","_createSublayer","_destroySubLayer","_setSubLayersSpritePropsForTile","numFilters","hueToRender","render","_this$props3","viewportLeft","viewportRight","len","fi","scaledX","scaledY","mtx","pixelProjectionMatrix","_ref3","HeatmapLayer_slicedToArray","pitch","worldToPixels","pushSpriteProps","defaultOpacity","defaultSize","removeChild","TracksLayer","Graphics","nativeLines","clear","highlightTemporalExtentIndexes","overInInner","overExtent","drawFishingCircles","fishingCirclesRadius","drawOverTrack","_drawTrack","substr","lineThickness","lineOpacity","prevSeries","prevWorldX","prevWorldY","_ref$worldOffset","worldOffset","circlePoints","lineStyle","duplicateWorld","currentSeries","_worldToPixels2","TracksLayer_slicedToArray","moveTo","abs","atDatelineWorldY","isWestToEast","worldXEnd","atDatelineEndWorldX","atDatelineStartWorldX","_worldToPixels4","x1","y1","lineTo","_worldToPixels6","x2","y2","beginFill","circlesLength","drawCircle","endFill","ActivityLayers","touches","queryCoords","clientX","clientY","heatmapFadingIn","heatmapStage","_heatmapFadeinStep","BaseControl","exportNativeViewport","_context","_updateViewportSize","_this$props$viewport","pixi","transparent","antialias","renderer","canvas","view","container","appendChild","baseTextureCanvas","blurFactor","tplCanvas","document","createElement","tplCtx","getContext","diameter","yCenter","gradient","createRadialGradient","rgbString","addColorStop","rgbOuter","fillStyle","fillRect","beginPath","arc","PI","fill","lineWidth","strokeStyle","stroke","getVesselTexture","fromCanvas","ticker","add","_onTick","viewportWidth","viewportHeight","resize","dim","_viewport$unproject2","ActivityLayers_slicedToArray","wrappedLongitude","heatmapFadeinStartTimestamp","now","timeElapsed","highlightedClickedVessel","highlightLayerData","highlightFilters","ActivityLayers_objectSpread","leftWorldScaled","rightWorldScaled","shouldUseRadialGradientStyle","toggleHeatmapDimming","_startHeatmapFadein","err","gl","getError","log","_this$_getHighlightDa","_getHighlightData","react_default","ref","onMouseMove","onTouchStart","heatmap_HeatmapLayer","tracks_TracksLayer","propTypes","func","contextTypes","getHeatmapLayersAsArray","ActivityLayers_container_objectSpread","getTracksWithData","getTemporalExtentIndexes","startTimestamp","endTimestamp","getHighlightTemporalExtentIndexes","connect","ownProps","nativeViewport","topLeftPx","bottomRightPx","topLeftWorld","pixelsToWorld","pixelUnprojectionMatrix","bottomRightWorld","northWest","southEast","north","south","west","east","PopupWrapper","closeButton","onClose","esm","offsetTop","tipSize","closeOnClick","Map","Map_classCallCheck","Map_getPrototypeOf","call","Map_defineProperty","Map_assertThisInitialized","_mapContainerRef","mapContainerStyle","window","getComputedStyle","setViewport","Map_objectSpread","mapHover","glMap","clusterId","cluster_id","sourceId","glSource","getSource","getClusterExpansionZoom","err1","getClusterLeaves","err2","lngLat","onMapInteraction","mouseOver","_resize","setTimeout","removeEventListener","_this3","maxZoom","minZoom","transitionEnd","onClosePopup","clickPopup","hoverPopup","cursor","interactiveLayerIds","className","styles","onMouseLeave","setState","onMouseEnter","getMap","onTransitionEnd","onHover","getCursor","isDragging","ActivityLayers_container","Map_PopupWrapper","content","getInteractiveLayerIds","staticLayers","getMapStyle","mapStyles","trackLayersIndex","lastIndexOf","finalMapStyles","mergeIn","mapStylesLayers","get","trackLayer","insert","fromJS","interaction","lat","long","popupFields","mainPopupFieldId","toLowerCase","featureTitle","objects","TYPES","geoJSON","setMapStyle","updateGLLayer","glLayerId","refLayer","currentStyleLayers","newStyle","glLayerIndex","findIndex","glLayer","visibility","setIn","toggleLayerVisibility","isBasemap","initialGLLayer","GL_STYLE","refLayerOpacity","labelsVisibility","getIn","showLabels","currentGlLayer","currentStyle","glType","defaultStyles","styleType","hasFeatures","applyStyleToAllFeatures","allPaintProperties","style_actions_objectSpread","glPaintProperty","glPaintFinalValue","selectedValue","fallbackValue","paintOrLayout","includes","layerColorRgbString","layerColorRgb","replace","applyLayerExpressions","addCustomGLLayer","tileSize","allGeoJSONTypes","numByGLType","geoJSONType","glTypeMax","getMainGeomType","layout","layerIndex","reverse","splice","instanciateCartoLayers","cartoLayersPromises","sourceCartoSQL","mapConfig","options","sql","mapConfigURL","encodeURIComponent","stringify","cartoAnonymousMapUrl","json","layergroupid","instanciatedCartoLayers","cartoLayer","tilesURL","newSourceId","commitStyleUpdates","basemapLayers","style_actions_toConsumableArray","bl","currentGLSources","workspaceGLLayers","workspaceGLLayer","finalSource","srcGlLayer","source-layer","finalLayers","addWorkspaceGLLayers","customLayers","isCustom","glLayers","glSources","cartoLayersToInstanciate","cartoLayerInstanciated","cartoLayersInstanciated","ADD_TRACK","UPDATE_TRACK","getTrackDataParsed","time","Infinity","timelineBounds","getTrackBounds","tbbox","minLat","minLng","maxLat","maxLng","getOldTrackBoundsFormat","addOffset","geo","lng","updateTracks","newTracks","prevTracks","newTrack","trackId","prevTrack","trackHasData","trackHasUrl","geoBounds","cleanData","rawTrackData","statusText","_getTrackDataParsed","targetMapVessel","finally","withReducerPropTypes","propTypesSchema","reducer","initialState","onAttributionsChange","withReducerTypes","instanceOf","action","module_reducer_objectSpread","module_reducer_toConsumableArray","loaderIndex","exact","tracks_reducer_objectSpread","tracks_reducer_toConsumableArray","trackData","removedTrackId","DEFAULT_TRANSITION","transitionDuration","transitionInterpolator","FlyToInterpolator","transitionEasing","easeCubic","bearing","attributions","sourceKey","attribution","mapReducer","combineReducers","ModuleReducer","TracksReducer","indicesAdded","heatmap_reducer_defineProperty","heatmap_reducer_objectSpread","heatmap_reducer_toConsumableArray","newTile","layerTiles","tileIndex","tileUid","releasedTileIndex","releasedRefTileIndex","newHeatmapLayers","heatmapTiles_reducer_objectSpread","tileUidsMarkedAsLoaded","newMapStyle","glyphsPath","style_reducer_objectSpread","style_reducer_toConsumableArray","viewport_reducer_objectSpread","currentZoom","interaction_reducer_objectSpread","composeEnhancers","compose","process","MAP_REDUX_REMOTE_DEBUG","REACT_APP_MAP_REDUX_REMOTE_DEBUG","store","createStore","applyMiddleware","thunk","throttleApplyTemporalExtent","throttle","currentFilter","applyTemporalExtent","setTemporalExtent","updateViewportFromIncomingProps","incomingViewport","viewportUpdate","MapModule","initialized","errorInfo","prevProps","indicesToAddByLayer","heatmapLayer","oldVisibleTemporalExtentsIndices","newVisibleTemporalExtentsIndices","layerIdsWithIndicesToAdd","currentViewport","componentStack","react_redux_es","Map_container","defaultProps","vp","fitBounds","padding","MDXContent","map_map_classCallCheck","map_map_possibleConstructorReturn","map_map_getPrototypeOf","components","_objectWithoutProperties","dist","parentName","href","index_m","__codesandbox","__position","__code","__scope","map_map"],"mappings":"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","file":"static/js/src-map-map.3003b10b.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"map\":\"map_map__2QkEc\",\"googleLogo\":\"map_googleLogo__1hHOD\"};","var byname = {\n  Uint8: {\n    size: Uint8Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint8',\n    setter: 'setUint8',\n  },\n  Int8: {\n    size: Int8Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint8',\n    setter: 'setUint8',\n  },\n  Uint16: {\n    size: Uint16Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint16',\n    setter: 'setUint16',\n  },\n  Int16: {\n    size: Int16Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getInt16',\n    setter: 'setInt16',\n  },\n  Uint32: {\n    size: Uint32Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint32',\n    setter: 'setUint32',\n  },\n  Int32: {\n    size: Int32Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getInt32',\n    setter: 'setInt32',\n  },\n  Float32: {\n    size: Float32Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getFloat32',\n    setter: 'setFloat32',\n  },\n  Float64: {\n    size: Float64Array.BYTES_PER_ELEMENT,\n    array: 'Float64Array',\n    getter: 'getFloat64',\n    setter: 'setFloat64',\n  },\n}\n\nvar writeStringToArrayBuffer = function(str, start, end, buf, bufstart) {\n  if (end == undefined) {\n    end = str.length\n  }\n  if (start == undefined) {\n    start = 0\n  }\n  if (bufstart == undefined) {\n    bufstart = start\n  }\n  for (var i = start; i < end; i++) {\n    buf[i - start + bufstart] = str.charCodeAt(i) & 0xff\n  }\n}\n\nvar stringToArrayBuffer = function(str, start, end) {\n  var self = this\n\n  if (end == undefined) {\n    end = str.length\n  }\n  if (start == undefined) {\n    start = 0\n  }\n  var res = new Uint8ClampedArray(end - start)\n  writeStringToArrayBuffer(str, start, end, res, 0)\n  return res.buffer\n}\n\nvar arrayBufferToString = function(buf) {\n  return String.fromCharCode.apply(null, new Uint8Array(buf))\n}\n\nvar pack = function(typespec, value, littleendian) {\n  var array = new ArrayBuffer(typespec.size)\n  new DataView(array)[typespec.setter](0, value, littleendian)\n  return arrayBufferToString(array)\n}\n\nvar Pack = {\n  typemap: {\n    byname: byname,\n    byarray: {},\n  },\n  pack: pack,\n  arrayBufferToString: arrayBufferToString,\n  stringToArrayBuffer: stringToArrayBuffer,\n  writeStringToArrayBuffer: writeStringToArrayBuffer,\n}\nfor (var name in Pack.typemap.byname) {\n  var spec = Pack.typemap.byname[name]\n  spec.name = name\n  Pack.typemap.byarray[spec.array] = spec\n}\n\nexport default Pack\n","import Pack from './Pack'\n\nclass PelagosClient {\n  constructor() {\n    this.MAGIC_COOKIE = 'tmtx'\n  }\n\n  obtainTile(url, token) {\n    return new Promise(\n      function(resolve, reject) {\n        this.request = null\n        if (typeof XMLHttpRequest != 'undefined') {\n          this.request = new XMLHttpRequest()\n        } else {\n          throw 'XMLHttpRequest is disabled'\n        }\n        this.resolve = resolve\n        this.reject = reject\n        this.request.open('GET', url, true)\n        if (token) {\n          this.request.setRequestHeader('Authorization', `Bearer ${token}`)\n        }\n        this.request.responseType = 'arraybuffer'\n        this.request.onload = this.handleData.bind(this)\n        this.request.onerror = this.handleData.bind(this)\n        this.request.send(null)\n      }.bind(this)\n    )\n  }\n\n  handleData() {\n    var self = this\n    if (!this.request) {\n      return\n    }\n    if (this.error) {\n      return true\n    }\n\n    if (this.request.readyState == 4) {\n      /* HTTP reports success with a 200 status. The file protocol\n       reports success with zero. HTTP returns zero as a status\n       code for forbidden cross domain requests.\n       https://developer.mozilla.org/En/Using_XMLHttpRequest */\n      var success = this.request.status == 200 || (this.isFileUri && this.request.status == 0)\n      if (!success) {\n        this.resolve(null)\n        return\n      }\n    }\n\n    if (!this.request.response) {\n      return\n    }\n    var length = this.request.response.byteLength\n    var response = this.request.response\n    var dataView = new DataView(response)\n\n    if (length < 4 + 4) {\n      return\n    }\n    if (self.headerLen == null) {\n      var cookie = Pack.arrayBufferToString(response.slice(0, 4))\n      if (cookie != this.MAGIC_COOKIE) {\n        this.reject(\n          'Could not load ' +\n            this.url +\n            ' due to incorrect file format. Cookie: [' +\n            this.cookie +\n            ']'\n        )\n        return\n      }\n\n      self.headerLen = dataView.getInt32(4, true)\n\n      self.offset = 4 + 4\n    }\n    if (length < self.offset + self.headerLen) {\n      return\n    }\n    if (!self.headerIsLoaded) {\n      self.header = JSON.parse(\n        Pack.arrayBufferToString(response.slice(self.offset, self.offset + self.headerLen))\n      )\n      self.rowLen = 0\n      self.header.colsByName = {}\n      for (var colidx = 0; colidx < self.header.cols.length; colidx++) {\n        var col = self.header.cols[colidx]\n        col.idx = colidx\n        self.header.colsByName[col.name] = col\n        col.typespec = Pack.typemap.byname[col.type]\n\n        if (col.multiplier != undefined && col.min != undefined) {\n          col.min = col.min * col.multiplier\n        }\n        if (col.offset != undefined && col.min != undefined) {\n          col.min = col.min + col.offset\n        }\n        if (col.multiplier != undefined && col.max != undefined) {\n          col.max = col.max * col.multiplier\n        }\n        if (col.offset != undefined && col.max != undefined) {\n          col.max = col.max + col.offset\n        }\n\n        self.rowLen += col.typespec.size\n      }\n      self.offset += self.headerLen\n\n      // Add the padding to nearest 4-byte-boundary\n      self.offset += (4 - (self.headerLen % 4)) % 4\n\n      self.headerIsLoaded = true\n      if (self.header.orientation != 'rowwise' && self.header.orientation != 'columnwise') {\n        self.errorLoading({\n          orientation: self.header.orientation,\n          toString: function() {\n            return (\n              'Could not load ' +\n              this.url +\n              ' due to unsupported file orientation. Orientation: ' +\n              this.orientation +\n              '. Supported orientations: rowwise, columnwise.'\n            )\n          },\n        })\n        return true\n      }\n\n      // Empty tile, stop parsing.\n      if (!self.rowLen) {\n        self.allLoaded()\n        return true\n      }\n    }\n    if (self.header.orientation == 'rowwise') {\n      var result = {}\n      for (; self.offset + self.rowLen <= length; self.rowidx++) {\n        var row = {}\n        for (var colidx = 0; colidx < self.header.cols.length; colidx++) {\n          var col = self.header.cols[colidx]\n          var val = dataView[col.typespec.getter](self.offset, true)\n          row[col.name] = val\n          self.offset += col.typespec.size\n        }\n        // self.rowLoaded(row);\n\n        result[col.name] = row\n      }\n      if (self.rowidx == self.header.length) {\n        // self.allLoaded();\n        this.resolve(result)\n      } else {\n        // self.batchLoaded();\n      }\n    } else if (self.header.orientation == 'columnwise') {\n      var colValues = null\n      var result = {}\n      if (length >= self.offset + self.header.length * self.rowLen) {\n        for (var colidx = 0; colidx < self.header.cols.length; colidx++) {\n          var col = self.header.cols[colidx]\n\n          colValues = new (eval(col.typespec.array))(\n            response.slice(self.offset, self.offset + col.typespec.size * self.header.length)\n          )\n          self.offset += self.header.length * col.typespec.size\n\n          result[col.name] = colValues\n        }\n\n        // self.allLoaded();\n        this.resolve(result)\n        return true\n      }\n    }\n  }\n}\n\nexport default PelagosClient\n","import PropTypes from 'prop-types'\n\nexport const trackTypes = {\n  id: PropTypes.string.isRequired,\n  url: PropTypes.string,\n  data: PropTypes.object,\n  color: PropTypes.string,\n  type: PropTypes.oneOf(['geojson', undefined]),\n  layerTemporalExtents: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.number)),\n  fitBoundsOnLoad: PropTypes.bool,\n}\n","import PropTypes from 'prop-types'\n\nexport const heatmapLayerTypes = {\n  id: PropTypes.string.isRequired,\n  tilesetId: PropTypes.string,\n  subtype: PropTypes.string,\n  visible: PropTypes.bool,\n  hue: PropTypes.number,\n  opacity: PropTypes.number,\n  filters: PropTypes.arrayOf(\n    PropTypes.shape({\n      // hue overrides layer hue if set\n      hue: PropTypes.number,\n      // filterValues is a dictionary in which each key is a filterable field,\n      // and values is an array of all possible values (OR filter)\n      // ie: filterValues: { category: [5, 6] }\n      filterValues: PropTypes.object,\n    })\n  ),\n  header: PropTypes.shape({\n    endpoints: PropTypes.object,\n    isPBF: PropTypes.bool,\n    colsByName: PropTypes.object,\n    temporalExtents: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.number)),\n    temporalExtentsLess: PropTypes.bool,\n  }).isRequired,\n  interactive: PropTypes.bool,\n}\n\nexport const basemapLayerTypes = {\n  id: PropTypes.string,\n  visible: PropTypes.bool,\n}\n\nexport const staticLayerTypes = {\n  id: PropTypes.string.isRequired,\n  // TODO MAP MODULE Is that needed and if so why\n  visible: PropTypes.bool,\n  selected: PropTypes.bool,\n  selectedFeatures: PropTypes.shape({\n    field: PropTypes.string,\n    values: PropTypes.arrayOf(PropTypes.string),\n  }),\n  highlighted: PropTypes.bool,\n  higlightedFeatures: PropTypes.shape({\n    field: PropTypes.string,\n    values: PropTypes.arrayOf(PropTypes.string),\n  }),\n  opacity: PropTypes.number,\n  color: PropTypes.string,\n  showLabels: PropTypes.bool,\n  interactive: PropTypes.bool,\n  filters: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.string)),\n  isCustom: PropTypes.bool,\n  subtype: PropTypes.oneOf([undefined, 'geojson', 'raster']),\n  url: PropTypes.string,\n  data: PropTypes.object,\n  gl: PropTypes.object,\n}\n","import PropTypes from 'prop-types'\n\nexport const popupTypes = {\n  content: PropTypes.node,\n  latitude: PropTypes.number.isRequired,\n  longitude: PropTypes.number.isRequired,\n}\n\nexport const viewportTypes = {\n  zoom: PropTypes.number,\n  center: PropTypes.arrayOf(PropTypes.number),\n}\n","// Application settings\nexport const TIMELINE_STEP = 24 * 60 * 60 * 1000 // 1 day\nexport const MIN_FRAME_LENGTH_MS = TIMELINE_STEP // 1 day\n\n// vessels rendering\n// from this zoom level and above, render using circle style instead of heatmap\nexport const VESSELS_RADIAL_GRADIENT_STYLE_ZOOM_THRESHOLD = 6\n// the base radius, it can only be scaled down by the radius factor calculated on the dataset\nexport const VESSELS_BASE_RADIUS = 8\n// in heatmap style, defines how 'blurry' a point will look. Higher = less blur\nexport const VESSELS_HEATMAP_BLUR_FACTOR = 0.15\n\nexport const ACTIVITY_HIGHLIGHT_HUE = 312\n\nexport const VESSELS_HEATMAP_DIMMING_ALPHA = 0.5\n\nexport const TRACKS_DOTS_STYLE_ZOOM_THRESHOLD = 2\n\nexport const MAX_SPRITES_PER_LAYER = 200000\n\n// interaction\n// radius of vessels lookup in pixels,\n// ie how large the clicked region should be for including vessels\nexport const VESSEL_CLICK_TOLERANCE_PX = 10\n\nexport const CLUSTER_CLICK_ZOOM_INCREMENT = 1\n\nexport const MIN_ZOOM_LEVEL = 1\n// user can zoom up to this z level, but it doesn't guarantee availability of tiles\nexport const MAX_ZOOM_LEVEL = 14\n\n// data\n// Limit tile loading for activity layers up to this z level.\n// Beyond, layer is still displayed but with coarse data from the lower zoom level\nexport const ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING = 10\n\n// Sets what should be the discrete zoom level to load tiles, from a non-discrete\n// viewport zoom values. For instance, a values of 0.5 will load z 3 with a viewport\n// z of 2 (ceiling of 2 + 0.5)\n// this has a direct impact on the number of points displayed on the map, thus on the\n// performance of the app.\nexport const TILES_LOAD_ZOOM_OFFSET = 0.5\n\nexport const STATIC_LAYERS_CARTO_ENDPOINT =\n  'https://carto.globalfishingwatch.org/user/admin/api/v1/map?config=$MAPCONFIG'\nexport const STATIC_LAYERS_CARTO_TILES_ENDPOINT =\n  'https://carto.globalfishingwatch.org/user/admin/api/v1/map/$LAYERGROUPID/{z}/{x}/{y}.mvt'\n\nexport const TRACKS_LAYER_IN_FRONT_OF_GROUP = 'static'\n","export const INIT_MODULE = 'INIT_MODULE'\nexport const SET_TEMPORAL_EXTENT = 'SET_TEMPORAL_EXTENT'\nexport const SET_HIGHLIGHT_TEMPORAL_EXTENT = 'SET_HIGHLIGHT_TEMPORAL_EXTENT'\nexport const START_LOADER = 'START_LOADER'\nexport const COMPLETE_LOADER = 'COMPLETE_LOADER'\n\nexport const initModule = (props) => (dispatch) => {\n  dispatch({\n    type: INIT_MODULE,\n    payload: props,\n  })\n}\n\nexport const startLoader = (dispatch, state) => {\n  const loaderId = new Date().getTime()\n  dispatch({\n    type: START_LOADER,\n    payload: loaderId,\n  })\n  if (state.map.module.onLoadStart !== undefined) {\n    state.map.module.onLoadStart()\n  }\n  return loaderId\n}\n\nexport const completeLoader = (loaderId) => (dispatch, getState) => {\n  const state = getState()\n  const loaders = Object.assign({}, state.map.module.loaders)\n  dispatch({\n    type: COMPLETE_LOADER,\n    payload: loaderId,\n  })\n  if (!loaders.length && state.map.module.onLoadComplete !== undefined) {\n    state.map.module.onLoadComplete()\n  }\n}\n\nexport const onViewportChange = () => (dispatch, getState) => {\n  const state = getState()\n  const callback = state.map.module.onViewportChange\n\n  if (callback === undefined) {\n    return\n  }\n  const viewport = state.map.viewport\n\n  if (viewport.bounds === undefined) {\n    return\n  }\n\n  callback({\n    zoom: viewport.viewport.zoom,\n    center: [viewport.viewport.latitude, viewport.viewport.longitude],\n    bounds: viewport.bounds,\n    canZoomIn: viewport.canZoomIn,\n    canZoomOut: viewport.canZoomOut,\n    mouseLatLong: viewport.mouseLatLong,\n  })\n}\n\nexport const setTemporalExtent = (temporalExtent) => ({\n  type: SET_TEMPORAL_EXTENT,\n  payload: temporalExtent,\n})\n\nexport const setHighlightTemporalExtent = (highlightTemporalExtent) => ({\n  type: SET_HIGHLIGHT_TEMPORAL_EXTENT,\n  payload: highlightTemporalExtent,\n})\n\nexport const closePopup = () => (dispatch, getState) => {\n  const state = getState()\n  if (state.map.module.onClosePopup !== undefined) {\n    state.map.module.onClosePopup()\n  }\n}\n","export const getTemporalExtent = (state) => state.map.module.temporalExtent\n\nexport const getHighlightTemporalExtent = (state) => state.map.module.highlightTemporalExtent\n","import { createSelector } from 'reselect'\nimport { getTemporalExtent, getHighlightTemporalExtent } from '../module/module.selectors'\n\nexport const getTracksData = (state) => state.map.tracks.data\nexport const getGeojsonTracks = createSelector(\n  getTracksData,\n  (tracks) => tracks.filter((t) => t.type === 'geojson')\n)\nexport const getGeojsonTracksReady = createSelector(\n  getGeojsonTracks,\n  (tracks) => tracks.filter((t) => t.data !== undefined)\n)\n\nconst mergeStyles = (style1, style2) => ({\n  sources: { ...style1.sources, ...style2.sources },\n  layers: [...style1.layers, ...style2.layers],\n})\n\nconst filterGeojsonByTimerange = (geojson, { start, end }) => {\n  if (!geojson || !geojson.features) return null\n  const featuresFiltered = geojson.features.reduce((filteredFeatures, feature) => {\n    const hasTimes =\n      feature.properties.coordinateProperties.times &&\n      feature.properties.coordinateProperties.times.length > 0\n    if (hasTimes) {\n      const filtered = feature.geometry.coordinates.reduce(\n        (filteredCoordinates, coordinate, index) => {\n          const timeCoordinate = feature.properties.coordinateProperties.times[index]\n          const isInTimeline = timeCoordinate >= start && timeCoordinate <= end\n          if (isInTimeline) {\n            filteredCoordinates.coordinates.push(coordinate)\n            filteredCoordinates.times.push(timeCoordinate)\n          }\n          return filteredCoordinates\n        },\n        { coordinates: [], times: [] }\n      )\n      if (!filtered.coordinates.length) return filteredFeatures\n\n      const filteredFeature = {\n        ...feature,\n        geometry: {\n          ...feature.geometry,\n          coordinates: filtered.coordinates,\n        },\n        properties: {\n          ...feature.properties,\n          coordinateProperties: {\n            times: filtered.times,\n          },\n        },\n      }\n      filteredFeatures.push(filteredFeature)\n    }\n    return filteredFeatures\n  }, [])\n  const geojsonFiltered = {\n    ...geojson,\n    features: featuresFiltered,\n  }\n  return geojsonFiltered\n}\n\nconst getFullTracksStyles = createSelector(\n  [getTemporalExtent, getGeojsonTracksReady],\n  (temporalExtent, tracks) => {\n    const hasTemporalExtent = temporalExtent && temporalExtent.length > 0\n    const hasTracks = tracks && tracks.length > 0\n    if (!hasTemporalExtent || !hasTracks) return null\n\n    const timerange = {\n      start: temporalExtent[0].getTime(),\n      end: temporalExtent[1].getTime(),\n    }\n    const styles = tracks.reduce(\n      (acc, track) => {\n        if (!track.data) return acc\n\n        const source = `${track.id}Track`\n        const style = {\n          sources: {\n            [source]: {\n              type: 'geojson',\n              data: filterGeojsonByTimerange(track.data, timerange),\n            },\n          },\n          layers: [\n            {\n              id: `${track.id}Lines`,\n              source,\n              type: 'line',\n              paint: {\n                'line-width': 1,\n                'line-color': track.color,\n              },\n            },\n            {\n              id: `${track.id}Points`,\n              source,\n              type: 'circle',\n              filter: ['match', ['geometry-type'], ['', 'Point'], true, false],\n              paint: {\n                'circle-radius': 4,\n                'circle-color': track.color,\n              },\n            },\n          ],\n        }\n        return mergeStyles(acc, style)\n      },\n      { sources: {}, layers: [] }\n    )\n    return styles\n  }\n)\n\nconst getHighlightedTrackStyles = createSelector(\n  [getHighlightTemporalExtent, getGeojsonTracksReady],\n  (highlightTemporalExtent, tracks) => {\n    const hasTemporalExtent = highlightTemporalExtent && highlightTemporalExtent.length > 0\n    const hasTracks = tracks && tracks.length > 0\n    if (!hasTemporalExtent || !hasTracks) return null\n\n    const timerange = {\n      start: highlightTemporalExtent[0].getTime(),\n      end: highlightTemporalExtent[1].getTime(),\n    }\n    const styles = tracks.reduce(\n      (acc, track) => {\n        if (!track.data) return acc\n\n        const source = `${track.id}HighlightedTrack`\n        const style = {\n          sources: {\n            [source]: {\n              type: 'geojson',\n              data: filterGeojsonByTimerange(track.data, timerange),\n            },\n          },\n          layers: [\n            {\n              id: `${track.id}HighlightedLines`,\n              source,\n              type: 'line',\n              paint: {\n                'line-width': 1,\n                'line-color': '#fff',\n              },\n            },\n          ],\n        }\n        return mergeStyles(acc, style)\n      },\n      { sources: {}, layers: [] }\n    )\n    return styles\n  }\n)\n\nexport const getTracksStyles = createSelector(\n  [getFullTracksStyles, getHighlightedTrackStyles],\n  (trackStyles, highlightedTrackStyles) => {\n    if (!highlightedTrackStyles) return trackStyles\n    return mergeStyles(trackStyles, highlightedTrackStyles)\n  }\n)\n","export const GL_TRANSPARENT = 'rgba(0,0,0,0)'\n\nexport const TRANSITION_TYPE = {\n  ZOOM: 'ZOOM',\n}\n\nexport const ENCOUNTERS = 'Encounters'\n\nexport const BRUSH_RENDERING_STYLE = {\n  NORMAL: 0,\n  BULLSEYE: 2,\n}\n\nexport const BRUSH_ZOOM_RENDERING_STYLE = {\n  RADIAL_GRADIENT: 0,\n  CIRCLE: 1,\n}\n\nexport const POLYGON_LAYERS_AREA = 'POLYGON_LAYERS_AREA'\n\nexport const CUSTOM_LAYERS_SUBTYPES = {\n  geojson: 'geojson',\n  raster: 'raster',\n}\n","import Pbf from 'pbf'\nimport { VectorTile } from '@mapbox/vector-tile'\n\nexport default (tileUrl, token) => {\n  const vectorTilePromise = fetch(tileUrl, {\n    headers: token\n      ? {\n          Authorization: `Bearer ${token}`,\n        }\n      : {},\n  })\n    .then((response) => {\n      if (!response.ok) {\n        throw new Error(`could not load tile ${tileUrl}`)\n      }\n      return response.blob().then((blob) => {\n        const reader = new FileReader()\n        return new Promise((resolve) => {\n          reader.addEventListener('loadend', () => {\n            // reader.result contains the contents of blob as a typed array\n            // blob.type === 'application/x-protobuf'\n            const pbf = new Pbf(reader.result)\n            const vectorTile = new VectorTile(pbf)\n            return resolve(vectorTile)\n          })\n          reader.readAsArrayBuffer(blob)\n        })\n      })\n    })\n    .catch((e) => {\n      console.warn(e)\n    })\n  return vectorTilePromise\n}\n","import pull from 'lodash/pull'\nimport uniq from 'lodash/uniq'\nimport sumBy from 'lodash/sumBy'\nimport { lngLatToWorld } from 'viewport-mercator-project'\nimport convert from '@globalfishingwatch/map-convert'\nimport buildEndpoint from './buildEndpoint'\nimport PelagosClient from '../lib/pelagosClient'\n\nimport getPBFTile from './getPBFTile'\n\n/**\n * Generates the URLs to load vessel track data for a tile\n *\n * @param {string} tilesetUrl       the tileset base URL\n * @param {array} temporalExtents   all tileset temporal extents\n * @param {object} params           - seriesgroup: a seriesgroup id, used for tracks loading\n *                                  - tileCoordinates: this tiles tile coordinates (zoom, x, y). Will default to 0,0,0\n *                                  - temporalExtentsIndices: restrict to these temporalExtents indices\n * @returns {Array}                 an array of URLs for this tile\n */\nconst getTemporalTileURLs = (urlTemplate, temporalExtents, params) => {\n  const urls = []\n\n  ;(temporalExtents || [null]).forEach((extent, index) => {\n    const urlParams = {\n      id: params.seriesgroup,\n    }\n    if (extent !== null && params.temporalExtentsLess !== true) {\n      urlParams.startTimeISO = new Date(extent[0]).toISOString()\n      urlParams.endTimeISO = new Date(extent[1]).toISOString()\n    }\n    if (params.tileCoordinates) {\n      urlParams.x = params.tileCoordinates.x\n      urlParams.y = params.tileCoordinates.y\n      urlParams.z = params.tileCoordinates.zoom\n    }\n\n    const url = buildEndpoint(urlTemplate, urlParams)\n\n    if (\n      params.temporalExtentsLess === true ||\n      !params.temporalExtentsIndices ||\n      params.temporalExtentsIndices.indexOf(index) > -1\n    ) {\n      urls.push(url)\n    }\n  })\n  return urls\n}\n\n/**\n * See getTemporalTileURLs.\n */\nexport const getTilePromises = (tilesetUrl, token, temporalExtents, params) => {\n  const promises = []\n  const urls = getTemporalTileURLs(tilesetUrl, temporalExtents, params)\n  for (let urlIndex = 0, length = urls.length; urlIndex < length; urlIndex++) {\n    if (params.isPBF === true) {\n      promises.push(getPBFTile(urls[urlIndex], token))\n    } else {\n      promises.push(new PelagosClient().obtainTile(urls[urlIndex], token))\n    }\n  }\n\n  return promises\n}\n\nexport const getCleanVectorArrays = (rawTileData) =>\n  rawTileData.filter((vectorArray) => vectorArray !== null)\n\n/**\n * As data will come in multiple arrays (1 per API query/year basically), they need to be merged here\n *\n * @param cleanVectorArrays an array of objects containing a Float32Array for each vessel param (lat, lon, weight...)\n * @param columns the keys to pick on the vectorArrays (lat, lon, weight, etc)\n * @returns an object containing a Float32Array for each API_RETURNED_KEY (lat, lon, weight, etc)\n */\nexport const groupData = (cleanVectorArrays, columns) => {\n  const data = {}\n\n  const totalVectorArraysLength = sumBy(cleanVectorArrays, (a) => a.longitude.length)\n\n  const filteredColumns = columns.filter((column) => {\n    if (cleanVectorArrays[0] && cleanVectorArrays[0][column] === undefined) {\n      console.warn(`column ${column} is present in layerHeader.colsByName but not in tile data`)\n      return false\n    }\n    return true\n  })\n\n  filteredColumns.forEach((key) => {\n    data[key] = new Float32Array(totalVectorArraysLength)\n  })\n\n  let currentArray\n  let cumulatedOffsets = 0\n\n  const appendValues = (key) => {\n    data[key].set(currentArray[key], cumulatedOffsets)\n  }\n\n  for (let index = 0, length = cleanVectorArrays.length; index < length; index++) {\n    currentArray = cleanVectorArrays[index]\n    filteredColumns.forEach(appendValues)\n    cumulatedOffsets += currentArray.longitude.length\n  }\n  return data\n}\n\n/**\n * Converts Vector Array data to Playback format and stores it locally.\n * The data structure is an array indexed by a time unit, ie a set of points every day\n * This preprocessing step allows playback to play smoothly as the necessary conversions and data structure set up\n * is done once (after tile has been loaded)\n *\n * @param data the source data before indexing by day, an object containing\n *  - a vector (Float32Array) for each header's column in the case of Pelagos tiles\n *  - an array of points int the case of PBF tiles\n * @param colsByName the columns present on the dataset, determined by tileset headers\n * @param tileCoordinates x, y, z\n * @param isPBF bool whether data is a PBF vector tile (true) or a Pelagos tile (false)\n * @param prevPlaybackData an optional previously loaded tilePlaybackData array (when adding time range)\n */\nexport const getTilePlaybackData = (data, colsByName, tileCoordinates, isPBF, prevPlaybackData) => {\n  const tilePlaybackData = prevPlaybackData === undefined ? [] : prevPlaybackData\n\n  const zoom = tileCoordinates.zoom\n  const zoomFactorRadius = convert.getZoomFactorRadius(zoom)\n  const zoomFactorRadiusRenderingMode = convert.getZoomFactorRadiusRenderingMode(zoom)\n  const zoomFactorOpacity = convert.getZoomFactorOpacity(zoom)\n\n  // store all available columns as object keys\n  const columns = {}\n  const columnsArr = Object.keys(colsByName)\n  columnsArr.forEach((c) => {\n    columns[c] = true\n  })\n\n  // columns specified by layer header columns\n  let storedColumns = [].concat(columnsArr)\n  if (columns.sigma === true) storedColumns.push('radius')\n  if (columns.weight === true) storedColumns.push('opacity')\n  if (columns.longitude === true) {\n    storedColumns.push('worldX')\n    storedColumns.push('worldY')\n  }\n  if (columns.id === true) {\n    storedColumns.push('series')\n  }\n\n  // omit values that will be transformed before being stored to playback data (ie lat -> worldY)\n  // only if hidden: true flag is set on header\n  ;['latitude', 'longitude', 'datetime'].forEach((col) => {\n    if (colsByName[col] === undefined || colsByName[col].hidden === true) {\n      pull(storedColumns, col)\n    }\n  })\n  // always pull sigma and weight\n  pull(storedColumns, 'sigma', 'weight')\n  storedColumns = uniq(storedColumns)\n\n  const numPoints = isPBF === true ? data.length : data.latitude.length\n\n  for (let index = 0, length = numPoints; index < length; index++) {\n    let point\n    if (isPBF === true) {\n      const feature = data.feature(index)\n      point = feature.properties\n      // WARNING: toGeoJSON is expensive. Avoid using raw coordinates in PBF tiles, pregenerate world coords\n      // FIXME: this should not be done when headers declare worldX/Y -  if (!columns.worldX) {\n      const geom = feature.toGeoJSON(tileCoordinates.x, tileCoordinates.y, zoom).geometry\n        .coordinates\n      point.longitude = geom[0]\n      point.latitude = geom[1]\n    } else {\n      point = {}\n      columnsArr.forEach((c) => {\n        point[c] = data[c][index]\n      })\n    }\n\n    const timeIndex = columns.timeIndex\n      ? point.timeIndex\n      : convert.getOffsetedTimeAtPrecision(point.datetime)\n\n    // FIXME: this should not be done when headers declare worldX/Y -  if (!columns.worldX) {\n    const [worldX, worldY] = lngLatToWorld([point.longitude, point.latitude], 1)\n    point.worldX = worldX\n    point.worldY = worldY\n\n    if (columns.sigma) {\n      point.radius = convert.sigmaToRadius(\n        point.sigma,\n        zoomFactorRadiusRenderingMode,\n        zoomFactorRadius\n      )\n    }\n    if (columns.weight) {\n      point.opacity = convert.weightToOpacity(point.weight, zoomFactorOpacity)\n    }\n    if (columns.id) {\n      point.series = point.id\n    }\n\n    if (!tilePlaybackData[timeIndex]) {\n      const frame = {}\n      storedColumns.forEach((column) => {\n        frame[column] = [point[column]]\n      })\n      tilePlaybackData[timeIndex] = frame\n      continue\n    }\n    const frame = tilePlaybackData[timeIndex]\n    storedColumns.forEach((column) => {\n      frame[column].push(point[column])\n    })\n  }\n  return tilePlaybackData\n}\n\nexport const addTracksPointsRenderingData = (data) => {\n  data.hasFishing = []\n  data.worldX = []\n  data.worldY = []\n\n  for (let index = 0, length = data.weight.length; index < length; index++) {\n    const [worldX, worldY] = lngLatToWorld([data.longitude[index], data.latitude[index]], 1)\n    data.worldX[index] = worldX\n    data.worldY[index] = worldY\n    data.hasFishing[index] = data.weight[index] > 0\n  }\n  return data\n}\n\n/**\n * A simplified version of getTilePlaybackData for tracks\n * Converts Vector Array data to Playback format (organized by days) and stores it locally\n * @param vectorArray the source data before indexing by day\n */\nexport const getTracksPlaybackData = (vectorArray) => {\n  const playbackData = []\n\n  for (let index = 0, length = vectorArray.series.length; index < length; index++) {\n    const datetime = vectorArray.datetime[index]\n    const timeIndex = convert.getOffsetedTimeAtPrecision(datetime)\n\n    if (!playbackData[timeIndex]) {\n      const frame = {\n        worldX: [vectorArray.worldX[index]],\n        worldY: [vectorArray.worldY[index]],\n        series: [vectorArray.series[index]],\n        hasFishing: [vectorArray.hasFishing[index]],\n      }\n      playbackData[timeIndex] = frame\n      continue\n    }\n    const frame = playbackData[timeIndex]\n    frame.worldX.push(vectorArray.worldX[index])\n    frame.worldY.push(vectorArray.worldY[index])\n    frame.series.push(vectorArray.series[index])\n    frame.hasFishing.push(vectorArray.hasFishing[index])\n  }\n  return playbackData\n}\n\nexport const vesselSatisfiesFilters = (frame, index, filterValues) => {\n  const satisfiesFilters = Object.keys(filterValues).every((field) => {\n    if (frame[field] === undefined) {\n      // this field is not available on this layer. This can happen in an edge case described\n      // here: https://github.com/GlobalFishingWatch/map-client/issues/661#issuecomment-334496469\n      return false\n    }\n    return filterValues[field].indexOf(frame[field][index]) > -1\n  })\n  return satisfiesFilters\n}\n\nconst vesselSatisfiesAllFilters = (frame, index, filters) => {\n  const satisfiesAllFilters = filters\n    .filter((f) => f.pass !== true)\n    .some((filter) => vesselSatisfiesFilters(frame, index, filter.filterValues))\n  return satisfiesAllFilters\n}\n\nexport const selectVesselsAt = (tileData, tileQuery, startIndex, endIndex, currentFilters) => {\n  const vessels = []\n\n  const { worldX, worldY, toleranceRadiusInWorldUnits } = tileQuery\n\n  for (let f = startIndex; f < endIndex; f++) {\n    const frame = tileData[f]\n    if (frame === undefined) continue\n    for (let i = 0; i < frame.worldX.length; i++) {\n      const wx = frame.worldX[i]\n      const wy = frame.worldY[i]\n\n      if (\n        (!currentFilters.length || vesselSatisfiesAllFilters(frame, i, currentFilters)) &&\n        wx >= worldX - toleranceRadiusInWorldUnits &&\n        wx <= worldX + toleranceRadiusInWorldUnits &&\n        wy >= worldY - toleranceRadiusInWorldUnits &&\n        wy <= worldY + toleranceRadiusInWorldUnits\n      ) {\n        const vessel = {}\n\n        Object.keys(frame).forEach((key) => {\n          vessel[key] = frame[key][i]\n        })\n        vessels.push(vessel)\n      }\n    }\n  }\n  return vessels\n}\n\n/*\nexport const getHistogram = (tiles, propName = 'weight') => {\n  let data = tiles\n    .filter(tile => tile.ready)\n    .map(tile => tile.data\n      .map(frame => frame[propName]));\n  data = flattenDeep(data);\n  if (data.length) {\n    const bins = d3.histogram().thresholds(d3.thresholdScott)(data);\n    const x = d3.scaleLinear().domain([0, d3.max(bins, d => d.length)]).range([0, 50]);\n    console.table(bins.filter(bin => bin.length).map((bin) => {\n      const binMin = d3.min(bin).toLocaleString({ maximumFractionDigits: 2 });\n      const binMax = d3.max(bin).toLocaleString({ maximumFractionDigits: 2 });\n      return {\n        range: [binMin, binMax].join('﹣'),\n        bars: Array(Math.round(x(bin.length))).join('█'),\n        num: bin.length\n      };\n    }));\n  }\n};\n*/\n","import template from 'lodash/template'\nimport templateSettings from 'lodash/templateSettings'\n\nexport default (urlTemplate, urlParams) => {\n  templateSettings.interpolate = /{{([\\s\\S]+?)}}/g\n  const urlTemplateCompiled = template(urlTemplate)\n  return urlTemplateCompiled(urlParams)\n}\n","import tilecover from '@mapbox/tile-cover/index'\nimport debounce from 'lodash/debounce'\nimport { PerspectiveMercatorViewport } from 'viewport-mercator-project'\nimport { ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING, TILES_LOAD_ZOOM_OFFSET } from '../config'\nimport {\n  getTile,\n  releaseTiles,\n  highlightVesselFromHeatmap,\n  updateLoadedTiles,\n} from './heatmap.actions'\n\nexport const SET_CURRENTLY_VISIBLE_TILES = 'SET_CURRENTLY_VISIBLE_TILES'\nexport const SET_CURRENTLY_LOADED_TILES = 'SET_CURRENTLY_LOADED_TILES'\nexport const SET_CURRENTLY_SWAPPED_TILE_UIDS = 'SET_CURRENTLY_SWAPPED_TILE_UIDS'\nexport const MARK_TILES_UIDS_AS_LOADED = 'MARK_TILES_UIDS_AS_LOADED'\nexport const RELEASE_MARKED_TILES_UIDS = 'RELEASE_MARKED_TILES_UIDS'\n\n// restrict tilecover to a single zoom level\n// could be customized to load less or more detailed tiles\nconst getTilecoverLimits = (viewportZoom) => {\n  let zoom = Math.ceil(viewportZoom + TILES_LOAD_ZOOM_OFFSET)\n  let tilesAvailable = true\n  if (zoom > ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING) {\n    zoom = ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING\n    tilesAvailable = false\n  }\n  return {\n    min_zoom: zoom,\n    max_zoom: zoom,\n    tilesAvailable,\n  }\n}\n\nconst flushToReleaseTiles = () => (dispatch, getState) => {\n  const state = getState()\n  const currentToLoadTileUids = state.map.heatmapTiles.currentToLoadTileUids\n  // console.log('Tiles left to load: ', currentToLoadTileUids);\n\n  // Tiles are released only when all to-load tiles have finished loading\n  // this is to ensure smooth visual transitions between zoom levels\n  if (!currentToLoadTileUids.length) {\n    const currentTilesToReleaseUids = state.map.heatmapTiles.currentToReleaseTileUids\n    // console.log('no more tiles to load, releasing ', currentTilesToReleaseUids);\n    dispatch(releaseTiles(currentTilesToReleaseUids))\n    dispatch({\n      type: RELEASE_MARKED_TILES_UIDS,\n    })\n  }\n}\n\nexport const markTileAsLoaded = (tileUids) => (dispatch) => {\n  dispatch({\n    type: MARK_TILES_UIDS_AS_LOADED,\n    payload: tileUids,\n  })\n  // console.log(tileUids, 'have finished loading');\n  dispatch(flushToReleaseTiles())\n}\n\nconst flushTileState = (forceLoadingAllVisibleTiles = false) => (dispatch, getState) => {\n  const state = getState()\n  const currentVisibleTiles = state.map.heatmapTiles.currentVisibleTiles\n  let tilesToLoad = []\n  const tilesToReleaseUids = []\n\n  if (forceLoadingAllVisibleTiles === true) {\n    tilesToLoad = currentVisibleTiles\n  } else {\n    const currentLoadedTiles = state.map.heatmapTiles.currentLoadedTiles\n\n    currentVisibleTiles.forEach((visibleTile) => {\n      if (currentLoadedTiles.find((t) => t.uid === visibleTile.uid) === undefined) {\n        tilesToLoad.push(visibleTile)\n      }\n    })\n\n    currentLoadedTiles.forEach((loadedTile) => {\n      if (currentVisibleTiles.find((t) => t.uid === loadedTile.uid) === undefined) {\n        tilesToReleaseUids.push(loadedTile.uid)\n      }\n    })\n  }\n\n  const tilesToLoadUids = tilesToLoad.map((t) => t.uid)\n  // console.log('force loading:', forceLoadingAllVisibleTiles)\n  // console.log('visible', currentVisibleTiles.map(t => t.uid))\n  // console.log('load', tilesToLoadUids)\n  // console.log('release', tilesToReleaseUids)\n  // console.log('----')\n\n  tilesToLoad.forEach((tile) => {\n    dispatch(getTile(tile))\n  })\n  dispatch({\n    type: SET_CURRENTLY_LOADED_TILES,\n    payload: currentVisibleTiles,\n  })\n\n  dispatch({\n    type: SET_CURRENTLY_SWAPPED_TILE_UIDS,\n    payload: {\n      tilesToLoadUids,\n      tilesToReleaseUids,\n    },\n  })\n\n  dispatch(updateLoadedTiles())\n  dispatch(flushToReleaseTiles())\n}\n\nconst _debouncedFlushState = (dispatch) => {\n  dispatch(flushTileState())\n}\nconst debouncedFlushState = debounce(_debouncedFlushState, 500)\n\nexport const updateHeatmapTilesFromViewport = (forceLoadingAllVisibleTiles = false) => (\n  dispatch,\n  getState\n) => {\n  // if in transition, skip loading/releasing\n  // else\n  //   collect all tiles in viewport\n  //   save them to reducer: currentVisibleTiles\n  // if not zooming: flush immediately\n  //   if forceLoadingAllVisiblelTiles\n  //     get tiles from currentVisibleTiles\n  //   else\n  //     get tiles from currentVisibleTiles\n  //     make delta with currentLoadedTiles\n  //     get tiles from delta+\n  //     release tiles from delta-\n  //   save to reducer: currentVisibleTiles -> currentLoadedTiles\n  // if zooming: debounced flush to avoid \"tile spam\"\n  const mapViewport = getState().map.viewport\n  const viewport = mapViewport.viewport\n\n  // do not allow any tile update during transitions (currently only zoom)\n  // wait for the end of the transition to look at viewport and load matching tiles\n  if (mapViewport.currentTransition !== null) {\n    return\n  }\n\n  // instanciate a viewport instance to get lat/lon from screen top left/ bottom right bounds\n  const boundsViewport = new PerspectiveMercatorViewport(viewport)\n  const bounds = [\n    boundsViewport.unproject([0, 0]),\n    boundsViewport.unproject([viewport.width, viewport.height]),\n  ]\n\n  const [wn, es] = bounds\n  const [w, s, e, n] = [wn[0], es[1], es[0], wn[1]]\n  const boundsPolygonsCoordinates = []\n\n  const limits = getTilecoverLimits(viewport.zoom)\n  if (limits.tilesAvailable === false && forceLoadingAllVisibleTiles !== true) {\n    return\n  }\n\n  if (e > 180 || w < -180) {\n    // deal with the antimeridian situation by splitting the bounds polygon into two polygons\n    const w1 = e > 180 ? w : w + 360\n    const e1 = 180 - 0.001\n    const w2 = -180\n    const e2 = e > 180 ? e - 360 : e\n    boundsPolygonsCoordinates.push([[[w1, n], [e1, n], [e1, s], [w1, s], [w1, n]]])\n    boundsPolygonsCoordinates.push([[[w2, n], [e2, n], [e2, s], [w2, s], [w2, n]]])\n  } else {\n    boundsPolygonsCoordinates.push([[[w, n], [e, n], [e, s], [w, s], [w, n]]])\n  }\n\n  const geom = {\n    type: 'MultiPolygon',\n    coordinates: boundsPolygonsCoordinates,\n  }\n\n  // using tilecover, get xyz tile coords as well as quadkey indexes (named uid through the app)\n  const viewportTilesCoords = tilecover.tiles(geom, limits)\n  const viewportTilesIndexes = tilecover.indexes(geom, limits)\n  const visibleTiles = []\n\n  viewportTilesCoords.forEach((coords, i) => {\n    const uid = viewportTilesIndexes[i]\n    const zoom = coords[2]\n    if (zoom >= 2) {\n      visibleTiles.push({\n        tileCoordinates: {\n          x: coords[0],\n          y: coords[1],\n          zoom: coords[2],\n        },\n        uid,\n      })\n    }\n  })\n\n  dispatch({\n    type: SET_CURRENTLY_VISIBLE_TILES,\n    payload: visibleTiles,\n  })\n\n  const isMouseWheelZooming = mapViewport.prevZoom !== viewport.zoom\n\n  if (isMouseWheelZooming === false) {\n    dispatch(flushTileState(forceLoadingAllVisibleTiles))\n  } else {\n    debouncedFlushState(dispatch)\n  }\n}\n\nexport const queryHeatmapVessels = (coords, temporalExtentIndexes) => (dispatch, getState) => {\n  // use tilecover to get what tile quadkey/uid \"belongs\" to the point\n  const geom = {\n    type: 'Point',\n    coordinates: [coords.longitude, coords.latitude],\n  }\n  const zoom = getState().map.viewport.viewport.zoom\n\n  // get quadkey for tile at current zoom level, but also neighbouring zoom levels,\n  // in case current zoom level tiles has not been loaded yet\n  const uids = [zoom, zoom - 1, zoom + 1]\n    .map((z) => getTilecoverLimits(z))\n    .map((limits) => tilecover.indexes(geom, limits))\n    .map((indexes) => indexes[0])\n\n  const query = {\n    ...coords,\n    uids,\n  }\n\n  // console.log(query);\n  dispatch(highlightVesselFromHeatmap(query, temporalExtentIndexes))\n}\n","import difference from 'lodash/difference'\nimport uniq from 'lodash/uniq'\nimport uniqBy from 'lodash/uniqBy'\nimport {\n  getTilePromises,\n  getCleanVectorArrays,\n  groupData,\n  getTilePlaybackData,\n  selectVesselsAt,\n} from '../utils/heatmapTileData'\nimport { ENCOUNTERS } from '../constants'\nimport { markTileAsLoaded } from './heatmapTiles.actions'\nimport { startLoader, completeLoader } from '../module/module.actions'\n\nexport const ADD_HEATMAP_LAYER = 'ADD_HEATMAP_LAYER'\nexport const UPDATE_HEATMAP_LAYER_STYLE = 'UPDATE_HEATMAP_LAYER_STYLE'\nexport const ADD_REFERENCE_TILE = 'ADD_REFERENCE_TILE'\nexport const HIGHLIGHT_VESSELS = 'HIGHLIGHT_VESSELS'\nexport const INIT_HEATMAP_LAYERS = 'INIT_HEATMAP_LAYERS'\nexport const REMOVE_HEATMAP_LAYER = 'REMOVE_HEATMAP_LAYER'\nexport const UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES =\n  'UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES'\nexport const UPDATE_HEATMAP_TILE = 'UPDATE_HEATMAP_TILE'\nexport const RELEASE_HEATMAP_TILES = 'RELEASE_HEATMAP_TILES'\nexport const UPDATE_LOADED_TILES = 'UPDATE_LOADED_TILES'\nexport const HIGHLIGHT_CLICKED_VESSEL = 'HIGHLIGHT_CLICKED_VESSEL'\nexport const CLEAR_HIGHLIGHT_CLICKED_VESSEL = 'CLEAR_HIGHLIGHT_CLICKED_VESSEL'\n\n/**\n * getTemporalExtentsVisibleIndices - Compares timebar outer extent with temporal extents present on the layer header\n * @param  {array} loadTemporalExtent Current timebar outer extent\n * @param  {array} layerTemporalExtents Temporal extent present on the layer's header (an array of extent arrays)\n * @return {array}                    Indices of the layer's temporal extents that should be visible\n */\nfunction getTemporalExtentsVisibleIndices(loadTemporalExtent, layerTemporalExtents) {\n  const currentExtentStart = loadTemporalExtent[0].getTime()\n  const currentExtentEnd = loadTemporalExtent[1].getTime()\n  const indices = []\n  layerTemporalExtents.forEach((temporalExtent, index) => {\n    const temporalExtentStart = temporalExtent[0]\n    const temporalExtentEnd = temporalExtent[1]\n    if (temporalExtentEnd >= currentExtentStart && temporalExtentStart <= currentExtentEnd) {\n      indices.push(index)\n    }\n  })\n  return indices\n}\n\n/**\n * loadLayerTile - loads an heatmap tile.\n *\n * @param  {string} layerId              layer id\n * @param  {object} tileCoordinates      tile coordinates from reference tile\n * @param  {string} token                the user's token\n * @param  {array} temporalExtentsIndices which of the temporal extents from  temporalExtents should be loaded\n * @param  {string} urls                 tile endpoints provided by header\n * @param  {array} temporalExtents       all of the layer's header temporal extents\n * @param  {bool} temporalExtentsLess    true = don't try to load different tiles based on current time extent\n * @param  {bool} isPBF                  true = read tile as MVT + PBF tile, rather than using Pelagos client\n * @return {Promise}                     a Promise that will be resolved when tile is loaded\n */\nfunction loadLayerTile(\n  layerId,\n  tileCoordinates,\n  token,\n  temporalExtentsIndices,\n  { url, temporalExtents, temporalExtentsLess, isPBF }\n) {\n  // console.log('loadLayerTile', layerId, tileCoordinates, temporalExtentsIndices)\n  if (url === undefined) {\n    throw new Error('URL/endpoints object is not available on this tilesets header')\n  }\n  const pelagosPromises = getTilePromises(url, token, temporalExtents, {\n    tileCoordinates,\n    temporalExtentsIndices,\n    temporalExtentsLess,\n    isPBF,\n  })\n  const allLayerPromises = Promise.all(pelagosPromises)\n\n  const layerTilePromise = new Promise((resolve) => {\n    allLayerPromises.then((rawTileData) => {\n      resolve({\n        loadedLayerId: layerId,\n        rawTileData,\n      })\n    })\n  })\n\n  return layerTilePromise\n}\n\n/**\n * parseLayerTile - parses an heatmap tile to a playback-ready format.\n *\n * @param  {Object} rawTileData          the raw tile data, loaded either from the pelagos client or as a MVT/PBF vector tile\n * @param  {array} colsByName            names of the columns present in the raw tiles that need to be included in the final playback data\n * @param  {object} tileCoordinates      tile coordinates from reference tile\n * @param  {array} prevPlaybackData      (optional) in case some time extent was already loaded for this tile, append to this data\n * @return {Object}                      playback-ready merged data\n */\nfunction parseLayerTile(rawTileData, colsByName, isPBF, tileCoordinates, prevPlaybackData) {\n  let data\n  if (isPBF === true) {\n    if (\n      rawTileData === undefined ||\n      !rawTileData.length ||\n      rawTileData[0] === undefined ||\n      !Object.keys(rawTileData[0].layers).length\n    ) {\n      return []\n    }\n    data = rawTileData[0].layers.points\n  } else {\n    const cleanVectorArrays = getCleanVectorArrays(rawTileData)\n    data = groupData(cleanVectorArrays, Object.keys(colsByName))\n    if (Object.keys(data).length === 0) {\n      return []\n    }\n  }\n  const playbackData = getTilePlaybackData(\n    data,\n    colsByName,\n    tileCoordinates,\n    isPBF,\n    prevPlaybackData\n  )\n  return playbackData\n}\n\n/**\n * getTiles - loads a bunch of heatmap tiles\n * @param  {array} layerIds                 list of layer Ids that need to be loaded for this/these tiles\n * @param  {array} referenceTiles           list of reference tiles (tile data regardless of layer) that need to be loaded\n * @param  {object} newTemporalExtentsToLoad (optional) a dict (layerId is the key) of temporal extents\n * indices that should be appended to existing data\n */\nfunction getTiles(layerIds, referenceTiles, newTemporalExtentsToLoad = undefined) {\n  return (dispatch, getState) => {\n    const state = getState()\n    const loaderID = startLoader(dispatch, state)\n    const token = state.map.module.token\n    const heatmapLayers = state.map.heatmap.heatmapLayers\n    const tilesByLayer = {}\n    layerIds.forEach((id) => {\n      tilesByLayer[id] = [...heatmapLayers[id].tiles]\n    })\n    const allPromises = []\n\n    layerIds.forEach((layerId) => {\n      const heatmapLayerHeader = heatmapLayers[layerId].header\n      const { temporalExtents, temporalExtentsLess, isPBF, colsByName } = { ...heatmapLayerHeader }\n      const url = heatmapLayerHeader.endpoints.tiles\n\n      referenceTiles.forEach((referenceTile) => {\n        // check if tile does not already exist first\n        let tile = tilesByLayer[layerId].find((t) => t.uid === referenceTile.uid)\n        if (!tile) {\n          // console.log('create tile ', referenceTile.uid)\n          tile = {\n            uid: referenceTile.uid,\n            temporalExtentsIndicesLoaded: [],\n          }\n          tilesByLayer[layerId].push(tile)\n        } else {\n          // console.log('found tile', referenceTile.uid)\n        }\n\n        const queriedTemporalExtentsIndices =\n          newTemporalExtentsToLoad === undefined\n            ? heatmapLayers[layerId].visibleTemporalExtentsIndices\n            : newTemporalExtentsToLoad[layerId]\n\n        const temporalExtentsIndicesToLoad = difference(\n          queriedTemporalExtentsIndices,\n          tile.temporalExtentsIndicesLoaded\n        )\n\n        const tilePromise = loadLayerTile(\n          layerId,\n          referenceTile.tileCoordinates,\n          token,\n          temporalExtentsIndicesToLoad,\n          {\n            url,\n            temporalExtents,\n            temporalExtentsLess,\n            isPBF,\n          }\n        )\n\n        allPromises.push(tilePromise)\n\n        tilePromise.then(({ loadedLayerId, rawTileData }) => {\n          tile.temporalExtentsIndicesLoaded = uniq(\n            tile.temporalExtentsIndicesLoaded.concat(temporalExtentsIndicesToLoad)\n          )\n          tile.data = parseLayerTile(\n            rawTileData,\n            colsByName,\n            isPBF,\n            referenceTile.tileCoordinates,\n            tile.data\n          )\n\n          dispatch({\n            type: UPDATE_HEATMAP_TILE,\n            payload: {\n              layerId: loadedLayerId,\n              tile,\n            },\n          })\n        })\n      })\n    })\n\n    Promise.all(allPromises).then(() => {\n      dispatch(completeLoader(loaderID))\n      dispatch(markTileAsLoaded(referenceTiles.map((tile) => tile.uid)))\n    })\n  }\n}\n\n/**\n * getTile - This action is emitted when a new tile is queried from panning or zooming the map\n * This will load a tile for all currently visible heatmap layers\n *\n * @param  {object} referenceTile a reference tile containing xyz coords and uid\n */\nexport function getTile(referenceTile) {\n  return (dispatch, getState) => {\n    dispatch({\n      type: ADD_REFERENCE_TILE,\n      payload: referenceTile,\n    })\n    const visibleHeatmapLayers = getState().map.heatmap.heatmapLayers\n    const visibleHeatmapLayersIds = Object.keys(visibleHeatmapLayers).filter(\n      (id) => visibleHeatmapLayers[id].visible === true\n    )\n\n    if (visibleHeatmapLayersIds.length) {\n      dispatch(getTiles(visibleHeatmapLayersIds, [referenceTile]))\n    }\n  }\n}\n\n/**\n * releaseTiles - This action is emitted when an existing tile is removed from panning or zooming the map\n * @param  {array} uids tile ref uids to release\n */\nexport const releaseTiles = (uids) => ({\n  type: RELEASE_HEATMAP_TILES,\n  payload: uids,\n})\n\nexport const updateLoadedTiles = () => ({\n  type: UPDATE_LOADED_TILES,\n})\n\n// triggered when a layer is added or set to visible\nfunction loadAllTilesForLayer(layerId) {\n  return (dispatch, getState) => {\n    //                current layer, all reference tiles\n    const referenceTiles = getState().map.heatmap.referenceTiles\n    dispatch(getTiles([layerId], referenceTiles))\n  }\n}\n\nexport const addHeatmapLayer = (layer, loadTemporalExtent) => (dispatch) => {\n  const layerTemporalExtents = layer.header.temporalExtents\n  dispatch({\n    type: ADD_HEATMAP_LAYER,\n    payload: {\n      ...layer,\n      // initially attach which of the temporal extents indices are visible with initial outerExtent\n      visibleTemporalExtentsIndices: getTemporalExtentsVisibleIndices(\n        loadTemporalExtent,\n        layerTemporalExtents\n      ),\n    },\n  })\n\n  if (layer.visible === true) {\n    dispatch(loadAllTilesForLayer(layer.id))\n  }\n}\n\nexport const removeHeatmapLayer = (id) => (dispatch) => {\n  dispatch({\n    type: REMOVE_HEATMAP_LAYER,\n    payload: {\n      id,\n    },\n  })\n}\n\n/**\n * updateLayerLoadTemporalExtents - when outer time extent changes, checks if more tiles needs to be loaded\n * by comparing the outer time range with the temporalExtent already loaded on each layer.\n * @param  {array} loadTemporalExtent Current app-wide extent of tiles that need to load, expressed\n * as an array of two dates\n */\nexport function updateLayerLoadTemporalExtents(loadTemporalExtent) {\n  return (dispatch, getState) => {\n    const state = getState()\n    const heatmapLayers = state.map.heatmap.heatmapLayers\n    const indicesToAddByLayer = {}\n    Object.keys(heatmapLayers).forEach((layerId) => {\n      const heatmapLayer = heatmapLayers[layerId]\n      const temporalExtents = heatmapLayer.header.temporalExtents\n      const oldVisibleTemporalExtentsIndices = heatmapLayer.visibleTemporalExtentsIndices\n      const newVisibleTemporalExtentsIndices = getTemporalExtentsVisibleIndices(\n        loadTemporalExtent,\n        temporalExtents\n      )\n      const indicesAdded = difference(\n        newVisibleTemporalExtentsIndices,\n        oldVisibleTemporalExtentsIndices\n      )\n\n      if (indicesAdded.length) {\n        // add new loaded indices to heatmap layer if applicable\n        indicesToAddByLayer[layerId] = indicesAdded\n        dispatch({\n          type: UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES,\n          payload: {\n            layerId,\n            indicesAdded,\n          },\n        })\n      }\n    })\n\n    // getTiles with indices diff\n    const layerIdsWithIndicesToAdd = Object.keys(indicesToAddByLayer)\n    if (layerIdsWithIndicesToAdd.length) {\n      dispatch(\n        getTiles(layerIdsWithIndicesToAdd, state.map.heatmap.referenceTiles, indicesToAddByLayer)\n      )\n    }\n  }\n}\n\n/**\n * Returns clusters or vessels data from a tileQuery\n * @param {object} state - the application state\n * @param {string} tileQuery - the id of a heatmap layer\n * @return {object} { isEmpty, isCluster, isMouseCluster, foundVessels, layerId, tilesetId }\n */\nconst _queryHeatmap = (state, tileQuery, temporalExtentIndexes) => {\n  const layers = state.map.heatmap.heatmapLayers\n  const startIndex = temporalExtentIndexes[0]\n  const endIndex = temporalExtentIndexes[1]\n  const layersVessels = []\n\n  Object.keys(layers).forEach((layerId) => {\n    const layer = layers[layerId]\n    const allPossibleTilesByPreference = tileQuery.uids.map((uid) =>\n      layer.tiles.find((tile) => tile.uid === uid)\n    )\n    const availableTiles = allPossibleTilesByPreference.filter(\n      (tile) => tile !== undefined && tile.data !== undefined\n    )\n\n    const currentFilters = layer.filters\n    if (availableTiles.length) {\n      const bestTile = availableTiles[0]\n      layersVessels.push({\n        layer,\n        vessels: selectVesselsAt(bestTile.data, tileQuery, startIndex, endIndex, currentFilters),\n      })\n    }\n  })\n\n  const layersVesselsResults = layersVessels.filter(\n    (layerVessels) => layerVessels.vessels.length > 0\n  )\n\n  // it's a cluster because of aggregation on the server side\n  let isCluster\n  // its a cluster because or multiple vessels under mouse\n  let isMouseCluster\n  let isEmpty\n  let layerVesselsResult\n  let foundVessels\n\n  const hasEncounters =\n    layersVesselsResults.filter((layerVessel) => layerVessel.layer.subtype === ENCOUNTERS).length >\n    0\n\n  if (layersVesselsResults.length === 0) {\n    isEmpty = true\n  } else if (layersVesselsResults.length > 1 && !hasEncounters) {\n    // if there are points over multiple layers, consider this a cluster (ie don't select, zoom instead, or don't highlight)\n    // there's an exception if vessel selection contains an encounter, in which case it will take priority\n    isCluster = true\n  } else {\n    // if we have a hit with an encounters layer, use it in priority\n    // if not the layersVesselsResults should contain a single result\n    layerVesselsResult = hasEncounters\n      ? layersVesselsResults.find((layerVessel) => layerVessel.layer.subtype === ENCOUNTERS)\n      : layersVesselsResults[0]\n\n    // we can get multiple points with similar series and seriesgroup, in which case\n    // we should treat that as a successful vessel query, not a cluster\n    const vessels = layerVesselsResult.vessels\n\n    if (vessels.length === 0) {\n      isEmpty = true\n    } else {\n      // look up for any negatives seriesgroup (clusters on the server side)\n      const clusteredVessels = vessels.filter((v) => v.seriesgroup < 0)\n      if (clusteredVessels.length) {\n        isCluster = true\n      } else {\n        foundVessels = uniqBy(vessels, (v) => v.series)\n        isMouseCluster = foundVessels.length > 1\n      }\n    }\n  }\n\n  const layer = layerVesselsResult === undefined ? {} : layerVesselsResult.layer\n\n  return { isEmpty, isCluster, isMouseCluster, foundVessels, layer }\n}\n\nexport function clearHighlightedVessels() {\n  return {\n    type: HIGHLIGHT_VESSELS,\n    payload: {\n      isEmpty: true,\n      clickableCluster: false,\n    },\n  }\n}\n\nexport function highlightVesselFromHeatmap(tileQuery, temporalExtentIndexes) {\n  return (dispatch, getState) => {\n    const state = getState()\n    const { layer, isEmpty, isCluster, isMouseCluster, foundVessels } = _queryHeatmap(\n      state,\n      tileQuery,\n      temporalExtentIndexes\n    )\n\n    if (layer.id !== undefined || state.map.heatmap.highlightedVessels.layerId !== layer.id) {\n      dispatch({\n        type: HIGHLIGHT_VESSELS,\n        payload: {\n          layer: {\n            id: layer.id,\n            tilesetId: layer.tilesetId,\n            subtype: layer.subtype,\n            header: layer.header,\n          },\n          isEmpty,\n          clickableCluster: isCluster === true || isMouseCluster === true,\n          highlightableCluster: isCluster !== true,\n          foundVessels,\n        },\n      })\n    } else {\n      dispatch(clearHighlightedVessels())\n    }\n  }\n}\n\nexport const highlightClickedVessel = (seriesgroup, layerId) => ({\n  type: HIGHLIGHT_CLICKED_VESSEL,\n  payload: {\n    seriesgroup,\n    layerId,\n  },\n})\n\nexport const clearHighlightedClickedVessel = () => ({\n  type: CLEAR_HIGHLIGHT_CLICKED_VESSEL,\n})\n\nexport const updateHeatmapLayers = (newLayers, currentLoadTemporalExtent) => (\n  dispatch,\n  getState\n) => {\n  const prevLayersDict = getState().map.heatmap.heatmapLayers\n\n  // add and update layers\n  newLayers.forEach((newLayer) => {\n    const layerId = newLayer.id\n    const prevLayer = prevLayersDict[layerId]\n    if (prevLayer === undefined) {\n      // console.log('adding', layerId)\n      dispatch(addHeatmapLayer(newLayer, currentLoadTemporalExtent))\n    } else {\n      if (prevLayer.visible !== newLayer.visible && newLayer.visible === true) {\n        dispatch(loadAllTilesForLayer(layerId))\n      }\n      if (\n        prevLayer.visible !== newLayer.visible ||\n        prevLayer.hue !== newLayer.hue ||\n        prevLayer.opacity !== newLayer.opacity ||\n        prevLayer.filters !== newLayer.filters ||\n        prevLayer.interactive !== newLayer.interactive\n      ) {\n        // console.log('updating', layerId, ' with visibilty', newLayer.visible)\n        dispatch({\n          type: UPDATE_HEATMAP_LAYER_STYLE,\n          payload: {\n            id: newLayer.id,\n            visible: newLayer.visible,\n            hue: newLayer.hue,\n            opacity: newLayer.opacity,\n            filters: newLayer.filters,\n            interactive: newLayer.interactive,\n          },\n        })\n      }\n    }\n  })\n\n  // clean up unused layers\n  Object.keys(prevLayersDict).forEach((prevLayerId) => {\n    if (!newLayers.find((l) => l.id === prevLayerId)) {\n      dispatch(removeHeatmapLayer(prevLayerId))\n    }\n  })\n}\n","import { fitBounds, pixelsToWorld } from 'viewport-mercator-project'\nimport { updateHeatmapTilesFromViewport } from '../heatmap/heatmapTiles.actions'\nimport { onViewportChange } from '../module/module.actions'\nimport { CLUSTER_CLICK_ZOOM_INCREMENT } from '../config' // TODO MAP MODULE\n\nexport const SET_VIEWPORT = 'SET_VIEWPORT'\nexport const UPDATE_VIEWPORT = 'UPDATE_VIEWPORT'\nexport const SET_ZOOM_INCREMENT = 'SET_ZOOM_INCREMENT'\nexport const SET_MOUSE_LAT_LONG = 'SET_MOUSE_LAT_LONG'\nexport const TRANSITION_END = 'TRANSITION_END'\nexport const SET_NATIVE_VIEWPORT = 'SET_NATIVE_VIEWPORT'\n\nexport const setViewport = (viewport) => (dispatch) => {\n  dispatch({\n    type: SET_VIEWPORT,\n    payload: viewport,\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  dispatch(onViewportChange())\n}\n\nexport const updateViewport = (viewportUpdate) => (dispatch) => {\n  dispatch({\n    type: UPDATE_VIEWPORT,\n    payload: viewportUpdate,\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  dispatch(onViewportChange())\n}\n\nconst transitionTo = (increment, latitude = null, longitude = null, zoom = null) => (dispatch) => {\n  dispatch({\n    type: SET_ZOOM_INCREMENT,\n    payload: {\n      increment,\n      latitude,\n      longitude,\n      zoom,\n    },\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  dispatch(onViewportChange())\n}\n\nexport const transitionToZoom = (zoom) => (dispatch) => {\n  dispatch(transitionTo(null, null, null, zoom))\n}\n\nexport const transitionEnd = () => (dispatch) => {\n  dispatch({\n    type: TRANSITION_END,\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  dispatch(onViewportChange())\n}\n\nexport const zoomIntoVesselCenter = (latitude, longitude) => (dispatch) => {\n  dispatch(transitionTo(CLUSTER_CLICK_ZOOM_INCREMENT, latitude, longitude))\n}\n\nexport const fitToBounds = (bounds) => (dispatch, getState) => {\n  const state = getState()\n  const vp = fitBounds({\n    bounds: [[bounds.minLng, bounds.minLat], [bounds.maxLng, bounds.maxLat]],\n    width: state.map.viewport.viewport.width,\n    height: state.map.viewport.viewport.height,\n    padding: 50,\n  })\n  dispatch(transitionTo(null, vp.latitude, vp.longitude, vp.zoom))\n}\n\nexport const exportNativeViewport = (nativeViewport) => (dispatch) => {\n  const topLeftPx = [0, 0]\n  const bottomRightPx = [nativeViewport.width, nativeViewport.height]\n\n  // compute left and right offsets to deal with antimeridian issue\n  const topLeftWorld = pixelsToWorld(topLeftPx, nativeViewport.pixelUnprojectionMatrix)\n  const bottomRightWorld = pixelsToWorld(bottomRightPx, nativeViewport.pixelUnprojectionMatrix)\n  const leftWorldScaled = topLeftWorld[0] / nativeViewport.scale\n  const rightWorldScaled = bottomRightWorld[0] / nativeViewport.scale\n\n  // lat/lon corners for miniglobe\n  const northWest = nativeViewport.unproject(topLeftPx)\n  const southEast = nativeViewport.unproject(bottomRightPx)\n  const bounds = {\n    north: northWest[1],\n    south: southEast[1],\n    west: northWest[0],\n    east: southEast[0],\n  }\n\n  dispatch({\n    type: SET_NATIVE_VIEWPORT,\n    payload: {\n      leftWorldScaled,\n      rightWorldScaled,\n      bounds,\n    },\n  })\n}\n","import area from '@turf/area'\nimport { POLYGON_LAYERS_AREA } from '../constants'\nimport { clearHighlightedVessels, clearHighlightedClickedVessel } from '../heatmap/heatmap.actions'\nimport { zoomIntoVesselCenter } from './viewport.actions'\n\nexport const SET_POPUP = 'SET_POPUP'\nexport const CLEAR_POPUP = 'CLEAR_POPUP'\nexport const SET_MAP_CURSOR = 'SET_MAP_CURSOR'\nexport const UPDATE_POPUP_REPORT_STATUS = 'UPDATE_POPUP_REPORT_STATUS'\n\nconst getFeatureMetaFields = (staticLayerId, state, feature) => {\n  const source = state.style.mapStyle.toJS().sources[staticLayerId]\n  if (source === undefined) {\n    console.warn('Couldnt find source when looking for fields of layer', staticLayerId)\n  }\n  if (source.type !== 'geojson') {\n    if (source.metadata === undefined || source.metadata['gfw:popups'] === undefined) {\n      return null\n    }\n    return source.metadata['gfw:popups']\n  }\n  // when layer is of type geojson (custom layer), use all feature properties available\n  return Object.keys(feature.properties).length === 0\n    ? null\n    : Object.keys(feature.properties).map((key) => ({ id: key }))\n}\n\nconst getAreaKm2 = (glFeature) => {\n  const areakm2 = 10 ** -6 * area(glFeature.geometry)\n  const formatted = areakm2.toLocaleString('en-US', { maximumFractionDigits: 0 })\n  return formatted\n}\n\nconst getStaticLayerIdFromGlFeature = (glFeature) =>\n  (glFeature.layer.metadata !== undefined && glFeature.layer.metadata['gfw:id']) ||\n  glFeature.layer.source\n\nconst findFeature = (glFeatures) => {\n  if (glFeatures === undefined || !glFeatures.length) {\n    return undefined\n  }\n  for (let i = 0; i < glFeatures.length; i++) {\n    const glFeature = glFeatures[i]\n    const staticLayerId = getStaticLayerIdFromGlFeature(glFeature)\n    if (staticLayerId !== undefined) {\n      return {\n        feature: glFeature,\n        staticLayerId,\n      }\n    }\n  }\n  return undefined\n}\n\nexport const mapHover = (latitude, longitude, features, cluster) => (dispatch, getState) => {\n  const state = getState().map\n  const currentActivityLayersInteractionData = state.heatmap.highlightedVessels\n  const { layer, isEmpty, foundVessels } = currentActivityLayersInteractionData\n\n  let cursor = null\n  const event = {\n    type: null,\n  }\n\n  if (isEmpty === true) {\n    const feature = findFeature(features, null)\n    if (feature !== undefined) {\n      const popupFields = getFeatureMetaFields(feature.staticLayerId, state, feature.feature)\n      if (popupFields !== null) {\n        const properties = feature.feature.properties\n        const mainPopupField =\n          popupFields.find((f) => f.id && f.id.toLowerCase() === 'name') ||\n          popupFields.find((f) => f.id && f.id.toLowerCase() === 'id') ||\n          popupFields.find(\n            (f) =>\n              f.id &&\n              properties[f.id] !== null &&\n              properties[f.id] !== 'null' &&\n              properties[f.id] !== undefined\n          )\n        const mainPopupFieldId = mainPopupField.id\n        const featureTitle = properties[mainPopupFieldId]\n        event.type = 'static'\n        event.cluster = cluster\n        event.layer = {\n          id: feature.staticLayerId,\n        }\n        event.target = {\n          featureTitle,\n          properties,\n        }\n        cursor = 'pointer'\n      }\n    }\n  } else if (isEmpty !== true) {\n    const isCluster = foundVessels === undefined || foundVessels.length > 1\n    cursor = isCluster ? 'zoom-in' : 'pointer'\n\n    event.type = 'activity'\n    // TODO MAP MODULE sometimes layerId is undefined, likely an issue with heatmap[Tiles]\n    event.layer = layer\n    event.target = {\n      objects: foundVessels,\n      isCluster,\n    }\n  }\n\n  if (cursor !== state.interaction.cursor) {\n    dispatch({\n      type: SET_MAP_CURSOR,\n      payload: cursor,\n    })\n  }\n\n  if (state.module.onHover) {\n    state.module.onHover({\n      ...event,\n      latitude,\n      longitude,\n    })\n  }\n}\n\nexport const mapClick = (latitude, longitude, features, cluster) => (dispatch, getState) => {\n  const state = getState().map\n\n  dispatch(clearHighlightedClickedVessel())\n\n  const currentActivityLayersInteractionData = state.heatmap.highlightedVessels\n\n  const { layer, isEmpty, clickableCluster, foundVessels } = currentActivityLayersInteractionData\n\n  const event = {\n    type: null,\n  }\n\n  if (isEmpty === true) {\n    const feature = findFeature(features, null)\n    if (feature !== undefined) {\n      const metaFields = getFeatureMetaFields(feature.staticLayerId, state, feature.feature)\n      let fields\n      const properties = feature.feature.properties\n\n      if (metaFields !== null) {\n        fields = metaFields.map((metaField) => {\n          const id = metaField.id || metaField\n          const value = id === POLYGON_LAYERS_AREA ? getAreaKm2(feature.feature) : properties[id]\n          return {\n            title: metaField.label || metaField.id,\n            isLink: metaField.isLink,\n            value,\n          }\n        })\n      }\n\n      event.type = 'static'\n      event.cluster = cluster\n      event.layer = {\n        id: feature.staticLayerId,\n      }\n      event.target = {\n        fields,\n        properties,\n      }\n    }\n  } else {\n    event.type = 'activity'\n    event.layer = layer\n    if (clickableCluster === true) {\n      dispatch(zoomIntoVesselCenter(latitude, longitude))\n      dispatch(clearHighlightedVessels())\n      event.target = {\n        isCluster: true,\n      }\n    } else {\n      event.target = foundVessels[0]\n    }\n  }\n\n  if (state.module.onClick) {\n    state.module.onClick({\n      ...event,\n      latitude,\n      longitude,\n    })\n  }\n}\n","const RGB_MAX = 255\nconst HUE_MAX = 360\nconst SV_MAX = 100\n\nexport const VESSELS_HUES_INCREMENTS_NUM = 31 // 360 / VESSELS_HUES_INCREMENTS_NUM - 1  should give a round number\nexport const VESSELS_HUES_INCREMENT = 360 / (VESSELS_HUES_INCREMENTS_NUM - 1)\n\n// Legacy: this is only here for compatibility with pre-mapbox branch workspaces\nexport const COLOR_HUES = {\n  orange: 0,\n  peach: 22,\n  yellow: 60,\n  green: 85,\n  brightGreen: 145,\n  lightBlue: 182,\n  blue: 236,\n  purple: 284,\n  pink: 312,\n}\n\n// FIXME mark explicitely as legacy. Check all usages.\nexport const getKeyByValue = (obj, value) => {\n  let result = null\n  Object.entries(obj).forEach((entry) => {\n    if (entry[1] === value) result = entry[0]\n  })\n  return result\n}\n\n/**\n * Converts an RGB color value to HSV. Conversion formula\n * adapted from http://en.wikipedia.org/wiki/HSV_color_space.\n * Assumes r, g, and b are contained in the set [0, 255] and\n * returns h, s, and v in the set [0, 1].\n *\n * @param   Number  r       The red color value\n * @param   Number  g       The green color value\n * @param   Number  b       The blue color value\n * @return  Array           The HSV representation\n */\nexport const rgbToHsv = (_r, _g, _b) => {\n  const r = _r / 255\n  const g = _g / 255\n  const b = _b / 255\n\n  const max = Math.max(r, g, b)\n  const min = Math.min(r, g, b)\n  let h\n  const v = max\n\n  const d = max - min\n  const s = max === 0 ? 0 : d / max\n\n  if (max === min) {\n    h = 0 // achromatic\n  } else {\n    switch (max) {\n      case r:\n        h = (g - b) / d + (g < b ? 6 : 0)\n        break\n      case g:\n        h = (b - r) / d + 2\n        break\n      case b:\n        h = (r - g) / d + 4\n        break\n      default:\n        h = 0\n    }\n\n    h /= 6\n  }\n\n  return [h, s, v]\n}\n\n// converts hue, saturation, luminance to an rgb object\nexport const hsvToRgb = (h_, s_, v_) => {\n  const h = ((h_ % HUE_MAX) / parseFloat(HUE_MAX)) * 6\n  const s = s_ === SV_MAX ? 1 : (s_ % SV_MAX) / parseFloat(SV_MAX)\n  const v = v_ === SV_MAX ? 1 : (v_ % SV_MAX) / parseFloat(SV_MAX)\n\n  const i = Math.floor(h)\n  const f = h - i\n  const p = v * (1 - s)\n  const q = v * (1 - f * s)\n  const t = v * (1 - (1 - f) * s)\n  const mod = i % 6\n  const r = [v, q, p, p, t, v][mod]\n  const g = [t, v, v, q, p, p][mod]\n  const b = [p, p, t, v, v, q][mod]\n\n  return { r: Math.round(r * RGB_MAX), g: Math.round(g * RGB_MAX), b: Math.round(b * RGB_MAX) }\n}\n\n// returns an rgb string with default saturation and luminance values\nconst hueToRgbDefaults = (hue) => hsvToRgb(hue, 50, 100)\n\nexport const hueToRgbString = (hue) => {\n  const rgb = hueToRgbDefaults(hue)\n  return `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`\n}\n\nexport const rgbToHexString = (rgb, css) => {\n  const str = ['r', 'g', 'b']\n    .map((channelName) => {\n      const channelValue = rgb[channelName]\n      let channelStr = channelValue.toString(16)\n      if (channelValue < 16) {\n        channelStr = `0${channelStr}`\n      }\n      return channelStr\n    })\n    .join('')\n  const prefix = css === true ? '#' : '0x'\n  return `${prefix}${str}`\n}\n\nexport const hueToRgbHexString = (hue, css) => {\n  const rgb = hueToRgbDefaults(hue)\n  return rgbToHexString(rgb, css)\n}\n\nconst closestNumber = (numberArray, goal) =>\n  numberArray.reduce((prev, curr) => (Math.abs(curr - goal) < Math.abs(prev - goal) ? curr : prev))\n\nexport const hueToClosestColor = (hue) => {\n  if (hue === undefined || hue === null) return undefined\n  const colorHueValues = Object.keys(COLOR_HUES).map((key) => COLOR_HUES[key])\n  const closestHue = closestNumber(colorHueValues, hue)\n  return getKeyByValue(COLOR_HUES, closestHue)\n}\n\nexport const hexToRgb = (hex) => {\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex)\n  return result\n    ? {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16),\n      }\n    : null\n}\n\nconst rgbToRgbaString = (rgb, opacity) => `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`\n\nexport const hueToRgbaString = (hue, opacity) => {\n  const rgb = hueToRgbDefaults(hue)\n  return rgbToRgbaString(rgb, opacity)\n}\n\nexport const hexToRgba = (hex, opacity) => {\n  const rgb = hexToRgb(hex)\n  return rgbToRgbaString(rgb, opacity)\n}\n\nexport const hueIncrementToHue = (hueIncrement) => hueIncrement * VESSELS_HUES_INCREMENT\n\nexport const hueToHueIncrement = (hue) =>\n  Math.round((hue / 360) * (VESSELS_HUES_INCREMENTS_NUM - 1))\n\nexport const wrapHue = (hue) => hue % 360\n\nexport const hueOrColorToHexColor = (color, hue) => {\n  if (hue !== undefined) {\n    return hueToRgbHexString(hue, true)\n  }\n\n  return color\n}\n","/* global PIXI */\nimport 'pixi.js'\nimport { hueToHueIncrement, VESSELS_HUES_INCREMENTS_NUM } from '../utils/map-colors'\nimport { VESSELS_BASE_RADIUS, MAX_SPRITES_PER_LAYER } from '../config'\n\nexport default class HeatmapSubLayer {\n  constructor(baseTexture, renderingStyleIndex, hue, useNormalBlendMode = false) {\n    // this.stage = new PIXI.Container();\n    // the ParticleContainer is a faster version of the PIXI sprite container\n    this.stage = new PIXI.particles.ParticleContainer(MAX_SPRITES_PER_LAYER, {\n      scale: true,\n      alpha: true,\n      position: true,\n      uvs: true,\n    })\n    if (useNormalBlendMode === false) {\n      this.stage.blendMode = PIXI.BLEND_MODES.SCREEN\n    }\n\n    this.spritesPool = []\n\n    const initialTextureFrame = new PIXI.Rectangle(\n      0,\n      0,\n      VESSELS_BASE_RADIUS * 2,\n      VESSELS_BASE_RADIUS * 2\n    )\n    this.mainVesselTexture = new PIXI.Texture(baseTexture, initialTextureFrame)\n    this._setTextureFrame(renderingStyleIndex, hue)\n\n    this.clearSpriteProps()\n  }\n\n  clearSpriteProps() {\n    this.spritesProps = {\n      x: new Float32Array(MAX_SPRITES_PER_LAYER),\n      y: new Float32Array(MAX_SPRITES_PER_LAYER),\n      a: new Float32Array(MAX_SPRITES_PER_LAYER),\n      s: new Float32Array(MAX_SPRITES_PER_LAYER),\n    }\n    this.spritesPropsCount = 0\n  }\n\n  pushSpriteProps(x, y, a, s) {\n    this.spritesProps.x[this.spritesPropsCount] = x\n    this.spritesProps.y[this.spritesPropsCount] = y\n    this.spritesProps.a[this.spritesPropsCount] = a\n    this.spritesProps.s[this.spritesPropsCount] = s\n    this.spritesPropsCount++\n  }\n\n  setRenderingStyleIndex(renderingStyleIndex) {\n    this._setTextureFrame(renderingStyleIndex)\n  }\n\n  destroy() {\n    this.spritesPool = null\n    this.stage.destroy({ children: true })\n  }\n\n  /**\n   * Updates the main texture frame offset to show different brush styles and hues\n   * Both args are optional, if one is omitted, previous value is used\n   * @heatmapStyle bool whether to use heatmap style or solid circle style\n   * @hue number hue value between 0 and 360\n   */\n  _setTextureFrame(renderingStyleIndex = null, hue = null) {\n    const textureFrame = this.mainVesselTexture.frame.clone()\n\n    if (renderingStyleIndex !== null) {\n      // one diameter + tiny offset between 2 frames\n      textureFrame.x = VESSELS_BASE_RADIUS * 2 * renderingStyleIndex + renderingStyleIndex\n    }\n\n    if (hue !== null) {\n      let hueIncrement = hueToHueIncrement(hue)\n      if (hueIncrement === VESSELS_HUES_INCREMENTS_NUM - 1) {\n        hueIncrement = 0\n      }\n      textureFrame.y = hueIncrement * VESSELS_BASE_RADIUS * 2\n      if (hueIncrement > 0) {\n        textureFrame.y += hueIncrement\n      }\n    }\n\n    this.mainVesselTexture.frame = textureFrame\n    this.mainVesselTexture.update()\n  }\n\n  render() {\n    const numProps = this.spritesPropsCount\n    this.resizeSpritesPool()\n\n    for (let i = 0; i < numProps; i++) {\n      const sprite = this.stage.children[i]\n      const s = this.spritesProps.s[i]\n      sprite.setTransform(this.spritesProps.x[i], this.spritesProps.y[i], s, s)\n      sprite.alpha = this.spritesProps.a[i]\n    }\n\n    const numSprites = this.stage.children.length\n    for (let i = numProps; i < numSprites; i++) {\n      const sprite = this.stage.children[i]\n      sprite.x = -100\n    }\n  }\n\n  resizeSpritesPool() {\n    const numProps = this.spritesPropsCount\n    const prevNumSprites = this.stage.children.length\n    const delta = numProps - prevNumSprites\n    // console.log(prevNumSprites, '->', numProps, ' delta:', delta);\n\n    if (delta < -4999) {\n      // sprite needs to be removed. Do that progressively (max 100) to avoid UI lock\n      const toRemove = Math.min(100, -delta)\n      // console.log('removing ', toRemove);\n      for (let i = 0; i < toRemove; i++) {\n        this.stage.removeChildAt(0)\n      }\n    }\n\n    if (delta > 0) {\n      const toAdd = Math.max(5000, delta)\n      // console.log('adding ', toAdd);\n      this._addSprites(toAdd)\n    }\n  }\n\n  _addSprites(num) {\n    for (let i = 0; i < num; i++) {\n      const vessel = new PIXI.Sprite(this.mainVesselTexture)\n      vessel.anchor.x = 0.5\n      vessel.anchor.y = 0.5\n      // ParticlesContainer does not support .visible, so we just move the sprite out of the viewport\n      vessel.x = -100\n      // vessel.blendMode = PIXI.BLEND_MODES.SCREEN;\n      // vessel.filters=  [new PIXI.filters.BlurFilter(10,10)]\n      this.stage.addChild(vessel)\n    }\n  }\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport uniq from 'lodash/uniq'\nimport * as PIXI from 'pixi.js'\nimport { worldToPixels } from 'viewport-mercator-project'\nimport { BRUSH_RENDERING_STYLE, BRUSH_ZOOM_RENDERING_STYLE } from '../constants'\nimport { vesselSatisfiesFilters } from '../utils/heatmapTileData'\nimport HeatmapSubLayer from './HeatmapSubLayer'\n\n// This is a faster version of worldToPixels that omits pitch,\n// and ignores values from the matrix that are consistently = 0\nconst s = 1 / 1.5\nconst worldToPixelsSimple = (x, y, m) => {\n  const fx = s * (m[0] * x + m[4] * y + m[12])\n  const fy = s * (m[5] * y + m[13])\n  return [fx, fy]\n}\n\nclass HeatmapLayer extends React.Component {\n  componentDidMount() {\n    this._build()\n  }\n\n  componentWillUnmount() {\n    this._destroy()\n  }\n\n  componentDidUpdate() {\n    this._redraw()\n  }\n\n  componentWillReceiveProps(nextProps) {\n    if (nextProps.useRadialGradientStyle !== this.props.useRadialGradientStyle) {\n      this.setBrushZoomRenderingStyle(nextProps.useRadialGradientStyle)\n    }\n  }\n\n  _build() {\n    const { layer, rootStage, useRadialGradientStyle, customRenderingStyle } = this.props\n    this.subLayers = {}\n    this.renderingStyle =\n      layer.header && layer.header.rendering ? layer.header.rendering : customRenderingStyle\n\n    this.setBrushRenderingStyle(this.renderingStyle.style)\n    this.setBrushZoomRenderingStyle(useRadialGradientStyle)\n\n    this.stage = new PIXI.Container()\n\n    rootStage.addChild(this.stage)\n  }\n\n  setBrushRenderingStyle(style = BRUSH_RENDERING_STYLE.NORMAL) {\n    if (typeof style === 'string') {\n      this.brushRenderingStyle = BRUSH_RENDERING_STYLE[style.toUpperCase()]\n    } else {\n      this.brushRenderingStyle = style\n    }\n    this._setBrushRenderingStyleIndex()\n  }\n\n  setBrushZoomRenderingStyle(useRadialGradientStyle) {\n    this.brushZoomRenderingStyle =\n      useRadialGradientStyle === true\n        ? BRUSH_ZOOM_RENDERING_STYLE.RADIAL_GRADIENT\n        : BRUSH_ZOOM_RENDERING_STYLE.CIRCLE\n    this._setBrushRenderingStyleIndex()\n  }\n\n  _setBrushRenderingStyleIndex() {\n    // only NORMAL brush styles support different zoom styles\n    const cappedZoomRenderingStyle =\n      this.brushRenderingStyle === BRUSH_RENDERING_STYLE.NORMAL ? this.brushZoomRenderingStyle : 0\n    const newStyleIndex = this.brushRenderingStyle + cappedZoomRenderingStyle\n    if (newStyleIndex === this.renderingStyleIndex) {\n      return\n    }\n    this.renderingStyleIndex = newStyleIndex\n    Object.values(this.subLayers).forEach((subLayer) => {\n      subLayer.setRenderingStyleIndex(this.renderingStyleIndex)\n    })\n  }\n\n  _redraw() {\n    const { filters, baseTexture, layer } = this.props\n\n    if (\n      layer === null ||\n      layer === undefined ||\n      layer.tiles === undefined ||\n      layer.visible === false\n    ) {\n      this.stage.visible = false\n      return\n    }\n\n    this.stage.visible = true\n    this.stage.alpha = layer.opacity\n\n    const tiles = layer.tiles\n    const defaultHue = layer.hue\n    const allHuesToRender =\n      filters !== undefined && filters.length\n        ? filters\n            // pass is set to true by filterGroupActions when none of the filters fields\n            // in the filter group is supported by the layer headers\n            .filter((f) => f.pass !== true)\n            .map((f) => (f.hue === undefined ? '0' : f.hue.toString()))\n        : [defaultHue.toString()]\n    const currentlyUsedHues = Object.keys(this.subLayers)\n\n    // get all hues, old and new\n    const allHues = uniq(allHuesToRender.concat(currentlyUsedHues))\n\n    for (let i = 0; i < allHues.length; i++) {\n      const hue = allHues[i]\n      if (allHuesToRender.indexOf(hue) === -1) {\n        // not on new hues: delete sublayer\n        this._destroySubLayer(this.subLayers[hue])\n        delete this.subLayers[hue]\n        continue\n      }\n      if (currentlyUsedHues.indexOf(hue) === -1) {\n        // not on old hues: create sublayer\n        this.subLayers[hue] = this._createSublayer(baseTexture, this.renderingStyleIndex, hue)\n      }\n      this.subLayers[hue].clearSpriteProps()\n    }\n\n    if (!allHuesToRender.length) return\n    tiles.forEach((tile) => {\n      this._setSubLayersSpritePropsForTile({\n        data: tile.data,\n        numFilters: filters.length,\n        defaultHue,\n      })\n    })\n\n    allHuesToRender.forEach((hueToRender) => {\n      this.subLayers[hueToRender].render()\n    })\n  }\n\n  _setSubLayersSpritePropsForTile({ data, numFilters, defaultHue }) {\n    if (!data) {\n      return\n    }\n\n    const { startIndex, endIndex, viewport, filters, viewportLeft, viewportRight } = this.props\n\n    for (let timeIndex = startIndex; timeIndex < endIndex; timeIndex++) {\n      const frame = data[timeIndex]\n\n      if (!frame) continue\n\n      for (let index = 0, len = frame.worldX.length; index < len; index++) {\n        let hue\n        if (filters === undefined || !filters.length) {\n          hue = defaultHue\n        }\n        for (let fi = 0; fi < numFilters; fi++) {\n          const filter = filters[fi]\n          if (vesselSatisfiesFilters(frame, index, filter.filterValues)) {\n            hue = filter.hue\n            break\n          }\n        }\n\n        // no filter passes: bail\n        if (hue === undefined) {\n          continue\n        }\n\n        // wrap worldX when point crosses the antimeridian/dateline\n        // world points go from 0 to 512. There is no way to determine if worldX is on the \"wrong\" side\n        // of the antimeridian just by looking at its value (where with lat/lon we can simply look at -/+)\n        // Therefore we compare it to the viewport's left or right boundary, depending on what is currently\n        // \"the right side\" of the antimeridian\n        let worldX = frame.worldX[index]\n        if (viewportLeft > 0 && worldX < viewportLeft) {\n          // worldX is \"behind\" viewportLeft, which means it is \"on the right\" of the antimeridian\n          worldX += 512\n        } else if (viewportLeft < 0 && worldX > viewportRight) {\n          worldX -= 512\n        }\n\n        const scaledX = worldX * viewport.scale\n        const scaledY = frame.worldY[index] * viewport.scale\n        const mtx = viewport.pixelProjectionMatrix\n\n        const [x, y] =\n          viewport.pitch === 0\n            ? worldToPixelsSimple(scaledX, scaledY, mtx)\n            : worldToPixels([scaledX, scaledY], mtx)\n\n        if (x > -10 && x < viewport.width + 10 && y > -10 && y < viewport.height + 10) {\n          this.subLayers[hue].pushSpriteProps(\n            x,\n            y,\n            frame.opacity ? frame.opacity[index] : this.renderingStyle.defaultOpacity,\n            frame.radius ? frame.radius[index] : this.renderingStyle.defaultSize\n          )\n        }\n      }\n    }\n  }\n\n  _createSublayer(baseTexture, renderingStyleIndex, hue) {\n    const subLayer = new HeatmapSubLayer(\n      baseTexture,\n      renderingStyleIndex,\n      hue,\n      this.brushRenderingStyle === BRUSH_RENDERING_STYLE.BULLSEYE\n    )\n    this.stage.addChild(subLayer.stage)\n    return subLayer\n  }\n\n  _destroy() {\n    Object.values(this.subLayers).forEach(this._destroySubLayer.bind(this))\n    this.stage.destroy({ children: true })\n    const { rootStage } = this.props\n    rootStage.removeChild(this.stage)\n  }\n\n  _destroySubLayer(subLayer) {\n    this.stage.removeChild(subLayer.stage)\n    subLayer.destroy()\n  }\n\n  render() {\n    return null\n  }\n}\n\nHeatmapLayer.propTypes = {\n  layer: PropTypes.object,\n  rootStage: PropTypes.object,\n  viewport: PropTypes.object,\n  startIndex: PropTypes.number,\n  endIndex: PropTypes.number,\n  filters: PropTypes.array,\n  baseTexture: PropTypes.object,\n  useRadialGradientStyle: PropTypes.bool,\n  customRenderingStyle: PropTypes.object,\n  viewportLeft: PropTypes.number,\n  viewportRight: PropTypes.number,\n}\n\nexport default HeatmapLayer\n","/* global PIXI */\nimport 'pixi.js'\nimport React from 'react'\nimport PropTypes from 'prop-types'\nimport { worldToPixels } from 'viewport-mercator-project'\nimport { TRACKS_DOTS_STYLE_ZOOM_THRESHOLD } from '../config'\n\nclass TracksLayer extends React.Component {\n  componentDidMount() {\n    this._build()\n  }\n\n  componentDidUpdate() {\n    this._redraw()\n  }\n\n  _build() {\n    const { rootStage } = this.props\n    this.stage = new PIXI.Graphics()\n    this.stage.nativeLines = true\n    rootStage.addChild(this.stage)\n  }\n\n  clear() {\n    this.stage.clear()\n  }\n\n  _redraw() {\n    const { tracks, zoom, startIndex, endIndex, highlightTemporalExtentIndexes } = this.props\n\n    this.clear()\n    if (!tracks.length) {\n      return\n    }\n\n    const overInInner =\n      highlightTemporalExtentIndexes === null\n        ? undefined\n        : [\n            Math.max(startIndex, highlightTemporalExtentIndexes[0]),\n            Math.min(endIndex, highlightTemporalExtentIndexes[1]),\n          ]\n    const overExtent = overInInner && overInInner[1] - overInInner[0] > 0 ? overInInner : undefined\n\n    let n = 0 // eslint-disable-line no-unused-vars\n\n    const drawFishingCircles = zoom > TRACKS_DOTS_STYLE_ZOOM_THRESHOLD\n    const fishingCirclesRadius = 1 + (zoom - TRACKS_DOTS_STYLE_ZOOM_THRESHOLD) * 0.5\n    const drawOverTrack = overExtent !== undefined && overExtent[0] > 0 && overExtent[1] > 0\n\n    tracks.forEach((track) => {\n      n += this._drawTrack({\n        data: track.data,\n        startIndex,\n        endIndex,\n        drawFishingCircles,\n        fishingCirclesRadius,\n        color: `0x${track.color.substr(1)}`,\n        lineThickness: 1,\n        lineOpacity: 1,\n      })\n\n      // Draw the highlight over the track when the user hovers over the Timebar\n      if (drawOverTrack === true) {\n        n += this._drawTrack({\n          data: track.data,\n          startIndex: highlightTemporalExtentIndexes[0],\n          endIndex: highlightTemporalExtentIndexes[1],\n          drawFishingCircles,\n          fishingCirclesRadius,\n          color: '0xFFFFFF',\n          lineThickness: 2,\n          lineOpacity: 1,\n        })\n      }\n    })\n\n    // console.log(n);\n  }\n\n  /**\n   * Draws a single track (line + points)\n   *\n   * @param data track points data in 'playback form' (ie organized by days)\n   * @param extent extent, in day indices\n   * @param offset object containing info about the current situation of the map viewport, used to compute screen coords\n   * @param drawFishingCircles whether to draw fishing circles or not\n   * @param fishingCirclesRadius radius of the fishing circles\n   * @param color\n   * @param lineThickness\n   * @param lineOpacity\n   * @param worldOffset offset to use when a track crosses the dateline (ie 512 to add a second world to the right)\n   */\n  _drawTrack({\n    data,\n    startIndex,\n    endIndex,\n    drawFishingCircles,\n    fishingCirclesRadius,\n    color,\n    lineThickness,\n    lineOpacity,\n    worldOffset = 0,\n  }) {\n    const { viewport } = this.props\n\n    let n = 0\n    let prevSeries\n    let prevWorldX\n    let prevWorldY\n\n    const circlePoints = {\n      x: [],\n      y: [],\n    }\n\n    // line thickness is ignored in native mode anyways.\n    this.stage.lineStyle(lineThickness, color, lineOpacity)\n\n    let duplicateWorld = false\n\n    for (let timeIndex = startIndex; timeIndex < endIndex; timeIndex++) {\n      const frame = data[timeIndex]\n\n      if (!frame) continue\n\n      for (let i = 0, len = frame.series.length; i < len; i++) {\n        const currentSeries = frame.series[i]\n\n        n++\n\n        const worldX = frame.worldX[i] + worldOffset\n        const worldY = frame.worldY[i]\n\n        const [x, y] = worldToPixels(\n          [worldX * viewport.scale, worldY * viewport.scale],\n          viewport.pixelProjectionMatrix\n        )\n\n        if (prevSeries !== currentSeries) {\n          this.stage.moveTo(x, y)\n        }\n\n        // more than a ½ world of distance between two points = crossing the dateline\n        if (prevWorldX && Math.abs(worldX - prevWorldX) > 256) {\n          // worldOffset === 0 -> this is the first time drawTrack is called\n          if (worldOffset === 0) {\n            // set a flag to call drawTrack again at the end of the loop\n            duplicateWorld = true\n          }\n\n          // get Y coordinate where track intersects with dateline\n          const atDatelineWorldY = prevWorldY + (worldY - prevWorldY) / 2\n\n          // whether tracks crosses dateline from west to east\n          const isWestToEast = worldX - prevWorldX < 0\n\n          const worldXEnd = worldOffset + (512 - 0.000001)\n          const worldXStart = worldOffset\n\n          // get X coordinate ending at dateline\n          const atDatelineEndWorldX = isWestToEast ? worldXEnd : worldXStart\n\n          // get X coordinate starting at dateline\n          const atDatelineStartWorldX = isWestToEast ? worldXStart : worldXEnd\n\n          const [x1, y1] = worldToPixels(\n            [atDatelineEndWorldX * viewport.scale, atDatelineWorldY * viewport.scale],\n            viewport.pixelProjectionMatrix\n          )\n          this.stage.lineTo(x1, y1)\n          const [x2, y2] = worldToPixels(\n            [atDatelineStartWorldX * viewport.scale, atDatelineWorldY * viewport.scale],\n            viewport.pixelProjectionMatrix\n          )\n          this.stage.moveTo(x2, y2)\n        }\n\n        this.stage.lineTo(x, y)\n\n        if (drawFishingCircles && frame.hasFishing[i] === true) {\n          circlePoints.x.push(x)\n          circlePoints.y.push(y)\n        }\n\n        prevWorldX = worldX\n        prevWorldY = worldY\n        prevSeries = currentSeries\n      }\n    }\n\n    if (drawFishingCircles) {\n      this.stage.lineStyle(0)\n      this.stage.beginFill(color, 1)\n      for (let i = 0, circlesLength = circlePoints.x.length; i < circlesLength; i++) {\n        this.stage.drawCircle(circlePoints.x[i], circlePoints.y[i], fishingCirclesRadius)\n      }\n      this.stage.endFill()\n    }\n\n    if (duplicateWorld === true) {\n      ;[-512, 512].forEach((offset) => {\n        this._drawTrack({\n          worldOffset: offset,\n          data,\n          startIndex,\n          endIndex,\n          drawFishingCircles,\n          fishingCirclesRadius,\n          color,\n          lineThickness,\n          lineOpacity,\n        })\n      })\n    }\n    return n\n  }\n\n  render() {\n    return null\n  }\n}\n\nTracksLayer.propTypes = {\n  zoom: PropTypes.number,\n  rootStage: PropTypes.object,\n  viewport: PropTypes.object,\n  startIndex: PropTypes.number,\n  endIndex: PropTypes.number,\n  highlightTemporalExtentIndexes: PropTypes.array,\n  tracks: PropTypes.array,\n}\n\nexport default TracksLayer\n","import React from 'react'\nimport * as PIXI from 'pixi.js'\nimport PropTypes from 'prop-types'\nimport { BaseControl } from 'react-map-gl'\nimport { lngLatToWorld } from 'viewport-mercator-project'\nimport {\n  hsvToRgb,\n  hueToRgbString,\n  hueIncrementToHue,\n  wrapHue,\n  VESSELS_HUES_INCREMENTS_NUM,\n} from '../utils/map-colors'\nimport {\n  VESSELS_BASE_RADIUS,\n  VESSELS_HEATMAP_BLUR_FACTOR,\n  ACTIVITY_HIGHLIGHT_HUE,\n  VESSELS_HEATMAP_DIMMING_ALPHA,\n  VESSELS_RADIAL_GRADIENT_STYLE_ZOOM_THRESHOLD,\n  VESSEL_CLICK_TOLERANCE_PX,\n} from '../config'\nimport HeatmapLayer from '../heatmap/HeatmapLayer'\nimport TracksLayer from '../tracks/TracksLayer'\n\nconst shouldUseRadialGradientStyle = (zoom) => zoom < VESSELS_RADIAL_GRADIENT_STYLE_ZOOM_THRESHOLD\n\n// builds a texture spritesheet containing\n// - the heatmap style (radial gradient)\n// - the circle style that is used at higher zoom levels\n// - the 'bullseye' style used for encounters\n// as well as a number of hues for each in a 2D grid.\n// Then, only the texture frame (mesh UVs) is modified depending on the zoom level,\n// in order not to have to recreate sprites\nconst getVesselTexture = (radius, blurFactor) => {\n  const tplCanvas = document.createElement('canvas')\n  const tplCtx = tplCanvas.getContext('2d')\n  const diameter = radius * 2\n  const NUM_STYLES = 3\n  tplCanvas.width = diameter * NUM_STYLES + (NUM_STYLES - 1) // + (NUM_STYLES - 1): tiny offset between 2 frames\n  tplCanvas.height = diameter * VESSELS_HUES_INCREMENTS_NUM + VESSELS_HUES_INCREMENTS_NUM\n\n  for (let hueIncrement = 0; hueIncrement < VESSELS_HUES_INCREMENTS_NUM; hueIncrement++) {\n    const y = diameter * hueIncrement + hueIncrement\n    const yCenter = y + radius\n\n    // heatmap style\n    let x = radius\n    const gradient = tplCtx.createRadialGradient(\n      x,\n      yCenter,\n      radius * blurFactor,\n      x,\n      yCenter,\n      radius\n    )\n    const hue = hueIncrementToHue(hueIncrement)\n    const rgbString = hueToRgbString(hue)\n    gradient.addColorStop(0, rgbString)\n\n    const rgbOuter = hsvToRgb(wrapHue(hue + 30), 80, 100)\n    gradient.addColorStop(1, `rgba(${rgbOuter.r}, ${rgbOuter.g}, ${rgbOuter.b}, 0)`)\n\n    tplCtx.fillStyle = gradient\n    tplCtx.fillRect(0, y, diameter, diameter)\n\n    // circle style\n    x += diameter + 1 // tiny offset between 2 frames\n    tplCtx.beginPath()\n    tplCtx.arc(x, yCenter, radius, 0, 2 * Math.PI, false)\n    tplCtx.fillStyle = rgbString\n    tplCtx.fill()\n\n    // bullseye style\n    x += diameter + 1\n    tplCtx.beginPath()\n    tplCtx.arc(x, yCenter, radius * 0.4, 0, 2 * Math.PI, false)\n    tplCtx.fillStyle = rgbString\n    tplCtx.fill()\n    tplCtx.beginPath()\n    tplCtx.arc(x, yCenter, radius * 0.95, 0, 2 * Math.PI, false)\n    tplCtx.lineWidth = 1\n    tplCtx.strokeStyle = rgbString\n    tplCtx.stroke()\n  }\n\n  return tplCanvas\n}\n\nclass ActivityLayers extends BaseControl {\n  componentDidMount() {\n    this._build()\n  }\n\n  componentWillReceiveProps(nextProps) {\n    this.props.exportNativeViewport(this._context.viewport)\n\n    if (\n      nextProps.viewport.width !== this.props.viewport.width ||\n      nextProps.viewport.height !== this.props.viewport.height\n    ) {\n      this._updateViewportSize(nextProps.viewport.width, nextProps.viewport.height)\n    }\n  }\n\n  _build() {\n    const { width, height } = this.props.viewport\n\n    this.pixi = new PIXI.Application({\n      width,\n      height,\n      transparent: true,\n      antialias: true,\n    })\n\n    this.renderer = this.pixi.renderer\n    this.canvas = this.pixi.view\n    this.canvas.style.position = 'absolute'\n\n    this.container.appendChild(this.canvas)\n\n    this.stage = this.pixi.stage\n\n    const baseTextureCanvas = getVesselTexture(VESSELS_BASE_RADIUS, VESSELS_HEATMAP_BLUR_FACTOR)\n    this.baseTexture = PIXI.Texture.fromCanvas(baseTextureCanvas)\n\n    this.heatmapStage = new PIXI.Container()\n    this.stage.addChild(this.heatmapStage)\n\n    this.pixi.ticker.add(this._onTick)\n  }\n\n  _updateViewportSize(viewportWidth, viewportHeight) {\n    this.renderer.resize(viewportWidth, viewportHeight)\n  }\n\n  toggleHeatmapDimming(dim) {\n    if (this.heatmapStage === undefined) {\n      return\n    }\n    if (dim === true) {\n      this.heatmapFadingIn = false\n    }\n    this.heatmapStage.alpha = dim === true ? VESSELS_HEATMAP_DIMMING_ALPHA : 1\n  }\n\n  onTouchStart = (event) => {\n    if (!event.touches.length) {\n      return\n    }\n    this.queryCoords(event.touches[0].clientX, event.touches[0].clientY)\n  }\n\n  onMouseMove = (event) => {\n    this.queryCoords(event.clientX, event.clientY)\n  }\n\n  queryCoords(x, y) {\n    // bail if all heatmap layers are set to non-interactive\n    if (this.props.heatmapLayers.every((l) => l.interactive !== true)) {\n      return\n    }\n\n    const { viewport } = this._context\n    const [longitude, latitude] = viewport.unproject([x, y])\n\n    let wrappedLongitude = longitude\n    if (wrappedLongitude > 180) {\n      wrappedLongitude -= 360\n    } else if (wrappedLongitude < -180) {\n      wrappedLongitude += 360\n    }\n\n    const [worldX, worldY] = lngLatToWorld([wrappedLongitude, latitude], 1)\n\n    const toleranceRadiusInWorldUnits = VESSEL_CLICK_TOLERANCE_PX / viewport.scale\n\n    this.props.queryHeatmapVessels(\n      {\n        longitude: wrappedLongitude,\n        latitude,\n        worldX,\n        worldY,\n        toleranceRadiusInWorldUnits,\n      },\n      this.props.temporalExtentIndexes\n    )\n  }\n\n  _onTick = () => {\n    if (this.heatmapFadingIn === true && this.heatmapStage.alpha < 1) {\n      this._heatmapFadeinStep()\n    }\n  }\n\n  _startHeatmapFadein() {\n    this.heatmapFadingIn = true\n    this.heatmapFadeinStartTimestamp = undefined\n  }\n\n  _heatmapFadeinStep() {\n    if (this.heatmapFadeinStartTimestamp === undefined) {\n      this.heatmapFadeinStartTimestamp = Date.now()\n    }\n    const timeElapsed = (Date.now() - this.heatmapFadeinStartTimestamp) / 1000\n    let alpha = this.heatmapStage.alpha + (1 - this.heatmapStage.alpha) * timeElapsed\n    if (alpha >= 1) {\n      alpha = 1\n      this.heatmapFadingIn = false\n    }\n    this.heatmapStage.alpha = alpha\n  }\n\n  // FIXME move to container?\n  _getHighlightData(highlightedVessels, highlightedClickedVessel, heatmapLayers) {\n    const hue = ACTIVITY_HIGHLIGHT_HUE\n    let highlightLayerData = {\n      id: '__HIGHLIGHT__',\n      visible: true,\n      opacity: 1,\n      hue: ACTIVITY_HIGHLIGHT_HUE,\n    }\n    let highlightFilters = []\n\n    if (\n      highlightedVessels !== undefined &&\n      highlightedVessels.layer !== undefined &&\n      highlightedVessels.foundVessels !== undefined &&\n      highlightedVessels.isEmpty !== true\n    ) {\n      const sourceLayer = heatmapLayers.find((l) => l.id === highlightedVessels.layer.id)\n      highlightLayerData = { highlightLayerData, ...sourceLayer }\n      highlightFilters = highlightedVessels.foundVessels.map((vessel) => ({\n        hue,\n        filterValues: {\n          series: [vessel.series],\n        },\n      }))\n    } else if (highlightedClickedVessel !== null) {\n      const sourceLayer = heatmapLayers.find((l) => l.id === highlightedClickedVessel.layer.id)\n      highlightLayerData = { highlightLayerData, ...sourceLayer }\n      highlightFilters = [\n        {\n          hue,\n          filterValues: {\n            series: [highlightedClickedVessel.seriesgroup],\n          },\n        },\n      ]\n    }\n    return {\n      highlightLayerData,\n      highlightFilters,\n    }\n  }\n  _render() {\n    const {\n      zoom,\n      heatmapLayers,\n      temporalExtentIndexes,\n      highlightTemporalExtentIndexes,\n      highlightedVessels,\n      highlightedClickedVessel,\n      tracks,\n      leftWorldScaled,\n      rightWorldScaled,\n    } = this.props\n    const { viewport } = this._context\n\n    const startIndex = temporalExtentIndexes[0]\n    const endIndex = temporalExtentIndexes[1]\n    const useRadialGradientStyle = shouldUseRadialGradientStyle(zoom)\n\n    if (highlightedVessels.isEmpty !== true) {\n      this.toggleHeatmapDimming(true)\n    }\n    if (highlightedVessels.isEmpty === true && tracks.length === 0) {\n      this._startHeatmapFadein()\n    }\n    if (this.renderer) {\n      const err = this.renderer.gl.getError()\n      if (err !== 0) console.log(err)\n    }\n\n    const { highlightLayerData, highlightFilters } = this._getHighlightData(\n      highlightedVessels,\n      highlightedClickedVessel,\n      heatmapLayers\n    )\n\n    return (\n      <div\n        ref={(ref) => {\n          this.container = ref\n        }}\n        style={{ position: 'absolute' }}\n        onMouseMove={this.onMouseMove}\n        onTouchStart={this.onTouchStart}\n      >\n        {heatmapLayers.map((layer) => (\n          <HeatmapLayer\n            key={layer.id}\n            layer={layer}\n            filters={layer.filters || []}\n            viewport={viewport}\n            startIndex={startIndex}\n            endIndex={endIndex}\n            baseTexture={this.baseTexture}\n            rootStage={this.heatmapStage}\n            useRadialGradientStyle={useRadialGradientStyle}\n            customRenderingStyle={{}}\n            viewportLeft={leftWorldScaled}\n            viewportRight={rightWorldScaled}\n          />\n        ))}\n        {this.stage !== undefined && (\n          <HeatmapLayer\n            key=\"highlighted\"\n            layer={highlightLayerData}\n            filters={highlightFilters}\n            viewport={viewport}\n            startIndex={startIndex}\n            endIndex={endIndex}\n            baseTexture={this.baseTexture}\n            rootStage={this.heatmapStage}\n            useRadialGradientStyle={useRadialGradientStyle}\n            customRenderingStyle={{ defaultOpacity: 1, defaultSize: 1 }}\n            viewportLeft={leftWorldScaled}\n            viewportRight={rightWorldScaled}\n          />\n        )}\n        {this.stage !== undefined && (\n          <TracksLayer\n            tracks={tracks}\n            viewport={viewport}\n            zoom={zoom}\n            startIndex={startIndex}\n            endIndex={endIndex}\n            highlightTemporalExtentIndexes={highlightTemporalExtentIndexes}\n            rootStage={this.stage}\n          />\n        )}\n      </div>\n    )\n  }\n}\n\nActivityLayers.propTypes = {\n  zoom: PropTypes.number,\n  heatmapLayers: PropTypes.array,\n  temporalExtentIndexes: PropTypes.array,\n  highlightTemporalExtentIndexes: PropTypes.array,\n  highlightedVessels: PropTypes.object,\n  highlightedClickedVessel: PropTypes.object,\n  tracks: PropTypes.array,\n  queryHeatmapVessels: PropTypes.func,\n  exportNativeViewport: PropTypes.func,\n  leftWorldScaled: PropTypes.number,\n  rightWorldScaled: PropTypes.number,\n}\n\nActivityLayers.contextTypes = {\n  viewport: PropTypes.object,\n}\n\nexport default ActivityLayers\n","import { connect } from 'react-redux'\nimport { createSelector } from 'reselect'\nimport convert from '@globalfishingwatch/map-convert'\nimport { exportNativeViewport } from '../glmap/viewport.actions'\nimport { getTemporalExtent, getHighlightTemporalExtent } from '../module/module.selectors'\nimport ActivityLayers from './ActivityLayers'\nimport { queryHeatmapVessels } from '../heatmap/heatmapTiles.actions'\nimport { MIN_FRAME_LENGTH_MS } from '../config'\n\nconst getHeatmapLayers = (state) => state.map.heatmap.heatmapLayers\n\nconst getHeatmapLayersAsArray = createSelector(\n  [getHeatmapLayers],\n  (heatmapLayers) => {\n    const a = Object.keys(heatmapLayers).map((id) => ({\n      ...heatmapLayers[id],\n    }))\n    // console.log(a)\n    return a\n  }\n)\n\nconst getTracks = (state) => state.map.tracks.data\n\nconst getTracksWithData = createSelector(\n  [getTracks],\n  (tracks) => {\n    const tracksWithData = tracks\n      .filter((t) => t.type !== 'geojson')\n      .filter((t) => t.data !== undefined)\n    return tracksWithData\n  }\n)\n\nconst getTemporalExtentIndexes = createSelector(\n  [getTemporalExtent],\n  (temporalExtent) => {\n    const startTimestamp = temporalExtent[0].getTime()\n    const endTimestamp = Math.max(\n      temporalExtent[1].getTime(),\n      temporalExtent[0].getTime() + MIN_FRAME_LENGTH_MS\n    )\n    const startIndex = convert.getOffsetedTimeAtPrecision(startTimestamp)\n    const endIndex = convert.getOffsetedTimeAtPrecision(endTimestamp)\n    return [startIndex, endIndex]\n  }\n)\n\nconst getHighlightTemporalExtentIndexes = createSelector(\n  [getHighlightTemporalExtent],\n  (highlightTemporalExtent) => {\n    if (\n      highlightTemporalExtent === undefined ||\n      highlightTemporalExtent === null ||\n      !highlightTemporalExtent.length\n    ) {\n      return null\n    }\n    const startTimestamp = highlightTemporalExtent[0].getTime()\n    const endTimestamp = highlightTemporalExtent[1].getTime()\n    const startIndex = convert.getOffsetedTimeAtPrecision(startTimestamp)\n    const endIndex = convert.getOffsetedTimeAtPrecision(endTimestamp)\n    return [startIndex, endIndex]\n  }\n)\n\nconst mapStateToProps = (state) => ({\n  highlightedVessels: state.map.heatmap.highlightedVessels,\n  highlightedClickedVessel: state.map.heatmap.highlightedClickedVessel,\n  viewport: state.map.viewport.viewport,\n  zoom: state.map.viewport.viewport.zoom,\n  heatmapLayers: getHeatmapLayersAsArray(state),\n  tracks: getTracksWithData(state),\n  leftWorldScaled: state.map.viewport.leftWorldScaled,\n  rightWorldScaled: state.map.viewport.rightWorldScaled,\n  temporalExtentIndexes: getTemporalExtentIndexes(state),\n  highlightTemporalExtentIndexes: getHighlightTemporalExtentIndexes(state),\n})\n\nconst mapDispatchToProps = (dispatch, ownProps) => ({\n  queryHeatmapVessels: (coords, temporalExtentIndexes) => {\n    dispatch(queryHeatmapVessels(coords, temporalExtentIndexes))\n  },\n  exportNativeViewport: (viewport) => {\n    dispatch(exportNativeViewport(viewport))\n  },\n})\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(ActivityLayers)\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport MapGL, { Popup } from 'react-map-gl'\nimport 'mapbox-gl/dist/mapbox-gl.css'\nimport ActivityLayers from '../activity/ActivityLayers.container.js'\nimport styles from './map.css'\n\nconst PopupWrapper = (props) => {\n  const { latitude, longitude, children, closeButton, onClose } = props\n  return (\n    <Popup\n      latitude={latitude}\n      longitude={longitude}\n      closeButton={closeButton}\n      onClose={onClose}\n      anchor=\"bottom\"\n      offsetTop={-10}\n      tipSize={4}\n      closeOnClick={false}\n    >\n      {children}\n    </Popup>\n  )\n}\n\nclass Map extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      mouseOver: true,\n    }\n  }\n  componentDidMount() {\n    window.addEventListener('resize', this._resize)\n    this._resize()\n\n    // useful with FOUC\n    window.setTimeout(() => this._resize(), 1)\n\n    // there is a problem with the container width computation (only with \"fat scrollbar\" browser/os configs),\n    // seems like the panels with scrollbars are taken into account or smth\n    window.setTimeout(() => this._resize(), 10000)\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('resize', this._resize)\n  }\n\n  _resize = () => {\n    if (this._mapContainerRef === undefined) {\n      console.warn('Cant set viewport on a map that hasnt finished intanciating yet')\n      return\n    }\n    const mapContainerStyle = window.getComputedStyle(this._mapContainerRef)\n    const width = parseInt(mapContainerStyle.width, 10)\n    const height = parseInt(mapContainerStyle.height, 10) + 1\n\n    if (width !== this.props.viewport.width || height !== this.props.viewport.height) {\n      this.props.setViewport({\n        ...this.props.viewport,\n        width,\n        height,\n      })\n    }\n  }\n\n  onViewportChange = (viewport) => {\n    this.props.setViewport(viewport)\n  }\n\n  onMapInteraction = (event, type) => {\n    // console.log(type, event, event.features)\n    const callback = type === 'hover' ? this.props.mapHover : this.props.mapClick\n    if (this.glMap !== undefined && event.features !== undefined && event.features.length) {\n      const feature = event.features[0]\n      if (feature.properties.cluster === true) {\n        const clusterId = feature.properties.cluster_id\n        const sourceId = feature.source\n        const glSource = this.glMap.getSource(sourceId)\n        glSource.getClusterExpansionZoom(clusterId, (err1, zoom) => {\n          glSource.getClusterLeaves(clusterId, 99, 0, (err2, children) => {\n            if (err1 || err2) {\n              return\n            }\n            callback(event.lngLat[1], event.lngLat[0], event.features, {\n              zoom,\n              children,\n            })\n          })\n        })\n        return\n      }\n    }\n    callback(event.lngLat[1], event.lngLat[0], event.features)\n  }\n\n  onHover = (event) => {\n    this.onMapInteraction(event, 'hover')\n  }\n\n  onClick = (event) => {\n    this.onMapInteraction(event, 'click')\n  }\n\n  render() {\n    const {\n      viewport,\n      maxZoom,\n      minZoom,\n      transitionEnd,\n      mapStyle,\n      onClosePopup,\n      clickPopup,\n      hoverPopup,\n      cursor,\n      interactiveLayerIds,\n    } = this.props\n    return (\n      <div\n        id=\"map\"\n        className={styles.map}\n        ref={(ref) => {\n          this._mapContainerRef = ref\n        }}\n        onMouseLeave={() => {\n          this.setState({ mouseOver: false })\n        }}\n        onMouseEnter={() => {\n          this.setState({ mouseOver: true })\n        }}\n      >\n        <MapGL\n          ref={(ref) => {\n            if (ref !== null) {\n              this.glMap = ref.getMap()\n            }\n          }}\n          onTransitionEnd={transitionEnd}\n          onHover={this.onHover}\n          onClick={this.onClick}\n          getCursor={({ isDragging }) => {\n            if (cursor === null) {\n              return isDragging ? 'grabbing' : 'grab'\n            }\n            return cursor\n          }}\n          mapStyle={mapStyle}\n          {...viewport}\n          maxZoom={maxZoom}\n          minZoom={minZoom}\n          onViewportChange={this.onViewportChange}\n          interactiveLayerIds={interactiveLayerIds}\n        >\n          <ActivityLayers loadTemporalExtent={this.props.loadTemporalExtent} />\n          {clickPopup !== undefined && clickPopup !== null && (\n            <PopupWrapper\n              latitude={clickPopup.latitude}\n              longitude={clickPopup.longitude}\n              closeButton\n              onClose={onClosePopup}\n            >\n              {clickPopup.content}\n            </PopupWrapper>\n          )}\n          {this.state.mouseOver === true && hoverPopup !== undefined && hoverPopup !== null && (\n            <PopupWrapper\n              latitude={hoverPopup.latitude}\n              longitude={hoverPopup.longitude}\n              closeButton={false}\n            >\n              {hoverPopup.content}\n            </PopupWrapper>\n          )}\n        </MapGL>\n        <div className={styles.googleLogo} />\n      </div>\n    )\n  }\n}\n\nMap.propTypes = {\n  viewport: PropTypes.object,\n  mapStyle: PropTypes.object,\n  clickPopup: PropTypes.object,\n  hoverPopup: PropTypes.object,\n  maxZoom: PropTypes.number,\n  minZoom: PropTypes.number,\n  setViewport: PropTypes.func,\n  mapHover: PropTypes.func,\n  mapClick: PropTypes.func,\n  onClosePopup: PropTypes.func,\n  transitionEnd: PropTypes.func,\n  cursor: PropTypes.string,\n  interactiveLayerIds: PropTypes.arrayOf(PropTypes.string),\n}\n\nexport default Map\n","import { connect } from 'react-redux'\nimport { createSelector } from 'reselect'\nimport { fromJS } from 'immutable'\nimport { TRACKS_LAYER_IN_FRONT_OF_GROUP } from '../config'\nimport { closePopup } from '../module/module.actions.js'\nimport { getTracksStyles } from '../tracks/tracks.selectors.js'\nimport { mapHover, mapClick } from './interaction.actions.js'\nimport { setViewport, transitionEnd } from './viewport.actions.js'\nimport Map from './Map'\n\nconst getStaticLayers = (state) => state.map.style.staticLayers\n\nconst getInteractiveLayerIds = createSelector(\n  [getStaticLayers],\n  // Note: here we assume that layer IDs provided with module match the GL layers that should\n  // be interactive or not, ie typically the fill layer if a label layer is present\n  (staticLayers) =>\n    staticLayers.filter((l) => l.interactive === true && l.visible === true).map((l) => l.id)\n)\n\nconst getMapStyles = (state) => state.map.style.mapStyle\nconst getMapStyle = createSelector(\n  [getMapStyles, getTracksStyles],\n  (mapStyles, trackStyles) => {\n    if (!trackStyles) return mapStyles\n\n    const currentLayerGroups = mapStyles\n      .toJS()\n      .layers.filter((l) => l.metadata !== undefined)\n      .map((l) => l.metadata['mapbox:group'])\n    const trackLayersIndex = currentLayerGroups.lastIndexOf(TRACKS_LAYER_IN_FRONT_OF_GROUP) + 1\n\n    let finalMapStyles = mapStyles.mergeIn(['sources'], trackStyles.sources)\n    let mapStylesLayers = mapStyles.get('layers')\n    trackStyles.layers.forEach((trackLayer, i) => {\n      mapStylesLayers = mapStylesLayers.insert(trackLayersIndex + i, fromJS(trackLayer))\n    })\n    finalMapStyles = finalMapStyles.set('layers', mapStylesLayers)\n\n    return finalMapStyles\n  }\n)\n\nconst mapStateToProps = (state, ownProps) => ({\n  viewport: state.map.viewport.viewport,\n  maxZoom: state.map.viewport.maxZoom,\n  minZoom: state.map.viewport.minZoom,\n  cursor: state.map.interaction.cursor,\n  mapStyle: getMapStyle(state),\n  interactiveLayerIds: getInteractiveLayerIds(state),\n})\n\nconst mapDispatchToProps = (dispatch) => ({\n  setViewport: (viewport) => {\n    dispatch(setViewport(viewport))\n  },\n  mapHover: (lat, long, features, cluster) => {\n    dispatch(mapHover(lat, long, features, cluster))\n  },\n  mapClick: (lat, long, features, cluster) => {\n    dispatch(mapClick(lat, long, features, cluster))\n  },\n  transitionEnd: () => {\n    dispatch(transitionEnd())\n  },\n  onClosePopup: () => {\n    dispatch(closePopup())\n  },\n})\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(Map)\n","// This utility looks at GeoJSON features and returns the predominant geometry type\n\nconst TYPES = [\n  { gl: 'line', geoJSON: ['LineString', 'MultiLineString'] },\n  { gl: 'fill', geoJSON: ['Polygon', 'MultiPolygon'] },\n  { gl: 'circle', geoJSON: ['Point', 'MultiPoint'] },\n]\n\nexport default (geoJSON) => {\n  // collect all geoJSON geom types\n  const allGeoJSONTypes = geoJSON.features.map((feature) => {\n    const geom = feature.geometry\n    if (geom === undefined) {\n      return null\n    }\n    return geom.type\n  })\n\n  // collect number of geometries by GL geom types\n  const numByGLType = TYPES.map((type) => {\n    let num = 0\n    allGeoJSONTypes.forEach((geoJSONType) => {\n      if (type.geoJSON.indexOf(geoJSONType) > -1) {\n        num++\n      }\n    })\n    return { gl: type.gl, num }\n  })\n\n  // get feature types with the higher count\n  let glType = 'fill'\n  let glTypeMax = 0\n  numByGLType.forEach((t) => {\n    if (t.num > glTypeMax) {\n      glType = t.gl\n      glTypeMax = t.num\n    }\n  })\n\n  return glType\n}\n","import { fromJS } from 'immutable'\nimport { hexToRgb } from '../utils/map-colors'\nimport { STATIC_LAYERS_CARTO_ENDPOINT, STATIC_LAYERS_CARTO_TILES_ENDPOINT } from '../config'\nimport { CUSTOM_LAYERS_SUBTYPES, GL_TRANSPARENT } from '../constants'\nimport GL_STYLE from './gl-styles/style.json'\nimport getMainGeomType from '../utils/getMainGeomType'\n\nexport const INIT_MAP_STYLE = 'INIT_MAP_STYLE'\nexport const SET_MAP_STYLE = 'SET_MAP_STYLE'\nexport const MARK_CARTO_LAYERS_AS_INSTANCIATED = 'MARK_CARTO_LAYERS_AS_INSTANCIATED'\nexport const SET_STATIC_LAYERS = 'SET_STATIC_LAYERS'\nexport const SET_BASEMAP_LAYERS = 'SET_BASEMAP_LAYERS'\n\nexport const initStyle = ({ glyphsPath }) => ({\n  type: INIT_MAP_STYLE,\n  payload: {\n    glyphsPath,\n  },\n})\n\nconst setMapStyle = (style) => ({\n  type: SET_MAP_STYLE,\n  payload: style,\n})\n\nexport const applyTemporalExtent = (temporalExtent) => (dispatch, getState) => {\n  const state = getState().map.style\n  let style = state.mapStyle\n  const currentStyle = style.toJS()\n  const glLayers = currentStyle.layers\n\n  const start = Math.round(temporalExtent[0].getTime() / 1000)\n  const end = Math.round(temporalExtent[1].getTime() / 1000)\n\n  for (let i = 0; i < glLayers.length; i++) {\n    const glLayer = glLayers[i]\n    if (glLayer.metadata === undefined || glLayer.metadata['gfw:temporal'] !== true) {\n      continue\n    }\n\n    // if layer is temporal, a filter must always be preset on the style.json object\n    // because each layer can have a different time field to be filtered\n    const currentFilter = style.getIn(['layers', i, 'filter']).toJS()\n    if (currentFilter === null) {\n      throw new Error('filter must be preset on style.json for temporal layer: ', glLayer.id)\n    }\n    currentFilter[1][2] = start\n    currentFilter[2][2] = end\n    style = style.setIn(['layers', i, 'filter'], fromJS(currentFilter))\n  }\n  dispatch(setMapStyle(style))\n}\n\nconst applyLayerExpressions = (style, refLayer, currentGlLayer, glLayerIndex) => {\n  let newStyle = style\n  const currentStyle = style.toJS()\n  const glType = currentGlLayer.type\n  const defaultStyles = currentStyle.metadata['gfw:styles']\n  const metadata = currentGlLayer.metadata\n  ;['selected', 'highlighted'].forEach((styleType) => {\n    // get selectedFeatures or highlightedFeatures\n    const features = refLayer[`${styleType}Features`]\n    const hasFeatures = features !== null && features !== undefined && features.values.length > 0\n    const applyStyleToAllFeatures = refLayer[styleType]\n\n    const defaultStyle = defaultStyles[styleType][glType] || {}\n    const layerStyle =\n      (metadata && metadata['gfw:styles'] && metadata['gfw:styles'][styleType]) || {}\n    const allPaintProperties = { ...defaultStyle, ...layerStyle }\n    if (Object.keys(allPaintProperties).length) {\n      // go through each applicable gl paint property\n      Object.keys(allPaintProperties).forEach((glPaintProperty) => {\n        const selectedValue = allPaintProperties[glPaintProperty][0]\n        const fallbackValue = allPaintProperties[glPaintProperty][1]\n        const paintOrLayout = ['icon-size', 'icon-image'].includes(glPaintProperty)\n          ? 'layout'\n          : 'paint'\n        let glPaintFinalValue\n        if (\n          hasFeatures === false &&\n          applyStyleToAllFeatures !== true &&\n          applyStyleToAllFeatures !== false\n        ) {\n          // style reset when no features filter is declared and neither is applyAll\n          const originalLayerStyle = GL_STYLE.layers.find((l) => l.id === currentGlLayer.id)\n          glPaintFinalValue = originalLayerStyle[paintOrLayout][glPaintProperty]\n        } else if (applyStyleToAllFeatures === true || applyStyleToAllFeatures === false) {\n          glPaintFinalValue = applyStyleToAllFeatures === true ? selectedValue : fallbackValue\n        } else {\n          let layerColorRgbString = ''\n          if (refLayer.color !== null && refLayer.color !== undefined) {\n            const layerColorRgb = hexToRgb(refLayer.color)\n            layerColorRgbString = `${layerColorRgb.r},${layerColorRgb.g},${layerColorRgb.b}`\n          }\n          glPaintFinalValue = [\n            'match',\n            ['get', features.field],\n            features.values,\n            typeof selectedValue !== 'string'\n              ? selectedValue\n              : selectedValue.replace('$REFLAYER_COLOR_RGB', layerColorRgbString),\n            typeof fallbackValue !== 'string'\n              ? fallbackValue\n              : fallbackValue.replace('$REFLAYER_COLOR_RGB', layerColorRgbString),\n          ]\n        }\n\n        if (glPaintFinalValue !== undefined) {\n          newStyle = newStyle.setIn(\n            ['layers', glLayerIndex, paintOrLayout, glPaintProperty],\n            glPaintFinalValue\n          )\n        }\n      })\n    }\n  })\n  return newStyle\n}\n\nconst toggleLayerVisibility = (style, refLayer, glLayerIndex) => {\n  const visibility = refLayer.visible === true ? 'visible' : 'none'\n  return style.setIn(['layers', glLayerIndex, 'layout', 'visibility'], visibility)\n}\n\nconst updateGLLayer = (style, glLayerId, refLayer) => {\n  const currentStyle = style.toJS()\n  const currentStyleLayers = currentStyle.layers\n  let newStyle = style\n\n  const glLayerIndex = currentStyleLayers.findIndex((l) => l.id === glLayerId)\n  const glLayer = currentStyleLayers.find((l) => l.id === glLayerId)\n\n  // visibility\n  newStyle = toggleLayerVisibility(newStyle, refLayer, glLayerIndex)\n\n  if (refLayer.isBasemap === true) {\n    return newStyle\n  }\n\n  const initialGLLayer = GL_STYLE.layers.find((l) => l.id === glLayerId)\n  const refLayerOpacity = refLayer.opacity === undefined ? 1 : refLayer.opacity\n\n  // color/opacity\n  switch (glLayer.type) {\n    case 'fill': {\n      newStyle = newStyle\n        .setIn(['layers', glLayerIndex, 'paint', 'fill-opacity'], refLayerOpacity)\n        .setIn(['layers', glLayerIndex, 'paint', 'fill-outline-color'], refLayer.color)\n        .setIn(['layers', glLayerIndex, 'paint', 'fill-color'], GL_TRANSPARENT)\n      break\n    }\n    case 'line': {\n      newStyle = newStyle\n        .setIn(['layers', glLayerIndex, 'paint', 'line-opacity'], refLayerOpacity)\n        .setIn(['layers', glLayerIndex, 'paint', 'line-color'], refLayer.color)\n      break\n    }\n    case 'symbol': {\n      if (glLayer.metadata && glLayer.metadata['gfw:isLabel'] === true) {\n        const parentLayerIsVisible =\n          newStyle.getIn(['layers', glLayerIndex, 'layout', 'visibility']) === 'visible'\n        const labelsVisibility =\n          parentLayerIsVisible && refLayer.showLabels === true ? 'visible' : 'none'\n        newStyle = newStyle.setIn(\n          ['layers', glLayerIndex, 'layout', 'visibility'],\n          labelsVisibility\n        )\n        if (refLayer.showLabels !== true) {\n          break\n        }\n      }\n      newStyle = newStyle.setIn(['layers', glLayerIndex, 'paint', 'text-opacity'], refLayerOpacity)\n\n      if (refLayer.color !== undefined) {\n        newStyle = newStyle.setIn(['layers', glLayerIndex, 'paint', 'text-color'], refLayer.color)\n      }\n      break\n    }\n    // Event layers and custom layers with point geom types\n    case 'circle': {\n      newStyle = newStyle\n        .setIn(['layers', glLayerIndex, 'paint', 'circle-opacity'], refLayerOpacity)\n        .setIn(\n          ['layers', glLayerIndex, 'paint', 'circle-radius'],\n          initialGLLayer.paint['circle-radius']\n        )\n        .setIn(\n          ['layers', glLayerIndex, 'paint', 'circle-stroke-color'],\n          initialGLLayer.paint['circle-stroke-color'] || '#000'\n        )\n        .setIn(\n          ['layers', glLayerIndex, 'paint', 'circle-stroke-width'],\n          initialGLLayer.paint['circle-stroke-width'] || 1\n        )\n\n      if (refLayer.color !== undefined) {\n        newStyle = newStyle.setIn(['layers', glLayerIndex, 'paint', 'circle-color'], refLayer.color)\n      }\n      break\n    }\n    case 'raster': {\n      newStyle = newStyle.setIn(\n        ['layers', glLayerIndex, 'paint', 'raster-opacity'],\n        refLayerOpacity\n      )\n      break\n    }\n    default: {\n      break\n    }\n  }\n\n  newStyle = applyLayerExpressions(newStyle, refLayer, glLayer, glLayerIndex)\n\n  return newStyle\n}\n\nconst addCustomGLLayer = (subtype, layerId, url, data) => (dispatch, getState) => {\n  const state = getState()\n  let style = state.map.style.mapStyle\n  const currentStyle = style.toJS()\n\n  // add source if it doesn't exist yet\n  if (currentStyle.sources[layerId] === undefined) {\n    const source = { type: subtype }\n    if (subtype === CUSTOM_LAYERS_SUBTYPES.geojson) {\n      source.data = data\n    } else if (subtype === CUSTOM_LAYERS_SUBTYPES.raster) {\n      source.tiles = [url]\n      source.tileSize = 256\n    }\n    style = style.setIn(['sources', layerId], fromJS(source))\n  }\n\n  if (currentStyle.layers.find((glLayer) => glLayer.id === layerId) === undefined) {\n    const glType = subtype === CUSTOM_LAYERS_SUBTYPES.geojson ? getMainGeomType(data) : subtype\n    const glLayer = fromJS({\n      id: layerId,\n      source: layerId,\n      type: glType,\n      layout: {},\n      paint: {},\n    })\n    const layerIndex =\n      subtype === CUSTOM_LAYERS_SUBTYPES.raster\n        ? // if raster, put at index of last raster layer except labels\n          currentStyle.layers.length -\n          1 -\n          currentStyle.layers\n            .filter((l) => l.id !== 'labels')\n            .reverse()\n            .findIndex((l) => l.type === 'raster')\n        : currentStyle.layers.length - 1\n    style = style.set('layers', style.get('layers').splice(layerIndex, 0, glLayer))\n  }\n\n  dispatch(setMapStyle(style))\n}\n\nconst addWorkspaceGLLayers = (workspaceGLLayers) => (dispatch, getState) => {\n  const state = getState()\n  let style = state.map.style.mapStyle\n\n  workspaceGLLayers.forEach((workspaceGLLayer) => {\n    const id = workspaceGLLayer.id\n    const gl = workspaceGLLayer.gl\n    const finalSource = fromJS(gl.source)\n    style = style.setIn(['sources', id], finalSource)\n\n    const layers = []\n    gl.layers.forEach((srcGlLayer) => {\n      const glLayer = {\n        ...srcGlLayer,\n        source: id,\n        'source-layer': id,\n      }\n      layers.push(glLayer)\n    })\n\n    const finalLayers = fromJS(layers)\n    style = style.set('layers', style.get('layers').concat(finalLayers))\n  })\n\n  dispatch(setMapStyle(style))\n\n  // TODO MAP MODULE\n  // dispatch(updateMapStyle());\n}\n\nconst getCartoLayerInstanciatePromise = ({ sourceId, sourceCartoSQL }) => {\n  const mapConfig = { layers: [{ id: sourceId, options: { sql: sourceCartoSQL } }] }\n  const mapConfigURL = encodeURIComponent(JSON.stringify(mapConfig))\n  const cartoAnonymousMapUrl = STATIC_LAYERS_CARTO_ENDPOINT.replace('$MAPCONFIG', mapConfigURL)\n\n  return new Promise((resolve) => {\n    fetch(cartoAnonymousMapUrl)\n      .then((res) => {\n        if (res.status >= 400) {\n          console.warn(`loading of layer failed ${sourceId}`)\n          Promise.reject()\n          return null\n        }\n        return res.json()\n      })\n      .then((data) => {\n        resolve({\n          layergroupid: data.layergroupid,\n          sourceId,\n        })\n      })\n      .catch((err) => {\n        console.warn(err)\n      })\n  })\n}\n\nconst instanciateCartoLayers = (layers) => (dispatch, getState) => {\n  dispatch({\n    type: MARK_CARTO_LAYERS_AS_INSTANCIATED,\n    payload: layers.map((layer) => layer.sourceId),\n  })\n  const cartoLayersPromises = layers.map((layer) => getCartoLayerInstanciatePromise(layer))\n  const cartoLayersPromisesPromise = Promise.all(cartoLayersPromises.map((p) => p.catch((e) => e)))\n  cartoLayersPromisesPromise\n    .then((instanciatedCartoLayers) => {\n      let style = getState().map.style.mapStyle\n      const currentStyle = style.toJS()\n      instanciatedCartoLayers.forEach((cartoLayer) => {\n        const tilesURL = STATIC_LAYERS_CARTO_TILES_ENDPOINT.replace(\n          '$LAYERGROUPID',\n          cartoLayer.layergroupid\n        )\n\n        // replace gl source with a new source that use tiles provided by Carto anonymous maps API\n        const newSourceId = `${cartoLayer.sourceId}-instanciated`\n        style = style.setIn(\n          ['sources', newSourceId],\n          fromJS({\n            type: 'vector',\n            tiles: [tilesURL],\n          })\n        )\n\n        // change source in all layers that are using it (genrally polygon + labels)\n        currentStyle.layers.forEach((glLayer, glLayerIndex) => {\n          if (glLayer.source === cartoLayer.sourceId) {\n            style = style.setIn(['layers', glLayerIndex, 'source'], newSourceId)\n            style = style.setIn(['layers', glLayerIndex, 'metadata', 'gfw:id'], cartoLayer.sourceId)\n            const refLayer = layers.find((l) => l.refLayer.id === cartoLayer.sourceId).refLayer\n            style = updateGLLayer(style, glLayer.id, refLayer)\n          }\n        })\n      })\n\n      dispatch(setMapStyle(style))\n    })\n    .catch((err) => {\n      console.warn(err)\n    })\n}\n\nexport const commitStyleUpdates = (staticLayers, basemapLayers) => (dispatch, getState) => {\n  // Store a copy of static and basemap layers. This is not used directly by\n  // the Map component which only needs a prepared style object\n  dispatch({\n    type: SET_STATIC_LAYERS,\n    payload: staticLayers,\n  })\n  dispatch({\n    type: SET_BASEMAP_LAYERS,\n    payload: basemapLayers,\n  })\n\n  const layers = [...staticLayers, ...basemapLayers.map((bl) => ({ ...bl, isBasemap: true }))]\n\n  const currentGLSources = getState().map.style.mapStyle.toJS().sources\n\n  // collect layers declared in workspace but not in original gl style\n  const workspaceGLLayers = layers.filter(\n    (layer) => layer.gl !== undefined && currentGLSources[layer.id] === undefined\n  )\n  if (workspaceGLLayers.length) {\n    dispatch(addWorkspaceGLLayers(workspaceGLLayers))\n  }\n\n  // instanciate custom layers if needed\n  const customLayers = layers.filter(\n    (layer) => layer.isCustom === true && currentGLSources[layer.id] === undefined\n  )\n  if (customLayers.length) {\n    customLayers.forEach((layer) => {\n      dispatch(addCustomGLLayer(layer.subtype, layer.id, layer.url, layer.data))\n    })\n  }\n\n  const state = getState().map.style\n  let style = state.mapStyle\n  const currentStyle = style.toJS()\n  const glLayers = currentStyle.layers\n  const glSources = currentStyle.sources\n\n  const cartoLayersToInstanciate = []\n\n  // update source when needed\n  staticLayers.forEach((refLayer) => {\n    const sourceId = refLayer.id\n    if (refLayer.data !== undefined && currentGLSources[sourceId] !== undefined) {\n      style = style.setIn(['sources', sourceId, 'data'], fromJS(refLayer.data))\n    }\n  })\n\n  for (let i = 0; i < glLayers.length; i++) {\n    const glLayer = glLayers[i]\n    const sourceId = glLayer.source\n    const glSource = glSources[sourceId]\n    const layerId = (glLayer.metadata !== undefined && glLayer.metadata['gfw:id']) || sourceId\n\n    const refLayer = layers.find((l) => l.id === layerId)\n\n    if (refLayer === undefined) {\n      if (glLayer.type !== 'background') {\n        // console.warn('gl layer does not exists in workspace', glLayer);\n      }\n      continue\n    }\n\n    // check if layer is served from Carto, which means we need to instanciate it first\n    // TODO BUG: check if layer is not instanciatING too\n    const sourceCartoSQL = glSource.metadata !== undefined && glSource.metadata['gfw:carto-sql']\n    if (sourceCartoSQL !== false && sourceCartoSQL !== undefined) {\n      // only if layer is visible and has not been instanciated yet\n      const cartoLayerInstanciated = state.cartoLayersInstanciated.indexOf(sourceId) > -1\n      if (\n        refLayer.visible === true &&\n        !cartoLayerInstanciated &&\n        !cartoLayersToInstanciate.find((l) => l.sourceId === sourceId)\n      ) {\n        cartoLayersToInstanciate.push({ sourceId, sourceCartoSQL, refLayer })\n      }\n      continue\n    }\n\n    style = updateGLLayer(style, glLayer.id, refLayer)\n  }\n\n  if (cartoLayersToInstanciate.length) {\n    dispatch(instanciateCartoLayers(cartoLayersToInstanciate))\n  }\n\n  dispatch(setMapStyle(style))\n}\n","import tbbox from '@turf/bbox'\nimport { targetMapVessel } from '../map'\n\nimport {\n  getTilePromises,\n  getCleanVectorArrays,\n  groupData,\n  addTracksPointsRenderingData,\n  getTracksPlaybackData,\n} from '../utils/heatmapTileData'\nimport { startLoader, completeLoader } from '../module/module.actions'\n\nexport const ADD_TRACK = 'ADD_TRACK'\nexport const UPDATE_TRACK = 'UPDATE_TRACK'\nexport const REMOVE_TRACK = 'REMOVE_TRACK'\n\nconst getTrackDataParsed = (geojson) => {\n  const time = { start: Infinity, end: 0 }\n  if (geojson && geojson.features) {\n    geojson.features.forEach((feature) => {\n      const hasTimes =\n        feature.properties.coordinateProperties.times &&\n        feature.properties.coordinateProperties.times.length > 0\n      if (hasTimes) {\n        feature.properties.coordinateProperties.times.forEach((datetime) => {\n          if (datetime < time.start) {\n            time.start = datetime\n          } else if (datetime > time.end) {\n            time.end = datetime\n          }\n        })\n      }\n    })\n  }\n  return {\n    geojson,\n    timelineBounds: [time.start, time.end],\n  }\n}\n\nconst getTrackBounds = (geojson) => {\n  const bounds = tbbox(geojson)\n  return {\n    minLat: bounds[3],\n    minLng: bounds[0],\n    maxLat: bounds[1],\n    maxLng: bounds[2],\n  }\n}\n\n// Deprecated tracks format parsing\nconst getOldTrackBoundsFormat = (data, addOffset = false) => {\n  const time = {\n    start: Infinity,\n    end: 0,\n  }\n  const geo = {\n    minLat: Infinity,\n    maxLat: -Infinity,\n    minLng: Infinity,\n    maxLng: -Infinity,\n  }\n  for (let i = 0, length = data.datetime.length; i < length; i++) {\n    const datetime = data.datetime[i]\n    if (datetime < time.start) {\n      time.start = datetime\n    } else if (datetime > time.end) {\n      time.end = datetime\n    }\n\n    const lat = data.latitude[i]\n    if (lat < geo.minLat) {\n      geo.minLat = lat\n    } else if (lat > geo.maxLat) {\n      geo.maxLat = lat\n    }\n\n    let lng = data.longitude[i]\n    if (addOffset === true) {\n      if (lng < 0) {\n        lng += 360\n      }\n    }\n    if (lng < geo.minLng) {\n      geo.minLng = lng\n    } else if (lng > geo.maxLng) {\n      geo.maxLng = lng\n    }\n  }\n\n  // track crosses the antimeridian\n  if (geo.maxLng - geo.minLng > 350 && addOffset === false) {\n    return getOldTrackBoundsFormat(data, true)\n  }\n\n  return {\n    time: [time.start, time.end],\n    geo,\n  }\n}\n\nfunction loadTrack(track) {\n  return (dispatch, getState) => {\n    const { id, url, type, fitBoundsOnLoad, layerTemporalExtents, color, data } = track\n    const state = getState()\n    if (state.map.tracks.data.find((t) => t.id === id)) {\n      return\n    }\n\n    const payload = {\n      id,\n      url,\n      type,\n      color,\n      fitBoundsOnLoad,\n    }\n    const trackHasData = track.data !== undefined && track.data !== null\n    const trackHasUrl = url !== undefined && url !== null && url !== ''\n    if (trackHasData) {\n      payload.data = data\n      payload.geoBounds = getTrackBounds(data)\n    }\n    dispatch({ type: ADD_TRACK, payload })\n\n    if (trackHasData || !trackHasUrl) {\n      return\n    }\n\n    const loaderID = startLoader(dispatch, state)\n    if (type !== 'geojson') {\n      // Deprecated tracks format logic to be deleted some day\n      const token = state.map.module.token\n      const promises = getTilePromises(url, token, layerTemporalExtents, { seriesgroup: id })\n\n      Promise.all(promises.map((p) => p.catch((e) => e))).then((rawTileData) => {\n        const cleanData = getCleanVectorArrays(rawTileData)\n\n        if (!cleanData.length) {\n          return\n        }\n        const rawTrackData = groupData(cleanData, [\n          'latitude',\n          'longitude',\n          'datetime',\n          'series',\n          'weight',\n          'sigma',\n        ])\n\n        const vectorArray = addTracksPointsRenderingData(rawTrackData)\n        const bounds = getOldTrackBoundsFormat(rawTrackData)\n\n        dispatch({\n          type: UPDATE_TRACK,\n          payload: {\n            id,\n            data: getTracksPlaybackData(vectorArray),\n            geoBounds: bounds.geo,\n            timelineBounds: bounds.time,\n          },\n        })\n        dispatch(completeLoader(loaderID))\n      })\n    } else {\n      fetch(url)\n        .then((res) => {\n          if (res.status >= 400) throw new Error(res.statusText)\n          return res.json()\n        })\n        .then((data) => {\n          const { geojson, timelineBounds } = getTrackDataParsed(data)\n          const geoBounds = getTrackBounds(data)\n          dispatch({\n            type: UPDATE_TRACK,\n            payload: {\n              id,\n              data: geojson,\n              geoBounds,\n              timelineBounds,\n            },\n          })\n          if (fitBoundsOnLoad) {\n            targetMapVessel(id)\n          }\n        })\n        .catch((err) => console.warn(err))\n        .finally(() => dispatch(completeLoader(loaderID)))\n    }\n  }\n}\n\nconst removeTrack = (trackId) => ({\n  type: REMOVE_TRACK,\n  payload: {\n    trackId,\n  },\n})\n\nexport const updateTracks = (newTracks = []) => (dispatch, getState) => {\n  const prevTracks = getState().map.tracks.data\n  // add and update layers\n  if (newTracks) {\n    newTracks.forEach((newTrack) => {\n      const trackId = newTrack.id\n      const prevTrack = prevTracks.find((t) => t.id === trackId)\n      if (prevTrack === undefined) {\n        dispatch(loadTrack(newTrack))\n      } else if (prevTrack.color !== newTrack.color) {\n        dispatch({\n          type: UPDATE_TRACK,\n          payload: {\n            id: newTrack.id,\n            color: newTrack.color,\n          },\n        })\n      }\n    })\n  }\n\n  // clean up unused tracks\n  prevTracks.forEach((prevTrack) => {\n    if (!newTracks || !newTracks.find((t) => t.id === prevTrack.id)) {\n      dispatch(removeTrack(prevTrack.id))\n    }\n  })\n}\n","import PropTypes from 'prop-types'\n\nconst withReducerPropTypes = (name, propTypesSchema) => (reducer) => {\n  if (process.env.NODE_ENV === 'development') {\n    return (state, action) => {\n      const result = reducer(state, action)\n      PropTypes.checkPropTypes(propTypesSchema, result, 'reducer', name)\n\n      return result\n    }\n  }\n  return reducer\n}\n\nexport default withReducerPropTypes\n","import PropTypes from 'prop-types'\nimport withReducerTypes from '../utils/withReducerTypes'\nimport {\n  INIT_MODULE,\n  SET_TEMPORAL_EXTENT,\n  SET_HIGHLIGHT_TEMPORAL_EXTENT,\n  START_LOADER,\n  COMPLETE_LOADER,\n} from './module.actions'\n\nconst initialState = {\n  loaders: null,\n  token: undefined,\n  temporalExtent: [new Date(1970), new Date()],\n  highlightTemporalExtent: null,\n  onViewportChange: undefined,\n  onHover: undefined,\n  onClick: undefined,\n  onLoadStart: undefined,\n  onLoadComplete: undefined,\n  onClosePopup: undefined,\n  onAttributionsChange: undefined,\n}\n\nconst moduleReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case INIT_MODULE: {\n      return {\n        ...state,\n        ...action.payload,\n      }\n    }\n\n    case SET_TEMPORAL_EXTENT: {\n      return {\n        ...state,\n        temporalExtent: action.payload,\n      }\n    }\n\n    case SET_HIGHLIGHT_TEMPORAL_EXTENT: {\n      return {\n        ...state,\n        highlightTemporalExtent: action.payload,\n      }\n    }\n\n    case START_LOADER: {\n      const loaders = state.loaders !== null ? [...state.loaders] : []\n      loaders.push(action.payload)\n      return { ...state, loaders }\n    }\n\n    case COMPLETE_LOADER: {\n      const loaders = [...state.loaders]\n      const loaderIndex = loaders.findIndex((l) => l === action.payload)\n      loaders.splice(loaderIndex, 1)\n      return { ...state, loaders }\n    }\n\n    default:\n      return state\n  }\n}\n\nconst moduleTypes = {\n  loaders: PropTypes.arrayOf(PropTypes.number),\n  token: PropTypes.string,\n  temporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  onViewportChange: PropTypes.func,\n  onHover: PropTypes.func,\n  onClick: PropTypes.func,\n  onLoadStart: PropTypes.func,\n  onLoadComplete: PropTypes.func,\n  onClosePopup: PropTypes.func,\n  onAttributionsChange: PropTypes.func,\n}\n\nexport default withReducerTypes('module', moduleTypes)(moduleReducer)\n","import PropTypes from 'prop-types'\nimport { trackTypes } from '../proptypes/tracks'\nimport withReducerTypes from '../utils/withReducerTypes'\n\nimport { ADD_TRACK, UPDATE_TRACK, REMOVE_TRACK } from './tracks.actions'\n\nconst initialState = {\n  data: [],\n}\n\nconst tracksReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case ADD_TRACK: {\n      const data = [...state.data, action.payload]\n      return { ...state, data }\n    }\n\n    case UPDATE_TRACK: {\n      const trackData = action.payload\n      const data = state.data.map((track) => {\n        if (track.id !== trackData.id) return track\n        return {\n          ...track,\n          ...trackData,\n        }\n      })\n      return { ...state, data }\n    }\n\n    case REMOVE_TRACK: {\n      const removedTrackId = action.payload.trackId\n      const data = state.data.filter((track) => track.id !== removedTrackId)\n      return { ...state, data }\n    }\n\n    default:\n      return state\n  }\n}\n\nconst tracksTypes = {\n  data: PropTypes.arrayOf(\n    PropTypes.exact({\n      ...trackTypes,\n      data: PropTypes.object,\n      timelineBounds: PropTypes.array,\n      geoBounds: PropTypes.exact({\n        minLat: PropTypes.number,\n        minLng: PropTypes.number,\n        maxLat: PropTypes.number,\n        maxLng: PropTypes.number,\n      }),\n    })\n  ),\n}\n\nexport default withReducerTypes('tracks', tracksTypes)(tracksReducer)\n","import uniq from 'lodash/uniq'\nimport {\n  INIT_HEATMAP_LAYERS,\n  UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES,\n  ADD_HEATMAP_LAYER,\n  UPDATE_HEATMAP_LAYER_STYLE,\n  REMOVE_HEATMAP_LAYER,\n  ADD_REFERENCE_TILE,\n  UPDATE_HEATMAP_TILE,\n  RELEASE_HEATMAP_TILES,\n  HIGHLIGHT_VESSELS,\n  UPDATE_LOADED_TILES,\n  HIGHLIGHT_CLICKED_VESSEL,\n  CLEAR_HIGHLIGHT_CLICKED_VESSEL,\n} from './heatmap.actions'\n\nconst initialState = {\n  // a dict of heatmap layers (key is layer id)\n  // each containing data, url, tiles, visibleTemporalExtentsIndices\n  heatmapLayers: {},\n  // store a list of tiles currently visible in the map\n  // those are necessary when adding a new layer to know which tiles need to be loaded\n  referenceTiles: [],\n  highlightedVessels: { isEmpty: true },\n  highlightedClickedVessel: null,\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case INIT_HEATMAP_LAYERS: {\n      return Object.assign({}, state, { heatmapLayers: action.payload })\n    }\n\n    case UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES: {\n      const heatmapLayers = state.heatmapLayers\n      let indices = heatmapLayers[action.payload.layerId].visibleTemporalExtentsIndices\n      indices = uniq(indices.concat(action.payload.indicesAdded))\n      heatmapLayers[action.payload.layerId].visibleTemporalExtentsIndices = indices\n      return Object.assign({}, state, heatmapLayers)\n    }\n\n    case ADD_HEATMAP_LAYER: {\n      const heatmapLayers = Object.assign({}, state.heatmapLayers, {\n        [action.payload.id]: {\n          tiles: [],\n          ...action.payload,\n        },\n      })\n      return Object.assign({}, state, { heatmapLayers })\n    }\n\n    case UPDATE_HEATMAP_LAYER_STYLE: {\n      const newLayer = action.payload\n      const layer = { ...state.heatmapLayers[newLayer.id], ...newLayer }\n      const heatmapLayers = { ...state.heatmapLayers, [newLayer.id]: layer }\n      return { ...state, heatmapLayers }\n    }\n\n    case REMOVE_HEATMAP_LAYER: {\n      const heatmapLayers = Object.assign({}, state.heatmapLayers)\n      delete heatmapLayers[action.payload.layerId]\n      return Object.assign({}, state, { heatmapLayers })\n    }\n\n    case ADD_REFERENCE_TILE: {\n      return Object.assign({}, state, { referenceTiles: [...state.referenceTiles, action.payload] })\n    }\n\n    case UPDATE_HEATMAP_TILE: {\n      const layerId = action.payload.layerId\n      const newTile = action.payload.tile\n      const layer = { ...state.heatmapLayers[layerId] }\n      let layerTiles = [...layer.tiles]\n      const tileIndex = layerTiles.findIndex((t) => t.uid === newTile.uid)\n      if (tileIndex === -1) {\n        layerTiles.push(newTile)\n      } else {\n        layerTiles = [layerTiles.slice(0, tileIndex), newTile, layerTiles.slice(tileIndex + 1)]\n      }\n      layer.tiles = layerTiles\n      const heatmapLayers = { ...state.heatmapLayers, [layerId]: layer }\n      return { ...state, heatmapLayers }\n    }\n\n    case RELEASE_HEATMAP_TILES: {\n      const uids = action.payload\n\n      // remove tiles\n      const layerIds = Object.keys(state.heatmapLayers)\n      const heatmapLayers = { ...state.heatmapLayers }\n      layerIds.forEach((layerId) => {\n        const prevLayer = { ...heatmapLayers[layerId] }\n        uids.forEach((tileUid) => {\n          const releasedTileIndex = prevLayer.tiles.findIndex((tile) => tile.uid === tileUid)\n          if (releasedTileIndex > -1) {\n            // console.log('releasing', layerId, tileUid);\n            prevLayer.tiles.splice(releasedTileIndex, 1)\n          }\n        })\n      })\n\n      // remove reference tiles\n      let referenceTiles = [...state.referenceTiles]\n      uids.forEach((tileUid) => {\n        const releasedRefTileIndex = referenceTiles.findIndex((tile) => tile.uid === tileUid)\n        if (releasedRefTileIndex > -1) {\n          referenceTiles = [\n            ...referenceTiles.slice(0, releasedRefTileIndex),\n            ...referenceTiles.slice(releasedRefTileIndex + 1),\n          ]\n        }\n      })\n\n      return { ...state, heatmapLayers, referenceTiles }\n    }\n\n    case UPDATE_LOADED_TILES: {\n      const newHeatmapLayers = { ...state.heatmapLayers }\n      return { ...state, heatmapLayers: newHeatmapLayers }\n    }\n\n    case HIGHLIGHT_VESSELS: {\n      return Object.assign({}, state, { highlightedVessels: action.payload })\n    }\n\n    case HIGHLIGHT_CLICKED_VESSEL: {\n      return { ...state, highlightedClickedVessel: action.payload }\n    }\n\n    case CLEAR_HIGHLIGHT_CLICKED_VESSEL: {\n      return { ...state, highlightedClickedVessel: null }\n    }\n\n    default:\n      return state\n  }\n}\n","import uniq from 'lodash/uniq'\nimport {\n  SET_CURRENTLY_VISIBLE_TILES,\n  SET_CURRENTLY_LOADED_TILES,\n  SET_CURRENTLY_SWAPPED_TILE_UIDS,\n  MARK_TILES_UIDS_AS_LOADED,\n  RELEASE_MARKED_TILES_UIDS,\n} from './heatmapTiles.actions'\n\nconst initialState = {\n  currentVisibleTiles: [],\n  currentLoadedTiles: [],\n  currentToLoadTileUids: [],\n  currentToReleaseTileUids: [],\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case SET_CURRENTLY_VISIBLE_TILES: {\n      const currentVisibleTiles = [].concat(action.payload)\n      return { ...state, currentVisibleTiles }\n    }\n\n    case SET_CURRENTLY_LOADED_TILES: {\n      const currentLoadedTiles = [].concat(action.payload)\n      return { ...state, currentLoadedTiles }\n    }\n\n    case SET_CURRENTLY_SWAPPED_TILE_UIDS: {\n      const currentToLoadTileUids = uniq(\n        state.currentToLoadTileUids.concat(action.payload.tilesToLoadUids)\n      )\n      const currentToReleaseTileUids = uniq(\n        state.currentToReleaseTileUids.concat(action.payload.tilesToReleaseUids)\n      )\n      // clean to load tiles of tiles that needs to be released\n      const newToLoadTilesUids = currentToLoadTileUids.filter(\n        (tileUid) => currentToReleaseTileUids.indexOf(tileUid) === -1\n      )\n      return { ...state, currentToLoadTileUids: newToLoadTilesUids, currentToReleaseTileUids }\n    }\n\n    case MARK_TILES_UIDS_AS_LOADED: {\n      const currentToLoadTileUids = state.currentToLoadTileUids\n      const tileUidsMarkedAsLoaded = action.payload\n      const newCurrentToLoadTileUids = currentToLoadTileUids.filter(\n        (tileUid) => tileUidsMarkedAsLoaded.indexOf(tileUid) === -1\n      )\n      return { ...state, currentToLoadTileUids: newCurrentToLoadTileUids }\n    }\n\n    case RELEASE_MARKED_TILES_UIDS: {\n      return { ...state, currentToReleaseTileUids: [] }\n    }\n\n    default:\n      return state\n  }\n}\n","import { FlyToInterpolator } from 'react-map-gl'\nimport { easeCubic } from 'd3-ease'\nimport { MIN_ZOOM_LEVEL, MAX_ZOOM_LEVEL } from '../config'\nimport { TRANSITION_TYPE } from '../constants'\nimport {\n  SET_VIEWPORT,\n  UPDATE_VIEWPORT,\n  SET_ZOOM_INCREMENT,\n  SET_MOUSE_LAT_LONG,\n  TRANSITION_END,\n  SET_NATIVE_VIEWPORT,\n} from './viewport.actions'\n\nconst DEFAULT_TRANSITION = {\n  transitionDuration: 500,\n  transitionInterpolator: new FlyToInterpolator(),\n  transitionEasing: easeCubic,\n}\n\nconst initialState = {\n  viewport: {\n    latitude: 0,\n    longitude: 0,\n    zoom: 3,\n    bearing: 0,\n    pitch: 0,\n    width: 1000,\n    height: 800,\n  },\n  maxZoom: MAX_ZOOM_LEVEL,\n  minZoom: MIN_ZOOM_LEVEL,\n  prevZoom: 3,\n  currentTransition: null,\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case SET_VIEWPORT: {\n      return {\n        ...state,\n        viewport: action.payload,\n        canZoomIn: action.payload.zoom < state.maxZoom,\n        canZoomOut: action.payload.zoom > state.minZoom,\n        prevZoom: state.viewport.zoom,\n      }\n    }\n\n    case UPDATE_VIEWPORT: {\n      const viewport = { ...state.viewport, ...action.payload }\n      return {\n        ...state,\n        viewport,\n        prevZoom: viewport.zoom,\n      }\n    }\n\n    case SET_ZOOM_INCREMENT: {\n      const currentZoom = state.viewport.zoom\n      const zoom = Math.min(\n        state.maxZoom,\n        action.payload.zoom || currentZoom + action.payload.increment\n      )\n      const viewport = {\n        ...state.viewport,\n        ...DEFAULT_TRANSITION,\n        zoom,\n        latitude:\n          action.payload.latitude === null ? state.viewport.latitude : action.payload.latitude,\n        longitude:\n          action.payload.longitude === null ? state.viewport.longitude : action.payload.longitude,\n      }\n      return {\n        ...state,\n        viewport,\n        canZoomIn: zoom < state.maxZoom,\n        canZoomOut: zoom > state.minZoom,\n        prevZoom: state.viewport.zoom,\n        currentTransition: TRANSITION_TYPE.ZOOM,\n      }\n    }\n\n    case SET_MOUSE_LAT_LONG: {\n      return { ...state, mouseLatLong: action.payload }\n    }\n\n    case TRANSITION_END: {\n      return { ...state, currentTransition: null }\n    }\n\n    case SET_NATIVE_VIEWPORT: {\n      return { ...state, ...action.payload }\n    }\n\n    default:\n      return state\n  }\n}\n","import { fromJS } from 'immutable'\nimport uniq from 'lodash/uniq'\nimport GL_STYLE from './gl-styles/style.json'\nimport {\n  SET_MAP_STYLE,\n  MARK_CARTO_LAYERS_AS_INSTANCIATED,\n  INIT_MAP_STYLE,\n  SET_STATIC_LAYERS,\n  SET_BASEMAP_LAYERS,\n} from './style.actions'\n\nconst attributions = uniq(\n  Object.keys(GL_STYLE.sources)\n    .map((sourceKey) => GL_STYLE.sources[sourceKey].attribution)\n    .filter((source) => source !== undefined)\n)\n\nconst setStyleDefaults = (style) => {\n  style.layers.forEach((layer) => {\n    if (layer.layout === undefined) {\n      layer.layout = {}\n    }\n    if (layer.paint === undefined) {\n      layer.paint = {}\n    }\n    // initialize time filter for time-filterable layers\n    if (layer.metadata && layer.metadata['gfw:temporal'] === true) {\n      layer.filter = ['all', ['>', 'timestamp', 0], ['<', 'timestamp', 999999999999]]\n    }\n    // set all layers to not visible except layers explicitely marked as visible (default basemap)\n    if (layer.layout.visibility !== 'visible') {\n      layer.layout.visibility = 'none'\n    }\n  })\n  return style\n}\n\nconst initialState = {\n  mapStyle: fromJS(setStyleDefaults(GL_STYLE)),\n  cartoLayersInstanciated: [],\n  staticLayers: [],\n  basemapLayers: [],\n  attributions,\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case INIT_MAP_STYLE: {\n      const newMapStyle = state.mapStyle.setIn(['glyphs'], action.payload.glyphsPath)\n      return { ...state, mapStyle: newMapStyle }\n    }\n    case SET_MAP_STYLE: {\n      return { ...state, mapStyle: action.payload }\n    }\n    case SET_STATIC_LAYERS: {\n      return { ...state, staticLayers: action.payload }\n    }\n    case SET_BASEMAP_LAYERS: {\n      return { ...state, basemapLayers: action.payload }\n    }\n    case MARK_CARTO_LAYERS_AS_INSTANCIATED: {\n      const cartoLayersInstanciated = [...state.cartoLayersInstanciated, ...action.payload]\n      return { ...state, cartoLayersInstanciated }\n    }\n    default:\n      return state\n  }\n}\n","// TODO MAP MODULE remove whole reducer\nimport { SET_MAP_CURSOR } from './interaction.actions'\n\nconst initialState = {\n  cursor: 'progress',\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case SET_MAP_CURSOR: {\n      return { ...state, cursor: action.payload }\n    }\n    default:\n      return state\n  }\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { compose, createStore, combineReducers, applyMiddleware } from 'redux'\nimport { Provider } from 'react-redux'\nimport thunk from 'redux-thunk'\nimport throttle from 'lodash/throttle'\nimport { trackTypes } from './proptypes/tracks'\nimport { heatmapLayerTypes, basemapLayerTypes, staticLayerTypes } from './proptypes/layers'\nimport { viewportTypes, popupTypes } from './proptypes/shared'\n\nimport Map from './glmap/Map.container'\nimport { initModule, setTemporalExtent, setHighlightTemporalExtent } from './module/module.actions'\nimport { fitToBounds, updateViewport, transitionToZoom } from './glmap/viewport.actions'\nimport { initStyle, commitStyleUpdates, applyTemporalExtent } from './glmap/style.actions'\nimport { updateTracks } from './tracks/tracks.actions'\nimport { updateHeatmapLayers, updateLayerLoadTemporalExtents } from './heatmap/heatmap.actions'\nimport GL_STYLE from './glmap/gl-styles/style.json'\n\nimport ModuleReducer from './module/module.reducer'\nimport TracksReducer from './tracks/tracks.reducer'\nimport HeatmapReducer from './heatmap/heatmap.reducer'\nimport HeatmapTilesReducer from './heatmap/heatmapTiles.reducer'\nimport ViewportReducer from './glmap/viewport.reducer'\nimport StyleReducer from './glmap/style.reducer'\nimport InteractionReducer from './glmap/interaction.reducer'\n\nconst mapReducer = combineReducers({\n  module: ModuleReducer,\n  tracks: TracksReducer,\n  heatmap: HeatmapReducer,\n  heatmapTiles: HeatmapTilesReducer,\n  style: StyleReducer,\n  viewport: ViewportReducer,\n  interaction: InteractionReducer,\n})\n\nlet composeEnhancers = compose\n\nif (\n  (process.env.MAP_REDUX_REMOTE_DEBUG || process.env.REACT_APP_MAP_REDUX_REMOTE_DEBUG) &&\n  process.env.NODE_ENV === 'development'\n) {\n  const composeWithDevTools = require('remote-redux-devtools').composeWithDevTools\n  composeEnhancers = composeWithDevTools({\n    name: 'Map module',\n    realtime: true,\n    hostname: 'localhost',\n    port: 8000,\n    maxAge: 30,\n    stateSanitizer: (state) => ({ ...state, map: { ...state.map, heatmap: 'NOT_SERIALIZED' } }),\n  })\n}\n\nconst store = createStore(\n  combineReducers({\n    map: mapReducer,\n  }),\n  {},\n  composeEnhancers(applyMiddleware(thunk))\n)\n\nconst throttleApplyTemporalExtent = throttle((temporalExtent) => {\n  store.dispatch(applyTemporalExtent(temporalExtent))\n  store.dispatch(setTemporalExtent(temporalExtent))\n}, 16)\n\nconst updateViewportFromIncomingProps = (incomingViewport) => {\n  store.dispatch(\n    updateViewport({\n      latitude: incomingViewport.center[0],\n      longitude: incomingViewport.center[1],\n      zoom: incomingViewport.zoom,\n    })\n  )\n}\n\nclass MapModule extends React.Component {\n  state = {\n    initialized: false,\n  }\n\n  componentDidCatch(error, errorInfo) {\n    console.log(error, errorInfo)\n    this.setState({\n      error: error,\n      errorInfo: errorInfo,\n    })\n  }\n\n  componentDidMount() {\n    // First trigger synchronous actions that should happen before any map render\n    // At the end of this, set a flag to allow map rendering\n\n    if (this.props.viewport !== undefined) {\n      updateViewportFromIncomingProps(this.props.viewport)\n    }\n\n    // TODO\n    if (this.props.glyphsPath !== undefined) {\n      store.dispatch(\n        initStyle({\n          glyphsPath: this.props.glyphsPath,\n          // TODO apply URL updates here\n        })\n      )\n    }\n\n    if (this.props.onAttributionsChange !== undefined) {\n      this.props.onAttributionsChange(store.getState().map.style.attributions)\n    }\n\n    if (store && store.getState().map.module.token === undefined) {\n      store.dispatch(\n        initModule({\n          token: this.props.token,\n          onViewportChange: this.props.onViewportChange,\n          onHover: this.props.onHover,\n          onClick: this.props.onClick,\n          onLoadStart: this.props.onLoadStart,\n          onLoadComplete: this.props.onLoadComplete,\n          onClosePopup: this.props.onClosePopup,\n          onAttributionsChange: this.props.onAttributionsChange,\n        })\n      )\n    }\n\n    if (this.props.highlightTemporalExtent !== null && this.props.highlightTemporalExtent.length) {\n      store.dispatch(setHighlightTemporalExtent(this.props.highlightTemporalExtent))\n    }\n\n    if (\n      (this.props.basemapLayers !== undefined && this.props.basemapLayers.length) ||\n      (this.props.staticLayers !== undefined && this.props.staticLayers.length)\n    ) {\n      store.dispatch(\n        commitStyleUpdates(this.props.staticLayers || [], this.props.basemapLayers || [])\n      )\n    }\n\n    if (this.props.tracks !== null) {\n      store.dispatch(updateTracks(this.props.tracks))\n    }\n\n    // Now trigger async actions\n\n    if (this.props.temporalExtent !== undefined && this.props.temporalExtent.length) {\n      throttleApplyTemporalExtent(this.props.temporalExtent)\n    }\n\n    // eslint-disable-next-line react/no-did-mount-set-state\n    this.setState({\n      initialized: true,\n    })\n  }\n\n  componentDidUpdate(prevProps) {\n    // tracks\n    if (this.props.tracks !== prevProps.tracks) {\n      store.dispatch(updateTracks(this.props.tracks))\n    }\n\n    // heatmap layers\n    if (this.props.heatmapLayers !== prevProps.heatmapLayers) {\n      store.dispatch(updateHeatmapLayers(this.props.heatmapLayers, this.props.loadTemporalExtent))\n    }\n\n    // basemap / static layers\n    if (\n      (this.props.basemapLayers !== undefined && this.props.basemapLayers.length) ||\n      (this.props.staticLayers !== undefined && this.props.staticLayers.length)\n    ) {\n      store.dispatch(\n        commitStyleUpdates(this.props.staticLayers || [], this.props.basemapLayers || [])\n      )\n    }\n\n    // loadTemporalExtent\n    if (this.props.loadTemporalExtent !== undefined && this.props.loadTemporalExtent.length) {\n      if (\n        prevProps.loadTemporalExtent === undefined ||\n        !prevProps.loadTemporalExtent.length ||\n        this.props.loadTemporalExtent[0].getTime() !== prevProps.loadTemporalExtent[0].getTime() ||\n        this.props.loadTemporalExtent[1].getTime() !== prevProps.loadTemporalExtent[1].getTime()\n      ) {\n        store.dispatch(updateLayerLoadTemporalExtents(this.props.loadTemporalExtent))\n      }\n    }\n    // temporalExtent\n    if (this.props.temporalExtent !== undefined && this.props.temporalExtent.length) {\n      if (\n        prevProps.temporalExtent === undefined ||\n        !prevProps.temporalExtent.length ||\n        this.props.temporalExtent[0].getTime() !== prevProps.temporalExtent[0].getTime() ||\n        this.props.temporalExtent[1].getTime() !== prevProps.temporalExtent[1].getTime()\n      ) {\n        throttleApplyTemporalExtent(this.props.temporalExtent)\n      }\n    }\n\n    // highlightTemporalExtent\n    if (this.props.highlightTemporalExtent !== null && this.props.highlightTemporalExtent.length) {\n      if (\n        prevProps.highlightTemporalExtent === null ||\n        !prevProps.highlightTemporalExtent.length ||\n        this.props.highlightTemporalExtent[0].getTime() !==\n          prevProps.highlightTemporalExtent[0].getTime() ||\n        this.props.highlightTemporalExtent[1].getTime() !==\n          prevProps.highlightTemporalExtent[1].getTime()\n      ) {\n        store.dispatch(setHighlightTemporalExtent(this.props.highlightTemporalExtent))\n      }\n    } else {\n      if (this.props.highlightTemporalExtent !== prevProps.highlightTemporalExtent) {\n        store.dispatch(setHighlightTemporalExtent(this.props.highlightTemporalExtent))\n      }\n    }\n\n    // viewport - since viewport will be updated internally to the module,\n    // we have to compare incoming props to existing viewport in store, ie:\n    // update viewport from incoming props ONLY if zoom or center is different\n    // from the internally stored one\n    // TODO FFS incoming lat lon should be an object, not an array\n    const currentViewport = store.getState().map.viewport.viewport\n    //                                        stop propagating updates from outside when zooming in\n    if (\n      this.props.viewport !== undefined &&\n      store.getState().map.viewport.currentTransition === null\n    ) {\n      if (\n        currentViewport.latitude !== this.props.viewport.center[0] ||\n        currentViewport.longitude !== this.props.viewport.center[1] ||\n        currentViewport.zoom !== this.props.viewport.zoom\n      ) {\n        // if zoom delta is precisely === 1, zoom with a transition\n        if (Math.abs(currentViewport.zoom - this.props.viewport.zoom) === 1) {\n          store.dispatch(transitionToZoom(this.props.viewport.zoom))\n        } else {\n          updateViewportFromIncomingProps(this.props.viewport)\n        }\n      }\n    }\n  }\n  render() {\n    if (this.state.error !== undefined) {\n      console.log(this.state.error)\n      return (\n        <div>\n          <h2>Map component crashed!</h2>\n          <p className=\"red\">{this.state.error && this.state.error.toString()}</p>\n          <div>Component Stack Error Details:</div>\n          <p className=\"red\">{this.state.errorInfo.componentStack}</p>\n        </div>\n      )\n    }\n    // won't render anything before actions in componentDidMount have been triggered\n    return this.state.initialized !== true ? null : (\n      <Provider store={store}>\n        <Map {...this.props} />\n      </Provider>\n    )\n  }\n}\n\nMapModule.propTypes = {\n  token: PropTypes.string,\n  viewport: PropTypes.shape(viewportTypes),\n  tracks: PropTypes.arrayOf(PropTypes.exact(trackTypes)),\n  heatmapLayers: PropTypes.arrayOf(PropTypes.shape(heatmapLayerTypes)),\n  temporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  highlightTemporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  loadTemporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  basemapLayers: PropTypes.arrayOf(PropTypes.shape(basemapLayerTypes)),\n  staticLayers: PropTypes.arrayOf(PropTypes.shape(staticLayerTypes)),\n  // customLayers\n  hoverPopup: PropTypes.shape(popupTypes),\n  clickPopup: PropTypes.shape(popupTypes),\n  glyphsPath: PropTypes.string,\n  onViewportChange: PropTypes.func,\n  onLoadStart: PropTypes.func,\n  onLoadComplete: PropTypes.func,\n  onClick: PropTypes.func,\n  onHover: PropTypes.func,\n  onAttributionsChange: PropTypes.func,\n  onClosePopup: PropTypes.func,\n}\n\nMapModule.defaultProps = {\n  highlightTemporalExtent: null,\n  tracks: null,\n}\n\nexport default MapModule\n\nexport const targetMapVessel = (id) => {\n  const track = store.getState().map.tracks.data.find((t) => t.id === id.toString())\n  store.dispatch(fitToBounds(track.geoBounds))\n\n  return track.timelineBounds\n}\n\n// TODO MAP MODULE make it a function\nexport const AVAILABLE_BASEMAPS = GL_STYLE.metadata['gfw:basemap-layers']\n","\n  import React from 'react'\n  import { MDXTag } from '@mdx-js/tag'\n  import { Playground, PropsTable } from 'docz'\nimport Map from './index.js'\n\nconst layoutProps = {\n  \n};\nexport default class MDXContent extends React.Component {\n  constructor(props) {\n    super(props)\n    this.layout = null\n  }\n  render() {\n    const { components, ...props } = this.props\n\n    return <MDXTag\n             name=\"wrapper\"\n             \n             components={components}>\n<MDXTag name=\"h1\" components={components} props={{\"id\":\"map\"}}>{`Map`}</MDXTag>\n<MDXTag name=\"h2\" components={components} props={{\"id\":\"description\"}}>{`Description`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`This component displays and load fishing activity and fishing-related layers on a map, used in various GFW projects:`}</MDXTag>\n<MDXTag name=\"ul\" components={components}>\n<MDXTag name=\"li\" components={components} parentName=\"ul\"><MDXTag name=\"a\" components={components} parentName=\"li\" props={{\"href\":\"https://github.com/GlobalFishingWatch/map-client/blob/9c5179358d4870c0fd4c2c0742917e72e6025c59/app/src/map/components/MapWrapper.jsx#L5\"}}>{`Map client`}</MDXTag></MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\"><MDXTag name=\"a\" components={components} parentName=\"li\" props={{\"href\":\"https://github.com/GlobalFishingWatch/vessel-profiles/blob/aa0e17395f6a4947bb3fdf3106cb9d0a744ba64f/src/profile/components/MapWrapper.js#L3\"}}>{`Vessel profiles`}</MDXTag></MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\"><MDXTag name=\"a\" components={components} parentName=\"li\" props={{\"href\":\"https://github.com/GlobalFishingWatch/data-portal/blob/96b1e24efcff58ade672a67229da0610d9d241ab/src/map/MapWrapper.jsx#L2\"}}>{`Data portal`}</MDXTag></MDXTag>\n</MDXTag>\n<MDXTag name=\"h2\" components={components} props={{\"id\":\"available-properties\"}}>{`Available properties`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`TODO: fix crash on PropsTable docz component`}</MDXTag>\n<MDXTag name=\"h2\" components={components} props={{\"id\":\"basic-usage\"}}>{`Basic usage`}</MDXTag>\n<Playground __codesandbox={`N4IgZglgNgpgziAXKCA7AJjAHgOgBYAuAtlEqAMYD2qBMNSIAPOhAG4AEE6AvADogAnSpQL8AfIwD0LVmJABfADQg0mXACsEyEFRp0CDSQCojvVO3YAVPBDjsAwpUwBlAIYYARpSzs8rux4wdOyuAK4ElESuBBDkrlBQAJ7sAOZ0MALRMOjsoXBoKWYWAAZUmHDu6F5YGcU47ACSYOyJlKEA5AIw7OShAhBtdniUAO7sBH4Evq4ADjPp6IotbT3uRT14MOQA1uxtU20C7OiU5EMZMIi-BAQzcIiSkikQE6EeOFREkqiUrGiJkjK8Eq1QyZnWTWWoXY2Hm_To5G67mScAIAlCKRSsDsIxeeHGNjsFU83iWM1g_m6mVsSPMtjgoRg62oqTxb3qiAAlGYjJIzBAiDNKAIpgAlGCuchTMBCIjsToSqXtADc_MFwrFioIABEAPIAWXYMsi8q6koIAFoTkQVWqhSKHJEhah9EbZfKcJJsK5BbBbagzOLzXr9TguhgMgAKdbMNhidYWRh4ADMYkc6pdNE46pF2XYuImPScwJJNQEiCkKfj5gs7EYMzEkYaUyiyRdedc6BYMWo8XYMyEd3GlFSMCmL3Y4cw_VQKXzMASnKkDYTdfTztdkmriekccUZhOvSI-hwaQIAFFYMeaAAhRINdCRzrCAjtbmoTnKhTKb2-mA4TQyB0ahaHoRAVBzKZ9VmN0TXaT04AEchJCiGZJFUbAALgf0BXtTVzVguUFXNdo7Q1dhgHYTQfHkQj5QAARgIgRAGVBAWFGBSIDVBdFRY5TgAL2cAhEmxdhuAo9YogEZ5UCudoAAZ2GTGYsHafcaxmTsWFneSABZVPYAA2VT1PWMAQIAMR9aBEnk_hnEORFHUwdgAAUhH4JZmJ-OAtMRMyawsmhnAgATLnYABGPSNPkcEeOoPiAEE5nE9hI0o8gbCgdBw3YeROXEsR0pjGR2FRUSYG4YBDyEkTsXkbda2ALLoFy4IADIOvGRJ5koZpWpyvLuBG-UwFCHie1Qdp2AAfg2Nrw0jQqrkG9rUDimspBkat3zMWFyMwMAwigKZlqKkqtpSlca0TIMpRwSzMhSa8CCa2s62gmZ2D-GARjw6rMv0DIrgAbQUnAFIAJiMpZIqh5McCMyKAF0lgE4QiCuABWfLaK3VcpHughHue16mqka7drMb8QEQ5DUPQiMNC0CgQP0BgDodSijpOgglgIVwZLHL6ADV4DgBcliS0WkoaAAZJKb3l88AH0byS5xz31JK3OcfK6PglDZi42n6eNtDUKwoDdFAgxwNw8jicNs0lTIh0PMoGZLF6-BDYHL2LRE-ZsPdqZMqdShJaWcgzVoYSOJjyIPDQGBxXQUJEQEOAllmclEn1Lh0FgEYhe6WjjSIroM7UsOKPcoQ_mnA3K9NLULWr0Ja9QR2HVeVBdlbhUa6DvAJu2Lje6mCYhBuWBDagJx_DwSQZ5EAg_Tryi0UlbYfZDlv3SNgOZmD-BV8yHZQ57yD682aJUPl1xEgyff4CWDxKUf5_X99nPysFjEcgT8X4CDfnYCuR9PQnzPnASQUAf7Z0nrfSiv1_oanAWSL2oRvZ_0PnBaBg5YGSDgH4auXE65fUNp6LEjMvofBAq4VOAhkF4XrmgF4-onChFgEsSWBBLBMXtPEc8WA7Z8LHAACQgCkPAUAZGEEETmERYjXSQIIShbhsBNEZ1gDgc0rFr5T3rpAARlAbxtAwP_HB6AsiiwgH9PCAtMioHyFNSwlAABamN8FERoVARmaC8L6KlIY1h5FKIcIIMJSqSciBEBeDE2AABVGYtjaD_zzkkJRwioCiLtr4j0TwAmzBIfVf8BjErhO5rkNJWRLCX22BA6hF9d5wJ3lfEJU0jEoNqekmAkiJTEFmCAjI1i6m0FGQIeWlBOw5OFCou2zSh6envsMtCayraVNcdUqYABxeWqtnCWAAJoqxabQ0pWILQVWxGUyqWFqAUJvmwrhui07ZEzhkFpzF3k6J4f-TuWddlWEaXAdOXyjgrNaVfGFTSwyfOBXXQZD9ZgQqzi0zZpSsUzARRnJFLzyIovWZYaA8B0XfOhTiyQOLSXYjxZCkF9jHEagpVCqBxTAkOPQSKBlBLjFJI-fiylHLLloVuYCxFGQQUND0JfKabKLklLQmgWg8rWJ8ulfFXiLY0VSqOBJT4KcXRsrgBlKSWiIpvIBWyjSFgOlNKuA0tptr1g4quMS1Crqay0rJfcdgnrZh0vJfqu1ADKpXEFd6iwQSNRXGZTygg0bOByu2VcWVartneoKvFWAUxPhCklueVAfgeJjLSgWqOTJuIQGaJGAOiI4BwBwHQVgOAdZuVVqKc82pkkAA0u3a11JYNW2pzw3mSXs9gXV-xCEbc21tOAAByuox2q3PEu0W4lRrtEwKwBcXtXpvkkjWHVRZ1SSwAOp4m1DAVgHjKBQDsBJLoABHUIEAuhPi6MxWgHdPlYCtHeiIj7sKcgYRemA16Ji3vvcIJ96xK1FpLe4LOz7z2Fqgzeu9D6n3mtuuwVAPoIrtCob8gFgUPpmlOgKCKaJGRhosMMVERHjzyUXnEKAzHXyMf7HG9gAAOBSwneNRCwElNIVxkwKV46iLIbge4xHCuWdKcnaCFW4MVDK7AcC6bUzAbyswriUV0zgfTOBUJLHdfKFdlgjnnlFA0JK8sGieJ7TNWiBUw05o2tqxKUxUQcQrXHGACcv2IeTqnU1-GPqoSuF60N6wvPrGAEoCLkHi2lrQ5GLJBci4lzLpGfu2xOTvj2glVx088Czw3jAa62ShELLyaorMEk15zxgJGIrjXMjNbthp4qwB1iBa6DgFgflohZRy3MBryi-v6G63N_J-hSvDYiKN8bWkCBTf4fM3ry2aCLdyQdggq2NpwyMuVs9Ni7Hcrwk9SIsrPgFE9kOCSkY0DPdnAmvCA2T0WBG_-Tbk28DRgIzd2gP2NQxY-uwBBMQCChEwFcT7kQChQ95YiOV4M0argsIvWcLwkcRVRwk77d2NQfGBgIUGqNeMWAxpEFHCUycpAxyTRnRBeM-YsO-TaZhyAIKbewL61r57YFAugOwxMcDrmoK6IbNZ9NpUVx9KJEB4hhWyFcY6T6DNJfihYStmYdRcHsCDyMGQhACCWFb4UsqLKFVV7WXij7_yLxSJbgQ1vbfe_t6gR3q4Ji2DM2OYSWQYcfTtyp6P9OYR-4EA7ygVxo9J-5--Cw_PT2RxN9qLgXCJoEHOs7iwjx2CWU_XxNEMi0hHDgIkHi1XqCDBCKExKBJojlWGDwnIfg5jBECBZLoIRUDJFQpOOg05Vxl6SlV7ok-9jNGD__fhIQjQILnBEEICRRjsHH1ODIBRDe1lrelZfOAT7NtjQ6AAhKNCaR1U7oCd3jvpt2WUige0QJ7aPZyvbNefpfjgNfqdquFnh9GXpYKurqKuKfkVoSBfoOM2liL1HgHAG5NEPiHfhJA_jAJAC6M_v9rDoDmNrYFtlNq_hYFEoKpHrDhYCgTMGgRgRMFcIAUgaeEkIwegZgXHhAZIFYNASEDNskMkqKPLG_hkr4BcJQflBnrDnIZnsflQXWmwV7M2tQLPtXh4OEIYvYKWmkOwNgbkBGPgdkC_gRvaggUARoTcP0Nod0noe4GkJGCQWeOHrQMtBZrMGZuUvorYRAPYYYgoflEoZwHWoDtOt1K4WHoAp1uBlbORnohENsMECNDgSYU_uYXQSQcDttqDjIVEmLp1iXnQcOCkXJASCHkAckXQLwbWNQOzo4bOHRlYewQ0RTiKE0WkHURYNQJIr8CDJUc2tYagP0fujbjIb0agPYPIjsKwa0WoTgNQDMbENsD0XsKgDMp2OHiKPMVUW0ZsbMugDsfzJMRsVsegOuHmi0fsYsdQBcVcWOPrhYbDssYvJLG5NgjMHscMQcTMVWp8TMDgusTYVoToYlF0Tcb8XcagJoXYeCa4pCXUTzvIWAaEXAa_vAbcXcDgJ_JLN_KAnYEYbgaYTkDOqoTiXiUxCMogs2rALOBMIVAAD5MmYkUnNpqaxBTJEn34ZEEGRFDGIGLGcnAK0k4D0kpCMmrhZHEHrZA5kEW4yGfAJLRLlKpL9IAELE4kincnsAsnsCgxoyClAFUkEnlr6mGnBG85oncRq4qFanNoOo8npGP4EEykfQ5EKl5GRgQ4wDOpXxYnQk4lOlnYfTgG1hl5Lq77V6YjfL-AN7kCt7dLon2nYmOk9aLKujEl8l5jkkOk4C0BLYtYkwSmMlEEfTta1b1aJB7aZmHbskFkZnzY0DBHhml78HwDyI0BWi2CuAeCwAWguhiIWhdlUhajfCUA9noAWjMSF43Jjg3KxFB4IH8LuHFGv7q6a7hToCsHojPFhlyHhnG76B57oDqkR4Dh3r_7unsBl5OmwGplBmOlgqGGjSXmsD_4Flgo3kA5ymkETbem-n-lNKBlCnBnfmtmhFl44pw60kPln75k4q6lGHvmflIW0k_kAIcT_nkGg6-mBozDcmgVAHoWEkCz5mLxzJNknahm1htm3n8GmkwT8EimwWEnwVg50HEXsFMWEW0mvkul4FP4CkNm8Xcnil0CSl4DMmskvHcXCmAJcn8XZmum5ndQNk6limlnSXSnlm1iekAUUEvFG6RAqmCrnkZLyXamKWimEl6lMkGlGmiVfw0l2UWkoxWnsCQW2kRn8GUXoC1nNmiAEZwENn-WBUnYCXGGqVknqUUVHERXFkSUMnSV6XKGXSlGzpXnsHhXUXFnbqCWkn2UyE36oU5UJV5V2zJVSXFXGXGnlVUVFl2w46nhjikrHjnQoVdAfkNUBWVX6AtVnjtVxG1WZVhUVVNUDWoytUCK0adVvndWfm5WTU0C04owzXDXLSv6YW_nYW5FTa-lTIXGJVLJWV0kTXHbFm0Vhk2l8HjD9U0AcUNmFmXUFIqVCX8l5lpmNkrUlmSVlklHpWcWlFlWLEvVNaRVpHRUfV5gsklWg3BkPV_UpWjWlHPVI2DVtVzWFRdXZVg0Y0KTrVDXY2o10Ho2_VrUbUk2409X40U3TXE0dWeU7UEg1awDVknULbk2vUrav6bQ3U-Xtm-AKLyKyICJI0cWv4Nk2CyKi2KJI1RUknCVdRS2IUi0KLi2_XVUTC6WA1hEZUg2LXsEy1yIa2c2ta8kxWk2w6lVG2LEm1y2a0800Da34hw11XS3q1i3m0ECY2zVM0CVnEI3NoO1m0E1E1Y0B3u1jVq2y1h300R3-0jXYFB1204mh3e0Y0M2R1xHbVpX6V_n7Wg78LSJx2Z2_VnX4Be3y2_XXV0U2nT78EgHsAWjlSfbdDN24gJDsCBASF5iqoZBEYJDJBb4TDdCJH7m-XzjTD7rDgYZlwppfZziX5z3YC2AxCzg_QdHjjmCA5LAOKICN191b0f7Sjuik4FCzpqHsC6hLrywnL62c57BHBY5qqcB2AsBgBgAXCPUEZl6txj0ppqpD1JBYXVwbHVp3VQF6jl6WT6wX2b3w5w4sikJtA5Q920h7AeDqBbD8yEYiAj4hDe7Pyrhnq9De76Ds5pTRGqkR7xHeEgHAHb1H2ZWsNsPsNYXfQnyuApDRCX2-l2Ctz7D5CuQjCbDmCc6X1oCS0vENnN3vVFUq0vE0NrmeFWyMPkPhgCIuJuKsQFWEY8JQC60bl1pKl9BaPs7il8OI6uRGFyPb1U7Y6E3W0fSaOUMOME7PA2PdB2P5kaPU5rUuMu7mPuOn04BP2-PfWMOc55161C2n5P2YCnSuDv1ZXkA0igNQ2RTow-IFj4gpM7yuIvCsQFF1rQQTD6IeBmpuM0CWNP2t32NhOc4aajSRQs27UbZelTaFO6PUAeLeKRCV3ROYx11hkwh6750fS-ns5f4_6s7_5DPb2eWKEvH83101hrMH4CDF5PUrmxEtoJ6K05mEF62u56Ie6gXmbR6eVdCI4CDmDA10GxiyBnFJhQxiBULHlZixzLzZA36VjvOvPfSC7-BwBLrEZ8CCDZDiDADn5XOHNfUcn7PR4FmUDCQzie6cjyDLjvSlHPNpg56ujh47DsDniHO3qCzQD3DbRxhAs9BC5gsQv8DVwwtwvIsJ5J4QYbghSCw7DYuSA3SZU0svMvHeV3UjBPJTBbMj6JDB6b2D5BbbJ2BoAYby40CnkF5Zh-Cz2BDBAxm17QsEa3N9DmBstZA4CbnyLblRX0bdDzSoCGPsBXCPO1iMCexNzfKA7VSA6NQyGMBULACmbsn4y4s7jutcAZC4uHlmBZ6i6WpgXgIq7rA1EVGvbgI-EYthogFXBpt_xmZ96dYgHgKchhpOk5uDjptCyZCJC6hgCRi5shwtpYDmhFaNLFsltupDJmnZzlteyVvEM1t1sNvwD5uzCdakW_whylaltI29u4KNtVvPy1v1sVt5toByZlrLvahZDTturV1O0Q3Flzv9vVvLvDvNrruCybt1vbvqYds1jLXO0EDHt5uLuDsrt9truVaoYwBbs7v3sWBiW0kvsLsDtnuruNukJjuRhAegLtthqaWEkgcjtvvgefuQcFsuE2VTLwfrBl69CBZEDcluoDECCAk4LIccmYdChAnzvwAAf0urHkffENzocjtQfzD1pfHFthoMFMGYGUcZsFBhrtGn2QmCfjQ8QieHHbGCy7Gsd0fNqSfkDScPFOjXEScTQqfMjTGzHbCadSc6djGDHns4DKfSdwkBEIlwDicKfpvmc6f_EfFfEGfae-bcRcxTC8w8JQSzBFHxSedFiVbjBCxnhiwSwLhpQfaEGaZEFnoOrUN_luGxFqPeFOljbRCuBmeqBdanYXQkxcD6NcCovosFDLRyEGW4WRimIeIWIP4AGNKtXmKWJS5nbrDGv3PjCNcxDHijl1dWIxvxSQGCEdoi6rrJLnJRApGcBTApPKdTT7RYBsJnoyxyyKzKxqwaxawdr6wSQHJHKnIqwWZjidiZegztApBgAjCIC8Ujm0ntAow0xKB0xIQWwCtEJ_xwrNqATaC2wcwOy3znv-yDhBx_zPKBfxdtt4ISTO5cCCeogYsWvgowDvqfrZBhp9BQDw_V6zhI_iio_VxhpUCLwqamcI_CfJu-yCfy7LvndpCUCaBPJLBK0EEeVhoIJwdI3-qmeodDsQcodgd89sfNoOtECBACC7tBQvD9dS66gyc7l2d5teCPqxRPfKDmyMwwKfcc9jLWy_fsxgQQRsJA9Dwnyg8hzg9LfkRnoTtgLQ9EFw-K-Qc48pB48o8fqE_Jt-pjgPjY-ZvDZvBnx-8U81h_D5D9kRSmfK9QBhpjyR_88i-hBi8ZAif-QvB2RO8jui_i9hqQCnRjKCe88utk-Yd63QWMh7DjH9DlBsXfJx_638Kv5x-CfZ8p-v7_3QBqqizxCMjKt2ApMsBt5EYCDJAqtiOxD4iKj4gpGj_99Gid8ZB9nzyQALiLDt_8GVA_Q99-y2CENvuL7b5QB8ZNoBHzysDb92CRi6iijz_58S_r-cARR59d8X_GarC0ApDCgZ-gzYxLBGQowhEXiz_DIN3ygC99qe2DXBunnWAMd7404eHqX1XCT4hQqqbngnyWKQCpQvGWwG5BvCWRBO0fXjMTzgB3hwWbGTPuoUwGnECM4NfbMWTQHC99EgvD9opyYGnsherA1vhLwY72oue8sCWAQPgzeZwMtgfHh73R7rAB66qfdIIJV6DcPOVvB0Gelg6Ts_YMPSQQrzJ4u8s2tgU_vH0YGED5Bi3Zbv5gAR8NbKqg9DLD00HoDyeuPUQe7zR5r8aww3GBqN31DjdzkDQOwBME7zthMAOQTfqfjgAjgxGiQdYGHz0GyCY-w2BcLg21wUDcSQg2IbAClDZBLIQyPoPAAQHQcSiK_HKMH1nC8Zz-YA7IYkKL5aCMWDHZLD6n3YJCo-yQ2oViA1rpDMhXQBgawI47rkCM-QmwYwLsEpBihr_cocwMqEFBqhDHL2JKHT4t8k-OfCLCT0KGDDhswwEYE_ECBPpohYaKQQYhkGJDDBUvO_h0JPZLsOBJw99mMNnCS8qCNnPIBECxj7DGhAOQPlT0SE0862oMFnuj3lD09Ge00JYJ0H8BqoHuDHTHksLDTpJXAEAnBlgPWBYhoRUA-QWbFe6a8PuIcEhGQmyB682YegQ3sYhN5HwzesCS3iYOC40ccEibdQdnlxHPtEhPwTAOz2sbE5ZhyfAQG7wJ4SCH21ALxsyLpFzCMg7I8Qc4KzwQ9TBRbe3s7k5wsj5hp6anIX1GHoCuB97TaMiIZhXJlUkgehLbCYQug2RP3HEXbAYDGII4qAF0FKEKTEQpQ_6GuCCkyghZnAcQqUMKAtHtDHRr4LeHvgyBpBb0MAGYEsErgAApfWOoiIgCgiA4QJfpxA9GC4ASXxC0bpn-TaIJ6XSQxFhFtGjhtGbSQVMsigSegnSX3UPKkPWzfcekbCSiKhGM42498swFYiSxDFFIdhQ_FMYlDTEej-E7OZxO4F6aoBi0OQesUbEYZKtWxhKB0FQmhRfRnkZ6ZLuYN1LvZ9Mf2czFbAlQ-EZxcFbiFOJ96ppQk-6KZA-HQyxwhkoWN0cKGBqgxpxQCbkrjhcH8EoytAK4JsGHwjAkQTaJPt0F8FTAdeRwBoNqDsABwPWOQPJnvktTVi8iBIboAclr7ZwO8AWbvDlDw6MVugjYmILPWdE_A8GDiHqDMFiDxBQGgDPPkf0_H60UmCCDYZBNSaXlJYv9CwFh1XGEkBsq4RDrr2AHbNIwUAP7FAAtZbjkJ3QKGrawFIcTIhEffRra3oYzAusbEi6BxK4BlY_MwXMLrMGzFRd5xF0Rcd4WXGoRBUAuUwfJJmCCpgsh4h0UWJPHrAzxIsBSeUn_hDUwU2Yq8dRI0kWTOxOwbMX9hKJwEb8DqZyRPjubmB7JlUOAKEQ64-SvRMAH0WJN8nYh_RsoIMa213jOTo2H4WSXxHsn1JKA_-JSbESWCjBUA15C6DDmzZmDaAXhXFIwxAJhoxMAzB4apOKkONypmMMqWgAqlXAqpTDMJmTgqlE8-gIQlTM1KQkapyGXUsqeZIjQZivoNBecdsK4lsAYAu4qXFcDPAZpF-246aYgj3E0T1MsUK7KYNQh55DKeADxGlPexF0_sMOdsdvWdYgEXJq4Iui4THDs5IwF0w8oNJmCVjnW8OJYJ439FtD6OF0EotdIrGkdWJ0Qd6dyM-nRAshcAWimlhrCoRax-ndKG9OQZFCjQX0iGT9KuldNQcMMvToDLwYfTkZYM9oZDNLY6Nim1AXsc60ukEZrpPTUmT2IwDlcks0nJzjAGY4Uy0ZVMjGZGBjHOdaODMjZhtIC6KCvOeBPmEFzNFF4pI5klKf_iek7TcK-0pAmYE5CRgvo74VUW9wnqJiKkQ_EsTbAN72wQAoo4Lg0CXQNA7MHg3tOcgkjtATZZs1WBbIm7nguIRsviFrDswjp9Qbka_s5nXR9oR0S6SwGlHaBuzVYHsr2aKB9nng_ZG6SwM7KFlBdXZ54OzJIgaB7JJELmNOe7O1jhzI50cgOUHJDkpy05GcyRFnM9nezDkUc_2bHOMHW9TBxyJKKKDszyxdQSUMdDf2tkNym5qsFuW3IcxxzSRfEewAaDcgqwR0Pc1ue3KDnDzPZY8tWL3Pbkki65wXQosBPeyX5jpR09mRYGuklEg-jQU2ebM8HnheMWkUSEcSuCX5hBRgocoPICxycCAFxb5IdIxl8JYilMkysF38oZAHwaUF0GMFvZxEqaTNdYLvKDyvCu5zcyeQ5lPnPx_KVwb-YnmcGZ45CcBZqcmPuJHETiRzGKjeXQXxtMFsnIWEXnikWBApyDTsD_PQA3yXZ-adTk8SfkGp4ZRxKhZvNfkZi1yH8hOffKyBpRzxudakXxEQXoZdQVA_RCfxSCoAMoSgAqf-ASLxthFchMBTQNeEzzR5Sc-edAtFCwLz5nYBBSwqQXXyawbk4Ra7QFL4L3kSxeXo8VoA4KYaJzBifs3kWWLCFlxehR4Xikij45Z6UTomkhJRc2Fu0pYPwq4VnplcEkfhVtUEX5ocJn8ElhJAsUAorFjRfQtWkkF1pOMUAOJbsChpfCHFRrMcCawNzRKT6iaRLua3UbMMfKcBRhl4Hq76M8lN5QKcUsQyxLd4tBKUaUuCTDNIgRAuUQaRKkeMmRDIrpZTkYaeMicmAWybWDqVWIrgtSlrjnFIbuAKpsqeZQ4ziCoBVlqAIgSssxi6hwg6ysJpsoqkHLqBsWQYMtMfncijliaCzJcqfjXKihSWPnILLvnlQ2qCtd7LQLrJ5dYuMOfeSHLDkVzfZ1csNGfPgX3VfqAshQe8pLr7sfaUXDOjXSfbHTncgKpOarCLnpzU5pc0OdnJBVVyY54KuBRfOFpl0UVh7cRDG3Ky0L6WsY2jgEtylF1glMRHdtvO4WyK-FbKjxektUxOLvCGC3TgypwR2LSSeCgVbiiFXMzmOUSlZiqOe4a91RXKMJkOP1HAQaRRo3pKYhl7_wsJNQJ9B4kvTCh0G_YkAjOQyBxB1sFoAODCPdEjjw4fdAisGjgBf4qG_YhMdSl9T0olW6Y3xXhH8UerPQms5Mb6o9H2B5YySY5A5lVgRqGg9gAANKqxPEuoA0KrBNn2Bu0-oGOfGM9C6BIAKQGaK4N1Ai5dYY3S2eeDeXLzE5dmUWA0HPCXpw5gczuZirrUNqm1A86tVMGSRuRtQSUceW2sbXX9m18oHtX2oHX1qh1TcztUoPrmYqU1aajNVmpzUtq7MC6_UOmqXSZrtYMcmdXQuC4hyPBUa-ef2onlLop0q6-2bqGPU9zT1Lc89Xus5WWAI5S6ZwGbIaC3110S6bUEHOfVJRX176z9Rum1CPqz0IcpdP2oaCiw1Yg6ptQXMxUQbLAUGmDZOo7VVrZ1wXU6afSi4XTmVGMrhcoorIQLW1qG4dToshWlSXloCzmfhS7ZBo_Ubq7enzJ3mcz_VGoSEnzK8XvLpm29HDdvQsowBAluFAjZzL3mvCx1_alDe2rI2rgIVZKkAgJqMUsbdpPpCZAMjo3ewGNsoO6bRWulsbOiqSzjYlOngkz3EI4d7J9h_T6B3pwyniQYwSDAzCc3jP-YYxyYmgJIDrRcHht2kiaVNYm-YJGnnWpqN1S6ndQHPI1kq9almpiNZtfzw5Jlk9D6BMu8Zx5Oc3OJTccBo1qbnVWmyIDpqUWsbUAKSpwnEVeWwqu1XXLsbTP6Y-J3szTbzcJo5XUzTNrEDxJGE80x97NnWjrW5qIBnYuNFWmmVNF7FMr_lW82Ls7kI21h95f6gDUhqA3fqMt102jaik03YhGNp9ZjZlpU36aCAHG_rehv3V8ROcGaSgOLCbQLh7A1OKLvFpS2IyeRmAITSDl81VchtrWygJGAjVRqR0ooWNS5kTXJrgtm67ddmvC2wUEcxORzQ9sE1lba5GGviDV2a71L3ssy1rg1pBysraG6mDlWEtiLcqsdAiz-XxFYDfQJIOqxZbQVR3-pQYoMKnRZjQDywkZdOsnI8qNK07FlXhLAIzsGE90OdYmVndMosC4h0ALBWRUVJal3LGGwuiYLxk2Aa0mpkqiXd0ocZy6xasCrsAUBxgyYqNNYZrVVrM3tbXNP0XFLdsh3G7xS3IhLUsBJ3hMRmsO2-RVs87gtuJVDd7ERhd1LN0deRUJaYIiCEU8CBANyD4AkjgwlghNCLMFy8A3BIgooDWkHrSigx3dU0yxtLrwBLAk9-6SxqrsICPcfK-HJ0OEG6CwAwAs3DAJOA1qL4wA_CHwSOEwB9hAJ7gHrofhYDuB36DISBpyr938CS9xqgQOgwkj6qFwcAI1SasfBd6A9Qe9PXw0z0ONB9UAZJKgFtW4NWI5TfoFgDkLKD14MejWr3v739gIABq4fZQF32Pgo99w2PWLUn2EZp9MASxnPoX1L6h-q-g_RvtMHF6CAJ-5wJxjzBtYvY3ej_aPpxy3lr9HusJnAG_0R6-I_QMWp_u_05AJIZ-7fTAcAPON-CGe2_Q43APxA0l148HfAhZBUB7m5aIfHvg4RYhKAgQSA1MB-Aig8Al6eAFMA8037LGE0R_UXnH0l6g9r-zDfsDwDnggRf85gw41YNCA7VMHLfUQAv2EAuDVB3ncjr0o0HRdihugwwbWqyZeDTU3g_wdRBqHVwT41EFcGUP0GdDhNXjBKAMPlQtDQInHN5mPxTb7UxGuzIhuQ2qxYNMmgjHJr0X5139sB7A8gthzQHCAvh2AP4Y-hU70tOuhVerxRHKrSky4tVazA1WGiAeZYwiEGItFhiIxEfdMZsCwAeJRQKQDwLmskA6En0FsC0MT2FCliIk7ABuUhvsC3qTkDmZwLGsblQEv12oL2SbMsBLA6j8axo80daNNzdQochWOeBaPAauj-coNexADwyJ0x9gb7WmsVhNHRQLR5wMkhvCnI3I4xpYPt1m3OA3IjcnNTMZ1SN7qjDofbscjOTnglUi5Pyfcj0R_CQU8ktAHshgCRA341CT0KUbgSvHUA7xz477CXnw6pgts82brAO43Gg54J-2ZCeuMqxQNc6iE52gRO3HL1HaKE4ibh1HaoIjcpNfYDaMjGVjgxzWJuoblbqnMI6H9dbJ1iigCTRJgY2sdVhkmTZFJ-wFSfcw4nOVIcvow0ZJNrH4NdmPk0yecBImD1mKrbtrEhMCndu8oEOVKcxOymQTuJlNIknKRRdKIfHbgoWAKi5T0Vrw2E5ibRMkrdFCvEotqeYJp7GZNK4zR8oICjSNTc48pGisp4BbajmK404dxPnrBPDCvCVDCu5NnpcsiK75UjSe15FMdnCnHaYPCUcKUuoknwpVHWB5pw088BJZKs0klKamqpSqIlweQRBop3BviFiFnE9AQmPLB5J-P8k-VcdxCtKOUzwBhgWuR2KlQNUJrAKRq_BSKMJgUjFmpgC-CSI2ebMP5WzdA5qtnSTrnRuzvZ8rBYBIOsSxwnANKApGVDLnGAqQKAOJW0prmIAAAaj3M3kpxW5xBHwpPOElQYEAXPXaXSilnEEx3QWJCIaXHN7Km5qZA-dO6Cw6eV3RAD8qgAPcbWe5TCrbDQCMgG6f9fgqfkIm78_zucW_m_XDF8R4gpcRIAEG6AUSlzLIQBsuL-FYM7VR9QIHEDyDz5JQ-IQiZspnpIhMtX9H-tPFozz9V-c9XusxMNauNTBOZivHf3zN6J5pUi87tWfUicAARzEkEaiyLMcUOLC_A1KNA62YU14Ywf-aSwTxPhmJe-O4Rgyyqr4UGvhXCyQb_OQT5IwS88wKOkm3VgmFDGgJxbVRrVQYUMAARmeIWkMKzBAKyxkFssox3LaUSfI4rzMZmHk_CWVJGH4v3d96wlqSw90imRBopklu_pDOo0qb-EjpyqFh0qgHb1xpg3LFMlctQTnTsSCfGACmQxxnLeyYy1WLvOgJZUagH3SvOH1NlxITliywQBKvvnjwj5zLmKuVrdQczzV-861c_OuBvz13P8wBd4l7lj8cBLoAVfvPMTn0ltexTeTgK2BAqwkoC_nTLzUBQGKRX0VCtyT9h6zm_QXBKHMCiqCO9w-C2Mgf5QXTzMFpsrbjETyowJ4wei6pa0gOhIA2cYKnQTIbOXsrFaYq6Vey538zMsxTrDJmUg3NClnXZcQFb4vtABLRl3cczDCt38IraR5wFzJ-tSW66tEIfYhIyX_X3zqlhRpkXzrkLlxSTJ4oFeCuElBL5Vn-UjbGjhWPKZlshZDd3rlIWluBq66AlSawWYQ91giIAyb3nWjgr16UJXk-ucqYrb9CSEtbqvzRurAN5icDdiCg2lgyYFaAaXaA4SHush_-b9cNSY2gbugK1ZGEmuE2pLEM9rmzbTP_gYbQVuGyFbfMrSGb7QES0aUDHo39bWN-3cGeEJTJREFE_IO3lyu8J8rhV8s41Z6ugIEbLtqqxytTP_y9Jfl2ALIZzPJ3bbYl9G_2c3NfHDbUdgG2fFkPedToik_O1o0FQfnIRg1xABKmwjXnOVfVp8-Xf0DR2BRTdzLusGVDndJYRY7IIJfaDIraA6AB7mZ2FD8GpsKV2AG_C4VC0zwHyvu-gAyEEy_Yzooe60JXs1m2LwXb-pvbSjm3EEoMYoAABJgAEqN-PIGXt3N4AxQBu0TqmB-BXVKMtKLvevvOkutApV--DI6ufVuoX99ocAQv5mLioCkUhhleEKCoPESUBIFfe_svo8CUyUGOfd9i56wHwXEu7mfTPHARZPnbMUg_KRvwPLWIQh6-dSxoOhFiCZO5iQ7uCwBSNDgaxdx_N12ALM6ehzXeYceXkH8wDyqQ7Wb33D-GBVVK9gyAxA1B9cUzBg8FRLBTMn4vSXw_1pX8xFM_M1DhMEc0BhHIoBxBDNdrAW39iCRwCTwKNFGJIuR_I4UbNsIP7zlR-_i8TPSfiDHwoIx09B4avQ0oJ94APY8fSOPCjYYJQKfc8eGOfHKQPxx4_0deOBARj3EvIGKAP9P-rNNoLIhhCkWhC5IbCUJKxB7XVUV9OECJFfyiK7VOAZRzlgSBqPA9g4ER1o_AxD4J7oOSMFiFKcaORIs92HGErdHZBQBFfCSKo51FlOvYFT-AGeKgANPynIoRIB5fD11Uz0uuLJbvA6d2bunQjkZ6I7gCDPhnfT0Zx5dRhKlTBWkVVLqGmTPx9gZ5tZzk-SBQ12gsQagDci1wzR5ojt1oOEBmjyRdnNALiJlVTP1OenFeIenM9KYG1Mqj92B-0P0a65JYkRM4rlkgeUBoHUAIF37DsZ7lwXdVCwJC4IfQuYHz9owqC4710F2mDFW2xPlXxiNggPwfGW_ZFupNMAILcBpvxdB4hvku_XLDC7OI-LoDaAeIFMgztXHvTVjQktl3pmsT2JFreA6NEVvvnTLyLzc6U--fxA5naUYUDInZelXBUoMF5wQH2cgJ9gRDoZz08adjOZCONiZnAVReVQoHGLve6NYr76kTX099F7C-ftQ1sXeLz56qhldQA5XXTiB2i5hdwvZrbWRF_NF7vxD0AcrnXG0p2C_O6qhrsF3E1rAuvLLSrj1waTOIWB2gUQPIpRnYZ08xwgl_-yO16GC7WGebq_Bf3WIOG-ozQIN2kJDfb8oq7QAYW844ZzQF7wbyN026dYtvq3czhFOSElCdZ2gx97tJZAFOxrdQLc37aKD2Q3hBLAT7xx4GccvQVsZbzCR8eaDTPslcrowvW5d6NuOG80dd7M-34pvawYbhIBu-349uEEiIJ8IO_PDDukoqx0d-O67RTuZ3YTwJ_O7JhLuzid92HPRQ-hJ2nThGP6JXfttnFqbYyWm6VcqvYAyQPTjV4c_CBGWTnIjsZ-sXjcuXE3R7uqp5RRIrMUF1t7ycB5GBZms88XSgJiFgBTJ7E4faAOn3Sl5WD7Md52xVeZjVXiduglOPIhEj73LHoCJhuH3TOjQ-JdzwSX6A7ftAfgLoRt2Td8L22IPSCWO6x7UAAiOe-wAe4JLo8iRUbmn7j4kF9umDfSByKZAx7Dt03DF4dxBOx_zTOWM7y4ws9nbTu2fykZZ9O74WrMpmlzgH3y7bePzHnEbagP641cFTiV8C6AGD1gHElCvCuUNczw-BzvmegvFdlz2KTC9RfJJwr_RnF-fzH4y8un9PusG89YOIglH5aaAho8BEtPiQdrSB_KRLAmPKfFj_TaqvjW60DXtkbYBvAuVSdwn1ayUXIVFeO9R5UwZa2M-nm9uhyNE7y6Yk5dBXGXmL6NGy8532vuoNPjx_gdTX-PUw9Jut7mtFV5okUDt-16WJrfwhee_gtY8kDbeCvSuAsFlFvOF3fYR5ykIzYSDtBjMr-Qb3_Nq_Jm6qoeAgFTfueQelPzX2D_KDVcD38JFoa79p6NIrfTvyzHTPJ6B-KemvieV2xD-RtQBof4QUchUfCeo3jv1jxH_98B_w20fEXgEZj9e_Y_rHqN_Yy-sOPHGA5nlDwGaG2As3VgYLuG6nHe_50vvHmn76nb-_I_yfcXjHz04Ht4-YfiQQn3x4yCrfphTTmQqT9hti_oPEv1VFL9Tj4-SecvzbwKOJ-v42fEoDnwRnkdxBuf9eMXo-j59Ra605nqu-1ZnSO-2HjD67rYHWELgRrvXxkCzTPSvX9Au4uABV6El8BJXg3mamT6dvi-VP8oNT484BH5fYfLTa2WJ6jGTO9HGwkP5x6q_1XJXgfmgMH9D_zwZ0x31BmsL7JD6VrFfUT5x_E_yQpPGfzKgL-I-gfNxLrOggp-wgg_0fcf-5-p6T-5-9PEVs4iRKH2h-qvMhRHxNfl9siK_Xvp9IBb9-TMZl7Pg13zU-9C-7Ng3lX6L5j8a_-_1P9oLQGHIy_9fUyRXzt_097-O_3fqDwF7B_tBj_p_y0HT7h9z-GEJPVn-v_N9H1zw-6FmDVmI-DkCnWJoMAGASKAlmD08coLAjLK3PukxIQfoB94vErfrv4i-d_ij49-FPpr6vOAIogGHW0Pqd4X-iCFf7p8JPvv402vfpT7g-kvvgGfohAe_71en_kb4YBAPlIrgeWAQ_5x2T_sf4EBA5JkAsAeQKP6Suo3vLDvmarudz8BMAB3CdgEAMIG_uH0BQEd-nAer6P-WAFT50B8oNIGLkQgCkS6-woCIFsMYgRIE9OUgQwEDkCPJQD6B7_q-btAAAMS9mu7qiRsBgVqoEH-6gZoFa-9AUgEyBVgfoGp6RgawwmB95pIHtAOgf4EyBgQQAL6kkUNP7G-v_gLSuML3oCKog0qCgF0EaAdv6q-nfrWD3-1AbgE8YpoECIZARAUr6y-hblRhz-ZAbk6isCQab6c-GDhkGw4Jvq4Bm-SQYAKFe2_mlCZWiCNlZmog3swEG-ZVqVYFBLXjWCt-vQaAiB27QsHauINXiR51elnsx7meYwdgBzmXkiaxt-HNu5xaSwXNpD2AdwpEBjePNnOIvC8wDZoVWiwLkB96SwJCIRmWUFGbvyMZphp46ESjyqE6cOEuYSo5SoVJLivhOFId631sF5Ae9npQDiW1SvjYgh_lk5ADOn4g-D2We3iTYlEYSrCEq4K7k1LnB5cBxQMgHgGfD6MixscjLGD7oMYbGWxicg7GzgE1x_CmFCEJ9AiIBly0OEkJCJgE4zGC5oKWIQSFLGG6rKZHImxtsbjGYYCUES8-dHSFIQ_4DEBiQIepjyKBlhvSEShZKKFDhQaUFDDYwRkJz4_BKdnbaYBYoY2hvuVwR7ZRS6NrqEw6nNkDRueVZql6ze5nn9iO-C3hJDwhMXEiFukelMeZ525UJyFQ0hIVAQ8hJIcyZkhAoVSG_CIQuYDzQ_xoCZEAb8JGD3BHbriFF2BGP57jeaNrQRUECvI6Fx4JoQgorSoRtNqvCxDr7Bx4CfrSKpYceGq7GYUMgeTkOH4jwHB6r-HGG-wXIUSG-hqxusb8hFIYKGZAaQQIAyE80GXin4nYWqhkg4QCEA70gXv1CwUUBsKFkS2AIiCnwsFNn4suznpaF8u2lC3RnEh3haCLh0IecxriHDIDZqo6XrFxSSOQFu7j-T6G-DHuCKOMSSwcquwz8u4XszCHhxUBxL4h5zgOHSoiPqtBLhO4SuH_U-IK3RxBBGJqGZ2_CE-Dk-y4meBgR93OBh-QINoDLKeYPmDY2h8UvFZVciVkNKwAU9qaG7BFWEhZdgvek0j-QMACcHlo72BKwCAhEX24kR2cA8Fp68ZuyoTashnGaRKchKmbARzUupIYROBkLrCglEYiDURSnOPakWXWORF8RxEeIFWeHKvw4xe-YLxETY_ERJH8eXAFWGbmaUKJHyR4ke-ZYgKkfgTxAjkPKEv2RoXU4cSJocETsRcnjqGwh2AVwAe2SrvpHihGwfw7ABIer-5Yg03tnBj2AgDU5dY9MG3YihjEbY7aSpVkmx_eemEhB-RdRJmGcAOYR9D1usIXdygIfPlwBx48jvjhikQJKQjGRUyK2SORnKrpGlW6GJ7bwRYyGZGghFkUXhcBb8g8iQRXAeBgm20QNVxKu3JJDIbB10uhG6S5SFhFtcuBtAwlq7gsfLwS22lVy-kSVphGlYqoDhEbie2sQqUAiNhuzpMWQJ7AJIYLu9iUQJoQ-B8IsIebgigaLAACK4hHqYBR_DjDLUABauiHVmYMJEj-msIRtF7Ap8IYhv8cAK-hY8coeKHbREQM4D7RBsPIAACazGegnRcxikCiE4hBJAIgxYKITxqhLIdhBit9EJyE4YANV4AxBarRRkMM0UlBSeiQLORwAX0Mkh96aUCKa8hhJsMYdGUxpYCXufbje4dow8kuiWQqcoJZIxMiMDEbBA3n9Cscy0Z1gWOIQlAD7ozTt_TekcQDtHox1AJjGDAOMX3qeUBZOIxdYhMlJGw4s_kixgydgGIASQekMJh4uZzP-Clw9zJGDFA_lJfTjhhEsdBkoOQKfbrR6ANE6I-FgEtE0gCKGIaWxmwZ1wdaG_nVTkKADn8K3hlYS8SSxdAF1gxhR0aUTtCj6PugphsOJ-IpAQgDgiO8kIu5HhxbQFhIxRxBDdEJxBHqswSxVqpPZW4zTtvZcxmsULBSKmcXzSHkBnivLfsPEBri0A70bNH8U72NWa0RTwQxGDYqERbj-aVqPiZDG7RryGsmr6pYD_qHJpJragEWl4bVmRUuJKSRR4feZmxEwmnYzR3JNbGSw6GMPGoQo8aAi2hY4JXFzRV7AtG0Ac8Z1ifiKMexYzxtJDvHoEsoDSBpQO8fogJAXMofGEkx8SPH1of2LijpxtToJoXQMOhvo3xYyMfE7xq4N7FSKH2KXFbx2QOvEYUssfjjfBQHixHi6nER1G_eX1uxbfhdmmCEQhdBJeyoY5ccAmfxHkdU7CR18TtHZRYCS7i-6fqMDH4xPcfUaim7cSMZIaKsBMbfqpMeTHXuZxAO4CmeyKKDXqbkN-KZumVALERA75mHERx8cfEGC0sOGXhdAvbs5AZOJofmB4ga-IpbSJ74rkBgukoX7B_iEbDkAeAyQJXEj4wsVjHViQ4LrANA2zsFxJ2ScW46n2vCVXH8eZsfIAWgaCWXFZA6ADE51U5kf5YqBkrj3ZWRglqYnyhCIesRFRsbkRrum7QPuhOiLCMu4qJ1OpEnAxlQX-6I-uUXdRZQJWq9HOQKrDhKQSPgpMBEM3QHkBSMZ0GkCoAvWKAxCgSQJ_zmAe5vOFD6iPhaE_hTEkJGT2qwTgHx2_sZlRwEjvtIlQ0lie-aTxq_h6RlRbiewEO2agTWEAiJoajY-J4ofF7HuriXoiUBwPk0lP-9DgPaXcHviPZGkXSRPFJx9sfw7teaUMPFpec3keEIowwZl6dJWCWZhbJxyVMjTJQHkZ6KRUYAGZo-wrkMHZRZxKlF0UuHgklDRFuO1FjSLpjlG_xz8V1iZxhCRrE4AWsfnHe4AKThF0qypOqaVQAmuhhrSSlGRQ903Xs1Fe6jwfRHY6_sWXhhYVFlQAzAyQOOGsUm_LxQZJ9QNYC78u_GhJKJeYCwBdAUoKAyaJg0YAyfMUMVMDj893htZtgQQFLhr4l5IH45APwRQb4WuuqJrgK7prybkJ_RrKaDx_pthy0kS2hKkqKUqZKaaw0pp2hypsmqSpeGKgtnBGKshs5EGkpmIxIGpOmLpj6pzaEvEwcEkv8omYlqZ1qde3XruQV8BUJyCoO2ZsVbyw9kY2j46qjImYwJldg56eEJoTWaDRxPEWIZJ2DtS7905gOpFERPdMOG0pKrAq6yQfYFIk7B_DgmlUR9yTlYUpzEi6zFR_kc-H3mGTsTa_2kdlowHIvqXCH3mNkc-YxUMAnyqRgOaQpHbmf4TeTXS2kAREaRAka2lyRREQJFxW53imjzRGCeWaEc0aafj-CrFlLZHBRHNXEFpUlkWl7xkkvWm3CU6Za7dAM6N1Y-pVkaDCfiwroiGFUT-M2nGK-NoRwdpKVEeYLpoXvUm1Oa6S0m1g3aV2CHBhHNRHFpZmFiGXBJltcFHpmPL-lsi9wdCkrMTEW8HYpQCv8FwJXwffI-eVUlmb8ONSUgm-EIaQl4FRSXvoCV2HniUpYgtafuKIJFyfKHhp2ZlglH6sqOOm8KLkcfgLmqZhAArmu5nWBo-dJH-G7mB5keZBRJnhEoFRl5r-6ohvifAZPJJoSpF4ZaIdxn4ZSDknF8ZejlcFRcrvidxPmFaWpRPJbvismIAXACCKvmZsaERnouyQ6FWhArnanPhpyaNCOhuUbP7DBjafNb50bSY97zAdbtkqxxD-Meixu-eq4hu44KXnFPgGToRInAfsLSlr0qIMqzxpg6X27cBK8RNF0E7ySBYOsOLp0EQWGwFsC7A3Ngy5EgGQPug5ArcJXFLAXKfiDHgXYtPT-Cc9PYlAJM3PPwfWR9L1HsAE6HsirQmwCSwpZRwDSkEMJWeXEmyU6CBgqRJoZXGfRIMZua1pTvrQ5KZsVP1mwhg2Qw5qZliTcjPRutiFThEW0TNG9ZUVNi7mKC2TtFLZw2ZhTrWqAKAyNZqTOn4gB0wHYC0purHSCAJGCTkAvwkttnExK-CS7aUZw9r8H_gGyYSQUZm8RdmcSagMuw9JxUBaCARqCaYwuxn_gdnbpSLplQ34L2fTYPZalCVSQ52cB4hvZ6CeawHJRmXDhEZkySK4JKWybExKkZGQjnnZ5rBlGg4a0UnGbR8oT1n7RLyaeZ4e6zPAk0AoFnFn0UwEXclTIWEb37PJywRkAoRF6elBw55GQTmFS2lF2mcyrWVkAgJhJHgl8JtJPjnQ5I6U3HekvyZ1ESoaVurKMw-YulwJGespqopG5EAQAeA1QIbD0QdzGACSA-ud4DpicnDpLnavdsUaoQzyMaJwiWNLADHxvHGvEUgRWrgzCgSUAOxLKNYE5kzAt7K4Bho2kMBToElAKgLigEYBiyB5ruZmJXwbkBzzZKMeTGzfGJRpKFwI3qiFKZc6YnJgigjCnEjkgDCgYq25lqFrLNiOyIdqcqbctqChyEcompBy1ebXlJQiauKZ8QEmuPJ_q9edbLt5asJ3kJqreWKBDo0Gk3ld58oFmq6gw-X3mTi2km1SNIgeRgTZwP-reYfGNIS8FV49FjDxmC8nA7hRIiQLbgYAVwEpBrMbSSvkhhApMGHUAZnCjI3kF-agBX5m9p5HeR1XF9JZxnKo_bDUz6DIR5uYFP07NoVAMKA6Qi0Us5aOBZLRh2ASjJlTf5J8L_kMIABey7bxwBSOxN6LGSjQgOJjOlDv5YBSzRQFiBX_nCAAgIAUIF6zss6gFx4IJFeRuCf0hN6r-TebRhWQMLYbmTeiuIigeLvai0YzBYwbHA9BbRhvJbIXjbpQVBfRbFQTBZPisFT1seAtoZesyHcFx4G8kGuuHmASkKnKlTppQeudUB1Op-dQAJeHxrqohRsWAzrRAVwFTqgwyYIW4s6ukHIZWINhquD86hhZYVS4uhgRj86FhcYV2WthjWDkKFppoU7Kq4PTy6qvGE3p9ciymDBMFueXgwiFGANMqbQWeGXi3ol5Fap5gTpEaDCg6bntbZwR-LhFTAZ4LqA5QwFLqqWQKRZ3iHSmXLnBdgtbFXpLmZOvECSw1nuIV2aJRGEXpocxoph75SAgfnsA2uhsyyG9PHoW1gLOnYU75LRaJiuAXOnYUWggxenyiYDOhYUTFIkMMVc6FheMXNFkxcUrzmzooubjgK5u9J_haUNHGCFEhTubrmXwSlRsZh5q6GmC-xXZp7FMhTAC8ZHFJcVMZoRQ_JyW7BWEW7FNxayG42Cjg8XCF7BaIX50ERYJmXF4Fjdng67xYLBWMEOpgB3Fc2fDKd4G5vTz06mxNECYUiJf0WcF8OJ8VGudaEgzFQaJSMWPKqJR8ac6jynsnRAIJbWCpmUAJvTSFEJclrE4MJbQXaQ5RavjbpmFHATUlc4BuZ9mq_pyXsAe5hJDJgRkKA6rMnPhyWb0CJcSXmFKQESWUASJdzp7Js4FiXshOJZvR4lUpQSVXC-dPiULFc4A6FKlf_l0WjpCXLHBRw88Y9aN6tGNXwa4kIcvlylzhXOCt0aJdMVzgxUMmDYwSkDOjMlX9KyWjQTrnpTkK2RbkWNI-RYUVF4kIs4h--ZoQ7HmAe8rRghFrxQ_ICwfxZEW8Y9PO4VZ483HozhUjSNpjJRNwZ1pnw_otLyLKcvBcRAZPtP_DWOshEQTkK0YewohKssXWa2K7wQToexnKogrfi5SnnkGK9ZUEqyKwRGgqK66XNHEHJfysIUmZsts_iYUzSoaXoyfmlLSvCjeX3mlhuqeaYFEycQWV1ERZds4k8dROTr1cZZUcQpR0ArCVFYDYVu635LmQ_xxFjKY4mVaV8MkUCAqRR7ixATFt0AU2j2SELHgXBWd505VeNYGpEYus4pJKKbK_gB-p8eaWtlwaMfE-ktwWUS1EkEpWVLAa0YfjwA_uSjh9iXyRfE4S9aJBUjsNqTMCPxHwBbiW4f2O_F_x0sa4AjAwaIHk0FUtu7mB5-OjMRHW4sGEne51bGaiZANFWSh0VoRLQUQ5jFZlw6OvSTGXOxPCaYLcVwFExURKgiYHlcyQlYLBLAoMMwmm6mANwmlEcNpbreMGlXQS7oNxbpWw49bmhU9-zCU-Ia0hlbFH5AL0K4CWV7AMzYiJoJaEnrYHFc_A9BXYKHmfEEeZPiH4s4PJVSVc-ZlzVJpgioWtlORQFQhliygUXPlDUQFW7wfFY5UvpKqWwz7yPeSPkJq6xH6bNBxgZuUfQkInNKz5bSAnnPwSeZlz3SnuQICuV-nsu5-FwRfYXIEHxhEm0YQRfVxGFHOk3rrEFYaUQ05eVZzIFo1xIwqsSBit-KjMshMqXdAetHzEHU4sSr5j0_8TLHPpAOelAAOamHkDsAysewCqxPJfJbEeSltbicxK4oji1WYiPbGuxI7O7GI-PVbWCUVdBYLD0V_DlqbeFrKkjpWIyZb1ypwuhbRDQVgVYLAL5ksI-D3BZxPYasMqVb2qSa6Vcu5ZVolWri5VsOPlWjgDPCGHLu9BDoWLKyNXUUtVr1ce5dVmVFdW0FB5VYhHlnYGIWW5ZkjMDW5C4NFz2x7ySnGZUJFd6Re4JaQnIeZEKYzWjVFgPy44S1XudCxc10v1VF5lCtsydl2oKVhisgAmR6SVTEAMTAUUXA6jxe-pm6YRQ4-ZPl15GVb6Zrl2VQ-XbAG0TaYbQtKt4qGeamqHlRc_8sbUuRdcZBm1F75GbWQZqXLigjlndrgbaQh2b6QZJLaabXfkChn9Ch5j-bgke1u8K_mQ8u8L_KC-NFY1zKRgUWSLdUMtQPrR1YKPeG5cf2AVyY5WtVMkvEcBNbWNIVmeKqr-10jmXtK_tTsCjV0bvwV4VOGI1zVlRhIXXbAX_sKAs0wNWTTiaYNR3mq1mVRrXQ10UYYbe14dbDUmUiwsR7AUtdRMSSuONXEmb-5vtzlC0h1q3qiqE0MRY5A95JpBx1bSL7WT2mdQHWyxbktXV2A-pDfjb1CdUVhJ1k5VlT3oPdaVj5010j-jS1uZevU7AwrtjaRGavC9xqiGyBpo0oGmuXm6y-vNrlG8h0LWjf04YM5BDwi8LYikIu4DRaANGfsYgTQEAK-gLwS8GA0wNr6CChINd4PA2gNK8Kg2y-W8I7mzUzufhW-5KNXtru5bFS5U-5vHHJUlFuDTBWJ58VVQ1K4bohTVPos-LFCp5vxu_WratFdnkeiG6MPLJIAcs0bFGZxjQAXGjqtJB7wZKElBwAT8n2KYoGmi6qf1OeQ_L55GGANXF5MxiGrxsYauVqgm7AI3mSI54P2pKmfoQ3nagNeQY1GNMpn6ED57AGlUWNlgMY2PuaJkHJ2NhjQ41WNTjd6Y2NjeUO4OYvDb3ljGpjTXm-N3aFuoBN2Jg7q6N2KiXK1q4xlrA-pQctE24qsTc4DxNYpkGamCsJvY2ONgjdbJZNbjTk1rGNjcrVqw2TR40OYQciU1YqBTeU2igNja42WNWqX6H4q5chHKVyecpYAtGC8j2ibq2oPGrjG-fqm4NN7jU02PuwKm02gqMcl03QKNeSbJ9N9gOMb1NzdaU01NnaDQnomo6ss3VNjTaMYRNdKt2gqwGqds0jNuzQM3WyBzYY1awxzZibrN6TZE2qmaVd0015tzS41bNTzac13NdKkk2Zyf2vGoJqPTdBqpN54H1ntA3zXipxqiagC1xNwLTY0Rqhjb9pgtdmBC3_NNeYC3xN08oc0ItuKjE2_NkLai3Qt8sM8jGApgOYBGAGYpWUl-MAJVaq2dgK3TrgZcD4K0Yn8EcD7A3yBLiuggEvpbstIjZpaugWFpsBkScAmCCkt7APRCvWPoBYDAAb7LRCPsbZlmCHBjVnUXMtewIXpHA3LZ9ZktYrULAStFENK1IVXPFYB1W6rby1Zg_LUXqII9blISC16UK3r7844ca1vsVtiK30QnhXq3tusONS1-p44YAyfilrVy30C0El3hoMGiR3T1-kDLyBmAWZSyBDUXPJS2et8AENWNUT7BWVc8MpMCFaMJ2NgoOhF1HK2-0HZozSfB6bfoAnYI2tm1JtubZTQFtt4WeiqANLQnoN2n4pWWr1tTn-YnY-9Gx5NlvukjRZtO1hW0TOoJa23Fkpbb23jmU1L-6hUSNCNobVOZpm0PyIlN21ztjAC3Y0AJbRgDslGADS0X4eQKDgYQ6-mZYok5CrW2NoN8sS1FAZLf5Q4cZKC3QUK_Ka3owUKiTgBntZ7aK3itcoBRADCMrdmHtu0FtQrOtr7ZK2ipuDLRAqJjgHAXu6fsLDgqJRYGB1ZAgjO6CTWP9M5AqJz7Vq2ZAb7WfYu8wHYBWSuZNAK3EWLCDXrlEKHf-26tA7MB1c88bTiA2A3KUvgCt_rUsh0QI7b8pEgsEiG03trFpq0kdGHRiy0QmPHYDutT1uLgYAUAQQC_ijcOok90yQEK3dhf7dq3oderYO0MddBOknetArb63nA1rfR36AW9px1ydkrdHzkdv1NI0SwFZIi7MhkrF1wj0I4P5TUWADa6CRJaKf9UbEVafZ30W6rcR16dFEAZ3v0uApZACd9qGZ0T4nYIJ3PiIuKLCByFSb50hd9XpgTfIvgsdb5Am9G5ALgPDFHCMc-gCh2eFO8bRD-dtYCkw7xgbV3RH8vdIHHcxeYMS6msV7bvzfyv7ewARtAeFpxTQN7Ze2YRKZtmGlsZKKB0EF8Be_DJs2HTOxGdlHWGiUQgGUx1BU_8Ip3ad_Ak2j706BHgKACMpG5k5xFup7haVnYC12cQQGbdEgd-BYQXvwY3SdhwAlHagp1omPNnXIhy5EIAKWrMWSz7V7QMDFegwneHk8tgHeaLNZs3OfzQAkYs53L4IXdXpWt04BeFGl_DvMAb4UcMfH46MFQQ1wVhZf10Hd9AihVB4nXbt09dhDdNoUdG7Y2gBFfAhLDYCc3ZZAZawZgkBTIEPRJA4VV8aD2pdJ8WjjzxGwXY6IIUPTT07-rMTvHSx8AEHGvxz6ThIk9BDTdVSVvFUFWEJpXcHGxuNXTNJZhVwXUT89sAMnmpxihTrqEeWwY21koP8ThGntIra9aSwG3de2a9fsHe0aaIXXPQpMvbokDZK_6J2DJAQ-Om6PtpLR51odkrfk5Adk4NRVcNtDiDUCt3FYb0Rl7HTkAwA9LuygmggDJT2f8dgILgOIprUcD-Aa-PqDhdkgFF3OVzosh2yd9vaR3VstEMQKkCxGBwysYq9rR3dAxPEnyuIJrTvSPWnvQ52KJRWVvi90n2GAIBCKaI9b5R_YLQ0ksLIcn06twAK90EAwHcj0wdkhJB1Xt_-d13gdcHSaAIdkDSF1297fXq2oUzfdsBMVsOJGBewU0PECFQKrJb7dA35W-Jud-VKXD98UAGaDoAyQDV1PlQxNF0pOC-KPSEgXBYLCZdNtsACO9UoDl25dFgCb1m9B_WPjBSOQK311dfIA12TQejLr0bdZti70C9SlUWBPomfceCzdvncmWwAXXXt16qi1LP10VRBKmbf9CjjgLzdbJXpQYkLxNL1Z5TIc6Gw0slHQQ34-A4HlmK0dAEYgDMvWdzOMuSi-ZUDH0DfgP9JMEU7kDdA-tS1xrtMYx4DNtoaSNB7Vi-g0DBAwNYdmw8SJ1b2BsF8Uoh7FiQ0VVVVehhngLFe4CkNXuT7nADPFbQN3VV0kIOpAlDYLAKVrFQoPkNN9Eo4wAqFlzKgYkA9hG0FrA4U4WDZqPcFmKUNDyV605CgIOGl-Hpyqv9dDUyHktKvcgNlVug0pVgOEA4kBkCiWiF3wDqPXj0wDsmkgMlVfg64DnprNkR6-DOwIHkntJgM-3E0YkK3T-Uc_NoSN4B_Pe1-ok_fJ1kdkEnuL-d8iHxAGxp5jUMV9fKe-U-9J_cvirwmwMonlDbfZUNp9-Voh1-kfqOwx1DBwM0Bj9CIFv1iQRWFe1PmXQLwwEF2IHYANDK8YG2V9I4L3Q1dFQwB1UCtEKbVc8HiBcTpQS_axAr9a-IPxnQjobzYCtM_IVDetRrfQLPtR7X7CKJqDD3gaWecD5UL1I4IFkb0c4N_31dUbeYB5DCbY6H_wEw2Wguq6et7UHDs0UcRpQjSrWU22fZbhT1xOKY3EJhsZhBksRKkcLXdl1yoLUojGOgOUqRKbE9ni6yYmBWYjwXLbzoYzUjij4AGmsRzUj6-diB3gXGRRDyOYI821dY0koQmRJ7I4fYNpIeqZi0jl5ugDrUkSb-405RPUM4EN9baETcjOCZPZmZoKaYK28KKM3AmOTI7SSHp2YetTSd4FaYLbwXPALA49M3T514CScOEORDBsJvmijOo6Aiaj3yNFmGeeMdqOraUyM6NsiyAs92idoBdiD8VAw5A0KNyo7U4QjiIMGj0V-HPVnJZS-LMOUA_mQQzxA7_fzbr05WaiAyEqZlB1tYfqIKOgIeowaEH145eMA4AH6CnURjQw3ojljM_nWjuSZKHi5LdHmRczhBIWIb2CWlY8GhljErilVXtVIhwzljVwJ2Nko3Y73Xw9SyJR0yNYMLEkdBY1HmOJAiDo6HrUROTMOwAl1XwWiVTY-cwUeKli1whdHY3gSDDXYzWPOxxiXxDvoaFX1SDdmPWoJnE-w0Z2HD8IwwNNpOHc25ijS4wJ56ClZZR3HuXdTRWwjFxIWNUKnqRJXBck3SI2Udj48F3Mh_9YMO5BH0BePwgV40-xHdN42j1zjSRBj2D88ADI3CJZ43Rb4NTPXslHEQA2P7tdZxMONJEPfUP2wd6xCmx0TWEzS1QTsNYEm1ggGce7gTonREnmj6E8EH49nVXhN1Uqjrz0rjKiTvFfJbBYRPsxN1ZRBi97Xc71aDogzWWLV_fZhPXj2E9I0sKgmUg3wTqkxKGMTjaDI0MIPEA1GcTqExpPMT9sfbEPtzdmkVa9DPWSi6TVGCIOy9HDBn0RDxGMu6YDBPce6UTCoXAMo9w_U1V6I6A5lQSTSVQuWvjoNeOorNOzes2Q17daxNJa2YfoqUK6ADNLo1Kicu6j1UWZdWfJ8vSInk9UAMU5yjTPdo5zVXWK_l817itNK9lwtaNV_SQsBI3s0mk2lMWOdnZCN-o98SolJ1I4zWPY2nikNw5DIrSCPXtVKf3xD8qTExAvAj2RV1yJrMVB278iEw4iZZ7oFpCmi-sUcCSMm9IAyoQz7eNMyJ3dDZ0FMV7SQbpJOZqAwHZMFDhl1d2wxRCd9tEH5Nr4lY4b3aiHCJvRYAiQAJDQdBBf3xl65Y2e2_9gXECMBDmEX5MykdZSyqW1ssQ3UYhejWY2DolkH41hNpzauVmmQ44eMhjZKKeVOVYbQRRlmUCVbAMjtIypHp--M7SQ1DEkPYNFOZM46MlR-4VGCYkfI7Fy0zno7qM2Rn42H6--cWeZl1orM-sjcke4iJV6010iCNmo_M92xHdUuMpV-THlGLXRFQ0yS11dE-BSCSwLqmNNX92yFNMqks0-IyEMvw5fSLTdgFfUZZdEOtM9wm9M6LbTm-AK17TvQ5K16t5Y4y3zwk1rkBcANeirPmG4bUDMG1wXF0CqzVY2I4-k7s66Y1g-8hc1HNZTWs1jGzgKaaQqTs4Gb3NnKodRaT6s-9ihz5bhFCPNMzR82Jzd5NAYGsAEnrPES11v3xdgeYM6Kr4W-On6RtjXdmVHEMLi6rRVrOaqPO4kMw2UfBzTmXjutOZpBK5w3dC9ORJKkX5NKDHwXbWMjq2sclHjPQ71UqaYs0FZLjQwdPPYgI6QNq6N2kOTOnBcJcx6yto7S2SYpqVP7H09nPEZ1kl_HtJ0_UKE_LlTYLcVcD6NqzUybypmtRzW6Yn4nHh9himBrjD0I4byz4guWQfxC2Dwwx3PD_fMPgHZgEpawqtaqCdiv46ft-NoTBVQex7zonXG1oTuk7vO_KdRI21c821BEYbMGwRyX3mIOdzPC5Kmv5SNzDGsKAtz9adOXFKa86qYmz6mmzNbzVNQfMvazcZKlK1Q-bFMnNApk_M2ZOYV1U-YMRcNPKzh1IgjHUBra3RzTrLUcDC2xrUknNEVZbGPKszQMxDD4Dnf4Iezmw1pPPtmifPQYsj1rIt1Fzvc0QyJhYIAu_U2-KmPH9LIFPyQSNvcrOodU_VUMYLQVA4DOWKThaDC68-PlTetww80OJF1nceX82Qdhx0hAf00QzVsACxKzX98AIDPcmIM-IugIki0Z2JtyE7m0QzyI1DONlz6c2V2aOIyyMP2dM_mn0jH9STNFLKaBZPQuXYPmPPynI6uDUzjg5GC0jVTg-nLxrCmqM0jJS2lDvj-o0aNgTBrR6MCz95hfNmTAy_UM5QlLfAsaTvSyUucz09gZPxLkdXxD_y0y0sujzSC8x2oLGk-gs5tyC9uU4LdQSsujhNLUlDlzQJbBOQNuk2sthtMyzS11Ej6CG53LGy9tRBji1mhPnLAQsLMyEZeM7WKWx_SAtz0109dbNAWSGk7C-rSWhNQOtSwuOH2S42lAgLXy3Ol0EsM0ElZzWzVHNMmLTTnLtN1ctM19yszd-r9Nsc0HSJTx7umHHuSKxcudVyJAoUT1UFPwRiz5i_iBArn9GAC4j2YXADQYeAJBM1LgmU0uWDICzCvoAdSzY60FYIzyt8rXyz8svE10jITzzkq3iDSrXYG_IVK3hAyMjz7bdUtfLYq8zT7t2Q0rNkt4oN5Kh9YAl2HLDRwPugXaS_k-atwJ07AC7RjICPzbDHfbsNcqDTAK3grVqnoz6Yrqx-0hdTqxkDJAnq4hI5A44SkwgroCLf1Eebq3aq0QkSHADnggoHMXv0MxHcKNetgAXiSw6a12H-iLXEw3_w6YX90-8fYgkuZF7AKrCITiQARTpSWQLAMwAQayPxmjv1BF7fSR8zJmkRwFRqvlLJS1IN1mIoBF6qFSNG2srO_bZyqT4Q621gjrzMAM5bOJStWaFrCoz5SCrZqNwNhjHS0grNOx8_UvVmQE0grSZ-wSU5mlX4_OMeQmM5MOqFZKE2uJAo49amzAXWDWNFQcWveaRJxYw2P5cfU_aFuzOXgRjBEwZp90kS09sMNdOx6yfwR8LqneDnrHUwyGFpbJB-uxcUHcNkiUI44plEDtXbWC5RRbQm5HCZ8wKIzWHFK4CAbkYgo1C5-dMoIMGwaD0HEbEG36g44L64SSFrW7ZlGi9iCHUTWrvdv6hVuBAIWuz4MHJRuobJRYGvOre-VvnsBcfpOsM20tiVEpR8s3T2dr2cIWvigDIKdALxtJExtwbBGMWmFr7EoghMbHG0PrAOHReemDRLwJa0pMguBmtHAhFmEBguEa5iDzDfDCyBmtHygIDjEbdJgCee44DZzmraqKZuida-JZtdhGDERZ2bRwOGI0YheT9ARcS_rgThblyl5vv02azAC5rfmw-xLmtgMmunwf5bBmQSSm_AA-ciWxZAP4ha357qj_gMWhUAheKRGrgi6zFvI8Km_6OFp2mzFu6b5XjFvuR36XiENhUNLw3XqAjWsbgYq4biwilLaXVs2rDWz5woFNVK4MLWSaymtnOXXGBYbMG44QuMb9W8ptTbRm4d4zoN-I_aVbliGqioyJRH2F59w-AvSSDlfN8gRbMQFFvVmScEUzNwv3RZu-b3yB9gflFndxu9aY6bQCdgmUkcAnA00A_b7swRHeQPinEJEszhvok12n4Bm0fzcbejG9NF9remDHVbVYmPzUd-IOv1lZRXSFzTcA4AMD9AtQWrg-bVm6oVjWK2zINH0p-E-KUWa-DYCcpsiSjsJQaO3YBvzdKWVkqsBOwq7E7U9DOkEMPrepsbbBW6ptBt7w0jtr4iXViBjkjW7Vt6bwu41u9LFWyztyoUgx9DzQ425xubbqmwfWfiTDW1sgCHW0en1h9mb1tbq_Wz9rOAnlBL1jI-W41tjrIE1PS07FFvPY3bEAFFuXbgEvkAJICCHXgmVh2ZLDwgcAP7ntt-YJjtc-cWWXi07bw-gxogQyIG1R9KTAyDkA86ONBH8cO-wDVr6esmP0sVm6TP1beGwIB27PnMAT1bKZOlBw7024WCzbNmfNvZb5O8ttjMVOy8Rl4i8NYG1IJ_ciDAevDNxJpZQe_7m85r21BIubge-5siMgmhMv5oQ--04F7EkJXsMzLEqwB_YbaIHtaOA-9yWeUcBEFtqoM-xNuyrrSaTvBb_ro3t_uG47G7FbGAEuvpEsDXeDlVE20sD3Sy-6HhB7M_tjGXKqW_UsX7IbvVvbb49R0HDeX8kmF67Cuz5znd_JPNCpYHbsAcTb2uyWSIIx-J4Xv0WW6mu2AH--jtv7xFmgf5rJW_VtAZ4tZXkgz09QICl0ptGLS77nGzsweFd_Zwseo2Lck2uGBLaSseG5K-nV17IkK6lRDRuHpyRiaB6e7RwYBBmUEHdcyyBD2TDV_gEUq442sibLa0-yjrWS0R5EjkZtDN5LWI1Rm21_68aN9zSBwtuzdWB0lvv7Q-9geX7Be19WVr1axId1hGUlLTXr0h1LQzragMstKB5e1-mFcyG_qRlLk8-vbf7e-1cNGER6XyMizyVWjSvCiLQwdAtPqXURQ1rE5-LPzpRI7z-HY45EmlrNu2yJJHAPmOMm7EUMbs_px7tJ0pHE89OC0rZxJls6HLLtwcR8vB2mtD7Nft0D6kWawYdk726esRD2PB0Pso4h-2_QIuDGGcRf7ha8iSyb41RfV9VFIMQd1C3hxQcP1RpfQtv5-7LDLkHkXHOImVIe9UMxcWmAabumoR8i1Qt4R3HORaDEkseCJvGJSv8ytpjo2qmRByQeO0wCXpzzHR_OnMK1Yc6oqYtWKnQc_NWx_i07Hpxxk3BcK2iMt2Ubun9DckRVo1apLqKrlLXz1pn7kfBSsmvlTA75NyR545oq2UBp4usTN9ruXhvxdgLtWppu1EwYCepe7SwsEEJKh4AeyZodeK4YbIPd1Qcj8J7SSInvtEuMcUtJ6cHobW2Rd6JQzYzuPa2GurOD6hrCq_ivp6AJvNRg_8hHY5moJ5kutkZ--gVl1rAO-YHZVdfif8eB2TOiinRC2G01H9dZzLkLCQE3NULiCMWnxe9K0tW6TzJwKIKnMlkqfmnGp0wOw4Zp2yL18ip5X7nzVriQOG0d6O-Yy-UVGqdbep3kEwv91J9NaW23p1adsiM1v6cn14rpNKz0Tp1GeZoS0jjl1UW4-7hcnEOAUB8nFnjNCASuntp7Qjzp9aeCeE-3VRoruYe6bDNhTViY-mBfiwccMjvD6d_py7un5_j8p2G3LuzfMR7vmcfMu4y-zZ_eYy-y7jNa9n_HjNZeT0ZxFD1nHXmOdFHUbsae05Y1aOnT1x1t9Bz1TnTdNmDBTkU72ncAPSdtLFBWvWBnVwc05b1oZ0pyzeqOceH6M9p0adDHKmowvCn2zFee0LXg_OdRGz9W9xioxSPcZ3IOFiGFa5yRiADO4_ANeElMSAIJhho_ANqb8AVwPwCPAXjGPDvAnwJIAlWFBvEAV4pCAUCXoIOOUbXI2pqbmLwHgMbBdhkgKrD7AQJAQCSAwAMFCidvLNsDyAFFy4hpA8gBfgeAYALNDcV3ALaxeQ6wPwB-QRO0yCgX_AIQC3A9wI8DcVp4GyDaEge39wu0iF8hefwsLrYA2As4Jhd5E5RrxcvA58FEBEX-wCQgE7GSFxc1g_APQ5QXelBBc_mt3B56gXKlS8SUQ_AMpECXdMFkAJAGl15DsA_AGeEmXDkE5fce_F_lBx4tlyoDUKDl8oaLkQsK5fuXVfkYwOXUZLQa1GcnPwB-Xr-AFf2X0FyABnh_kiABLAdl3ACreC3KBd8SOU_XB2XQV6lfhx5ggCgZXWVyoA5X90dQAmXBV_5duXgV55cgAn8BMCYxY4C6uZXTV7YC5XIFxweACH0IW5mX13HXYmXetDxdtOJV6v78A-EuNdnEs19AC0-4TiZfWXHDMyyFGrgJGC3u97o-7Dyz7pO43gYejgDYw3IJlfHuG15_CRgMmDdeKAfZvwA_uBrnUT8A0gfNeSuL1xYF-BaIIBXeLXADrRWXx7lDDLuEMNjA_u6xB9e-BugT9fWOq1xdeCAm19dd3XSN_dfnXr45ddbXt1zddnXYNwtc6An17IFCBGV2DDHukUL_zHuIpWwyyh3g2GRx4gl2MdvXmVBDeHWDN6wxM3lgd9c2BK1wDdo3IAPYFf0HK6jfrXvN72YPXkrlTeDXf7vu3gXdMFZEs3FgDxfeXLl6BcTXIAEPMA3IAEJd3ADwE8CRJVoCIDeLo-haCQA6F7OAWgAmFDAAA7PohzAfkCIAQYkgKwCRQq8N7zkXFQORcqJs0FgDVQWAPIAdQiQNVCJAvtwJDVQAkHFAgAsSfwBF2Dl--Hdhgt7DiR3ioVrgmXqobDCv4_ANEBgkeV6ldUIT5gACVUMApCRQAmOwB7IwgNLtLA-d4XfF3EGs4BJQSwCbLngeyA0BLAgiMQz6gnV7EB2AAAO11gka5NbcAg9jcBa3jwCMCj3p4GXd6IiF6qhQAj3RaBTuqsFGrv1UAGhBqoRAHACqwqECHTEA_5mICt3a9wfzJIksFICuAEgGz7xgIAAIerg_ACFe55ct7WAJ3gY-rea3Ilzrd-oet5aDkROUEbeKXBQGbeW31t3cBCgJMIheO3zt9iBjg3wO0hkont97e-3_t8ACB3HUMHfAAod_wAR3qt77AtXMdwZd0ED96FhJ3oFyneX3BGBFcLhyt2neq35Q0_dD3L95KRv3JwB_eG3xt0pcpAf91bd5wtt8A-RADt07dpHkD-ldgPMADA_AAPt37cB3QdyHdh36D1HepX2D3HcfQeD0qH8XVwEQ_m-vGBBeZAQCBVd338tyADGX5D3VQjXiAFNlPRUV6lfcbys63BlXWj2JDEuw-FgawALiNsDcAekKLdRZtNxg_zALVwn2x3xDwo-tXmBB1dog4QgY-4Pejwpmd2oT6URGPJj89EtX8TeeD2AgcmS2WQ7CYaBtXeAEE8j8z9M3D6LmAKfB4Abj3-4ePMj01c-PRT5njqPej-tOiAUT_4_6PsR7o-TZM0dNlmPTVxY8pPaT_mDoAWkKrA_AqsILApEG91pCVXMhEY_kidwLDeSuyV9NfX3xGAleFXH0DM8tXIwD09MIQV1VceXDl5eidGSUI0Dag_AIs_NQPV7M8qAmcKgCqwVquFdpXkVy1cNAySPYBLoDgFkCf8XV4lfTPJzy1flAMiKrCSU1z1s-pXt6NZVJ6dVyADvPbDMs_R3voqrBlwKQ2C9HPkrZ8_BXlAAM9tBvlwi9FXzVw5erVGV-C-sMkL-Y-AIeQKrCJAsd3i-ZUBL01ef8rAAM-YP8L-sSUvRl04Qwv4QIU_0vZxIy8gA4xLWgLPDL0i-pXtgJQDJgCzzISyhhV5Hd0vqV-U8X3aj1ffVPQsKEA6PTVw08zXIAM087RrT_E_AtiT8k_l4XT6s-9P7QtXjVuqsMRbDP_gDg_RParz-YTPRN8m4fPxVy1c59vLxy_8vTVwa_rP_z7c_bPuz_s-HPfL468OX8geQAXPVz91ekPC4Hc8PPTz-bgf8X_C68OvWL6lffPKQL89Kl4bzc8bCLV0C8yIILwGDsvibyldNX4iTC9mgCbxC9uv19yi-DP6LwG9Jv7T0S-4vGL5y84vJL2S_Nvlb2q-_AtL148FvFb4G-pXUQLOAsv_1-S-lEnL9y8C3Y73QScvgr8K_wvor3zQlPkr2U8VVFT2O_8AQQAJBKvRlxE839dT_HfWv13LE9tPDkNq9JPqwDtFVAqsPmVj0qsDAHkUMAPe8fGRAKrBPiHgMeBIQ0QMKDPVOfREvX6UA_KBbviADND6kRADJCFcUffMOsQN79cH08f71B--iGoAUB9Pnk0B8wAAkCB-vm4H88CBCxs0h-aOw74VypPBoDCAYflr2E9qZtr1M_9v9b3M-yFC73VRivy7729Sva7_I_33IABnfwkWd01fng54J4j-o0kMwgwAzwC2LCghQDK803crybSSwFrwe-6PKr7G4xPLT6Y9avKsBe9GAwMk-LbM0H9QB8jiH2J8XPxH10-yf5hhR-HvVH18R2va1_i-dvenz3BBX077DicvXsvfR7In6p3HdoSUCK9MfS7xQ-lPQF-x9-PnHwHC0A1br24ugtT7Ee7vbVvu-NPVLz-Ynv6nzq-WPa07PDBukX2OAWf_j1Z-0cNn668DvTV8699vdn0V_8AHr_ZebP3r6lc7PRxn6_fghX3R9nPIb5c_klGbwC9NX9z48_PPcb288dv5XyAApvab5J_VfWbw5c5vkik5v5vzn0s_2f0L7C_lvZX81_9PNb0t8Uvnbzi_rf475t-Nvbb9t8zvnb9S89vtb019FvTL8O9hAo7wN_Nfk7wd8ufnb3O--fmVMx8BfK70F9hJOX01fcfVnLx_8AnslI1XAo9yMBCk4X8PZZfJMFF_rvo9cyxgAzEDu_hPcX3C8JfKnxq9qfDlwk8Xvd7w-9gSz75EBvvMAB--Wq371WKWJ17_mWdAcP8nigfDlAIBgARRoh94QKHxT90_zEFh_6kdPwz_4fRn7B_1e9P_-_iJyH8O859fP0UYkfhoKz-UAX30082v1nzR_Lf534ID0_933N-DfbnycgefS6JQnHGPn4x8vf_ny8QSvrH6u-ffUn3RRVP6oQp_Kve78j-qv6rxECav2L26JpfJoNsDbAMwKrAOfoz4Y9HviANR_c3tH4r-sYcL7N_HPav2O4a_nn36EtGOv89-lEr34b-ePyjyb_rY0P1U-642wAghWIlz4lDpZ03wj9KfYz77_JfGP-e-6v4v0aDxAmf5UDr3vEHn95Xz177_-_xN4W-nPae1ACofDH6H-Ivg3xjAugKv2H_NfsL6rBPR2wEQBx_dBAn9hPgX1y_BfsryQ-GygAaJ2qwzD0fhW_Rv8n8ffqfxx-6Pat8Tca3ND9rd3o2ne_cG3fetOSr_pt-bfsPNt0A_23kItXpMwgO_AAa4XoEv9wIl_ykCCPcCCg9KAIj3_-B3NB4hfXR7H_ERppvKrZyoBH4z_aV4lPKh77_Z-5H_d_6n_T-4X_H-5X_f-4cPO_6IXB_5jgOBCqAeXD5AVwBv_bTqPdCAFqob_4UXUO6KAf_7UAwAHh3Dx6F_H355fHBAFfVv4tXUAEEAWD4T_WHBivYAFNXDgHr3XhgzAKAHvfWf6m_WAGP3eAGH_R4ACA5AFMPNAGsPa_4APTh73_TLiP_fAEugQgHEAkRpPAUpCRJSgF__H260AqR4MAm35KvGX7XcZv72vQP6nPDgFcAvX7x_P_bm_OV4CA1WB4QEQHG_Lf7CgL754PAr4H_YS6IAk_4MPM_5f3T_5sPZQFYA7h44A0TpP_AgGv_AQECsDUAUA3_7UAowEIPEwEUPRgGM3Jv5y_AP4K_WwFL_ewES3Sf5OA7wZdVCK7sUPIGStCh6K_RzIRxDAA-ApP4tXOoEtcRoFFhcwFlPYfwFeBy41zM37SfRP5quDoH8AFoEP4AwKx3VK6OBQu56QIUrrvam5jvFW6K_N24LgHy6NAmf5yPDx7CZbF6K3WgBtAxDzRfVV7J-EJ5SvMNqzA4oHzAmoGnPG-7xXHf5NXNYHChRoGbA1K5XAsK59A84GJ_WoGBPVqxdXFj6b_cABLXB4GwhZoGfAzq4hPDYHxRT8RAg9q5fA0EEUPQYFW_fx5Q-GG5VA9hg8XWgDCAm4GZUWz4CdCC7ZfDEEogob7Q7Nl7HuCwAzjK172BSKAwAZMB6QIyDkAaX6lEHswiYYkFNXckGuAKGBgAIyDzvdGoF3RkGvjXR7kgvSAwwbGCg3PEF0EaTA8g9tz8AckGF3MAB6QOF7o1LaqdFCUHC3dACRQDwDTAukF0ED0rigptySghSCuASKAcgjwAag2HDClbUFC3RwLIwSKDJgKGDGgj6AW3Xszo1XUHSYdABQwOUFMgoTBmg_EGOBHswCYCkGnAoa7g3P4EJAHHwbwHXxIg1K5oEBBCI3DooAAUjhgwmDjBHRTOugYKh8Mvnl-QtykEJSSyAtoLyCTIP8eo5BeBTINJBXfjzBnHxiYrwMpu6NWTA6NUVBTbhigTIP-yrDF4B8_yWeFwJaugoEb0qwNEBc1xuBPF0BBDlw7Bj1F7BMt3lCCUTBAA4Jqeaf1XACwNOeg4MtA6V0aBWQKteamU98NXyW2cWUqeb308BdMExiXgCiuYIPlC7YMnBw4JNCY4PGByr2PBHj3aB8INuBEuG_uq_BauwABz6Yd0b-r_iNuIEHTBVr1FAFBhEAI4C4QpLnlgGtH9B9lVfBd4PyA4UBMuPZlKBbwLCeivw7B6IC7B24J7BB4PFCR4IVeAINHBEIInB6ENeBo9RnBaEPRAd3DIepgKR-QwN9-q4PG-HBwN-0_1EB1vj3BGENQh2EIQhJ4PBB8ByYhir2HB14JR-qtzvBvQkfBz4LpBkd14hH4ORBYT2_BUej_BzeHYAgELFowENJBQkOHI4EOT-UENFKLYOagbYIcuW70QhvwOQhFD0eB_API-LEMwhbENSuWkNwhvGHwhmkIw-REKH0i4LMBN4KMeFEMje-Vwp27jy3BvwLohj6AYhiIHYBhkJQhiIDPBvkO3enEL2BZELfBfEIcuT4OIwL4KL-4UJEhLfzYY_AHEhv4JFwUkJkhhADkhoEMUhBDyuAKkKiyfAMshEYIUQcn29-NEKQh_wKMhjEKKhsiBKh3kJkCWEOqhaBHM-5kOnBGkMahJUJshCGGHBS4Mo-P5ichbT04uqzB-BLV08h-4L0h_YPahzUP8h9UJMhTVzM-8nyvBoUIchPEOHIEUNSuwAAc-XABihPvzihQ4IShrNxAAyUK3w_4JHA6UNqeoryyhloCUhkEIpuktzUh1QPeBpz0l-2kJauukMT--kNh-8P0qhAUIahxbyp-U4IIwhUL-hzEE6hpUMPePUMs-fUOkaa4MGhbkMT-M_1GhdUKwe_0O-hM0OjW0dxRhi0Iec-wOU-K0MtAa0KauG0II-fw07-MAG2h2QN2h-wKxBX4J_Bx0LShQEIrBtYHkheMOucEENAueULuh_QNbBj0Jaulv2GhDlzehYTw-hIAD5h40OMh6MNSulvwKhbUKauRkFBhdkNIhy0JXB0MMoh64Oohh7wRhu4K8hqMN5hdUMChDl1Fhify4hqr3ChDiDgkkUOD-5MKtelMM_BYkNphkkIAhDMIuhsULAhOUKigt0NnGMEMPeivzC-mXyz-uIP5hqV0Fhh72FhvsIi-_sNqe00P1hqVzDh4PwjhAMO5hsENOescOyAEP3lh3UPsh3EOVhi_nqurkOKe7kJGhWsLGh70ImhTVxThPT3jhqMOjhZcIy-4cPcAAcIoexsNxhpsIfBFsOihgkJZhVF1thh7yOhDsNOhTsKY-l0NZhykI9hc503BgMJlhs1yr-WfylwOf1cQ9fxAugcKauwcP8ewsIz-M8Nr-ufzc2-fyrhv0KnhUAGr-2fzr-28Lyu0sJ5hAsOnhNfznho-2m-6cJIh_VjIh2cJhhecK5hGsNohRcKRhF8IPhG8OvhC8NBeUcL3h4AEvhR8K3h5_Ab-jcKWh3EJbh5sPWh7f1JhVsOn-wkL2h1gIOhvcNShjsNkhjMJJBQ8Ouh7MNHhcwLwhk8MX-2nRX-CgIVhD8KVhP5j_MucJP2r8P8eM_1euOsM0h7_1IRJt1G-YsPFC1cP4AGDkaBcIO4hOgUEC8gTte1YKL-OgXDBzIKRmvoPHQHcIiCHNyiCf1zZeh-ROujf1kRegRkC4iN1BvZmEwpwPkchCPPhpkJYRqO0gBGcMVhWcKoRTZBoRG4Oc-G_xaujCOmh7AMMRKuz82u8Nmh3CJwcp0F4RPTjIhAiLkCeQBMuIiJ9-YiK5uEwPPAaoT0gFtwOeeILZuX1zURv1xF0iiI6KyiNER-N0iCYwJaukwK0ROiLPhScIcRJCKMRaqBvevEHIRLIUoRQ1gsRLkO6OTAKYcFkg6Buj2420LBvB_j0ucqAGHh3cMyo2TCZB-CMcBI9XEq-cPhh78Jt8xcKFhpcM3ejiLIB44IARriIJBx0EK2IUOxhtSJ6uugDsSUQDSA7AKcREyNxuzSNaRoF1rB2QK2ROElGA0PnGICCHRBVENUhdCPzog31cBQgJehDlzsRHCJ8hzCJIRNyJcREsKauPCJMRFCLMRZSLmwliPVh_jz4Rqrx8RhN38RKiPxuGiN5ulkCRmFtySgoDiiReN0huqSNT0JlxBuYKMRRciLSRDlwyRIt0ZhuiIshRCOuRswEKRiUFuR5jw_hnyJKR3yN_M5SI4OjfzUyY10aR7TymuCyN0eWyNwR-0I4YHSN5Bxm1fG4tzmBnsPHhwyMPBTyLABLyMmRbyLcRMyI8RcyP2ACyLsuSyIFAPDF-BYqM2RSyPZRHRUDB-yJ3wIwCORGQBORfyPORzgInh-iP4BLCPcBw4IYRn10_hBiJIR5qPFR44OTe7iMjhmQMzhdv3MRvyIqRViPFeIAEBRuMOBRQiNBRySMhuEKPsCekD0gSUEigN4AAAnDIiUkRijkUTsikkYEi40bEiQ0VojtEbijskd7CCgbaiNQMSjXEKSj2nuSj74ZSi3UT8jckJYi6UdUi_JHKi6YMyjGUayi1UW7DqYWwwuUe24ukSUCekVG5_kZx9hYa4C7UQ8i0YQ6j3kU6jdgfMjGUfKirnIqjVkQ5cB0e9cVAE2i2YYflNUUsiDkTqjSOPqjPUdBC9ETkiHLtY9YgBVcRyKnAwYfQjRAaORrUVS9NHgejH7vajzwRo9yrjeiKHsxI2kZx8RoMaD-AMfYo7oGDAIS6BSuOm9X8Og9fUbjc8fCGjIoBbdVYgJhXHiKCmrtL5TvCyjOPlSRIIY6C6YH7pWAbl0W0f51dkc_0IYBbdSwdgi8MSgjn-mBcCMR9AcMQRjiwawwMMQJ0o0ejVMqBDAbQdyihrkWC3koGC8fAmilEaDdDUV1UgYfeibHvAA74QXDsXsWjB0S1d90b0BH0SXDxYcOjeMdej4lsODn0aJDD3m-joMR-iv0bjcf0aFgXeKcD0Hk3DcbtAjTnjVBRPl0B4APIAAAF3vozuHxQwjH4gtBHt3IQJygZsCa4WkFYIpmGBg0aE2qK9wxaZBHuXVOAWY9zHyRNf4JfMJ6IY9mHIYwLCTPRTEcMKjHutAJFEYiwBag8jG0Y3MGMY0ogCYJLF0EBkEdo9hh8ongEsYvTGuwpdEd1XR4hY3KFhY1DEvothjRY9tyxYuLG4YlLH4Y-rHWY3LoW3dLGw4eGDkY5jEj1QMFvgvNBqoG5Bp8dN5KIhjFwwsJ5AY-dFvgiFGRg6MEKQRMEMgmMHJg_LHDkPwCLwOJH_XDjHdYu8E9MeHDJ_KrGw4P7Lo1RsEvfDbFLY-ICTkSbFwAKMFg2GbF_8ATCJgiGB6QKNELY8bF3gtMENohDGUgJDFMg1EFqECrGUYkjG1gLDG5dQ7HutCjGYg_7EWANLHg4qKCJYgjG7Yjhg0YqHFZYym6dYthjvJPFGtQk1ERvLqFLw5lj3AphGpXBcG4Q9YC56V85KqS2Cl5ZMRAoAUTqqaS4GyfEQJ8YHiBwYkR1wPJhsoRNgrIH4zp5SQCs4_VDgIW0QQgQ-RXqCtRhoIFQEqCZpEqcLTrAQuSvHPFTjNXORgqKXE9xbuTdNbRTrANRRzyCeR9yVXEbQH5BaNHWTT5EuLFMPSIQZZ3DCKQwyuaPrrlEK4B5KAbpPsMGCKWQBSRgSKBRo-0ElsXaqO4j1Kx8BFSzsLrTScYrTNEa3HHMaTgvSaGikkJmR6cQPExUVThYKB-SR4-xTR4zsA2KCKA24xzjvEFmQucUPFP4Czj-EQIgQkVJRx4sPE3yf6KWoRVDOmNQ6WsNci5wIfhcKOAB3efEA5YJsRnwZ7xguI0zHyWI6eFFXx6YKw6hRcvIX4NcopRCkpG4F7yi41pry4mOTt46g494_TCHLX6hXAbZB94s0wD4ucoJhYfGYqUI5y4vFbj40myT4umpd4-tYyEIew-0OfFNiP0xL4gWjwBboCQKTXHtyWI52OAxR0jfZjCKb06OseaCgwU1KP4-_EACacZxae_HMbUHDz4v0wQ2WNYWpQ6oGYdjpQSXRE6ZF7zq4jRTX4hzC34t_T34hPTv481jCKWUJ34wWpTrcAmnnDAAReJ8Jw4fRgAEtcqeUUxSwRVWzpLUHwaBKKBAErYIOpUAnAyQWoQIQfHYOKVHPsV_CyebMFTHO0wT0SkSoDe_HyidgQsCdNhKiUtjYdcETJsH3E88BUSMCErK_sG9j_sP3Hb0WzimcBzg1gPoikcVzjh41YiaEnTgXEE4g6EtQnWKGqYGEqYgyqDPEqErTjZ4zO66EfPGJCVQnTHDBwsrNnF_wJ8AT0emKWoYtiRgCehsoNWSKqGIwr3MFAFiKnF6iRIy04rVTG8BnGm8EHjM4h1T1wB1CJsGYxa8dEROkEFA844VB28A-Ac4tPJUsbnF4gZwkW8eKDGieGbPNVuq2NLZorldgBVNPvLxiAsTaNPYJ8QCvEm40BSZcacaq8dKxgTMFCl4_lTl4z-bG4-tZJkViA14uvE2tRvFPeV0IveZcqq1BAnoOPQZv4vfGFSb3pEEs0yyhRA4oE2gB3BdqyQEkRLY7NKp95aYlV4H6opMLpwn4tcqT7a_pHEsXTRxG1IOoeiqhUHuqAWZIb31GMpa1GQgd4yVxBsRpDrED4nJDZEiFxdgl39EAnT484lnA-ijY7KolTE8jaS1ZiAZZYCgh1AYmX5P0xfkYOqUnIhIzE_wbmYUcorpGKRF1fLj3EowiMLCKrIkmgmdcOglAkp8xbEq6ROow-h8DIjx-rLgntEg4ltIXgmTaFokjCQQmrgUzjegKUAhxb4k7ATBACnVkmmcTvpx4QIofVOqpSE6thx4WqqtVRIRckovCxudErSiNvh1UaUpKk4eqZUWwq0iUzhcCOogOlNUmybHGZeUNoncmRwlpEyFDgIJ8ApExyRNITwlOkHwlP1MnEcNdZBOkq2DBE7ERJGf7i_1B0BINdBrLwEow9wZBo4NGsD5NHZrapGsDlnWpo4rQlQdNAlZjoIlbzNXYzrAe-ahkv0JhoCMmjNGNQmmdYBVNLFZ8LJMkIzEJr-NVGbrAdMnFkmsARzK5pYrW5phoUI5otYFpMHCwDZzQla5zdYCbHf7QotMI7xNMNBwtRuQvHYuT0Hd46dk4FqsNKlAf1OokVrRolqHZ3B_LTLTmiccJRrctCRgGfipMH9pyEMvD2LJHaX0b3qjdSJLW6F5bqTGlqdsZhYF8TkZhoMvAREYiTpjfxZiQC6bJAA7IqsXaazAVlLMYJEDD4M0QSwIWDJAOabaQS-gpMAFanmLfDbAH4BjAf-aaLFoZV9IvS6LKg4wbQObU6aZReHQtZv8Eo7ZbAa5dVLw5zHcY4Lgc3EOaGhTxyRwlAjNaR2aScnrE-EkfgIgi14l4D3eBvFTQAshjElEIveEMm8LaP4T4ojz2DUFi5vaRRqrEimUQWkbH4mil-mec7n4lfFguUskjuDfGTNAOSxknppzNElb7E4pbHk0pb7MCpZ0EOjJoTOZYKUlZxLE_yjuRBEILLP0ivLdOpqU6_avoABIaTYyam2LSlHET7JnLC5ajVMUaWUzsA6UiUZ6U-5Z-pWWxoTf4msUsRTsUyRScU2RRWYPtbeUC_HFE65q1NOSlWtP45drNikSKKRQlhMXS0jRHp1UUGAOU9ADHpILF_dVolnEUzApU_o5_EmklbBaKnAvPylAknil9rQSnrMYKmiU5ppomcKkTnHoInEs0xnEwiT2jeYn_gMUYTnY9LSOXTB1U10bdLDSnohNYltUvtbKVDqk2RFI5nAtIa0EwEkZSCKmSzEElQEsFw5kh-YCmcKm0jNKCFUjilxU8zCtLAU5xCWxT2UhqnaUxk75UzrgbU3ylbUmamlU_qk05UEkTEgsl3uZGYLNU5osUgqneUmKnFUy6nBjSYYuqMGCDUqeZYzCKSkUhfH-UX6JBU4SndAUsnrNcKlXDY4n8UtcpOUs4mm1PsZA0xElJ9f8rVhLeakkpSl9rfdYIhCam5bZXpShE1KvzV9Z-odAnEJWABYEwmn5uVQB4Ew-r5cUcb6MJGnVjHsZyxFQhkoKdajQP7Is0amnDEbdoLBKMZ80aU51UXmkJ6Xmkq2a9xg2FRIReN3HM0sAni0i7HkE6WnMwfkrUE5sEqU0mlE03mlnEtaktU0AkTzSKnmpXGkSjcanvJVYmtUgKnXU5glgk7V6RzB-a3NcKlOzeqlw0xqmJVMRJS1WehDzE5YrHERTmDSwbbUwKk60sql60gOlW0l4hKjQk6qjFSZUnD05JhOgl9LA0L40iwBOzHkaSHZJDMzDEZsMXTJxCSkABUDmkq02Oqx0_jxvrMLx00nqafrFmkp1FRLp039bGBNrw50_6rBoIda_ZNpgd1ZM4rdb9AN09M5bda4LV06SSRZdhj2nAMbscVJzXuf2ZezPOmU0hmxtMOQoznPKkP8RhZfUstB_dOLRLmEebIE1qn_U76lk01_Ap0jdZp0jOmr-bOkBzdADigMABN0gulL0yMZdTUumPhSQ69TSunCSMlA102sbLVBunZAM-kX0wLwt0vFzr0kPSXhXTAjzCWlq2T2a50z-n50qqzLuUzBAMxWlj09-mn0vAhf07ACq0tpjrEcW5o4r5Lm0-gmzU1yhjIJeYA0v2AUk8GllEmKZwE55oxzWql_Qe85WCaanmsNalm0gEmDUy2mG0_1D_yahnzU7YkveWsmMHF6mnUt6lFUi6n9EniljHRCko0tcrlUsDLEMtsl_NbY7xNXhmxlWhkkU9Ck3HTCkvRFKkcM4Kk9krFr9kt47tk2RnAteRniOC2nkqUg6EAa46rEW47YUo_hEMvKpUkzylbBOknyqB0n-El0nYoeRpdTN0k04_WThE8iA-k4BoINTBoBk_nE1gEOSLGUUChNSwD30VwwNAN9QbcFskhMzFRhMiJlRM95rVkqXGJM0QjJMk5BHIS9C6wHYzkMlWAL3b8QNk0tT0mD5pFM7UAx_KSkDxbMm20q5p0mDsm3NCplMHD1SuMtbQocfXF2mYin1FRDDOWaZZ-oTKmnoZywyNH6mOUDqSNWZibBoGulwU8ZlaMfIzv0qZnuzQZkOEp1FGgYQ5SKOMzdMqvFTQGUgUU0CTUUjVBN48YlguUJmZMmORRMutSxMwpkO0yEnBcHMz9MommGkcykNRFKnEkhRlMMlzq1MO5bDDGxku4VfFItM5kByFJk5zG5mnMBBIgnVOYgbRyjPMovCvM-xkkkxRlgE8U6QssSC_MofEnMjJnhM85nZM5wC5MtyD5M05rNM8Kk5mSZnP092YIjAMm6TczAksuEZzIMllS4GFkHMhEnw0yJLMTaZn6rb2k0s8UABzRZn8pYylUs_ZhcshZn0svAomTWFmHUqymssygDcsr2bsst5Yt7C7zu5Oeg2dBzrXkl4ZZJLRatDcem50xGne1WlmT0-ADTMzDI0AUlkpId2YL7XSYH01Y6fMsxAysykC8si9jMwZdh90p0ISQP7LysughYMoEk0s46gisv8amsw1nuzYE5zM6VnCss1n8pNFkR7UplJqJpnJIYpksmapnEs5ywBso1kOWQqQ-shKgiss4kus7GJNTbIBSNGRrO0jVB-mXVkjABVohs31nhsgjITM_VkOsi1kyEK1kP0mADTM6CAURfNmtTb5a7tZ1n0s1Pwt0YHHWkE6nvM4xkZsullVsv8bls_QAps8lmRsm2mHNepn4mHpqxs4pmGMrGn9EoVk8sv1mOUDRlUyOxmDs2RR0LZxkv1TlClIRhieM0IneMnXI1ISyDZISgALSAQBZg9bAuiduCoQC0BYgdMRezQ4IpwRMj9idADJgC0BezdMT6gE2SA6ZYzngaDTywJYA6wAdDrqHuRgc4FpCNU6LzGD0QHGQDRa_AUIIc0uKidYJkWAEORuGJuRpkrZp4cnozpMtdRA6ULSg6YjkJMo-Q3qRWBQKc9RhoFDnzaLX7AaEXEIaSDTD5IjkjkjlCDiTpkMkqYBjoSyBJQCbjuyRnyoc3opvaagDagPoDTfLXS1giTmoAO9kPs4UB_jcvA3sxTmPoEn7LQYmT66ViDaGTXRJOHNZvAWIDGkicm9EqABrkXor5SEohqVCKBYY-krI4DVGrgTpQ1YwDgSgDFjLo2TSUUvAAecgjCp6XKEOg1cDZ6WkQeg7zCDSLACNSUtTQcoHQqwcDn1SLZSYwK4BAcrX4wcmLnDk30zdUCLk1YklktaagBWMkzmBcfCnrMwimIrMzmV40im7M4YlMsu_JHM-ikYs2tSkaJuQrszvH0EmQj5SHKm45eLmPYCogpU23QmgDcyqScLl1SDrmnKQ5RiMs0y9cuUDFQRcQNSIbl1Ud8gRc8zA9KLnDbohakQ0wjkNcywDhU5ugh0_ZilSEAnqMhhmxrZrnT41rnb0SI4ZchLmjKXlBpaFbmcMurkgckLRbqZdQByJNmNWCqTkjJblnEp-hDmTAhIlAVnqrQbm9KGQg9cp-j6kHMzvcipI9c6LSvQD1ktOMUS8afsalEP6mUaHvECcoTnywETn_qN9RMcuog3ckWm2aaklsMHrk2cpmkv4sXTjKWzQduYnm2aLBbaVZkQQuCVmOU-zk8SGSxk8xbkeMOnmuQPinFs-GnM8s_EBGHfFI8i2mnc0-h1EE5SYwNZTsAJ-j9cgVSA85bmTOPZSRAM5RXAJ-hTcpxQzcoHlzci7lM4cnkOMPHk8JZNk5cioiMcj9Roc9sI4AddT88yRnJBe7lHqK5q0cs9S1ZbfHAEj5lYxK5QzICwoHc62kveE3kLabUArsxFnBsydlG8qxnbsm3mX4tjlIaDjkbcgPkfM7KmM8stbL42xmsEwnkC82klLkekmq5WIzioXwhnsv86ekoome2DIzxILIybwWIl-Mo-AgNP0lINEFDcuaEzQoa5B12R4z_gZ4xBknDmemeEzemMNANMqhLa_FoxsmHuKUmfuJhoI0yd8m4ysc4UwypfkzR_CfnqwDVKFNFpktIeIy8c-omzcHPHWcClmwNYGirrSMB18o7hhpYIj3xE0IJqCwZ_YPfnngdHKNoSTLyhE_ljOPwjWErQq_xZramRFSRohTbJKyO0yrkcpC3oVglIpZXIcqZcT7JSOljxTOkn4HEr3mIsJgHMwjeGCAV7AlXBbEiVahBHpxQC_JQa0_jxqueAWc-D-ZG4q1hb9H8qqWPSy0Yb-538b7prnIGhHpehz8SXqw2_GuzDWE9LrgzChHpVSwh6bWxveZSrtAMQAD2ZAqCwQUCCWUwxa2RgBcCsAo8CmYCCWKNHiCiQWSC8QUowaUZH0VfDpJYAJb4WlIHZKHZzhYAKwgWYgaXUBjiNDsB2AA7LRhVZm8UQcrgC_jxFhTmZ5-Ldzp-a8rh02AXYw8wV6eIORN-ZwJrMA9o22CVBF4kbylcponQyLiI64IyJf8yqA_8vmBmoc_nXCS95S5V7IC5BISGkBDiKpJDhjM9YBWpQZkoudfndIfLl4U1ZkEUzZleC_onbICrleckYk0UmrnBU0fmomb0yUMkYCjRFDLqrWBKzJTALamVGw9cy0yYEN5lGM7BmAhP8ZVCjhnh8j0womSs6x84xkdCsbk2dBAV_M-7kExZinO8qakfMs1L-oL3nPndFkR8uzCKmWprOAAYXYMpIXDC-EajCxYXRs3vmdxfvndxXuKcmf3m3MviB85RHIOJR7IijTekXCqIXXBePku0kGnwsodnYMu4XQ5RPmewpoIvC_dmZ8vwlHsj869SS_J587-r_nYtSlqNyDlqR2QT4aEndAMRhu4CfDpEj0SHqSExhM5wDX8GolAiu_Ljkmto5ClspxcTqTKc8HxCAcOISwQKArM1glrM__rUAYrnuUnAVlcvIXkUyrnz44oXEMlEWdoNEXX8dYXeswkUqYeYVfC3dmestwUZ8pxmoALPkBEtpAFibjZVGd0lhEy9mOqA8TyYY8RHAfsSuiIsTpiGNpWLDRoU4-NjSijyKaAFUycqKyRtIGSrdE9Ebdre2rx1Vvqr8kWyAmP4R3gYagMXOzQaFRGrUAFCpibffJYVDlRuSW_KvmG_C35e_Jv2QqADeQxiyGYtzZWJfIBi4tyaoLrAsWJewoyUGTX2bdblbYfRgFQZqw4HArEFEAqD9PbqNOEArIFMHIZir6Q_5TRwjsHMU9dPMVIFMApGbUeFwETApkFXRw72KSxL5b_IwBEEGwFGiYZIGMUNsuMUxDIKY_TPbrardYKEJAdq0YPsVqHTMU5ObMWBTIApZiqsVkFS8zMwHLE1tVCbDUUchXrY8Dji2xRq8-szkkMcUzi2xQbmbyyiBOtC2AWVBri1OBiFXsUHissU3ivmmZRcsXgdbZIi2YBJ3i0gojsUSb7i3vpFnVHEUTG2zXi78Vq7PpEbfR8WwdVol1FOCn40zfZ1jOMUdihAYiVchRxi31xBjKZzNi-MUr2Xop0EUzB5uOohti4J7pU7CXFivCXNrFlx3inXBoSuCWxDJ64yEaAqli_1CsTQiUr2EsXLOdYigSogpTisoRJTCCXkSu_hYiZArTnXGpW82sBISlGR_4xqK8S9CVJiznyIStCXIS_mSOUbQqui1AARiwTIlEUzC35XjDFuHXAoyFSXuFSamdcW_IqS3CnvKY0VXwMuw9Ae0TKi08Sai5NrktMFCB5aZRjmTBZa1VGQknBHRoSm2rpcZrYljEmCvhHdBXlDQ40jfwChmccaugckhI0GsUqRd_IvkMnQeSl8gzoOMU-1YbY8ogSrv5BWi71aKVtIYMU22J2LbE4hKfvZJKI8vpLEKVgjh0Tsxac1_CT4UqUJ0cqU8CM4G46PyQv2OKUr1KnG5BBvEqcLWq3EusYOoRkKuAbKVEeSUC0gxKr8ODpLsAdxw9SraHAUZxKgTPiDARViZhpdKkWAa_nihFGCLS0s4kYK8ro1eGrMSO0UhhB0VWlErTYkmure9JvROiuqWCSvLGSuC6JNY8d5Mgx3jjSnuryADTFwAYoDo1E0KZTV4Q8-aTzo1IsLlhdGplhIrG1gL6XyI-JF8-NtHutYGVjAvnw9S6xzo1DF6Co9hhcS1MJXAB6W7wYVzyALyoiNV6VMg96VMg_eThBT652VOgjMSMGBpuEHCCWbNyRAEEHm8TiBs6doAD2TGWvgJyh7kf0TVFGACg4ykp7Av6VMggGVIyoGX-o4QJXAesEpYgmXBogny7kNGWwypkHwy7v4gQ3pFCio7mSuBaUd1ePnkAS_m9dV8bv4mELEZASWsMa6VzEkJBqy-7bTU5cJjIUkFo4xq7KyuKn6y36LSkVcCyeGtFGlXwnRGAEUaiLEWf1WUUXsr0mzcM0CG5Y3KSAWF7pidX6a_bX7efDDkbsLDnRiEY6XHFoSqMqsrRysY4YUphrFGL1Rjk3jlFEk7Q0AM7QxbK7RyoGok8c7pCGisDSYqL2RuQHtRCmVWClyntSwtZ45VyyEXWyLRmVy3UBlytyA2NdkWxqUQjoijuTymDvkcizuXX8JZqkMuuWDoJtQHcftRRqV5pDy5uU9qEeXDqMeWWAKNQG4ksxjgOFzt3QWAV4Vfh_8uIVUKLilgEvNy1FUaXmYINKoZcELZ2dWUrOM1IIhFtImhWin2ZS8reFawW0FG-WUC58b2KLTJjZVTKy_fL4--U9IuhdwY5S0MULC54nPymgXu-P37WfWbLeDKPZ6zaCzLDJfANhX0UY2KdJ7xZnhgudJJ5ubJy_5EIA0bSFbPEnfmTi3_JDbHYquDVcD2sQBUfQK4D4K4sW0S5ZyiSLrC3DfUyd1dgDLk91IeCuSRjgb3ISgBNREAKGByZe1wr2WoqwvMf68KiSA9mOrpktC0BGQZWawvYyJwuJrjQgnOxW9DO5L5IRU8K1FgzIb_R_o1bp0AC0CLy90ViYAUBJ8ZxxD8PPBeMf1BH5OQiISsMrD2NhXLyrHQopKhRf4EqxwuPhVwueiQ1gWRXFiigU2_H-zKZLEByK7xVI_GuwaZHhxUDfxVeKzZKHgvjnz8DAAuK97DhKzexcKWzK-uFAV-ihJVv2ffa1gchR5KVYon9DYrLmCSCrmI4rpK8GSu0U4ocZOST8K6-xnmX1yMlVEmzS7eVIKf1KNKh8BOKqpVZCTxUCKnEItKk8KsnKYUkkr_JfSOaTtKroCRRHpVCSlwWK9Trg5KmFK-zJKSzASsQ3aGnn3aK3RkucGQW1XJagC_JbNKuhhFSJzyNWJKDbidPiCzSaSScvQah09ZBV0ClTD2UrYlKWSZsbbQ7ZbIw5xyu0Y2sw5XISY5UUzU5WoALIY-UVMz9SZ0QeachUTrJf6YSuGY9aaMqLWNg5nOEhbnFHexfSJqWxKr6TP5Tezp6QxjGC9KAYKzbJnCuE5fEDeU5QTZaryk7j4qqXAoq6-yHVBxUWeIEnf5feUynCZ4kq9-yyWI-k7OXAov2YsUEKuiX4TasRoAZjgkq9MWZUelVmwhlkHJMAB_YMACZeBKXCudRWjADIDm4G8K9syTzEYY9C2nOgiCqzeUH1UVUXQcVWFcSVXFcPhIyqgQByqkajnODTIyUIOh4qoVU4Ex8DHuarjuK9tzaq2Kg8y3AqgwB1UACKuqOsCApNuGhVaOF1XHpOtwdaGaCeqjhjeqgZyuq3xUok3FxcqqIA8qi1Wr8OEnRq7KSxqnKDCuLlV5uUlC1YNKAhqlZwJq3lVCqq-V1UDgG3yuzTbucwTOBKPBL_dyJgq1BIK8b_KXyzco01GEAVq0mqcFViZpql4C8IeWUtOXkVByETpaoQ1FlA1bani6FXL-V-KyDGqxoHF-wFrWfbobV8y9HH_bJS4HEAqphSoHao53OTnB2JaaASeXtUsIUIiFq18LygXYTp8ZwLgi_qIVqSwytWNMVXDXfg24uHAQAFIigMVvT0gCviASHFCgwF1S_uQtXNUyCRICJtWhcSor50Tvr-oOdX37DcgdHZUn_7OwxBHTOaBaPoWci7XEfQKGpLqw1I85Qin3KFxSjEUjgSqCpQEKDDXjEHkm6YDgGFhGnk_4pzSQ6Aqaii747zKmYCwyJZVQleWmc8veXX5A-ZojTnpbK1Q74iwmZPknyh81BOXXK8xk7AW458yfZVaMd5VsAT5WRC-M5TQU0UXKomYiMsva1mTQ7s7ZCmprMPo7AVo5WbZ5VLrUw45mUTV_AESAnKyTWsQX5WyGDgFgq_eQQqo0otpZTUwq4_ajqnSIIq2KVIqlexkq8GRoqxcAcULFV9KsFnBcPqwMq_HREq9eWWqlzWjYOtW7yxMVZCQMVZCEglLmXoRASqk5ziwqLsq6hW4FGU6-ay1XP4rzTn7dLUSQNLXqqm1K5anKD3VTlQyRArWpUwrhgfYlVCq0iXBcEoSdOaKL6MYOVR_FsIsmMOVhhDhVmgbhVQwYLX_gfeUduLNXijHLFvEjhgI4WADxYSrWr8KxikSCrWBaibXJRKlbSNNABwyUrVI8H9FrEY9y1azg6cw7qr0rSqVNqnrbygEUhlqxtUngL9WxuR3i1q8ZXQQiwB7qv9Utqr_KWq87kJaiZVJYYWnlqk8D7q7WxHK7Tw_qk7VAHeA5nlVTXbAdTVH7WFWBHFTSZyiIBMNXOUHhGzlQ6BLQNTYY5ucmOVkHOOVbaN7Uu0ZtVVqk_BgalTC2sCZWva2HA3a4WCcFYDWcbejbPncMhDlbDXoa2GRYav4I4a2GT4altBL_IjV0awsIMaw0kKzMUX_C984aiehBeMn-rGIZ2BDwV2D2qenHC8RnEzAGmWiNEXCzAA5Dui5jhPs80AzkWYCvs_8x1wMmUzAaoBq63cCogC2Da6tyJnAGXW6a8TXEGXMQByr7UAgE3X6asUhI7anEy6uuw_IbwhG6peVTAZjiXoTID94JhR4VNQi1Fe5Vs6lZV3aNaDhgGOBp4m8DhACIA7KDYjMyV5WX4KZUPMQmDMcF9Z0a6qA2c95LM81PUMa6LJh6iPXUAaqDcyGADh66PTucOghvEKtDVQMvWSwd5KoYYYACASFiIGcf6Mw_qAVFMxAzAaqB_ZBSDvJW7ZKPaqB6QbPVVoOXiwyaqDYueRyhsCiDB6ugDyOKQDMcJqC-2Bliy676DctflIy4OXAm4OLj-YdEBhJH3V3APBQ4IKMAbyZcgh4OMx60N3m6gcYi0og1bZ4DMAnkfPCHbSg4fQXEAYAUYD6ILsAABIPzr0dIDbMBUBKQwSzn4T34v_cKDBEP_XtCLXBRKI-jEWNPYsrcvDXqewB6GfAEg_XbC0YfYCVTfLgIEf_VKQrTnUExlZgSYfCMuK-gR8OUCctAVp26o4Cp6DDARiJrqL9HbJfk2RJTwgLCmlM9wvAnuhXdQPZXeUPqIclIAQyXjDnkoID73eRDTcIPr1wpfxe7Bg0zOKCQL0Gt5nZLfCDSw7bP0cqBEAHWi-c-A3_eYajIGnmrCFNA0gG8KCYGzLH3XSzVX67lgf6Ja4L6WciHYG8iP6k4Ag_RhZv6ovwf63USd0n_XkUEPDoGrXCT1StZaG50VHnR8g4ADe41iRhDMIM-koCxsXLdVmrtAc3BZgVfDN0FkApMcfCKJR-xZgfAiKXONLvZPhib0K7JA9BWVFKIBX_RPw00AHUQZADOwWG5_XKDAvTD2Ggh_6gGKUsXURn0wKV8QMg0D6IWCSwDNBeE3I1VGgo2-EVPTxg2o3FLCvQNGxfLNGyo35GgQCV2ILldGlBnOHMg2RMJ8hK6SnBkG_UhBcm1h-MFXR-9MWhyWfMhYaRNAhxF-aSxKJhncmQidGg_ErGwgADHCnXH4XbT-Kd7C4aZ9IaUW6RMaC6TRldQnubd7AcA5pwNkf6R4az9WzgR5RqGY7Uu0TkrfG_gWFq4txuGt4irEKLgvG2WJvGmsTYyT40pAb4104X40lkL43RAGwyImyLWEyaMpbMe_X1K8OCwLPY0vEWqSa8ughtSWblk0I3m9iOPCAhOPCV69PG0cOPCA65jhx4YYDjERk3gVXkVx4XqQ7iLlbc4VQoOkAKTIjV_DPMDcqQsPaYuYkFhNoSIbesCyRFSBtX93YADtTIrUVG1o1DGwI0beA1wNq6gDJbfgREbKqDymxU0rkMebliS5Rn6wYgrZPGp4wGQiamy5TFoNVDVQdQ2iVOFiGmoCTEWE0246xFzmm-QDvJMfWJgL6AHIM4h9Mck0YAaqDyc3sQNqqYiViYM0IER40ZAMM3R6vTiRmkPCgmvlhnEZQa8iu02JrbUDPQWSBzgQ6KgCuum85btVQ0JlV8yw9rbnLM2X0O5xlXfXLpnCTxVmo7X5Q18bkKJdVvJWM2AhaqCAhWM2BsXTAgEVs0jFCqTtmvs2YwVs0a8ogDtmkc2xm842pKBM3qEIrRKE1JSxmzk1leKhRwAaqCLmmaRwABtXem11jW6uFZ2UNxYnYac1gUc6jltZBYhsDl4MmuMTIbXdJ6cRXXuq7ugzoJyausd3We6uEBMgmzn56m81fESEoJaWM1JaBjUfmpjhfm5nm_ml3A564vVMgmk0V64VQ8yHBAgWrc0zvC820cYyZ2wEC3T6r4ge6z4YCAeC1eUTs1msenUump43czAUjMmjIC3mmdUzoEi1kcS82s8-83dQR82JgZ82YWt822aaqCUW5jjfm7xggW_HD_m4ABsWoC1Z6pkEF6ovWR64fVsyuC1Mg3i2kcdi2041C1x9dC0vmyNhnELFh-sTURy6-WBbm55j0sUFiSmjDp-Sce4UeKjwUeSgBnml4jCsKNgHs7iD0IE-DMkiIRnSN4RUCJ6SCoBESwiU9Cfm2jjOW85S-AKS3mE9ATCkyWRy8_UlSQEc2BWhho8bOy0WEwzg-C56QaEuwmWEyWTUaiPGxWyK2mEtPGsyJK1ucALo6csmTtFCK0ZWyOxdScQnGKMc7rmgQmnCIQl5sAYTKiSvKOEr6CHst7ipyzhpdTTXKgigvm3wFRJUAdzZDweiCoQaoCCPfHzjEJ_7YAEFCYAWZRANSvkBM6QCE_SxABQD0TJdbODzAJaTt3L97rYd1SGwc1SfvK1TCgG1SiGXBjpiZvJR8s2TZM3kJQch7mwc8DmEsheTtZFu4xza_GnW3UBQot2QYcgtTYc0GaT0bVlqzP1Be465ViHWUAEUDHhqaEZmfWlPKjkyebjkulSnMrFlAs7JmXMhoBxMl5qXqJJnYs6JlXM8JqLNSjVTACG1ZMshkfNCuWI2qG3Y225ptyzFlY23Fl5MxdljGZpm42wFmRMnFl4sglnrNZpk2NHvlLsypkJsshlByZm03WuNms2skxPNYpp1MtWANM8m20JSm3nNAW1wmekzC28YyM2obj8EI179Ac0TtW0jhG9NuizgeeBP0WAD7oIxhsQdk7vDXuhgBBJDWsLfA2dJYZyG9RYflE7jGxFekVrEEYdWjICAQlUhIpEAgVSLhSpmb7my6ipiIgaAD3SbegQ8qwA3WheR3Wh61JyViJLmSJJJQHBV2aWGEKOVXl6NJJ5QaQ62UJE60pcuDmHIBm2XW89Q3kd237WhO2nIJO1JQKLmgc863p2yeTtZJHrYgCO1MIIDZ2abFy5KobV9FNACqwTpT68voojFJu2Xclu2STeACV2r7oR8QQ7RKsADmrPaShsjdlE0-02KHLFKbK9fWvBNQ6FLJDLJs2tkis8kZEzdxn0oEdkGs6ZkRpDk7bjVbrqzd_TKsslSCWde0Osz8AYnKwDDDBejvWiubUGsPbBAdJIO_FVnDDbVjdARI2kIPMB6xA0pC0X7owWH4auILITyGl8D4gMPihAPsDyctCwEAJ8TBADW3H_BDAoaiHIL2ytnNs81lkbMdXnC5Nl-oeZkBzVNkWig2moQBRrrsr2YOso-hgpFsakuc21_dA-1_bUBlS7eUBB8k1kYOke2yskOYD05TRVcK-0uqDGwTMhh12syWDss4IiwzcObi2oW0FM6W3c2kpm01fA5nHRuxNTYNAFsrSay1EVm0RdhbekW-Z7Clm1VMshn8LHNkZadukXMbR3ygZ-0xKpI05AD-2FqU-3ipFTSD27dqYOwh1-oIzQD2oe3BoCznvYIfCIgC4gFAGFwPMsRz-lMbQdzAnQHy7EZjzHOz3M75lE0jw4koLqYhOws4uqRLZSso4bUZEpRSsnh1IOvlmOUVryYq4UBuOo4geOhIBeOv1wMCvShxOp8Y2svJ0va5vaglZFlpTNOY4OzPJ_5YZkos5ZYNWCxihO_NyEnOBYIbPM1gCgs0Qsqp0302bw-SxmlQ0dp2V03tmIjWNxFOxykrjYZ0_irbUpxJp1B-Bp3kFJ_I1dKMaEJLfZ9Mlp1WqxOoM08sb6MFZ1frV1mZ4v-UyEJJ3v06ZliS_Z0jO7dFuG-LgMOi4jYOiZ2pU64lH1E8a4GEh1cnVx2QUuQK6QXNyZO2qbfOlICeOzZ1rk9k7uZHe1PgKwV0OsK3ROrqZLxRgwTlfqZb2sF0pnVbr-UX_V3Oo4hyst53b2lF2d0gObou7EA2OykBYuqeo4ujuntAC0CUui0BA9L3iEu_Vmp08unPpUWZO5TrA9TIuIQnWggYqAFmQ2mm0E2mOb8LKJ2nrCKQK9Cx1VcVR2Y2pG2k2_FlS25pn8LPWiPO6Zkik7h1nOoNkhfHzAculOa9O7EBbaa6RWO0hBEuj63autKw2i1WAjW6a3pCIe3OOgQr4aJrScyPV17SRUIJmMrRnoM11acC13btK12uustCRgU11TWt11L2S10zUrUH61bjTZaVe3wADbRlKFx1_O9x2zgIF0wuomk-OrTAQnWPJrkGE64pSCzNAB8lG8vhDbAd3Y3tAoCSAd60ZFIWi42QaJ91KNL324YYqsEAjlu8qA6msCSwBEcDBEr8KNWUp1c2ZoC0pa2Y64Ie3ZgY8At6WgBJAOt2n4T52xuwF25OsNpQAGJ24GD6Dz2BzqtwQV20bQMYzuvgp1uohoUOhd0bOhN2OHfFyxYNF7YOZJhQGyp0BCad1C0Wd1h24YatwJJiCwPcxru6h1TDP2BXuhcCCwTcIruioCe05t36oVt3NO7d20tYqDHu7ICnu_FwJMTGD6cr12IgTLK9u6Q2sAcPI5APB7lQLSCN62QyoQV3TqHcXS1ukpTbc_RKWMDD2DRE4D4MWbjaomViG9V2oZwQxZgO7p1aMUBg8pKXkjMQaKlwCcB6WAVoL4VTpviI3kH29vad4Zuib8GzrpuVqA7TGeYKOFD0bKQ3lZW8wB3miST9eNmzRlD-bQ5NfDN0WQlz0eezw4fAzmAVuDgGYzGmsL2BfBEvSMUCQzl6MWj1VWQxU6VD2KWOa1-QZfT7oJa2bWovZ3GpZjGexZQJ6VcAme4QyL6Ha3ck0PQdFNnjOexZQsGNz0M8XBhBWKXQKIvclhMILneemsCO7M9CgwEYBR6-AD2WIz0lKGL18IW3Dp6BL0xe1AComudZGkAZz8C2L1rUBuyb6erifEUpIQkO8XLrI1ICgF4CbLYNB226ZBVe0To-2pph0elDXyIR23D0uAA926u0guNmWf2GN3ZOuN0Tu390jqppTSe_Q1A0boDFQIu5KQfUhjADcx_ZITA3kMvB16I_hEG2kCnSrgA2lNuiI4ab6SdBD3ceP4aPWFQolJRIBlJIBgjgCB0jgE71lJICVnoEYCHeUGLrVKKBCYZtxjAIH6q0oUqjws9AwAB73PepSCt0CGDCYRdWmCEYAiKvtlCYFSIwAMH2Tev73NuboCt0T70duOLJU6Er2nesr2ASsSU06GL3ZMQjBs6H71pe5Sr4-8qBs6e718IEn04-1AAyChyphGRZSo-m71bij8X80rH2g-gn0GkKH2s-0GDs-4n3KVFn3c-g0i8-yn0yCw8gE6wDi0-x9Bo-xEhvilcbM-jn1gEyn2E-sn08-xX38-tL1C-6MobidzSFOz6X6gHzgQAOn1M8MByAStqrFe8X30-u8XuFQaK5JAT2pCUjiY6dgCfTb6ZQdHMX98HEDLA_97voTsDLk3dp-wdrTEYHIC7OteAYgfECAMPOA52Ith-oeAboYJW3jEDr0uirnC3qx21h-7eguqUdZXrG30x-731moHH5te6r1J-4b0JO2y2n0F1SR-1OnO-_ejJin44yRcP3YgUdZ1K_hzu2533uWDiiq8iSBQwTCjTO-8XE5E53UTBAbpUrACrQXboO7dYgZ8Rv104M4idKRv1uFaiV1UcsYnG__atRKDVwzCV342mG1w2_l06pdGZb0X93Ia6SIYHK9CbABcAVSS-g5a2YB36bXlygIwifc20ofYPf1QYA_1QAI_00lP0psy0hZVce11OOlLijugb3ju91zAu4X3lOl9J-ustABuj10pcI6QWW9G2Z7ETYEUK_a85Qf0yHXNpyHZjXKHUAVl4YiwhdOr1KepcxiMTvBQdD33oAGfglGQrjDAg9CzgXF6X9dCx-jboovvMzWfSxmUaVNiVlCUGDO-i3SkakZQsBmzlRFWQzu2zjXVSMJhX-waLz2fAPLkwgXzwTvC9zaB1a2j-DDhaoojgOlyyIOpSGLSQND6M8mQWcwDY7CQM-ITW2RcBzqP2Aj0YMYIDH9K7KyGJ2kh6NLS0ek0AARb7YVJedYfQe-ICQVeJ4NLYCkcB23VeyMAOBw_k2pHP2idJtl1ez7LYABNrZ-hr0QyTwMPrUykBB1yXFQTP044eTbBcatZgq0zBl-1cAJzGT2gu5boXMatbmO1h0W4UQ4xbcQ4aaSMBZ7UKU0AOQ5lacUWzGAtSeyn-oz4GbDYSJrr8IP4Y1mOlRIabNQuYJdBqwaNT1y9gBQwPSDKzYUp9BpSBktTLH4uQ7y2IM7x0qJLmqwVJ5JQbNSwc89SWASRD2yOUwtB4FoN3A7jngSEVl4UYMkMbiB5eAvZbMDIr_0d0C_dZQNH8Tfh9kAYjMBKPJKJS-jSBAlyXsCUDhrZoA4oSAN1kn1JdoNuROYQ5BsJT4MxySs6nWhYPdoZwCSIMdw0mYyBmAMHbdAKkjO9Qm770GJTmAGj290Bx70pLKR7ewBiCItarHQMJKrAKADiY-8oubaIGvBxg5z8q5oRyPpoTyiSACYCENqBnBnfQR5KqUIYC74doD9kcxiy-AVJ-jQ6YESYQA11ANAKIXdYmdFkMydOlRvBloxYrZWCiEKYP7WjEWFKnACk3SvIrceO11qPO2hHSRDJIDZrJgdrFSOs9Aih0KmdoPpr6gJLl7IFkzywNyCSIPZ4yhzjGQBvvItGPUCdNf4MwcwEPjGEEPywMEMMYyAMnWw4yOYEdAtGHYy_aAUwqhdNGy2oBiLSBbg62mENCIg_iV7ZBjWBUVRc7A_QqB6kOP8Ly1jAX3YGEQBiA6vMAOfMXboMZizOiGvpI4S-iV7IkPhHXFoxssdwOYXuJqwNyB9oNKAqQyANfaaNS_aZFqnW8jkrqaHFah0wSTBlO3gc2sOJh_DqrACRg-IUVSX9XfjfTbQOdaewhlZPzJwAIHapAEB0uIWgBIgGjZ5-NVlNBuZV4mQu08hVO21h1x67B_git9MvCuBgiZfOnSBzgM6aW66NLDhi71X9McMwOm3pl4G8AWDagD_pUuYAIJa5DRHXgaJYcKASKgCNGj8rtWABhqdA1UWBuUDjhyAM52pUNHW6P5wmTcNnW4FoXW0u3nqWsOjbMMMOiALY4BmCTBtDSyAMcbAHiWxSnByh0L1T610QP8lXOXCO3MatB5eXjRP0DbXNocvB5hwBJgElJi0Rg_gg3TkM3tKXnKQKA3MRqpRl4b6bjhXhVcyP3pdkOcACR1Wkg3d8Bg7Xfh6Bgfho8N7odgucmmsAVpcCA_iXbTbCfhn7q2zWYDkUNapmtRMNwgJRXL01j0pOG3rNBgO2TyIO1wMJOQrmE67yh-uRT8yhJExdoyTGXUDdGdMWD3AIGPASxIcEFC5QAT_6lwPIhLEGSAlGVg2dgMnAByrCQ8PC2CzQfNQyIbgDH2KmK30WmJ7INuUORwmKMmJpkuRtyPh-VNwIAryMzRHyPyXfyMg4IKNf_fDoBy9ADhR2YAQAKKOMwY-ysJdhI9qb8QGAii4-3Ci6B3CzCsAe1TlB9hovs6xxf1A0Seks9CHXGCMqhIUE2i1UOC2gu1pQT702i5wCiwUaOiK7REdh4Lg6hyaOHCkHRTNVWBLoZJCGgQUqHeMvCI-_ghrRtUMbR57l2hnaOGgACIA4VjqsgWegpMeoE5ALgTFhtJpYqU6PA6c6MzR_oP8ESMAnR6W2thySnbR3aPXtGel7h6SGifSUAZ8b-3LDG-3g7E_oFoPhhceejyQBLoAq6rXXeAZg0162SIURDSJrh95T7Xa_hvRs5pEEBZAB4xzmaQKfgqPIG7rAF-Daoq4DClChpBACogCYMm41gNnwa0PZCae3KF6QVmP44DWg3gUoS5Q825hoFkMRQBGCp3TSB9AQvIqPSDHgqRbVSYeGAmcsvC0xPtDZqasQURUJaaCwd3JAKPqwAXhjkAW9YOAWMaH8JRJKo5tCQBs8C38u8BJuRfrYMa3Tb8V21r0kXacFXKUWAewb6AIPa2x9QC7nJ_Iex_Tyb1OtB-xwJhDOh2OEuUA6gxGgAj8cnUSOs6qy7NXqiLMlqOAVADjEALat6Q67gDZ0QbaueiSIeaP1AJOPAXFkBW9HhApDEVqncU-B5gVuCa3I_535XEB5u-YAt6UqO5EvN2SAHOMLR6xwj_IiKOLMlpSNBkBkFScDBKXOBl6Bn7D4O3U5AB8kCtVfCee1ULYwAASVAZ9qBSIYApew7IcAceMb9Jcyee6ahPte2YWAJdD8iI4CTgUojWAMcigBcJxb8UoR3TdgC7x1kT0EQ-MCtUkXBAasobai-NXx8XiAcW-NQh0oQZxq1bYeJxbkKPRoDsdhhHxgNDzRifAYWPI2hhn_qQBmSAeADxCSIOAAcAd7Ce_JYD3vZBMeAWopMKT37AGaePdFNKD3vLBPjRkpTGOStZFGfgjYJhTU-akYoNmX7liYM2wDxnug52MnBUJiphk4WhOpAD-Ch2h-yyGBBPViLABlbdBxpQMTDXtMnBMRAROUJ1wbNuJSBXAHID8EMTDpOlo3B6UaBk4G8j4gQpX4uUiyygcwRlOiZgNFSrliYYCwvecsAH4uTLXtNBPAGHIAVJOpxMZIozzQKRWH5RHytBdoItOF7wpAVPl0EFRPpQIoyt0EUL7h1WnDY0ogOJ8CoveDwCuJ2HDuJs2zXtGUpmJ1Wm7hzKgBJuVaCi0ojuJ0eH0UfECSACSDqhcb3PE0GB0Rf-CsAEnFBh3QApxoYAMYet13Mab7vSJPjsuZenSG8wDQJvCy4MSANoEODBGOJFSqwPhBtJn6CqwWophJlpaqwdgAxggNBqhmCOFQfgi69a9mzIIvCTR4ZOFQMloZJkaXUMPpNQ0eaOjRg7wduFwh9JgZPLJqDkjJuyYwAcZMNRLZMF2sP1pQGl76MQ5M1h1ZPnSDZO1GBaPbJ4AxjJyihF4c5OxBholMJpsyD2_AotLRRW9La9oQAWQyk6H6DKzJ3HXtJ1r8OOBpz7IFMbhI0DKzUFOd6E5OQp69rAp1uiaqslqwp4vGCZejIDJuZOcqJhSgwVgBLAV9BkgIlPjAa3QeWX5CFe7SQJ6PBj4pn6AEp4lMzAMlNOAClOR6BPR-ifsACwa3ScpzPaMpiUYIHAEkqYYcyPR8JPGree7bJ4JSJc37lCpucAipm8DDJj-ASpiphCpoowyp4ZOSOxMMLxwhh1JgYRQGxwlu3aTlNdHj2VJojDL02iM2iuPhmODwBBCqbZIqFfyxcJpMWplpYlJj0rxgvQ2NJxkAWprRU2p1jXT2qAyFGXpbup6VmFGK1OqbR1MzO8hTFAaBPbXDaE-OAQAyKU-zQJ08Bxp6NPvADwAFQZxLTHXTKFGWBPYAT1PvYaBMxwJtABO3FOdAZZID2DwCQK66o2pRRYugKACRDQOrsWUtA1ppNzQJ5gONphcCRDWUL_KttPmctEAVobtPduD6Iu8J3GXYGU7VphcByuDcwGg_3zdp9FhuOBSAWJGdNogaJxXa54ljpntMydT2J2B9QDPdJ8AZGnwaTWA_QVoYXCg5O5z2BJ5zygBSDdwfSXmAdxyXkSAA-3U2JLp9NN2RmkYBpoxyDILAC5pjAolJo3XoJv1MmON9NBpp1FmoOPiWKm2zQJ7NOfpodP5pnoCFp2xVT7KtCogF-P1LQ3SsiKqrBKWZBGZQrx7xqqoxi2U7Bs46TDmPsjVMcxgRJzDOFQDcxEZqpiynMjNnDBWykZy-TdUbqJ0qc1OUAZmSogBxze60DPeiutD18V-VFUeY2dOGi0SSbJXHMNOzhOSRCMgOZy-0jc7NLAmMItU6N0Kpcmn8i6DyZomPOAUGAz8an0MVRDMEASTN2aAvVIZveNWDEnj6Z6TNWYKMpUHIjyWxiwbWx7fifaMdyEx9aOh63TP6Z-3QsZ7AAWppFTDijtZ-zZ2NpQSQAAAPXsCs0CCsrgCNuvAF4AEo2AAUMAKgYWYizUWZRgMWbizyVISz0WdiznIGPs6ECbYWwBaW6wXj1YcY8RBGAgOrxMvkf4eaN7Qh84PxqnTuErKz_RsOwlWdOg7lguw50pmUdWaaNDWedjJhSNINWeghVjPgzk4CzTgac_gX6bNshRkykCPgugEaYRu8aZjTSaYTTwTiWAs2ZTTSaZl8aaZfTfEFYzRjlcAo2a7Od0XKCf6aITW2aAzv_NDTYGaI8EGeGzO2egz42f2z1_ncz64akIeRiuz3maoJMvkOzcy2ezRjjyze7SszWwUuz22a0VY2Y8AE2YOzxkoq0cfCewVmhNZlAH0zXqahzXmJLGkOZ4g0OamAZLT-jZ0bC0lgA2zD9gDT-mYRzrjnew3Gc0w6wEFTLZlDTwBk-9MyfSgGOY-jWOZaMl0ZBjzGcezIwE91cOaJztqeKg9fAGTs0ZWjm2cZA-zk4zkGc4zUXFhlvgE5zDvF4zFfGxVUnqI8x2Y8AH6aBze2ZEkmJptsMN3c45QeEa_owF1_5zpUDPix5RxgiZQcmgTGN2Rud105ARctMEvvLN5Oxl6K66nkg66nJFOOdJY5u34aluyDkB21Z2lueC4N4FFAUakWDoTXbk7WUrOvRRXQooB1g8sB85FgAnQ4gS1gTRhUe6QveUvuf9zp1sDzDmGDzzjUR5ZIa-DqsB-DfTS3xtYI5MooDhapWPBzujUa1Wvy8-hjSDkFedDlhjW9zQ8m5ClCQDC7YTlMzuFvy8kE2l7XGFC8kBjuTue51Lsre47DXDCL7zfgVQbBF_BAOmpRno8beyaQI4RLuHxhhiTz2Lch2Q1TQfWrgv-Eb0CNWhBK7jtMgYSc9NYC1ML0WBltNkXz6IqXQpMo0xWioHsOvpowV-Z3cv0WG6m5nkg-ElPzp8tvopMv19_wnlAt-ZiAX-YAs3GOfz2gUJlz1SXzn-b9GN-d199AcfzZgE9SBXNWZLoqXzXCnz0CQFwYJsfp4S-e3zK7n7WGVgSAgJiXzvBIwL5-fRNBFTCDvWrclWRRoDZOiIlL7xBBHFBgCQRv6V5gFdjY8OeJMASLVIrtJdqBfNEKkfHCxEq0ce3ogkDBbgCJSlF4d4AOQ7oUDC3UzGJz6UTsSfBXMq4Bwk-BfPz9nEJORBdvoM9jWdKhF9gTXCXz_gawAy7HULAcjGJP9NX8ovAPM1zvtlAJPhEK7g4IaKrlALgo2CZeHnsGCtgQUBsAYJtG-QZAMS2-YVN2NPkbcHzindvsGggwehSlBjCIA4hYx5Ohf3pJY1ckKhBwAovCe9vhZgAIRdRKQRb8LJMG0iLxGSLIRdUKCRaT4-7WZiNtmSLSIh51jMHYameQoGOudatbCCBI3dH8ZGDQFYhjBQaAZN9JiDSCZdcF7jaDQaLfpK6L2DViJsk2RNZiBP0FonWtxP2tUbBhBQhSZEchuXIMRUYUBAUayg5RmmLIoBBQ2hDagvYhE6LSHWLOUE2LEBbrgyXTB6Pm3D6Z9AIQnoHkQBF2D6UcBWI-gHtyt8DPAvnSo2DfLHAjxbJQRLQTjC-d1EsHUeswMQ9mNnQz2CXDtWzogdW4bX9WmHRLWBAFxiR_Fw6D7tXw0IeBirqwU6BrRRc3dDSOY3X5sSyFdWD0zSKPoH46rDFboq-3QqgiTnxrmzX2giWiiqCorjifRfIpjufacWI4YDTB79qPR-IFDqd95XvcDdUnt9SwH089QGvQ3dEcJW-ExudJfpLbDAaYGywxm5PEVt14fgAb4gNaICxjWJrDsAwACqqT_XbctrQAT44V-L7Qyv6aNPq6U0UCoUzLEISKUx4OSG2xCAeQWeqjk6kQZ9TUwD46FXprAyoCcl43VfMiekMYHlFTp6rSHF6-k7aPxz70C-VxLWOsd4r7Q5IBxzji3OA4oxrQk9ApGDLl81zaxnWFwXRzs1LxEx4_pbXuHBWGoMTJLUodXYAjuPVaMQdRYmZaBznlBTLVpckKedOPAmZe-8ACgjweZdRg4GAiAhZaHTYtSBoMZZ26gEswoJZbQ6zaFCLrZaZLw_RwAvCeTLfpdLLi217LAUwx9OWymYw5a7L4TEzVpZbbLnYpHYMTCT5OJoLKaUB2L6AD2LqqBh6ppf6JnZdxLvM3-ctYFbLPExqOQTFKo85Y2WQTBPLB5MbQ-heXYu7UKgLdN4GdBD46Yksx4cmwKzfHUNWz7QdE3QBslTWENL8sHNjpLR9mJkpZdpPTPwLtyhLAsDh6Zkzg8XZatq8owSd_DjtL0FSbIQFYAI0Ffgq8FZxLa9zkItGSXMmPCwJYNlXCOBD70VezwAa5mIrKtI3MhxRoragHYyOAzrQMZe8mmp3zoAcHZinfo0KgejwEwaBh6KzgYr2ACco2HWxsIvuPLIk35pZnpS6IfRuLZhowEVRv4rfHU-Efegi8IlfKIkx2t5zxM4rNIBrMGaZnyxDWMG7FR9yUXA4Gd1WfWHhRcmwlWa2Pjyqqy-xMG0Swk95WHV6ysykawJNx2nwEQkPkl19UW0da6UEO8cID0anCSgDwa0kAL8CFgjnWwkw9DdxY9F5SQSw0sn7zSAveGkItvXtmi5zUGlVRMr6peiW44UA1QXCqNv5NU5EyetBVVRP69iwz2_7RxkjmhyyRxpJgumAzwunXt6BfSIARfUAYyjjnoWEhJYLm1srJlaqriMhqrGtFtw22AarorQ1Trek76-VZ1EhVf2TBABKrACZIM9i0MSg6AXlooHaDNeX-aD9D6rBOAGrauhhAw1fLWdKn9ypoqMGqgwcrz8CrKj6EL61pedwLrr0GZDnITAFUFg7rjOrqFn4EKNASUSfFv26VZer_8Bywf2Cy4zPJ0cfCfclEkoMcV1YrQl1Zarp5zv4XWGarZFOfSW-3kGxlc4qQBmvNRlbIaKNcJozAchrlPsYL3mpCNXmVKAONfYAFiRxrtEF34YCZL6n4m9GX_hIEHkx_Kk4ZTSlXXngkImKArQtrtQCvIU0dvVdhwh32bijAEUNdTpDCqZdZ3C0zVZaKr0QDmr1bCKwIgFlcP1berUlHZdfyqXMOmoHYiWyPAxceHsLJVwBChYers3H7wl-wv4UXGFrnTursWmf-8nDpE1A7E0zFg3WSSfE1r2QG1rPgejKhFdHCyDMKV2xXer9LHRr6g04qZSqqWyDLorrGQDrWACYrKIWcspVcNQSNYxr51cXFagF_c14oFrriB5Gnw0NrpQlhTRuHtr22PQATtbsAApTeVA7FYD0Oh4GwPWeJrfREWRq0dAycZEcdgAyr_8eiWT5i3wxVVN6u8CfKqRU34gOGVYH4lOAXNS7jVgAFaT5gR4mcGqVjLnMA-_G99GiR1jJixga6EiosWlmaAl22P-2TzGD-0yv6gqTnQEsEvoaQW-ga6N_Es_Q6rHPAAdIgDkQOscyS3QHfJTaE_JQXALjyOzL0g9fowUoH_tq-BwQTww_o8uA2IzkBywJeji6V7T0Dp2R96DVe2GjdYnjaISfMCrFwNzMEvoeT2fgg8fqT5ok3Jn9rJa17WYjFVXSgM1alrz8EKgC1eSc0nUtacNfr66YZe844UOLVPWttys2QbY9Y1LC9b9GwWTnwUbOIb83S9pTi3_a7k1tG6YZxrYnRlLprSUj_4cFg_CDuCTxGfKwlH0WaJek6OnRfaenQXLCAy5LLQHRg2wzYr0fFvtY9AB27VjwN8fVQbUHVbYK_mBL7kBkraXU0bTrm2GM_SSGmQ3as41dquQ9BPqAwDyAoDGP6YkyCGtDn34raWLmPJ03w9FjOlB1cezII2brpVX8Gt1SDy4AzprkQwbWDPv_g3kzJAiQxbrpjfMrvmdZGLMgcbFxOMbUTbn6QgxnVr-K_xJ9R8byQ2BrUwHdtUjdR6E3O4DmMGsgYSVFAviP3E1ABTjM1AqkJTfWwZTcJuHJciAOdk5wtTccc5Tcjy04AKAbyAMzlTZEc1TeKb5oDabhNw6bvlRSA3TcabfWiKbkQFabAgBqCi2xWLmRbHANTcGbszdO8EzacLLFDlIJsaI2Vdu-6cNZd9cDamAyjnEzSdasEf0XYsHDY4q61L9p1TGsG9NZmd-zY4qpfuTFpzeYDCXu5rGzfAG4NYs96TBX4k9cFajwa8LHDcS2gOH5r4NZcijLMebUKRbS-zbMwMiCiA7FdBbYNcFrK40BEhNz3TW-w4b4KVqriLblIYLZRb_NPaA5_hO6cAdObRdYS07FYaKeLeRbyddRbKAL7Qe6Y6Yr4rJbdLdH0JyD3Tx-QyUWLe_WIkj0oSLaxbqLcJLYGFSDewBVIZ8d74hXXfDvdB6YVvTzA4DahDfvU3ooLYPrJjd2AT5ne2YJQtAxUBQBJyBBdGxF2yzwaLgdAAGug9p4YqTC0s5gENGDpeCsdGql8DGoHslxVHs-9OJ4XhtJbQTeIw2NagA9AryUr5lYbHreJ4BoyNb5gGwGetDqLxU35bpzetGn5adqUABQsv4kdY1lQRbm_HMqskMljV8QjbV1dGS8LdsqAIhTbhAD3TGbahrm_JMphbdcQLyeoMSfEZl6GDYrJ6fOJZiikTwlRs5JdfMg6xVUpgXg9rxxRm24Rarbu5lornbYmAvbcYrZxWs5S5hE6HFBrboOrOJGCtpKWXDzc4Qd-zqqo5D1BaYlWaof4uTNWr7WVYIlAGULt9CmmS3DoA-QH3Q9QAjtsHpuDm9E96jAeCy7kEYbxEcvIBSUX4tihQBA4ri1-LhVj2ahZLMeyejBDF7oz_1vtlrcBbUEipcvuzhFo-j7QkgAfordAUcEOSxb9LeCNlBc193-QiAO7aXQkh1CbA5ZCbb4tE2zTHkVdBb-8l7dfwInXJbzmneCkQGjjdpz9GHFuJw3KlI7tgboo4lZf6S7YaWgUVObTzedb9FRE6bzfBKA1nIAHll3aYrzBpo4orLl9NhbTegi8r-HmghHdE7zMFfwA_urrvKGyKPpSeI5ZbqwZTi2AughpFhHcuKuUWVjDQFVj54A_bt0ZOyH2xdAf7YB65aCA7C9Hpb4HevaUHdhbsHbhVfEBi9oHZyybLYS9_xuiAI-nP-QVkI7fPL4wqqEo7UyjhgwREI79LbUioHdk0FHZ1bYXfP-JyGcOsLcTbfUo4rFHYxDFTbk7JMAS7-RnKbppwo7CXdx5AzdKb7TZ8qGLG6beXembKzfqbAaOOWnsMxbZLbzbeXFDbFHa9OhqF6bvKDq7HiDmbXHH87dXd60MzbmbzZYUcsLYCOBHZy7_uwH0FHYjqQlIEq9jdVbgeVBgUnfjrcHbdAWfRh47yVLbSztwScNfoqMoH9bONfS9HHbhrMgrypZNECGM3bO483eErhkXmekdQ3otCPqlpgm27P5VzGzuQSbc3dowalccUHEHxbydedbONdfyD3duKB3bEl-3d27oGQluXNZO7yTd-V-lf2CHlTBQVbZGb0eT0G_jYI0wlUBcCgOXWO8mEqoXZQrdbai7BfqCgrbYy2l9NIrxCtx7tVf9ru7SYyhxV3aYdZUiTnfP-faBc7MXbc7Qxc87OUCCs0cWZ5cdeErGxLpKtmm57WABkFQXZCGWXHpbAvYS99LZF74KTZb4vei7OUFi7VMlR7_gDQuLD1l7M7exbGtFl7aBVLr5CnLris2faez292qTj-b0W3SKzm2aA3jYSb7QzBQz7XzjNdfYAdddKrjdZHAWTZJYSirOgEn3cAWuH-bYwdRkHdblIXdeQYmSj_KjVYlaPVeiW2FlAb7VnlbIdagbyQBXroFYtjhVXjyVvcuNL1atqqfbSdPlFdrIda2K_bfcT4fefgz-xAK1Pb7bpfaHbFSr4gDxTn2L1cZCY4Fow4vdJGb3eE7LXcWb6rkU7w9mGos-HPW6TDmCt1Xr7x4EPLkYFKoL3fO7gvcW7_3ax1PEQZ7YMEL7t6zF7fHdJBOrdn7tfZ1b4vdJBQrZX7yNaL7QrfX7dRDR7bCK37MddvWB_dV7i_aElL_VH7zffjrl3dkK13YZynPimcaHTs0GQxSbX5jH7Cdef70vYZ7Ykrn73_ZygfaHF7wRH-7__fQAJyF_7q_Zl7fHeAHX_aFbEA-37t61370A9XAIA9P7BQHgHx_fwAyvYUBQA7rtNtlf7UPedzcOzcAMQDgAK_FdUwZxcdz_a9LxZTv40mYPlfDDIHWjn6C1zdkzlg2Yk9A-Z1wa1jFQqtdb1XGf7LqqFV3reOYbJ1P6vQlSYtKR2bvdvng_LWq695n7ru_AosfeHmAZ2X1m6AAMI2O3KAscACIKKyno4O3vE0gKeAEl3tucl1QuCgJUuSxb6j8iH0A6EBfE58CMgyMHsCT6ucD8SH0AFoGTAVIIexRkGpBMaL3ZHNc9hMkroHF_EEHq_HWoXbLrY_3ZCHOUF47S4qfLfbJ1016dKTtgHIH_QQGzxA8YH5A59clA8xV1A5DrtA6O2DA9IHmQ5gc2Q4I2BGAtZtqq1VfeITLJC1_im_R4HsVgug6Q6KHzA8ts_A7Q-u7XyH-Gyks9A_OzDjIyHWjiyHRwjLzqpm42vG04Kkhxjywm2DWaq0HWDNkk2cfmk2NEVhO0Wwm29pYeq2MYAHTPfl7sFcceP7Aq7eQFlQJ-gX01XteVKiRvWNGUJ70oHxGEXjXMzQCPFuBOZgdw9p7lS0n7T3dEGLqvHadaDeHfSpiyt3Zz79GUKVjGQ3MIA_pbFPZeH6NPzAoRdBHoHbr9q5ZGAi2xhHMXZhKMpwbZ8Dsas_QUoGDlGaHyQ8GHJQ6OE7Q8A-EAChd_QXPqQathwIwB8AG1VC7DTDdwLiERABw9Qmxw8Uw4BQ6g-xp8AS7U2H6ABrDFSQiAew7LQjI6OHo-hOHAW3JHD-uSA1I7Zb17T5Hi_AFH5TaFH5_xFHrI_2NyQE5HUXd5HdI_2H8o9QAzI-q9iZxmlUwAz2K3aDGbsZubhI8E0QtZUz0dNrAcOxtrYzlv7txS0zcI83TpRHn2Uzta2t3O8G5CiLD8caT7emfXoFHnt63ylvbg4FtG1sjq7x6H9iaAz0GTDeuqhaRzGvxT0Q7_VCDYkgTHIXV6lr-BHibw-KgkQ5PgHafGizRP8GprZuAdAFCkyPYHpcBE57naQc7UwGNQ6GF_ZVdECwZVyIAnhBng8AGGABKujCiMDbHqDBygX-nXgysnuCLDs5UoRYbHyIY0xQsE8I1oB1EQVjBsDY5oTdY7uCF0FSpQuXdLTotnHSwA9KHlGHHYKUFgEfBg467AtZxqAugxqB0c98WNQ9acj0aAELgwbeOAiMBYTF4-lVmiqHT5YhGKhiqIAxiqk1irlE6Kj1kIw4_4cxqFyLzIXvHIxQPHH4CfH2BiBzr46wA748_HRmu_H_qF4VBUH_HzxNjcTorBggE7QAH8GvHIxXWo26bQAT4EAAxn9vgOojMtf1BVVFWSSplsyReU8dC5UrAAQHdPtAQAARpCROZCKLwjCmgAS61Flhx-6kB6dEUJovV0eo1zizSVnB02NUW8RIDxIiYSJoiWDw7TCJPSLQzi3dGh9rLX_Av9JsAogMdJgiUkqWKxvWm0JIU20Cug10Bugt0Oc490AegZgEehRvQocgSYyKVJtnTFdvA50iYRTtmYMTX8KZwsoEllz2NvrwEGpPqSMwFGtgCJgid4liMJgzwM87HL9YkPgiSMOWCaLJ5J2RwE-HVbGYJo1LFHqKBox6TDeIdXPlFYsy8eaLElGpMn2IlPSkIeqRIJIAdzeJQSDePmaizUZdAOLIldVaJO4N3AiiYqL44MqKn2dxspi633Zi_hd4gMVHVLn1HW---yhZM7pk9LxoZjB-cC5WEg64GVP-KNChppzTYPROYcNNFprU8g1aInT6p05b0hJg9MHZgyrB5g4sH9QMGJU8rFHC1HaYzwOwycp96nwnSvaNKadOpEH2spGpHWLJQZIrJSZIzp32tHJa0sfS0hZWB7gwHBpYNWlvfFD6UzqxRjZF08KDs0g5ydPcH1KrCwNLilJtJ2FXHk58xdOFxMOUrRY7UbRaZKmkDytTRc1OjxEZJtmK9Pk-00hHJSGQvpyZo2kNjOYxzb2vYt5Kj6viF75UpLGW3GOsSQM60Nr_KzCDDOtgk6RKZzf0nZbdOtlu4tkZypJFdJSMJaDbapEN7jsp2aLLpyLP42IfixZxjOsp7IdZ1vuJLJfjPrJUrPc2iTPwzGTOxNh_kRBcOsKaPm0c6O2VvvRgB9Zz6AAU8OYaE3YcapVW1Ws5xM_aJtRCoBUktpxHIdpxug9kAsGlg3bLKlmEUsCQs2ZqE7XAPbRhu-4yl1OxsyH5BbPBQN0aYQI8P229fW-mwp2W9SHPjwGHO1O333J8NHOiKpzPOuPg5iFDQEFh8JW4Z_zPkdZSpkFqn7DUGrOKqhrP_R9cqfaB9PJZ2CcEa7xmm57m1UlfMa258gtSeZlqfhSwW5gQOsk6HJhBQL0su578onZ9jRIfebPhBZbPR5_XOs6InRnZ11kH5AHPW-0HOO-6nOVOz32I5zRIRQNnPY50XPQi4HPk5_whN5-nPe-6xBLcNPOyCiILgiB4N_Z_MP458XO-Z9ErkpLQAFZNfQhZ_ak92Hxq45Qroahbg6NVnJqQNU0JTGcPYk5TFt_538Ee1p4dE5SoymGjoJT6FAu5FAwwHGCjyGcJdzmpIMpmvUSbaQ9yREFtQyHpwOxCKQxwy2HZKKZzegyquNJPPD3pR9F_o_DMgv0PR4wA9MEZORGQod9HQu4DIwvKlGExAjAAZz_vQuQjLbjEAyrPEFj7RR1iQuvrWAvxF6IuMxGXOBZydgJF9Qu9atwTZgHLIQcB_O3sNa7-yllIcpN_OawItPVtKIyrBgAUJuvYcIg805rpIYv1kIWsTF79NzS78pSg7rVrtUNOhDEguK9p7omXZzIndG4vNjQ9JdajzX4C5SKap4F74rWuRNF2j1tpBjIIl0rJIwHNOSooVO0IB-crYEbr8-YbwipEQQG9YfkB6UFz_OTNiB6e_psl76Yo4LTI58VUxLq7QAB6Xwuil2HMvYDUuhdAoi8lzGCB6QJAN1WoAcYBNEs8IgA5i32AipNUBrkFKA-9COQjLUQR1I8_BDDPLhOl0NN3IHGJ6umYBul91Oj-H0vvANcgJnvj4aRJkvd4E5l2ik35DCFPBG9APStIK43D8nsvIIAcub5AsvfIzpgerSsvsfGsua9VtaG9dcvZgP0u7l18Qg4O7sNIJcv5Ls8v0Y1gBVl-8uHlwIALQA3qO4BXpll_8u3l7RwPl36J5lz0ullzcvIVzapAV43hHlxIYRyAHpfl68vkV9CvbtpkuACqUE_dGMCrgPYEoYGqCwAFGjkwKcu8IOcucIt8vel4iuAV9CugV0HBtPRCumVzggYV18v4V1ivblzivOVyyuiV3wveV0iu1l7dtuV4suRVxyupdYKvA4Pvb2V1CvOV3ivncF4ACCqUFQV9Y4SV2Su9IBSuqVzfh9lzQApl9xB6VwiuXl3yv7l6ivgV_KvGV4qupdcqvEhQSvgV3wviV-wBSV-SvKV9SuNQLSuulzyuFV_yuZV5auwV4Z6_V2Kv83SqvHVxiuS9C6u3VzquPV_quzl4auLl76ubV_6uKjGniQV7nrYyusBWl7u1coVUv5dOD7VIAPS_dCo8i14kKtl49Ho1_zcB6aqvpwATchEVrpml70zs4ESLt1QPSxlxnw0AHj5-yKcBtgDkvaqyo8FIGWvNICUupoGUuuYoXpi1zowrehLLXENtjIwBaAPSomDF1zNisgzIl4kYOvh133UiRaSuo0WGihMIcufyabcsl90Gt17eqXQBaBclx0UB6VRdh4blCTIFgAjV3CvJVyGv3lwXqM18XrEAJRbNlzsBtl9ORNV66vq10muX1ymu1l--v7CJHrEABZACOCTHcfKnAJly6An12xAyWqRxq-N0AvoAbkIJOkYfgtIbY2-dWg2mMAEY-aIfgvV0TV1KvafGiBsfD98ijM7gjl6eHWVyxwoYIZB41zSvE15pAj16w8T10xufACxuvV2xuLANJBZICcuezIZARNz4AxN56uRQLSuGO92IMZvFp90IevXG0GvCACo8DIDxuDVwQAa1xWuWuFWuv6JJur2JpuHV2qunV-U2pMKJvuN1FALNypBH17ZbaPHp57xEG2Wl20vsAFcAJBUhuyN36vBl1Ruc8V-vlbc7hDgespCzu5vk12aukV15uLQNRvEAIgBXAN_WjgDdX9ZPJB_QJnWW1ypg218UvZNyEByl2AJKlw6vo9A8JVzO1wC1wVu2Y9pvRgdOjk8X3onwPlVytyQhWACkA9zFgASAMqAkkovkCANwBwgGAAzbooAYwcmB7APAmUgDGCC7mggLEFgAet9qBBt_aDBtwmCC7gXcpt7NvLblNvGt9SU4AGNuJt5rcet0lBBt5ZAtt8D9wUojAJPltvuQTNioYJZB-txNuet-eAYwQpBxtwpBNtwpAo0T1v7AFtg8AFNv8JKtuFtwjAPB19vkwOduC7lD50QLAB3txbdQAU4B0AL9uFIGDvkwONvLbvqA9IINv7AD2ZXAEZB4d8jvuQVNvIoPDvjt4XcoYJjukdyjupt1juMd1DB7AFju_sjjvid1jv9QA9vidxbd9QfDuid9NvC7pju5t7juidwjuCd-jvmdwXcLQOTuSd1Nuqd_Tu9QWzuGd4Tv6dyzuKd1ABjt_YBkwHTvidyLvOd3Luptzzuudxbcpt1tuLt1dubt5tvet1tuzt8mAnZGuuRgRgAXVybnIwNPGlgObvug0KDjrqdcB6X5zug2pv-1wWueg2evtdeBD9ObWv1V94AB6QFut_XoIa1xGuUu7lDuN0hvurdkANcOVADxHfay9F4S0AKtjvOewALbkZABMKpAZSB5uU1-FvqN2Gh096FuBl5RuItz5vot7Fu9KB2uENzAA1zMYAOdtRuESAAsBWhZARAN8h6uhRq78p_wDLbVM4nLRvR16xBx1xUvy9zQvaRNjBXdxIYcYGev7dw4Oz11euYYGeul1ZfI_RhkAtN7-vK1-VvrcZVuPI8PcLYMgQRSPbdUIHnxz4NVH3B-hAVkefBW99Ls9IKrA8AD08IABfheTobvSt8bulIQP7xiEauhJzkSNy1uWXaOJO6cW1ahENti2iyvAXqNtiQUAAelRTcACgCP0iIFXywGsAeWp6AeyA4aLHCTuWf93uXpyweWOVNAejxLAfODZxI1UA-y7NBRd5TSpVeAP5JeAM4AUYHuZZoFiw6LoUASlCaWkDxXEnQFbbp1r6AI8LQfmD-pgvy33pdy_QfBQMbEYeqmWnWqTiXGRcWBWHo3jiyeBP9z4yPYK3XoUBgQdgJOJ59SQ3ZK9YOswPFvKsJvr1sNibLCCHgdYE3cGjMPJdQAmp61EHJiAAQAr0_FleiHiEdREpWcK6JWAyjlKWevhVcggRThemASugHaoWaOfg30L3wXY8CqTTmfBxwqrH5YJIgh7mIIGDK-R5QHkpH5e70Q8F4ewj9mXAj8EfbgKEfUQO2Um9tomziDtV2gAkeQj-7wwj7vxxsJGIR7J2qKyAgQXD7x4uYvugTnaUeYAHapePGKkY6DEfcj6iATvD7F2gHsgk5IJYdyUBY_nDLWNKw6bqjxeNmj_whkj3pmAO0-AkoKy8FXAJBpvoJZigI-Gy4EcBT7CmwLYsUfptAMfvDwihbbvPD3QtrYB2NoQIGvWbBSLEfmjxtZinefhS0MXBRBriQcuMvhEfJ4emjyTB5cIcw2sAgQLj9oMsuMagx9ISA7j-seGDKHh6ZLJY-aNcf6ZLcffZ1pW3j6INND1vw_dn5HeTbYAOKO5Jfj6iAZymN7qu94brmEwW1YSuWgaPcfBjyTB3-s46VYltkyWqXJLAJCLBfiKAiQJnB50NxHug8JgCpHkBKUnXur2mF9TgF5DjKBSeAtsnsaT4BJlMHKUA0JYAyTzGU7AHyf_3kntG3pQQgQCf0h8CnBy5uoGhAMLhpxyqxjj_6NKCHlHJrVrb1nPcoBIEtcsuBJ9JAMWhJAIfcUPtkekjw8fIEy8Rz-HXhqTyZ0Xj40e8T4dU1qqNBuQa-ZQKLYBOLM2z-gCJQkT-l3G3tugkwTKcb8NyeJYB4fqjxUfOsICegct5JbuQifcTxsf2hM6AaikwXOfFaf8-3Cfm0CqfNj4mf_wJolJkH-FVwKmeEz7n90zwigHT0Wf54QWeIq5CIE0OLXA8gmhOYtmeh-6uENzL0GKknpAUT9GegFWgoFwOKrpOm9X_T8WbYFhFX_8nm67NLIea6m-xw9RA0PEEDnyz5LBgGdGD2z9BK4A9YEMJHfhBSDof-jPofDD-eBQz40exDMwlHAO8NaUjZ0ZoLe6opggQzuueeOGDNAM4G-IRwKjgKGOaJd923XogHnHuQwfQtbPyUOJggQRzxhJrz-wwHuIcfEfLOUGzXWEezwUd7bUBVqz9ygo_DQBrQZGAYoAwKgxr3ZxVc3rWSptVok2KUcSjsV-uRBf0L0uYKkqhfIL9Mg6AB2esjWif0oEGeIL9J1vBDI1aQjReAO2lA9C7r1dJuOe2BM_ApzwA0Zz9Bn4ANmeFz8ReCL3gxBLx33VacRe-z2ReOWdkQIL1d1-z4UrwL35GSL7TWbBpgKgBOsVUz8TwuAKEWilZpf0AByOF7L2eAO7TX_a7pfQ68O3WucOfH0NQxGL4LVaa562tL-LdieMK4j54-gtLzIRxL0Ze_W8eBPWwkXiMAl7ieLuUi1T83z4mjKz4FbBNEjn0fL2fBHdiacnL27tUnN8h1zz63d0o-gkSuEexnaRKOJIwnmu1leVWGS04rz5XrBxunuqj0enL0Jf0ry-YUr7lfxPezPUBaww4ryqwcr2leKkmVeO-6sfzQqlf4r0VeKr1bQqr5zoer9ZlWJnFexE-AN-r_lfOr4VeHEMVeGza0kuWxxJyr0lfKr11ZOr5QnFr7gpRKsNeXL1lfKEy1fUr0JfTxi4kZL6MB-z_nWnL7AgFrXC2IIf2r9KPhfRL_nWPL4LU3q0GMZ8FidBDa4256C6AGWlMA9ICCvZWDIFUdJ-SFL2he7r-9heg63QbpIpeJL-YABk0uf-k5tUULzZfpwHRf5HbZqZTg9fpwEFGTi7t71z8-BR7jSBA1VEREbwKIFXPoBsb9bI4a7iBJYFEfpL4pfo8GO6tjfUR4QOAnu9wZelLyTfmb26KMj2iwXeDrgiuWIU6ykyCwjVhGTz_CMzz3jLLz3jEALzefjgBXwt8BNAGQHMANQBXGr2uzfFKJfkb6Eze1bxUQxb9yjz8KrfdvVLfAL_UBnADgg8IBXNNb9N9_UFd1Kb0iycazbecAIcenDl1j5Cq8SbbNHbJu6Il-CMgcR6NjNOGHZN0B4GfiL7JeyL6v5iL9z0tJqkeslW7eX4awX5HN2fIb0Zf9b010d0Nbf8b-36Iq41mW1e8kFzGuYRLy3qxL0de1hMEBOR4cUg76MAtLxCPXRxnfd8MaO6qAuYNL65e9LwxlwBlpemMujfDfKBgTL43ezL3i4G73cdWbxfNiBPZe9LzljUzyUIuOwmgor3_ALr2eA1UCjAIb8DeW9ZGUZnZlQruj5ec-gl6ShGcQ876vhTr6lfzr1sBLr1Yj-UVPQy72sII71d1zHa7fGtuve_L_vZRgCun47-Kqruq3fRoO3e2RCg7flixQIL-He2pmuvcOo0fwz5zEfOLh56O6feIL21csoDI1loChPdEYOrVMETe2REne9GDugKb2nf86H3fpMy5oEgEOejgJnfVLyadhtgkpbr_neiL4g-zFKinC729XsCupfLL_Igm70COW703e8LwnfbL8QIu7_Q-e76JU-79ZfWHxjeh76ZeYr6URieFg_sy5bgShCZmgrxde32KVh6LYS5-L7AzOsDvexwBIhFL-Vfdry-Fp74felITCnyH0LklLdveSH7vfiH3w-BRKuFxr5o-Q4BdfrocNKo7zfenLxveIa-64L-AdfMqDwbFL7_eAhDA-qj4A-OesA_ToCBfo77d2CERAGk5o4TFD9cXlD8FQX92UYHi3xWRxhIf5Re5AWLv7AWLumIMq1Rt-xN1bQtw7cKqh8uy-SaSEC9XSbD30fYm4aOKqoz12YmyrvSMU_OtCUQxG1u2iOi8QSs5K4JjxMApjzJyxpfMeugIsfYWNh1onL8SXiNzL8Fr_EKpg2fc_q_k3JHOf_wNYFQz1d1dqrd0TxETXjzwQxH7fPAlj8_S-9Csfrr5FO-L7n9cSPhdWx1LFbUhQZ6KtnTrWtmWPT0GBpwJHfEh2Z7HD5zEOekVqD-gKJtIDYbH5HYaowGt1MABgBBLPaauJe7TbL_g-kdmfX8q9p0D-D2uufmvgz4IEI1a6-My8JC-i1foxtbLUGfVtQBJAIBhWT_sfHb6uWtdc0Bsy25AWLhY4gX87HnxWegfHlRtsyxk_HJni_nxbHG_HxS-Gxm8lTqkZeD-kQvq2FxeowJC-8pkd2PkoClSKt6n8ayzUvMivfyqd6OKnyr18KqUXB84zBip1brLdeJREn97LKiVqAXYFqAQUGS0o-pwk-0A0B_YAfor9waKDi1JO4IESJZJwMXqspSAk499drGWq_ldS-y32R6J3O8MXR9KMXt6BaplrVtbJi23zfAPAmLU7HxAMx4AtFf6-qWijnEc7AnKkULo2cxG-He8SH1o3TmKOQzndo1xyzi9kSyjP1OSeDLrncDqGpTB8HyQyUy1ow_NxQ79pBOUk9r-GGgII4naVQ2qGw0AW-dmvqHDQ8aHTQ3Xd1gDqHs8z7I88_WoA5PaGgdI6HgQ6CGa3wS1Sw6HJywy-onqdWHk334g81BwaQUPecVp2_V7ziChQ8iZ4sifmIl3xa1P-ax1D7mnA5AvEBOY3IEsMkB51mxdBpeTG_wji0Y2398Hs838G0TACHJEECHnQwc8wYxuW5-K_4n63pd2x0EB91AVWDSmXhQ1rSGCXMAMW9EfwyriwBeaGGG_33cGcN1klr1U51O8J4WtploGYHTWZf349ZmQ4YxJYC_AZoD8F56mVX1kdnBEw1H0nxN3RE9uEXX4_OSJW9g37vGklugz-pw4sVxEw0fGo9TR7AFmIh_7ZP2vCe2PbGqLBUZLvxfkLWgVptg4VB6eHNI90BTgxpAP5jk9vkLSkt8IY6t8Iyk2xupd9LuLOeNjFtBEKx_h8Hmnymx_AwBAIAZm7UVbgFABwjefx6x6cBXxDJcQsJeBEc0-BNlMZ-90_FxyQPYBTD6oUHP-4BjPzNQrXxLgnwFDAR7DnYW9K1Z6lil3lZn4mz0JdHKznKZhXmHMXP8nH_AOCkFEbsUNcP5-jgGS1Qv2iZ9YBYmUv96Z9YABERk_wR0v7tGwv0znWCP8BK9HCWxwJA7zALwr_u1IMDP0Z-YvwsaYJsRg36OjnY3-9GAYxdHgYxUlac21_E3_qBLh0cB8lcjmDxITnr1-LmQ30N_XQBuYuv09z6c0DH9QGuZBv6jnK7_w5Ftn5_BG8rMFv4jnVaRt-YeZUtEgNDr6lskAKkil3sDTBR3BQRhUzKEXjv5UsQPycXnP4Z_TDx8AQsBV3d34IiFsK_gNAq_g9v9Tg48IF-yWoKGZm3HgPvy8Qvv3Kgfv-U2wT6uW-M6N-Cc5OzYc4yBQ0zD-WyMPNCjF-n5c0rnLM7O7Xvy7QDguE4E4GJIwbNAmtFVhtJKoUYzlPUt7U8NnW0lG_x2BXwKktJg3cUJgXU8EQbvyeAcfyTw8f07ilgNNmrrstmyf2yJY00tnk03z_E04L_oE8L_U02HpOQGzXQiDV-Hv_hIM7Cz-qJNNoHP3L-lruKBuSWDZRNqt_BwplpGv1zlsDZB-s0rWAfAPnXtf98gbA_i4N6MSlRL4EAIHUzHug0t2yCkHgVf7gBAgLJArTO2VZf7gAhYOQBIwFQSQfzr-Uu2HoLd8rNhzJwlWZXrggDS7_AbD2mfPIT-tMTQJo__hIwDQlltCAkAMPxv0jfxYATfw1_Ev-MbE__d_Xf6J8eVZgRPf9H-ff37_uS_t-qxL9_EkUhewbLwqyWmH_m7pX9I_87_C_zH-M7PH-MWO3_HP7gBk_1H-O_27-S_xMAy_x3-K__7_q_zF1CbsrMIYFGjf-BqiHf03_fueH_W_zUVe_w9_RyNeh4kb2GC_33-M2IBUu_yj-E_xWRo_5EFbwuGQua1F_jP0Xj59fEuoJEvq7AF14c1iBAhAEfx4t9fr1WLfrC8FCe_9RuWL_2Vsn_5GGgkA6v5-9PugCzBDkL04O-qFOvmQPi6gGJsaf-p_cGIgMxosFM4cW_hiIJ-QwXo7_lMaR5ooASTAcxpunAB4EuCYAcsaFeg4AUAQjDBBci-WkHRoGjxop9BKPDV4GAHsEFgBMujAeEwBixCUAbVW8szH4KrA__6V9o6onRpSEBXophyNMImgMv5WEPq-4tbavg0AOAD1YHUGl8560AcaLxCjGlLQOjCF-LSIeOqv4JaUmuD-ABfqDKwiJPceUeT1LIAQ-r4IoEYB016CkDZ-UfR2nsMQpgFoIIfqf-SufjF-y4iFoLTIQcjEZr3uzyAlHiHgFU6p1pcQ2UBfHj4BTgFOtA4BK4gGEDYBF-CmAXJgqyJ5SpHo9rIS4FkItX6bLEw0an7X2L9GxIY5vtnmUahLALW-JzRFvpKGpb6igEAaCBBUkKkB_9pk9Lp2MgFlAaNglcBJATBw8QHqfilswQG5ROceGmjh4OEBu1TSAbLg_hr2GsUBR-qCwGkAL-r-AW1AoFA4oO0BRZyhAfqoV-5AICkQbIjaQKBQJFyoAKSgRdTRlKa8amjs4AwBIBDb_qwBIBCDIBrQN5CGAdOAAogeGk16iaDbAXREuwFcAdGUJXjS7ARQeeDxIGVwLAB9aMxWCFAh4GMBAwEs8rVe5F73MNhe1rpygCG2qtBvARpo1kCnhrKgL9hsypz4rQGraOMBl8SMEBcSTwFnlvNAuQGYmPW-webOYE2-HbiNguGQfTBtAFlAPbTiPitgAcZUXnuquIFdDJkqVQSdnp7C5-DVrJH6BIEY6qSBuXrrUGH0-gCM9miaEQCZwF0MLVDMgTQAurYPGqgAyWxcILPQzxpL_K8aCBA0gYP6dIHAPFE-rIGFqtyBBAC8gZkm4oGmLpX-LQBLeoxQVdpESN3QC5LiGvY8YdpyBlOiY5y7MN9QtIxcDiPw-BJSSGOcI3rfASIkoJKaHM3QIgFoGkgB12ScqIekHOrg6Alom96uemwYQVj-_g5UtWzYBgpa6UwMasRMbAZxZHAQrOafDEGBoYFPetN6mFARgf3gUYHQ6C3QgpTClIMc4YGBgR7ySYHzerGB-dDxgfXGmYEUtvnWvOYe3vw49PZbDlyOJyAs9nCaHnbH6KPoQVh5gdkABYF3aJwGwvaxAQBU_I4MjtqOuo4BbBJAbwZDvlAQKsCjvlWGNYZN0JgYEBgGAfmQ1i4oevVsuQSi9AxqQPwZgRzqWYzEanVQ9LZ1EDq225SajnKOhNwKjjlASo4nlICB0xqcTKOsEP7hkIsBywE5KOlAfA5QgesgIIEFAGCBoOSIsIAuHURKorCBfgBMZK3S8rpoGjigIIGKtsJAvojtlJMqPlAj_A_IBFC_gQROBwGvHsCBALoPgVie3gEh0NBBmABoACcQ2c4Usi-MWlbn7ohBf4FoglCeoVBQQato4EGoAChBM84jzvxmF3SyMPhBt4GUKMhBUc4kQQCmgCgJFqMAgEFN9seAl4CzAE5072AMQcBS50CerECBBEHUQURBtEE3zpbOOyaZYv6BhHpwgSWe7wGvgfEAkkEWJlCmN4HJSIMBskF-ANTmTehsQXcAug7GuMvc74EbVJ-BWgE6QRcS_bKCkD-BMEG3jv4OrBaKQVLIykGGQT0EhkEitm-2txiwinPQJBqzQOsAz7x1zmAu8lQIUrgcJjJXHJcQ8C4xbMwyksz8AaN-aUAVvsqGMuLJyGqG4kF-QRrQUyCmilFoCvDtAKrAfZI4qD80qsCGVE2c64LUmqd4pebKAYyAd8yKhpW-UUFExuGW535LmEPYLA749rQUTfDALpxs4aqFih9APkE-HKeYV5psjsoB9UGGbKTq1fjtQXVBv85MbNZqI6rUAaCUJoQcjCaBKOTReCnULUGcbJ1srNLNQfuwCUF3VnFBYtBLQWAMpqSwhCZ47yRVQdkOM0HdQVOqe-w2pHDsGcyJJtG-xMo9DsMI80omVCv2NqzF9vF6uVKpxFKcXxR1inAuFjKqMhlqknpnEmNBSYQTQWecU0H6MMoyb0FMNHNBtdKhJotBiCCJQStBhABrQQE2G0HyhFtB_UFgLtVBN0oPQmwwXZw9HBdB6dZrSpv2BpCAwQJqqjJ3QcHsgiQUYkc8hVyyCgUoispuJuDBoCCuTGDB1yr9BOVB3gz_6lHkUJ5noHrQndq1gAlSts7Kzg4cvExMYGPOQVCjrEyaXUFPoMLBv84QLjasIpJgoIWELC6cLn4YP34cLgIucBg8mhEBceqVLKggo04lnnPCr_g6ZKoccw4JzseBKs5kdvw4h86GzjzBEQZrUCpExFjPflAAe76gfpWYWDiftlu-NsF2wScWNBDNMM4ce0FPoEjw3t4jegCUCBA3AbAAdwFhiGVwKuZdnq3OA0E_7ENBj4HqUPHUZFajQG4Mh4E-GmEUYEECQcxBZ5SHARcAIoT41gOY3uAlnlswAohuRGeAiz7bMMuejNRRUDyU7zqe4AXE2J6cqMIy1yowwVZg-7AsDg6BzhpnTvuw8lSIwf5BfRxdwbHKEsG92Eya6Jx_rPyaChyCmjIArt5gAHaak1j6mj4BPQEBfngQ6pruXuUggMDH8KUuB6pZboXoHmAamvyBlyiCgbqaet47wcRYe8HbwR4gHIEnEIeaOIFnwQ_IXpoyELxafaz3xE-kybqSuIwA95zHuDPwqeo0LCBan4gfwaAgIFozWD_B3Q64bO5QIFogENVAPZo3JAXOzMBSmpAhagAgWofO1UCHziBapQEJAV0Ah5rIIY0BIFpCACIA4wGHmtJBjFzHuNbBO762wVj-mDi6moQhQH6uwQe-lUAgWgbaCPYFAIKggMCemutq29D_6KnqssFKwX4YICHb0FIYbW4bQorBfY5wGLGaBMA4eMpadVCwsHswSqKNQQ-arzCvwa-M78F03L_OwELJTKAgrFrUwRkAgeR_wZbYqiH0wZbYXCGn0GAh29AgWg_OagDQIfrB2ABwIU_OXtzAAIghx7joIdfYaCENAdfYmCEvgDgh4iF8Qesg4wEgWuQhX8yUIQ7BZCGSwC7BJCGCoDQhC6R0IbOADCHAADzATqJzNqViMU64OFrguUIWmq-MIBCsIR447CECIZwhzCGn0Dwh1UB8Lqwu5sRnEMIhYUwNqm4hCsQGEO1BR5ZPMGu-0axRTGCgwZpgoHohiaAGIafQIFqc4CHcQ5oQIWYhViHGIeYhx7jwIdYhliEgWvLOrawqztoh0i7mLjUAG5q-TC4hHwGHmtEBZMKFIVuaoiFPMLuAIrBO3s3u9_5BkDZaNYCdKNqSe8ax8H2spVqtFGHMEyFlCBKSMDY_zuMhIyG8wUchUi7dwfVsHlp3IX3BgUE2rI8hybBgoLch6wBTgaf6DyHpWmGgcAEjTu4uuVrs8OkhxxBcLnyIrIhhoHkhcsEhGCFaWeCbIchaEuDbITGg4Vq-Wg5a0U6OEpshiS7wIAEQcfRoykq-qZ4RXst2RBDp0jQAAmCa1A_utjSqoAJguGY3gCcg3oaVyjGo2rwUcrxgb7DyQOg2UMBVVBpUs96DEBdwY4CkoQQAAmAaVA0GvKH8IAKhQqGhchCAZKEUoQkhjQBkobSh9KHS2r6G66AqwCyhihYDsOyhjyYYNrL4aZRjgGqgneb8odShwqF6oaKhhqFkoZm4XVQCoQaCMqHhQFcAVqFGQAqhDKHKocyhxKjqodWwmqHFVpyhA7DcoSahKmB8oZCWqqAGgsahJY5-oWKhgaFGQBahI_I0ANahfLayoRmgBoKOoUqhTKGqoa6hBGBsofKAHKFcobqhIaEGoewEBABBobJgvqHyQDDY-aERoZKh4ZKqoNaCNqFZzJWhXqHVsDgAdKFOocmhWOasoRqhGaFaoXWhz8A-oTmhPwhmobNWUMDBofqhB2p9odaCkaFSof2h1aFNFP2hiaE-hs2haqFpoW2h7QCZod6h2aFDof6hGaCjoYWhPaHGVHmhm6HOLhLWE6GxobahB6HaoQ2hiqGzob9oLqGS4guh7qHtoZ6hWaG-FEWhvaEuWB2hg6GmoS-hnqFjoTWAM1beDpOhB6HeDjOhjKGXoSmh16EfQOmhS6GPJgBhK6GPoduhZ4A_oXpAb6GhoSvKkGEIYeWhWeCpnqzmGlxaKlA4A7CcvkwoWQpogLMOeDCT4NIGYACkYWEUMpBwEIOYXwF6UIOYACAf3vmepdZU6g6AXmqOKPWY8l5MYXWg-x5vFKxhBGDcYXO0DlgigLkq9d4RVoCOYmzAjnHO6ADlKnpQ-x6XmCCmc7QVJPxhxCgJegjwHwBkII4AmAB8bBAAhUDdQJemX9ChPqmeAwg4YRy-oQAQNC_YRXII8ERhnooykIZhPZ7pnnIm1GFHOtAKJRB0Yaph2lC5KsxhjBg0YVS27GFhFmswhZ5iOIpY4qEzEJbO-bLELgvgBJbPFOsAmGHxwC7wxmGcXqZhADRYcFWIYRSeiv5Okv4FZgA4-x4ANDfIqZ6Tnolhr8Dc3oYsZOhFcvse8hxbBFoqZnCygI4QhqrFgAA8SQCG6A5ou1TioRROZWH26Kme_kCXgQRSB94dShtq70gzTLAAk-A2lDZhEVb78NmWVVR4YeeUVj7aPq4aXQTVloLA9Z4yPnN2Wj5qyiKhAgDz3mDYfWG3qh1gQ2HuAH0OnXD5YdOeRWFlcDI-uWERVuOe4nK-wHFgMmEN4MRgRhS3YVAMznqJAOmhJYT7oZ1hZWY7AMHkuGEFYWAgx2Ge8t9hR2FBvmtgGLDxYYkAeGEK6CDh0LgA4QA0YaAxYZpikOETYT9hC4FYYXFhUOEmYRA0bRIiYUcAf7wqsOxeYV7eEEShg_ZEEIZhC1ohXnfU-OG4oIThtxQb3sNgF15_vEwYd_ZWxKFeV2EE4c9h1tY_Nhxe9o4JKAtaGKGrMuOe2KHUoPeclU4STmwgwupHwKLqIKAEiCa-Mk4FEuXyrRY9Fu0WsDQavv-80gF6vjBOw4hFEigC-0jxhkv4ZqhuvhtaJPzbWgF6bsDmvsnmwIaDoN-o6ebnqJWcSwBm4YsGMHJp5o5g1uHONKcY_mDnGOmIOI5MDhG6wZwzGBUW4bqB5DO-bQFvAMu-HKAEUCbeHgBTIES0k-ZX9Hgax0DBbDfWB_Ba4alIOuGZJJ3gaOABbFhIkZgEfmXoubwcQHoKRtaARuPQ0QBr6AnsI8aJQHYaG8CLbCKUYSi1hsAYkUC2RhWsSeFuQCnhoUB_gFFw_v7eQLUUYAChFnYAZLReEkAYZLQm_nvgoMB6QAAIZLSHfsPh8MDaZlM4i2y94elARAA_8GPhLQCq0gvhVoLaZh4M3eH-iPq4k0Tz6rO-j_4qvuaA3QFAAevqQAEasHfqkEHOGnwB6vocpHyW8-ioAKYaJCgwAc4a5QDfXNV4NzocpKeQAmi__poa2QDcVAABCmpAAbfhoAFTSBABxAFIEAtYdaCQAZ-Q3iEvfvu-fiGLGt9QMBHEIXARpCFrGkfqY4A3gOiApCAVSGEhKQA0EFAR7BBIEb4hqBGX6u5BfAE1jvXA7OxYIbQw3RB0pIEhKBFSOJOk5-hFdvQhGpitwU-QoQG4hGWY91bwQWYBnTbhIU6YDGwCiNJ0VArnzKy-LBGb0BrsoyziEVHkl9BfhIRwuBFZmJwRGBFYEXgAihGdRJnBGLCgeC6YyhEEAJgR27Q4ERIReBGdREQRQSE6EROB_QGSIQS-lQHdAXkazCAp_lRgMyEyQW-kAQGXMB8Bbhr8IPoRpCDqEclYwER24RbhQebO4Ty4YeYR5hARZ-C-wCSkTpg7oA24aBHNoGz427Q-EVg4_hGO4Rnm3pj4OAWYlACpIHCARqrLQNKMYD7n4PER3hFGEXZ4Wf5nAn_qnhGqEYkRIb5qAP_hsQh6EaoRhhGyEQIRyVimEQwRLphP4XERDRGYwFUR_KpsTAEhRCHEEcnY3Mw9hNVkfubm4Q7hwGhW4UaGU3gXvrnmV74ByDIQVwD-ERMRluFO4dMRPLhF5nC0oQEj_CoRCRHFEeUgeBJuGjsR9RF7EU0RxhGVQIcRelDbZKAwIRHOYMwa27S22FSeit4OgOystFggRo8RKkRxAAmBjRH8EecR6ZhJwYURahH7Eb5Yo0DJEZMRaxGVnMug1_AR5s24BRFdETHowJHzwIfkKkSDeFgScJGnEb8RekgtXpGBPxGjNohkXToLBIKgnNIRAQcGzRFT0vHY_8qUgZZB1R5nEUSRl9KokdJ2BGD2DLRGlzDB4RhQqdJcESAKooRskdYkY4BVEXgSmhGsERcRbHjkauYe7hq_4dRUrMGaHCOcjnT6Uo0BeBzsEUeaaAE2CiycQKrd0CqqZEhkQfyQGpFHpA50WpHEDEIRbIjELFUUeuAjQWselhGDASDka_5WIqBeFVI0CBIhlpEanKje9pEWkRUgtkH6ZL6c5QS6wWBMULK6kYJ6_DgYOOzmDixx8CpEOEj6ZkfoCPa9EfOYwZwVITNYXE6lEPu4ltjHuGXgIzx98PaYc9B8SPosO0qCJKJq7eBzTLsuxkbhnLFqyZE0hnhIUlj6DHHE5ram3kre_zaC7DzYYjaXhM1smqqxcOKqqZEjepeENqTNkVpgvZ5CZrVezbiKQOemPZEShH9hmLDs1B24oMCBkYyAJXBNloesaDqNWEkAW75CnBK2VMxmjnCwPJEJLiIkzhZLmOkkcfD_wE8sh2T_yKGRCQDhkcW2JUzhkfMyUeSQts5YC5H_VOGR3UQfQACOzd70ZBuYYZG98OCO5l7e0lD-r5EDOFeYMpzfkRGRRXb3lnWwxOZc0vpBSZxoGAQwLICKWLuRUiZ7Uhv0bwAQgh7QaBov4UIAiQDh4azka5ER4bqMcfDaZqiscFGCkJyRF5g4UcYkN3ZeoqOm15GJAIuR4ZFAUWdm-jDc0qv4ZeC0pM5s6DAwUU9OvCi4hIhRDR4ckOuR2cDZJoyA7zaOgfaICFEGnHYhWQhOGhmeiJHVEWD4oGYrpphR3JB8UezKHwAjHM4A774LMAJ2BJE34P-RF5EY3mRstpFd2ut2k9iMup06Wh7NoMcR6FG0kCpRfFz_4NFU_FaxuPDUNkz0NC34RiqW2DxKR2yu0HUQk5GbajdSuURaUaGyl5H70ltmRXav5HJR2FFvpkV261BYmqD2Z4GrkDxRcACWURpc1lHCgLZR5xL2FgzBcSGnQHDmephxFlReMYSUkRRedpGglGtEK86Pzg-Ecfh7cjKRKSEB6KF6iaA8IWcOfJoiJDn2Y_Y3Dk8OdRRDrA8OpVHYAGuYY_ZLfquWbw7nEq92Qnbx1u8sMErP9oVAfw7cRBmKVw659h229JAOjqAOfaAU9mX2dACDttgAPVFJaJVBwT4EkeGc-pE5ALvUcZGf3pK4UP6eUe1eeSqpmJAAzd7nURuYovD9BHcO-5gfkVnS93blkbFKRwiCDjliNSgxbCQOuI7e4QSO_3Y0DiLYC-y9Dh3UUP7K2CGRr4xxJr-K3aK2PoxRI4AvWKCwZQifwNAAPR58ZrxhD1H05LFkrj6lEFHsnupcjjWGc0xbFqaUF2igvpaUn7ybeu4A0gBOXL5i4FFcjn52PLRxOK3ASkBb4NjA8MBMnhcAEg6hCG5UW-CYAKvcqcD60KF2u_AubBV8QgDpvB5sx974uMZGxNHN6Ft66gDqWPoss-a_kuOAAWxZxs42rNGASCp6BODT0BRYRva2NtyG8-YWgJIAh5hf3v3WFwBD4HCK-fROgAvQE4AUBldyr4Bs7JiuzojCrgDezayCfkNhlszxpNB-ofQUUYbRkdwe9BXo4-wJXOLR9OQk0S3otj6pmNj2jv6axLCOfHY9HpVRJehPep6U3UChdhuYMdH1doUh_BB80XYAJAZKXE58ydE5ZOHs-WRF9BOAu_D8AC5sfC7-0Xn0I-AbesHRZxChdvnWTNF-JlFk8D6nAXhA_-hMZPHRONFPeiAQPCF4uDSOEkB10RjRkI7IhtyOcvZD0WS0jDDIhlyqg9EP0GToX_Zr9nx2ysxj0eOBBo574E5-c-yz6DrhnsB2qCvoxeEH6CaOLoG-gVGRsOCMMJnh93gkKq-M80BN4S3huECYRIPRrIGT0d5Aph7PikD8o-ja4YfoQVg30XwgcBiVgffRv2Y9HlSOfbJt0fpeLAH4gDYGbdESjv_RApCqjtbRjIwV6CAxeLghUURR_FF_4vFR7EpmoMe4QP4cMMchHDAgDl6c-7hf9jL4svY_EHwReJG-EBg4czYDnF_2gX64McRgQoSE3AQxRx6SUWNgTqJKPAY-kNEzXnOcZ4G4zuHhn4j1AWrMKCGuHpJRNATcZqg6AWA8UeLWYeE8UbkEolGjKv8StJEHEUjYTfBnQeaRnREYkcQxIJESQGCRqxGpETcYDaETcD6k54BNGBD-JlFhARUgLhEjAYRRAojzIXfObgo8UasBKFGUAG_helDMkRfwrJFYUXRIPIx_6nYxaFE8UcCegQEhBpwRHwGMMVYE1XiZQAEB4YCoUrHOlEDUEeMBdVFpkPbKThGDAYwsehAjAWawaQBHEZ4x5lGgIC4QPFEX4WUhkqCwikkx7PbmMfP47hEMSN4xnjG1EVQcLMFWTlsELBZc6mYAQuEqTgfAiPIxHPZadqhQofEx-gisCH5aofCooYwI3TG_kDAhLm4QoTKI12qWISFa0ZFHCJ8hJW68MY0BbyE1gK0R9sGkIVsIvTIKEZJRczEooafQ_-jjMdbRPCFwodVaqzKyIeUGq75goO-YSr6V7jyuquH1dMYgz_imAYa-sRJi4XBAEuFGvhLqURJM4ma-muHP0cnhh-iuvqfQ7r42ekbhdqjpiNaGqsC2husY3pi3vve-oIZPWkhy64jz6tUhbLQtYMvqWoBH4YYaJ-GGGmfhP_45MT4aV-GZJl8wpuBnkGpo3-HOGtXAf-FHEeQRwjH1wFExHwExMRwRLpG5MVIBNhF7vowQndye_g6R_4DoGM9KDexxZFSxzhHDAez2KTEzOkeQIxxEsbkxSlFuchUxFgD_6rlAkpGhQdvA0sEgRkRhhc6WIU3B887XIREGNLFKkRYRf-TCsRiqw_bpcAdRmRo_AbXBPijjELKgsqC6iAfRwyHmwZMhPc7a2plQ80AzKplQHKKsMNbOoE49IVQSVrEiLrzBMQbLuNbOBE6HziqxVyHWsdl6rWZMYpUspHCQ0Fds6Pjmsd8gM6CkcGaxpohuWKjA17TxsQpyibE04M4wIDjNuKmxMbFHAAXiZ6QiJInYK5j4uJ2QqqA9kBUAEfBHoiZ2PwAWgCuc2QAWgFaeJGSglNKxIwAq9gUA9gCfXOhgsdrAsaCx3b5pqL2-D746RAoCHbG-BOCg5Ta14RYm9TBWAKrUNobDoGCxNxgQsU6GoIbU5iDcKkQtsa6aMdRRsZFQFSERscWQQBhZsXGx4xAnYIEw2vZB4PHUMRaNIK_k5SQRAaa6cVQ7AAze9lGNcBGUS8GDMegxpRABsTIQLbFtsbOAI7GHWHzBwkrDsZ2xjI5i8uE4KMqXpkseFdThOF1sCPBO4liw2Moi0qnAVKQ7AJoC_qDgyipSqcAxIVFAJxo3lGX0ArRD2FGxj1gJcHNMgDD9hpRaywzubIAww1DMtDKc67HjEDHUk7Z1UNexgpC3sS70uZSsTI-xaMrPsUrKxVHtLlDBCi7FkLX6phhnEIfODm6qscGxKzhj-pK4X7GAcaOx_iQycX-xwHGZXkSKikBYAFCianGWQETK565-kNR0QFICCN0G6xCjkJhxaHFj1NdePNaJJGS6FzAfgHxOuXiiLBYAZLSZmtRUc_BS7PPACXCsSDzRFSSSDAoQSsx2cRI29vSN1lnUakaqNuYAz_j71lb0M0Aatp72PcDWsNA2qFhecb5xErTGtJ6W9fRjBlUsh5K3QKH2coDlXhNWCDZzgGgAFkCZbkc46YaeLG4gIDpNdMZG4-B7cjh-W-AFoIXoke6aes-2CYAZcccA3FTfsSkAv7G2PJsAyjZz0C2x8_BsIj0AnbFyGmhIjXHxcXKAn_ztceSg47GBfoWR6PbSBGrsTXHq5rWATXGjkEhxunFNoMNxziygRhhxcGLpcSNxXI5O1iV-eoEc7N-SWtQWSmaU6rK8NguAPNEatnXRRvRYnEnszgZl6E-2VtF8Ll5xv_SSsS2xwFC0EFxxxUpdIWYYyrFXSC1x8nHCuj0IQPETcbCGYQw_vLVsiHE6cShxRxxbceUEvGAoAvtxHtYvKBQRGsHYaIqRasGxQbeOo8KpmO-QDohB7LFB75An6H2gRPHdUCfoCvafEZ9cVbZY6v36CQrA_skKBVFT0OuKweDIcSZ01KSSKJ929fToGEBIrkDIgHG2jixKMcYx4pCpwDQQy3Ew8bj0X8b9YS6AfXaKjEuYGcCj0lkAIxYmkZLAoRCNUdf27tZibLcOrVF9tofOXVEa8Vw-OcHh0Vx2A1FSUYL2w1FUXv92Y1EgQA_2iVSPkTNRQFQgDnAO1PZU9stRnABrUauW6dijduHRhMEojoxxFha2Pnd6oHZzUQv2AAgVJEjxbV6Z-MFwePY-8bPRQj6glKDA-9ESQBfRr9HgeKF2o9FjgdgY2w5gDvPRmfGwABRiR9Hr0e56U0DP6IOWYUy70RnU3VAE8QIWRhBe8S_s_R6ukfco-6BtaP7-l1S70WXg5DrxdGvgAAC91NHjhONgm8QKtnb-erCxLJdsVc4nrDtMA9YU0f38dVCV8XegJPECkFRmZqA0jifUJPFxDincjYxp0aPoyPEJwS3QGhrUpKC-71jr5D-UH3FZ1IoOOEi6DiacEfH53jXsAL7f3rNw6-BmttVx6SSn8a3WPDA6iPPmgDAseuXRbezCAq-MCvGzEErxLr7OkRDRqdEZiOwAD9CMBrfaGixn8arsuDA4gLIk_SDnopK4wZg6gNPxUGBSjoXSrAAU8arSA6Qxdjr05PFstjsmboaSuNAqY4APiC5Kp3GE0XEs64qtwPoY08A_DECI1WoNEtyslGyUANoYnBQr8cTxwfHclLvR2aSgdsO01_G73ulAN3EA-pDAWiKgxqjRdRqgdj20QgnZfLY-c9hLmDWGUAku0XOAneBICZTRUglr8oAoo5C9iAvxstisCaiAHiAcCa96Agll6E_RDPYnEHwJ-Ljz2MoJN4pibPLRNAmaCfVeGVhoCYO6ovEPyPoJ79DGGGYgJgnn0TIJc7QWCQAOvYjWCdF6WAA4-okAybHJ8Z8xzeGp8a-MyVJuCZdxLoB6CcHxGfFgGN_oucCJCVv-Uo5pCXcoyIYcyoXxBqgb0cvomprb0WXxrDDWTGyxIvEugC3xEQmSCS4JwXCJ8UDcLQB2WMPRL9FD6HI-CQk6CR4JxCgL8bkJwSDIhpkJ3QkugDgJ_QmU4PkJjZxr0UUJxfFb0dXg5Qnl8ZK4ArFN8X6QH2hYAM0JiQBt-v3RNAGN8ctxqwncluFMlY6A8Wwi43Gsjj7xaA6zgLxklLYsuNTxNDYDlmJKC7b1XjcJqAg4ALesK4w3-JDRNEqECQz2w9Gk8Vry8_GYCRWBnwl3oNXxYjh18Vo4MZ5nlNJxxwmdsbERwvGjkDQQehoAPqKxw_7KSktcJmY_vFgaal79fnRkefazcQrW1ez9cb4EVbZ3CS7xG5h4icHWd1F7nqKxLbHjcVzITwkiNAOWvGQxwPSJ_oyJAEyJvXEsPCcJjI6znLwR8yFllpxYxUzqUUDQAAl1BhgJ5_xXCS8Q3diLrorG7AB10etQ-9JCXvRUHjF3sdsADN7T9jlATtZXAEJe6xDfcaww7rHrEB-xUnFHCZyJnbFycdCJo7GKcSgJ4TgGcdDxqxCw8WP48PHX-HSsvL5zAgN4quZVMXYeRHi1MTfI8LFsiI0xYjiSiJdyeyGQoe1wHTHrMdbR4YnusdsxInHDMeBqfHEyLjchbJIXIWHMHyFJicchFIqiyL6JAuHzvkHhrjH26mkuBsjnMZKulzG_9NcxUwEa4b0grGb45qG-r0A5AS1-_0bTfgm-s37FGL1Gqur9Ruk-GQFHNFkBscyRckcgbkBehkmhfoYmNK7hgMTwHqsy4pp2AOIxeYlxblQY6h4niFIx_DGyMcKRcfh7ZsRYMVxRAFAAAsaT4N024IGR_lcR_BACsQyxOr62EW0apcHDjpCG7kDEKLEAAUx2ERaxseFThAnhxkaq4Yp-ZtG3icK0vInUsdYRx4li2NeJI7AL5EAgN4mniSrIBdp9iQOJF6GPzKKE3-h6Acp0hkHQSeR2GW6aAcmWrAD-oIhJLo5A0GuJhRSbifSQ6AA7iY64L_r-wY3xEfAYALhJ7kA2ERtw36hC4oKEzgDbqBugzBJwsO--YeRWXjVBq5aWsNUBeybP9keJMgHq_lew0uy5BIDi5MZ0ENm-XYmfBhPKZLTUxi8QQkmkhiJJ-sBiSYYxgpAJqikBfDGcSTgAbEk8MXKR19jttDgKbEnOOIP22xG7YHwxOkmdYKSRfxFm8RZmEwF0sWKxQsDIMSzISBASsd7WVkmqUbZJWLEvidT0Wi560HTxiljLodLWHob9iWbIg4lMmK1mGfCeSR2hFE4-SWBJQGEBSXHgUIi7VF5Jz8DASQOgnoZ-SeBJApitZqwyrMSxSdV4YUlJSRFJKUmMwULxLkn_4EeerWB-YcfgROTWSQswHeEhAHwgzkkMSZ-QWABzdiuQtUlIEEVJBAAJevMJBFFNSYsQbIn0SXxcrkk2cIdsCXqTlh1JvUmfkANYPUkaXH1JLUkJeiXGvImdSdqQDUlH6nNJ_UmF4CphnBFLSS1JAfFaVsMeAjGPhMZJdJEUkXpJnyiNAYZJFjhLieSR-WaZJuUxNUkjSfBg2D52sflJATHlMSExi0DGtuuC5VLhkC5WPnGIpI9YCar3UI0BxvHlXlvgFfi2dG8RgJGPEYdku5HDcRYghYChcKAs3QAnDL2ATqTNAO_W_NE6zN8I75DWNvnhn8YwfiismrTvAXmYijbEuF1xct5guKd-GpiVzI3ehImHWL54O3H0QPXwKkb18FnGtv7lfh0Uh2TFgXZxb3GVrPpJx0nP9qdJmJFyMQnOPWhhQWqRn0GVLK--XQCGSSWeCkmqfnwxVWHUMTGILoAOEQSRe0kCycgyTlZrWPwQ79Zm_kcAvI7FfuVezMn2_pV-z_YvtuLJ7EnUMaEWkklqwN2JQX7KzCrJy4nIMkd-O0lqAMwSdYrS5sJmjAobUWN-qOb-pisJ1YnjfodgMlHp1FLmXsmbflDQU36bRoDGjObZfqv4236ugBxhbDEVkAZJX_aLbLHJWYDNfme-JIZWydJJQX4ynKnJUwAgOB4eScnUMYd-AGYhyTt-CclikUYx0sk2rGxJcsmPdn9J19iGSaEB1cm92LXJvpB2SZFRFBGi8AdIw0kTSYVJh2yhAR4a1kmMSYKJavFTUWJhRSrPkd22SBDSYUbxL4klnnyJE-qZer-R3tJR-o1JI0nsECs4K8nZEO--KhrTrikUlzBLSYyJV5jiUWZgR8lsiSfJ5UDVSXWEu8kqQRcS40kZIKNJcI62gSYkSfDDyQvJATFLyfGRaxTYiRlsLmhEAP_gEmGi8MPJs8lfQe--H8mvgUvJzo4IenxcA5ZpQB3qySaq5kpCw8mfEI-gUpGvyQApSBALyetJA8mVLO-QV8bvyREBi8mhMXQA38mcqNe6FxLdyVgprdD4KW_JDEnEOhZxO4y0KUQAw8kAiFq23iSVtkgQAIgHuoLAIHwCNskwV96Qic-6KTDzeg9i4gqiDvPJmrIQUjCKAxCpUjmW14ad4AHApIon8FrayQDyJu7C21QjgERsp7ZxskH2jiYDtKGyzkE_cswmBE4MgksAQGACKQ_wVcGd0tCSl9C_6oYpAxD_3sJK48lPkY8UDikKbu7x91Fo0FUJiTEBAXxsiImzOpXJ3xTCKXHRi3YRAF8sbyac6JGAWoJzjsIpnlC6OlycHG60OsOAXyxOKUYxMLxdgMPJMtapKaQRNYAZKccQDEmoZjeQ9vEjflPJovCgKd7SRo6dATYR1kmgUC3JC4BsSZ5QcOz6IJaucCkWhrAsHWxAri8JNkacYnQQZeD_ib-J_UlviQDsiYzHZAQwCt5sIHpSm0TT0NLRSUgDEI9Y88lHOMZGGHp0EM0poRYIKQ_wzSlESThJxYDnxGRJu0415BbIVEk0SUugKE57BrdB_8FLSmZ6NhFxkQLGfQDZWE7iMmA9mB6kScF8iQcErhHHQZfqr5ydYa-BfwgFiQwAgFwgACV8qVxAgMSAVQDeAKUEv4CF5Ja8QXxm9vm8qVyA-pDAMKkEghp67ux_fCAAhvZX0b4sls4s1r6Ii8AvwP76NDqi6vj45QAggBCpsdzS3AmqLVy7tFhAyKn5PD5UZcRyYprUzLBagC1cgWYGgjgAVtxwolU8pr4hwGyppNxIwDgANoIcfCypNcBsqXpAkMCyhhZ8LKnK6g1ObKnYwLKGUqkiqVCwI8DFYGypUMA4AIjA3KlyvJAeCSL8AIFmEqlgYrKGcQTKqVfUf6ANTkBgXUbwYHa8-qkg3LKGhsL-PGqKDSYOXAapkqnaqQv8mRh7jqnYLqkSqYD6HcBqyu1iyqljFh6-wK5sGGypRkCKqSapVTxG5H0AJuRm5LwmLqkRqRDAUalyvMSp9r6nvCAArqn14SmpC_y_sv-yH2IuqfXhq7HKqTGpdPwBymW8iamSqTmp_jzZPn8ufVp1emypWqlCqdKpIAD0QPCuvU6WDm2JrfaiYhJciACmDgpcbCIWDivA_U5pdi2peL6NqUKpSKklqYiuuT5hJPk-vwLsqZqpSqk8qbcxNqmZqRKpVtzVqZx8xKnWgPypEalcqUU80RRmwGSpuADHTo8gYootWobwQ2A8QmweyjwvXCFg5vRWiHnAhzwKAJ6aQAA`} __position={0} __code={'<Map viewport={{ center: [0.026, 123.61], zoom: 5 }} />'} __scope={{props: this ? this.props : props,Map}}>\n  <Map viewport={{ center: [0.026, 123.61], zoom: 5, }} />\n</Playground>\n           </MDXTag>\n  }\n}\n  "],"sourceRoot":""}