{"version":3,"sources":["webpack:///./src/map/glmap/map.css","webpack:///./src/map/lib/Pack.js","webpack:///./src/map/lib/pelagosClient.js","webpack:///./src/map/proptypes/tracks.js","webpack:///./src/map/proptypes/layers.js","webpack:///./src/map/proptypes/shared.js","webpack:///./src/map/config.js","webpack:///./src/map/module/module.actions.js","webpack:///./src/map/module/module.selectors.js","webpack:///./src/map/tracks/tracks.selectors.js","webpack:///./src/map/constants.js","webpack:///./src/map/utils/getPBFTile.js","webpack:///./src/map/utils/heatmapTileData.js","webpack:///./src/map/utils/buildEndpoint.js","webpack:///./src/map/heatmap/heatmapTiles.actions.js","webpack:///./src/map/heatmap/heatmap.actions.js","webpack:///./src/map/glmap/viewport.actions.js","webpack:///./src/map/glmap/interaction.actions.js","webpack:///./src/map/utils/map-colors.js","webpack:///./src/map/heatmap/HeatmapSubLayer.js","webpack:///./src/map/heatmap/HeatmapLayer.js","webpack:///./src/map/tracks/TracksLayer.js","webpack:///./src/map/activity/ActivityLayers.js","webpack:///./src/map/activity/ActivityLayers.container.js","webpack:///./src/map/glmap/Map.js","webpack:///./src/map/glmap/Map.container.js","webpack:///./src/map/utils/getMainGeomType.js","webpack:///./src/map/glmap/style.actions.js","webpack:///./src/map/store/index.js","webpack:///./src/map/tracks/tracks.actions.js","webpack:///./src/map/utils/withReducerTypes.js","webpack:///./src/map/module/module.reducer.js","webpack:///./src/map/tracks/tracks.reducer.js","webpack:///./src/map/heatmap/heatmap.reducer.js","webpack:///./src/map/heatmap/heatmapTiles.reducer.js","webpack:///./src/map/glmap/viewport.reducer.js","webpack:///./src/map/glmap/style.reducer.js","webpack:///./src/map/glmap/interaction.reducer.js","webpack:///./src/map/store/reducers.js","webpack:///./src/map/map.js","webpack:///./src/map/basemaps/index.js","webpack:///./src/map/map.mdx"],"names":["module","exports","map","googleLogo","byname","Uint8","size","Uint8Array","BYTES_PER_ELEMENT","array","getter","setter","Int8","Int8Array","Uint16","Uint16Array","Int16","Int16Array","Uint32","Uint32Array","Int32","Int32Array","Float32","Float32Array","Float64","Float64Array","writeStringToArrayBuffer","str","start","end","buf","bufstart","undefined","length","i","charCodeAt","arrayBufferToString","String","fromCharCode","apply","Pack","typemap","byarray","pack","typespec","value","littleendian","ArrayBuffer","DataView","stringToArrayBuffer","res","Uint8ClampedArray","buffer","name","spec","PelagosClient","_classCallCheck","this","MAGIC_COOKIE","url","token","Promise","resolve","reject","request","XMLHttpRequest","open","setRequestHeader","concat","responseType","onload","handleData","bind","onerror","send","self","error","readyState","success","status","isFileUri","response","byteLength","dataView","headerLen","cookie","slice","getInt32","offset","headerIsLoaded","header","JSON","parse","rowLen","colsByName","colidx","cols","col","idx","type","multiplier","min","max","orientation","errorLoading","toString","allLoaded","result","rowidx","row","val","colValues","eval","trackTypes","id","PropTypes","string","isRequired","data","object","color","oneOf","layerTemporalExtents","arrayOf","number","fitBoundsOnLoad","bool","shape","hue","filterValues","endpoints","isPBF","temporalExtents","temporalExtentsLess","field","values","node","VESSELS_BASE_RADIUS","MAX_SPRITES_PER_LAYER","TILES_URL_NEEDING_AUTHENTICATION","startLoader","dispatch","state","loaderId","timestamp","Date","getTime","payload","onLoadStart","completeLoader","getState","loaders","onLoadComplete","setHighlightTemporalExtent","highlightTemporalExtent","getTemporalExtent","temporalExtent","getHighlightTemporalExtent","getGeojsonTracks","createSelector","tracks","filter","t","getGeojsonTracksReady","mergeStyles","style1","style2","sources","_objectSpread","layers","_toConsumableArray","filterGeojsonByTimerange","geojson","_ref","features","featuresFiltered","reduce","filteredFeatures","feature","properties","coordinateProperties","times","filtered","geometry","coordinates","filteredCoordinates","coordinate","index","timeCoordinate","push","filteredFeature","getFullTracksStyles","hasTemporalExtent","hasTracks","timerange","acc","track","source","style","_defineProperty","paint","line-width","line-color","circle-radius","circle-color","getHighlightedTrackStyles","getTracksStyles","trackStyles","highlightedTrackStyles","TRANSITION_TYPE","BRUSH_RENDERING_STYLE","NORMAL","BULLSEYE","BRUSH_ZOOM_RENDERING_STYLE","CUSTOM_LAYERS_SUBTYPES","getPBFTile","tileUrl","fetch","headers","Authorization","then","ok","Error","blob","reader","FileReader","addEventListener","pbf","Pbf","vectorTile","VectorTile","readAsArrayBuffer","catch","e","console","warn","getTemporalTileURLs","urlTemplate","params","urls","forEach","extent","urlParams","seriesgroup","startTimeISO","toISOString","endTimeISO","tileCoordinates","x","y","z","zoom","templateSettings","interpolate","template","urlTemplateCompiled","buildEndpoint","temporalExtentsIndices","indexOf","getTilePromises","tilesetUrl","promises","urlIndex","obtainTile","getCleanVectorArrays","rawTileData","vectorArray","groupData","cleanVectorArrays","columns","currentArray","totalVectorArraysLength","sumBy","a","longitude","filteredColumns","column","key","cumulatedOffsets","appendValues","set","getTilePlaybackData","prevPlaybackData","tilePlaybackData","zoomFactorRadius","convert","getZoomFactorRadius","zoomFactorRadiusRenderingMode","getZoomFactorRadiusRenderingMode","zoomFactorOpacity","getZoomFactorOpacity","columnsArr","Object","keys","c","storedColumns","sigma","weight","hidden","pull","uniq","_loop","point","geom","toGeoJSON","latitude","timeIndex","getOffsetedTimeAtPrecision","datetime","_lngLatToWorld2","_slicedToArray","lngLatToWorld","worldX","worldY","radius","sigmaToRadius","opacity","weightToOpacity","series","frame","addTracksPointsRenderingData","hasFishing","_lngLatToWorld4","getTracksPlaybackData","playbackData","vesselSatisfiesFilters","every","selectVesselsAt","tileData","tileQuery","startIndex","endIndex","currentFilters","vessels","toleranceRadiusInWorldUnits","_loop2","f","_loop3","wx","wy","filters","pass","some","vesselSatisfiesAllFilters","vessel","getTilecoverLimits","viewportZoom","Math","ceil","tilesAvailable","min_zoom","max_zoom","flushToReleaseTiles","heatmapTiles","currentToLoadTileUids","currentTilesToReleaseUids","currentToReleaseTileUids","releaseTiles","markTileAsLoaded","tileUids","flushTileState","forceLoadingAllVisibleTiles","arguments","currentVisibleTiles","tilesToLoad","tilesToReleaseUids","currentLoadedTiles","visibleTile","find","uid","loadedTile","tilesToLoadUids","tile","referenceTile","ADD_REFERENCE_TILE","visibleHeatmapLayers","heatmap","heatmapLayers","visibleHeatmapLayersIds","visible","getTiles","updateLoadedTiles","debouncedFlushState","debounce","updateHeatmapTilesFromViewport","mapViewport","viewport","currentTransition","boundsViewport","PerspectiveMercatorViewport","bounds","unproject","width","height","wn","es","w","s","n","boundsPolygonsCoordinates","limits","w1","e2","viewportTilesCoords","tilecover","tiles","viewportTilesIndexes","indexes","visibleTiles","coords","prevZoom","queryHeatmapVessels","temporalExtentIndexes","uids","_queryHeatmap2","_queryHeatmap","layer","isEmpty","isCluster","isMouseCluster","foundVessels","highlightedVessels","layerId","HIGHLIGHT_VESSELS","tilesetId","subtype","clickableCluster","highlightableCluster","clearHighlightedVessels","highlightVesselFromHeatmap","heatmapTiles_actions_objectSpread","UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES","UPDATE_HEATMAP_TILE","getTemporalExtentsVisibleIndices","loadTemporalExtent","currentExtentStart","currentExtentEnd","indices","temporalExtentStart","layerIds","referenceTiles","newTemporalExtentsToLoad","loaderID","join","tilesByLayer","heatmap_actions_toConsumableArray","allPromises","heatmapLayerHeader","_heatmapLayerHeader","heatmap_actions_objectSpread","temporalExtentsIndicesLoaded","queriedTemporalExtentsIndices","visibleTemporalExtentsIndices","temporalExtentsIndicesToLoad","difference","tilePromise","pelagosPromises","allLayerPromises","all","loadedLayerId","loadLayerTile","_ref2","points","parseLayerTile","loadAllTilesForLayer","layersVessels","availableTiles","bestTile","layerVesselsResult","layersVesselsResults","layerVessels","hasEncounters","layerVessel","v","uniqBy","updateHeatmapLayers","newLayers","currentLoadTemporalExtent","prevLayersDict","newLayer","prevLayer","interactive","prevLayerId","l","transitionTo","increment","callback","onViewportChange","center","canZoomIn","canZoomOut","mouseLatLong","getFeatureMetaFields","staticLayerId","mapStyle","toJS","metadata","getStaticLayerIdFromGlFeature","glFeature","findFeature","glFeatures","mapClick","cluster","currentActivityLayersInteractionData","event","fields","metaFields","metaField","pow","area","toLocaleString","maximumFractionDigits","title","label","isLink","target","zoomIntoVesselCenter","onClick","interaction_actions_objectSpread","hsvToRgb","h_","s_","v_","h","parseFloat","floor","p","q","mod","r","g","b","round","hueToRgbDefaults","hueToRgbString","rgb","hexToRgb","hex","exec","parseInt","hueIncrementToHue","hueIncrement","wrapHue","HeatmapSubLayer","baseTexture","renderingStyleIndex","useNormalBlendMode","stage","PIXI","particles","ParticleContainer","scale","alpha","position","uvs","blendMode","BLEND_MODES","SCREEN","spritesPool","initialTextureFrame","Rectangle","mainVesselTexture","Texture","_setTextureFrame","clearSpriteProps","spritesProps","spritesPropsCount","destroy","children","textureFrame","clone","hueToHueIncrement","VESSELS_HUES_INCREMENTS_NUM","update","numProps","resizeSpritesPool","sprite","setTransform","numSprites","delta","toRemove","removeChildAt","toAdd","_addSprites","num","Sprite","anchor","addChild","worldToPixelsSimple","m","HeatmapLayer","React","Component","_build","_destroy","_redraw","nextProps","useRadialGradientStyle","props","setBrushZoomRenderingStyle","_this$props","rootStage","customRenderingStyle","subLayers","renderingStyle","rendering","setBrushRenderingStyle","brushRenderingStyle","toUpperCase","_setBrushRenderingStyleIndex","brushZoomRenderingStyle","_this","cappedZoomRenderingStyle","newStyleIndex","subLayer","setRenderingStyleIndex","_this2","_this$props2","defaultHue","allHuesToRender","currentlyUsedHues","allHues","_createSublayer","_destroySubLayer","_setSubLayersSpritePropsForTile","numFilters","hueToRender","render","_this$props3","viewportLeft","viewportRight","len","fi","scaledX","scaledY","mtx","pixelProjectionMatrix","_ref3","HeatmapLayer_slicedToArray","pitch","worldToPixels","pushSpriteProps","defaultOpacity","defaultSize","removeChild","TracksLayer","Graphics","nativeLines","clear","highlightTemporalExtentIndexes","overInInner","overExtent","drawFishingCircles","fishingCirclesRadius","drawOverTrack","_drawTrack","substr","lineThickness","lineOpacity","prevSeries","prevWorldX","prevWorldY","_ref$worldOffset","worldOffset","circlePoints","lineStyle","duplicateWorld","currentSeries","_worldToPixels2","TracksLayer_slicedToArray","moveTo","abs","atDatelineWorldY","isWestToEast","worldXEnd","atDatelineEndWorldX","atDatelineStartWorldX","_worldToPixels4","x1","y1","lineTo","_worldToPixels6","x2","y2","beginFill","circlesLength","drawCircle","endFill","ActivityLayers","pixiReady","touches","queryCoords","clientX","clientY","heatmapFadingIn","heatmapStage","_heatmapFadeinStep","BaseControl","setState","exportNativeViewport","_context","_updateViewportSize","_this$props$viewport","pixi","transparent","antialias","renderer","canvas","view","container","appendChild","baseTextureCanvas","blurFactor","tplCanvas","document","createElement","tplCtx","getContext","diameter","yCenter","gradient","createRadialGradient","rgbString","addColorStop","rgbOuter","fillStyle","fillRect","beginPath","arc","PI","fill","lineWidth","strokeStyle","stroke","getVesselTexture","fromCanvas","ticker","add","_onTick","viewportWidth","viewportHeight","resize","dim","_viewport$unproject2","ActivityLayers_slicedToArray","wrappedLongitude","heatmapFadeinStartTimestamp","now","timeElapsed","highlightedClickedVessel","highlightLayerData","highlightFilters","ActivityLayers_objectSpread","leftWorldScaled","rightWorldScaled","shouldUseRadialGradientStyle","toggleHeatmapDimming","_startHeatmapFadein","err","gl","getError","log","_this$_getHighlightDa","_getHighlightData","react_default","ref","onMouseMove","onTouchStart","react","heatmap_HeatmapLayer","tracks_TracksLayer","propTypes","func","contextTypes","getHeatmapLayersAsArray","ActivityLayers_container_objectSpread","getTracksWithData","getTemporalExtentIndexes","startTimestamp","endTimestamp","getHighlightTemporalExtentIndexes","connect","ownProps","nativeViewport","topLeftPx","bottomRightPx","topLeftWorld","pixelsToWorld","pixelUnprojectionMatrix","bottomRightWorld","northWest","southEast","north","south","west","east","PopupWrapper","closeButton","onClose","esm","offsetTop","tipSize","closeOnClick","defaultProps","Map","Map_classCallCheck","Map_getPrototypeOf","call","Map_defineProperty","Map_assertThisInitialized","_mapContainerRef","mapContainerStyle","window","getComputedStyle","setViewport","Map_objectSpread","mapHover","glMap","clusterId","cluster_id","sourceId","glSource","getSource","getClusterExpansionZoom","err1","getClusterLeaves","err2","lngLat","onMapInteraction","getMap","isDragging","cursor","resourceType","match","mouseOver","_resize","setTimeout","removeEventListener","_this3","maxZoom","minZoom","transitionEnd","onClosePopup","clickPopup","hoverPopup","interactiveLayerIds","className","styles","onMouseLeave","onMouseEnter","assign","getRef","transformRequest","onTransitionEnd","onHover","getCursor","ActivityLayers_container","Map_PopupWrapper","content","getInteractiveLayerIds","staticLayers","getMapStyle","mapStyles","trackLayersIndex","lastIndexOf","finalMapStyles","mergeIn","mapStylesLayers","get","trackLayer","insert","fromJS","interaction","lat","long","popupFields","mainPopupFieldId","toLowerCase","featureTitle","objects","TYPES","geoJSON","setMapStyle","updateGLLayer","glLayerId","refLayer","currentStyleLayers","newStyle","glLayerIndex","findIndex","glLayer","visibility","setIn","toggleLayerVisibility","isBasemap","initialGLLayer","GL_STYLE","refLayerOpacity","labelsVisibility","getIn","showLabels","currentGlLayer","currentStyle","glType","defaultStyles","styleType","hasFeatures","applyStyleToAllFeatures","allPaintProperties","style_actions_objectSpread","glPaintProperty","glPaintFinalValue","selectedValue","fallbackValue","paintOrLayout","includes","originalLayerStyle","layerColorRgbString","layerColorRgb","replace","applyLayerExpressions","addCustomGLLayer","tileSize","allGeoJSONTypes","numByGLType","geoJSONType","glTypeMax","getMainGeomType","layout","layerIndex","reverse","splice","instanciateCartoLayers","cartoLayersPromises","sourceCartoSQL","mapConfig","options","sql","mapConfigURL","encodeURIComponent","stringify","cartoAnonymousMapUrl","json","layergroupid","instanciatedCartoLayers","cartoLayer","tilesURL","newSourceId","commitStyleUpdates","basemapLayers","style_actions_toConsumableArray","bl","currentGLSources","workspaceGLLayers","workspaceGLLayer","finalSource","srcGlLayer","source-layer","finalLayers","addWorkspaceGLLayers","customLayers","isCustom","glLayers","glSources","cartoLayersToInstanciate","newTiles","cartoLayerInstanciated","cartoLayersInstanciated","composeEnhancers","compose","process","MAP_REDUX_REMOTE_DEBUG","REACT_APP_MAP_REDUX_REMOTE_DEBUG","store","createStore","applyMiddleware","thunk","targetMapVessel","geoBounds","vp","fitBounds","minLng","minLat","maxLng","maxLat","padding","timelineBounds","ADD_TRACK","UPDATE_TRACK","getTrackDataParsed","time","Infinity","getTrackBounds","tbbox","getOldTrackBoundsFormat","addOffset","geo","lng","updateTracks","newTracks","prevTracks","newTrack","trackId","prevTrack","trackHasData","trackHasUrl","cleanData","rawTrackData","statusText","_getTrackDataParsed","finally","withReducerPropTypes","propTypesSchema","reducer","initialState","onAttributionsChange","withReducerTypes","instanceOf","action","module_reducer_objectSpread","module_reducer_toConsumableArray","loaderIndex","exact","tracks_reducer_objectSpread","tracks_reducer_toConsumableArray","trackData","removedTrackId","DEFAULT_TRANSITION","transitionDuration","transitionInterpolator","FlyToInterpolator","transitionEasing","easeCubic","bearing","attributions","sourceKey","attribution","mapReducer","combineReducers","ModuleReducer","TracksReducer","indicesAdded","heatmap_reducer_defineProperty","heatmap_reducer_objectSpread","heatmap_reducer_toConsumableArray","newTile","layerTiles","tileIndex","tileUid","releasedTileIndex","releasedRefTileIndex","newHeatmapLayers","heatmapTiles_reducer_objectSpread","tileUidsMarkedAsLoaded","newMapStyle","glyphsPath","style_reducer_objectSpread","style_reducer_toConsumableArray","viewport_reducer_objectSpread","currentZoom","interaction_reducer_objectSpread","mapReducers","replaceReducer","throttleApplyTemporalExtent","throttle","currentFilter","applyTemporalExtent","setTemporalExtent","updateViewportFromIncomingProps","incomingViewport","viewportUpdate","MapModule","initialized","errorInfo","prevProps","indicesToAddByLayer","heatmapLayer","oldVisibleTemporalExtentsIndices","newVisibleTemporalExtentsIndices","layerIdsWithIndicesToAdd","currentViewport","componentStack","react_redux_es","Map_container","MDXContent","map_map_classCallCheck","map_map_possibleConstructorReturn","map_map_getPrototypeOf","components","_objectWithoutProperties","dist","parentName","href","index_m","__codesandbox","__position","__code","__scope","map_map"],"mappings":"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","file":"static/js/src-map-map.1794bc5f.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"map\":\"map_map__1TLha\",\"googleLogo\":\"map_googleLogo__3lQ1y\"};","var byname = {\n  Uint8: {\n    size: Uint8Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint8',\n    setter: 'setUint8',\n  },\n  Int8: {\n    size: Int8Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint8',\n    setter: 'setUint8',\n  },\n  Uint16: {\n    size: Uint16Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint16',\n    setter: 'setUint16',\n  },\n  Int16: {\n    size: Int16Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getInt16',\n    setter: 'setInt16',\n  },\n  Uint32: {\n    size: Uint32Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint32',\n    setter: 'setUint32',\n  },\n  Int32: {\n    size: Int32Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getInt32',\n    setter: 'setInt32',\n  },\n  Float32: {\n    size: Float32Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getFloat32',\n    setter: 'setFloat32',\n  },\n  Float64: {\n    size: Float64Array.BYTES_PER_ELEMENT,\n    array: 'Float64Array',\n    getter: 'getFloat64',\n    setter: 'setFloat64',\n  },\n}\n\nvar writeStringToArrayBuffer = function(str, start, end, buf, bufstart) {\n  if (end == undefined) {\n    end = str.length\n  }\n  if (start == undefined) {\n    start = 0\n  }\n  if (bufstart == undefined) {\n    bufstart = start\n  }\n  for (var i = start; i < end; i++) {\n    buf[i - start + bufstart] = str.charCodeAt(i) & 0xff\n  }\n}\n\nvar stringToArrayBuffer = function(str, start, end) {\n  var self = this\n\n  if (end == undefined) {\n    end = str.length\n  }\n  if (start == undefined) {\n    start = 0\n  }\n  var res = new Uint8ClampedArray(end - start)\n  writeStringToArrayBuffer(str, start, end, res, 0)\n  return res.buffer\n}\n\nvar arrayBufferToString = function(buf) {\n  return String.fromCharCode.apply(null, new Uint8Array(buf))\n}\n\nvar pack = function(typespec, value, littleendian) {\n  var array = new ArrayBuffer(typespec.size)\n  new DataView(array)[typespec.setter](0, value, littleendian)\n  return arrayBufferToString(array)\n}\n\nvar Pack = {\n  typemap: {\n    byname: byname,\n    byarray: {},\n  },\n  pack: pack,\n  arrayBufferToString: arrayBufferToString,\n  stringToArrayBuffer: stringToArrayBuffer,\n  writeStringToArrayBuffer: writeStringToArrayBuffer,\n}\nfor (var name in Pack.typemap.byname) {\n  var spec = Pack.typemap.byname[name]\n  spec.name = name\n  Pack.typemap.byarray[spec.array] = spec\n}\n\nexport default Pack\n","import Pack from './Pack'\n\nclass PelagosClient {\n  constructor() {\n    this.MAGIC_COOKIE = 'tmtx'\n  }\n\n  obtainTile(url, token) {\n    return new Promise(\n      function(resolve, reject) {\n        this.request = null\n        if (typeof XMLHttpRequest != 'undefined') {\n          this.request = new XMLHttpRequest()\n        } else {\n          throw 'XMLHttpRequest is disabled'\n        }\n        this.resolve = resolve\n        this.reject = reject\n        this.request.open('GET', url, true)\n        if (token) {\n          this.request.setRequestHeader('Authorization', `Bearer ${token}`)\n        }\n        this.request.responseType = 'arraybuffer'\n        this.request.onload = this.handleData.bind(this)\n        this.request.onerror = this.handleData.bind(this)\n        this.request.send(null)\n      }.bind(this)\n    )\n  }\n\n  handleData() {\n    var self = this\n    if (!this.request) {\n      return\n    }\n    if (this.error) {\n      return true\n    }\n\n    if (this.request.readyState == 4) {\n      /* HTTP reports success with a 200 status. The file protocol\n       reports success with zero. HTTP returns zero as a status\n       code for forbidden cross domain requests.\n       https://developer.mozilla.org/En/Using_XMLHttpRequest */\n      var success = this.request.status == 200 || (this.isFileUri && this.request.status == 0)\n      if (!success) {\n        this.resolve(null)\n        return\n      }\n    }\n\n    if (!this.request.response) {\n      return\n    }\n    var length = this.request.response.byteLength\n    var response = this.request.response\n    var dataView = new DataView(response)\n\n    if (length < 4 + 4) {\n      return\n    }\n    if (self.headerLen == null) {\n      var cookie = Pack.arrayBufferToString(response.slice(0, 4))\n      if (cookie != this.MAGIC_COOKIE) {\n        this.reject(\n          'Could not load ' +\n            this.url +\n            ' due to incorrect file format. Cookie: [' +\n            this.cookie +\n            ']'\n        )\n        return\n      }\n\n      self.headerLen = dataView.getInt32(4, true)\n\n      self.offset = 4 + 4\n    }\n    if (length < self.offset + self.headerLen) {\n      return\n    }\n    if (!self.headerIsLoaded) {\n      self.header = JSON.parse(\n        Pack.arrayBufferToString(response.slice(self.offset, self.offset + self.headerLen))\n      )\n      self.rowLen = 0\n      self.header.colsByName = {}\n      for (var colidx = 0; colidx < self.header.cols.length; colidx++) {\n        var col = self.header.cols[colidx]\n        col.idx = colidx\n        self.header.colsByName[col.name] = col\n        col.typespec = Pack.typemap.byname[col.type]\n\n        if (col.multiplier != undefined && col.min != undefined) {\n          col.min = col.min * col.multiplier\n        }\n        if (col.offset != undefined && col.min != undefined) {\n          col.min = col.min + col.offset\n        }\n        if (col.multiplier != undefined && col.max != undefined) {\n          col.max = col.max * col.multiplier\n        }\n        if (col.offset != undefined && col.max != undefined) {\n          col.max = col.max + col.offset\n        }\n\n        self.rowLen += col.typespec.size\n      }\n      self.offset += self.headerLen\n\n      // Add the padding to nearest 4-byte-boundary\n      self.offset += (4 - (self.headerLen % 4)) % 4\n\n      self.headerIsLoaded = true\n      if (self.header.orientation != 'rowwise' && self.header.orientation != 'columnwise') {\n        self.errorLoading({\n          orientation: self.header.orientation,\n          toString: function() {\n            return (\n              'Could not load ' +\n              this.url +\n              ' due to unsupported file orientation. Orientation: ' +\n              this.orientation +\n              '. Supported orientations: rowwise, columnwise.'\n            )\n          },\n        })\n        return true\n      }\n\n      // Empty tile, stop parsing.\n      if (!self.rowLen) {\n        self.allLoaded()\n        return true\n      }\n    }\n    if (self.header.orientation == 'rowwise') {\n      var result = {}\n      for (; self.offset + self.rowLen <= length; self.rowidx++) {\n        var row = {}\n        for (var colidx = 0; colidx < self.header.cols.length; colidx++) {\n          var col = self.header.cols[colidx]\n          var val = dataView[col.typespec.getter](self.offset, true)\n          row[col.name] = val\n          self.offset += col.typespec.size\n        }\n        // self.rowLoaded(row);\n\n        result[col.name] = row\n      }\n      if (self.rowidx == self.header.length) {\n        // self.allLoaded();\n        this.resolve(result)\n      } else {\n        // self.batchLoaded();\n      }\n    } else if (self.header.orientation == 'columnwise') {\n      var colValues = null\n      var result = {}\n      if (length >= self.offset + self.header.length * self.rowLen) {\n        for (var colidx = 0; colidx < self.header.cols.length; colidx++) {\n          var col = self.header.cols[colidx]\n\n          colValues = new (eval(col.typespec.array))(\n            response.slice(self.offset, self.offset + col.typespec.size * self.header.length)\n          )\n          self.offset += self.header.length * col.typespec.size\n\n          result[col.name] = colValues\n        }\n\n        // self.allLoaded();\n        this.resolve(result)\n        return true\n      }\n    }\n  }\n}\n\nexport default PelagosClient\n","import PropTypes from 'prop-types'\n\nexport const trackTypes = {\n  id: PropTypes.string.isRequired,\n  url: PropTypes.string,\n  data: PropTypes.object,\n  color: PropTypes.string,\n  type: PropTypes.oneOf(['geojson', undefined]),\n  layerTemporalExtents: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.number)),\n  fitBoundsOnLoad: PropTypes.bool,\n}\n","import PropTypes from 'prop-types'\n\nexport const heatmapLayerTypes = {\n  id: PropTypes.string.isRequired,\n  tilesetId: PropTypes.string,\n  subtype: PropTypes.string,\n  visible: PropTypes.bool,\n  hue: PropTypes.number,\n  opacity: PropTypes.number,\n  filters: PropTypes.arrayOf(\n    PropTypes.shape({\n      // hue overrides layer hue if set\n      hue: PropTypes.number,\n      // filterValues is a dictionary in which each key is a filterable field,\n      // and values is an array of all possible values (OR filter)\n      // ie: filterValues: { category: [5, 6] }\n      filterValues: PropTypes.object,\n    })\n  ),\n  header: PropTypes.shape({\n    endpoints: PropTypes.object,\n    isPBF: PropTypes.bool,\n    colsByName: PropTypes.object,\n    temporalExtents: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.number)),\n    temporalExtentsLess: PropTypes.bool,\n  }).isRequired,\n  interactive: PropTypes.bool,\n}\n\nexport const basemapLayerTypes = {\n  id: PropTypes.string,\n  visible: PropTypes.bool,\n}\n\nexport const staticLayerTypes = {\n  id: PropTypes.string.isRequired,\n  // TODO MAP MODULE Is that needed and if so why\n  visible: PropTypes.bool,\n  selected: PropTypes.bool,\n  selectedFeatures: PropTypes.shape({\n    field: PropTypes.string,\n    values: PropTypes.arrayOf(PropTypes.string),\n  }),\n  highlighted: PropTypes.bool,\n  higlightedFeatures: PropTypes.shape({\n    field: PropTypes.string,\n    values: PropTypes.arrayOf(PropTypes.string),\n  }),\n  opacity: PropTypes.number,\n  color: PropTypes.string,\n  showLabels: PropTypes.bool,\n  interactive: PropTypes.bool,\n  filters: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.string)),\n  isCustom: PropTypes.bool,\n  subtype: PropTypes.oneOf([undefined, 'geojson', 'raster']),\n  url: PropTypes.string,\n  data: PropTypes.object,\n  gl: PropTypes.object,\n}\n","import PropTypes from 'prop-types'\n\nexport const popupTypes = {\n  content: PropTypes.node,\n  latitude: PropTypes.number.isRequired,\n  longitude: PropTypes.number.isRequired,\n}\n\nexport const viewportTypes = {\n  zoom: PropTypes.number,\n  center: PropTypes.arrayOf(PropTypes.number),\n}\n","// Application settings\nexport const TIMELINE_STEP = 24 * 60 * 60 * 1000 // 1 day\nexport const MIN_FRAME_LENGTH_MS = TIMELINE_STEP // 1 day\n\n// vessels rendering\n// from this zoom level and above, render using circle style instead of heatmap\nexport const VESSELS_RADIAL_GRADIENT_STYLE_ZOOM_THRESHOLD = 6\n// the base radius, it can only be scaled down by the radius factor calculated on the dataset\nexport const VESSELS_BASE_RADIUS = 8\n// in heatmap style, defines how 'blurry' a point will look. Higher = less blur\nexport const VESSELS_HEATMAP_BLUR_FACTOR = 0.15\n\nexport const ACTIVITY_HIGHLIGHT_HUE = 312\n\nexport const VESSELS_HEATMAP_DIMMING_ALPHA = 0.5\n\nexport const TRACKS_DOTS_STYLE_ZOOM_THRESHOLD = 2\n\nexport const MAX_SPRITES_PER_LAYER = 200000\n\n// interaction\n// radius of vessels lookup in pixels,\n// ie how large the clicked region should be for including vessels\nexport const VESSEL_CLICK_TOLERANCE_PX = 10\n\nexport const CLUSTER_CLICK_ZOOM_INCREMENT = 1\n\nexport const MIN_ZOOM_LEVEL = 1\n// user can zoom up to this z level, but it doesn't guarantee availability of tiles\nexport const MAX_ZOOM_LEVEL = 14\n\n// data\n// Limit tile loading for activity layers up to this z level.\n// Beyond, layer is still displayed but with coarse data from the lower zoom level\nexport const ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING = 10\n\n// Sets what should be the discrete zoom level to load tiles, from a non-discrete\n// viewport zoom values. For instance, a values of 0.5 will load z 3 with a viewport\n// z of 2 (ceiling of 2 + 0.5)\n// this has a direct impact on the number of points displayed on the map, thus on the\n// performance of the app.\nexport const TILES_LOAD_ZOOM_OFFSET = 0.5\n\nexport const STATIC_LAYERS_CARTO_ENDPOINT =\n  'https://carto.globalfishingwatch.org/user/admin/api/v1/map?config=$MAPCONFIG'\nexport const STATIC_LAYERS_CARTO_TILES_ENDPOINT =\n  'https://carto.globalfishingwatch.org/user/admin/api/v1/map/$LAYERGROUPID/{z}/{x}/{y}.mvt'\n\nexport const TRACKS_LAYER_IN_FRONT_OF_GROUP = 'static'\n\nexport const TILES_URL_NEEDING_AUTHENTICATION = 'dot-world-fishing'\n","export const INIT_MODULE = 'INIT_MODULE'\nexport const SET_TEMPORAL_EXTENT = 'SET_TEMPORAL_EXTENT'\nexport const SET_HIGHLIGHT_TEMPORAL_EXTENT = 'SET_HIGHLIGHT_TEMPORAL_EXTENT'\nexport const START_LOADER = 'START_LOADER'\nexport const COMPLETE_LOADER = 'COMPLETE_LOADER'\n\nexport const initModule = (props) => (dispatch) => {\n  dispatch({\n    type: INIT_MODULE,\n    payload: props,\n  })\n}\n\nexport const startLoader = (dispatch, state, loaderId) => {\n  const timestamp = new Date().getTime()\n  const generatedLoaderId = loaderId !== undefined ? `${loaderId}_${timestamp}` : timestamp\n  dispatch({\n    type: START_LOADER,\n    payload: generatedLoaderId,\n  })\n  if (state.map.module.onLoadStart !== undefined) {\n    state.map.module.onLoadStart()\n  }\n  return loaderId\n}\n\nexport const completeLoader = (loaderId) => (dispatch, getState) => {\n  dispatch({\n    type: COMPLETE_LOADER,\n    payload: loaderId,\n  })\n  const state = getState()\n  const loaders = state.map.module.loaders\n  if (!loaders.length && state.map.module.onLoadComplete !== undefined) {\n    state.map.module.onLoadComplete()\n  }\n}\n\nexport const onViewportChange = () => (dispatch, getState) => {\n  const state = getState()\n  const callback = state.map.module.onViewportChange\n\n  if (callback === undefined) {\n    return\n  }\n  const viewport = state.map.viewport\n\n  if (viewport.bounds === undefined) {\n    return\n  }\n\n  callback({\n    zoom: viewport.viewport.zoom,\n    center: [viewport.viewport.latitude, viewport.viewport.longitude],\n    bounds: viewport.bounds,\n    canZoomIn: viewport.canZoomIn,\n    canZoomOut: viewport.canZoomOut,\n    mouseLatLong: viewport.mouseLatLong,\n  })\n}\n\nexport const setTemporalExtent = (temporalExtent) => ({\n  type: SET_TEMPORAL_EXTENT,\n  payload: temporalExtent,\n})\n\nexport const setHighlightTemporalExtent = (highlightTemporalExtent) => ({\n  type: SET_HIGHLIGHT_TEMPORAL_EXTENT,\n  payload: highlightTemporalExtent,\n})\n\nexport const closePopup = () => (dispatch, getState) => {\n  const state = getState()\n  if (state.map.module.onClosePopup !== undefined) {\n    state.map.module.onClosePopup()\n  }\n}\n","export const getTemporalExtent = (state) => state.map.module.temporalExtent\n\nexport const getHighlightTemporalExtent = (state) => state.map.module.highlightTemporalExtent\n","import { createSelector } from 'reselect'\nimport { getTemporalExtent, getHighlightTemporalExtent } from '../module/module.selectors'\n\nexport const getTracksData = (state) => state.map.tracks.data\nexport const getGeojsonTracks = createSelector(\n  getTracksData,\n  (tracks) => tracks.filter((t) => t.type === 'geojson')\n)\nexport const getGeojsonTracksReady = createSelector(\n  getGeojsonTracks,\n  (tracks) => tracks.filter((t) => t.data !== undefined)\n)\n\nconst mergeStyles = (style1, style2) => ({\n  sources: { ...style1.sources, ...style2.sources },\n  layers: [...style1.layers, ...style2.layers],\n})\n\nconst filterGeojsonByTimerange = (geojson, { start, end }) => {\n  if (!geojson || !geojson.features) return null\n  const featuresFiltered = geojson.features.reduce((filteredFeatures, feature) => {\n    const hasTimes =\n      feature.properties.coordinateProperties.times &&\n      feature.properties.coordinateProperties.times.length > 0\n    if (hasTimes) {\n      const filtered = feature.geometry.coordinates.reduce(\n        (filteredCoordinates, coordinate, index) => {\n          const timeCoordinate = feature.properties.coordinateProperties.times[index]\n          const isInTimeline = timeCoordinate >= start && timeCoordinate <= end\n          if (isInTimeline) {\n            filteredCoordinates.coordinates.push(coordinate)\n            filteredCoordinates.times.push(timeCoordinate)\n          }\n          return filteredCoordinates\n        },\n        { coordinates: [], times: [] }\n      )\n      if (!filtered.coordinates.length) return filteredFeatures\n\n      const filteredFeature = {\n        ...feature,\n        geometry: {\n          ...feature.geometry,\n          coordinates: filtered.coordinates,\n        },\n        properties: {\n          ...feature.properties,\n          coordinateProperties: {\n            times: filtered.times,\n          },\n        },\n      }\n      filteredFeatures.push(filteredFeature)\n    }\n    return filteredFeatures\n  }, [])\n  const geojsonFiltered = {\n    ...geojson,\n    features: featuresFiltered,\n  }\n  return geojsonFiltered\n}\n\nconst getFullTracksStyles = createSelector(\n  [getTemporalExtent, getGeojsonTracksReady],\n  (temporalExtent, tracks) => {\n    const hasTemporalExtent = temporalExtent && temporalExtent.length > 0\n    const hasTracks = tracks && tracks.length > 0\n    if (!hasTemporalExtent || !hasTracks) return null\n\n    const timerange = {\n      start: temporalExtent[0].getTime(),\n      end: temporalExtent[1].getTime(),\n    }\n    const styles = tracks.reduce(\n      (acc, track) => {\n        if (!track.data) return acc\n\n        const source = `${track.id}Track`\n        const style = {\n          sources: {\n            [source]: {\n              type: 'geojson',\n              data: filterGeojsonByTimerange(track.data, timerange),\n            },\n          },\n          layers: [\n            {\n              id: `${track.id}Lines`,\n              source,\n              type: 'line',\n              paint: {\n                'line-width': 1,\n                'line-color': track.color,\n              },\n            },\n            {\n              id: `${track.id}Points`,\n              source,\n              type: 'circle',\n              filter: ['match', ['geometry-type'], ['', 'Point'], true, false],\n              paint: {\n                'circle-radius': 4,\n                'circle-color': track.color,\n              },\n            },\n          ],\n        }\n        return mergeStyles(acc, style)\n      },\n      { sources: {}, layers: [] }\n    )\n    return styles\n  }\n)\n\nconst getHighlightedTrackStyles = createSelector(\n  [getHighlightTemporalExtent, getGeojsonTracksReady],\n  (highlightTemporalExtent, tracks) => {\n    const hasTemporalExtent = highlightTemporalExtent && highlightTemporalExtent.length > 0\n    const hasTracks = tracks && tracks.length > 0\n    if (!hasTemporalExtent || !hasTracks) return null\n\n    const timerange = {\n      start: highlightTemporalExtent[0].getTime(),\n      end: highlightTemporalExtent[1].getTime(),\n    }\n    const styles = tracks.reduce(\n      (acc, track) => {\n        if (!track.data) return acc\n\n        const source = `${track.id}HighlightedTrack`\n        const style = {\n          sources: {\n            [source]: {\n              type: 'geojson',\n              data: filterGeojsonByTimerange(track.data, timerange),\n            },\n          },\n          layers: [\n            {\n              id: `${track.id}HighlightedLines`,\n              source,\n              type: 'line',\n              paint: {\n                'line-width': 1,\n                'line-color': '#fff',\n              },\n            },\n          ],\n        }\n        return mergeStyles(acc, style)\n      },\n      { sources: {}, layers: [] }\n    )\n    return styles\n  }\n)\n\nexport const getTracksStyles = createSelector(\n  [getFullTracksStyles, getHighlightedTrackStyles],\n  (trackStyles, highlightedTrackStyles) => {\n    if (!highlightedTrackStyles) return trackStyles\n    return mergeStyles(trackStyles, highlightedTrackStyles)\n  }\n)\n","export const GL_TRANSPARENT = 'rgba(0,0,0,0)'\n\nexport const TRANSITION_TYPE = {\n  ZOOM: 'ZOOM',\n}\n\nexport const ENCOUNTERS = 'Encounters'\n\nexport const BRUSH_RENDERING_STYLE = {\n  NORMAL: 0,\n  BULLSEYE: 2,\n}\n\nexport const BRUSH_ZOOM_RENDERING_STYLE = {\n  RADIAL_GRADIENT: 0,\n  CIRCLE: 1,\n}\n\nexport const POLYGON_LAYERS_AREA = 'POLYGON_LAYERS_AREA'\n\nexport const CUSTOM_LAYERS_SUBTYPES = {\n  geojson: 'geojson',\n  raster: 'raster',\n}\n","import Pbf from 'pbf'\nimport { VectorTile } from '@mapbox/vector-tile'\n\nexport default (tileUrl, token) => {\n  const vectorTilePromise = fetch(tileUrl, {\n    headers: token\n      ? {\n          Authorization: `Bearer ${token}`,\n        }\n      : {},\n  })\n    .then((response) => {\n      if (!response.ok) {\n        throw new Error(`could not load tile ${tileUrl}`)\n      }\n      return response.blob().then((blob) => {\n        const reader = new FileReader()\n        return new Promise((resolve) => {\n          reader.addEventListener('loadend', () => {\n            // reader.result contains the contents of blob as a typed array\n            // blob.type === 'application/x-protobuf'\n            const pbf = new Pbf(reader.result)\n            const vectorTile = new VectorTile(pbf)\n            return resolve(vectorTile)\n          })\n          reader.readAsArrayBuffer(blob)\n        })\n      })\n    })\n    .catch((e) => {\n      console.warn(e)\n    })\n  return vectorTilePromise\n}\n","import pull from 'lodash/pull'\nimport uniq from 'lodash/uniq'\nimport sumBy from 'lodash/sumBy'\nimport { lngLatToWorld } from 'viewport-mercator-project'\nimport convert from '@globalfishingwatch/map-convert'\nimport buildEndpoint from './buildEndpoint'\nimport PelagosClient from '../lib/pelagosClient'\n\nimport getPBFTile from './getPBFTile'\n\n/**\n * Generates the URLs to load vessel track data for a tile\n *\n * @param {string} tilesetUrl       the tileset base URL\n * @param {array} temporalExtents   all tileset temporal extents\n * @param {object} params           - seriesgroup: a seriesgroup id, used for tracks loading\n *                                  - tileCoordinates: this tiles tile coordinates (zoom, x, y). Will default to 0,0,0\n *                                  - temporalExtentsIndices: restrict to these temporalExtents indices\n * @returns {Array}                 an array of URLs for this tile\n */\nconst getTemporalTileURLs = (urlTemplate, temporalExtents, params) => {\n  const urls = []\n\n  ;(temporalExtents || [null]).forEach((extent, index) => {\n    const urlParams = {\n      id: params.seriesgroup,\n    }\n    if (extent !== null && params.temporalExtentsLess !== true) {\n      urlParams.startTimeISO = new Date(extent[0]).toISOString()\n      urlParams.endTimeISO = new Date(extent[1]).toISOString()\n    }\n    if (params.tileCoordinates) {\n      urlParams.x = params.tileCoordinates.x\n      urlParams.y = params.tileCoordinates.y\n      urlParams.z = params.tileCoordinates.zoom\n    }\n\n    const url = buildEndpoint(urlTemplate, urlParams)\n\n    if (\n      params.temporalExtentsLess === true ||\n      !params.temporalExtentsIndices ||\n      params.temporalExtentsIndices.indexOf(index) > -1\n    ) {\n      urls.push(url)\n    }\n  })\n  return urls\n}\n\n/**\n * See getTemporalTileURLs.\n */\nexport const getTilePromises = (tilesetUrl, token, temporalExtents, params) => {\n  const promises = []\n  const urls = getTemporalTileURLs(tilesetUrl, temporalExtents, params)\n  for (let urlIndex = 0, length = urls.length; urlIndex < length; urlIndex++) {\n    if (params.isPBF === true) {\n      promises.push(getPBFTile(urls[urlIndex], token))\n    } else {\n      promises.push(new PelagosClient().obtainTile(urls[urlIndex], token))\n    }\n  }\n\n  return promises\n}\n\nexport const getCleanVectorArrays = (rawTileData) =>\n  rawTileData.filter((vectorArray) => vectorArray !== null)\n\n/**\n * As data will come in multiple arrays (1 per API query/year basically), they need to be merged here\n *\n * @param cleanVectorArrays an array of objects containing a Float32Array for each vessel param (lat, lon, weight...)\n * @param columns the keys to pick on the vectorArrays (lat, lon, weight, etc)\n * @returns an object containing a Float32Array for each API_RETURNED_KEY (lat, lon, weight, etc)\n */\nexport const groupData = (cleanVectorArrays, columns) => {\n  const data = {}\n\n  const totalVectorArraysLength = sumBy(cleanVectorArrays, (a) => a.longitude.length)\n\n  const filteredColumns = columns.filter((column) => {\n    if (cleanVectorArrays[0] && cleanVectorArrays[0][column] === undefined) {\n      console.warn(`column ${column} is present in layerHeader.colsByName but not in tile data`)\n      return false\n    }\n    return true\n  })\n\n  filteredColumns.forEach((key) => {\n    data[key] = new Float32Array(totalVectorArraysLength)\n  })\n\n  let currentArray\n  let cumulatedOffsets = 0\n\n  const appendValues = (key) => {\n    data[key].set(currentArray[key], cumulatedOffsets)\n  }\n\n  for (let index = 0, length = cleanVectorArrays.length; index < length; index++) {\n    currentArray = cleanVectorArrays[index]\n    filteredColumns.forEach(appendValues)\n    cumulatedOffsets += currentArray.longitude.length\n  }\n  return data\n}\n\n/**\n * Converts Vector Array data to Playback format and stores it locally.\n * The data structure is an array indexed by a time unit, ie a set of points every day\n * This preprocessing step allows playback to play smoothly as the necessary conversions and data structure set up\n * is done once (after tile has been loaded)\n *\n * @param data the source data before indexing by day, an object containing\n *  - a vector (Float32Array) for each header's column in the case of Pelagos tiles\n *  - an array of points int the case of PBF tiles\n * @param colsByName the columns present on the dataset, determined by tileset headers\n * @param tileCoordinates x, y, z\n * @param isPBF bool whether data is a PBF vector tile (true) or a Pelagos tile (false)\n * @param prevPlaybackData an optional previously loaded tilePlaybackData array (when adding time range)\n */\nexport const getTilePlaybackData = (data, colsByName, tileCoordinates, isPBF, prevPlaybackData) => {\n  const tilePlaybackData = prevPlaybackData === undefined ? [] : prevPlaybackData\n\n  const zoom = tileCoordinates.zoom\n  const zoomFactorRadius = convert.getZoomFactorRadius(zoom)\n  const zoomFactorRadiusRenderingMode = convert.getZoomFactorRadiusRenderingMode(zoom)\n  const zoomFactorOpacity = convert.getZoomFactorOpacity(zoom)\n\n  // store all available columns as object keys\n  const columns = {}\n  const columnsArr = Object.keys(colsByName)\n  columnsArr.forEach((c) => {\n    columns[c] = true\n  })\n\n  // columns specified by layer header columns\n  let storedColumns = [].concat(columnsArr)\n  if (columns.sigma === true) storedColumns.push('radius')\n  if (columns.weight === true) storedColumns.push('opacity')\n  if (columns.longitude === true) {\n    storedColumns.push('worldX')\n    storedColumns.push('worldY')\n  }\n  if (columns.id === true) {\n    storedColumns.push('series')\n  }\n\n  // omit values that will be transformed before being stored to playback data (ie lat -> worldY)\n  // only if hidden: true flag is set on header\n  ;['latitude', 'longitude', 'datetime'].forEach((col) => {\n    if (colsByName[col] === undefined || colsByName[col].hidden === true) {\n      pull(storedColumns, col)\n    }\n  })\n  // always pull sigma and weight\n  pull(storedColumns, 'sigma', 'weight')\n  storedColumns = uniq(storedColumns)\n\n  const numPoints = isPBF === true ? data.length : data.latitude.length\n\n  for (let index = 0, length = numPoints; index < length; index++) {\n    let point\n    if (isPBF === true) {\n      const feature = data.feature(index)\n      point = feature.properties\n      // WARNING: toGeoJSON is expensive. Avoid using raw coordinates in PBF tiles, pregenerate world coords\n      // FIXME: this should not be done when headers declare worldX/Y -  if (!columns.worldX) {\n      const geom = feature.toGeoJSON(tileCoordinates.x, tileCoordinates.y, zoom).geometry\n        .coordinates\n      point.longitude = geom[0]\n      point.latitude = geom[1]\n    } else {\n      point = {}\n      columnsArr.forEach((c) => {\n        point[c] = data[c][index]\n      })\n    }\n\n    const timeIndex = columns.timeIndex\n      ? point.timeIndex\n      : convert.getOffsetedTimeAtPrecision(point.datetime)\n\n    // FIXME: this should not be done when headers declare worldX/Y -  if (!columns.worldX) {\n    const [worldX, worldY] = lngLatToWorld([point.longitude, point.latitude], 1)\n    point.worldX = worldX\n    point.worldY = worldY\n\n    if (columns.sigma) {\n      point.radius = convert.sigmaToRadius(\n        point.sigma,\n        zoomFactorRadiusRenderingMode,\n        zoomFactorRadius\n      )\n    }\n    if (columns.weight) {\n      point.opacity = convert.weightToOpacity(point.weight, zoomFactorOpacity)\n    }\n    if (columns.id) {\n      point.series = point.id\n    }\n\n    if (!tilePlaybackData[timeIndex]) {\n      const frame = {}\n      storedColumns.forEach((column) => {\n        frame[column] = [point[column]]\n      })\n      tilePlaybackData[timeIndex] = frame\n      continue\n    }\n    const frame = tilePlaybackData[timeIndex]\n    storedColumns.forEach((column) => {\n      frame[column].push(point[column])\n    })\n  }\n  return tilePlaybackData\n}\n\nexport const addTracksPointsRenderingData = (data) => {\n  data.hasFishing = []\n  data.worldX = []\n  data.worldY = []\n\n  for (let index = 0, length = data.weight.length; index < length; index++) {\n    const [worldX, worldY] = lngLatToWorld([data.longitude[index], data.latitude[index]], 1)\n    data.worldX[index] = worldX\n    data.worldY[index] = worldY\n    data.hasFishing[index] = data.weight[index] > 0\n  }\n  return data\n}\n\n/**\n * A simplified version of getTilePlaybackData for tracks\n * Converts Vector Array data to Playback format (organized by days) and stores it locally\n * @param vectorArray the source data before indexing by day\n */\nexport const getTracksPlaybackData = (vectorArray) => {\n  const playbackData = []\n\n  for (let index = 0, length = vectorArray.series.length; index < length; index++) {\n    const datetime = vectorArray.datetime[index]\n    const timeIndex = convert.getOffsetedTimeAtPrecision(datetime)\n\n    if (!playbackData[timeIndex]) {\n      const frame = {\n        worldX: [vectorArray.worldX[index]],\n        worldY: [vectorArray.worldY[index]],\n        series: [vectorArray.series[index]],\n        hasFishing: [vectorArray.hasFishing[index]],\n      }\n      playbackData[timeIndex] = frame\n      continue\n    }\n    const frame = playbackData[timeIndex]\n    frame.worldX.push(vectorArray.worldX[index])\n    frame.worldY.push(vectorArray.worldY[index])\n    frame.series.push(vectorArray.series[index])\n    frame.hasFishing.push(vectorArray.hasFishing[index])\n  }\n  return playbackData\n}\n\nexport const vesselSatisfiesFilters = (frame, index, filterValues) => {\n  const satisfiesFilters = Object.keys(filterValues).every((field) => {\n    if (frame[field] === undefined) {\n      // this field is not available on this layer. This can happen in an edge case described\n      // here: https://github.com/GlobalFishingWatch/map-client/issues/661#issuecomment-334496469\n      return false\n    }\n    return filterValues[field].indexOf(frame[field][index]) > -1\n  })\n  return satisfiesFilters\n}\n\nconst vesselSatisfiesAllFilters = (frame, index, filters) => {\n  const satisfiesAllFilters = filters\n    .filter((f) => f.pass !== true)\n    .some((filter) => vesselSatisfiesFilters(frame, index, filter.filterValues))\n  return satisfiesAllFilters\n}\n\nexport const selectVesselsAt = (tileData, tileQuery, startIndex, endIndex, currentFilters) => {\n  const vessels = []\n\n  const { worldX, worldY, toleranceRadiusInWorldUnits } = tileQuery\n\n  for (let f = startIndex; f < endIndex; f++) {\n    const frame = tileData[f]\n    if (frame === undefined) continue\n    for (let i = 0; i < frame.worldX.length; i++) {\n      const wx = frame.worldX[i]\n      const wy = frame.worldY[i]\n\n      if (\n        (!currentFilters.length || vesselSatisfiesAllFilters(frame, i, currentFilters)) &&\n        wx >= worldX - toleranceRadiusInWorldUnits &&\n        wx <= worldX + toleranceRadiusInWorldUnits &&\n        wy >= worldY - toleranceRadiusInWorldUnits &&\n        wy <= worldY + toleranceRadiusInWorldUnits\n      ) {\n        const vessel = {}\n\n        Object.keys(frame).forEach((key) => {\n          vessel[key] = frame[key][i]\n        })\n        vessels.push(vessel)\n      }\n    }\n  }\n  return vessels\n}\n\n/*\nexport const getHistogram = (tiles, propName = 'weight') => {\n  let data = tiles\n    .filter(tile => tile.ready)\n    .map(tile => tile.data\n      .map(frame => frame[propName]));\n  data = flattenDeep(data);\n  if (data.length) {\n    const bins = d3.histogram().thresholds(d3.thresholdScott)(data);\n    const x = d3.scaleLinear().domain([0, d3.max(bins, d => d.length)]).range([0, 50]);\n    console.table(bins.filter(bin => bin.length).map((bin) => {\n      const binMin = d3.min(bin).toLocaleString({ maximumFractionDigits: 2 });\n      const binMax = d3.max(bin).toLocaleString({ maximumFractionDigits: 2 });\n      return {\n        range: [binMin, binMax].join(''),\n        bars: Array(Math.round(x(bin.length))).join(''),\n        num: bin.length\n      };\n    }));\n  }\n};\n*/\n","import template from 'lodash/template'\nimport templateSettings from 'lodash/templateSettings'\n\nexport default (urlTemplate, urlParams) => {\n  templateSettings.interpolate = /{{([\\s\\S]+?)}}/g\n  const urlTemplateCompiled = template(urlTemplate)\n  return urlTemplateCompiled(urlParams)\n}\n","import tilecover from '@mapbox/tile-cover/index'\nimport debounce from 'lodash/debounce'\nimport { PerspectiveMercatorViewport } from 'viewport-mercator-project'\nimport { ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING, TILES_LOAD_ZOOM_OFFSET } from '../config'\nimport {\n  getTile,\n  releaseTiles,\n  highlightVesselFromHeatmap,\n  updateLoadedTiles,\n} from './heatmap.actions'\n\nexport const SET_CURRENTLY_VISIBLE_TILES = 'SET_CURRENTLY_VISIBLE_TILES'\nexport const SET_CURRENTLY_LOADED_TILES = 'SET_CURRENTLY_LOADED_TILES'\nexport const SET_CURRENTLY_SWAPPED_TILE_UIDS = 'SET_CURRENTLY_SWAPPED_TILE_UIDS'\nexport const MARK_TILES_UIDS_AS_LOADED = 'MARK_TILES_UIDS_AS_LOADED'\nexport const RELEASE_MARKED_TILES_UIDS = 'RELEASE_MARKED_TILES_UIDS'\n\n// restrict tilecover to a single zoom level\n// could be customized to load less or more detailed tiles\nconst getTilecoverLimits = (viewportZoom) => {\n  let zoom = Math.ceil(viewportZoom + TILES_LOAD_ZOOM_OFFSET)\n  let tilesAvailable = true\n  if (zoom > ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING) {\n    zoom = ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING\n    tilesAvailable = false\n  }\n  return {\n    min_zoom: zoom,\n    max_zoom: zoom,\n    tilesAvailable,\n  }\n}\n\nconst flushToReleaseTiles = () => (dispatch, getState) => {\n  const state = getState()\n  const currentToLoadTileUids = state.map.heatmapTiles.currentToLoadTileUids\n  // console.log('Tiles left to load: ', currentToLoadTileUids);\n\n  // Tiles are released only when all to-load tiles have finished loading\n  // this is to ensure smooth visual transitions between zoom levels\n  if (!currentToLoadTileUids.length) {\n    const currentTilesToReleaseUids = state.map.heatmapTiles.currentToReleaseTileUids\n    // console.log('no more tiles to load, releasing ', currentTilesToReleaseUids);\n    dispatch(releaseTiles(currentTilesToReleaseUids))\n    dispatch({\n      type: RELEASE_MARKED_TILES_UIDS,\n    })\n  }\n}\n\nexport const markTileAsLoaded = (tileUids) => (dispatch) => {\n  dispatch({\n    type: MARK_TILES_UIDS_AS_LOADED,\n    payload: tileUids,\n  })\n  // console.log(tileUids, 'have finished loading');\n  dispatch(flushToReleaseTiles())\n}\n\nconst flushTileState = (forceLoadingAllVisibleTiles = false) => (dispatch, getState) => {\n  const state = getState()\n  const currentVisibleTiles = state.map.heatmapTiles.currentVisibleTiles\n  let tilesToLoad = []\n  const tilesToReleaseUids = []\n\n  if (forceLoadingAllVisibleTiles === true) {\n    tilesToLoad = currentVisibleTiles\n  } else {\n    const currentLoadedTiles = state.map.heatmapTiles.currentLoadedTiles\n\n    currentVisibleTiles.forEach((visibleTile) => {\n      if (currentLoadedTiles.find((t) => t.uid === visibleTile.uid) === undefined) {\n        tilesToLoad.push(visibleTile)\n      }\n    })\n\n    currentLoadedTiles.forEach((loadedTile) => {\n      if (currentVisibleTiles.find((t) => t.uid === loadedTile.uid) === undefined) {\n        tilesToReleaseUids.push(loadedTile.uid)\n      }\n    })\n  }\n\n  const tilesToLoadUids = tilesToLoad.map((t) => t.uid)\n  // console.log('force loading:', forceLoadingAllVisibleTiles)\n  // console.log('visible', currentVisibleTiles.map(t => t.uid))\n  // console.log('load', tilesToLoadUids)\n  // console.log('release', tilesToReleaseUids)\n  // console.log('----')\n\n  tilesToLoad.forEach((tile) => {\n    dispatch(getTile(tile))\n  })\n  dispatch({\n    type: SET_CURRENTLY_LOADED_TILES,\n    payload: currentVisibleTiles,\n  })\n\n  dispatch({\n    type: SET_CURRENTLY_SWAPPED_TILE_UIDS,\n    payload: {\n      tilesToLoadUids,\n      tilesToReleaseUids,\n    },\n  })\n\n  dispatch(updateLoadedTiles())\n  dispatch(flushToReleaseTiles())\n}\n\nconst _debouncedFlushState = (dispatch) => {\n  dispatch(flushTileState())\n}\nconst debouncedFlushState = debounce(_debouncedFlushState, 500)\n\nexport const updateHeatmapTilesFromViewport = (forceLoadingAllVisibleTiles = false) => (\n  dispatch,\n  getState\n) => {\n  // if in transition, skip loading/releasing\n  // else\n  //   collect all tiles in viewport\n  //   save them to reducer: currentVisibleTiles\n  // if not zooming: flush immediately\n  //   if forceLoadingAllVisiblelTiles\n  //     get tiles from currentVisibleTiles\n  //   else\n  //     get tiles from currentVisibleTiles\n  //     make delta with currentLoadedTiles\n  //     get tiles from delta+\n  //     release tiles from delta-\n  //   save to reducer: currentVisibleTiles -> currentLoadedTiles\n  // if zooming: debounced flush to avoid \"tile spam\"\n  const mapViewport = getState().map.viewport\n  const viewport = mapViewport.viewport\n\n  // do not allow any tile update during transitions (currently only zoom)\n  // wait for the end of the transition to look at viewport and load matching tiles\n  if (mapViewport.currentTransition !== null) {\n    return\n  }\n\n  // instanciate a viewport instance to get lat/lon from screen top left/ bottom right bounds\n  const boundsViewport = new PerspectiveMercatorViewport(viewport)\n  const bounds = [\n    boundsViewport.unproject([0, 0]),\n    boundsViewport.unproject([viewport.width, viewport.height]),\n  ]\n\n  const [wn, es] = bounds\n  const [w, s, e, n] = [wn[0], es[1], es[0], wn[1]]\n  const boundsPolygonsCoordinates = []\n\n  const limits = getTilecoverLimits(viewport.zoom)\n  if (limits.tilesAvailable === false && forceLoadingAllVisibleTiles !== true) {\n    return\n  }\n\n  if (e > 180 || w < -180) {\n    // deal with the antimeridian situation by splitting the bounds polygon into two polygons\n    const w1 = e > 180 ? w : w + 360\n    const e1 = 180 - 0.001\n    const w2 = -180\n    const e2 = e > 180 ? e - 360 : e\n    boundsPolygonsCoordinates.push([[[w1, n], [e1, n], [e1, s], [w1, s], [w1, n]]])\n    boundsPolygonsCoordinates.push([[[w2, n], [e2, n], [e2, s], [w2, s], [w2, n]]])\n  } else {\n    boundsPolygonsCoordinates.push([[[w, n], [e, n], [e, s], [w, s], [w, n]]])\n  }\n\n  const geom = {\n    type: 'MultiPolygon',\n    coordinates: boundsPolygonsCoordinates,\n  }\n\n  // using tilecover, get xyz tile coords as well as quadkey indexes (named uid through the app)\n  const viewportTilesCoords = tilecover.tiles(geom, limits)\n  const viewportTilesIndexes = tilecover.indexes(geom, limits)\n  const visibleTiles = []\n\n  viewportTilesCoords.forEach((coords, i) => {\n    const uid = viewportTilesIndexes[i]\n    const zoom = coords[2]\n    if (zoom >= 2) {\n      visibleTiles.push({\n        tileCoordinates: {\n          x: coords[0],\n          y: coords[1],\n          zoom: coords[2],\n        },\n        uid,\n      })\n    }\n  })\n\n  dispatch({\n    type: SET_CURRENTLY_VISIBLE_TILES,\n    payload: visibleTiles,\n  })\n\n  const isMouseWheelZooming = mapViewport.prevZoom !== viewport.zoom\n\n  if (isMouseWheelZooming === false) {\n    dispatch(flushTileState(forceLoadingAllVisibleTiles))\n  } else {\n    debouncedFlushState(dispatch)\n  }\n}\n\nexport const queryHeatmapVessels = (coords, temporalExtentIndexes) => (dispatch, getState) => {\n  // use tilecover to get what tile quadkey/uid \"belongs\" to the point\n  const geom = {\n    type: 'Point',\n    coordinates: [coords.longitude, coords.latitude],\n  }\n  const zoom = getState().map.viewport.viewport.zoom\n\n  // get quadkey for tile at current zoom level, but also neighbouring zoom levels,\n  // in case current zoom level tiles has not been loaded yet\n  const uids = [zoom, zoom - 1, zoom + 1]\n    .map((z) => getTilecoverLimits(z))\n    .map((limits) => tilecover.indexes(geom, limits))\n    .map((indexes) => indexes[0])\n\n  const query = {\n    ...coords,\n    uids,\n  }\n\n  // console.log(query);\n  dispatch(highlightVesselFromHeatmap(query, temporalExtentIndexes))\n}\n","import difference from 'lodash/difference'\nimport uniq from 'lodash/uniq'\nimport uniqBy from 'lodash/uniqBy'\nimport {\n  getTilePromises,\n  getCleanVectorArrays,\n  groupData,\n  getTilePlaybackData,\n  selectVesselsAt,\n} from '../utils/heatmapTileData'\nimport { ENCOUNTERS } from '../constants'\nimport { markTileAsLoaded } from './heatmapTiles.actions'\nimport { startLoader, completeLoader } from '../module/module.actions'\n\nexport const ADD_HEATMAP_LAYER = 'ADD_HEATMAP_LAYER'\nexport const UPDATE_HEATMAP_LAYER_STYLE = 'UPDATE_HEATMAP_LAYER_STYLE'\nexport const ADD_REFERENCE_TILE = 'ADD_REFERENCE_TILE'\nexport const HIGHLIGHT_VESSELS = 'HIGHLIGHT_VESSELS'\nexport const INIT_HEATMAP_LAYERS = 'INIT_HEATMAP_LAYERS'\nexport const REMOVE_HEATMAP_LAYER = 'REMOVE_HEATMAP_LAYER'\nexport const UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES =\n  'UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES'\nexport const UPDATE_HEATMAP_TILE = 'UPDATE_HEATMAP_TILE'\nexport const RELEASE_HEATMAP_TILES = 'RELEASE_HEATMAP_TILES'\nexport const UPDATE_LOADED_TILES = 'UPDATE_LOADED_TILES'\nexport const HIGHLIGHT_CLICKED_VESSEL = 'HIGHLIGHT_CLICKED_VESSEL'\nexport const CLEAR_HIGHLIGHT_CLICKED_VESSEL = 'CLEAR_HIGHLIGHT_CLICKED_VESSEL'\n\n/**\n * getTemporalExtentsVisibleIndices - Compares timebar outer extent with temporal extents present on the layer header\n * @param  {array} loadTemporalExtent Current timebar outer extent\n * @param  {array} layerTemporalExtents Temporal extent present on the layer's header (an array of extent arrays)\n * @return {array}                    Indices of the layer's temporal extents that should be visible\n */\nfunction getTemporalExtentsVisibleIndices(loadTemporalExtent, layerTemporalExtents) {\n  const currentExtentStart = loadTemporalExtent[0].getTime()\n  const currentExtentEnd = loadTemporalExtent[1].getTime()\n  const indices = []\n  layerTemporalExtents.forEach((temporalExtent, index) => {\n    const temporalExtentStart = temporalExtent[0]\n    const temporalExtentEnd = temporalExtent[1]\n    if (temporalExtentEnd >= currentExtentStart && temporalExtentStart <= currentExtentEnd) {\n      indices.push(index)\n    }\n  })\n  return indices\n}\n\n/**\n * loadLayerTile - loads an heatmap tile.\n *\n * @param  {string} layerId              layer id\n * @param  {object} tileCoordinates      tile coordinates from reference tile\n * @param  {string} token                the user's token\n * @param  {array} temporalExtentsIndices which of the temporal extents from  temporalExtents should be loaded\n * @param  {string} urls                 tile endpoints provided by header\n * @param  {array} temporalExtents       all of the layer's header temporal extents\n * @param  {bool} temporalExtentsLess    true = don't try to load different tiles based on current time extent\n * @param  {bool} isPBF                  true = read tile as MVT + PBF tile, rather than using Pelagos client\n * @return {Promise}                     a Promise that will be resolved when tile is loaded\n */\nfunction loadLayerTile(\n  layerId,\n  tileCoordinates,\n  token,\n  temporalExtentsIndices,\n  { url, temporalExtents, temporalExtentsLess, isPBF }\n) {\n  // console.log('loadLayerTile', layerId, tileCoordinates, temporalExtentsIndices)\n  if (url === undefined) {\n    throw new Error('URL/endpoints object is not available on this tilesets header')\n  }\n  const pelagosPromises = getTilePromises(url, token, temporalExtents, {\n    tileCoordinates,\n    temporalExtentsIndices,\n    temporalExtentsLess,\n    isPBF,\n  })\n  const allLayerPromises = Promise.all(pelagosPromises)\n\n  const layerTilePromise = new Promise((resolve) => {\n    allLayerPromises.then((rawTileData) => {\n      resolve({\n        loadedLayerId: layerId,\n        rawTileData,\n      })\n    })\n  })\n\n  return layerTilePromise\n}\n\n/**\n * parseLayerTile - parses an heatmap tile to a playback-ready format.\n *\n * @param  {Object} rawTileData          the raw tile data, loaded either from the pelagos client or as a MVT/PBF vector tile\n * @param  {array} colsByName            names of the columns present in the raw tiles that need to be included in the final playback data\n * @param  {object} tileCoordinates      tile coordinates from reference tile\n * @param  {array} prevPlaybackData      (optional) in case some time extent was already loaded for this tile, append to this data\n * @return {Object}                      playback-ready merged data\n */\nfunction parseLayerTile(rawTileData, colsByName, isPBF, tileCoordinates, prevPlaybackData) {\n  let data\n  if (isPBF === true) {\n    if (\n      rawTileData === undefined ||\n      !rawTileData.length ||\n      rawTileData[0] === undefined ||\n      !Object.keys(rawTileData[0].layers).length\n    ) {\n      return []\n    }\n    data = rawTileData[0].layers.points\n  } else {\n    const cleanVectorArrays = getCleanVectorArrays(rawTileData)\n    data = groupData(cleanVectorArrays, Object.keys(colsByName))\n    if (Object.keys(data).length === 0) {\n      return []\n    }\n  }\n  const playbackData = getTilePlaybackData(\n    data,\n    colsByName,\n    tileCoordinates,\n    isPBF,\n    prevPlaybackData\n  )\n  return playbackData\n}\n\n/**\n * getTiles - loads a bunch of heatmap tiles\n * @param  {array} layerIds                 list of layer Ids that need to be loaded for this/these tiles\n * @param  {array} referenceTiles           list of reference tiles (tile data regardless of layer) that need to be loaded\n * @param  {object} newTemporalExtentsToLoad (optional) a dict (layerId is the key) of temporal extents\n * indices that should be appended to existing data\n */\nfunction getTiles(layerIds, referenceTiles, newTemporalExtentsToLoad = undefined) {\n  return (dispatch, getState) => {\n    const state = getState()\n    const loaderID = startLoader(dispatch, state, layerIds.join('-'))\n    const token = state.map.module.token\n    const heatmapLayers = state.map.heatmap.heatmapLayers\n    const tilesByLayer = {}\n    layerIds.forEach((id) => {\n      tilesByLayer[id] = [...heatmapLayers[id].tiles]\n    })\n    const allPromises = []\n\n    layerIds.forEach((layerId) => {\n      const heatmapLayerHeader = heatmapLayers[layerId].header\n      const { temporalExtents, temporalExtentsLess, isPBF, colsByName } = { ...heatmapLayerHeader }\n      const url = heatmapLayerHeader.endpoints.tiles\n\n      referenceTiles.forEach((referenceTile) => {\n        // check if tile does not already exist first\n        let tile = tilesByLayer[layerId].find((t) => t.uid === referenceTile.uid)\n        if (!tile) {\n          // console.log('create tile ', referenceTile.uid)\n          tile = {\n            uid: referenceTile.uid,\n            temporalExtentsIndicesLoaded: [],\n          }\n          tilesByLayer[layerId].push(tile)\n        } else {\n          // console.log('found tile', referenceTile.uid)\n        }\n\n        const queriedTemporalExtentsIndices =\n          newTemporalExtentsToLoad === undefined\n            ? heatmapLayers[layerId].visibleTemporalExtentsIndices\n            : newTemporalExtentsToLoad[layerId]\n\n        const temporalExtentsIndicesToLoad = difference(\n          queriedTemporalExtentsIndices,\n          tile.temporalExtentsIndicesLoaded\n        )\n\n        const tilePromise = loadLayerTile(\n          layerId,\n          referenceTile.tileCoordinates,\n          token,\n          temporalExtentsIndicesToLoad,\n          {\n            url,\n            temporalExtents,\n            temporalExtentsLess,\n            isPBF,\n          }\n        )\n\n        allPromises.push(tilePromise)\n\n        tilePromise.then(({ loadedLayerId, rawTileData }) => {\n          tile.temporalExtentsIndicesLoaded = uniq(\n            tile.temporalExtentsIndicesLoaded.concat(temporalExtentsIndicesToLoad)\n          )\n          tile.data = parseLayerTile(\n            rawTileData,\n            colsByName,\n            isPBF,\n            referenceTile.tileCoordinates,\n            tile.data\n          )\n\n          dispatch({\n            type: UPDATE_HEATMAP_TILE,\n            payload: {\n              layerId: loadedLayerId,\n              tile,\n            },\n          })\n        })\n      })\n    })\n\n    Promise.all(allPromises).then(() => {\n      dispatch(completeLoader(loaderID))\n      dispatch(markTileAsLoaded(referenceTiles.map((tile) => tile.uid)))\n    })\n  }\n}\n\n/**\n * getTile - This action is emitted when a new tile is queried from panning or zooming the map\n * This will load a tile for all currently visible heatmap layers\n *\n * @param  {object} referenceTile a reference tile containing xyz coords and uid\n */\nexport function getTile(referenceTile) {\n  return (dispatch, getState) => {\n    dispatch({\n      type: ADD_REFERENCE_TILE,\n      payload: referenceTile,\n    })\n    const visibleHeatmapLayers = getState().map.heatmap.heatmapLayers\n    const visibleHeatmapLayersIds = Object.keys(visibleHeatmapLayers).filter(\n      (id) => visibleHeatmapLayers[id].visible === true\n    )\n\n    if (visibleHeatmapLayersIds.length) {\n      dispatch(getTiles(visibleHeatmapLayersIds, [referenceTile]))\n    }\n  }\n}\n\n/**\n * releaseTiles - This action is emitted when an existing tile is removed from panning or zooming the map\n * @param  {array} uids tile ref uids to release\n */\nexport const releaseTiles = (uids) => ({\n  type: RELEASE_HEATMAP_TILES,\n  payload: uids,\n})\n\nexport const updateLoadedTiles = () => ({\n  type: UPDATE_LOADED_TILES,\n})\n\n// triggered when a layer is added or set to visible\nfunction loadAllTilesForLayer(layerId) {\n  return (dispatch, getState) => {\n    //                current layer, all reference tiles\n    const referenceTiles = getState().map.heatmap.referenceTiles\n    dispatch(getTiles([layerId], referenceTiles))\n  }\n}\n\nexport const addHeatmapLayer = (layer, loadTemporalExtent) => (dispatch) => {\n  const layerTemporalExtents = layer.header.temporalExtents\n  dispatch({\n    type: ADD_HEATMAP_LAYER,\n    payload: {\n      ...layer,\n      // initially attach which of the temporal extents indices are visible with initial outerExtent\n      visibleTemporalExtentsIndices: getTemporalExtentsVisibleIndices(\n        loadTemporalExtent,\n        layerTemporalExtents\n      ),\n    },\n  })\n\n  if (layer.visible === true) {\n    dispatch(loadAllTilesForLayer(layer.id))\n  }\n}\n\nexport const removeHeatmapLayer = (id) => (dispatch) => {\n  dispatch({\n    type: REMOVE_HEATMAP_LAYER,\n    payload: {\n      id,\n    },\n  })\n}\n\n/**\n * updateLayerLoadTemporalExtents - when outer time extent changes, checks if more tiles needs to be loaded\n * by comparing the outer time range with the temporalExtent already loaded on each layer.\n * @param  {array} loadTemporalExtent Current app-wide extent of tiles that need to load, expressed\n * as an array of two dates\n */\nexport function updateLayerLoadTemporalExtents(loadTemporalExtent) {\n  return (dispatch, getState) => {\n    const state = getState()\n    const heatmapLayers = state.map.heatmap.heatmapLayers\n    const indicesToAddByLayer = {}\n    Object.keys(heatmapLayers).forEach((layerId) => {\n      const heatmapLayer = heatmapLayers[layerId]\n      const temporalExtents = heatmapLayer.header.temporalExtents\n      const oldVisibleTemporalExtentsIndices = heatmapLayer.visibleTemporalExtentsIndices\n      const newVisibleTemporalExtentsIndices = getTemporalExtentsVisibleIndices(\n        loadTemporalExtent,\n        temporalExtents\n      )\n      const indicesAdded = difference(\n        newVisibleTemporalExtentsIndices,\n        oldVisibleTemporalExtentsIndices\n      )\n\n      if (indicesAdded.length) {\n        // add new loaded indices to heatmap layer if applicable\n        indicesToAddByLayer[layerId] = indicesAdded\n        dispatch({\n          type: UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES,\n          payload: {\n            layerId,\n            indicesAdded,\n          },\n        })\n      }\n    })\n\n    // getTiles with indices diff\n    const layerIdsWithIndicesToAdd = Object.keys(indicesToAddByLayer)\n    if (layerIdsWithIndicesToAdd.length) {\n      dispatch(\n        getTiles(layerIdsWithIndicesToAdd, state.map.heatmap.referenceTiles, indicesToAddByLayer)\n      )\n    }\n  }\n}\n\n/**\n * Returns clusters or vessels data from a tileQuery\n * @param {object} state - the application state\n * @param {string} tileQuery - the id of a heatmap layer\n * @return {object} { isEmpty, isCluster, isMouseCluster, foundVessels, layerId, tilesetId }\n */\nconst _queryHeatmap = (state, tileQuery, temporalExtentIndexes) => {\n  const layers = state.map.heatmap.heatmapLayers\n  const startIndex = temporalExtentIndexes[0]\n  const endIndex = temporalExtentIndexes[1]\n  const layersVessels = []\n\n  Object.keys(layers).forEach((layerId) => {\n    const layer = layers[layerId]\n    const allPossibleTilesByPreference = tileQuery.uids.map((uid) =>\n      layer.tiles.find((tile) => tile.uid === uid)\n    )\n    const availableTiles = allPossibleTilesByPreference.filter(\n      (tile) => tile !== undefined && tile.data !== undefined\n    )\n\n    const currentFilters = layer.filters\n    if (availableTiles.length) {\n      const bestTile = availableTiles[0]\n      layersVessels.push({\n        layer,\n        vessels: selectVesselsAt(bestTile.data, tileQuery, startIndex, endIndex, currentFilters),\n      })\n    }\n  })\n\n  const layersVesselsResults = layersVessels.filter(\n    (layerVessels) => layerVessels.vessels.length > 0\n  )\n\n  // it's a cluster because of aggregation on the server side\n  let isCluster\n  // its a cluster because or multiple vessels under mouse\n  let isMouseCluster\n  let isEmpty\n  let layerVesselsResult\n  let foundVessels\n\n  const hasEncounters =\n    layersVesselsResults.filter((layerVessel) => layerVessel.layer.subtype === ENCOUNTERS).length >\n    0\n\n  if (layersVesselsResults.length === 0) {\n    isEmpty = true\n  } else if (layersVesselsResults.length > 1 && !hasEncounters) {\n    // if there are points over multiple layers, consider this a cluster (ie don't select, zoom instead, or don't highlight)\n    // there's an exception if vessel selection contains an encounter, in which case it will take priority\n    isCluster = true\n  } else {\n    // if we have a hit with an encounters layer, use it in priority\n    // if not the layersVesselsResults should contain a single result\n    layerVesselsResult = hasEncounters\n      ? layersVesselsResults.find((layerVessel) => layerVessel.layer.subtype === ENCOUNTERS)\n      : layersVesselsResults[0]\n\n    // we can get multiple points with similar series and seriesgroup, in which case\n    // we should treat that as a successful vessel query, not a cluster\n    const vessels = layerVesselsResult.vessels\n\n    if (vessels.length === 0) {\n      isEmpty = true\n    } else {\n      // look up for any negatives seriesgroup (clusters on the server side)\n      const clusteredVessels = vessels.filter((v) => v.seriesgroup < 0)\n      if (clusteredVessels.length) {\n        isCluster = true\n      } else {\n        foundVessels = uniqBy(vessels, (v) => v.series)\n        isMouseCluster = foundVessels.length > 1\n      }\n    }\n  }\n\n  const layer = layerVesselsResult === undefined ? {} : layerVesselsResult.layer\n\n  return { isEmpty, isCluster, isMouseCluster, foundVessels, layer }\n}\n\nexport function clearHighlightedVessels() {\n  return {\n    type: HIGHLIGHT_VESSELS,\n    payload: {\n      isEmpty: true,\n      clickableCluster: false,\n    },\n  }\n}\n\nexport function highlightVesselFromHeatmap(tileQuery, temporalExtentIndexes) {\n  return (dispatch, getState) => {\n    const state = getState()\n    const { layer, isEmpty, isCluster, isMouseCluster, foundVessels } = _queryHeatmap(\n      state,\n      tileQuery,\n      temporalExtentIndexes\n    )\n\n    if (layer.id !== undefined || state.map.heatmap.highlightedVessels.layerId !== layer.id) {\n      dispatch({\n        type: HIGHLIGHT_VESSELS,\n        payload: {\n          layer: {\n            id: layer.id,\n            tilesetId: layer.tilesetId,\n            subtype: layer.subtype,\n            header: layer.header,\n          },\n          isEmpty,\n          clickableCluster: isCluster === true || isMouseCluster === true,\n          highlightableCluster: isCluster !== true,\n          foundVessels,\n        },\n      })\n    } else {\n      dispatch(clearHighlightedVessels())\n    }\n  }\n}\n\nexport const highlightClickedVessel = (seriesgroup, layerId) => ({\n  type: HIGHLIGHT_CLICKED_VESSEL,\n  payload: {\n    seriesgroup,\n    layerId,\n  },\n})\n\nexport const clearHighlightedClickedVessel = () => ({\n  type: CLEAR_HIGHLIGHT_CLICKED_VESSEL,\n})\n\nexport const updateHeatmapLayers = (newLayers, currentLoadTemporalExtent) => (\n  dispatch,\n  getState\n) => {\n  if (newLayers === null) {\n    console.warn(\"New layers in updateHeatmapLayers can't be null\")\n    return\n  }\n  const prevLayersDict = getState().map.heatmap.heatmapLayers\n\n  // add and update layers\n  newLayers.forEach((newLayer) => {\n    const layerId = newLayer.id\n    const prevLayer = prevLayersDict[layerId]\n    if (prevLayer === undefined) {\n      // console.log('adding', layerId)\n      dispatch(addHeatmapLayer(newLayer, currentLoadTemporalExtent))\n    } else {\n      if (prevLayer.visible !== newLayer.visible && newLayer.visible === true) {\n        dispatch(loadAllTilesForLayer(layerId))\n      }\n      if (\n        prevLayer.visible !== newLayer.visible ||\n        prevLayer.hue !== newLayer.hue ||\n        prevLayer.opacity !== newLayer.opacity ||\n        prevLayer.filters !== newLayer.filters ||\n        prevLayer.interactive !== newLayer.interactive\n      ) {\n        // console.log('updating', layerId, ' with visibilty', newLayer.visible)\n        dispatch({\n          type: UPDATE_HEATMAP_LAYER_STYLE,\n          payload: {\n            id: newLayer.id,\n            visible: newLayer.visible,\n            hue: newLayer.hue,\n            opacity: newLayer.opacity,\n            filters: newLayer.filters,\n            interactive: newLayer.interactive,\n          },\n        })\n      }\n    }\n  })\n\n  // clean up unused layers\n  Object.keys(prevLayersDict).forEach((prevLayerId) => {\n    if (!newLayers.find((l) => l.id === prevLayerId)) {\n      dispatch(removeHeatmapLayer(prevLayerId))\n    }\n  })\n}\n","import { fitBounds, pixelsToWorld } from 'viewport-mercator-project'\nimport { updateHeatmapTilesFromViewport } from '../heatmap/heatmapTiles.actions'\nimport { onViewportChange } from '../module/module.actions'\nimport { CLUSTER_CLICK_ZOOM_INCREMENT } from '../config' // TODO MAP MODULE\n\nexport const SET_VIEWPORT = 'SET_VIEWPORT'\nexport const UPDATE_VIEWPORT = 'UPDATE_VIEWPORT'\nexport const SET_ZOOM_INCREMENT = 'SET_ZOOM_INCREMENT'\nexport const SET_MOUSE_LAT_LONG = 'SET_MOUSE_LAT_LONG'\nexport const TRANSITION_END = 'TRANSITION_END'\nexport const SET_NATIVE_VIEWPORT = 'SET_NATIVE_VIEWPORT'\n\nexport const setViewport = (viewport) => (dispatch) => {\n  dispatch({\n    type: SET_VIEWPORT,\n    payload: viewport,\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  dispatch(onViewportChange())\n}\n\nexport const updateViewport = (viewportUpdate) => (dispatch) => {\n  dispatch({\n    type: UPDATE_VIEWPORT,\n    payload: viewportUpdate,\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  dispatch(onViewportChange())\n}\n\nconst transitionTo = (increment, latitude = null, longitude = null, zoom = null) => (dispatch) => {\n  dispatch({\n    type: SET_ZOOM_INCREMENT,\n    payload: {\n      increment,\n      latitude,\n      longitude,\n      zoom,\n    },\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  dispatch(onViewportChange())\n}\n\nexport const transitionToZoom = (zoom) => (dispatch) => {\n  dispatch(transitionTo(null, null, null, zoom))\n}\n\nexport const transitionEnd = () => (dispatch) => {\n  dispatch({\n    type: TRANSITION_END,\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  dispatch(onViewportChange())\n}\n\nexport const zoomIntoVesselCenter = (latitude, longitude) => (dispatch) => {\n  dispatch(transitionTo(CLUSTER_CLICK_ZOOM_INCREMENT, latitude, longitude))\n}\n\nexport const fitToBounds = (bounds) => (dispatch, getState) => {\n  const state = getState()\n  const vp = fitBounds({\n    bounds: [[bounds.minLng, bounds.minLat], [bounds.maxLng, bounds.maxLat]],\n    width: state.map.viewport.viewport.width,\n    height: state.map.viewport.viewport.height,\n    padding: 50,\n  })\n  dispatch(transitionTo(null, vp.latitude, vp.longitude, vp.zoom))\n}\n\nexport const exportNativeViewport = (nativeViewport) => (dispatch) => {\n  const topLeftPx = [0, 0]\n  const bottomRightPx = [nativeViewport.width, nativeViewport.height]\n\n  // compute left and right offsets to deal with antimeridian issue\n  const topLeftWorld = pixelsToWorld(topLeftPx, nativeViewport.pixelUnprojectionMatrix)\n  const bottomRightWorld = pixelsToWorld(bottomRightPx, nativeViewport.pixelUnprojectionMatrix)\n  const leftWorldScaled = topLeftWorld[0] / nativeViewport.scale\n  const rightWorldScaled = bottomRightWorld[0] / nativeViewport.scale\n\n  // lat/lon corners for miniglobe\n  const northWest = nativeViewport.unproject(topLeftPx)\n  const southEast = nativeViewport.unproject(bottomRightPx)\n  const bounds = {\n    north: northWest[1],\n    south: southEast[1],\n    west: northWest[0],\n    east: southEast[0],\n  }\n\n  dispatch({\n    type: SET_NATIVE_VIEWPORT,\n    payload: {\n      leftWorldScaled,\n      rightWorldScaled,\n      bounds,\n    },\n  })\n}\n","import area from '@turf/area'\nimport { POLYGON_LAYERS_AREA } from '../constants'\nimport { clearHighlightedVessels, clearHighlightedClickedVessel } from '../heatmap/heatmap.actions'\nimport { zoomIntoVesselCenter } from './viewport.actions'\n\nexport const SET_POPUP = 'SET_POPUP'\nexport const CLEAR_POPUP = 'CLEAR_POPUP'\nexport const SET_MAP_CURSOR = 'SET_MAP_CURSOR'\nexport const UPDATE_POPUP_REPORT_STATUS = 'UPDATE_POPUP_REPORT_STATUS'\n\nconst getFeatureMetaFields = (staticLayerId, state, feature) => {\n  const source = state.style.mapStyle.toJS().sources[staticLayerId]\n  if (source === undefined) {\n    console.warn('Couldnt find source when looking for fields of layer', staticLayerId)\n  }\n  if (source.type !== 'geojson') {\n    if (source.metadata === undefined || source.metadata['gfw:popups'] === undefined) {\n      return null\n    }\n    return source.metadata['gfw:popups']\n  }\n  // when layer is of type geojson (custom layer), use all feature properties available\n  return Object.keys(feature.properties).length === 0\n    ? null\n    : Object.keys(feature.properties).map((key) => ({ id: key }))\n}\n\nconst getAreaKm2 = (glFeature) => {\n  const areakm2 = 10 ** -6 * area(glFeature.geometry)\n  const formatted = areakm2.toLocaleString('en-US', { maximumFractionDigits: 0 })\n  return formatted\n}\n\nconst getStaticLayerIdFromGlFeature = (glFeature) =>\n  (glFeature.layer.metadata !== undefined && glFeature.layer.metadata['gfw:id']) ||\n  glFeature.layer.source\n\nconst findFeature = (glFeatures) => {\n  if (glFeatures === undefined || !glFeatures.length) {\n    return undefined\n  }\n  for (let i = 0; i < glFeatures.length; i++) {\n    const glFeature = glFeatures[i]\n    const staticLayerId = getStaticLayerIdFromGlFeature(glFeature)\n    if (staticLayerId !== undefined) {\n      return {\n        feature: glFeature,\n        staticLayerId,\n      }\n    }\n  }\n  return undefined\n}\n\nexport const mapHover = (latitude, longitude, features, cluster) => (dispatch, getState) => {\n  const state = getState().map\n  const currentActivityLayersInteractionData = state.heatmap.highlightedVessels\n  const { layer, isEmpty, foundVessels } = currentActivityLayersInteractionData\n\n  let cursor = null\n  const event = {\n    type: null,\n  }\n\n  if (isEmpty === true) {\n    const feature = findFeature(features, null)\n    if (feature !== undefined) {\n      const popupFields = getFeatureMetaFields(feature.staticLayerId, state, feature.feature)\n      if (popupFields !== null) {\n        const properties = feature.feature.properties\n        const mainPopupField =\n          popupFields.find((f) => f.id && f.id.toLowerCase() === 'name') ||\n          popupFields.find((f) => f.id && f.id.toLowerCase() === 'id') ||\n          popupFields.find(\n            (f) =>\n              f.id &&\n              properties[f.id] !== null &&\n              properties[f.id] !== 'null' &&\n              properties[f.id] !== undefined\n          )\n        const mainPopupFieldId = mainPopupField.id\n        const featureTitle = properties[mainPopupFieldId]\n        event.type = 'static'\n        event.cluster = cluster\n        event.layer = {\n          id: feature.staticLayerId,\n        }\n        event.target = {\n          featureTitle,\n          properties,\n        }\n        cursor = 'pointer'\n      }\n    }\n  } else if (isEmpty !== true) {\n    const isCluster = foundVessels === undefined || foundVessels.length > 1\n    cursor = isCluster ? 'zoom-in' : 'pointer'\n\n    event.type = 'activity'\n    // TODO MAP MODULE sometimes layerId is undefined, likely an issue with heatmap[Tiles]\n    event.layer = layer\n    event.target = {\n      objects: foundVessels,\n      isCluster,\n    }\n  }\n\n  if (cursor !== state.interaction.cursor) {\n    dispatch({\n      type: SET_MAP_CURSOR,\n      payload: cursor,\n    })\n  }\n\n  if (state.module.onHover) {\n    state.module.onHover({\n      ...event,\n      latitude,\n      longitude,\n    })\n  }\n}\n\nexport const mapClick = (latitude, longitude, features, cluster) => (dispatch, getState) => {\n  const state = getState().map\n\n  dispatch(clearHighlightedClickedVessel())\n\n  const currentActivityLayersInteractionData = state.heatmap.highlightedVessels\n\n  const { layer, isEmpty, clickableCluster, foundVessels } = currentActivityLayersInteractionData\n\n  const event = {\n    type: null,\n  }\n\n  if (isEmpty === true) {\n    const feature = findFeature(features, null)\n    if (feature !== undefined) {\n      const metaFields = getFeatureMetaFields(feature.staticLayerId, state, feature.feature)\n      let fields\n      const properties = feature.feature.properties\n\n      if (metaFields !== null) {\n        fields = metaFields.map((metaField) => {\n          const id = metaField.id || metaField\n          const value = id === POLYGON_LAYERS_AREA ? getAreaKm2(feature.feature) : properties[id]\n          return {\n            title: metaField.label || metaField.id,\n            isLink: metaField.isLink,\n            value,\n          }\n        })\n      }\n\n      event.type = 'static'\n      event.cluster = cluster\n      event.layer = {\n        id: feature.staticLayerId,\n      }\n      event.target = {\n        fields,\n        properties,\n      }\n    }\n  } else {\n    event.type = 'activity'\n    event.layer = layer\n    if (clickableCluster === true) {\n      dispatch(zoomIntoVesselCenter(latitude, longitude))\n      dispatch(clearHighlightedVessels())\n      event.target = {\n        isCluster: true,\n      }\n    } else {\n      event.target = foundVessels[0]\n    }\n  }\n\n  if (state.module.onClick) {\n    state.module.onClick({\n      ...event,\n      latitude,\n      longitude,\n    })\n  }\n}\n","const RGB_MAX = 255\nconst HUE_MAX = 360\nconst SV_MAX = 100\n\nexport const VESSELS_HUES_INCREMENTS_NUM = 31 // 360 / VESSELS_HUES_INCREMENTS_NUM - 1  should give a round number\nexport const VESSELS_HUES_INCREMENT = 360 / (VESSELS_HUES_INCREMENTS_NUM - 1)\n\n// Legacy: this is only here for compatibility with pre-mapbox branch workspaces\nexport const COLOR_HUES = {\n  orange: 0,\n  peach: 22,\n  yellow: 60,\n  green: 85,\n  brightGreen: 145,\n  lightBlue: 182,\n  blue: 236,\n  purple: 284,\n  pink: 312,\n}\n\n// FIXME mark explicitely as legacy. Check all usages.\nexport const getKeyByValue = (obj, value) => {\n  let result = null\n  Object.entries(obj).forEach((entry) => {\n    if (entry[1] === value) result = entry[0]\n  })\n  return result\n}\n\n/**\n * Converts an RGB color value to HSV. Conversion formula\n * adapted from http://en.wikipedia.org/wiki/HSV_color_space.\n * Assumes r, g, and b are contained in the set [0, 255] and\n * returns h, s, and v in the set [0, 1].\n *\n * @param   Number  r       The red color value\n * @param   Number  g       The green color value\n * @param   Number  b       The blue color value\n * @return  Array           The HSV representation\n */\nexport const rgbToHsv = (_r, _g, _b) => {\n  const r = _r / 255\n  const g = _g / 255\n  const b = _b / 255\n\n  const max = Math.max(r, g, b)\n  const min = Math.min(r, g, b)\n  let h\n  const v = max\n\n  const d = max - min\n  const s = max === 0 ? 0 : d / max\n\n  if (max === min) {\n    h = 0 // achromatic\n  } else {\n    switch (max) {\n      case r:\n        h = (g - b) / d + (g < b ? 6 : 0)\n        break\n      case g:\n        h = (b - r) / d + 2\n        break\n      case b:\n        h = (r - g) / d + 4\n        break\n      default:\n        h = 0\n    }\n\n    h /= 6\n  }\n\n  return [h, s, v]\n}\n\n// converts hue, saturation, luminance to an rgb object\nexport const hsvToRgb = (h_, s_, v_) => {\n  const h = ((h_ % HUE_MAX) / parseFloat(HUE_MAX)) * 6\n  const s = s_ === SV_MAX ? 1 : (s_ % SV_MAX) / parseFloat(SV_MAX)\n  const v = v_ === SV_MAX ? 1 : (v_ % SV_MAX) / parseFloat(SV_MAX)\n\n  const i = Math.floor(h)\n  const f = h - i\n  const p = v * (1 - s)\n  const q = v * (1 - f * s)\n  const t = v * (1 - (1 - f) * s)\n  const mod = i % 6\n  const r = [v, q, p, p, t, v][mod]\n  const g = [t, v, v, q, p, p][mod]\n  const b = [p, p, t, v, v, q][mod]\n\n  return { r: Math.round(r * RGB_MAX), g: Math.round(g * RGB_MAX), b: Math.round(b * RGB_MAX) }\n}\n\n// returns an rgb string with default saturation and luminance values\nconst hueToRgbDefaults = (hue) => hsvToRgb(hue, 50, 100)\n\nexport const hueToRgbString = (hue) => {\n  const rgb = hueToRgbDefaults(hue)\n  return `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`\n}\n\nexport const rgbToHexString = (rgb, css) => {\n  const str = ['r', 'g', 'b']\n    .map((channelName) => {\n      const channelValue = rgb[channelName]\n      let channelStr = channelValue.toString(16)\n      if (channelValue < 16) {\n        channelStr = `0${channelStr}`\n      }\n      return channelStr\n    })\n    .join('')\n  const prefix = css === true ? '#' : '0x'\n  return `${prefix}${str}`\n}\n\nexport const hueToRgbHexString = (hue, css) => {\n  const rgb = hueToRgbDefaults(hue)\n  return rgbToHexString(rgb, css)\n}\n\nconst closestNumber = (numberArray, goal) =>\n  numberArray.reduce((prev, curr) => (Math.abs(curr - goal) < Math.abs(prev - goal) ? curr : prev))\n\nexport const hueToClosestColor = (hue) => {\n  if (hue === undefined || hue === null) return undefined\n  const colorHueValues = Object.keys(COLOR_HUES).map((key) => COLOR_HUES[key])\n  const closestHue = closestNumber(colorHueValues, hue)\n  return getKeyByValue(COLOR_HUES, closestHue)\n}\n\nexport const hexToRgb = (hex) => {\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex)\n  return result\n    ? {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16),\n      }\n    : null\n}\n\nconst rgbToRgbaString = (rgb, opacity) => `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`\n\nexport const hueToRgbaString = (hue, opacity) => {\n  const rgb = hueToRgbDefaults(hue)\n  return rgbToRgbaString(rgb, opacity)\n}\n\nexport const hexToRgba = (hex, opacity) => {\n  const rgb = hexToRgb(hex)\n  return rgbToRgbaString(rgb, opacity)\n}\n\nexport const hueIncrementToHue = (hueIncrement) => hueIncrement * VESSELS_HUES_INCREMENT\n\nexport const hueToHueIncrement = (hue) =>\n  Math.round((hue / 360) * (VESSELS_HUES_INCREMENTS_NUM - 1))\n\nexport const wrapHue = (hue) => hue % 360\n\nexport const hueOrColorToHexColor = (color, hue) => {\n  if (hue !== undefined) {\n    return hueToRgbHexString(hue, true)\n  }\n\n  return color\n}\n","/* global PIXI */\nimport 'pixi.js'\nimport { hueToHueIncrement, VESSELS_HUES_INCREMENTS_NUM } from '../utils/map-colors'\nimport { VESSELS_BASE_RADIUS, MAX_SPRITES_PER_LAYER } from '../config'\n\nexport default class HeatmapSubLayer {\n  constructor(baseTexture, renderingStyleIndex, hue, useNormalBlendMode = false) {\n    // this.stage = new PIXI.Container();\n    // the ParticleContainer is a faster version of the PIXI sprite container\n    this.stage = new PIXI.particles.ParticleContainer(MAX_SPRITES_PER_LAYER, {\n      scale: true,\n      alpha: true,\n      position: true,\n      uvs: true,\n    })\n    if (useNormalBlendMode === false) {\n      this.stage.blendMode = PIXI.BLEND_MODES.SCREEN\n    }\n\n    this.spritesPool = []\n\n    const initialTextureFrame = new PIXI.Rectangle(\n      0,\n      0,\n      VESSELS_BASE_RADIUS * 2,\n      VESSELS_BASE_RADIUS * 2\n    )\n    this.mainVesselTexture = new PIXI.Texture(baseTexture, initialTextureFrame)\n    this._setTextureFrame(renderingStyleIndex, hue)\n\n    this.clearSpriteProps()\n  }\n\n  clearSpriteProps() {\n    this.spritesProps = {\n      x: new Float32Array(MAX_SPRITES_PER_LAYER),\n      y: new Float32Array(MAX_SPRITES_PER_LAYER),\n      a: new Float32Array(MAX_SPRITES_PER_LAYER),\n      s: new Float32Array(MAX_SPRITES_PER_LAYER),\n    }\n    this.spritesPropsCount = 0\n  }\n\n  pushSpriteProps(x, y, a, s) {\n    this.spritesProps.x[this.spritesPropsCount] = x\n    this.spritesProps.y[this.spritesPropsCount] = y\n    this.spritesProps.a[this.spritesPropsCount] = a\n    this.spritesProps.s[this.spritesPropsCount] = s\n    this.spritesPropsCount++\n  }\n\n  setRenderingStyleIndex(renderingStyleIndex) {\n    this._setTextureFrame(renderingStyleIndex)\n  }\n\n  destroy() {\n    this.spritesPool = null\n    this.stage.destroy({ children: true })\n  }\n\n  /**\n   * Updates the main texture frame offset to show different brush styles and hues\n   * Both args are optional, if one is omitted, previous value is used\n   * @heatmapStyle bool whether to use heatmap style or solid circle style\n   * @hue number hue value between 0 and 360\n   */\n  _setTextureFrame(renderingStyleIndex = null, hue = null) {\n    const textureFrame = this.mainVesselTexture.frame.clone()\n\n    if (renderingStyleIndex !== null) {\n      // one diameter + tiny offset between 2 frames\n      textureFrame.x = VESSELS_BASE_RADIUS * 2 * renderingStyleIndex + renderingStyleIndex\n    }\n\n    if (hue !== null) {\n      let hueIncrement = hueToHueIncrement(hue)\n      if (hueIncrement === VESSELS_HUES_INCREMENTS_NUM - 1) {\n        hueIncrement = 0\n      }\n      textureFrame.y = hueIncrement * VESSELS_BASE_RADIUS * 2\n      if (hueIncrement > 0) {\n        textureFrame.y += hueIncrement\n      }\n    }\n\n    this.mainVesselTexture.frame = textureFrame\n    this.mainVesselTexture.update()\n  }\n\n  render() {\n    const numProps = this.spritesPropsCount\n    this.resizeSpritesPool()\n\n    for (let i = 0; i < numProps; i++) {\n      const sprite = this.stage.children[i]\n      const s = this.spritesProps.s[i]\n      sprite.setTransform(this.spritesProps.x[i], this.spritesProps.y[i], s, s)\n      sprite.alpha = this.spritesProps.a[i]\n    }\n\n    const numSprites = this.stage.children.length\n    for (let i = numProps; i < numSprites; i++) {\n      const sprite = this.stage.children[i]\n      sprite.x = -100\n    }\n  }\n\n  resizeSpritesPool() {\n    const numProps = this.spritesPropsCount\n    const prevNumSprites = this.stage.children.length\n    const delta = numProps - prevNumSprites\n    // console.log(prevNumSprites, '->', numProps, ' delta:', delta);\n\n    if (delta < -4999) {\n      // sprite needs to be removed. Do that progressively (max 100) to avoid UI lock\n      const toRemove = Math.min(100, -delta)\n      // console.log('removing ', toRemove);\n      for (let i = 0; i < toRemove; i++) {\n        this.stage.removeChildAt(0)\n      }\n    }\n\n    if (delta > 0) {\n      const toAdd = Math.max(5000, delta)\n      // console.log('adding ', toAdd);\n      this._addSprites(toAdd)\n    }\n  }\n\n  _addSprites(num) {\n    for (let i = 0; i < num; i++) {\n      const vessel = new PIXI.Sprite(this.mainVesselTexture)\n      vessel.anchor.x = 0.5\n      vessel.anchor.y = 0.5\n      // ParticlesContainer does not support .visible, so we just move the sprite out of the viewport\n      vessel.x = -100\n      // vessel.blendMode = PIXI.BLEND_MODES.SCREEN;\n      // vessel.filters=  [new PIXI.filters.BlurFilter(10,10)]\n      this.stage.addChild(vessel)\n    }\n  }\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport uniq from 'lodash/uniq'\nimport * as PIXI from 'pixi.js'\nimport { worldToPixels } from 'viewport-mercator-project'\nimport { BRUSH_RENDERING_STYLE, BRUSH_ZOOM_RENDERING_STYLE } from '../constants'\nimport { vesselSatisfiesFilters } from '../utils/heatmapTileData'\nimport HeatmapSubLayer from './HeatmapSubLayer'\n\n// This is a faster version of worldToPixels that omits pitch,\n// and ignores values from the matrix that are consistently = 0\nconst s = 1 / 1.5\nconst worldToPixelsSimple = (x, y, m) => {\n  const fx = s * (m[0] * x + m[4] * y + m[12])\n  const fy = s * (m[5] * y + m[13])\n  return [fx, fy]\n}\n\nclass HeatmapLayer extends React.Component {\n  componentDidMount() {\n    this._build()\n  }\n\n  componentWillUnmount() {\n    this._destroy()\n  }\n\n  componentDidUpdate() {\n    this._redraw()\n  }\n\n  componentWillReceiveProps(nextProps) {\n    if (nextProps.useRadialGradientStyle !== this.props.useRadialGradientStyle) {\n      this.setBrushZoomRenderingStyle(nextProps.useRadialGradientStyle)\n    }\n  }\n\n  _build() {\n    const { layer, rootStage, useRadialGradientStyle, customRenderingStyle } = this.props\n    this.subLayers = {}\n    this.renderingStyle =\n      layer.header && layer.header.rendering ? layer.header.rendering : customRenderingStyle\n\n    this.setBrushRenderingStyle(this.renderingStyle.style)\n    this.setBrushZoomRenderingStyle(useRadialGradientStyle)\n\n    this.stage = new PIXI.Container()\n\n    rootStage.addChild(this.stage)\n  }\n\n  setBrushRenderingStyle(style = BRUSH_RENDERING_STYLE.NORMAL) {\n    if (typeof style === 'string') {\n      this.brushRenderingStyle = BRUSH_RENDERING_STYLE[style.toUpperCase()]\n    } else {\n      this.brushRenderingStyle = style\n    }\n    this._setBrushRenderingStyleIndex()\n  }\n\n  setBrushZoomRenderingStyle(useRadialGradientStyle) {\n    this.brushZoomRenderingStyle =\n      useRadialGradientStyle === true\n        ? BRUSH_ZOOM_RENDERING_STYLE.RADIAL_GRADIENT\n        : BRUSH_ZOOM_RENDERING_STYLE.CIRCLE\n    this._setBrushRenderingStyleIndex()\n  }\n\n  _setBrushRenderingStyleIndex() {\n    // only NORMAL brush styles support different zoom styles\n    const cappedZoomRenderingStyle =\n      this.brushRenderingStyle === BRUSH_RENDERING_STYLE.NORMAL ? this.brushZoomRenderingStyle : 0\n    const newStyleIndex = this.brushRenderingStyle + cappedZoomRenderingStyle\n    if (newStyleIndex === this.renderingStyleIndex) {\n      return\n    }\n    this.renderingStyleIndex = newStyleIndex\n    Object.values(this.subLayers).forEach((subLayer) => {\n      subLayer.setRenderingStyleIndex(this.renderingStyleIndex)\n    })\n  }\n\n  _redraw() {\n    const { filters, baseTexture, layer } = this.props\n\n    if (\n      layer === null ||\n      layer === undefined ||\n      layer.tiles === undefined ||\n      layer.visible === false\n    ) {\n      this.stage.visible = false\n      return\n    }\n\n    this.stage.visible = true\n    this.stage.alpha = layer.opacity\n\n    const tiles = layer.tiles\n    const defaultHue = layer.hue\n    const allHuesToRender =\n      filters !== undefined && filters.length\n        ? filters\n            // pass is set to true by filterGroupActions when none of the filters fields\n            // in the filter group is supported by the layer headers\n            .filter((f) => f.pass !== true)\n            .map((f) => (f.hue === undefined ? '0' : f.hue.toString()))\n        : [defaultHue.toString()]\n    const currentlyUsedHues = Object.keys(this.subLayers)\n\n    // get all hues, old and new\n    const allHues = uniq(allHuesToRender.concat(currentlyUsedHues))\n\n    for (let i = 0; i < allHues.length; i++) {\n      const hue = allHues[i]\n      if (allHuesToRender.indexOf(hue) === -1) {\n        // not on new hues: delete sublayer\n        this._destroySubLayer(this.subLayers[hue])\n        delete this.subLayers[hue]\n        continue\n      }\n      if (currentlyUsedHues.indexOf(hue) === -1) {\n        // not on old hues: create sublayer\n        this.subLayers[hue] = this._createSublayer(baseTexture, this.renderingStyleIndex, hue)\n      }\n      this.subLayers[hue].clearSpriteProps()\n    }\n\n    if (!allHuesToRender.length) return\n    tiles.forEach((tile) => {\n      this._setSubLayersSpritePropsForTile({\n        data: tile.data,\n        numFilters: filters.length,\n        defaultHue,\n      })\n    })\n\n    allHuesToRender.forEach((hueToRender) => {\n      this.subLayers[hueToRender].render()\n    })\n  }\n\n  _setSubLayersSpritePropsForTile({ data, numFilters, defaultHue }) {\n    if (!data) {\n      return\n    }\n\n    const { startIndex, endIndex, viewport, filters, viewportLeft, viewportRight } = this.props\n\n    for (let timeIndex = startIndex; timeIndex < endIndex; timeIndex++) {\n      const frame = data[timeIndex]\n\n      if (!frame) continue\n\n      for (let index = 0, len = frame.worldX.length; index < len; index++) {\n        let hue\n        if (filters === undefined || !filters.length) {\n          hue = defaultHue\n        }\n        for (let fi = 0; fi < numFilters; fi++) {\n          const filter = filters[fi]\n          if (vesselSatisfiesFilters(frame, index, filter.filterValues)) {\n            hue = filter.hue\n            break\n          }\n        }\n\n        // no filter passes: bail\n        if (hue === undefined) {\n          continue\n        }\n\n        // wrap worldX when point crosses the antimeridian/dateline\n        // world points go from 0 to 512. There is no way to determine if worldX is on the \"wrong\" side\n        // of the antimeridian just by looking at its value (where with lat/lon we can simply look at -/+)\n        // Therefore we compare it to the viewport's left or right boundary, depending on what is currently\n        // \"the right side\" of the antimeridian\n        let worldX = frame.worldX[index]\n        if (viewportLeft > 0 && worldX < viewportLeft) {\n          // worldX is \"behind\" viewportLeft, which means it is \"on the right\" of the antimeridian\n          worldX += 512\n        } else if (viewportLeft < 0 && worldX > viewportRight) {\n          worldX -= 512\n        }\n\n        const scaledX = worldX * viewport.scale\n        const scaledY = frame.worldY[index] * viewport.scale\n        const mtx = viewport.pixelProjectionMatrix\n\n        const [x, y] =\n          viewport.pitch === 0\n            ? worldToPixelsSimple(scaledX, scaledY, mtx)\n            : worldToPixels([scaledX, scaledY], mtx)\n\n        if (x > -10 && x < viewport.width + 10 && y > -10 && y < viewport.height + 10) {\n          this.subLayers[hue].pushSpriteProps(\n            x,\n            y,\n            frame.opacity ? frame.opacity[index] : this.renderingStyle.defaultOpacity,\n            frame.radius ? frame.radius[index] : this.renderingStyle.defaultSize\n          )\n        }\n      }\n    }\n  }\n\n  _createSublayer(baseTexture, renderingStyleIndex, hue) {\n    const subLayer = new HeatmapSubLayer(\n      baseTexture,\n      renderingStyleIndex,\n      hue,\n      this.brushRenderingStyle === BRUSH_RENDERING_STYLE.BULLSEYE\n    )\n    this.stage.addChild(subLayer.stage)\n    return subLayer\n  }\n\n  _destroy() {\n    Object.values(this.subLayers).forEach(this._destroySubLayer.bind(this))\n    this.stage.destroy({ children: true })\n    const { rootStage } = this.props\n    rootStage.removeChild(this.stage)\n  }\n\n  _destroySubLayer(subLayer) {\n    this.stage.removeChild(subLayer.stage)\n    subLayer.destroy()\n  }\n\n  render() {\n    return null\n  }\n}\n\nHeatmapLayer.propTypes = {\n  layer: PropTypes.object,\n  rootStage: PropTypes.object,\n  viewport: PropTypes.object,\n  startIndex: PropTypes.number,\n  endIndex: PropTypes.number,\n  filters: PropTypes.array,\n  baseTexture: PropTypes.object,\n  useRadialGradientStyle: PropTypes.bool,\n  customRenderingStyle: PropTypes.object,\n  viewportLeft: PropTypes.number,\n  viewportRight: PropTypes.number,\n}\n\nexport default HeatmapLayer\n","/* global PIXI */\nimport 'pixi.js'\nimport React from 'react'\nimport PropTypes from 'prop-types'\nimport { worldToPixels } from 'viewport-mercator-project'\nimport { TRACKS_DOTS_STYLE_ZOOM_THRESHOLD } from '../config'\n\nclass TracksLayer extends React.Component {\n  componentDidMount() {\n    this._build()\n  }\n\n  componentDidUpdate() {\n    this._redraw()\n  }\n\n  _build() {\n    const { rootStage } = this.props\n    this.stage = new PIXI.Graphics()\n    this.stage.nativeLines = true\n    rootStage.addChild(this.stage)\n  }\n\n  clear() {\n    this.stage.clear()\n  }\n\n  _redraw() {\n    const { tracks, zoom, startIndex, endIndex, highlightTemporalExtentIndexes } = this.props\n\n    this.clear()\n    if (!tracks.length) {\n      return\n    }\n\n    const overInInner =\n      highlightTemporalExtentIndexes === null\n        ? undefined\n        : [\n            Math.max(startIndex, highlightTemporalExtentIndexes[0]),\n            Math.min(endIndex, highlightTemporalExtentIndexes[1]),\n          ]\n    const overExtent = overInInner && overInInner[1] - overInInner[0] > 0 ? overInInner : undefined\n\n    let n = 0 // eslint-disable-line no-unused-vars\n\n    const drawFishingCircles = zoom > TRACKS_DOTS_STYLE_ZOOM_THRESHOLD\n    const fishingCirclesRadius = 1 + (zoom - TRACKS_DOTS_STYLE_ZOOM_THRESHOLD) * 0.5\n    const drawOverTrack = overExtent !== undefined && overExtent[0] > 0 && overExtent[1] > 0\n\n    tracks.forEach((track) => {\n      n += this._drawTrack({\n        data: track.data,\n        startIndex,\n        endIndex,\n        drawFishingCircles,\n        fishingCirclesRadius,\n        color: `0x${track.color.substr(1)}`,\n        lineThickness: 1,\n        lineOpacity: 1,\n      })\n\n      // Draw the highlight over the track when the user hovers over the Timebar\n      if (drawOverTrack === true) {\n        n += this._drawTrack({\n          data: track.data,\n          startIndex: highlightTemporalExtentIndexes[0],\n          endIndex: highlightTemporalExtentIndexes[1],\n          drawFishingCircles,\n          fishingCirclesRadius,\n          color: '0xFFFFFF',\n          lineThickness: 2,\n          lineOpacity: 1,\n        })\n      }\n    })\n\n    // console.log(n);\n  }\n\n  /**\n   * Draws a single track (line + points)\n   *\n   * @param data track points data in 'playback form' (ie organized by days)\n   * @param extent extent, in day indices\n   * @param offset object containing info about the current situation of the map viewport, used to compute screen coords\n   * @param drawFishingCircles whether to draw fishing circles or not\n   * @param fishingCirclesRadius radius of the fishing circles\n   * @param color\n   * @param lineThickness\n   * @param lineOpacity\n   * @param worldOffset offset to use when a track crosses the dateline (ie 512 to add a second world to the right)\n   */\n  _drawTrack({\n    data,\n    startIndex,\n    endIndex,\n    drawFishingCircles,\n    fishingCirclesRadius,\n    color,\n    lineThickness,\n    lineOpacity,\n    worldOffset = 0,\n  }) {\n    const { viewport } = this.props\n\n    let n = 0\n    let prevSeries\n    let prevWorldX\n    let prevWorldY\n\n    const circlePoints = {\n      x: [],\n      y: [],\n    }\n\n    // line thickness is ignored in native mode anyways.\n    this.stage.lineStyle(lineThickness, color, lineOpacity)\n\n    let duplicateWorld = false\n\n    for (let timeIndex = startIndex; timeIndex < endIndex; timeIndex++) {\n      const frame = data[timeIndex]\n\n      if (!frame) continue\n\n      for (let i = 0, len = frame.series.length; i < len; i++) {\n        const currentSeries = frame.series[i]\n\n        n++\n\n        const worldX = frame.worldX[i] + worldOffset\n        const worldY = frame.worldY[i]\n\n        const [x, y] = worldToPixels(\n          [worldX * viewport.scale, worldY * viewport.scale],\n          viewport.pixelProjectionMatrix\n        )\n\n        if (prevSeries !== currentSeries) {\n          this.stage.moveTo(x, y)\n        }\n\n        // more than a  world of distance between two points = crossing the dateline\n        if (prevWorldX && Math.abs(worldX - prevWorldX) > 256) {\n          // worldOffset === 0 -> this is the first time drawTrack is called\n          if (worldOffset === 0) {\n            // set a flag to call drawTrack again at the end of the loop\n            duplicateWorld = true\n          }\n\n          // get Y coordinate where track intersects with dateline\n          const atDatelineWorldY = prevWorldY + (worldY - prevWorldY) / 2\n\n          // whether tracks crosses dateline from west to east\n          const isWestToEast = worldX - prevWorldX < 0\n\n          const worldXEnd = worldOffset + (512 - 0.000001)\n          const worldXStart = worldOffset\n\n          // get X coordinate ending at dateline\n          const atDatelineEndWorldX = isWestToEast ? worldXEnd : worldXStart\n\n          // get X coordinate starting at dateline\n          const atDatelineStartWorldX = isWestToEast ? worldXStart : worldXEnd\n\n          const [x1, y1] = worldToPixels(\n            [atDatelineEndWorldX * viewport.scale, atDatelineWorldY * viewport.scale],\n            viewport.pixelProjectionMatrix\n          )\n          this.stage.lineTo(x1, y1)\n          const [x2, y2] = worldToPixels(\n            [atDatelineStartWorldX * viewport.scale, atDatelineWorldY * viewport.scale],\n            viewport.pixelProjectionMatrix\n          )\n          this.stage.moveTo(x2, y2)\n        }\n\n        this.stage.lineTo(x, y)\n\n        if (drawFishingCircles && frame.hasFishing[i] === true) {\n          circlePoints.x.push(x)\n          circlePoints.y.push(y)\n        }\n\n        prevWorldX = worldX\n        prevWorldY = worldY\n        prevSeries = currentSeries\n      }\n    }\n\n    if (drawFishingCircles) {\n      this.stage.lineStyle(0)\n      this.stage.beginFill(color, 1)\n      for (let i = 0, circlesLength = circlePoints.x.length; i < circlesLength; i++) {\n        this.stage.drawCircle(circlePoints.x[i], circlePoints.y[i], fishingCirclesRadius)\n      }\n      this.stage.endFill()\n    }\n\n    if (duplicateWorld === true) {\n      ;[-512, 512].forEach((offset) => {\n        this._drawTrack({\n          worldOffset: offset,\n          data,\n          startIndex,\n          endIndex,\n          drawFishingCircles,\n          fishingCirclesRadius,\n          color,\n          lineThickness,\n          lineOpacity,\n        })\n      })\n    }\n    return n\n  }\n\n  render() {\n    return null\n  }\n}\n\nTracksLayer.propTypes = {\n  zoom: PropTypes.number,\n  rootStage: PropTypes.object,\n  viewport: PropTypes.object,\n  startIndex: PropTypes.number,\n  endIndex: PropTypes.number,\n  highlightTemporalExtentIndexes: PropTypes.array,\n  tracks: PropTypes.array,\n}\n\nexport default TracksLayer\n","import React, { Fragment } from 'react'\nimport * as PIXI from 'pixi.js'\nimport PropTypes from 'prop-types'\nimport { BaseControl } from 'react-map-gl'\nimport { lngLatToWorld } from 'viewport-mercator-project'\nimport {\n  hsvToRgb,\n  hueToRgbString,\n  hueIncrementToHue,\n  wrapHue,\n  VESSELS_HUES_INCREMENTS_NUM,\n} from '../utils/map-colors'\nimport {\n  VESSELS_BASE_RADIUS,\n  VESSELS_HEATMAP_BLUR_FACTOR,\n  ACTIVITY_HIGHLIGHT_HUE,\n  VESSELS_HEATMAP_DIMMING_ALPHA,\n  VESSELS_RADIAL_GRADIENT_STYLE_ZOOM_THRESHOLD,\n  VESSEL_CLICK_TOLERANCE_PX,\n} from '../config'\nimport HeatmapLayer from '../heatmap/HeatmapLayer'\nimport TracksLayer from '../tracks/TracksLayer'\n\nconst shouldUseRadialGradientStyle = (zoom) => zoom < VESSELS_RADIAL_GRADIENT_STYLE_ZOOM_THRESHOLD\n\n// builds a texture spritesheet containing\n// - the heatmap style (radial gradient)\n// - the circle style that is used at higher zoom levels\n// - the 'bullseye' style used for encounters\n// as well as a number of hues for each in a 2D grid.\n// Then, only the texture frame (mesh UVs) is modified depending on the zoom level,\n// in order not to have to recreate sprites\nconst getVesselTexture = (radius, blurFactor) => {\n  const tplCanvas = document.createElement('canvas')\n  const tplCtx = tplCanvas.getContext('2d')\n  const diameter = radius * 2\n  const NUM_STYLES = 3\n  tplCanvas.width = diameter * NUM_STYLES + (NUM_STYLES - 1) // + (NUM_STYLES - 1): tiny offset between 2 frames\n  tplCanvas.height = diameter * VESSELS_HUES_INCREMENTS_NUM + VESSELS_HUES_INCREMENTS_NUM\n\n  for (let hueIncrement = 0; hueIncrement < VESSELS_HUES_INCREMENTS_NUM; hueIncrement++) {\n    const y = diameter * hueIncrement + hueIncrement\n    const yCenter = y + radius\n\n    // heatmap style\n    let x = radius\n    const gradient = tplCtx.createRadialGradient(\n      x,\n      yCenter,\n      radius * blurFactor,\n      x,\n      yCenter,\n      radius\n    )\n    const hue = hueIncrementToHue(hueIncrement)\n    const rgbString = hueToRgbString(hue)\n    gradient.addColorStop(0, rgbString)\n\n    const rgbOuter = hsvToRgb(wrapHue(hue + 30), 80, 100)\n    gradient.addColorStop(1, `rgba(${rgbOuter.r}, ${rgbOuter.g}, ${rgbOuter.b}, 0)`)\n\n    tplCtx.fillStyle = gradient\n    tplCtx.fillRect(0, y, diameter, diameter)\n\n    // circle style\n    x += diameter + 1 // tiny offset between 2 frames\n    tplCtx.beginPath()\n    tplCtx.arc(x, yCenter, radius, 0, 2 * Math.PI, false)\n    tplCtx.fillStyle = rgbString\n    tplCtx.fill()\n\n    // bullseye style\n    x += diameter + 1\n    tplCtx.beginPath()\n    tplCtx.arc(x, yCenter, radius * 0.4, 0, 2 * Math.PI, false)\n    tplCtx.fillStyle = rgbString\n    tplCtx.fill()\n    tplCtx.beginPath()\n    tplCtx.arc(x, yCenter, radius * 0.95, 0, 2 * Math.PI, false)\n    tplCtx.lineWidth = 1\n    tplCtx.strokeStyle = rgbString\n    tplCtx.stroke()\n  }\n\n  return tplCanvas\n}\n\nclass ActivityLayers extends BaseControl {\n  state = {\n    pixiReady: false,\n  }\n\n  componentDidMount() {\n    this._build()\n    this.setState({\n      pixiReady: true,\n    })\n  }\n\n  componentWillReceiveProps(nextProps) {\n    this.props.exportNativeViewport(this._context.viewport)\n\n    if (\n      nextProps.viewport.width !== this.props.viewport.width ||\n      nextProps.viewport.height !== this.props.viewport.height\n    ) {\n      this._updateViewportSize(nextProps.viewport.width, nextProps.viewport.height)\n    }\n  }\n\n  _build() {\n    const { width, height } = this.props.viewport\n\n    this.pixi = new PIXI.Application({\n      width,\n      height,\n      transparent: true,\n      antialias: true,\n    })\n\n    this.renderer = this.pixi.renderer\n    this.canvas = this.pixi.view\n    this.canvas.style.position = 'absolute'\n\n    this.container.appendChild(this.canvas)\n\n    this.stage = this.pixi.stage\n\n    const baseTextureCanvas = getVesselTexture(VESSELS_BASE_RADIUS, VESSELS_HEATMAP_BLUR_FACTOR)\n    this.baseTexture = PIXI.Texture.fromCanvas(baseTextureCanvas)\n\n    this.heatmapStage = new PIXI.Container()\n    this.stage.addChild(this.heatmapStage)\n\n    this.pixi.ticker.add(this._onTick)\n  }\n\n  _updateViewportSize(viewportWidth, viewportHeight) {\n    this.renderer.resize(viewportWidth, viewportHeight)\n  }\n\n  toggleHeatmapDimming(dim) {\n    if (this.heatmapStage === undefined) {\n      return\n    }\n    if (dim === true) {\n      this.heatmapFadingIn = false\n    }\n    this.heatmapStage.alpha = dim === true ? VESSELS_HEATMAP_DIMMING_ALPHA : 1\n  }\n\n  onTouchStart = (event) => {\n    if (!event.touches.length) {\n      return\n    }\n    this.queryCoords(event.touches[0].clientX, event.touches[0].clientY)\n  }\n\n  onMouseMove = (event) => {\n    this.queryCoords(event.clientX, event.clientY)\n  }\n\n  queryCoords(x, y) {\n    // bail if all heatmap layers are set to non-interactive\n    if (this.props.heatmapLayers.every((l) => l.interactive !== true)) {\n      return\n    }\n\n    const { viewport } = this._context\n    const [longitude, latitude] = viewport.unproject([x, y])\n\n    let wrappedLongitude = longitude\n    if (wrappedLongitude > 180) {\n      wrappedLongitude -= 360\n    } else if (wrappedLongitude < -180) {\n      wrappedLongitude += 360\n    }\n\n    const [worldX, worldY] = lngLatToWorld([wrappedLongitude, latitude], 1)\n\n    const toleranceRadiusInWorldUnits = VESSEL_CLICK_TOLERANCE_PX / viewport.scale\n\n    this.props.queryHeatmapVessels(\n      {\n        longitude: wrappedLongitude,\n        latitude,\n        worldX,\n        worldY,\n        toleranceRadiusInWorldUnits,\n      },\n      this.props.temporalExtentIndexes\n    )\n  }\n\n  _onTick = () => {\n    if (this.heatmapFadingIn === true && this.heatmapStage.alpha < 1) {\n      this._heatmapFadeinStep()\n    }\n  }\n\n  _startHeatmapFadein() {\n    this.heatmapFadingIn = true\n    this.heatmapFadeinStartTimestamp = undefined\n  }\n\n  _heatmapFadeinStep() {\n    if (this.heatmapFadeinStartTimestamp === undefined) {\n      this.heatmapFadeinStartTimestamp = Date.now()\n    }\n    const timeElapsed = (Date.now() - this.heatmapFadeinStartTimestamp) / 1000\n    let alpha = this.heatmapStage.alpha + (1 - this.heatmapStage.alpha) * timeElapsed\n    if (alpha >= 1) {\n      alpha = 1\n      this.heatmapFadingIn = false\n    }\n    this.heatmapStage.alpha = alpha\n  }\n\n  // FIXME move to container?\n  _getHighlightData(highlightedVessels, highlightedClickedVessel, heatmapLayers) {\n    const hue = ACTIVITY_HIGHLIGHT_HUE\n    let highlightLayerData = {\n      id: '__HIGHLIGHT__',\n      visible: true,\n      opacity: 1,\n      hue: ACTIVITY_HIGHLIGHT_HUE,\n    }\n    let highlightFilters = []\n\n    if (\n      highlightedVessels !== undefined &&\n      highlightedVessels.layer !== undefined &&\n      highlightedVessels.foundVessels !== undefined &&\n      highlightedVessels.isEmpty !== true\n    ) {\n      const sourceLayer = heatmapLayers.find((l) => l.id === highlightedVessels.layer.id)\n      highlightLayerData = { highlightLayerData, ...sourceLayer }\n      highlightFilters = highlightedVessels.foundVessels.map((vessel) => ({\n        hue,\n        filterValues: {\n          series: [vessel.series],\n        },\n      }))\n    } else if (highlightedClickedVessel !== null) {\n      const sourceLayer = heatmapLayers.find((l) => l.id === highlightedClickedVessel.layer.id)\n      highlightLayerData = { highlightLayerData, ...sourceLayer }\n      highlightFilters = [\n        {\n          hue,\n          filterValues: {\n            series: [highlightedClickedVessel.seriesgroup],\n          },\n        },\n      ]\n    }\n    return {\n      highlightLayerData,\n      highlightFilters,\n    }\n  }\n  _render() {\n    const {\n      zoom,\n      heatmapLayers,\n      temporalExtentIndexes,\n      highlightTemporalExtentIndexes,\n      highlightedVessels,\n      highlightedClickedVessel,\n      tracks,\n      leftWorldScaled,\n      rightWorldScaled,\n    } = this.props\n    const { viewport } = this._context\n    const { pixiReady } = this.state\n\n    const startIndex = temporalExtentIndexes[0]\n    const endIndex = temporalExtentIndexes[1]\n    const useRadialGradientStyle = shouldUseRadialGradientStyle(zoom)\n\n    if (highlightedVessels.isEmpty !== true) {\n      this.toggleHeatmapDimming(true)\n    }\n    if (highlightedVessels.isEmpty === true && tracks.length === 0) {\n      this._startHeatmapFadein()\n    }\n    if (this.renderer) {\n      const err = this.renderer.gl.getError()\n      if (err !== 0) console.log(err)\n    }\n\n    const { highlightLayerData, highlightFilters } = this._getHighlightData(\n      highlightedVessels,\n      highlightedClickedVessel,\n      heatmapLayers\n    )\n\n    return (\n      <div\n        ref={(ref) => {\n          this.container = ref\n        }}\n        style={{ position: 'absolute' }}\n        onMouseMove={this.onMouseMove}\n        onTouchStart={this.onTouchStart}\n      >\n        {pixiReady === true && (\n          <Fragment>\n            {heatmapLayers.map((layer) => (\n              <HeatmapLayer\n                key={layer.id}\n                layer={layer}\n                filters={layer.filters || []}\n                viewport={viewport}\n                startIndex={startIndex}\n                endIndex={endIndex}\n                baseTexture={this.baseTexture}\n                rootStage={this.heatmapStage}\n                useRadialGradientStyle={useRadialGradientStyle}\n                customRenderingStyle={{}}\n                viewportLeft={leftWorldScaled}\n                viewportRight={rightWorldScaled}\n              />\n            ))}\n            {this.stage !== undefined && (\n              <HeatmapLayer\n                key=\"highlighted\"\n                layer={highlightLayerData}\n                filters={highlightFilters}\n                viewport={viewport}\n                startIndex={startIndex}\n                endIndex={endIndex}\n                baseTexture={this.baseTexture}\n                rootStage={this.heatmapStage}\n                useRadialGradientStyle={useRadialGradientStyle}\n                customRenderingStyle={{ defaultOpacity: 1, defaultSize: 1 }}\n                viewportLeft={leftWorldScaled}\n                viewportRight={rightWorldScaled}\n              />\n            )}\n            {this.stage !== undefined && (\n              <TracksLayer\n                tracks={tracks}\n                viewport={viewport}\n                zoom={zoom}\n                startIndex={startIndex}\n                endIndex={endIndex}\n                highlightTemporalExtentIndexes={highlightTemporalExtentIndexes}\n                rootStage={this.stage}\n              />\n            )}\n          </Fragment>\n        )}\n      </div>\n    )\n  }\n}\n\nActivityLayers.propTypes = {\n  zoom: PropTypes.number,\n  heatmapLayers: PropTypes.array,\n  temporalExtentIndexes: PropTypes.array,\n  highlightTemporalExtentIndexes: PropTypes.array,\n  highlightedVessels: PropTypes.object,\n  highlightedClickedVessel: PropTypes.object,\n  tracks: PropTypes.array,\n  queryHeatmapVessels: PropTypes.func,\n  exportNativeViewport: PropTypes.func,\n  leftWorldScaled: PropTypes.number,\n  rightWorldScaled: PropTypes.number,\n}\n\nActivityLayers.contextTypes = {\n  viewport: PropTypes.object,\n}\n\nexport default ActivityLayers\n","import { connect } from 'react-redux'\nimport { createSelector } from 'reselect'\nimport convert from '@globalfishingwatch/map-convert'\nimport { exportNativeViewport } from '../glmap/viewport.actions'\nimport { getTemporalExtent, getHighlightTemporalExtent } from '../module/module.selectors'\nimport ActivityLayers from './ActivityLayers'\nimport { queryHeatmapVessels } from '../heatmap/heatmapTiles.actions'\nimport { MIN_FRAME_LENGTH_MS } from '../config'\n\nconst getHeatmapLayers = (state) => state.map.heatmap.heatmapLayers\n\nconst getHeatmapLayersAsArray = createSelector(\n  [getHeatmapLayers],\n  (heatmapLayers) => {\n    const a = Object.keys(heatmapLayers).map((id) => ({\n      ...heatmapLayers[id],\n    }))\n    // console.log(a)\n    return a\n  }\n)\n\nconst getTracks = (state) => state.map.tracks.data\n\nconst getTracksWithData = createSelector(\n  [getTracks],\n  (tracks) => {\n    const tracksWithData = tracks\n      .filter((t) => t.type !== 'geojson')\n      .filter((t) => t.data !== undefined)\n    return tracksWithData\n  }\n)\n\nconst getTemporalExtentIndexes = createSelector(\n  [getTemporalExtent],\n  (temporalExtent) => {\n    const startTimestamp = temporalExtent[0].getTime()\n    const endTimestamp = Math.max(\n      temporalExtent[1].getTime(),\n      temporalExtent[0].getTime() + MIN_FRAME_LENGTH_MS\n    )\n    const startIndex = convert.getOffsetedTimeAtPrecision(startTimestamp)\n    const endIndex = convert.getOffsetedTimeAtPrecision(endTimestamp)\n    return [startIndex, endIndex]\n  }\n)\n\nconst getHighlightTemporalExtentIndexes = createSelector(\n  [getHighlightTemporalExtent],\n  (highlightTemporalExtent) => {\n    if (\n      highlightTemporalExtent === undefined ||\n      highlightTemporalExtent === null ||\n      !highlightTemporalExtent.length\n    ) {\n      return null\n    }\n    const startTimestamp = highlightTemporalExtent[0].getTime()\n    const endTimestamp = highlightTemporalExtent[1].getTime()\n    const startIndex = convert.getOffsetedTimeAtPrecision(startTimestamp)\n    const endIndex = convert.getOffsetedTimeAtPrecision(endTimestamp)\n    return [startIndex, endIndex]\n  }\n)\n\nconst mapStateToProps = (state) => ({\n  highlightedVessels: state.map.heatmap.highlightedVessels,\n  highlightedClickedVessel: state.map.heatmap.highlightedClickedVessel,\n  viewport: state.map.viewport.viewport,\n  zoom: state.map.viewport.viewport.zoom,\n  heatmapLayers: getHeatmapLayersAsArray(state),\n  tracks: getTracksWithData(state),\n  leftWorldScaled: state.map.viewport.leftWorldScaled,\n  rightWorldScaled: state.map.viewport.rightWorldScaled,\n  temporalExtentIndexes: getTemporalExtentIndexes(state),\n  highlightTemporalExtentIndexes: getHighlightTemporalExtentIndexes(state),\n})\n\nconst mapDispatchToProps = (dispatch, ownProps) => ({\n  queryHeatmapVessels: (coords, temporalExtentIndexes) => {\n    dispatch(queryHeatmapVessels(coords, temporalExtentIndexes))\n  },\n  exportNativeViewport: (viewport) => {\n    dispatch(exportNativeViewport(viewport))\n  },\n})\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(ActivityLayers)\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport MapGL, { Popup } from 'react-map-gl'\nimport 'mapbox-gl/dist/mapbox-gl.css'\nimport { TILES_URL_NEEDING_AUTHENTICATION } from '../config'\nimport ActivityLayers from '../activity/ActivityLayers.container.js'\nimport styles from './map.css'\n\nconst PopupWrapper = (props) => {\n  const { latitude, longitude, children, closeButton, onClose } = props\n  return (\n    <Popup\n      latitude={latitude}\n      longitude={longitude}\n      closeButton={closeButton}\n      onClose={onClose}\n      anchor=\"bottom\"\n      offsetTop={-10}\n      tipSize={4}\n      closeOnClick={false}\n    >\n      {children}\n    </Popup>\n  )\n}\n\nPopupWrapper.propTypes = {\n  latitude: PropTypes.number.isRequired,\n  longitude: PropTypes.number.isRequired,\n  children: PropTypes.node.isRequired,\n  closeButton: PropTypes.bool.isRequired,\n  onClose: PropTypes.func,\n}\n\nPopupWrapper.defaultProps = {\n  onClose: () => {},\n}\n\nclass Map extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      mouseOver: true,\n    }\n    this._mapContainerRef = null\n  }\n  componentDidMount() {\n    window.addEventListener('resize', this._resize)\n    this._resize()\n\n    // useful with FOUC\n    window.setTimeout(() => this._resize(), 1)\n\n    // there is a problem with the container width computation (only with \"fat scrollbar\" browser/os configs),\n    // seems like the panels with scrollbars are taken into account or smth\n    window.setTimeout(() => this._resize(), 10000)\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('resize', this._resize)\n  }\n\n  _resize = () => {\n    if (this._mapContainerRef === null) {\n      console.warn('Cant set viewport on a map that hasnt finished intanciating yet')\n      return\n    }\n    const mapContainerStyle = window.getComputedStyle(this._mapContainerRef)\n    const width = parseInt(mapContainerStyle.width, 10)\n    const height = parseInt(mapContainerStyle.height, 10) + 1\n\n    if (width !== this.props.viewport.width || height !== this.props.viewport.height) {\n      this.props.setViewport({\n        ...this.props.viewport,\n        width,\n        height,\n      })\n    }\n  }\n\n  onViewportChange = (viewport) => {\n    this.props.setViewport(viewport)\n  }\n\n  onMapInteraction = (event, type) => {\n    // console.log(type, event, event.features)\n    const callback = type === 'hover' ? this.props.mapHover : this.props.mapClick\n    if (this.glMap !== undefined && event.features !== undefined && event.features.length) {\n      const feature = event.features[0]\n      if (feature.properties.cluster === true) {\n        const clusterId = feature.properties.cluster_id\n        const sourceId = feature.source\n        const glSource = this.glMap.getSource(sourceId)\n        glSource.getClusterExpansionZoom(clusterId, (err1, zoom) => {\n          glSource.getClusterLeaves(clusterId, 99, 0, (err2, children) => {\n            if (err1 || err2) {\n              return\n            }\n            callback(event.lngLat[1], event.lngLat[0], event.features, {\n              zoom,\n              children,\n            })\n          })\n        })\n        return\n      }\n    }\n    callback(event.lngLat[1], event.lngLat[0], event.features)\n  }\n\n  onHover = (event) => {\n    this.onMapInteraction(event, 'hover')\n  }\n\n  onClick = (event) => {\n    this.onMapInteraction(event, 'click')\n  }\n\n  getRef = (ref) => {\n    if (ref !== null) {\n      this.glMap = ref.getMap()\n    }\n  }\n\n  getCursor = ({ isDragging }) => {\n    const { cursor } = this.props\n    if (cursor === null) {\n      return isDragging ? 'grabbing' : 'grab'\n    }\n    return cursor\n  }\n\n  transformRequest = (url, resourceType) => {\n    const { token } = this.props\n    if (token !== null && resourceType === 'Tile' && url.match(TILES_URL_NEEDING_AUTHENTICATION)) {\n      return {\n        url: url,\n        headers: { Authorization: 'Bearer ' + token },\n      }\n    }\n  }\n\n  render() {\n    const {\n      viewport,\n      maxZoom,\n      minZoom,\n      transitionEnd,\n      mapStyle,\n      onClosePopup,\n      clickPopup,\n      hoverPopup,\n      interactiveLayerIds,\n    } = this.props\n    return (\n      <div\n        id=\"map\"\n        className={styles.map}\n        ref={(ref) => {\n          this._mapContainerRef = ref\n        }}\n        onMouseLeave={() => {\n          this.setState({ mouseOver: false })\n        }}\n        onMouseEnter={() => {\n          this.setState({ mouseOver: true })\n        }}\n      >\n        <MapGL\n          ref={this.getRef}\n          transformRequest={this.transformRequest}\n          onTransitionEnd={transitionEnd}\n          onHover={this.onHover}\n          onClick={this.onClick}\n          getCursor={this.getCursor}\n          mapStyle={mapStyle}\n          {...viewport}\n          maxZoom={maxZoom}\n          minZoom={minZoom}\n          onViewportChange={this.onViewportChange}\n          interactiveLayerIds={interactiveLayerIds}\n        >\n          <ActivityLayers />\n          {clickPopup !== undefined && clickPopup !== null && (\n            <PopupWrapper\n              latitude={clickPopup.latitude}\n              longitude={clickPopup.longitude}\n              closeButton\n              onClose={onClosePopup}\n            >\n              {clickPopup.content}\n            </PopupWrapper>\n          )}\n          {this.state.mouseOver === true && hoverPopup !== undefined && hoverPopup !== null && (\n            <PopupWrapper\n              latitude={hoverPopup.latitude}\n              longitude={hoverPopup.longitude}\n              closeButton={false}\n            >\n              {hoverPopup.content}\n            </PopupWrapper>\n          )}\n        </MapGL>\n        <div className={styles.googleLogo} />\n      </div>\n    )\n  }\n}\n\nMap.propTypes = {\n  token: PropTypes.string,\n  viewport: PropTypes.object.isRequired,\n  mapStyle: PropTypes.object.isRequired,\n  clickPopup: PropTypes.object,\n  hoverPopup: PropTypes.object,\n  maxZoom: PropTypes.number.isRequired,\n  minZoom: PropTypes.number.isRequired,\n  setViewport: PropTypes.func.isRequired,\n  mapHover: PropTypes.func,\n  mapClick: PropTypes.func,\n  onClosePopup: PropTypes.func,\n  transitionEnd: PropTypes.func,\n  cursor: PropTypes.string,\n  interactiveLayerIds: PropTypes.arrayOf(PropTypes.string),\n}\n\nMap.defaultProps = {\n  token: null,\n  clickPopup: null,\n  hoverPopup: null,\n  mapHover: () => {},\n  mapClick: () => {},\n  onClosePopup: () => {},\n  transitionEnd: () => {},\n  cursor: null,\n  interactiveLayerIds: null,\n}\n\nexport default Map\n","import { connect } from 'react-redux'\nimport { createSelector } from 'reselect'\nimport { fromJS } from 'immutable'\nimport { TRACKS_LAYER_IN_FRONT_OF_GROUP } from '../config'\nimport { closePopup } from '../module/module.actions.js'\nimport { getTracksStyles } from '../tracks/tracks.selectors.js'\nimport { mapHover, mapClick } from './interaction.actions.js'\nimport { setViewport, transitionEnd } from './viewport.actions.js'\nimport Map from './Map'\n\nconst getStaticLayers = (state) => state.map.style.staticLayers\n\nconst getInteractiveLayerIds = createSelector(\n  [getStaticLayers],\n  // Note: here we assume that layer IDs provided with module match the GL layers that should\n  // be interactive or not, ie typically the fill layer if a label layer is present\n  (staticLayers) =>\n    staticLayers.filter((l) => l.interactive === true && l.visible === true).map((l) => l.id)\n)\n\nconst getMapStyles = (state) => state.map.style.mapStyle\nconst getMapStyle = createSelector(\n  [getMapStyles, getTracksStyles],\n  (mapStyles, trackStyles) => {\n    if (!trackStyles) return mapStyles\n\n    const currentLayerGroups = mapStyles\n      .toJS()\n      .layers.filter((l) => l.metadata !== undefined)\n      .map((l) => l.metadata['mapbox:group'])\n    const trackLayersIndex = currentLayerGroups.lastIndexOf(TRACKS_LAYER_IN_FRONT_OF_GROUP) + 1\n\n    let finalMapStyles = mapStyles.mergeIn(['sources'], trackStyles.sources)\n    let mapStylesLayers = mapStyles.get('layers')\n    trackStyles.layers.forEach((trackLayer, i) => {\n      mapStylesLayers = mapStylesLayers.insert(trackLayersIndex + i, fromJS(trackLayer))\n    })\n    finalMapStyles = finalMapStyles.set('layers', mapStylesLayers)\n\n    return finalMapStyles\n  }\n)\n\nconst mapStateToProps = (state, ownProps) => ({\n  viewport: state.map.viewport.viewport,\n  maxZoom: state.map.viewport.maxZoom,\n  minZoom: state.map.viewport.minZoom,\n  cursor: state.map.interaction.cursor,\n  token: state.map.module.token,\n  mapStyle: getMapStyle(state),\n  interactiveLayerIds: getInteractiveLayerIds(state),\n})\n\nconst mapDispatchToProps = (dispatch) => ({\n  setViewport: (viewport) => {\n    dispatch(setViewport(viewport))\n  },\n  mapHover: (lat, long, features, cluster) => {\n    dispatch(mapHover(lat, long, features, cluster))\n  },\n  mapClick: (lat, long, features, cluster) => {\n    dispatch(mapClick(lat, long, features, cluster))\n  },\n  transitionEnd: () => {\n    dispatch(transitionEnd())\n  },\n  onClosePopup: () => {\n    dispatch(closePopup())\n  },\n})\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(Map)\n","// This utility looks at GeoJSON features and returns the predominant geometry type\n\nconst TYPES = [\n  { gl: 'line', geoJSON: ['LineString', 'MultiLineString'] },\n  { gl: 'fill', geoJSON: ['Polygon', 'MultiPolygon'] },\n  { gl: 'circle', geoJSON: ['Point', 'MultiPoint'] },\n]\n\nexport default (geoJSON) => {\n  // collect all geoJSON geom types\n  const allGeoJSONTypes = geoJSON.features.map((feature) => {\n    const geom = feature.geometry\n    if (geom === undefined) {\n      return null\n    }\n    return geom.type\n  })\n\n  // collect number of geometries by GL geom types\n  const numByGLType = TYPES.map((type) => {\n    let num = 0\n    allGeoJSONTypes.forEach((geoJSONType) => {\n      if (type.geoJSON.indexOf(geoJSONType) > -1) {\n        num++\n      }\n    })\n    return { gl: type.gl, num }\n  })\n\n  // get feature types with the higher count\n  let glType = 'fill'\n  let glTypeMax = 0\n  numByGLType.forEach((t) => {\n    if (t.num > glTypeMax) {\n      glType = t.gl\n      glTypeMax = t.num\n    }\n  })\n\n  return glType\n}\n","import { fromJS } from 'immutable'\nimport { hexToRgb } from '../utils/map-colors'\nimport uniq from 'lodash/uniq'\nimport { STATIC_LAYERS_CARTO_ENDPOINT, STATIC_LAYERS_CARTO_TILES_ENDPOINT } from '../config'\nimport { CUSTOM_LAYERS_SUBTYPES, GL_TRANSPARENT } from '../constants'\nimport GL_STYLE from './gl-styles/style.json'\nimport getMainGeomType from '../utils/getMainGeomType'\n\nexport const INIT_MAP_STYLE = 'INIT_MAP_STYLE'\nexport const SET_MAP_STYLE = 'SET_MAP_STYLE'\nexport const MARK_CARTO_LAYERS_AS_INSTANCIATED = 'MARK_CARTO_LAYERS_AS_INSTANCIATED'\nexport const SET_STATIC_LAYERS = 'SET_STATIC_LAYERS'\nexport const SET_BASEMAP_LAYERS = 'SET_BASEMAP_LAYERS'\n\nexport const initStyle = ({ glyphsPath }) => ({\n  type: INIT_MAP_STYLE,\n  payload: {\n    glyphsPath,\n  },\n})\n\nconst setMapStyle = (style) => ({\n  type: SET_MAP_STYLE,\n  payload: style,\n})\n\nexport const applyTemporalExtent = (temporalExtent) => (dispatch, getState) => {\n  const state = getState().map.style\n  let style = state.mapStyle\n  const currentStyle = style.toJS()\n  const glLayers = currentStyle.layers\n\n  const start = Math.round(temporalExtent[0].getTime() / 1000)\n  const end = Math.round(temporalExtent[1].getTime() / 1000)\n\n  for (let i = 0; i < glLayers.length; i++) {\n    const glLayer = glLayers[i]\n    if (glLayer.metadata === undefined || glLayer.metadata['gfw:temporal'] !== true) {\n      continue\n    }\n\n    // if layer is temporal, a filter must always be preset on the style.json object\n    // because each layer can have a different time field to be filtered\n    const currentFilter = style.getIn(['layers', i, 'filter']).toJS()\n    if (currentFilter === null) {\n      throw new Error('filter must be preset on style.json for temporal layer: ', glLayer.id)\n    }\n    currentFilter[1][2] = start\n    currentFilter[2][2] = end\n    style = style.setIn(['layers', i, 'filter'], fromJS(currentFilter))\n  }\n  dispatch(setMapStyle(style))\n}\n\nconst applyLayerExpressions = (style, refLayer, currentGlLayer, glLayerIndex) => {\n  let newStyle = style\n  const currentStyle = style.toJS()\n  const glType = currentGlLayer.type\n  const defaultStyles = currentStyle.metadata['gfw:styles']\n  const metadata = currentGlLayer.metadata\n  ;['selected', 'highlighted'].forEach((styleType) => {\n    // get selectedFeatures or highlightedFeatures\n    const features = refLayer[`${styleType}Features`]\n    const hasFeatures = features !== null && features !== undefined && features.values.length > 0\n    const applyStyleToAllFeatures = refLayer[styleType]\n\n    const defaultStyle = defaultStyles[styleType][glType] || {}\n    const layerStyle =\n      (metadata && metadata['gfw:styles'] && metadata['gfw:styles'][styleType]) || {}\n    const allPaintProperties = { ...defaultStyle, ...layerStyle }\n    if (Object.keys(allPaintProperties).length) {\n      // go through each applicable gl paint property\n      Object.keys(allPaintProperties).forEach((glPaintProperty) => {\n        const selectedValue = allPaintProperties[glPaintProperty][0]\n        const fallbackValue = allPaintProperties[glPaintProperty][1]\n        const paintOrLayout = ['icon-size', 'icon-image'].includes(glPaintProperty)\n          ? 'layout'\n          : 'paint'\n        let glPaintFinalValue\n        if (\n          hasFeatures === false &&\n          applyStyleToAllFeatures !== true &&\n          applyStyleToAllFeatures !== false\n        ) {\n          // style reset when no features filter is declared and neither is applyAll\n          const originalLayerStyle = GL_STYLE.layers.find((l) => l.id === currentGlLayer.id)\n\n          if (originalLayerStyle !== undefined) {\n            glPaintFinalValue = originalLayerStyle[paintOrLayout][glPaintProperty]\n          } else {\n            // this will happen when no style exist in the original definition (ie custom layers)\n            // in this case set glPaintFinalValue to null and we'll just skip applying\n            // any selected/highlighted style for this layer\n            glPaintFinalValue = null\n          }\n        } else if (applyStyleToAllFeatures === true || applyStyleToAllFeatures === false) {\n          glPaintFinalValue = applyStyleToAllFeatures === true ? selectedValue : fallbackValue\n        } else {\n          let layerColorRgbString = ''\n          if (refLayer.color !== null && refLayer.color !== undefined) {\n            const layerColorRgb = hexToRgb(refLayer.color)\n            layerColorRgbString = `${layerColorRgb.r},${layerColorRgb.g},${layerColorRgb.b}`\n          }\n          glPaintFinalValue = [\n            'match',\n            ['get', features.field],\n            features.values,\n            typeof selectedValue !== 'string'\n              ? selectedValue\n              : selectedValue.replace('$REFLAYER_COLOR_RGB', layerColorRgbString),\n            typeof fallbackValue !== 'string'\n              ? fallbackValue\n              : fallbackValue.replace('$REFLAYER_COLOR_RGB', layerColorRgbString),\n          ]\n        }\n\n        if (glPaintFinalValue !== undefined && glPaintFinalValue !== null) {\n          newStyle = newStyle.setIn(\n            ['layers', glLayerIndex, paintOrLayout, glPaintProperty],\n            glPaintFinalValue\n          )\n        }\n      })\n    }\n  })\n  return newStyle\n}\n\nconst toggleLayerVisibility = (style, refLayer, glLayerIndex) => {\n  const visibility = refLayer.visible === true ? 'visible' : 'none'\n  return style.setIn(['layers', glLayerIndex, 'layout', 'visibility'], visibility)\n}\n\nconst updateGLLayer = (style, glLayerId, refLayer) => {\n  const currentStyle = style.toJS()\n  const currentStyleLayers = currentStyle.layers\n  let newStyle = style\n\n  const glLayerIndex = currentStyleLayers.findIndex((l) => l.id === glLayerId)\n  const glLayer = currentStyleLayers.find((l) => l.id === glLayerId)\n\n  // visibility\n  newStyle = toggleLayerVisibility(newStyle, refLayer, glLayerIndex)\n\n  if (refLayer.isBasemap === true) {\n    return newStyle\n  }\n\n  const initialGLLayer = GL_STYLE.layers.find((l) => l.id === glLayerId)\n  const refLayerOpacity = refLayer.opacity === undefined ? 1 : refLayer.opacity\n\n  // color/opacity\n  switch (glLayer.type) {\n    case 'fill': {\n      newStyle = newStyle\n        .setIn(['layers', glLayerIndex, 'paint', 'fill-opacity'], refLayerOpacity)\n        .setIn(['layers', glLayerIndex, 'paint', 'fill-outline-color'], refLayer.color)\n        .setIn(['layers', glLayerIndex, 'paint', 'fill-color'], GL_TRANSPARENT)\n      break\n    }\n    case 'line': {\n      newStyle = newStyle\n        .setIn(['layers', glLayerIndex, 'paint', 'line-opacity'], refLayerOpacity)\n        .setIn(['layers', glLayerIndex, 'paint', 'line-color'], refLayer.color)\n      break\n    }\n    case 'symbol': {\n      if (glLayer.metadata && glLayer.metadata['gfw:isLabel'] === true) {\n        const parentLayerIsVisible =\n          newStyle.getIn(['layers', glLayerIndex, 'layout', 'visibility']) === 'visible'\n        const labelsVisibility =\n          parentLayerIsVisible && refLayer.showLabels === true ? 'visible' : 'none'\n        newStyle = newStyle.setIn(\n          ['layers', glLayerIndex, 'layout', 'visibility'],\n          labelsVisibility\n        )\n        if (refLayer.showLabels !== true) {\n          break\n        }\n      }\n      newStyle = newStyle.setIn(['layers', glLayerIndex, 'paint', 'text-opacity'], refLayerOpacity)\n\n      if (refLayer.color !== undefined) {\n        newStyle = newStyle.setIn(['layers', glLayerIndex, 'paint', 'text-color'], refLayer.color)\n      }\n      break\n    }\n    // Event layers and custom layers with point geom types\n    case 'circle': {\n      newStyle = newStyle\n        .setIn(['layers', glLayerIndex, 'paint', 'circle-opacity'], refLayerOpacity)\n        .setIn(\n          ['layers', glLayerIndex, 'paint', 'circle-radius'],\n          initialGLLayer.paint['circle-radius']\n        )\n        .setIn(\n          ['layers', glLayerIndex, 'paint', 'circle-stroke-color'],\n          initialGLLayer.paint['circle-stroke-color'] || '#000'\n        )\n        .setIn(\n          ['layers', glLayerIndex, 'paint', 'circle-stroke-width'],\n          initialGLLayer.paint['circle-stroke-width'] || 1\n        )\n\n      if (refLayer.color !== undefined) {\n        newStyle = newStyle.setIn(['layers', glLayerIndex, 'paint', 'circle-color'], refLayer.color)\n      }\n      break\n    }\n    case 'raster': {\n      newStyle = newStyle.setIn(\n        ['layers', glLayerIndex, 'paint', 'raster-opacity'],\n        refLayerOpacity\n      )\n      break\n    }\n    default: {\n      break\n    }\n  }\n\n  newStyle = applyLayerExpressions(newStyle, refLayer, glLayer, glLayerIndex)\n\n  return newStyle\n}\n\nconst addCustomGLLayer = (subtype, layerId, url, data) => (dispatch, getState) => {\n  const state = getState()\n  let style = state.map.style.mapStyle\n  const currentStyle = style.toJS()\n\n  // add source if it doesn't exist yet\n  if (currentStyle.sources[layerId] === undefined) {\n    const source = { type: subtype }\n    if (subtype === CUSTOM_LAYERS_SUBTYPES.geojson) {\n      source.data = data\n    } else if (subtype === CUSTOM_LAYERS_SUBTYPES.raster) {\n      source.tiles = [url]\n      source.tileSize = 256\n    }\n    style = style.setIn(['sources', layerId], fromJS(source))\n  }\n\n  if (currentStyle.layers.find((glLayer) => glLayer.id === layerId) === undefined) {\n    const glType = subtype === CUSTOM_LAYERS_SUBTYPES.geojson ? getMainGeomType(data) : subtype\n    const glLayer = fromJS({\n      id: layerId,\n      source: layerId,\n      type: glType,\n      layout: {},\n      paint: {},\n    })\n    const layerIndex =\n      subtype === CUSTOM_LAYERS_SUBTYPES.raster\n        ? // if raster, put at index of last raster layer except labels\n          currentStyle.layers.length -\n          1 -\n          currentStyle.layers\n            .filter((l) => l.id !== 'labels')\n            .reverse()\n            .findIndex((l) => l.type === 'raster')\n        : currentStyle.layers.length - 1\n    style = style.set('layers', style.get('layers').splice(layerIndex, 0, glLayer))\n  }\n\n  dispatch(setMapStyle(style))\n}\n\nconst addWorkspaceGLLayers = (workspaceGLLayers) => (dispatch, getState) => {\n  const state = getState()\n  let style = state.map.style.mapStyle\n\n  workspaceGLLayers.forEach((workspaceGLLayer) => {\n    const id = workspaceGLLayer.id\n    const gl = workspaceGLLayer.gl\n    const finalSource = fromJS(gl.source)\n    style = style.setIn(['sources', id], finalSource)\n\n    const layers = []\n    gl.layers.forEach((srcGlLayer) => {\n      const glLayer = {\n        ...srcGlLayer,\n        source: id,\n        'source-layer': id,\n      }\n      layers.push(glLayer)\n    })\n\n    const finalLayers = fromJS(layers)\n    style = style.set('layers', style.get('layers').concat(finalLayers))\n  })\n\n  dispatch(setMapStyle(style))\n\n  // TODO MAP MODULE\n  // dispatch(updateMapStyle());\n}\n\nconst getCartoLayerInstanciatePromise = ({ sourceId, sourceCartoSQL }) => {\n  const mapConfig = { layers: [{ id: sourceId, options: { sql: sourceCartoSQL } }] }\n  const mapConfigURL = encodeURIComponent(JSON.stringify(mapConfig))\n  const cartoAnonymousMapUrl = STATIC_LAYERS_CARTO_ENDPOINT.replace('$MAPCONFIG', mapConfigURL)\n\n  return new Promise((resolve) => {\n    fetch(cartoAnonymousMapUrl)\n      .then((res) => {\n        if (res.status >= 400) {\n          console.warn(`loading of layer failed ${sourceId}`)\n          Promise.reject()\n          return null\n        }\n        return res.json()\n      })\n      .then((data) => {\n        resolve({\n          layergroupid: data.layergroupid,\n          sourceId,\n        })\n      })\n      .catch((err) => {\n        console.warn(err)\n      })\n  })\n}\n\nconst instanciateCartoLayers = (layers) => (dispatch, getState) => {\n  dispatch({\n    type: MARK_CARTO_LAYERS_AS_INSTANCIATED,\n    payload: layers.map((layer) => layer.sourceId),\n  })\n  const cartoLayersPromises = layers.map((layer) => getCartoLayerInstanciatePromise(layer))\n  const cartoLayersPromisesPromise = Promise.all(cartoLayersPromises.map((p) => p.catch((e) => e)))\n  cartoLayersPromisesPromise\n    .then((instanciatedCartoLayers) => {\n      let style = getState().map.style.mapStyle\n      const currentStyle = style.toJS()\n      instanciatedCartoLayers.forEach((cartoLayer) => {\n        const tilesURL = STATIC_LAYERS_CARTO_TILES_ENDPOINT.replace(\n          '$LAYERGROUPID',\n          cartoLayer.layergroupid\n        )\n\n        // replace gl source with a new source that use tiles provided by Carto anonymous maps API\n        const newSourceId = `${cartoLayer.sourceId}-instanciated`\n        style = style.setIn(\n          ['sources', newSourceId],\n          fromJS({\n            type: 'vector',\n            tiles: [tilesURL],\n          })\n        )\n\n        // change source in all layers that are using it (genrally polygon + labels)\n        currentStyle.layers.forEach((glLayer, glLayerIndex) => {\n          if (glLayer.source === cartoLayer.sourceId) {\n            style = style.setIn(['layers', glLayerIndex, 'source'], newSourceId)\n            style = style.setIn(['layers', glLayerIndex, 'metadata', 'gfw:id'], cartoLayer.sourceId)\n            const refLayer = layers.find((l) => l.refLayer.id === cartoLayer.sourceId).refLayer\n            style = updateGLLayer(style, glLayer.id, refLayer)\n          }\n        })\n      })\n\n      dispatch(setMapStyle(style))\n    })\n    .catch((err) => {\n      console.warn(err)\n    })\n}\n\nexport const commitStyleUpdates = (staticLayers, basemapLayers) => (dispatch, getState) => {\n  // Store a copy of static and basemap layers. This is not used directly by\n  // the Map component which only needs a prepared style object\n  dispatch({\n    type: SET_STATIC_LAYERS,\n    payload: staticLayers,\n  })\n  dispatch({\n    type: SET_BASEMAP_LAYERS,\n    payload: basemapLayers,\n  })\n\n  const layers = [...staticLayers, ...basemapLayers.map((bl) => ({ ...bl, isBasemap: true }))]\n\n  const currentGLSources = getState().map.style.mapStyle.toJS().sources\n\n  // collect layers declared in workspace but not in original gl style\n  const workspaceGLLayers = layers.filter(\n    (layer) => layer.gl !== undefined && currentGLSources[layer.id] === undefined\n  )\n  if (workspaceGLLayers.length) {\n    dispatch(addWorkspaceGLLayers(workspaceGLLayers))\n  }\n\n  // instanciate custom layers if needed\n  const customLayers = layers.filter(\n    (layer) => layer.isCustom === true && currentGLSources[layer.id] === undefined\n  )\n  if (customLayers.length) {\n    customLayers.forEach((layer) => {\n      dispatch(addCustomGLLayer(layer.subtype, layer.id, layer.url, layer.data))\n    })\n  }\n\n  const state = getState().map.style\n  let style = state.mapStyle\n  const currentStyle = style.toJS()\n  const glLayers = currentStyle.layers\n  const glSources = currentStyle.sources\n\n  const cartoLayersToInstanciate = []\n\n  // update source when needed\n  staticLayers.forEach((refLayer) => {\n    const sourceId = refLayer.id\n    if (currentGLSources[sourceId] !== undefined) {\n      if (refLayer.data !== undefined) {\n        style = style.setIn(['sources', sourceId, 'data'], fromJS(refLayer.data))\n      }\n      if (refLayer.url !== undefined) {\n        const { tiles } = currentGLSources[sourceId]\n        // Using default tiles url as a fallback\n        const newTiles =\n          tiles !== undefined && tiles.length > 0 ? uniq([refLayer.url, ...tiles]) : [refLayer.url]\n        style = style.setIn(['sources', sourceId, 'tiles'], fromJS(newTiles))\n      }\n    }\n  })\n\n  for (let i = 0; i < glLayers.length; i++) {\n    const glLayer = glLayers[i]\n    const sourceId = glLayer.source\n    const glSource = glSources[sourceId]\n    const layerId = (glLayer.metadata !== undefined && glLayer.metadata['gfw:id']) || sourceId\n\n    const refLayer = layers.find((l) => l.id === layerId)\n\n    if (refLayer === undefined) {\n      if (glLayer.type !== 'background') {\n        // console.warn('gl layer does not exists in workspace', glLayer);\n      }\n      continue\n    }\n\n    // check if layer is served from Carto, which means we need to instanciate it first\n    // TODO BUG: check if layer is not instanciatING too\n    const sourceCartoSQL = glSource.metadata !== undefined && glSource.metadata['gfw:carto-sql']\n    if (sourceCartoSQL !== false && sourceCartoSQL !== undefined) {\n      // only if layer is visible and has not been instanciated yet\n      const cartoLayerInstanciated = state.cartoLayersInstanciated.indexOf(sourceId) > -1\n      if (\n        refLayer.visible === true &&\n        !cartoLayerInstanciated &&\n        !cartoLayersToInstanciate.find((l) => l.sourceId === sourceId)\n      ) {\n        cartoLayersToInstanciate.push({ sourceId, sourceCartoSQL, refLayer })\n      }\n      continue\n    }\n\n    style = updateGLLayer(style, glLayer.id, refLayer)\n  }\n\n  if (cartoLayersToInstanciate.length) {\n    dispatch(instanciateCartoLayers(cartoLayersToInstanciate))\n  }\n\n  dispatch(setMapStyle(style))\n}\n","import { compose, createStore, applyMiddleware } from 'redux'\nimport thunk from 'redux-thunk'\n\nimport { fitToBounds } from '../glmap/viewport.actions'\n\nlet composeEnhancers = compose\nif (\n  (process.env.MAP_REDUX_REMOTE_DEBUG || process.env.REACT_APP_MAP_REDUX_REMOTE_DEBUG) &&\n  process.env.NODE_ENV === 'development'\n) {\n  const composeWithDevTools = require('remote-redux-devtools').composeWithDevTools\n  composeEnhancers = composeWithDevTools({\n    name: 'Map module',\n    realtime: true,\n    hostname: 'localhost',\n    port: 8000,\n    maxAge: 30,\n    stateSanitizer: (state) => ({ ...state, map: { ...state.map, heatmap: 'NOT_SERIALIZED' } }),\n  })\n}\n\nconst store = createStore(() => {}, {}, composeEnhancers(applyMiddleware(thunk)))\n\nexport const targetMapVessel = (id) => {\n  const track = store.getState().map.tracks.data.find((t) => t.id === id.toString())\n  store.dispatch(fitToBounds(track.geoBounds))\n\n  return track.timelineBounds\n}\n\nexport default store\n","import tbbox from '@turf/bbox'\nimport { targetMapVessel } from '../store'\n\nimport {\n  getTilePromises,\n  getCleanVectorArrays,\n  groupData,\n  addTracksPointsRenderingData,\n  getTracksPlaybackData,\n} from '../utils/heatmapTileData'\nimport { startLoader, completeLoader } from '../module/module.actions'\n\nexport const ADD_TRACK = 'ADD_TRACK'\nexport const UPDATE_TRACK = 'UPDATE_TRACK'\nexport const REMOVE_TRACK = 'REMOVE_TRACK'\n\nconst getTrackDataParsed = (geojson) => {\n  const time = { start: Infinity, end: 0 }\n  if (geojson && geojson.features) {\n    geojson.features.forEach((feature) => {\n      const hasTimes =\n        feature.properties.coordinateProperties.times &&\n        feature.properties.coordinateProperties.times.length > 0\n      if (hasTimes) {\n        feature.properties.coordinateProperties.times.forEach((datetime) => {\n          if (datetime < time.start) {\n            time.start = datetime\n          } else if (datetime > time.end) {\n            time.end = datetime\n          }\n        })\n      }\n    })\n  }\n  return {\n    geojson,\n    timelineBounds: [time.start, time.end],\n  }\n}\n\nconst getTrackBounds = (geojson) => {\n  const bounds = tbbox(geojson)\n  return {\n    minLat: bounds[3],\n    minLng: bounds[0],\n    maxLat: bounds[1],\n    maxLng: bounds[2],\n  }\n}\n\n// Deprecated tracks format parsing\nconst getOldTrackBoundsFormat = (data, addOffset = false) => {\n  const time = {\n    start: Infinity,\n    end: 0,\n  }\n  const geo = {\n    minLat: Infinity,\n    maxLat: -Infinity,\n    minLng: Infinity,\n    maxLng: -Infinity,\n  }\n  for (let i = 0, length = data.datetime.length; i < length; i++) {\n    const datetime = data.datetime[i]\n    if (datetime < time.start) {\n      time.start = datetime\n    } else if (datetime > time.end) {\n      time.end = datetime\n    }\n\n    const lat = data.latitude[i]\n    if (lat < geo.minLat) {\n      geo.minLat = lat\n    } else if (lat > geo.maxLat) {\n      geo.maxLat = lat\n    }\n\n    let lng = data.longitude[i]\n    if (addOffset === true) {\n      if (lng < 0) {\n        lng += 360\n      }\n    }\n    if (lng < geo.minLng) {\n      geo.minLng = lng\n    } else if (lng > geo.maxLng) {\n      geo.maxLng = lng\n    }\n  }\n\n  // track crosses the antimeridian\n  if (geo.maxLng - geo.minLng > 350 && addOffset === false) {\n    return getOldTrackBoundsFormat(data, true)\n  }\n\n  return {\n    time: [time.start, time.end],\n    geo,\n  }\n}\n\nfunction loadTrack(track) {\n  return (dispatch, getState) => {\n    const { id, url, type, fitBoundsOnLoad, layerTemporalExtents, color, data } = track\n    const state = getState()\n    if (state.map.tracks.data.find((t) => t.id === id)) {\n      return\n    }\n\n    const payload = {\n      id,\n      url,\n      type,\n      color,\n      fitBoundsOnLoad,\n    }\n    const trackHasData = track.data !== undefined && track.data !== null\n    const trackHasUrl = url !== undefined && url !== null && url !== ''\n    if (trackHasData) {\n      payload.data = data\n      payload.geoBounds = getTrackBounds(data)\n    }\n    dispatch({ type: ADD_TRACK, payload })\n\n    if (trackHasData || !trackHasUrl) {\n      return\n    }\n\n    const loaderID = startLoader(dispatch, state)\n    if (type !== 'geojson') {\n      // Deprecated tracks format logic to be deleted some day\n      const token = state.map.module.token\n      const promises = getTilePromises(url, token, layerTemporalExtents, { seriesgroup: id })\n\n      Promise.all(promises.map((p) => p.catch((e) => e))).then((rawTileData) => {\n        const cleanData = getCleanVectorArrays(rawTileData)\n\n        if (!cleanData.length) {\n          return\n        }\n        const rawTrackData = groupData(cleanData, [\n          'latitude',\n          'longitude',\n          'datetime',\n          'series',\n          'weight',\n          'sigma',\n        ])\n\n        const vectorArray = addTracksPointsRenderingData(rawTrackData)\n        const bounds = getOldTrackBoundsFormat(rawTrackData)\n\n        dispatch({\n          type: UPDATE_TRACK,\n          payload: {\n            id,\n            data: getTracksPlaybackData(vectorArray),\n            geoBounds: bounds.geo,\n            timelineBounds: bounds.time,\n          },\n        })\n        dispatch(completeLoader(loaderID))\n      })\n    } else {\n      fetch(url)\n        .then((res) => {\n          if (res.status >= 400) throw new Error(res.statusText)\n          return res.json()\n        })\n        .then((data) => {\n          const { geojson, timelineBounds } = getTrackDataParsed(data)\n          const geoBounds = getTrackBounds(data)\n          dispatch({\n            type: UPDATE_TRACK,\n            payload: {\n              id,\n              data: geojson,\n              geoBounds,\n              timelineBounds,\n            },\n          })\n          if (fitBoundsOnLoad) {\n            targetMapVessel(id)\n          }\n        })\n        .catch((err) => console.warn(err))\n        .finally(() => dispatch(completeLoader(loaderID)))\n    }\n  }\n}\n\nconst removeTrack = (trackId) => ({\n  type: REMOVE_TRACK,\n  payload: {\n    trackId,\n  },\n})\n\nexport const updateTracks = (newTracks = []) => (dispatch, getState) => {\n  const prevTracks = getState().map.tracks.data\n  // add and update layers\n  if (newTracks) {\n    newTracks.forEach((newTrack) => {\n      const trackId = newTrack.id\n      const prevTrack = prevTracks.find((t) => t.id === trackId)\n      if (prevTrack === undefined) {\n        dispatch(loadTrack(newTrack))\n      } else if (prevTrack.color !== newTrack.color) {\n        dispatch({\n          type: UPDATE_TRACK,\n          payload: {\n            id: newTrack.id,\n            color: newTrack.color,\n          },\n        })\n      }\n    })\n  }\n\n  // clean up unused tracks\n  prevTracks.forEach((prevTrack) => {\n    if (!newTracks || !newTracks.find((t) => t.id === prevTrack.id)) {\n      dispatch(removeTrack(prevTrack.id))\n    }\n  })\n}\n","import PropTypes from 'prop-types'\n\nconst withReducerPropTypes = (name, propTypesSchema) => (reducer) => {\n  if (process.env.NODE_ENV === 'development') {\n    return (state, action) => {\n      const result = reducer(state, action)\n      PropTypes.checkPropTypes(propTypesSchema, result, 'reducer', name)\n\n      return result\n    }\n  }\n  return reducer\n}\n\nexport default withReducerPropTypes\n","import PropTypes from 'prop-types'\nimport withReducerTypes from '../utils/withReducerTypes'\nimport {\n  INIT_MODULE,\n  SET_TEMPORAL_EXTENT,\n  SET_HIGHLIGHT_TEMPORAL_EXTENT,\n  START_LOADER,\n  COMPLETE_LOADER,\n} from './module.actions'\n\nconst initialState = {\n  loaders: null,\n  token: undefined,\n  temporalExtent: [new Date(1970), new Date()],\n  highlightTemporalExtent: null,\n  onViewportChange: undefined,\n  onHover: undefined,\n  onClick: undefined,\n  onLoadStart: undefined,\n  onLoadComplete: undefined,\n  onClosePopup: undefined,\n  onAttributionsChange: undefined,\n}\n\nconst moduleReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case INIT_MODULE: {\n      return {\n        ...state,\n        ...action.payload,\n      }\n    }\n\n    case SET_TEMPORAL_EXTENT: {\n      return {\n        ...state,\n        temporalExtent: action.payload,\n      }\n    }\n\n    case SET_HIGHLIGHT_TEMPORAL_EXTENT: {\n      return {\n        ...state,\n        highlightTemporalExtent: action.payload,\n      }\n    }\n\n    case START_LOADER: {\n      const loaders = state.loaders !== null ? [...state.loaders] : []\n      loaders.push(action.payload)\n      return { ...state, loaders }\n    }\n\n    case COMPLETE_LOADER: {\n      const loaders = [...state.loaders]\n      const loaderIndex = loaders.findIndex((l) => l === action.payload)\n      loaders.splice(loaderIndex, 1)\n      return { ...state, loaders }\n    }\n\n    default:\n      return state\n  }\n}\n\nconst moduleTypes = {\n  loaders: PropTypes.arrayOf(PropTypes.number),\n  token: PropTypes.string,\n  temporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  onViewportChange: PropTypes.func,\n  onHover: PropTypes.func,\n  onClick: PropTypes.func,\n  onLoadStart: PropTypes.func,\n  onLoadComplete: PropTypes.func,\n  onClosePopup: PropTypes.func,\n  onAttributionsChange: PropTypes.func,\n}\n\nexport default withReducerTypes('module', moduleTypes)(moduleReducer)\n","import PropTypes from 'prop-types'\nimport { trackTypes } from '../proptypes/tracks'\nimport withReducerTypes from '../utils/withReducerTypes'\n\nimport { ADD_TRACK, UPDATE_TRACK, REMOVE_TRACK } from './tracks.actions'\n\nconst initialState = {\n  data: [],\n}\n\nconst tracksReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case ADD_TRACK: {\n      const data = [...state.data, action.payload]\n      return { ...state, data }\n    }\n\n    case UPDATE_TRACK: {\n      const trackData = action.payload\n      const data = state.data.map((track) => {\n        if (track.id !== trackData.id) return track\n        return {\n          ...track,\n          ...trackData,\n        }\n      })\n      return { ...state, data }\n    }\n\n    case REMOVE_TRACK: {\n      const removedTrackId = action.payload.trackId\n      const data = state.data.filter((track) => track.id !== removedTrackId)\n      return { ...state, data }\n    }\n\n    default:\n      return state\n  }\n}\n\nconst tracksTypes = {\n  data: PropTypes.arrayOf(\n    PropTypes.exact({\n      ...trackTypes,\n      data: PropTypes.object,\n      timelineBounds: PropTypes.array,\n      geoBounds: PropTypes.exact({\n        minLat: PropTypes.number,\n        minLng: PropTypes.number,\n        maxLat: PropTypes.number,\n        maxLng: PropTypes.number,\n      }),\n    })\n  ),\n}\n\nexport default withReducerTypes('tracks', tracksTypes)(tracksReducer)\n","import uniq from 'lodash/uniq'\nimport {\n  INIT_HEATMAP_LAYERS,\n  UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES,\n  ADD_HEATMAP_LAYER,\n  UPDATE_HEATMAP_LAYER_STYLE,\n  REMOVE_HEATMAP_LAYER,\n  ADD_REFERENCE_TILE,\n  UPDATE_HEATMAP_TILE,\n  RELEASE_HEATMAP_TILES,\n  HIGHLIGHT_VESSELS,\n  UPDATE_LOADED_TILES,\n  HIGHLIGHT_CLICKED_VESSEL,\n  CLEAR_HIGHLIGHT_CLICKED_VESSEL,\n} from './heatmap.actions'\n\nconst initialState = {\n  // a dict of heatmap layers (key is layer id)\n  // each containing data, url, tiles, visibleTemporalExtentsIndices\n  heatmapLayers: {},\n  // store a list of tiles currently visible in the map\n  // those are necessary when adding a new layer to know which tiles need to be loaded\n  referenceTiles: [],\n  highlightedVessels: { isEmpty: true },\n  highlightedClickedVessel: null,\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case INIT_HEATMAP_LAYERS: {\n      return Object.assign({}, state, { heatmapLayers: action.payload })\n    }\n\n    case UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES: {\n      const heatmapLayers = state.heatmapLayers\n      let indices = heatmapLayers[action.payload.layerId].visibleTemporalExtentsIndices\n      indices = uniq(indices.concat(action.payload.indicesAdded))\n      heatmapLayers[action.payload.layerId].visibleTemporalExtentsIndices = indices\n      return Object.assign({}, state, heatmapLayers)\n    }\n\n    case ADD_HEATMAP_LAYER: {\n      const heatmapLayers = Object.assign({}, state.heatmapLayers, {\n        [action.payload.id]: {\n          tiles: [],\n          ...action.payload,\n        },\n      })\n      return Object.assign({}, state, { heatmapLayers })\n    }\n\n    case UPDATE_HEATMAP_LAYER_STYLE: {\n      const newLayer = action.payload\n      const layer = { ...state.heatmapLayers[newLayer.id], ...newLayer }\n      const heatmapLayers = { ...state.heatmapLayers, [newLayer.id]: layer }\n      return { ...state, heatmapLayers }\n    }\n\n    case REMOVE_HEATMAP_LAYER: {\n      const heatmapLayers = Object.assign({}, state.heatmapLayers)\n      delete heatmapLayers[action.payload.layerId]\n      return Object.assign({}, state, { heatmapLayers })\n    }\n\n    case ADD_REFERENCE_TILE: {\n      return Object.assign({}, state, { referenceTiles: [...state.referenceTiles, action.payload] })\n    }\n\n    case UPDATE_HEATMAP_TILE: {\n      const layerId = action.payload.layerId\n      const newTile = action.payload.tile\n      const layer = { ...state.heatmapLayers[layerId] }\n      let layerTiles = [...layer.tiles]\n      const tileIndex = layerTiles.findIndex((t) => t.uid === newTile.uid)\n      if (tileIndex === -1) {\n        layerTiles.push(newTile)\n      } else {\n        layerTiles = [layerTiles.slice(0, tileIndex), newTile, layerTiles.slice(tileIndex + 1)]\n      }\n      layer.tiles = layerTiles\n      const heatmapLayers = { ...state.heatmapLayers, [layerId]: layer }\n      return { ...state, heatmapLayers }\n    }\n\n    case RELEASE_HEATMAP_TILES: {\n      const uids = action.payload\n\n      // remove tiles\n      const layerIds = Object.keys(state.heatmapLayers)\n      const heatmapLayers = { ...state.heatmapLayers }\n      layerIds.forEach((layerId) => {\n        const prevLayer = { ...heatmapLayers[layerId] }\n        uids.forEach((tileUid) => {\n          const releasedTileIndex = prevLayer.tiles.findIndex((tile) => tile.uid === tileUid)\n          if (releasedTileIndex > -1) {\n            // console.log('releasing', layerId, tileUid);\n            prevLayer.tiles.splice(releasedTileIndex, 1)\n          }\n        })\n      })\n\n      // remove reference tiles\n      let referenceTiles = [...state.referenceTiles]\n      uids.forEach((tileUid) => {\n        const releasedRefTileIndex = referenceTiles.findIndex((tile) => tile.uid === tileUid)\n        if (releasedRefTileIndex > -1) {\n          referenceTiles = [\n            ...referenceTiles.slice(0, releasedRefTileIndex),\n            ...referenceTiles.slice(releasedRefTileIndex + 1),\n          ]\n        }\n      })\n\n      return { ...state, heatmapLayers, referenceTiles }\n    }\n\n    case UPDATE_LOADED_TILES: {\n      const newHeatmapLayers = { ...state.heatmapLayers }\n      return { ...state, heatmapLayers: newHeatmapLayers }\n    }\n\n    case HIGHLIGHT_VESSELS: {\n      return Object.assign({}, state, { highlightedVessels: action.payload })\n    }\n\n    case HIGHLIGHT_CLICKED_VESSEL: {\n      return { ...state, highlightedClickedVessel: action.payload }\n    }\n\n    case CLEAR_HIGHLIGHT_CLICKED_VESSEL: {\n      return { ...state, highlightedClickedVessel: null }\n    }\n\n    default:\n      return state\n  }\n}\n","import uniq from 'lodash/uniq'\nimport {\n  SET_CURRENTLY_VISIBLE_TILES,\n  SET_CURRENTLY_LOADED_TILES,\n  SET_CURRENTLY_SWAPPED_TILE_UIDS,\n  MARK_TILES_UIDS_AS_LOADED,\n  RELEASE_MARKED_TILES_UIDS,\n} from './heatmapTiles.actions'\n\nconst initialState = {\n  currentVisibleTiles: [],\n  currentLoadedTiles: [],\n  currentToLoadTileUids: [],\n  currentToReleaseTileUids: [],\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case SET_CURRENTLY_VISIBLE_TILES: {\n      const currentVisibleTiles = [].concat(action.payload)\n      return { ...state, currentVisibleTiles }\n    }\n\n    case SET_CURRENTLY_LOADED_TILES: {\n      const currentLoadedTiles = [].concat(action.payload)\n      return { ...state, currentLoadedTiles }\n    }\n\n    case SET_CURRENTLY_SWAPPED_TILE_UIDS: {\n      const currentToLoadTileUids = uniq(\n        state.currentToLoadTileUids.concat(action.payload.tilesToLoadUids)\n      )\n      const currentToReleaseTileUids = uniq(\n        state.currentToReleaseTileUids.concat(action.payload.tilesToReleaseUids)\n      )\n      // clean to load tiles of tiles that needs to be released\n      const newToLoadTilesUids = currentToLoadTileUids.filter(\n        (tileUid) => currentToReleaseTileUids.indexOf(tileUid) === -1\n      )\n      return { ...state, currentToLoadTileUids: newToLoadTilesUids, currentToReleaseTileUids }\n    }\n\n    case MARK_TILES_UIDS_AS_LOADED: {\n      const currentToLoadTileUids = state.currentToLoadTileUids\n      const tileUidsMarkedAsLoaded = action.payload\n      const newCurrentToLoadTileUids = currentToLoadTileUids.filter(\n        (tileUid) => tileUidsMarkedAsLoaded.indexOf(tileUid) === -1\n      )\n      return { ...state, currentToLoadTileUids: newCurrentToLoadTileUids }\n    }\n\n    case RELEASE_MARKED_TILES_UIDS: {\n      return { ...state, currentToReleaseTileUids: [] }\n    }\n\n    default:\n      return state\n  }\n}\n","import FlyToInterpolator from 'react-map-gl/dist/es5/utils/transition/viewport-fly-to-interpolator'\nimport { easeCubic } from 'd3-ease'\nimport { MIN_ZOOM_LEVEL, MAX_ZOOM_LEVEL } from '../config'\nimport { TRANSITION_TYPE } from '../constants'\nimport {\n  SET_VIEWPORT,\n  UPDATE_VIEWPORT,\n  SET_ZOOM_INCREMENT,\n  SET_MOUSE_LAT_LONG,\n  TRANSITION_END,\n  SET_NATIVE_VIEWPORT,\n} from './viewport.actions'\n\nconst DEFAULT_TRANSITION = {\n  transitionDuration: 500,\n  transitionInterpolator: new FlyToInterpolator(),\n  transitionEasing: easeCubic,\n}\n\nconst initialState = {\n  viewport: {\n    latitude: 0,\n    longitude: 0,\n    zoom: 3,\n    bearing: 0,\n    pitch: 0,\n    width: 1000,\n    height: 800,\n  },\n  maxZoom: MAX_ZOOM_LEVEL,\n  minZoom: MIN_ZOOM_LEVEL,\n  prevZoom: 3,\n  currentTransition: null,\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case SET_VIEWPORT: {\n      return {\n        ...state,\n        viewport: action.payload,\n        canZoomIn: action.payload.zoom < state.maxZoom,\n        canZoomOut: action.payload.zoom > state.minZoom,\n        prevZoom: state.viewport.zoom,\n      }\n    }\n\n    case UPDATE_VIEWPORT: {\n      const viewport = { ...state.viewport, ...action.payload }\n      return {\n        ...state,\n        viewport,\n        prevZoom: viewport.zoom,\n      }\n    }\n\n    case SET_ZOOM_INCREMENT: {\n      const currentZoom = state.viewport.zoom\n      const zoom = Math.min(\n        state.maxZoom,\n        action.payload.zoom || currentZoom + action.payload.increment\n      )\n      const viewport = {\n        ...state.viewport,\n        ...DEFAULT_TRANSITION,\n        zoom,\n        latitude:\n          action.payload.latitude === null ? state.viewport.latitude : action.payload.latitude,\n        longitude:\n          action.payload.longitude === null ? state.viewport.longitude : action.payload.longitude,\n      }\n      return {\n        ...state,\n        viewport,\n        canZoomIn: zoom < state.maxZoom,\n        canZoomOut: zoom > state.minZoom,\n        prevZoom: state.viewport.zoom,\n        currentTransition: TRANSITION_TYPE.ZOOM,\n      }\n    }\n\n    case SET_MOUSE_LAT_LONG: {\n      return { ...state, mouseLatLong: action.payload }\n    }\n\n    case TRANSITION_END: {\n      return { ...state, currentTransition: null }\n    }\n\n    case SET_NATIVE_VIEWPORT: {\n      return { ...state, ...action.payload }\n    }\n\n    default:\n      return state\n  }\n}\n","import { fromJS } from 'immutable'\nimport uniq from 'lodash/uniq'\nimport GL_STYLE from './gl-styles/style.json'\nimport {\n  SET_MAP_STYLE,\n  MARK_CARTO_LAYERS_AS_INSTANCIATED,\n  INIT_MAP_STYLE,\n  SET_STATIC_LAYERS,\n  SET_BASEMAP_LAYERS,\n} from './style.actions'\n\nconst attributions = uniq(\n  Object.keys(GL_STYLE.sources)\n    .map((sourceKey) => GL_STYLE.sources[sourceKey].attribution)\n    .filter((source) => source !== undefined)\n)\n\nconst setStyleDefaults = (style) => {\n  style.layers.forEach((layer) => {\n    if (layer.layout === undefined) {\n      layer.layout = {}\n    }\n    if (layer.paint === undefined) {\n      layer.paint = {}\n    }\n    // initialize time filter for time-filterable layers\n    if (layer.metadata && layer.metadata['gfw:temporal'] === true) {\n      // is this field always called 'timestamp'\n      layer.filter = ['all', ['>', 'timestamp', 0], ['<', 'timestamp', 999999999999]]\n    }\n    // set all layers to not visible except layers explicitely marked as visible (default basemap)\n    if (layer.layout.visibility !== 'visible') {\n      layer.layout.visibility = 'none'\n    }\n  })\n  return style\n}\n\nconst initialState = {\n  mapStyle: fromJS(setStyleDefaults(GL_STYLE)),\n  cartoLayersInstanciated: [],\n  staticLayers: [],\n  basemapLayers: [],\n  attributions,\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case INIT_MAP_STYLE: {\n      const newMapStyle = state.mapStyle.setIn(['glyphs'], action.payload.glyphsPath)\n      return { ...state, mapStyle: newMapStyle }\n    }\n    case SET_MAP_STYLE: {\n      return { ...state, mapStyle: action.payload }\n    }\n    case SET_STATIC_LAYERS: {\n      return { ...state, staticLayers: action.payload }\n    }\n    case SET_BASEMAP_LAYERS: {\n      return { ...state, basemapLayers: action.payload }\n    }\n    case MARK_CARTO_LAYERS_AS_INSTANCIATED: {\n      const cartoLayersInstanciated = [...state.cartoLayersInstanciated, ...action.payload]\n      return { ...state, cartoLayersInstanciated }\n    }\n    default:\n      return state\n  }\n}\n","// TODO MAP MODULE remove whole reducer\nimport { SET_MAP_CURSOR } from './interaction.actions'\n\nconst initialState = {\n  cursor: 'progress',\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case SET_MAP_CURSOR: {\n      return { ...state, cursor: action.payload }\n    }\n    default:\n      return state\n  }\n}\n","import { combineReducers } from 'redux'\n\nimport ModuleReducer from '../module/module.reducer'\nimport TracksReducer from '../tracks/tracks.reducer'\nimport HeatmapReducer from '../heatmap/heatmap.reducer'\nimport HeatmapTilesReducer from '../heatmap/heatmapTiles.reducer'\nimport ViewportReducer from '../glmap/viewport.reducer'\nimport StyleReducer from '../glmap/style.reducer'\nimport InteractionReducer from '../glmap/interaction.reducer'\n\nconst mapReducer = combineReducers({\n  module: ModuleReducer,\n  tracks: TracksReducer,\n  heatmap: HeatmapReducer,\n  heatmapTiles: HeatmapTilesReducer,\n  style: StyleReducer,\n  viewport: ViewportReducer,\n  interaction: InteractionReducer,\n})\n\nexport default mapReducer\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { combineReducers } from 'redux'\nimport { Provider } from 'react-redux'\nimport throttle from 'lodash/throttle'\nimport { trackTypes } from './proptypes/tracks'\nimport { heatmapLayerTypes, basemapLayerTypes, staticLayerTypes } from './proptypes/layers'\nimport { viewportTypes, popupTypes } from './proptypes/shared'\n\nimport Map from './glmap/Map.container'\nimport { initModule, setTemporalExtent, setHighlightTemporalExtent } from './module/module.actions'\nimport { updateViewport, transitionToZoom } from './glmap/viewport.actions'\nimport { initStyle, commitStyleUpdates, applyTemporalExtent } from './glmap/style.actions'\nimport { updateTracks } from './tracks/tracks.actions'\nimport { updateHeatmapLayers, updateLayerLoadTemporalExtents } from './heatmap/heatmap.actions'\n\nimport store from './store'\nimport mapReducers from './store/reducers'\n\nconst mapReducer = combineReducers({\n  map: mapReducers,\n})\n\nstore.replaceReducer(mapReducer)\n\nconst throttleApplyTemporalExtent = throttle((temporalExtent) => {\n  store.dispatch(applyTemporalExtent(temporalExtent))\n  store.dispatch(setTemporalExtent(temporalExtent))\n}, 16)\n\nconst updateViewportFromIncomingProps = (incomingViewport) => {\n  store.dispatch(\n    updateViewport({\n      latitude: incomingViewport.center[0],\n      longitude: incomingViewport.center[1],\n      zoom: incomingViewport.zoom,\n    })\n  )\n}\n\nclass MapModule extends React.Component {\n  state = {\n    initialized: false,\n    error: null,\n    errorInfo: null,\n  }\n\n  componentDidCatch(error, errorInfo) {\n    console.log(error, errorInfo)\n    this.setState({\n      error: error,\n      errorInfo: errorInfo,\n    })\n  }\n\n  componentDidMount() {\n    // First trigger synchronous actions that should happen before any map render\n    // At the end of this, set a flag to allow map rendering\n\n    if (this.props.viewport !== undefined) {\n      updateViewportFromIncomingProps(this.props.viewport)\n    }\n\n    // TODO\n    if (this.props.glyphsPath !== null) {\n      store.dispatch(\n        initStyle({\n          glyphsPath: this.props.glyphsPath,\n          // TODO apply URL updates here\n        })\n      )\n    }\n\n    if (this.props.onAttributionsChange !== undefined) {\n      this.props.onAttributionsChange(store.getState().map.style.attributions)\n    }\n\n    if (store && store.getState().map.module.token === undefined) {\n      store.dispatch(\n        initModule({\n          token: this.props.token,\n          onViewportChange: this.props.onViewportChange,\n          onHover: this.props.onHover,\n          onClick: this.props.onClick,\n          onLoadStart: this.props.onLoadStart,\n          onLoadComplete: this.props.onLoadComplete,\n          onClosePopup: this.props.onClosePopup,\n          onAttributionsChange: this.props.onAttributionsChange,\n        })\n      )\n    }\n\n    if (this.props.highlightTemporalExtent !== null && this.props.highlightTemporalExtent.length) {\n      store.dispatch(setHighlightTemporalExtent(this.props.highlightTemporalExtent))\n    }\n\n    if (\n      (this.props.basemapLayers !== null && this.props.basemapLayers.length) ||\n      (this.props.staticLayers !== null && this.props.staticLayers.length)\n    ) {\n      store.dispatch(\n        commitStyleUpdates(this.props.staticLayers || [], this.props.basemapLayers || [])\n      )\n    }\n\n    if (this.props.tracks !== null) {\n      store.dispatch(updateTracks(this.props.tracks))\n    }\n\n    // Now trigger async actions\n\n    if (this.props.temporalExtent !== null && this.props.temporalExtent.length) {\n      throttleApplyTemporalExtent(this.props.temporalExtent)\n    }\n\n    // eslint-disable-next-line react/no-did-mount-set-state\n    this.setState({\n      initialized: true,\n    })\n\n    // heatmap layers\n    if (this.props.heatmapLayers !== null) {\n      store.dispatch(updateHeatmapLayers(this.props.heatmapLayers, this.props.loadTemporalExtent))\n    }\n  }\n\n  componentDidUpdate(prevProps) {\n    // tracks\n    if (this.props.tracks !== prevProps.tracks) {\n      store.dispatch(updateTracks(this.props.tracks))\n    }\n\n    // heatmap layers\n    if (this.props.heatmapLayers !== prevProps.heatmapLayers) {\n      store.dispatch(updateHeatmapLayers(this.props.heatmapLayers, this.props.loadTemporalExtent))\n    }\n\n    // basemap / static layers\n    if (\n      (this.props.basemapLayers !== null && this.props.basemapLayers.length) ||\n      (this.props.staticLayers !== null && this.props.staticLayers.length)\n    ) {\n      store.dispatch(\n        commitStyleUpdates(this.props.staticLayers || [], this.props.basemapLayers || [])\n      )\n    }\n\n    // loadTemporalExtent\n    if (this.props.loadTemporalExtent !== null && this.props.loadTemporalExtent.length) {\n      if (\n        prevProps.loadTemporalExtent === null ||\n        !prevProps.loadTemporalExtent.length ||\n        this.props.loadTemporalExtent[0].getTime() !== prevProps.loadTemporalExtent[0].getTime() ||\n        this.props.loadTemporalExtent[1].getTime() !== prevProps.loadTemporalExtent[1].getTime()\n      ) {\n        store.dispatch(updateLayerLoadTemporalExtents(this.props.loadTemporalExtent))\n      }\n    }\n    // temporalExtent\n    if (this.props.temporalExtent !== null && this.props.temporalExtent.length) {\n      if (\n        prevProps.temporalExtent === null ||\n        !prevProps.temporalExtent.length ||\n        this.props.temporalExtent[0].getTime() !== prevProps.temporalExtent[0].getTime() ||\n        this.props.temporalExtent[1].getTime() !== prevProps.temporalExtent[1].getTime()\n      ) {\n        throttleApplyTemporalExtent(this.props.temporalExtent)\n      }\n    }\n\n    // highlightTemporalExtent\n    if (this.props.highlightTemporalExtent !== null && this.props.highlightTemporalExtent.length) {\n      if (\n        prevProps.highlightTemporalExtent === null ||\n        !prevProps.highlightTemporalExtent.length ||\n        this.props.highlightTemporalExtent[0].getTime() !==\n          prevProps.highlightTemporalExtent[0].getTime() ||\n        this.props.highlightTemporalExtent[1].getTime() !==\n          prevProps.highlightTemporalExtent[1].getTime()\n      ) {\n        store.dispatch(setHighlightTemporalExtent(this.props.highlightTemporalExtent))\n      }\n    } else {\n      if (this.props.highlightTemporalExtent !== prevProps.highlightTemporalExtent) {\n        store.dispatch(setHighlightTemporalExtent(this.props.highlightTemporalExtent))\n      }\n    }\n\n    // viewport - since viewport will be updated internally to the module,\n    // we have to compare incoming props to existing viewport in store, ie:\n    // update viewport from incoming props ONLY if zoom or center is different\n    // from the internally stored one\n    // TODO FFS incoming lat lon should be an object, not an array\n    const currentViewport = store.getState().map.viewport.viewport\n    //                                        stop propagating updates from outside when zooming in\n    if (\n      this.props.viewport !== undefined &&\n      store.getState().map.viewport.currentTransition === null\n    ) {\n      if (\n        currentViewport.latitude !== this.props.viewport.center[0] ||\n        currentViewport.longitude !== this.props.viewport.center[1] ||\n        currentViewport.zoom !== this.props.viewport.zoom\n      ) {\n        // if zoom delta is precisely === 1, zoom with a transition\n        if (Math.abs(currentViewport.zoom - this.props.viewport.zoom) === 1) {\n          store.dispatch(transitionToZoom(this.props.viewport.zoom))\n        } else {\n          updateViewportFromIncomingProps(this.props.viewport)\n        }\n      }\n    }\n  }\n  render() {\n    if (this.state.error !== null) {\n      console.log(this.state.error)\n      return (\n        <div>\n          <h2>Map component crashed!</h2>\n          <p className=\"red\">{this.state.error && this.state.error.toString()}</p>\n          <div>Component Stack Error Details:</div>\n          <p className=\"red\">{this.state.errorInfo.componentStack}</p>\n        </div>\n      )\n    }\n    // won't render anything before actions in componentDidMount have been triggered\n    return this.state.initialized !== true ? null : (\n      <Provider store={store}>\n        <Map {...this.props} />\n      </Provider>\n    )\n  }\n}\n\nMapModule.propTypes = {\n  token: PropTypes.string,\n  viewport: PropTypes.shape(viewportTypes).isRequired,\n  tracks: PropTypes.arrayOf(PropTypes.exact(trackTypes)),\n  heatmapLayers: PropTypes.arrayOf(PropTypes.shape(heatmapLayerTypes)),\n  temporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  highlightTemporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  loadTemporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  basemapLayers: PropTypes.arrayOf(PropTypes.shape(basemapLayerTypes)),\n  staticLayers: PropTypes.arrayOf(PropTypes.shape(staticLayerTypes)),\n  // customLayers\n  hoverPopup: PropTypes.shape(popupTypes),\n  clickPopup: PropTypes.shape(popupTypes),\n  glyphsPath: PropTypes.string,\n  onViewportChange: PropTypes.func,\n  onLoadStart: PropTypes.func,\n  onLoadComplete: PropTypes.func,\n  onClick: PropTypes.func,\n  onHover: PropTypes.func,\n  onAttributionsChange: PropTypes.func,\n  onClosePopup: PropTypes.func,\n}\n\nMapModule.defaultProps = {\n  token: null,\n  glyphsPath: null,\n  highlightTemporalExtent: null,\n  tracks: null,\n  hoverPopup: null,\n  clickPopup: null,\n  heatmapLayers: null,\n  temporalExtent: null,\n  loadTemporalExtent: null,\n  basemapLayers: null,\n  staticLayers: null,\n  onViewportChange: () => {},\n  onLoadStart: () => {},\n  onLoadComplete: () => {},\n  onClick: () => {},\n  onHover: () => {},\n  onAttributionsChange: () => {},\n  onClosePopup: () => {},\n}\n\nexport default MapModule\n","import GL_STYLE from '../glmap/gl-styles/style.json'\n\nconst AVAILABLE_BASEMAPS = GL_STYLE.metadata['gfw:basemap-layers']\n\nexport default AVAILABLE_BASEMAPS\n","\n  import React from 'react'\n  import { MDXTag } from '@mdx-js/tag'\n  import { Playground, PropsTable } from 'docz'\nimport Map from './index.js'\n\nconst layoutProps = {\n  \n};\nexport default class MDXContent extends React.Component {\n  constructor(props) {\n    super(props)\n    this.layout = null\n  }\n  render() {\n    const { components, ...props } = this.props\n\n    return <MDXTag\n             name=\"wrapper\"\n             \n             components={components}>\n<MDXTag name=\"h1\" components={components} props={{\"id\":\"map\"}}>{`Map`}</MDXTag>\n<MDXTag name=\"h2\" components={components} props={{\"id\":\"description\"}}>{`Description`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`This component displays and load fishing activity and fishing-related layers on a map, used in various GFW projects:`}</MDXTag>\n<MDXTag name=\"ul\" components={components}>\n<MDXTag name=\"li\" components={components} parentName=\"ul\"><MDXTag name=\"a\" components={components} parentName=\"li\" props={{\"href\":\"https://github.com/GlobalFishingWatch/map-client/blob/9c5179358d4870c0fd4c2c0742917e72e6025c59/app/src/map/components/MapWrapper.jsx#L5\"}}>{`Map client`}</MDXTag></MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\"><MDXTag name=\"a\" components={components} parentName=\"li\" props={{\"href\":\"https://github.com/GlobalFishingWatch/vessel-profiles/blob/aa0e17395f6a4947bb3fdf3106cb9d0a744ba64f/src/profile/components/MapWrapper.js#L3\"}}>{`Vessel profiles`}</MDXTag></MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\"><MDXTag name=\"a\" components={components} parentName=\"li\" props={{\"href\":\"https://github.com/GlobalFishingWatch/data-portal/blob/96b1e24efcff58ade672a67229da0610d9d241ab/src/map/MapWrapper.jsx#L2\"}}>{`Data portal`}</MDXTag></MDXTag>\n</MDXTag>\n<MDXTag name=\"h2\" components={components} props={{\"id\":\"available-properties\"}}>{`Available properties`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`TODO: fix crash on PropsTable docz component`}</MDXTag>\n<MDXTag name=\"h2\" components={components} props={{\"id\":\"basic-usage\"}}>{`Basic usage`}</MDXTag>\n<Playground __codesandbox={`N4IgZglgNgpgziAXKCA7AJjAHgOgBYAuAtlEqAMYD2qBMNSIAPOhAG4AEE6AvADogAnSpQL8AfIwD0LVmJABfADQg0mXACsEyEFRp0CDSQCojvVO3YAVPBDjsAwpUwBlAIYYARpSzs8rux4wdOyuAK4ElESuBBDkrlBQAJ7sAOZ0MALRMOjsoXBoKWYWAAZUmHDu6F5YGcU47ACSYOyJlKEA5AIw7OShAhBtdniUAO7sBH4Evq4ADjPp6IotbT3uRT14MOQA1uxtU20C7OiU5EMZMIi-BAQzcIiSkikQE6EeOFREkqiUrGiJkjK8Eq1QyZnWTWWoXY2Hm_To5G67mScAIAlCKRSsDsIxeeHGNjsFU83iWM1g_m6mVsSPMtjgoRg62oqTxb3qiAAlGYjJIzBAiDNKAIpgAlGCuchTMBCIjsToSqXtADc_MFwrFioIABEAPIAWXYMsi8q6koIAFoTkQVWqhSKHJEhah9EbZfKcJJsK5BbBbagzOLzXr9TguhgMgAKdbMNhidYWRh4ADMYkc6pdNE46pF2XYuImPScwJJNQEiCkKfj5gs7EYMzEkYaUyiyRdedc6BYMWo8XYMyEd3GlFSMCmL3Y4cw_VQKXzMASnKkDYTdfTztdkmriekccUZhOvSI-hwaQIAFFYMeaAAhRINdCRzrCAjtbmoTnKhTKb2-mA4TQyB0ahaHoRAVBzKZ9VmN0TXaT04AEchJCiGZJFUbAALgf0BXtTVzVguUFXNdo7Q1dhgHYTQfHkQj5QAARgIgRAGVBAWFGBSIDVBdFRY5TgAL2cAhEmxdhuAo9YogEZ5UCudoAAZ2GTGYsHafcaxmTsWFneSABZVPYAA2VT1PWMAQIAMR9aBEnk_hnEORFHUwdgAAUhH4JZmJ-OAtMRMyawsmhnAgATLnYABGPSNPkcEeOoPiAEE5nE9hI0o8gbCgdBw3YeROXEsR0pjGR2FRUSYG4YBDyEkTsXkbda2ALLoFy4IADIOvGRJ5koZpWpyvLuBG-UwFCHie1Qdp2AAfg2Nrw0jQqrkG9rUDimspBkat3zMWFyMwMAwigKZlqKkqtpSlca0TIMpRwSzMhSa8CCa2s62gmZ2D-GARjw6rMv0DIrgAbQUnAFIAJiMpZIqh5McCMyKAF0lgE4QiCuABWfLaK3VcpHughHue16mqka7drMb8QEQ5DUPQiMNC0CgQP0BgDodSijpOqZaONIjPVQriuamSiCFcGSxy-gA1eA4AXfK6PgyRUQ40WsDwijjhgY7QlOkI7CS2WkoaAAZJKb3N88AH0byS5xz31JK3OcZXBY9SQPEpVDsJppQ6aQlDZhDmYsKA3RQIMcDcPI4mVbNJUyIdDzKBmSxevgFWB3Ti0RPmf3UDj7miyIDw0BgcV0FCREBDsAX3QVGu1JT8X3KEP5pw9puk8tLoW64kupgmIQblgFWoCcfw8EkUeRAIP0251tFJW2TPC57uDPVzmYC_gOfMh2Ivh51zZolQ83XESDIN_gJYfcVy_r9vrO4CWVFoliK-b4EO-G5VjvQc-84CSCgC_euQ9II61-v9DU_8yTp1CBnN-W8haSF3iAtWfgB5cWXl9QBTwoCMy-h8ECrhK4CCgdrSiaAXj6icAbGAH8xyWCYvaeI54sDRxYQQAAEhAFIeAoCCMIGwnMnDuGukbtvFCjDYByJrrAHA5pWIn2gZRZB6AsiywgH9PCSxV6oHyFNSwlAABamM0FeyxIzWBeEVFSjUdQ8itDi4EGEpVJYnwiAvE8bAAAqjMbRtB34hDmEkcRHCoBcOjtY1WtjQ4VWUaoxKLjS5aKyJYI-2wAGe1VqvY-h815wEcVNdRNDcjBKyHwiUxBZg_wyGEzJtBGkCHNpQTsUThSSOjnkpunpz71LQkM1CZTnHxVPurLohDpmcWXqhautcmmzIiF0SQA9lmQPirxFsswll1zSp8CuLoDlNIylJWYVxFnZC2e_MwBV4pzLDDAckkoq63LrpGG5Nc657QSsYkeeAx6LxgNdSJ7CekxKkVmCS89x4wEjJGWgEjoXR0KtwYqwB1jPJYH5aIWVIyzHJIkbpmQ0X6GRZC8lsT9CcnfBYXFtgtIEEJYrAgZLemUpRdE2lNB6UPLhkZf5uyqkhJgLo_RGonqRAaAlXxs405DgkpGNAnwCiSrgSKDFWKcVrP_HillhLVwtIlXorVBALm3VrOAmIBBQiYCuGqyIGrzUOMRHoAQ4M0argsFPWcLwHURWdQqlImr3XAy9ajDSH0LAY0iE6-VrqpUihwPGogMbayPJrO-TaZhyDgLgHYL6DClHdGwKBdAdhiY4HXNQV02Kayf1oGlRtH06ExHiGFbIVxjpQEVpmiwGQhDlnYKgA2UBB0wgECOuVFkrjjoSJmvNNZPgbhoNqLg9gCV4EjMO4USx90CDnZQQqbbay8UoMoqeKQ90zoPdO2dqALIMtrBMWwOB2XCSyFa2Nj7hRXCPVOod97j3PsoIB0DJ6p3ZosCuiwa760bq4Awialqz2rkeOwSyEB64j36JiDI5VEg8WBdQQYIQnGJQJNEcqwwDY5D8HMYIgQLIzOROwVCk46DTkw5IdgSUgXlowHsZo76wnspCEacBc4IghASKMTjMEpwZAKPFdtzRkWEhwLvUp9jyIAEJRoTSOpXdAGHrUWFNeG6Vso5XqsVYOOAWmP26ZwPp7Vq54O1iw5YXUepVwQE0-JnTTnTxJBmHgOAbloj4iMxJRdUALN_qZfi1lu7fW1g7f4xF56_0WCxL1KLMWJhXBC25wrkXouxeA7G3z_ndThJJewAJopzZiqyOcLomW4Ovo-n1_K6msvBe0256ggm0QQA8OENR9g_Czm6PF3IEZIAunM5JSzBJXNhfGzcfo03ylzfcGkSMzyzzftoMtHAYzkn_miJNg7aiBveYsEF9Kcz2BdXKvq08Y4LuIs5Nd2Y135H_giNsYII0JImb1mZ5LsbUtGoy5t177jS1MN_fliw4O6BldG2FnHqBasfWoDZkUR2Ft4-2-nUppO3Uagp2kYntZqB8N-CDLbpSxuoDZ6wDIzOLDUHsCInYVOuc7dQML2I2wBd7FQB0zs36RRi9CzTnA1AFfoCVwQWXGvOnoHXLAWgKvuea8N2OZhPWWeS6norNySCZgm4l8LygduHe69QBN_bM3EqM4iuViXXups--MX75nsHY3PaG69kb1O7j4FESIoRHLqVcqzEtxLn3uoB7VzYIRSexGp4pTQHAsBZwTHhx9RHO7TtjgEfn0RKfUV8stTn-PefhGN85cXggArrUvc4JpzLLnxdq8fkxBpEC7AZ4nVnznqv4_j-fr_UpZeUgV_YAAH038PtvpTm3fyn-wGfCQ5978_ZLGI5A2mr7oOvvAA3K-1mr-l6MKOy6-I8fVGAQTxXOfPwftfkftvuwKDGjPPm5kvpPivlvpvqASjANhYFHtxBpulOfoUrksfqNIlk_oyj9oajXqatkiUiPgvqUhgXAH3h9APlhgAHKKaTaEZHD-AkbkCUblLR6D5oH45q48pQot5YEJaz5fboFF4t6l534b55ZvpkYIrgqkpiEwqt48Hx58E0pKHIF8YwhwAiI0BWi2CuAeCwAWgujcIWi6FUhajfCUD6HoAWjMRoYWjspOGX5MjWohZfquGY7truIQBdrhToBlboiW797_IfRYajIwTgIr6Bax6j7t51LL4rIn5JYbYpb4HMqEHVK0C1IXzQHnLn6REzA36GIqGr767d4t5UFZrrDeaIaZg6hcC_4_oDgwCsBKqUFpE-b8YUGxHcFx7kE5LT6jStHtEE5DG4HfYcQ4AEGv5EFDGkFuYUHVFwacERGJFRFT59GLFhZFE36CH9hdBjG54bHFFT6TEv6Eqmq5HDI347EnF5FnEr6lEDGl4VGKHoqaHWpYZQHfT8aAHsDRFNLbG75lE4C_H7EpFn5gkQlT4SHl4P6wGgmvGAGQnYHCHZ5gmolwlr4V6rgXEZFpbGrv4-J-Lf7NGhL3Hx7YkwEgFgEvHxGlKwm0lwFgGIHsBfHhH8ZTxdIfH6DbHn48noCVFKEHGZ4iFglCkinRzwn36TFvZv5Y6jEdFvG8nN6ilQ5jqz7b5W4GbKlhZSl8kl64n4g6nv6CnvHqnRzeq_YcoCgA4HH6lq6GlWn6A2lniWD2nnRmlY4Wlqm8pKGgyoy2menHjnRLZOnx4ukBnWnBkelensmTF4HTGzFXHZEwBtKa7Sn6D_6SmWkxl0rsmbTUFaFqFp6iDWoKmiGunp7omn4SmvFlk96ylSGZYKlW6RnkFGlTCamZ4-n5Z6lHEqlNniEmlInmlgkjmBkKQowhkJmOlDkE7dnumsLzn9l_rVkFk0BBmznxlhmFQRmLm8HLlxmrn7mZZJkEggqwDyHZk0BUldk1m96ZbFk1EoHdG-CJ5d7dkClgkd4F5N5blTBQkNmMkJ4N7J53kkwmnylD7v6dngWd6QXdniR1lQDjlY6DltEqn_nflPktmmk74TmvG4XIVPkrl2n7mCFW4WAIWkWF7kUzlzlUXrmxqFFflkVAU7nMUOnxY0WHHYW7EcUMVcWnmUUA4XldHpEpmZGv7sr15IUiX8FKEPmIUAVQUrFvnUEwj9rdDSEx79FgX0WAXKVxKHmCW57CUmXqHopSUI6ElI6178JWVQWqXGUaVFleZrH8YeZTAWjlRqrdC-X5jQDoWBAda0A5BoC0ACCoDxBJDDgEjdDMRlpTpYYjDdB-B86JVrpSzdAhoFCHE06JXYC2AxCzg_T04OhoBTFdBLB6KIBaGmqVUprSjugFUVW6bsC6i0HmwACaXB6aewRwHqMVnAdgLAYAYAFwNAWhnsEw-VnqcVCQKI-qOQ9aWhfmeo2Glk7sHVc4tqgJLIcA9GOU7A4V7gewHg6gWwOuY6IgIQ5gUsmQiQq4oqvQM6-gZOPZtV_452XhgOYyvl7mVVFZXJWOENkNUNyZ30u8rgKQX8FVpqdgns-w-QrkIwmw5g6ahVaAIJm25-wVS2MOq2eYXUmWZ2f2ANQO4cwNH14YHKmQxiLwrEqFQhCQ-JdlBlip-W9NX1oNpeX89qrkS2hNAto1GQ3qGFvNfQDN31bxAawti2o0YtrVHwkaO50tf6fNNA8tQ1otYJwN6akl-lH5b2Q1mAp0rg41Al5ANICVmpkU6MViBY-I1tRiJirEVuCp0EEwKiHgzmOtBAetVi_lqtFqaamMGKo0kUl5yZXQMxslhKHtLN1AZilikQqlRtUd7JcGOlisXNsa1moNMqRA9mLqjmNOWdoNudg2m2r5qxNYr5KmAg500hVZ2mza_4R6YpE6kxl616lAt6HhrhOAR67JXQ9qsVl0WOsYsg_FSYUMYgBC9Rro5AmQJ12QBmlYS9C930Ba_gcAtBPoVU_AA84gwAI9WQY9oG0JH6XdN9I6OAEQwkM4t6nI8gy470-Wc9aYToSGUw36Ow7A54t92oY4FC_aFYu4897-iY-9haR9J9fAgg2QF9V9tAj9woJ6ZCGY-gQD2wn9GC39H020cYF5Xl3x_GIw1A7QUwLdj1iQ76FVrGHE7BainA5gq9yG6AqGWYWV3QgQwQjBaQ591qk9fQ5gGD_4HafhIiARBxaIjIc0Wpp-VwPNpDacXcRGcy1UcyjUVujABCwAOApje--MJDdYkgWjXAGQ39r6m0K6JaoOC-_8ra6whOVwSq_8F-b9mavlXjg4PjJ1swiKvl_8gOtg4oAAjqELhtkJmhQYE-nD489dfLqGAJGN42_GPVgOaMijkhE5yJmnsVPskygoXCojOuk5k9k5UyE_MJGKU7_EU4k92eU6k9U4kBk1k0Ezk2gJ_DxDAD09qFkPSiUy5e0x3Ckzk2k907U305UwM5LEMyM2M8U-sNGaZfoB07M10z03U_ADgMs-4IiGs7QOM-sMyU0rs5U3Mwc4s0cw04itc3_G_Jc02pfofivrc0c_cwszM_U0xoijSa_IXB8xYFhr0OrEQDfusMMHzgIPbjMMgr8_vsC5GEKCixU_ABs6uiLtsMi6i9Mzi-i6E5iw7hE5mpVsVrFmi74wUJmnTq1X7vS-NDxEy_LvrtrmyxNOQJy2bk6EbhFIc6Uuy_y8yDbtLryxy5K7zhzqKzgOK5y0Ho9r7vNmkDKxKzWELrbjAES47iSz48qw8vFM42WjMXrHzB0e4zWJ46o5OusDS9VqVg6xMxBUpTZTs26x40MQuhOiU-zkiw7v60uusAWtLga6G46zWM0zcz63a1M4lpmls16zQNG5mq8_cAm3gV_EAT8zm3Lt9ay-lDqhREoJK5rjy6WxdMABWzq1y52ObsbjW5iuW5y1LqLq21ivW4LjzkG-o2W3Wyq3tsHodhqxFOdG28O5Ky7m7ti4O7W_WyumLLrPrIbOa0wgHMoPTGHGrPqkzGoBHNoFHBzLHBomXEKAOj0GaLQMJBxEsMSkkPqFwOgLACMHlfEpsq3MXNAq8KgLsPkt-_nHgBNNsHgr-5UpABypQDeG0BgP0tvJ6IkmhMDaksYhB0bpe67jAOeKgPNnXHYBJIhorPyHBRYJi0IIiEWmPagKwDgC7G5LbKKOeNqAEgABrMfOy6iWB2zajng3gBIADisBRV1HpSdA9HLHSU9glgtsrsTHjHXHbHnHLH-oPHfHAnwnhU5NmkVHCstH9HtB_mds54tBssbN8omAfOU8Mwr0XE8O71_9isAA6niOA6wGYlekR9xrE_E0-F0MxLQBaMB9ZxEN52-Lg1ezAG5xMB515_2uG857h_h6cyssR8l7F3gPF8IP2t4WOiffJAQilUwoFB9GaKdPaUEYyFOsMKiHFcePJFPHEFAHV6-FOnhFcAABwKS9dTpRBYBJSavKQKRTpd1uC-HhSjqnauFlsZTsCmMX5ZDeRXI6yLcP2oRLBFHyTGdydOyigNBJTmwNDmKsczS0QFTLq5o7KJRTAfbEe3swD3tdBIpDtKDtvYeKx4cEfnJPuJAvtdjvt5VaZgf0r_KruiqSzSwEBywKxKwqpcBDtJeArjA5JpSU1f4_qA3A4UEzHRCuBKuqBIq94XQkxcCWdcDP2UCv0FDLSvqXG7rQdmJwcmb_45K_awfwdVp97rASPT0YHP32kWEs8IemvcSru8wGx3f6rbtBwMyhy_GgIYQsyRzsxgQQTaxCfmy2zOCWB9U2yALIfEKhxYguGVSgK3ZYS0M3co8mxmyWzWx2wOxOyMfuwSRa869682zXYQMhKuCgztApBgAjCIC_HmFT7tAozxQS9WtS8CamwWxWw2z2yOzOyuzOCy-7uMyYJvzFLHzHtsx6Dq-nyis5yDj5xvwQcQ-3eo9rxuMSTnpcD0uohv3HNwAxNxMDyZp9BQDN-TaziZp-_0uUDXW3WZpUBTyjqKst-MseNZzD8ug9MB9pCUCaC0NLAk1mYIEpsQJQXZuKv_O9OAt_P7MAuks4DjrlwZAQtGgvAi9Vq6iNuBFGs5NeBXqxSZ_BzZ_AK59An1wF_AQi-McDXuRFL75Jd4FfQuFXy1jkRRUcbN5pvAb7rAm-L_epv3xSBt8O-8TRYB42gDwAxwD4Pvn4xxRvB94RA2fjWD-D5AjCIrR5kyVy4lNGQ9LS_oEAEBMt_ILwOyKgKOYsD-c5kaADFX350CqmL1HpquGn4YtTaERZRkG36DlBASECXwMozezspMsoHWgcf1KS8C2BmWLDJAFOgZBZY8QRkHYFsBSYWAVGOKgIGSA1VMasQfEIqHxAQ4bBdga2voJiqGEJ4kABcDgM2xYZKgP0YwdnDMGXU5momeTOhSvbUCJ4rAIIXYEjC6hRQt_AwQIHZJYYGqyQmKkYKgAmCrgmULICkGFBcDQY2MJYEZBRh10_07gwwXEOH6j8pQMGV9HiwsDnxpwzfSQauB4xChoqQgzQernqE65As0WG8JZHpZv8Y2H0CfnADvDH1Gu3A2nAMKnRTk-k9LQ_gf1P5H9z-2gm_tjm7JwBzYCsMYQwNqKRN2-MAPzl32QGepVEfOI4e_zF77QYBDoUVK83r5dEUB0_dAf41sBTZYAdwmNiuyeFTBRUoLBAdnCQE1gPhwgmfrOEwHnDO-CTdYPVm2qMd2A6nNjgbwaB2AJgtGdsJgByABCVBI4TGq9UoE_CaB_wzNIrFgBSge08w8EscKbQLhbq2QSyHUj6DwB2h5LaQt4JyjkCB-q4WITkM5H0i1h0I9Ac0PyiSjjKdIxVuMPdYAVWR7IroL0PP7PN8uvI5_p8OIHWohRuQ0URsO1EFBJRl3ZkBwJEjMDQgV_HQauivQAZ6RMIlIFSOGAjAr4gQKBvSPlFXCPBTiW4Z6MZEWBqh9cVYYaOEFii-hjom_rYHsB5AIgWMf0fcKbSkD5-9I-tEv035rYlggfGAKvzgDr9TQ_gGKpH0lE99-RTo9YEP1TGLCnWvfKsTdQaFi9aYWfUODn0LjYI8q6AAAae2L7QIwBTcCASAmgHaxRUWLZBG8PPTdiCAzA4sDvztRBpLR1ouERcMRE1h_UzwJWguNYFLiERvgwEcOJr7hNUEEIuNJjE3F8DV0kaEMaILP4-NthH_VAE2K_4m9jeaEUhFHAoQugBAXYtXsANPiZRqALoKUF-y1AhdbkP7P8TezqRPdmRUoYUMBOpG3V0k7cQWAACl3YMiIiAKCIDhBPB8ySDq4isCigZOAAaWcC2xLYfVc8KKFtgNBaCtsSyKKB6pyddQlkW2EJ0YkBI3I8SUxuxGfSCIkJOsAtDhwNbcThYoORREwnGSJQsIAkyiB6SGI5ZEOQsT0BQTz65JP0MEtZKUk0CySlMMweVmwL0mdtdgGEr2NFQyDocpJxiGScvEojspvqhiJmp7WoB4ccgpk1WGh0sHaSKk5EAhPkk9BfQIOoqf6nm32Iqou6ZbDbsDkt6gi4ANvPiGeDlQ-iYgfONpA-B87r0oJzgTScKB5qgwQpV-G_D6hrB0ERAEUTYDMgypGwGQx4GjFMD_6NBtQdgXONoxyCu1OMoOJTOliSrsAteCgmAjiLu6nV0ASI_jOFXMlHwUp3QOCT8Dup6IeoMwWIPFWSALVkh6FBqW9mtrgJ3R_UojGYNaKKxZqNYGbqFPOJFRVwsUwnikKRSpE22UAY5tcN9HdBNSSjboF9nulUDfhz0lWsEWx4zAbpZbe6YjzMAioa-Z4L6IpLSgnSLmF0KKeHEt6oQcs-aMGTLFmA5Yjkj3bKTSLWR5TwZaM7_GEnkklJFJxUijojIJmOS14ikpHpWU0wGYMC1M7jFPXMDkzzenBd6rLX0BtIhOQgZBD51ZnYhMsVPNCctCFl_8xWAgqMJGFunFR7px4SWH7wOIZjsg7JGmgDIuhyzfe-PAPqhGqCIAUgvMmYMWLeo18MCN-OVGoCOScyaA3Mw2avkLEWzsAPTSwERPsCkTyJSUSidRNon0TGJtBZiaxPYm6hOJhUAANRRROCWHVbPEAhkEy0oAso5seGlhypIwAfPMX0Go6R9KZOwRSZ-ici4tVwWHBOfsKPwSRi5tpJ8OLLfCrgGZBMwWiviVbChzwkoXdAUzXhtJ6qNMv9MXLCl6TFJN-B6YrBFBtydg5s5mOwHDkQAlgqE5wCPO2BtJNKEeQMWgBjn4zzeaUaOVAFjnm8NJlqdoFXJW4zB-55xTgnz3MCbzt5gspuiDPil7Ij5rhMxDa3CmuElgowVAB0Tm7noAm32a-kDQFq-VM0A3DOvGLhkg01aQCzGIArQDAKrgoC4GgqmAXj8-geY0dKAommWSPqKCxJpQAhxyQf5mDMZCV2USE5AFa8v4aOBh5kKQWs3TNOgqelpSq0VwRKY9KmkMLnMEU2KKDJR6oRN0RJPAI_KcxQzUyiJNtpjnsmg11GvlLubWGEVOVvqkYKRQ41IX6SB26UW1EsDXHTzlR98HoDkNRDX9a2q4WRahAMnSzogGi6gE6KNDaKwkBaWMdfyUWXIZgxk9RuoqOoD9rF0QDkbYr0UxVpFFgYxbMGMlmK7qmizxVPR0V2L9FqQxxXaycmp1UArkxdtOyMVJ1d0KdKaK5Lp61EO2erKNt2zsqyKhJ87ZBNkqbqcLo-QItdnzCLCoBAJlqJxf9gEU05lFvCpHM0ruAgzIwX0d8I-Pl5oQiFMACSSki8nfigBnMKpaKlokNA5O6IgJAbwkjtBplsy_zPMvPCax9xKPJ2HJ1476g3IiQo7rbHPDsdeO_stKO0G2W2xdl-yoidr2OWnLLAGy2ATX0uV8IGgQnPhMdw-U7LnYNyw5fcrM6WBzlry95Z8tBU_K9lByu5ScsBVPLnhLyywElFFBydzYuoJKPxySGLLdeSKlFWioxVwrgRNfewAaDcg2xeO5EvFVRPOXEq9lZKu2KivRVUShxzylHh2nRwTwVUumObsIukWyLpCZAxoLQRmW2w5lNsDrtfCFJXBdMV3B4aYU2V8RP4IoTXERhVTCKP4L8o6p2AyAPhpFkPe0p_EFBpQXQYwUZpdkBx7kJKtolHmkE_FZB0Ayq49DkAkhCltVOQYmitjMwqNigAAEmAAurHV8gW2L6piDHgDVMweQMUHYBlZ9VksQUBWLSX5cBV2K5FRSsZWihxVokfXEwvSCZBIqDqh8DKshGaZQFgy9XE_21xKyPVa2J_CWpcZ65FcUPdDLUV55jhJGmq6cA-FlXV8Uea6YVg6qhn-qdVF0SMGqooX_ZeVCa_lSmJpWkrzw5KhlRiozWSr21rqwtQhhr5d00oBUy1eupR7-qfOtai1vuuQF0z91BFOfIeskn1qDcQrC3JWtMzVq7Kl65RNeubY7q66e4llXxGZYWo_cUM7lWkqWDbrdVG61wluqppY9kefEFrlAB9jAMJIz6_8D-rwh-4hsCpGDXBt2CallZ62aQmfObVWq-IwVBDaPT_mtU0NmmYGl4FZ6WccNT-fDdfPfIYa14-XdNFcGBrZ1IgU6CWqOlBgcaBatqQNJgCWD8a1aa4oTTAFJm1hqNCHdjQLRk1VpuN7gYBXKjk1q04gqAFTUTjerKbMYuocIGpojoabgF-mwYdagcKKwr4BADpLpBaoR0LNGZaIDZvLFN1ru4vSZRutYQoUVUywulMOvPRJq51Vy35VCqOUwr_ZmaLSJms7BlZuyFS9zfKru515JmT5KGe5W7Kfy5-8wK4CCo-VfK-EEKv5dCoeWRaJVWaz8h62srll4tjwxLbouEkO5_1w60dcBsMWEbpeWQcDZjzNUnr3spG4HKWt1YNbsW962HI-ukKIay1c7fVg7lFmMbNofSvdih0kCeTykYy6OAwAgnQd7-YSRaTUH7RmIXOwoM6u5N8r2EMgcQNZBaFzj1jXwtkiKjABuKoRPS2IUut9VEmSAiin204i9r-ZeTdJyGhnBOw-2DLhld2f7fdvsDmwAkuvKibbCh0NA3ZtscxLqANA0TaC9gNToCo-26BIAKQGaMiMayojRV54SpXVsuWywGg54FzjcqBVYqgtlO6nbToJW1K-InE7UElHJWM6adiQunfKHZ2c67Y3O5nbVq_WAMgtKOtHbRMx3Oxsd9OuTpLv1Do6Zd-oWFaLvhVbKgt6nGHfSs50UraCIneXSKuDlOwPZuKg3SztFQuykotBZwDMoaA9UjltBbUOcut2277djusztqEt0vKgttBTnQ0FlhC6qdPO5FcCr90B6g9tsYXbzuZUa6FVY4d7SqikXNa0lE6vhYmpTEU6Q9tOpdeVoAUnD41Ge64j9rwFwA3toNMpQEoTWA7ycE7MpZ-vj1TBi6rVKGb5QpIwAANfC9PY5SnXZaWsbkDnVzpz28689MWuzXhA71rrjgCakvY8V-3l7ZQ8i6orItr0EA_cDe2-bX2ZqmIRwCPHiIF30AaKhaQaI1QG3cXrjT97NSdOwCGrX6u9SOHvTXj70RRLliu5XVjoi2rgoty602mqkP00BasgmpWkAcsUSbas6aGDNPtkVz7hkC-iva1Sr0z6M9a-jfX3kb2EqUeGS1iOnSsQqp00D-ndE_tfzYG06lASMMmzdZUGCDbm9XZgb4ikHElImFVIQfSzEHCUL-q4G7rt2WAHddEr3dAdn3pkntsweA0vsr0r6a9qAYtvXvQNk6xdt-zGElMoDywi0C4ewJGgHUn7hNF-iTawayjsH0l8S3fZGCh0w7eO1EhHUjvf3S7P9lgY_XOJ0PialachhLQoaZ6c8aNKqBTZ0VEUtaINMMlJe1vwXPSx1ANKDVMFYDfQJI22rns5mkI-GwYoMHw9djQDmwPFKRhVFZvALJG4jQOLAOkasWZHXABR6ICjCk0WBcQ6AV1nAv_kC0qjEwWrjAEbywL-ttNOo2rU2CN5xVXYAoDjFG6F6awsixg2YgoPn6ojgtRw8wh-jhxnDQaETeHBoNdqPNKPMWMfSmlJ70ocVDYzXVT3d62tu6hg-nAOFgACAbkHwBJHBhLAZyER86gvEiCihG85xtKKDG2NsAzUatBo3gCWBvG-c8tLo8nij7vkoWTocIN0FgCnHHqOQAjIQFExgB2U2IkcJgD7DtT3AIa1TCwEur0hGQtxiIMUT1gEAjtAgM6hJD20Lg4Ah247Y-DxMnGzjWAH41_D-MC0yTUAAJKgBu23VWIvtfoFgFfQvD7jRAR48niJMkn-wEAfbRScoAinHwXgG4A8aeP0mCuOxtWiybZMcnLB3J8U3yZr4QnCTVJ5wC1zzBwpjjBJ6U1LX4y_GPjEdOAIaduMwm9TxJrXIaadV3G5TgpxvGaZnLsALTjJq0w4htPxA3Co0hQQQDAQsgqAsVFZGxk4x0IsQI_NwocamA_ARQeAFzvAB-qWn5aE0dU63hNOnHzj2plHunImDNy-ICWX01mfZNCBbtkYWU3GKFOEACztxnw7aw-jJnXW7Z1M-mZ3Jjd9geAWBX2dLMEAezq4DKqiAXQaguzqIb1FOglDjnyog5wsTOYI1F7e9NcrPRHt4NR6Y9yKsfc_1Nq6npTBpwM74L_T2mjzzp2rD4agODGFtgcZsWhGW2W90O3k1XuMvPZQdZQaE-JFhJwk0DdJmwLAGYlFApAPAH2mbP2jDgWgJ-woHyQ6AmgQBomk8aeCdUkAIXomuk7FbwfsAeyvZZE-wDit1BO7tQ-y2ifYfYBYXEduFqifhcItXKLY54MiV7tItnL3JPE3HfxMh3mG0dFEmizrwCQ3g9ebkRi0sA97cG3ISK7HWxc9C7I0TcFqYB711769zwhCU3rdgt7f4re00ZeHjLQBCccxRAO-IbzQsxBILul1APpciB3w499BqYMspFWuxPeyl85fZaU5KWbYPuzXbMscvuWVLRuty173WV0HWdUEJFcRPh10XeLooMiY7HR3YqMdh3Xji7sWUuxRQ4Vgi8iqItRWYrZE2ifFfsCJWzuwV0VJcsos4Xsr4evboiuwvUXornlviJcud5p8mOFVo3U1aU7ZWbLIVzhmSUqhQy5JEWWloWAKj-astEUVyz5cCulbot-51cM6xKzfGclDyLhQnsoX3y-rz8yqJlrtYbnvLTHXy9NeXW3YatcqhQ39ygpQzfN_KPY0jiA0BHO9Bx7q5uokjbqrsN2b_JszHDfYNrIRmmkjOCNB10ZJGyqMLNnmFmEpUAXuYDc0viyhsIIxtWlF9p4AwwXPKlIxV3JnkHS_GSKL1wUjg2pgPGRG7FhRsmY0bolDG-JXOjY3cbYRI0HBOllfWIAaUBSMqE4B1hUgkNnEpITwCs2IAoc0OU_mCmc3f4W64W00lBgQAgTqBSMFiDaQ-8FZ-PWjVWrzAgFZbECeW52G1mB9g-iAJspH0Ua_TC6UcNADif7zeUuCG07EUXkfaZCiM2EviPEA_aJAAg3QA6V9ZZCrTLea_cwCP1u1aFAgcQPIOWhbm7SRql1ARuYKCzTUGa4we0rfx8GJVwqQYtBtag5mfUaAOGFIej00vMLU5-8iPvVSzFBjixoNubdLaDqZ2xqvZPuoXXnhjBjVIDUDE-CDGcZYx51V2yqPdvmAvbeY8-XBKbKh35IQGsW1-OBlm3U71sggJXclqoxQYUMCoSRqlhg0L0k96e16nntz2F7MIDABdO_zZ2Qb7KFOQHwPmcAi7ksqhOARnmRgK7596oq-VkXspL51Cra7QYBQO2IkiQNpFwgOn5BqMm12AEsC6BgAO5PQSe0JxHvD20pzMaRVh2NVA3vrsAW49DZ-uW8IgIs_GxzaMvEcwHI95-lnFuOS9TokM7B-na_wg35ZmtyWMvx1vqXI-txih4rJIcM1wHcthh_j3WDKg05mk7IOpHlAyj0AkfRuQIGbmEoZulUO-P4u9P8Yzw5Ubh-gDZFeKVRw1CrYpUioKOIlcU1OzX2mqKPwR3GYBxAlBg-rgAt2O-PIHUfeLigUti9DXz8Dl6bFG8hxyBW6g6ONHo20mjkC-yuPvF7mOIeeuKgKQTZKPP7jljMRJQEgFjpRxJCAdtJQYpjrOECaCd8RCHZDjldUql6KS4n3-O-CjHylQAcnonOtkk_qkQIgbw-Nh5LDnwVP_e2tkPrQ4qFfZqn1DupwTMj5ZPxHCTwqCASKdaPgnCQGLNFSVQZAYgejyiItxSc5Ylgi3P_ujIbpcEEhAwnAM4OczxUBnNAIZyKD0SUECKkxLDIUKvJtAhEMIEO0-yWk0COb_YD8VMF3jDPSRf6XUIs-WdEp-nVzjZyM-2dsYRHrcrEGs7OODhbnkjyYZ5uxnZBshyjCSKs9ef_PNn8APJ787eeJBcnNxkkto_iqYawXoRyF4M-hfvO4XUL9OLc9yeowrcI4q57qHaTXx9gLx9oLEGoBOFu0vDml7oAtACh4anEWcmqhyHlAZbUAeFzi8SC10LA80fO60HCBcRIa8kLSNFXFf5YsOPzq5zhmWoYvva5HCGnY8ifgjRofaAurp0hohPsnlAcJ1AA1fDE4UwRLPPxX1fiPDXETpx1q_iCkd38cdKRwg8sKSZMawQH4OEu8W22jgZgzAAfQHhQmx0zRhan69cEf2jX_FUVMKEEQryR78DxS4FfrlNJCeGAdWXdOOZOrRoQdFh-rbHv8UFSsb2SPEDaToz3VD6lWYXT_Tyvoqir-IBi7SjFv43Zb7_KDClc0ByXP8fYLk9rfrP-X1jrHLRHJN6V-KkLHooSBCqn4mM8wcwB6_MBevbsMILAGVU4Y9Tm3y1NdrIxZCqpug0LOMaHcoJjuXXNVcTKsALqSY-3U9-N427kyZ4AhGVfeehXUBt24A2wCAN9D-5qY4GH5DjAhNpHoBPtVlPMEu-jNnu_-x7q9_W6gCNvr9_FOZ9pRHfzOrXsAMJ7a90dEcfpyjEAih5gBofjXDjzUtq4eum0PoUHm90ELSi4f8PJryzq9JUb_vIqjb3tGi7XjKv38w73StW5tRfW_-jgSfiBY8A08KqiymV1jgVIxP1bMFo4M4_0dy3pP7juHNx6Bd7qIE_H4UIJ7SiAXgLoFyMJJ9_hkJJ-grm1Gp7tECBBPwnucBJGMd8ezPgnsMEoF9W2eBPoF08I579WmeXP7wDwBGvg_8VyPSryj5cePftAog6WMrlDWX5jheH3jlUYTx8EVGIasXo5nqPvjHv94_UWRyC_QCNuls7QR0WJ6hrzRGPoLoIce4sCwK5HGLl5G8kRBPhvVLHSyFFfh26hUV1E0UEJxvC8PnPGn0C5Z8lGQ0MvzQPtLBrY-Ue8vBX8ryoxG_ouyvP7j6Cx4SCzfhRNX8BHV_aANfzwTXz2XDuJVtfmOnX7r55969CeJRsuQd7GgHzS2AvDb8b8ZmVuePuoN3mD3d_v3KeQ3IweB3A80uH3UAGjCGsfYLsc2oHagMkGS4peiu7qV7hF4l6xzPf2PkNWugh6lGUNesLa5mR9_-srpIeQ9LEI5t_i6JqB0ATgVDOOtyeIEkDiBI7N5OPXRUn0iuCIhEhpR9PGQEGtEO-lmvlGwr-n36CjXygfgLoGV2fNde7yj7IrppLw7Vu_xqfWY6IvsEZf0_ifIkLOZVSJ-M-BXsq0VKai15tJSf3-Sn9L8WDk_f4IGntZPfgeoPKA6DpB-b-_xQ3bfIN2G6uK-vfeUHH1pjWDJHvU-rZpDnLAPNWzoBqfGb2WVm8s5S_XVGD8P0cCYf4M7fcJAP8H8BKh_NSUfnVUNiwyK_1f6wV32k4iCYhYAbSQn1NiV-JAKDf0SZ8b_5zA-qf0DijelBZ-j3phvsGCC9MNt4bW109HPwmbrq3HZG8QHX4oPd7a9fLKb__gn-lmAzk_o0VP-ZjtN6w2kuoc0ckGifz_1b6cSUCT-w0PeVGkUPnw3_VxL_0__GaT5IHX920RIOKAsFlHShR-8H8wQW5SDGihV2geQzLF36NXl_3fWOUX398B8r5JfXvszBZiHbu1xP-CQBaBn-nAir4N-i_hv4iQtdD_552J9qn5AB8oCAGMu-glAAQB4QBYTQWZntAGr-BntJ4IBv3kgFA-KAaD5oBVzhgGhUeAZPwq-YlkRK26Elixz-y7JB4Bmg2wKj4Xoj_vvKVwL_oXTv-CWJ_6VQVuIgF_-Evgb7aqqAe0DoBsvpXAQBS_gQEGOv8LAHn-Gvu_jiB4vpAhSBYGJQGyB1AfIEugdAcKDKB8nmZ7sBnAdwEIYvAXACJA5cFegCBf-ppi3-1TnPiuBWslQ61OiALYBuiC4Prat-jIJeSkuDNGlJwARfuc58AP7l362kYvsgGAB-gXL5iuWYpn5QBCBJZztAPPnhJY4oqNtLkmEQSX7iQ_FFpChBVPuEHkiE8F9j7-J1KMB-B_aHR7mu3PhUGcQfPu0AC-2QflhCBmPj94ECf3vxQSBOgdX7S-MgUkGgBmQeSIl-WcvxR5B_aAUFZ-Triq71-hAaz41BrooYTkmBtkEHveHARKBcBHHi-Rv-IgWk4xBpAQMHYQugTL5UB0rlmK0AZhJAHK-4BDAFL-tNtLb7-CnhW5jaVbqR7dBP1icG9BZAf_4XBMgXIHygtwZaDSeZgVJ4WBBwZtg7BrgHsElkVDCAx84WYOLLBu-7iaBoh7Ut0JZgK_HKAgIOmgXTtAdtEhB-gr_pthdBXfmIGnB2gecFDB0gfoEghxIbhgFoMAIoFwBiQJCGqBzwdSH_B_QbSEABIPtgDABhgfKAkhrISFydgEAHkBTBP7n35QAA_gZ4gBAfOKHGEmQCwAyhF3v1i8hBACnL8h8QUKGKmBgdcFihLIcYQt8OCmyEQhsPrGjyhioaz7KhzIaSFshFoRDgmBF9qJztAAAMS42hXtqGaBpAfqHkBCQcKFXBNAIy6qhLoWiCWhFoF8ayhkNHaHmwcto6GRhLhEIBuhcYRUIgEkUFbgvBw2EsEqBrPu8H3elbrhpW4lIUcH_gNIQaE1-jIaKFOhEodaGAOywV-LEBMIX-hwhCIVpQ8BRIRvRFi5IX-gVhn3j0G6hfQe_hnBgobWGhhxoeGFZifYRkDsh6gfGH5YTwRyEUMsIVYHj2H0Ck4DhsaJ2HcB3mF0F_cX9lrAqiv9sYhl-w4V4iV-hklH5AhagLTbC-VIRtBb62kDGIws9odH7vYyYvMDH6hvhvzEmSwH7z6G3xmEZjMtPqBqdaL1vdZl2gJF9ZLui9gQrRSmlgnI2-vvnvbA2xClb5g2R_iEBdgC5hnL5UzQBOAnA8ANNAE2K7nxA3wy9uhoO-yiOnJIQsLn_wPgC9iWGfBZYb04Kq-cq2gLSEUAyAeA-8JUL5hp2D-Ec-DgNxZK62VvxaCWfVMJbOAHPN7YXE-cnjyVOEkH7xeY-dERHfhAkVnCWc9gBJG1WZEs4ACWQloxZhghYgYqm0DEYiCC8YkJcY98WoQRGMRtkU9zdoaUFDDYwRkNYGuu-9vRH_BacvnJ0hzEegCX2X5rPLWRneg4x1-19nRH_g4smm6PgPLgvIXQt_uTyakwUdHTQ4D3oLae-WDuVCiRekQZFSRxkTJFyRCkb3YqM5lpZaGWWcCOr48K0PlE6R8wMU70hX4VfZ_6z_MFG1YEUVcBdRmWAKpYgd8EAaUuBmu2yZYIAXkK9sWaANi5BU4RcYU0BUZqT6RuvDxY7e0VtJGmR8kfOECAVuPNDpCzQNtFkg4QCEDjg48pl6Fo9DBZFHADUtgCIge8AoLuimjpDTIO16FzYIk7ABaD8Uu_p9E_uL0XFFbE83gtxBiifkDJuqo0PnaPR1coDEvIiLIrCwRkNAlFB-E_hrJ3-YkZ0BXRUMVjirQsUaP63470f5Q5h1qAhEi-7KJXJA-lvGeBkx__oDh-QIuIijMRqAaNytRd9kNgP2qMutawAYjrACuGyMsE5dgRJrkj-QMAJ-E-ckYDQwCAgse8gixIEXdbdaD1kEaJmIRl1r_YsEVhzExoCgjJUKQ2OLGSxiICLFCOXzkig6x-KHrFJhECJI6ioaUfmDCguscLFmxBnlwAtRWIGlDGxQsZ-HhYLUZvKOQhERvJhRPLnnKERA2OrEjhYvhFF0hXAJfbxu3sYxF5hs0TASXGF3liC4xBsS3JIo9MHm4m-j1ip4Q2uvseL5Y63EhAZx54ljg9RnAKeb5Y-XvnLh8v8AIFcAtWMj7xRKLCdRJR5sV5ixx2ji26lyhECLLiyQcRhEkxY4FTGSBIvpTEChgOLoCXakYJvI34d9rTZsxa1jlhcxkUbhFbUROq7BoiqyjbDBmMBumRP2dPKqAvh3EMFJjg26CKCUAUDoMx20WQGnC-IBdCqh2S-cgWpORiIKfEv0AAIrtYI1grHdWqEI4B8SVnjrDiyYMLQjP8EUU_Hpw5SHkLlQ0TLWIRRr8dTwfxysPIAVCr5KKi_x1AHjqtY7WBJAIgxYK1iI6_9A0SRgaEj1QMsAaGACl-6Cf_HVE71EvaGuAvvYGDAX0AEjEmaUGVaGREVplbEWLFpYCre7yPV6McxKrQSWQ7yrw5UJmCW1iPhHfgu5_Q0zLfGIoenvABXofOJI7TUr-HEBnxSUAwkWazCcSaqyC1H96KJvhrqjv4Enk8yX4eQOwBiAEkHpC9czrgPT_gH7LFSRgxQEKSFU50YoLHQeAjkC-qYCegARqxnjfE0gLyDWbGeT4ROhW4yPhYDC-cXt7bwx00ULIGJSKMBFZxsaCqLKJuWNMEQIBsm0CLSz_H7yj-OScgh1x_FH4nh4RZKrKXaojsOiAuNjsYhXojiVLB_eNSS-QOMr9pbGAopzH4S0A8Cb3JmKK-DLFgRgRiYnV6GepwZoiYVpwl-YHCbFZ5WiKglaC62oHua9RcJKhA3S5sRrLq2fiSaIYOGiREA34QSYrA-c8UWsn9JBim2xngvSTX6Xx3SfqyygNIGckxKSDnQkHJ9yUcmHJoRh8kqICQNfYvJU-B8mlIpyTMBls4cFUmty8scVCRRfJn8kr4AKR8mrgz9FjRIoJzDxC3JBuDClNItSWrH9xr1n9IX45DlrGbYadgzQW-mlmg44Rm2CilXxkVFckNynzqnG_JZ8clHfx2tKbJl6WCWwnVWVFlJEZW0ybwY2wTFs7o8JfCXV78UG3lFZBynEg0De6suHsnnx6tn_xFJeSbmGcE4NF0C1e3QM7ERRIVIWDW0DdtqmDSuQAXSmW2cC1K2MOQB4DJA8CY9TUAjCZYl-wAmG5ANAJLjXxwOj8S6bGOcqXLZ-J8gCy6dJqKXarFAVuMHEH2fIT-4BRhEXSFuphESxGy47Uel4pimQbdSmBsuNjhl6YMCalwAWCTaHUEtdHmHg0WUMdjdA2qTVTxUh7nVIhAMyHkC40Z0DarkoCVEKBJAhQuYDhyMwUe4kkOMfFH0pojneGtR1PrUnXeuDtqmakXqVsnupzrngRu-oaaOEAhw8RQHThEUSr7RpjEWn6AxIaX5EzpE4feHTh1Toy5B8IfFwAq-o6QZ7bJx7qKgN-aUF2lE8yMZm77-aUTm4YpX4tskvIhYTtFrp_cdr72xUYGT6pRRvg37GeUSSj710-acgaOUj9lQpLxi8gNgfANeHeipCqSYcYNJOAE4nNJM6M9iv23atBqRAn-Dlgd6osbFIPwzfk8SYpN1juiyx46o9ZYYz3EiBFgMwMkCZeAJAEK_Eh7vUDWAZgmYKzSRqXmAsAXQFKAJUlqcGarSK9IQmugdgtf7UACVHiKuCAlCUEgee9r7a3Uq5s_rrm_eqVZcp5VmtHOAyyfgrfMTSIIZjJKma_pBa7Vo5bZW2mVmyFqtxmiGXG63F8z5semQtymMWbGrK1mMsulBjOTmTfq2AN4ERnVc3QAVCcgiTgDZgO5sNHHUcysdTTvWBKRzFg42EVdhhxuERPzYy5aQG7gIQbrYI2xJsYIzHRnGTVQbufYFqlf-3Vq7FSxX6fXCXp8fufb_ejyYDLq2zsR8EeOc-Lm6hZgUaDB_8WbqxFZRpYesCvoCpCVmmxA8jBSFKCatpACxWWSLFixmWW7FlZlBFFHAm_GFSm3JoDjCzlpb2HiIp2isRiGwsXcVenXSq4DVmbJDsXADvhB7oEFvS3UM1lhZTEfm4hRStt1k5ovWjFEwsg2dzaC2sYpED--Tcgyl_8tSbIpvh72UQCfhjyZ-iiRf4az51xodjgA98YOV-LAR6GSubBGz1kMkA4NNPimIOzvtLxu-v8oSmbZsUb5GxZ1vsEZR-GUp2kAxisViBXZJOehEH2gUXDY18x6U0hmIcqDclQR8BLhHNU2qfO4hu2QBtk6Z9mWP5fZojv-mpJIIu6nM-LYVm7bEl2a1l-JFQg1lKezgQWFy2isvLnjawaf3ExS_kZXGRpvDmUlWc-PCr5X2-_nDnthtoZpj7-PfIp5q5KLijwSwZesrAx-NAFryU5cTu6mOR47i1j5AFVCk6x2YkJbn-AUmDN5rwLqSjzGqC-kUE_umaVblk02eGXr-O7AEpDzQ6FqnIW5gEY5kuRcAOkFgwqeVADu5PkZhFVhWuWHG657qTcFl6huX7Fh5ZeppSN0iIWj7vk0ZgzbjgzNrzbs2xOQRS82_NjlHWqI9qLY34Ethd6i5MaS6a3-EUU7FQAV2aLYu5suS1HBRUMh4EK2lTqrkx5rURrZ-8zTj4ECO6QSAR-J7MjXwXpzqpVnpuN6SH73ph-Yb55hZia-l3Z7EbBQ3-uDoJF5emGkUkYAb4Nx4gm9ScogoZT4M7ENSpEXYCcZpVKiCmCc7lNnvIk4Sb4Hxf6Mj7G246N36N0WhFlBbAuwG9iW2sjgIB84OQJ7DwJSwGJn4gx4O4A4g3QHiKJUi2Z1oTgkAHhibUDWOwCCcQnKtCbAwDKgWKCHGQ9RkFuoQbrDglAC1FwJdCc4CIJL1hPnKRbgcvmPeHNldlr5WtvumIAcqU4QwJdDrTLvY-cvAn8F7WEtjEeF6soV8FiCaIW7O_GBJk2CzQGgVZBwbnY73UUwEIx0g_qdSl5g1EZli0JTKdckrMNhS6YP0DOfXDM5zhWikPSagD0zbJViR9GExf6O2Tv4-_iYVnZFru_gGY7hZ4VdJdqpEWYU7hZKaxFAaZgzj-bmfdJ-JlnKembYwQY-nJF1hbck6YeQLugPxw-R_BaFZ8aoXNh1-UvLdhKnuVSm2iIbvY_Wn6W0hLxugVm41FC8gjnc0SRUzmFF19ENnSEsiuwUwAtKecj9FlACkU2FLMe-Tzxe8bdiuGi2ozCqSuPC-braZ7CAIOgBAB4DVAKsPRBT0YAN7DVAuklDx4yMwKobUiH2nMgQcf4k6yrksAACnUsJ8RSDSGyaQIBJQXTPcg1gSqaaquAmaNpDEEx8Pbg9C4oBGBv0_xS8WM0JSG5DREmGlCUPIxlhBagIRRL9r_FukoqrWa-uFX69qFuP2rSWYOmDpWSRcMVY186KtqBXKrssRLnKFJVSUkS9VlMAC65Ktbpuy5ysyV2wrJcRKMl7AGpy6gUelyXnKfJQKXUlQUijIwlOwP8UxY9cEaY3-OYopEQRWBnHYN8P8sriNAfEu4iJAh6BgBXASkK-QKkK_N7buB8pb3ZKsNik_iGlppcl5isgua3LJetSXAL-AoZOCJW4yXgvjDOWzmQjCgOkNfE4unpeiZ2AurvlhulNzjC6lIVAN6UrytAG87-l-qvHmBOlKZph2OzpZ0TfBIZX6VHMEZQIA-l0ZRmXkEcZd2mty4qOiYDpwkcWVx2jALHbHgS3NqjveaadWVYlaUOWXHg8HppHzOzZd0DFQ6JrRwcR0NN2WE2akVkDomfnhx6eUoRARrRJ0iXZSWl1AEsJC8lcDtoZp9pDWV3U_ZRgBSajjFvpEyOwDtrz5JpdQCm-fEC2Zwoexd4Ay2-5R-Do-batIRZG0QFcA-GoMMmCJeWRrZoPlM5P1wlGVmveVxGI5uZqflr5T-Xz2y6LKpYY4DK0SXaeYBQR02AgGF6XO9cN-7HxBALqA5QwJdsA7alkMKCwVqqvjyPsXYBkzwmX1jEYOuEKV0R6qtUnnG5sapXOgdoWpZ0I6lCecBVE5OYq2a1gt5VOLqlq2JwIflpRuxUWg1FZqX9caRrZr8VXFauADchRlcB8VGpaJWMagYvTZYcTNhJBMxY5IOWSwKkWODLlJpK3mVlWlZwBd5dlKKgdlTZfjzqV6JgPnbERlZWXdlWJZMTWVCNqpUaVLZf3htlCpEZVdly5Txi2VHlcwbHAQ5faSUMs-bRiqVBPMAZBo5lYoUhKbeTmKpG8uNECTEK_DFVWaFWcvZ50SHgqSHUxUAlXiVcVYXRZVn5UFUhmAVdahYcUACJ6-ValXMaYA4VdLbaQ-FZJhnZd-dLIVUlZXjbcepVXOChyEkMmBGQCZdAXeR6Vc1WjglAIlWzg8VdFUvlACe1UaRaVZpjtVARXlUFGo1blXjV_5ZNWzgB4bhEYEN7K7hHJPUmib2kcgn4TvkBpStWLVc4P5RZVQlXODFQyYNjBKQX2LVVTU9Vfa66U9GlOVngyFcKQ5I6FZhXRAdUZLCOSQQb0VMy15TXJVcoBHZVL2hiN5UhRU6CvyMVK6OKxTQ7aqhVzy8OML4jqgGsjkWxNfCAkARN-vvDTyd_HEaP8muDDl783iGZ5ARitrRBmuweZxEdaLaNBFyx8SQqSgKuPAUnj-JPG2xk82bhJCI8kxAxrNFDNZc4zWLFe2jlxH0NDn9RWcLVjSetWLEas8pNfrgwYLURgR8I_gP8VpQAvCrlsRjWSITs8utXB4i16tf4AsJ6FNDisJohXPiW5snrbXgxhXlWQ5IGtXAD_FkxD_r64KkdbTBV40WVqdgHPLuXM1qFTtr_VrgMgTbhk6rxFXAdJVyVg-YtdmgCkztZrWK2IBPTJJ1WaXomF0QtW-Sz5OJcejJWqpdiVaqrdKOoRSApLpF5eM5dNB6F7AGBW8Z8RVBVsYsFTeixAidt0CW0FuDkB5itUtoh3OsaDj64K2dtjnhwpaoTj2FNfLnDyJPnPGRPFbyfACRg0OcOC4K5NXsJLAdkqpjwASqU6huSIGV8nxUlHC6hHJLmcCkXQoKbBkkVUKYil0ASKJkAjA6JfVEIZdSdBpvFWtczXC4EoO8WwSnxd8V6ergHfV4CbtaqnCR0RS_UmVwxfxTZ1fVTbl8Qt9ahWv1qQIbL_F19qA0A1oBGKmhVmABF5Y4-8mAZK0WDRXEdl-DX-j5eG9ecFipGVI3hENsaPl6CIUQFQ0WACBEA2KxfOF_VfFL1FR5dgqFdFiUAYJTxiqYs4Eg2wNOSIA3QNFhXEZdan1cHVxGGFTBV_VQjWvAiNVuHyr8UAqhyX0lbsrLge14-t8ES1qaeVWuA2ahKW5IcJdfAIl-PAoofFbDdfADeENCvyLldxqzwc8ejeibC8cRt-WON6JrLhTR0BbXRFKt6q0h510snnXSpNeUBmIeXHqbRqJVxHoliBSSUYmll3NHF7NolidYnsAtia1V12H3o3YjoRiUtz2oFJhWhhJU5bEm928SbmmxNSKaHUJN3VnJIXl0NceCuNNGrTUUKcDfjzSlisI-DAR0bijKeGCHF1pSNrPFU38UyjYDGqNg-oLrqNxEno1aNs1oDGvYktVDSViVdXo0FYOYjtorNVZQuALlcRno3eN-WHUXBFmmIrUIcytZ2ATp4wFLAXFVxQuCqos_j-6AZBzbWAwZr-HBllsDichlNJrzQgGbySQK9wXQfjX-ABNxdUE3F1ITYvIEa2PvvlMQ7OKhWXWOSEOqiKAWimLClnJdSWHW5Wvyrwt5ccuzg8KxnxDzEJSFDJh5QxC8bpBfhljWta38SOJHEXDRFlY8qORzXsOJUvxjaQwbs1RO-3NMS0lIT-Fy358hZUii8t2wA6WmyWLR_5317PI7FEpE9TS1o8pJjK0lICUcTxlsvNQ0Frwq6Yc3pQoxLC1b-pYZeSyKUpDkiXhqFaE2ceBdAqRat7PMWHCB4rWvCGewoHq2TqKjSmJqNsdcUF-1szdDQoCgrV0VnpZnguh_QqFXa02ikNHs3lN9dG3HA1ULG8VVIy2EHY5AvRHpxtEXDSnGiOFrWvCSOCpAZiCtdgKnXZtircijKtU_nK1JtEreZiTEsioFwwthrWm07AWbuC2uajYveZPiIyKcTfajxCSWbFPYtrCTU0dgiDdA-SFPDaIqFj20zUAUMvDoWyFkO2zw6FgJLoWd4JO0zwaFsXDRMd4LJIPFdpLPWH1aXr8WvFH9fLCsN3xdSyINOFeu2_aJjYkBmNANTiiaS1zf2iCYsUMiWmWqJaXqwAGJfdpmcxKgEj-yNFjjq3cclrpLSQ68HgJJQ-wjiVuShCGiVx5L5piWNqDqpTWAtGZHnUg64kqWrQd8hk3oCY2oJSV8I54JzodWa0bSVYdtsDh14dpmWtE8lajSR2WA-HV7JOWCyvzrjN5KlR00dcOr5Y8ldJY15USH7ZyUMWhHZSWcdrAfYA8dHlmSUo8bynlrgq0eoxZOwoWecridYKt8pSdzgDJ3OAPJfZbMdZHXhYuWQqnJwadLVppk8lKLcR24d1HZp1UqiykZ16dtVhR2MddsFZ3Ne1yqFoAq_smRILqrHOjragiOoxYR5FgO0CUdJnSx3USjnbcphaDyq52UqlJbRKedQnap2idbOrZ3GdpHUxz8pflgx1D6dnQF2OWKXYZ3ngNsKnyJdpncl0MWbvPKAsceXabpWdKXbF2nWGHWo1udlJVV3slCXfV30WAqTyXyd-WnJxWGxEu51B6ynbl1ydoKp13w6x3G7K9d0nbl08lUOrh3USHXZJ3dd43f13YJ8oNN1IqxHUN3zdo3T12UlfXTJ0QcxgKYDmARgC017CEQbAAWysQNnD-U64HlTYi9pD7BHA-wERgVoomXiDjAReMu59IAlIdIHAUjJsCh2vgBKC8YR3ewD0QJQT6AWAwAHMy0QqbOWQOAk9ps0PdewGCZHAL3UdLsAx3WD1SwEPRRDQ9odnvxWAH3Wj3XOndlmAe2_3X_z5egPcXXpQoQl0zhCxPZWkvU7aRj2g9wvlD1dMtENDT5YF3eFmZeq0pT1W2qKJ905kFaTUEMY7dqr5fSRQLyBmASNazQekp3c0G8989bD094K9U-SplaEQzQt4Fas6r5k2zNuRMUFqrBHEp-gC3iuSl6Qb1psw5mJTOlpvTXyqAl3T5xgEmzLvx7CKba3JXWc0tA4i5pst2R6973ejZq13ZJb1woJ5Bd5VkofSJipNQdLr0I2IhAH0I2jAI7kXgShK5LykGAM73FFzccrzh1YTSDXT0TvdRwgVJgDL3tqbSL9ofR7aq4LmARRL7n_gMveX1Y9mQHKAUQjojD1U-OQNz0bSI0iD0t9OPcAAKZUoLRAmpjgJGXbG2cGxR4CRYBP2dYdEEA6jt3QCanN94PW30mO6AqP2WhczTITdAQdlQiImuCqv3Y96_Xj3e9cACr04gNgOJliY_3QPbE9KNO6BB9QFESDDSkvS6p99rPQP3r9HfbkDEmdgNz1voM_V0I8NNAM1Kdw5qedTJArQmCD99a_ZD1n9ewvlhlp_PRT0QIVPTANHA9_UoRPRmPfAMUQ4wqP17CBwkWgfQ9HmpG0M-GCtIjgQpDPpTUM1CPD254-OtRcMCPeiYi96PXgMn9kPYQPjUbkCMKADZA-a4r-nYA31GwaIrLBAq4cvwOWQDfYA6xYRGDiLmA1aRVRuQC4PDSu4uinoicDbPVOXAAHyVz2CDH0NbQfJFabiCn44VOklQAmBfmBY0Yg2YIf9MvXyDPofLMjVCklfXgI80fUXax4C4_dmVRl27djjb9bTJr2X9maJohp55_YYjEDCsPVTDCsg5tDw4H-XmKD0t6Dg2dgHg36Aw5T8WP3CA_g5P1hI5_Zf29ZmmJbk6tt-XZSZNDdqAw5NfnW1hegGADiEEAdgMP3jgABQ9SuAsQtAC4ScuJzgN9CJtT3TgmMUJEji6g4ULRYc9dPWPFdyVu3OYi9SQrP9hvc0Nr1YNbAB-DOZYENvoewmEM1yMQ0WhTotgDIPT6oqPFRtIAKWlB71PyfMAyYruACm02ccbfB4Cpg9a1yJDyUYkZJkjqcMQIAKVfWGJsDQA0P1LKbWBWDfOPlwfQH_QworJ_4Vbj_Dr7Se3AZEbQ23vkwvn_xntc9aX2HdrPSUGWau_DP3-U2I9nDh2pxGINyY1tG8gXta8KBKdgyQE3XRAOAE31wD3AxRAPOt2rRCwjMAFrUQ0q0rfViDfvBYpaqOQKG4VSdEKtLXDGg3YARsroHBIB51tPqCSD1jAIMsNayA33H9rfQgOc9RYP2gzCJ9NDQNc2cKgN7uV6FaLGI33a6Cnu_3TyNR5hqSQVyY40jxBcueYOaP9t8bv2Dwla8Po2qjg_a0Oj9vg3kMbDAA2QMz9WZf6ML9esEv0qjjI2qO49Go8qRujkpYraxokYBAmsQ8QIVA1UcQBe6RAy_XHaM9H7K4JQAZoOgDJAH_dBV9DJqY-zMYImHJhnu6kf33s9LI7dSGDRg7WDkjmGlSNFjnGBkBpAOQLWMY9zg_L0sgBI5kOIo7I1CWaj0wokCzC0xocMjC0NWsN-jAQ7tpDkcY9sBu1XRFhy9j8zjOOyDDVXZQhFZ5n_X31qkXrWeqrFBYAGYo42A3c2WtMCOHjAI1Q5em5Q41lnjx-A2MPQTzpeMPjs5L3EEUnNKbTC-rvVuEyKittE53jcI1-PJxTQ09HKwSHtITvUbxfu1rIVjc7Zda79e4CITwoMhPOYn42HVGKIEwg25JSDayHoTljYe3dUjzjADO219t5zajx4JpQKkb4yTBPOwEeeqakrVf-NTlgE3XkjDE9SuPwNM9fqx8T5jXhNXtWjlqOTjJ9HOXzjc_aEgHD8Qx1zLjpjQo1MtSBFeXT0rY8pOSwGI-X0CTdgP5RCk0mdNikY4QvX2Zpno6f0ajwUQGOADIiN-pGFigulIVpNoyODhUJY2B6Egc8JsDGpZeuZPqjL1GyNhj4YIiDh5kNLZMHAB0YFN9t_Q2gQz9isl0AI02ZdiAtD9k5nHWjQQPG0uT4JmB2-TFEN6Mfee_GYia46UMmO9gqRNbQWCZ0HPlmCq0s4KFQ_PUT04D5fcX3ZwhqeL1nUF1JWP4iJVJRHlUc4L2Oy9Lg5NAK90w85hWTNRUv0L6PxgG17ChU_rhpQdGl0QY1_hnLE41RZmBrM1KsTNE6mwTQXVYlDqpjV8K6qstyh26UgBCgDT4BaBvgW01gbb9Q9UhEj1LjGPUi18AgeptG-AKcTvTjxHCwm1ZeneC5x5bIXJd9NpcI4MpiPI_WZpf04Y4RxLxotwvTEtiFEZ5F3nUUnD_TpMOktkckDOe96yRfmP1cAqcRtIuRN3ASQcM8FGzkmA-PW25iwzb2FDew2EjbjlNeJNTjDuWtymM8AoTNEYMBTXxlD1PbcQQI7M1-IgDPQhnlANi_UFN4ecefy2KJvbUMy_apZVCyMFKBWJixTlANnCcZ8QIWPJAQBdKC4YqIFbhYcJqdrW_Tn9oY6kz-bdzVdlUOWfn6OE03gKWzdzeJ50yJqc67JDSGTehPgmUp1oGzvDqLN9tv2nbPGeBsxRUQ0cTM_w-zMs7bMhzzjdsNZ91HMqrP89JCOWDeRs7E6mzTcekp4CSPm2U6NLru81uz7QBZAmYDfd7ORT4c8oghzSPkw3dWsTBvXCk0cxYIul0QdNOa9s06INPjZmMe7zQJM132zkWQXvyX9x7v6131M0-fH64bWd3OVzkPHXPO9Lcy6YjtYs_95_o1c_CC1zoQzHObDvpLbNFDa86B0CjKqe-SspSpZu3yJVvRkO4jnMVknQjP7mHPBTm876MyT68_lgkKKjVPPUcM87LjZzVmIBHpeq9d_Oa9JAz8Wet8k4nP5YIGRYCrOkwzn3pzR8zSCgLDfV8lxNlEBCNd98g__XgT1tF_EjJXI5vMvz8AHHPzTy7QvOPz2C6vP1zO8_iJkIPEH9VbzpCzPPGeAc7bOMOcFTiMtMng8e44TejVMK0TIRIAtHDbCyXM3zxCnfP5DnWM40MLKkxDSwLoyWuajNzrQl2VdDFtM3utu4dDTBRvUWB0MKGzeWPHuobZd5I-FSYiPiCc9d8lQAzzry6TDgOHE2_ZCaniVAt04CC0dq2oKE2BKEsb9ogdcc1LM2z2IC5lOzpPBHMC18OfNrxQB3TpPTD1fWxmuClgjbRMQLwJFS2DwQHqmyJBs2YJLzeiFgXugWkHUruJRwDjQVUq0qhDl94S1O7rSc0-7Qz90ZmWlB0CVCYX19HLZiNcDUY0P0DCAU9LMCLNGdfPZjE8O-J0IFVFgCJAAkLP3ZltfTkAhzTg8FYDj5gAJMeLYs7LOLTU5QdO3W2NakkjNG5CmIcdW3lx0Y6wneeC1YMzVcDtLv2o0ItRWQSIbEZ5WRtORZwOEUSfTvMzEQi1xy_jNT4jkxJCMTSzpRPOY9y19PnEV0jFSELtzWWwfLNy-LYRxbPl9INBTRbWCX5lGs0EnL5slWg7OhdLIq6TCitCsPLK-OlJLAoMPst4CCBPn2bl3EMEsg9XQBSCKw4ef5SFL6HFEuf4sS1zmXUWs4VRJLdgJW02DnsBkvFwFVHBI5LsmP935LkY4P149Ic3d0TwQDrkBcAiJtxjErCZgNOYZ9DMyKUg4eSqgCr21tjjItuXbh0VdmXUV0Cp6LePoCrJ1tKsPacc_KsFKmOGM3pdqavxwNdxXSdZYYIjBcBtSdg1tIsFrgl2B5gcEpJhyYWQXL2uDrNEKRGu8BsKDtFGUbMsY-8y2RmLLQI1hiCDQdKHaPsp-O0v9DLUVit2RyOW9aXLH00mvwAqShnpIrY84b6PB_C-LPYgcxRgbdW2kDCuD-aihT4o1GWqRlsGipXxCojSA-fms-mA8_R7CSma_jjJdJfZ1rR2mabTTOFProILZvhMtInRksNf54F4QqtLYDX3c1OuCMyCYXtS8ocj0xULeJli9zOC9myK9mvWd0wAl_YQt-o1vdVp6z7vZr0XkN5kiOPZ7WeEVYeJHlmuOUvqwkD-rEPlGDtZAtRC3odtltxjMQfOOWsi2CPOtjkt-xt_HLLb6CqvqcUej2teyfa22QLNU0dmgroBK6z2momZEes94ek3Es-2KPZs0cDwIhOy2KCs6YLNAzEDMhR5UmW3Urqn_cd2Wpl7FLD0r_3U91YDcdkzRpAOqfiDTrKFOrNA9xY2B29DjgpDk5THPf5PVrqWjGKkOTWLGG2MuG1Ov25aU5BU0DKtcu4_2G2cd0yjT1PT389NDOVWZrR3c4Ors4ywasQIWZHsL2LGlMGttqoa-ljkZs3H71rTrObiktRL03dP_gYyFcsvTLUXOthOXYJDP_rAM9agvLTzi9OA4ks0GtAjisfAJaeqK-LakzFMwwZNrPM0kRfira-f2xbBwDlC7rfc9vORbnywZ4brJC872pbH3hlubr_TUr3s--63rNobLeMzgpbuRYVtzrSUC6uzzUdkv0HrRW80GZbpC8zhXoOXh1ubr64W2SaYDW01vwr3wf4L4RDdiWNzriVDUssFzQKc5xANAt7TbzXm-gA-bktKTNpQw2_iJKNjrZHmyLZq1Btw6wXf8rhalgOF2MqkXc7pedWmW60zWyixDTeDnrdvONb-Il43lJpufXlaEuk2xucMpC3QNgAgVYb5wAWXJf2rbaUAFtvLqqCtuGu3m8bMm-2xFZOg7MO69ujbmWLIpW4SK0jt4gYO7DtG-oClcsZrdMyjtw7PRXVtATeK2YBIbx3eKDMyEo74orIcEnzhqG9QYrKewpS7ABvxjINYK-TjS6yNKxYdP90LbX8MdSuEvO7_0mpXOxkDJAgu_lTrU82wlubEv8M33s9eU7QhwA54IKAiQcQ8Lj2KhkrYCoYisLrvRK08lzy3tYSF1H9DBAm5KjLb9lMC2wS84kAnLevsdOS73O1qVUz5ZNT64s9ayU7xxv1q5sfT7m4jmNq3vuH1Pk3u3ADeotxjxhh7nuz3iR7O5FZlT45u-jPvkkO1RM_jIW132rTDaxWviyua66qD5NfKs47VX0gvp3gHkAWuGznO-7t2zgKbMBIo5c-dKbY7WZmlmzGc74tlzVs-XP4kLUZ0OQMuEkaul7RaOXtGzVey0v_gwMbvid7PNTP3W1IhGItL5J42th97-891Y32KQscnq2QYtBPc0A-90M0CC-mjtStKPIECogVfRC5dD20qh5l60e63sp7cPP2iQLYIyZ6_wzOMzvUi2bIx7m7gmLWbpmfs3yMN9Uu9YJHTIoJcGx7qAZvuCCNjfXncTCdcEbiy5u-KAMgp0Nvsr45u98tRg-2X_zm7tWQT5P7emIQfxlPWbhEvAVPdbRRKY1AHZhABdJl7w0BsjAAI0yNeT3FpGQIiwBUmAJ9ZtDxuzFTBmLwNJlUHRGDQdB2yjthKVc5IEFSEHy2N3AOa3B-NSG74xQztvpfqIzYa7Wu33UlVECMgfwAUvPIcFzGAObt05KPHY54cVAGhjpcgMxgeEHKB1LwSy10o8m3t-B4YJP7o_iDlNRYkR-3By37dFaA4Y5N_QJlV64_ss7ZwqgfNDrE6NDsTQwprt7wy_qjzgrprVpGPJ4QTYe6HaB_Hm7-X2AZimHCUBYf1wT-PtFJU7GDMhQTewBwfiHMQJIeHulNczTdwZ7pQfKH6UPNInA5EVl5j8ihiaDLMQPa_JHALR3QwqOAFANg2rFUpxC19y7ndHI1b2J_tKwjHqzRdLJo7Su5HnqPVRzu1_fiAZj-VFMDmD6FJLAQ4hxAMD9AF_pWTHZjR5z7d-iR3ZSFHVUhHbW0NgFsdvdix-YeeodgH_wb8ZradH7Hsbkcfg0a2Q9QC9wR1_u2HaB3RhtAZ1PMdSYXuXj7cYYR1YcuHIR0Cc_UOR08eCCmWPNBIHqR2EcSyx-bgdP7zhwIC3tbh_xGCRmpF4dftFhs4DskUI00g6HmJ_ftaEVUhpoUKrdhIcTwpR-1L5AviGlnoFWzsG5DyWzkqkrHtg_YLnu8BS65VSbU_G23sFaTKP5R5AOJzjQ6FNMfoUjuz8YdDuinrtHL0h82v4nGJ1LzuYhB5wQKkSp3jH34lnFEeUp6h7Efa1wRNNURNQ60dQ4KMbeUuoAbYEwe-mRIKQ1Kp6UEIflZrB-gUcH6NJ3qFbPp6C5anP0MQfAxCiv8saS8IHABenLVeyToayh6GchHJ--J4nHeu9afgr4TQXRplZu2GdztpfsadLAUZxdD0cfJwXKmJcAIoe8HKqnTYmYmB_4cRy4bRTvGHee75s4n8J2kc9kK-3mDzQdbHz6dngJ92ej-Q2Oz3jUMR9rvjUtZ_rvVngwEod67puw2eEHMOR-qfrRoN6vhmFIAIAKUiojl6EHbdGpPmA4yXN2Kdu3bl23b1qLsuF0tgJOdcCr0nLUEsuEjOeLeA6F5gI165wZvGUt7aXQnLyKHgIgHHu972R76NXMvLTFGUCPw29mzBHXTfEIgtVrt5xoc67yh3EM1nKF_WeGH0h800O77u3-cU0L8v1EAX7u7VjAXzMDpv-hiOzdnR5OQDvlvTbm8B77nqZ3PlLYb672WxooGysv96p5wVpKdKnczjXn2c3_wPb4np1E3Zoi9iDW7VJ1-KZp1u3o1EnKYu1nyXv4ce6YDUl59PTg724W6Wn2u9G5PnNAi-fTnpx7euicBu_OcznYK9wtquVlM-fKHTqBmfRKmwZZdY4Bh4xdf74ePXHPYWc-jvWL257ueN4KZ1_tIGteWuduGGHcZTGSAV_DzvYnp4bLZDgG8VAmrKYtxdddW3Yt0yd2qx63P4MV7klToT2_lB6reLcCK-XDFxFeuXUV1OwJXSLf3qrds3Rt2KdC3Tt0Td5sAVd1asBoluixxqiUSgOpDsZtPkc3B2tZQ0Jf9ggyj1gqSdXpcmhTd5KQ40nOJ_ALQSyJaITVRtX-ROVkaa_R-FSJY_AANjZ1qCdK1tEN-JuhAS5y_S2B77bcHvBmrLQELstZOR96fZIM6I7jXmcZBc6mXfWK1y2krdnEk9-1xWujEB17EDDmMWxFW_Xg_r2dsXBaYlCuzQ9E-DaQBQEd4X53lxnplrUW63SPXuJZPa9XQFIvJeXiZZq1HEctiYUZ4f0PjfNBc-KjdfiN62ccOtGeo-v5OZejI2BrOe2OUatbW8De5bJN4TdrBbN-z43jH0KzctryjBzdy26gjzctjeN2v5L-YpETfi3HISLe0UYtwZ677kt5zes-ity-Ny331w7EsK7xkrfvXWt3zgm0VuC7OpDT4C0iw3cV1mK_bmfsr5TTyt-TfNBvjXtuDeB2xM1Hb1EgdZ3bv-se5etUtw7ELNWOFkGDzxN-z56N6goHfq26gno33BXAmTcH-HIXo277Ydwrfn2AC1DR0KU0onfg5et05f7NH2y2fwHtNlG0f1MbRNBxth7usAZ7zmHzf1wh173hYzlHBrcR-qSZm1k3WJ4lEZFRbQJSsADCvSgIrCakyuPayN_Xdd3jNweFuaKxUkgHsmyIRydtv4hezHIlcGcjlZ7kt-x3F0COyofIvyERj-SYkmWjElU9xkACSXDYvfGWaxUMQvIm91QjLwJy8ffb3bbcMh33YyPveX3-Eg6AnLC-jfcDIgyK22QdXi0_cCS31B_dIcRCHYgC0f98vA5YgD8pLAPE9yDZgPL93ZZa31AJA8egRvIzBp3rEOfdbIYpdwr7InyHWfz3pyHg_1wmOIMpXA694veJMfrFYBDEFD_CynEVwNfdEPJTC-0iib92Xq0PnzJVA5a3-Bw8WA38gA9MP3ohZKWCVwElLCPU0Bw8IHMfOux3yi95_z9K0D4-ZYB6lvuwg23tm-Yba4EOej8AsMV7RIA7AF1yZo_AM6z8AVwPwCEAtwPcCPAt9aeBsg02EPKTiuDJIDgOI_PEA4YJ1AUAucO6FBam8zrCHDRKkgLbD7AKLKGbAAwUM0PjrhDJIDAALGzADyAOmB4BgAs0LfXcAr0l5DrA_AH5CHHTIPo_mPNwHcAPAGyH_W2PrwPY8XaP4k48uPPsMa62ANgLOBeP6WD4_KPA4C8AHwUQAE_7AasC0-hI6TzWD8A1TqY92U_T7MB6ySqXFL6PptPwBh8z-bzI72Ez_wB6jgz1M9EZFoDM9c8_ADouZPdmYM_YoIAIs-5PdMNs_fgmWPwBNkOzws8n0SzyABnPxz5tinPQxOc97Plzwc-9Etz3-jLPT8LMAWgbGEwezPI0vM9PPLZQc9h8Pzy_n_Pczns3GPOtmHyw2-j6DCZYlEPwCOxBzxUC0ACQK09eQ7APwAzBVz24BovjPjk_5XCL1i8qA_z2Y97Pk5i4RSwmL9i_rBUAFc_0EKZhRZQ8_AES-bYiL6S9XPbaTS8qAcAIv5TQgz_R46LHL8i_kvBsnmxMI4z0sBIvfL3vB6PfmWy9_oIr2S8kvPsBMD2BY4DzsgA0r7y_8v8r_Ef-Zq4Il5QvLTmzLzPdz3TByO5z-_j8AmAda-Q0tr7QHSegz_C-AxZ9KBauAkYJt7betHXt6JCB3jeDXGOANjDcg2r8e7uvPsJGCjc0b4oB42_APxR55OixYD8AkYfa8Q0Kb2aFRh6YWyFfGLr8e5QwejRDDYwCb7LgZvzoWmExhzr3C_hvggB69Rvsbw29xvYb26-1vkbzG_RvobyW_8UZbxKHqh0oeM9gwx7pFClCx7r1UQ0iby-S1Y5jwxdpv7zzoCZvs7_lg9v5odGFuhVb4O8tvXoVNSA7zb9DT8APob1zxvP7hO9533YVNGZPtOea8fQmT1kDovtAIu_Jv1zz5PVvIABY8FPjwOvhl6VoCICxhVJt8-1PBQBaBdcUMAADsKiHMB-QIgE4-sAkUHPBl6Y4GrDRAcH7ACzQWANVBYA8gB1CJA1UIkCYfAkNVACQcUCAA2hpz_g4HP20b09zvJqaFDhQgzx5GwwJzyAD3Y3uAK8HPBCIrIAAlVDAKQkUF1y9SwgHj5LAXHzx98f_us4BJQSwLRLngQnA0BLAbCNUz6gmr7EB2AAAO11gtx0A7cA7QG-9WPkgCMD6fp4AJ_KInwEzCLwDQxaCdetsDDrfaUAGhAxURAHAC2wfsPgDEAUAO0BiA8nw5_hCASIrBSArgBIAcB8YCADvnq4As-Uviqg-8kvZky-86fhT5-_Yg375aDixOUP-8ePs4EB-gf4H3cBCgJMCZ8wfyH_gKhmxiAV-of6H5h_YfwALh8dQ-H8ACEf_ACR_XPZH-S8Ufu77GinPeAjR85PVwPR8hf1qLS-PRkX-1-CyMX_k-6f8X_ACJfv746apfdTykAZfYH8SiQfuX5EArasHzJdFfOhHS-gIJqaV_AAGH1h84feHwR9EfDX_vBXPLX1O9PvsAJ190fnkb1_XvIAOK9X4kr4N8gAAz1e9Lvj3zrayFcADAlXPjHqz2ewT37ECSvcSzMgBmsAEzTbA3AHpBHv0BZd9nfBz0qPCgcP1mhToyz-q_yyWr8Jckv73zj-Pv0hT99_fBzzJ3ngsnKz0MSBoOdSxYGr2iD0Z2ZcIfJAmAHvB4AqP9QQI_TXyS_I_O0cF_946P298ZLogB98PfeP9x4mvMhXQlyF9Lyi-aSFP4xKGgIwOgBaQtsD8C2wuxzABOfWkFK9W44v6OKdK1bz-7KvVz_s-KvENEb8HPiv1K7_POrzi8HPLnCRZJQjUhs_vzJL6K-u_tcKgC2wl2jy-2_5Lw0ABI9gLQQOABQkUKsvSb81Cu_Kr_wDlAgiLbB34Pv3S9XP4DPkApAbxtQBh_Lv0i9R_qDDMC2weVK4AZ__FOb_kvqv-r-F_hv5H__fFieM-m_WOMX8kvyTY5-JAPP7X_5Y9f8Y-_Aav2R-t_Sr5X8HPUQLOB5_4QKz8gAPf7Gjt_IAIixBY5f5DQT_tgJQDJgYf1biORmz41_NRSPx8Vs_rf_08lBoQK9-i_3weL9E_0v-S-k_5P8d2U_Cv0r-uAtsCqKTYAHrbBB2mv_4CUfn39IV6_A72g0V_Wf8b_PPY_x9AT_S34UIa34kvX34kve34SWJ35vPM359_cl7ShcgCe_b37avUAGJ_A57-_QP7B_WgCFCLV7__CP4__A54x_FIBx_darIA_r4LgJP7wAQRBp_AMCj_cP6Q9WAEkvdVJ5_M0Az_GAH4Akv6UANX7whQl50AnWDsAhv7V_VgF1_BgFbPLxRN_Fv68Aif6FCVgBd_df64A-gH8A4Z6D_MIATAIQFt_EQGT_VTA7veQF8Azl4HPef6L_WgHL_Sd6MfRH7kvbn5b_SF4gAIIACQff6eBAv7C_Nr5ffEPjH_XF6qrcn5ypKoC2wCHILUW2B4hUoga_PEK2wDKgeAJOSXaB9Ar8PUbiDPUZZiGwGIAGaAgEIgAyQcngB5eKasQbwFG-SIE6jVIGvIDUAFAFX6STeUBxAhIFwEJIHPAAkSMrXIGbOQf7k8S_4wgGAC2A1r5zvd_4O4T_6uvWf4aAk36AZFf4c_df7mAzf5NA2sD8AZj5jsfV78Ac8DngcxDZsaSCUIJg5qIdXAyQSwH8_DvCKwF_6OAx94H_HX7OAiX5nxKX5uAm2Dn_CxQZUVuhpA6gBgzHIHPAagAZA7DDy_FRyrA7X42vbYEf_PN7f_PQHNfOYFnA_546Aif77KfqhCcR3RSRSSxJQJf7v4HoGmAzn46PAYH3fIYEgAXOC0AADxvIF0BC_HH79PewGRfAn7ffSX6_fE_4kvM_5AqY7osrMeAsiJX7gIJEGv_ZoE62Z4EG_DoGKAwF48AzP5vAkl5AA5F42_VAHkvCAGO_aVLO_Iv4aA-AGIA6IAJ_d0RXPdAFB_bdBYA0P60AhkFu_aP6UAogHx_UgEgAMAH8AZP5UAkXY0A74EaApgH5_NQG9_WkGl_bgE6g8f4aAxv6GggAHGg6v62wZv6mgvAGMgjv4yAxH4ag2kED_IgEqAkf6Og20GaA_oDaAyQG8gvMSGAoSJ_oMEEWvMwFc_AYGXfEYFqsGgHkvPZQgdK4D6fEYCq4eEGRUREFjgC_hjgJYGhfQQBgAZiB2AxfIOA_H4kvQn5Yg4n6n_dwFAqXwH-ApKh-AgyzBAmAChAi7TRAB9CeAjwAZAucLZgiDAlAycBgAMCw5AvCD5AiHKdAdsHxA0TgCAbsHiDU4Ge_CHKjgnsGVAvsGD_GIFdgsCx1A0cE5gwYEPfFoHYsNoE8g2kHTg60EKAj0G_Avqj_AuiSAg6TgggrHBBgqj4QgzQFf1DMF9fEABeRdYG4_NEFPgjEEuA4sE4gzJ6y_AkHugbYDbAXP4Tgh4FY4XX6tAl4E0gj0ENcBwHug6UEgAQ8HHgmZJngowGggkwHBg68EWA3n7s_TMF9obYCkgqtBe_RKDsHNUG5gyhz5gsX7bA1wEk_MsFy_Kn7YQ3CGOfXiCEQ1j7M4ECGbgsCFsAj0EKnKAAFAoF7QQ7P4YwF0B7g3QEwQ_P62wX77bAIgDng_LCXgpwEhgyEG3gjCFo_TMFtEHMi2wSABpfQoBPg0j59A0MHyQhH7PvQd6vvUb6FPZSFgDSb7JfOwhqQ2b7zfLL5LfJx5-8BEyHsetD5AVwBegFELNDSQCWQgoAFfUBC1fJQB7fPyG4fer7Qgx94mQ5obEA5E5ggTSFr_Lr46QtZDkgmEHRfAyGxfR4ChQuABmQv96eQ9L7AfBb4QfHL52Q_HgOQ1QBOQvwiuQnMgNDCKECAbyHRPQj6KAfyG1QwKHEfS76bAx4EbgvmRsQ4QG0g0KEZAySGBgz7bb_awFuQxz4I0GYCvfWSE3guKFrgqL76QtBqGQyx7GQwaHpQ6b6ZQub7ZQmyF5Qkz72QscBK8DADFQlyGpQp4ChwTNLVQvyEYfeqEnfJqEvggsEsQtqHUg9iEwQrqHIvAMGxoFf7BQkl6pQ22B4QUaFoQsMGmA6aHwvWaHvvUqGmQk4BJfDKEAfLKGZfRb7rQlb6bQ9yFFQl0DOQoGHuQvCBVQ3yG1Q06GVfc6GMfZqHAQp4GgQ26EdQj0EPQr4HdAvqFWA96G4JPI62wJU5fQ7SHGPC8rxQx94-nQV7BES74-naCBYAYBSDPHGyXfdSKvgqL7XgjVz8ebGR6PZiHgAGxQuvF6F8_JSGDQvwGzAamFP7WmExQ-mG5idP6TQlN7KHFmE1cRj7swkoxcw_R48wxj58wq6HRQq55Cwq9AiwtWFiw60qSwsmH8_d6F4QBWEs7JWFXPKuqMwkl7Mw_R4PnHWHKHDmH6wq4CGwi17GwsiFjQ82EJATkxWwrYE2wuF5Sw-A5GPRUFbEAmGF0WkFrPEzDuw1EF5g9EG4_EZ7eAfWSGyK57TPNeBgvLf5wYXoHKwkACpwuZ6XfUYJZwnR4TBLPxI_ZoIlwsf78AEAK1wiuFFwv57uhK54HvaKDdVZuEQvKdCTPD0GovBcAEvdOFvfS6FkQ3WS5wpVIFwlZ6Vw_54oQq8F0wwQBXRCeFj5FF63vceHqwhOGQ-duGpBC_yNw9nwDw16HDwmCGdmKl48_C6GZw_mHDPGYCjPfOHAvBeGdw9Z4KQzCGoQ1eEXfRj6bwjgEpmK-F3ggAGMfGCFqvPAC0_LV43wkiHtwmeFYAPOG5JeeGfPGYCrPV-Fpw9-GKQz-Hlwu167w3-GqvGn5Y_V6jYIquIQeZ-GY_TV4EIy75tw_mGPvTALdwpOEOvQ56vId2FY4doHNjemFC_DZoPfZn6qAtBGQ0HNKffL0KRQGADJgPSBGQcgBMI_LA42PrhTefd6RQVwBQwMABGQQwEbNbj5SInfoyIvSAwwbGDFvSaFY4ZMC42DZoyInj5gAPSAOAjZrpNAYxqIkAA-hdACRQDwB6QJRFTeO6qqIwAb7vBSCuASKCKIjwDiIv9A9VZxHc9VxHIwSKDJgKGDeI2NAgffRHSIqxEKQPRHoAKGCmIqbw9cPxF7vKJE42LriCI5uEfQPhHUI2gL7AXALrvEl5RYcBD1vBPIAAUjhgvXDKRCeVDepb3AAOSMP8dCPTeKgE9QjaSyAoSI-gLCKMG2L0rg1Lx4R47w2aHSMEG_AGNovSIvBGzWTAGzQsRgAxigU3iCK47zthq4HPh2f0FAaJgnhOMM--MCLgRyCCr-ebAHhZcKueWCMu-OCJ3-KyMIRhEWrikUPJeyyNmoaCL2aiyKueVyMtA3L13hayIpBB6RLkQoK9hrMK2BGyLnhKLyOey8Jkh14LsCDgWl-hyPzk9yMF-G8KIRECAhRJyOrhI0WRBIcIrQ_7x8EVz2AAeoyI-YsLBC3zxAg7UM--ooBH4IgBHADCC9c5sEbwGSPYAfCNOeyKPyAtHwNhY724mpcIWRwCKWRu_1WRU8MP-b3xzhsCN-R5L0AIuyPBBq8IORP8PBR_fzZRpyMYi5yJ5-lyPFRZ8JZRsKPRA4fAG-zyI5RWwOkKvgTZBBrzFhPyKfhfKP-R9dD2RKL3sCXgFBRIqMIiCqL3-EqMRAUqItRE8Jrhd8OueyKM1EaKIxR4iOpRZhHCeeKLneBKNlMxKPIw7ADJRyeApRVKMdRZhFpRMUJxs8yOtQdyIOeNgPZRt8JNhOqPgRfyJ2RvSNX-Y0OFRFryOR1gIaBUKLORxCPJecaJuRQ8PlRsaIaBSqPJM8aKgRDqPVR7yPIBnyO1hjwKTRWyJTRV-AFRGCP--xqKvQeaMYiVzyLRYKPzRMKLLRjQPhR-8IdR2KOdRBz3RRJ9ExRWwInRuKIaRD3x9RRKLRE_qMDRhAGDRWKJpR3aG5hDKPqKrfxjR5LxWBc5irRwcM5RzaJGhraNiA7aJXhmCNCoPaMRAVz2PRawIHRkqILRBSNEQ9wMARzUFLRR6M_Rc5grRiXBVRCaLIhtaLqCWsOzuIv25RmyMvReqNTRAKIe-Y0OBRJqIfR5cOfRQEKcBEURtRBz3QxdqIRR7cInReiBygaKInBXAFnRjwPnR1yI3e9COXRcmBJRI4HXRQv2X-W6LDRO6PpRUaKARFrxghK4O4KwGOrRiaOgxvKIEB8GINRgqLvRHNCtR5cJ4xqGOwxzX3bB36Mh6v6MYB7YMAxGGJF-qqJahOtg1RHyL8y2qMExuqOExbaLTRhqL5RXaNNRWaNFRcmNXBr6OtR76LPo8mN3h9qJNhhGNRRU6PVSeQPnBM6LdRoaMtAnqMXRMINoxfqNJR5KJGRlKJYxloHDRu6I4xP6K4x2f0fBkCLPR3yP0xyaLgxRmIQxCUOvBmaLne2aPixZqLfRQ6PJej4LlRsWKueRkFUxp6PYcNaK0xdaJxB3sKbRyWJbRqWOvRxmLExnaJBRqGNKxMmLsxD4LwxY6OcxTqKIx2f2nRUQHIxuMMoxiKIGR3qMJRdGLXRIWOYxc6O3RdKIDhe6OCuTKOjRSmNbhRIIRBpIPTBfGMSx9WIfhs8IMxogLSxomI7RBzyyxmGMsxJLzhBxIJTB7CLyxtmIKxN2K2xyYJ2xTGOlh62JKxBz1ux22PcAY4HKxe2MqxJsLAxmqLqxuMIvR2yNOx8P1axRqPaxkmKuev2Lex_2IexFmMHRyux-xr2OyA92N6x-wAIxA2Ncx5L2GxcT28x42K9RTgMCxq6OCxQaNCxIaOxRkWPYxp7zWxnGLneMENohlQHohBEIwKREKBxWkwdRkOKvRYiJax52PJel2Ie-2aPZxCHHwhxiEYhosMexbIW6xkuLwhDEO5xrH2KxrOOz-SuM5xMuNVxrEEBxCWOBxoGOqx4GIbRkGJhBAuKaxQuPSxj7yQxZmI6xF2PiAOEI5x0uKHksQiYh8uNkxJLy1xLuNlxkcIteTmKRRHqMGxaKM4h3EJJxOiKi-TqIXR1GMaRlOPoxAaLmxoIPCx9LiWxUUBWxT0NuRG2IGhKkOWhFWL5xIOJ1sNz10xSWMOxPKOOxjqNRQN6MBRq8NTeCONjRssNzxkmM9xMoJkeE8MoRJsNTCfbzyAgz3GRWwNTC-SP3elkHPAaSIE43mNTCroRzeXAG4RupWDeYsPHxq7ytCZnh7huNlxsp8M-xLOKcB90NlhlMM9QeeNIhnKOkKReK1RJeMfhKWMjxleOFxt6KueteJsx5cIphSxz4OTeO6xKTjbxVznbhneKlC3eP0eveMeB_eKXxBzy9C54E8iekBA-2oDHxmbwreGYSnxI_xnxI71_xEBInxtCPJeB7xXxa-I_hG-Ie-W-JUhw0InhY0Jvx8uL7RssJwJT-OexLeL5ge-Pbhh-KLwEGL0xpeJgxVzxue1uJuxb-IdRH-I1Cn_x_xuML_xk_B7hlkCHxIHySggTgjxy7yzeMYVze-jyLec-IQJC-KQJJLxQJq-LTR6uM3x2fwdhGoFwJ14PwJaON7R9eJUhn0JIJGOPJeL-N5x--LVRheOoJpuNoJp-Max5-OiQVeIe-7eLIhbBP7ePeKkJ5bwHxViL0gekCSgkUBvAAAE5wCeW9ECeITYCa4SJQogT3CfITD3ooT18TFiNcYQSVITviYqE7DqRPbjC0dviH8RkBkifWiTMQ387ccYToEQ1jYMTYSoUN5jpCupYs4Y-9-HBUSYQbS5UACy4ogGkBycbjDEiZkTjKG0iYQS0Sefse488qtjLvEwTaXn1iyIbUT6iWy4-0RkTr4VsDhifFRRgBAFEWOAgiiWk8mcQeis8ffiKoVkSuIdoJUiW9D0iWsSaYbvDbcfDiDcfnjp4YUSGCeYT-ibUiUhHm9X3i-ibsaAMCAPhC0MPV9R0Xjjx0QTjiMVOimho8SaAHn89ikcQ0UqNjPvmTj_MY-848dkBpQhJDaccniGcQHCC3gtizCKcxhgNKjVXgKZzCASZSccij-oARUJsRDBDHh9EIYPPYLiQ4TOUdii_AFPBZCeY8dCMUiFIJUjJESUjqkfCTLQGSSbCMET2ACEiliZnjvsWkTsCfLC9ibfj4iWAM5Ybn8-SbDjTMYcTsYRpiIcacSXnuYSxYWUSCZNUTp3pVo0GFQiaicy5WXI0SQSU4DhobbA2iRHjmgbMAKUZkjgFlA0Ycf7j8MQ6jhiRqTy4cQSxYVMSFMCMBZiRkB5iRBjosYpiuSdsSeScKSn9ir8rRKwItifwB3oTqSRSSLjcieKSLXi8inARbjiieSg7CTCCgxNcS7HDy8vicidniYx8A8SST3iUNiUyfBwHiYYQdgn8A7VICSqPlHiqMV_8aMdNjiUeCSrRJujGSSniI0XCSKMcijESSj9gXqiTdTBiS7gk9VdsWDBcSUsALQASTpIfYSWCf1izCMySKSa-8qSUzEaSeUiaSQySmyWOT4gCyToCXR83ScnCiYbLDHYSGTssddjAyZuSNQOsT1CavDkMd2j8ifzjpSeS8bnnKSaHAqTVSUqTVHCqSCwZgT1SQ0SYoZNjGkY7C9SQYjYQWoTQscaT7mpEkLiRmTJiS-TRiT9jfyXaTmXNMTHSUGwXSabi1yYejPSYKStyT6TNiXXjuSchSDyduTq8eXCTyeZi53pGSoMXQShMdSiL8RcSEyTF9bia3D7id8Shfg19gKQuTfMcHjPiTRTkTr8SCyQCTOyb5jo8eWTY8ZWS0RNWTISfNjGKfWTuYY2Sxsc2TSMK2TyXnWZIgGiTTjFxSIAt2ScSTgA8SQOScAISSzsXO9iSXWTxye4TCkdSTaSRUj5yRJTFyeSTWSeyTTSegiMCTUTs_sD9egAl8LCGpjzcZKT1kReTcEYgicUfFM_nnGSbcdeCLCAGTHvrmoQfsN9b8c3igqRK9QqYx8KKTHjcYSNBQkfwBvVIj8akWSiXQJZ5m4Q18dKT-4ukcYEIiZFAQPrYkuuLD99SaACFAlHdqiQ99x8NzDvyerB9frFTBBu-SjBpMjmxh9AIYCB8pvJkiOEbWBGqYINDHh1T8sG1T-qQw0uqRYAeqYANfCSNTY0ASShqZSipvD0SdATlTJ8dUYYCQnlg3qbkpoohTjHsFSHKRN8nkUcSTCQdirCUUSPnhPgkEaC8fKZficKW1iUMehTCwdtSXvvoSLkXdTIqZmtd4TFTeKXFSUGDUikqWR8UqZXB0qb0j6KRaSnyZHig8YTiSXjVBfnkEA4APIAAAF0JUnzE4ossljUinH8UxT4ahOUDNgLtBW44941IvCnXaNbxMQfkgHPAKklUzJ5mYpwgcCEgEg0yqmUgaqmRI2qlbgnfrtImakfQTgktU2sBOImalZIgHys02sB9U5mkSI1fGC0hhpzU-Dw1I-nFsYmmkwgqqkGwmql4mJmktUlGnQ0dmkc09gDtUkWlhYmanK0qGggfSakfQeGDc0sWn3NCWnIoo3AxUSmkb-ammrUyymXeChEjk97zuo8EL_4o9FTk64xGUuckI00klLkyTbLUwZ6SE7t6I0j2i2oN8lTeC0BO0GZFdvbKmI0vSku0gpGbfQyllCLriVIiGB6QXwkmUxpHYo8qmqk2mmkcOWkM0hWlNEyLx80iwDNUtWmzIowY805hEl0gx7602sAV0wQZV0_LA60yGgTUmunp46GjzU_8khtBClZ4vakSkkDHno9yknU1CBeU355vwi4ljQ7-FaEx9Ek0rb6WA9YBAmO8w7sZtq8SPHQz3QwD8YcFBLSZGrsoXqaaOfVa8GVXTHcWgh2wWHRcSCSBQwPSCs9Hqo30pSDHdSRFKQLDC7-XupxdKCA-yBiRJQVXTkSMzhCcSwB8IEVQldI-m5dKT6e8c8BcSZ-m-VUkRU7HyjSHFujfuPQTugM9xDUWAA2cYNyGEdnDNhCEpGpQqiRhHyJdHUQaZeIohv09gDnnULLMcdFSHcbXjsSShmAqOjp2wd_T_0ljjOAPhCteAupeRNiATuQRiP-LvF0zYESXUAwqS9CH7cZN-RQDHqS8Mo0DmgOCQtcBynxFP06wwkhlkMsiRNWChmedGHRpQLrgwMtdz19MnyVuIYCKYdoBGEWWichKTBNDIpYOnbYD1ABSh1nJKbnUHIRvpfVZKMgrpKca2CtYeiQycPzCYqVanDvdc6ioDxmB6GZR9UdboSdRTp8IAJCpdZMCG00K5frJxlWdTzr6gfUC0SITjycc2BuQPhCO_JSprU6JndWLkpkSPUDnbehnI6VHRK6JhmMWVhnmwAurskkhkuwTjjOANyAHcXjhkSYSzUSKKzuRFfGBHThmcMZKRe0TpkSMzLzGnCxnIINdwsmH4rpCTKiKYNLKsbVaQRsHYB5gCcEgnCXpJ2OCScuB1CFUY06KMpq4jdRHThWPzA2wJgJCdW2BuQdjhpQSNHZM0VBmGWHSWGLbpFMqXQY6OwwnM3xk18RJl0Sd_Q2wIPTLdQmJYYffqrAbGhWIIZnVjSdz9LVBkLgB-DHREiIqzOACtHFIChAbHp6AJEDX7QwiFBfno-TGrpfrGpk3MySLngd5knM2H74rfjC1jLDBkoz_BiDNxIVUcpa-iEnxohf5kjgZBlwRGzj0jTpk3gSibUAI3xoFVEChUUDJAkC1LHRdqRUAKWAF0NnZIMinqjAIjAoM5SH0vVFndWfxmU6PXgcJdFmvMrFm5dVrr0qPFRJMk5kdMqjJbQ2wa0YCU6S9VaR4oTKQtoMVloMuTC0DTNLTyd0B6pOlwGsyehuEDPyg0Do5ygVLylIbDDLM6wrTGa2jOs8IRFvcxm0DfpbJgX7aes0GhaM_paZeKGDenZoy6EOcBhsieSrUkN5aMs9xmFcqbxMICS4QAiB-nbQThCUo6GoLlm9DPJazAUoiWJVg5aMuEC0jIZhTrIXZzABlmH04rrmrDFm2wFiS7UOdTM2LJkkM9hI8pOizMWXUBkWHzp8OIyGPAOVLhYVx5QAZaEfsdLALAlIBoWIeSSATsAKoGdmLSVb5hwWaAcWFIDcAb1SCJHqgiJITg8ldtmaZKZJEWKrrcJbtlnKKIK-dZKGAgOhJDs6p6jsndATsqdkZAGdnoAOdmzACACLsxmDeqCVIcSJ1LagY6HRPDD7RPXD7XYVgB3aM5k18XJm1WdHS-yJiQNswORfs85SAELqxW6WtlYJW2Cn01jhJM-TgBIf-mAqRHQB6HqjnKEGFTfFL7LQriDj3Oz5DENST74HKT_8QCAnsH8SbaOe6YyajnwSTSS6SbdZAUWWJ-XTihLDZDq73UtSMeWCyIc8UpcNeBrQyEirs1M-61jfVZngSyze2WloPcLKTUcnmjblXJCIlY6TLEUnhn3SM7mzcYCoxDIJV1KGLvgaTljgWTm92I-7cbDGSKc7GS5SddqmctOhDETNBzyYxK18PlpVZAtqk8L2rUXd8ArWFsBdjJ7hxyf-wwAJ2iuuKGBKrZ-IiiDzJo5ILkBxRiJhIWzKVQKGAxc8LJTRIBKgEeLmwASKC4xKZymMW7CJc8WTFSBA6ioIMR2c1AB3gZ0qxPPcqqwonA6wLEralHeqjXOmRV1UTgGYKupmlDDyFQcJIc0YIzWlNeyylVrnWlTB51eKeLn2JUQYeLRS6OXPZTAZMr6qXtkfQdMoEuMMpelYRa5lBbnvOQXihqBIqxoeblwgNbnBjAIYxlI5gBlEg4RVabmhqfugdxFISylN0p4hMhFLc_0aDcxFBW4YbmXcm9T3zWxQLjSforHB8KP1T66bNdYYBDRxy6Od0qLcvbmT9A7n5lUNQS2ZmDzUy2IX9VADOlCwiGzY8D_cyfpWJRewOgRfbI8j7mdaFPrb2T_oQ0BUi2AOVAI8yuDnNZOyvc5bmZlbHmhIF_ag8sZjHucnko8zrDrco5hpzf85Y8--YAZCBpTlRnnU88i453K3D_iN7lgwcAgBlEXlPQ1SY43SMAGYcnl3cxcbwrYXzk8k1xANIrkjc-RzaKcWqxoRbjJeZnA3cun4g07XnaKDnj4I2VJ887Niy8unmyTSJL8XPMoG80xjbcj0oPzVlL3zcHnS0sXm-ubIAs8lO5Dudy59Q5eQvck1wv7JXnaKfPqTlDHzB8jDw5KeAiR-C8q9cl0zSERbjLNVcDWlXtA2KOPmMVMPltqKupx8zXzilSyAToLhrEOSCRZALGQfFXGReaJ8iyxErnmc6kZSaMmxLDbOS5ISbnTAApqpacPZAUM_DdkY7m_c5MoktOmrHwM_Bn3Js57ozNrJlFCip1XvnctQvoLuCJLr7MioWSBbCa8yirsVb3oUUe3qwHPHmxacih29BMiq1EWrqWa04Ktfe6_LSUD8sFzlCtH7nzONOq2tFJLC-U_kTzDdTcRazzBqUtryAVCpBpURr55d7xhxaWmu5QiIowaWnKrfvTZiKrn0NfLCViYrkXlMrkHVItJzyL2r1NBflpADflmkkNqy4VLk60j-ZZYZ_jGOAXhkY1KnwAYoAbNCKKaLRNIWEMAV_oCaJ1lahq4BOMIBwrql8BXKn4BIIi2teWpTeXgHM4qGiYC-ZpXAHAWv80EpgDQgVTeYgVTeAVQNhLIZTeIMRgwULw7oXhxReLMZ0_SATsuDFbtARlz8C18Ci81mGSM3ShN02ihXOQAW1gMQVshXhkCBaZGC0wwXuhAQIC8VgU79dgU6AvhGAZYXxJyNICKSIlByndVRbWJgllFWLmTRGHLZsMAhPQ7a5TlcomMaHzkUKLjmEAbICoVIvkezO9hKc9YD5SZLSVaKChV8i8o18osZ189LSV88_nOcuCa2OJ0reaAY54UDvlfYTIVAUbvlP1KblOlPvnZCwfkKtYfnbEbI75C1LQT8qoVT8zrkSstWowCxflBzZflXAUoVLDNfm78zLA8YPoUpacmw8UZaB7837kH8_vnqSY_nD4U_mN80sqZtHWoP1O_lynB_lFmJ_nsAXgW2tMjHhCyKjv8kPIKqfuLZzH_lUCv_mMRAAVUCoAURQEAXe2cgXsXfHi9oc-wlc6AVJyWAWrC1BromWJ7ICu2ni0i-bxsDAVTeFAS7C2tr7Chi74CuACCCnfrCCnfqiCsgUbNSgVcCgwU0C6AkCBCOlmCvJFMC-UBbvKaiPC9AlQ0XgH2CmEZTlJwX-c83iuCs_lLFTwXhc7NjDsQ9zi8uZyBCjHzBCxui4tOrQqcuADRCpjnWc1ujxCs8D58p9YKSCmRhChi5RCgmR182uTm8LbjiinJCMyIEaj8uUVUyAmQdcqcrSiq-TlcMkV-clwUainRT8OCUXm8ObK9KJtoKPZbToPagAdtWjmF8TR7bFKYD5_A4pHFGdlmgXSRwQgEF7soEG_tf1LNDXSTETHc4MXc3beIYq7Kkg3AEsSK7oUQkpfaK5ZodeB46wdNDKGW9oaGT1DcSFbQC0GMVtsoLT7KNyCcSSqyHM3UDZityBTdPLrUSLMU5ixZQ1XPMUFindla6Ryz6RaKyJCXMVKcOsXOARIQ2dM1alipjgscWnSe8TnTqMxZRqNDsVccbsVYWGHTYPBKRjgDVyKfSWA4YHwT4ZOzIaLEIzjciJSHlO7jbCh-iaxGLKl2GmIy5ecXjzItRKFH2Jtza3LZxJDLf5doCOABjBZgAPzhczDYWMwqjRmTUTJTUOy65XcXw3WSrzOCKJ6cyuoXlN_Lt0YtTCFewE35Z8ZwET8VNObwIf_AIKg3QWpTlTa5ATTPnT0UCX2AjfIQS6xyvkdKh2DNAr89XSJNcp7IHuH7JvHJECn4ZLxFUHbk8nA_Y37bvzC-Cu5TxI3mhld5x-Ha8ZsTVcDzQWCULecia3aV5ZUTB3lhlP6RIoWqb-aMuJXAZwRSidpLilL4oSgYiREAcNkqoLEAauFcWVpXYJSS9VkY9Y7oWgIyCs9fP48uDVzG8shEYOWkY3AWUr5_cSGJc_ZKnAQMyWeJ8B0AC0CjitepKYFdzYSIgBPQdDibodcTZsPUqvoRXm_VAyV99SFrWqAIy6ZR1Sl0cBwauefIEeCbkt7CjiySo3ntZEQqg3dwJhSiJRuHMCXqorfJdOIigFYBKUciQk7goo-IdxDAAhSmSWZSlUTSKA0pFSzVxdZdiLNcqKUYeNM7AjKco4aCcqljJvJs2JSraVDmyB83Sp82AWwGVT3wFS9qU2KaqoVCvnIMKOlqFSLvpBSsqVaSkPnbEUEQPgLzlZ1PQaulbRRMKMqXM4WaV-3DPGNS4XwNSw-IkMkxRBsLQxTGCxSK0eYzeuFURBivXaDJSlqYLKC5M1FNZ_SbXr6AJKAUskSBjybpnUAeBoP0ei4hiow7BGeC7v7Cc5IXDC5lXeoLNNIOjPSlKScCN6XiPViD_FIbBYcTBRwSY2qKxUKGa8gVTJsYGqE87S7L-W9ZTXaUAa8mIyqADVw0SsbkOsAbAKkYiW6FI2wT1B3AzinKBTDKezaKKcWuAOmVVoEmWJS9aVHTWgBLirKX2lQbaatWmWDY01xky7jzUtVbk8nGIxG87iXvOY4V7INAAGsVmWzc_LB6_VmWt3JFBgAMthgAUPxeOLNxU8DpDHA7dBwxTKL8-E-hv5NW4tjQWWzi_Noayi6Bay8ng6yynimSg2WUgKdjgxQ9JpS4oKWy-mWKtY9xTxHVASC7WUdQKbx0SrZygwO2W3ZZxzByvMphyjrIHENoIToGaBBlaGghy2FzhyuXKg3fii10NBIfiBWWDYuaVlyHOVeyzsQfXXmjaObRSekUFBpQFOVR7KIDyyouUsRK3ChQvTmLKBDmNytyEfAU47qnaJRtyk8ANSHoW2hZ_hulTmWAU9_BNy84qEVd7zJeCuUAOYoJ5lcPAkuZBRIytAL3Eg-5kw2oguVIbbYyxy54ywy6ZnGIz5nEI5AS08ZwEFy6Nna8bFQBumIyr8LRiRo7CudNB-pGaCSuFeXP3ToTty4k7ygG4RQBagooideIk6BczyyGblVTOwA4aDRQQACHAJULExFoZRjtSIoigwBfQXeJuV9y0Oyvyk8Djyn6im0Vobm8g-VuXNsj2XGKhTCnvz7imKL1wOCRLYB-gWi1AAfAReXwZEYqO3Nii7WByxMcZsWJCHZZKLbq5YKREYIFIhUbcOtT9sRFg1qUjS8K0xT9rUxihQ4aJHSzLCVVbO4R4SnaSs7OXOKAliHS8Ay6GEAxnSyJTKHK6X3WeSVI5XFI00VmI-XCUD-ikMWlXW9plKR6U0ACGVsAKGWPLRB6oAT6Wj0b6UPkkGWaOW4z_SqvyIXWI5Bi6XA2XRc7Ay1PZgyyeyWKv4CvSmxXvSuxVMtGPZuQtGUpiDGWMaR7IeKpny7jXIUo8YiWEy_KXaKdmXeKH4x90bYiUyqCXUy7hQQMVWVdaScVFKoWWZKhOicyxcVqKtrnLiyRVfWR8WFbauWA8xKXSyrZxANBUgUOYpUpES8iPi-ORlKq2WnJLpWDY6pqWxF0zDKnwSh-RIEDK4jG_RA8RBeMuKWcN0Ungj0XScSqJjgcSWuASSVQwCpVT7EPl8-auXwzeans9dLwvAchQTKnKCC0HaTTK6cWDYn1qAxXwJoAbYDXIGZXFy_YRPKvRqpeLxqRJMcrDCt-W6RFuV2ZP0IwgduU-nI5CawzbCIKitbfBFARDy18WrqP3kgq1BWXNCeVplIWU288WVO8zaVN0bG4fQMeUAqj-UvSzkIoK40j57GFERVGZnbAHxUOXJJUI3RyjximgAqGJ_ZJin5YYNaYxSKpxYGKqWAHC8MXOYUJpjylFXoK72h4KjnDg4vonOVWCZ_K5FXQ8DeTYK8kz37eA7RRHhUWsXVjS4ARW_yXhXBKERVj0NyHiK8AySK3BrzGThUhXMjmKPSQCkIa0WACW0WnwBOBAcLUACSPsRwQAcSV8fBCzALXi2SkSTL3ECSj0rEACSaQWl4i0BYgXcCogMODVAQNX3SM4DyWHWCHslDloczzoG6TDnYc_2S4c3gz4cwkorsgSRBK6xUwEW-6fykSCSALNUhKhuTzHVnw6SZeAH8_yRhwD4BFoMcVTAA1gucTIDMYL8IH1O4DyS-C5HSlRWnStaDhgIMU4cG8DhACIDVcobQF0Zpq6YI84z0WsCMAA1iSK7QxVQDzxTGBuKGqzADVQKRUwFPVj9quUyoAaqDFKGAAbqwdXI-YdVzqw9XI-FskCAFBiyUoSmbYLEnsoMxAzAaqDh0hSDI-So6dfaqB6QNdU4cR_jGSaqDEeOZyWMFqDZQdaBzOKQAGsJqCv2etWNquECuMI8TrjWdVniRvxYCS4SriJdUaCLYR-k8HJnCZcTlxbtW44ekQ_ATADbibATj8ddUDq6gD_CAjWIavtjTaLVj3iMwDga4lCs-FJxPyLoiHq5JQ9sGjX2jQ-hoiGCBo9KtC8lLUC1oETJZgCcS3cdEBf1FtVa9ImLIIKMBcqGuSd0daaF0BzS6gRFjF4uCXz4Jz5BKchCUIcUDNAZGU8TPBg8MPhjoYOyi4gHaEJg7SDngNyFko_RSfiALiUA8KC8OELC3_OzVBndwjaYJzXhoubRNURWAKnX7aWQYOT2AUcxFQhME3q-0j7AP5o81NzUqibtCTCqKB5hYY4XAG2hkjIQA0COUDtSaZmaaz8QhUZamXsHCTI1JMaoABKjtSW146s9egWwh7qsvDgKjAadmaDFdmUENKj_EIIBefERB7HUUb_Y-oLsnUrVLeflkKSi5qD1aKgjgU_m5k5RxwAIgCqA61Amak4DBazGxhaiq5qaqLXhQGLWP0uN5xK20T6awkyhUNkwOEe8hP4CbWjAF5A_rXDiWasqg5qWzXhohzWRa5zVzZdYDuatyIsGJu5xEHADqa5xQZajIDaayzg4EApXTXD5rOJc8VomWRyRGB1ksga2hcYQ1J2OK8V0ITehRUGgBxFXqYtAaLwT0aRLeReRV_xSWCUIeBy7ahMGXJUEyRUReKOaqhKo6z8Taa2C73HbLWkmfll7re8j46j8QZAHLDIZaAnlI4nWA9RvBVy8nVJSb5Aaa6HVo6zSwAmQgAM62NmExbYhfGRRiG0eozQE0Tg864Cgq0EXWdGZozJ4WypYkRPSV6b4KLccOgGIK3BfGZnAS6jy4bVd8ioGYHTJ6XYxAjAAiK6xAxSKYGrUAL6BiPSaSs0FVBiK3iKSOI25xRKG6E1JFWAGV3Ukwa0qM65jTwaXiIZBBFgH3FRjn4faUcHJ3Bq4X-IEsX8gfoLEAEIBfbdQJuXWlai5z4ePU2KWqW_c1JXu62pXeKBVVm5dKBtKzMpGXSm6iy-nLKHfOU1K6uUdyvXbdQz_lZFSWVA8sfKf8inLbCkLDR64HDnYfOSnYcdKY7IQqERW0gznb-yEFViDAKZBp67J-JwZYLkEGS_kZSiQqXJZQ4HCTobz1H05PxXwkTUhirpQYdAFvBaBDQOgDVNbmjDoXfwgEdfXnNeCXr7IdxnpVjw7APdDty9qpWaHswZ66_XRAGcwZ660orDHfqQGKbzYa7TSAxR5phtIdy10SBr7ouZze67YCX63uWzgG_XRoO_VgGh_XvlJ_Xmlc3V8Kus4gG66xG67TAW62YBW69DhIGu6jafINjDDbzCqqn3VYGyRwhYNA0zADA2WCLA1ZiSlV4GobBngN7UqoIBwZtc3J6wXuiLgWuzaYFvXRGfRy2kL6DxJV8jeYS5LUK_qzjUbUDPQWSBzgDBY9SymZXy5mZ74KXJCG6uxsGjiYY-WwCiGhg6FUYVzivPYqw3VoJaGwrxzOYXxXy4Goe0Juod8dMxQyRerpJQiISOWzZwXJerBAZppyGiKqE4Vg3oUKoJKJaw0Aq8GK_aROXdQHvhA4V_AxqtrCociYHxq5JlJQLDk4dZNUEWVNW0EHu7KG0Grv4UsR_9CYT5YTAb0igTDD_WNwCQNUHyQJll5UI4AzQcOQuGnRYQvYGot0Q84i1U2gF6TbAQKLjSZYBBSQKfqLGGViCuSWrAJyWrCHqg1iPnSNju4NQRBsbo1tkLO5sKGDDa1MoirgDGqZYOeje0HgD3wilEH0ItBTjPRh1yVCAOCvWDVQKWbVNPHUc6gnWvalg0r-QHYceQDIW6-c5z6vnAbGrY2d0GCKUQRTXKarQUjqpHzHG1ACKHPDgxUC42T6-fCeEH9A3G-c5Ka0VXmub_V4wTLCWMRMBfQLXjc8sADVQZvVjgbTWAZbHBOSUw3widMxQm7TAmGzCpmG1EBwmuXDEEHfStGjABQmlo0uSDABYm1nBBsFE0foUk2IsEk1SsHYDkm2nA0mwhj-eE-LUKuk2966hVYmhOTVQBORYmkximMXygcmvWGYwLk2CmyIAcm6BRCm4ACNG0U38UPXVFpVk2ymhbBYm9B6pSIGbVQZU34-V1Qw0q3AgmydWFq-HYrIAmCG_SlUiSWPVaDHYAmmtChz4NraaMB3ANq-jUqHHvqzq7dUEsA1iTGCTRYm8EbIa5029G7FgK0S_SYAD00XoYjWbqqbyHq6qBdGh3CBmnU1KvY00O4ChbRwQM3Aa200QauxiZynk3SMEHBB2P43R-Yy4lCgY2NaU03-64NgjaWTzWmydV0aptVTeNlXVQIs2umtlWBmw9YnS5dXAAWs1xm1dXv64M2Dq79XEVKM1TeFs35m302TiRM3WMZM32m6M0ckQDJSAME3mwHU1z0XRSH0JY0b9HeSFCIegF-IeiUACxhTGmBj2MD9bcQUhC7wccQeMbfplib4StUOoQcSqJjwiQjWNKb_Dnm26jkalcQIYF00hsOsRj8eFgDm4liKsVoakKTmGniXDVoa-DVXmijUxmTTR_mxVjaCB83lxcRRnm-kTisSC3KKAyTUapxQuKWC18sXJTDaT83CCE1hxKAfWZKeiqKsbC0IYahUnmoR7W6lU3A7K8Q1MTYTBMM7yyqUhCMawRR5xe1ixKp80-m4lgsW3wAfmw1gcW4PUc4WbUzsGsDh66VgFKAS2UavJQvm_i1TRRgxJKES1TRK-UZsUi03CDU2OqbNixKktY-5L6DyPPdhRilh6lIDYqWqycQMc7WAmpKgAcHfJD0QGBEFfPAKIsQ9jYAASSYAGTTOQAdooWWeAOW-DhjtWMWUQNQb1weYBPSRT5IQRsH4nB1mnaUGjnaAK1XaHMy6SaVmBMuVlJQTjgKs95nKs81ZJMuT61shdT1sxtnbKL0V46Ndo7tDdqWXIlZzmQtabDb85P7X86nEbvjpkQ1Zl6B9qVq6MUQ6UDleWeHStYVgKWAfqjR6BoB26R3jKskroXKILR1i1q3tWynRdW5PhVdasVddFq2Aqdq0tdRrpG6Aa1TWoJkzW4rrjW5q2igQa1BM5wAucBTjudFLpWfaVK9Wy5TzW_2TtWza3bWy1bJ8AJD7WnkqpWHZnIc_a3ycC7YWrc5Q3Wnq17W7UA5Wc1ZFWORU18MrpqrO2A3Wna13W961ClVVb5dAG3nWxixvW6rpaMu_79AICQmWg6WkjAKizgCeDGs8gGdM8w7tTPdwA5btAZTdtRwRUgZwSEjbt1CBjeJBNZ27Fpp4CUy0ZAIlkCHNvSg0YBQwOL6x36LjV-0REDQAZFatUYBSxsw9npW9_SZWudSvofWZl6JKAIsyIIGvR7JDUYqDRW2VlSReVnFMn-mJW3a0LqJJlP4Fm0y2xa17s-W08WRVna8ZW2qsg3SrDeACi2wfbi24jxbSxaXmaNAC2wNjSOs7io22v81v69wgi2sW0zywJa5SlJV6KfhSUAcUASrI1azayzaDXcNY3SyCJ3ShzbBZUhwzzX7QBIUVbObVHI_3TMqT2KO14CGO1VoYMy5zKG7tAcPK6mRKjLqXhxB0ZO2BIUVafgFeL25T9iFWykAsDQrUOrU_ARAcwhzTKPIR2TiqQ69tTfuD3JnuaqYjgOgAMgcH7MQEQD4gKgQwsnY6Emk0aBAAgAZUYIBo2xLhEK6IpJ2keZdIFO2irVPUb7JO1l6YCyyrRWCp216bD1a5bPaOPIF2n20b24q1b2xAoQ3Y25tBEcDE26KamsxTYV2yE7ygbxCr27EDr2iVZb2ku3WoCtpH2hfTEKhmgL6F-1FWt-0DYDi5gbfvS_WsG1hWQG0CpKG2HLd217SqWBAdG8hkLWUr_nIu3c8WtYGGR6zAOgVQvWmNX3W2Kz1dbTImpLe3T6R3VvEYeiL2xTR8OefW38YuAt20ln46d-1SLGvBgAL23_2uVZl6TfQe2viAsOkoq_af7BQyNjCIgTXAFAI1wZbe3JEVV6roO0CLXS0iqh20Izh23HKkOMR3JrAna6WqhVKOjrYos1Q6MDZ-3z2l0xcTbqyZpNh2b22O0JxaKKCOxDpShWcCiOzR12RXGWVDNe16On3xy0Wx388i47JK6DTo3MDpGrVR3z6fe1eOgUYL6dmST2ZR1HMSWa9zWfaYLcuwBO_ETH7LmqFtEOaWcCJ3d7QDb5K74JGOvR0v7ZJ0uaqylfbCew9Xbx0SzW0o3SQp3cxR-q0RDR3s-OJ3XpHTkkwRJ3pRUp3_gZvZHir4JW4DJ2-2gB1L2tnkf9P2a97DklXa4IwZOzXBb2mvbwAGebeLBJ1j2D3IZ2tIYWO1u26QGLzCgIR364ER0JAUJ0s9HOZn2p3VpDLIL52kJ2uOhvb_SHsgWzcuavoUh15zIUgOaxx3DO4u3p2rZ1kO2zUSrK526Ojp2UgN-13Oz_LbOi6YWgH51QxXAS6OzXB13HxZAjRFbTDFB3LxJEZMOztaGZHLT9Wya3HWxa0RdHq3aZIOjrOyzJDGOhW3C2F0TWta0LWnXhbWtyDCWCG3QO7_RsK02hDO_XDEOwi4vOo-1UumIkIHKF1pkcVDVW7EBIGWRQ8Ok6jGO4q18q0SUo8W2BuWvlisiL238O1VRp6TB0JqDl38KDr4A0NzSGVOsHuWoV0lFEV26wRy2Iofl3yuwV3yOYV0aqJxEcihQzLXDOB03cQyt6FVAWO4R3WOtZ0HOjeTEVfq4Yuw6brtYa4fgSjILZYiJSMEe0fwd9zfQeh0bIDe1t2l1wjuYMzrqcOFASMtJR5Gqi-UQN3lQah0LUfEIjgJ-7YxSp1j7TUUnuZoCcZTla9oL23ZgY8CYmNF591SNZcEM10rOi10weZoK03ZN35u1Zo6O7OCewVF0HOyN0Bu5lqxoGRxR5Gt37Oqp1aOl1wfQKIB7HS2iVOXlkxOyIUduit1MnFt3ugXt2uAUOSRuycoSraKaewcd0_RD3KMoaN1xuoh4Julx3tusSAWgYqBB0Fl388wo7pulV0KurAqZu0kasAHho5AIb7FpLSCXqxWKoQTYy6KsjQWoW4zEaPSTy0CN3zZfiDmFCISKYDjAGzZqg1wN-jb6ZyQmjH-36ABKiCMggzBmD9gUFfuz_dQmwGjID0JKXO3CAXYC0YYKgBCWgZheVqC5LDt2dK2YDy0Au0j21w1vVZmSRtYdYs5FtBBs1vRUpZfojgGRy2oMMznyd0A2mLoDCMdOBwRU4xjSAUyTgZnU-GZsxxGTYwN2by1-QTkx84fy3hAoK2m6muj8erwwfUhxoIcSsw5mVOTTk7firgHwyKe6sy3UVOTA0DXUT6DUDvTRvCqemsBBZRWKgwEYDVc-ABb2Pj3BGMz0fwQ9A_GLexme1ACP62FwQG2FwwG8z07kaxz8mVnj24JtK-4M3lp7KzICgOm1B1Km1BsWm3NDTm0R0SD1EKkRCf4fMrYgE22H7DlQvVHVwuOJZ2WOnSApAGx0bu7OCi0NvwTGxHUra3fUBFXj5KQEAhjASsrh0nrgFHfFkSgdChpaoXY0AA6pcAI6oBUe1BqgsRm0xGJb0bQRjiNRtKJAZtJdMmllabQb3NpPfbFZXfw4JMr09cFRhjAOMGxs7qp7o0VBBck5lze_ygQwXriXymvgjAaSWBFHrgtRGAD7ezspRQOb3zQboD-UZb18-UU4-GPz1DegL1vcl_agwF70jAYLmoAHIxBchz0YrL73lQHIxvej-D_e973lGRhrWoO71XoB72h4M3nPe170b6j70_euH2fejfWZ5DFZ7ewH2o-xH3lGBxi4q6TRxGe70Tepnk08tnkve2z1joT73fe0AjTGFH2gEEYDo-mn0OerH3A1Y-ImgIOaiC_UBS8CAD4-9fgmyYXnyeqtBc-qH1vcxirBmFQayYcL2IsWWLsAXpb9LA2bBjVwREFU_AB5WJidgYSXK8bOAUGE-jDLcnjzwDEDsbStnApZ92g0BfTrDHzgI2xFgZ5c8pcaQEghe5oYYOcJhl6SPajO6m2j2Mi7OYSsHxegQ52-q11mO98j2-7EAm-uu5y-zuS2G5vRWxP33wARPaS2FqIs2uX2b2bYhS2y-mTEbJ1c4Eoqv7NNLSTSnn0i_iiwIgZZVoZcw_uLgSx-6ND8UW22x-oCrW8q3CRzVpKj3fRUGZdwgMKo61tWoJnDWhoDdWqrraZZP3ouxWKmXIOwucTYALgYBSFUAuWXFZkxHEbm1LYTjQSQ46qbyxQ59-oIBQAQf0ieNL13rD-0Su1h3Sun9CFuqx05ey115e2bLryyVUf2jV1DMLV1Kurwg8qXc0kMx3YnLVPYqoIP3x7FvAgXKR3WbcCLfxL5neTGkSI2uj1fWTGi0YA2bK-9ADOCNCzk8KZ4LgSxQ1_AFmu2e4m3GPELRK4AVqC_BqW8kUSgwOX1-m5RWoBtlUblW4ws2h93A4UTQxezGC4RGRwAB4SVgeGfq0YaNZT20Fn2i_tAjgF0CiIajSAeqe0p3dIRcMR_yUBqxDAsnY725MwqcZSwqUbOHXL2LXymO0AiQGR1nV9cfVWIcOTEua1AuZASBlsASbO-yL3OYeQPQZU5Ie-231d7LYBBsHwrYAeeru-m337-2QOnJNX3Oc0wPeoe4Y18R3aa8xbhB-k1CirYX2NumZ2RgR3aMO0DI14Uq0s7cq2PEFwPEXB_1KEEC5j3U0V7sFEpQWaTyvmOjnvmQAR8QDrw3gByzHMy-laI3mJ8QMJn_WuK1pQZb3JBwBiyweIPqsjpmOMpq5kSVIO5WO5my6FzqocgJCGgLqq7-LDDXe_jCxM8JklBlXSAqMiS0ESoMSBxlBv9Z4DZUa2h_PLUjWiDZlLdIoONBj_RlBvnR1B9KANByG22GMYOtB9oMExf5CEst07kAe86TuMwSCMkY6ljXKgxABnwk-bEJdAewjco86hM0CdZgFEvrfWlHh-vWbqNBlio9ISnAMVdYDzAFuTdfcSlw6h0lXAHqpHtIIB4KLrhwEiwAcBRvA8yb4MBwvSB_B633J4G8DCiAOHAfTNhQhtkndVSLR9ASQ7dfIqmRaJ5VXASJmNkxDb8YERLscVXRKYCWJKbEXCtPCBUvHZYOJAeoBzYZAoRCI1JsuUpAkMs8DESSiZ3gWDzFTa6giaIIRM2mVZhHM_RdciwAvLfQCxnJMbXUYLbFOvdA0AawRMGtfUShxICa0TUipeNUU8hnBIyh7PUR4GJLdnbSYg9P-KIsZoaPUXkqdeTUZM7SjxyYPhDOAWWCUh6gC6PFkBN1A2AF_EHqa2PeB5gT2BvvYyGUK3ECeu8EkE8YUCTs90Ovs00M5B6TyiQoWIMs1nogdGqTZwW8KPsETA9gmZAlqqHU9SSTBXGNklaIioSVAcvpnyIYB2e4NwcAJ0b_a0AhMxYMgMjL_r4DdgC0EAC3RJfLDWASwg5ABTypeHKalh8sOpASsP_dRg7BAWsNzeYsNMjBsPWif4PNhwRjCiQ0NHAOsN1jKcoCYenqQ0KsPsAf0PcYN2zQ6gV66bEhkyQDwBmIPhBwADgAqoW_5LAPwFbhjwDySr8K3_b0zJh4t5E5NKB-Aw8MeRY8OKxMCwSQW2BgWfjAXhts57IC4ys25GwDcPTxAaB-AYOBVBE2P2gKod8OpAT8PyHVn7BGdcN2Sx8PHAeOQlGavoKoW4z8yKCNsTFRhKQK4A5AfjADcaKIDcSzgKoJ_D4gJSouuFuSygHZE4qw_1V4K_z4gdnU0-U2gbHScCNUd_A4Rm_zV9XcOHhnIDhyGWzs2MCzzQdSW6lWuj7hIlKP-FIA0RrHB0R2szV9eDL4s2Nm20jsKbhbWiP-DwACRtI1QyI4AXVQqBiR8OS4srHA8Rv9A7hK3B0RvdED4fECSACSAcMrhXH60AigRMJCsAJelBLY_yWh4ZxDAGrhRuqehqgjRRWiFeTls0kbmAJcNXUP2wXBviBRYTzg-20CxpaW2AfwYKM_QW2DySoSNNMW2DsAEpFTh8JnxB5SNMLGACWQHkiWoVIMJRwqDHdIyNPWdHjRRzUhmh3IPzQXfzqMRz4xRiiw5BmpmJRgkYpRzpCWoAqOVR591pQGQGWceqPpBoqN8-BRTRR2KOtR9jhVR8nU1Rv6o9RywOsqH8PI2Fh15DJph6SrTzV9CAC3GLg0cAY7qRgb6LlQDBxIWCSALR9KDLR5oDHdDZ2Q8JqOs9JaPV9Q6P-UG2U7Rr8NOALbZlR7KPnpF4ysAJYDRMMkCPR8YAiaXJwpUbz1gyF4x3UO6M_Qe6NPRmYCvRpwDvRs_YvGGYBPRr6Miae6MAxkKJjnPQbURl8Mk2dNxHAGnaWfSqNAaMh7E2P56sR5GNxB1GPnUdGN-0TGNgWbGMJRkK4w26RJjHTyOOiX7Y-5VF59ALr0YelyNxUctnOsrINKCPDwBRjwDgMGR6ixdQRlsPyM6eDwBNMeyN3VWcl6usK6MgAWOWeNLRbBKlr75QKPEzCWMcxrmN8wZzC8x8dXFAJcNevGJ6ueAQDvcX1RLhtzxLAfWOueHzycgD_klrc9KgWFcPYAKWMMG0CzeIItDaKtEDUuKhBZifHRZiDwAKFD6AuZQtJ1KBcBTjYVo9qebAugF7wDh6JygWFAPBx_2Mn0RyIIyqOMT5Z2PEceOPVeF-joCJaPCofmXX2ZOOUeSsoeI4ILxx1-hpQYoAKQX1S-xkOOv0XzxLEkyNlxhcCv0Y1UWAM6ZoAJ8DDDalqw4Z8ORqiy4qMb0KPy-UAKQH9gmR4xytESAAYfXxJogSuMWx2xyKxwTy1ILAC2x9KAR3HoCOx33aTgeWNsxgWPKxuw5CxnJ3T8lePLhygAzxiyVLhh2PtpXyXP1HDiogMsM9hlVDaCZCZAaTpAyybPwAW5CYPcpFCjER-1oZYdRI2f2iB0WWjV9QoSpjdmxfxwwiV3I4h_x--OFQeaD00A5VHEHng-RqbmKx6bSogdTzNq3mMNc-ePguOKUgEYW6KG1IjbSh7xIOMzx8IRkAYuHzjUSq4PEdRoO8SyMD8SttjkJ4oOgwZwSg-zbJ6sVEBEJ0Iw7qi-MAW6iaT8NhMkJrbhA1GsDC-RkPMhxIAYuUwytef17FB3tVHJfhACJieMmHbAACxtLTYAPcPdnNKCSAAAB6XoVmgqclcA3z14AvABCiwAChgBUF0T-icMTKMGMTpidBgeicB2FiasTnIG9U6EFyYWwCaYKifHVKoj0O1qH7OMIylUrOvvInidOgt-rzjuvL8TMpTZ1gSeHMQFSigwqGZwskaSjESe7Oj5XAIISb6h0bFz5KPCXDAsdcAc8b089sb2AzwQugGsbrexsfeAusaNj2sfeAKQD1jlSfBINSajuBUA_5JDPUE2SdyTC8ajue4dXjLSaVjsfDQOW8Y8lxTStjHMZyTacaPjBSY5CGGUKugPSAswyeUTipg6Ty8c8jxM0UTHMbcTvJg8TQycE8IybfoeSY8Ar8h5Cu0rgTbMfswABhg4bCeljFOsykr0D5jjIBOTRNKzAx3SmDTQbsMjzJMOisbYTdydegFyf9lNYC_jmMa3jh4eW9mUcmDhQYoT0wdKDqunKDbQcNACwbFjX6xGAjavOTKqFQTbbGFusUcyDjVt8jjIHJcyCetjWAGQTUMnlqbMZKlSZQFuaTqK9GPm6T08ZtjacYXjr0gGd1caXxh8VNVsljAGG9PAg-q0YCNujqZklhPZpoDre7b1jenICE5KPG4MHujokpkRYqiunkgiukCg8ib4gpJx8OvVrMOuZIl8ryb4gN4FFAMOgAZrAQxUGHN8sLFWM4ooBdg5sF1KmaEE4SYSdglEm6-7Gv1Wmqe1T9bN1TVEn1TgVhYqREk86hyhoZnnUBUZqfWABVlFA03ToFyxjq0yyoQhuHXOUoadPBuHRFTfEGWifmEkie7JKim0RYqVdXkgBnMzQ20Xkg20TlTWlsZgoQaqiBljvg7KZAAvmEncEFkpZKHtcEClhzEJCSD-CeoCEGYZ6krRGtArkamAevOsEvES30yaeC8NYAGsTXH4Cd1mwiPVCkF-Ass8jLnZ9lXFHT6An1sG1I5s8kEwCkvhrTLYtoIUgoF946Y59a6ZQS4QznTpoWdCi6aHTK6dAI7QAQDWYgnTMQAQDW6bMAQWWkeNSkt9taekUIJmDdNAfQoK_FrTQ1XxCb8FuM8VEsstabeEr6eXTmeri8pyXtKIfvfTLSqyl7ab7q3NFgDLTrBudUox8rEv3RQiYMsqMUGMdzqfT_QdYE4QnbTPJxo2fUlgDBIWCMl_DvAWvDyim0W8WWcEkcsDitEzNlXA36aXTTEhyYks3_TjGfv85TuCwWcA54tad0DWAB6YLGf9klGYCK4dMvIl_H5sZMJZF15R3T-8HCw2SrlA_BoLu0jgaVGvJAQv21WkHeCIwqZIxymDgJV-c2f88h0GiWcA5htGZrAxGcSApGc4zksx05f4rQIF_BozmVXychmZKM8VQcz8wG1qHsU2wBmfmARmbhQtman9-dxhjGPk8zbhGXpcvBCDT7QfuohnvGBPAMt9HI_M5EBRYREqbgg7UXaCWbc-47WXaC7VQsM7XLVVonnazlqnaasFyzxKs8tgJCgNMHGlM8SDO0YQMCt12k09ycFjFugB1DBxTjM17PBhKQDHZWUDCDNkZFAAkmmwbUFckZjMrVfWZygA2fuJDqrGGruClwroFvuIiA8AGCAmzJx20GIHJ0sY4BkGVfUrVZ4DWzeAn26ZfRB6-lltUoSB6kWCTFWtAyVO5_P0apYw52kq3F2m_St2BAHNqj8zv68HwsKj_iwSvO0QGmvVrAobuez8e1w2uA1B68Az52jYzgqPoGsm-WH8oFZzjOhsiuA1tEhzXpwhypdzA8JLXod5fTVp3PTDoQi39GYuGvtQY0C9kYDEDipgFc9QDc4p-B9ycmHbeqObRzUNDDom6z2W6ZjhtI8BpZXk2X6SAznWKu3JjFEGQmTY256dPXYamXmOzpYzPcK_QXDFNvY5UKGjtbWFFiPfCiQIdOiGmvTB8rfRyFtxh74LvRM97AGVA9fOpmonFeME6AQIdd2J6X3JUToGZ740pVBzS_MElIOYc-MZ35OsV36qmmEZ6snjX6j5Bf6_823lhdBNzJ_X3wjamdKnVsawLw1NUiKGJ6Fgap4vuYsl7JA9ziuZ7KPuZbFYrVrqP6CDzqMAsW0xRbFYebtzmrU9zLkUJ9Pu1NoEedBzOAGfDTuczz0PqwAmWFzzVubiOhedyGT3qgztYDLzpSH6WZOsjzVecz9kdEiARVV-53M2Gz6AFGz0VAXqxJhlzx0zrzkKwnVvNwzz5_VdzERRfGepDHzJWxfGlec3WPGZ6YefSEzDdMmIKuZf2PfFxWAyYx8Kuc1DrPWykmqQr50SAlz5sHpDIueM5-VvOGPmmez5tUMQwQ38DfSAVzoOfklk9RpAqueVz__VK2qKBPz_-BvzkQ1XqluY2djeSw4PfDj2ylUYlKRpNOEwFZsoBfHkOlW5sMBeJM1Pn0q1mcxYGee3GFl3dqECzZ5m2ZGEv2j7z_aFBgsBbUAovO36WN2IjsaFfzR9TZ5QnoWzU2e21_QgJ1-BZVzRBaQL0PLvzuCnraxkZ3jVBZ028qbbTu7RImB7WZ6CkbAmHI0BGTUBwmWB1boFjWEL1jTLOpE3YaPSqCWu2dDDE1EVs2xzLgi1GZOlRwngczHiEu_jhAjqQaA7AEd2kgBvgUsGp--QBg0ArgCBrp3k2kvXJFjGAuARYfqWEPWImn9SQm3xT1DYQky8mCtqUBOsKo1tAGjBAGCRyE1LG_GzOz8AxCUx0twKsusIAi3AZQbhblAE_GNG2In-6yzkSoi0mAYfp25-WE0rWoSlnK84G6MMIFZQSRd0GdOz1DrQwCLH4iCL2GFSjYRfp60Zn42rsAaAXHEsArWFPplJR66A1BiL7ijiLJRbHA5ACSLemymTfxXwmyDT3aihevg73JyERAGMQ8ksYWPTlxMIgAbc0xedsBwneiCGiKzkxaELXheZ6JZzDqF0BCqyGp2c4Ed55cxZNGGXEuL9hx-W3CeNGUod2Lnhcwm3xSloX2A8LGE2_qzPW9QKAaNG8xc6yMhwqGlEfud3-VKAfxfMApcfBLtEH2kpPQ-Of_H5mhngnGTMwOwX7tPcsU3x4xQAR14fOIq3kWF8ixLyd_vJio2QH48aRbruNCaid-jQYTlEy3sDdhCLjRZeoyKFWLMHnWL-wleyaGa0z4Mq6Y8hyPAtociodVS1ZSlXAj9GsMOcQihk5JcKU2skYTu8lA9Fiq6YVJcRcj9vEOdqn5LtvuBqwBcZs48iUqGiggLHxZZLHeT-22AHZsnUuZgKBbeogSvp6xHAQmLJah5JBeT5avJJL8xeBmhsWFLOXjiEM0StEvJeyAKpbsAnVW6uDNGfjUit_G74uF8tY0Q2qheO62odsjpDI-KY4fYaisjkw57Uw00FVgqAQjmQpgnqkZkpWoIYeO6k4cVkLfFrgESkS16m3YaavotSyQFKWtUgQsc0hoykmEy8pR2UhHadfpIPUKWrRFzg4nEKo-ik_cDpOakK4yyL0RHKgfdomApIZ6kgEgVgUsGSAjWaaQHDACEeZaUYUoA5EeYa2RIPX9c9aDlwzkCJQpxkUGM_TMK_AY_6SRd8m8Zf-62qUVkrDBmQyvEKoNG17qUYa8jt1BqL3S0KAIPWr6nrJjLkYDpLUMGQmhUGaLIdkwGVPVSL8xbXc0zMf8mXjUGNw0FW5F2O6T5eLL18CzZ9xJAKQmBFO4QhkG5Ns7Dao04WEk1qk6WpuLpozJ6f3XbqBULHAQEQtwMFU9UNG3W-gw2BIvK3xCmOcXGUvqWAHu1sBlFb4GAg3GEcSzDcF2ZCE7kEVGMZYNmBTC2C0o3cgC2bEGU8Rtdvk1jGSk3jGlTgEZcr1KmndwGAeQASoJYxNSiZc0m1tDCEYsQdWvRhw9tUl-FtuwvzZ7SEmqkXSgQBzQrU4znG4xTN5cQyOGnd2UrElaOLsscPmgk3Erq43wmYlYpGtlaPla2BUY_gqlUikzcrzla0mHvhR4LNubz93ONowRnTQ1kC_qooE_xGUm6zJMDPAwCkirayGir7BPxzUdGwDmMCSrGnhir4JWnABQFLQ7CbirtpESrUjPM8OVb4ab9AKraVciAGDgirpVbUCm_lqUOoeKrmVfqrS_mqrRAAUzv1BpD5Ep6Gf5YWOLQwGE7AGWcBCawrDfF2uPanBLcADYaEOwomVExMrJ9G1MNxbYagfpxqNxZQDW9nxLQGXQzaRfKgvlqCwqSzEZDUkwGmozSL8hzmQN6jGr8BAoWk8X6r01bQyj2Turn6Foa3tXsdF1YdL1kjZ56MXYJww3Q0U1eQy8RZ7Ohever_1a-rUd1-rmmCerUiswLT6jWoH1ZT9zcXaA5kPY4ww3joxJdBrqfqRrVJj6oNBqIVT1atm9KdhrHEEurpJa-rkOdxrwZhdQkRlFLhqU0L4VDRNMFTzAp5cEYzRgqoF1b7LTlYuzu7hDMH0WKg5kL6oZzv0KBWsMKn5BdWeCno8LDvhoNtFrLdfSB6sAwsAnDnzsUxkZcUisZchDVnIkswn4jxYWrx4F-LueQ8rKtjgIOtZgAetbJmr7Ehw9jtNoqWZm4xNfhrDMy3zF1ygATtmaks-BT-UQGDcFDSDRmkAnQNtYHgdtflAbtdcAjLk9rhAGGGINauryeXDraReGjfEEv4agp84GBYiK80AKSY5GQjYDVnVQZfMg8lQ1Llsi1LcES2L_QfjrvNjgL-dfvwxdbUAppeKqX1iaG2xETrltcK26es5qGSrz640XuJ4GYTo1cvtOW1tFAQqgN0ZWEoAP6eXTUSy1g3dveM9QFFt57pwZFVB5GSAZAKnFdkG5rIEoNqgskLaHMhufsm9HuVxDqumxzurL4D7dVXLXOXSNusEDc3QGRrkgAGo_lCv5T1eRr53L8lLPpqVEQEHrPVHBdWedKQiphCr8vPorUdB0ldPzECs9dbr0VDQDStHA0kQGz1vN3uJbpuAb0EVAbMgZzOo7k2wZjPGr49WWrM6FWrl_KaGG1eMqVDnIAuTmV4K_05IQ0vRMceyerRDeZgqJ37AEDdIbagEywq0CKrH1WUpg7uPAgmCr2dtHPCFLEAbHZTi1OIYaAeIfPAO9bf6e9f4gLoFvFR9dSyn7DPrF9e5o0RX-rN9akNfEDM9VJnY4uBWxrW9nv15WapMqciaGQDdOlWjcwDcMAGwWjeRrLsUUb3-ggb_NeMbjpj6ohp0hr_1cDr7tQgbEjIy4dHGGcz1ZegrgGAsMVZZuEDcDrzODqrUVfKrEJXyrM4itwfjeSrMVfXCjKPmc19cBr9jcAbUdyOQRVZDrMHAarIkHYbJeCSbztEiAWVYEAKTY0CkTb-rNxbrahdC0bkOarlEDZLl3BakbSlYMr_vCob2AHSCwJZSVrfVCMPTmkoftf-rmtfBLpZRlAJ9D1rxo0c9GDf6r5Rmr9BNCeGNTdBgdTawAW9h6bTlQPmjRVFOgBu0czTdGdNlf8rtTftI1Pgu8UdcdLgfq6bj9RmbJtaGbL-0Gb4JaYTCSWDL6orGbTlbhlhyf1WQJSGI8ddyr_DRSAonJSSIGxMq6rjazaewCUJlSMbPvp-balXMbPvqzrRwGalyvGZs2pYLrBSSSb-pfBb8BYRI5dewAldd-5CjcdMSjetiljdUbZWcpMjplTkKdeQ1Npfqb1NQqqs6sJbUzZSTQDt-bijbJbW9mRrIkwJ4_NZpbFjZygVjY_tHzf8A7j1m-TLeCqANcbwTLYCcFtox8oZZULdSwEwAVF9AB1bzAVoZ9szQAEmqza1qSOZKQ5fUjLIoDsAnxdjL0FfjLI4FWbyZdowSYxkg7gFxtYjN7qnRFTL-qHTLR1BsLvkzyL9PU9s3ERPLesDYY55ZYYTP2vgulbGLrCAebNTbb06xZfz3reBbQUGzrp0Vzrq-pUq4ZzkLFIchzsLZLrxpYrr3Uo8dUwCMq60fWLplXtINLc6Fx4GIbdDbHAKpcYbYKD-cWwB-E1AH-qjlRc1DQo0mtlYmbGzeh5t9e4dyzf7llRkUbYMBtbL1GQy1LbwbfCP5rzbZTbjLY7ba0tIa3bYjb1udhcfbe0jHLbazg7f2L18HwA47fUhNLZtCyPgrbazarbmbeh5vsUuep-3mbSOqWbOo1JM4zcmbF3gObbbbRbWTp7b7bZrbyfOabx7ZZbp7aHbvbYvb1qCPbUbbZ5LbenbkOZpbA2CPbnzfUht7anbFIe_bXLbwbc2RMjS7Zub_BfDOLOzxetgG8E5emTuAjuabhucVMQYhIT2iq_gcABg7a9lITc1ecwyHbdLOqul26spGV92tz1zTbDlg2IBLC0ykEE7jMEmohtoas1dt00j-6Dg3VsVgEncjJxncwQFLS5gGyArGyoj5QHXoU2F5y4NBGOfQv7ZTwDselTyng1T05bnj28eo9MlGNAHQgUCoPgRkGRgXoWxM2gaIAr0AtAyYGERadKMgIiP8Jm2EV5OJdU1ivPPsJCbI7CXkXzmTAObVnZyguDZrbK-cGMJkdRe0Ha2cmHYyTRGif2UHfQ7WziNcmHfg7hQOV4RNS32qHZiAfneNtETjg7hMq32CKUjONsrbYWsq1-wsvpTCKW7qCiSDE_yx87aHYw7ydyniCHYNLSHfPs0hZQ72-bbUbnci701ei7cXdubUyZ_2hB0Ewl1iizZlcAuYB1HClAUgOlAWgOJGXsr3ncPlAbcVilEGRryjcsbd-ch-aXBSr_bzlQ0pjZMdNscNRF2l2Q2HVL0oCHq4B2ZgrNmaAlZS672AE27yLaGlBzdGd_xTDlkfSOa9bfyVsBWzOTUoUqLeTZslZSPbyNdhb-3d-5IwGfDD3fbbjkVFQIwDiO73csb4VUzjT3NntpDkw756hAISp187MHYC7-XYObhdj9L-gEw7PdyTlsaFe7aPIxbOUGOZYdAaSJwargMVZm7VJjm7uoaR7H0BR7uPKMbxRqx7k3dx7qAFm77iEDKQcvfw33dR75jcx7E3aGYU3byAePcdMBPbp76uuSApPexrsbIiArPcRA7Pbh5NPYEOBt0_5Z2aQbJ-trA1EoOboofuurcnFL2cyVO8pembpHcYTg0p8aVuGNOp7ZZ2TNzPe46vWZhyeMADIeS06sHFecoGvz2IDJAg4CZmiyiSbb-W_iG43wmZk1kDwMUDm7lWUQGszUDjey97DfS9qQsjWSh3aS7pHd3gU4xxWUBQuzMRltQoEHAYryCqa0fdcqV4wRIO8pOQPnHQAiMEJAeflb6V2FHg8AGGA9MpHUiMAL7NQRygBpgXgnICT7LUWfDWfc_QhpnwFUsCuw1oA_EynqAiiMDfDGfaAi_zR2ceudie7ffYAd1QQI0fcQyxClwktZgGY0hcn75gDbYJyB2cLmROQgcaPKaABfYs_eOAnfabjS_b1lmZf85OyZuNJRgFAVoicllghclAh26-UolH7Q0pOQ3mY37-Rhn7SeY6QhpgslB_fslx_et1H0rjczQwv7BUCv7Jke-CsTzBgN_bQAD8FX7JRlnI6gHOm7QEAAxn9vgOJP8s6OpdMbpQYx1GxYAGfs7OelCNxv7ztAQAARpHAPywlaJ7ymgAgy9AUr-wFlo-44wD4gNNTVaDpS1E_di0yXw6BGXw84IOJl4K7RF7m4xb7qEH2B0Q9_4LlaLAK5ZN4tst1gJcoTtsVpAVJmhctAp0eLmIPQuhIORB4ioU1G5101H6mSVHSpPrSoONoIQhUOg1bWY_KFlXeeh91Apa7WMebASx44QhkBQwYA3YA80tHfCeEjimFk0bB4Fl3WKo4oKMYO-2DIYi0lcAQFXKxVFD4OG2Chb_B32wq2I2pvBw94BWPrg31GEPSwuhaSlIawgh3LhVWCHhjshOxoh-xF2NWglQcMfdn5Kzl9Bxqp0ONIo4AKRHaepYJUYg_4C6IIOMRHw2FpRj5ldTlyCLpoFTGJZIZmvXF28z2FugKIOQtCF1nOpYAcficrGh3k0zcbsInyDDnShy0O15XPzH_FIPhurIOeh30PLbd_56h8txtI2MKlhqMOpoDph3Wq0Px7ISEOh4oPcVGmocfrkE86tvbMGPupXDV5XbMkMUThxUIReQari6gjXd0M0P3WliXJM1cPuZSuol7m0ObAgXQZ1OoPlB0cPtpg8OYZksOzhzcPCtoOpNS58PW7kjEMipZxnhzNZ2SGeoevXV5IR5QFY6Jlhxzu8P2VScPsVUYpek1OJMR0EKxdrA6KbYMpDzUhqHh5Rb5mNRacmHeIjzbgoSLYmwRhwaJrxLSOlmO6zzmJFFOWJ4P7gwRa0Lb4O7jfyPZWAEOCWEhaG2CEOl7OKPgh5EP_GihrjWAKPRRxhbDWMKPtWH2wkh-OwvB6haRR-paCR2xsOB2_AnwIMoxEqDgImN8gsh0Q8TRSvSFHqfcj-UQ8GB72ImB-AJy-KwOSsxgQ3GISVWxAfAKCAJIeBxfdOB5_cTLNABQEH6OtkHwPJkBewY6mi0B9GatY6ryVuOCKUSJCmL1iroOKbXkPWcuehKxAnNDk5DwaHkQ8XdndL0xx8OCh49Yihy8Br_K4KNh_vByh90AoxyRJARyjxGFqDBsR_AL2GJaKZmo5EsR6CPpjIrIyjZMOC6C61qSg2OGDMI18JgiOhSIVtGFg_QCkqckMCMsLgsKW0DbCpWim3iWckKSLah_xQVdTkhZcFuOVK_PKERsZ3YY9iPiW-gtvhwhWjOlyVhxzKsDtV9U1Wi6Zxx57UMCJ2pT9sk58JtOOTKtpyckMq1Fx0th-7reOdgOq00kkePuxyeO8R0f6ZHnJGtRayKSR43RT4_hgSkBSOAWwY1WR1RbDFn0JvQFKBX9ruOdgAgh0ds8LXzQ2JRmw01tmqzxqR7Vg7Gm416RBhPLUN8E2KnBrmcBNV6J1bhsquxVwLQBaGJ6tUmJ8BkYHUgRbU1UofcqGO64P_AnwD6PG-RSZ3mE5zF7laPQs4zAdLe216BzFmog6fAJ2vlnF2tlnPLRCAdOs4yzOtFZM0P50kuhBzZh2dtHre50oujdtM0N2sNVrVY9J3IsrJ8153bjWBLOnZPe1usA1lkPjBOlssbJ4dsrJyl1M0GA71VgZP2_esBkrrxcLzl5OJmktatVsFO6rjxcGrqFPmrn6nixcEzpByldtmWldcurVaBkBFnw4OmK0xyOsE4xmOLrjPogJEQziRmiFqE5RMbaL31Ba8c5r_PMdCqEAd5hjVapekft-trGxkbvSKpolhgPsFtJV3MiyxIJUtkgCYVcwzyt27XVwkQDMhRy0Whxy7eKYbhVQElmMAGpHJhtgD8AxgJOsyNulMKNo4NBEwWsF9CLyXB3udzdlAkElfecATQdP_LqGLpcOGLjB7qOZHhuchpsW2kckWOPWZYJ4cGWPupJWOMHtWODKo_51Os5O8LPMOMfC8tD6FQCMoO9wu6LZKXpusOMHjM0C-pU2EK_pPCuoZOuh6dswup9arttF1GLFePFdqctTh_-Bg9n-gFKlltlkzltxbA-P_aqbM8ti_1-5pSliZ8thELNDtSFjdW_quTPi5S9smtqE04ZqzPR_CxEQVq1P8tuFl-atvMiR0DPFnCDPU_mDOuZdMYgtmeOqI5ZODJ1FZsZ05tnlmLPR9hLOGRV9KOpy_rmEdzOI4iDTM0vtPNx00Oxh1sOK_QeOzzFOVgZ2rO_vBrONVJRAnNnUUB8FRHEZ4F16GdjOyblR4TZzNYIR9Cr08prPSZ_XBXjD7dwcrDV08h7POZgomA5z5xIuf7PAVvXAMVjHc9ZwD1kfF2PBh1twOp2BPJhI_4nJwrO1okrOM5yrOOJeLObZ-DOHFR1P2SB3UW0FzOvZ0KQeZ9DHDx6LOi59bPJZ9Ur7ZxnPHZ-zJH_G5ONlgcyUuoDO21FbOU_iXOpZ7ZKidmDAWx0TtH2DXP9cCgkCGz8PugC7OsugxZsZ3PkIXNPOKZ131CtlXk0nNzPhcwfN2znWcY52XOo54XtHVCgl6lX7tHhsmtmx6Yw29mXpPu2ylzulCPURhLNVAEjFanXbN3tQG0_FvbMc9eC6w9qNBhM21Uz5qzzU_dvPt43A3gFywtr5y_OvFjoRLusUiTUv2kbbgct8enHl4F3V4kF-PJpA4FlEVXfPk1rAv-eT3yC5yzNBh7vaVrmEhT5yxEpLhLyd40fPjpg7PZZ9nPQbQFOkZ1V1sZwKtPZxsOZmkA0sMP3dkK_3UXrsDtZqxxKnnLHP2ruyQ8ZlHOeIi2PGFw_tgdnXdQthSXfuVXcZF6zMOp1QvbsoBkBVkC6KHaMqoWhKthSHgI49lXcM8ojFmYMTxInYH36nSrQ9F4W5mDYYvftN75ioEAvMBec7M7XfazbidMjfEQ7EeH_3lZfLdWfO3sURyOMj7UYun5-iOueaOURm_ad-F_Gt3e4TOvrETsQR2Quido5EdF5Zm9F5fzz0mEvtNU4uoR0TtzF2oBLF2U659ik66PHYvTEg4uiregA8l8Yvx5C4vY6O95klz2noaItxClxgvEUEzE77dkA6lxEuVE3o12l7tP0F3TFFEoYu-lxTrLZDgvzvCPKde7L3U5xDOcZ11dkl32PdhzGOIp0i72F59qkzH9A_1ulxSF-IuKF7QuFlxqooZx949l18Odh6nZH_CFOlGf3Pp6IPPQZ7bPjpvbOAxYQdoZ-2P3WnDPCFVnOC6CFO4p2Qz7l8ec_Z6cuSrmGKQZR8vKFbDPVl9cvfh0lP_l6ldGrkt0gVwcvQV8YrwV7e1o2JnOZFASPIJ_BmKuzBOTVcEHZJ9_c1HQpPWYFaqtispOMs6pOss8u1-BxRY4Xbi6EXR1aRrVstLzhYBDrfC6m_ejPkXSIOmV-tb8XWdakrZdb3rZmgcHUDaPrQQ71gP5O0g2lZIHZDbRV5ec2LNlPj9rlOOkizR4gAYPw2G26k3cgGpNDu7GnX4KDV3PasyBQ7jV0gpI7Yfa_beavDZ3V3u2nqPxlmJyttvlP_sFPOpoG9Pih59PLRd9O4JlMOBV3i6W_W37iutjPa3Xv7SWszPLUKzPXh9PR6Fx8Ow13quG4EwuC6FyvmVzyvIp1jPtl3D2bZEauI1xPEWZ-vPf51BO3hyBPs10XVYnfbkYV78uOhwGuWV6dbCXQquobaGvTVxURzV_gsGZ-rlr6AfazV6g7wytQBJ4rvPrnZS7bneTt958CI57a86SVm2usoh2v38G4UJ11_bzV5GvvV1Cv3WhnkuXe87R13Vhj_NG0b7aIMo8v1OWppMBucrxrbRpYRDF1vOA2no6F9CM7U-oXaf8Evbp9u_hwXana3mguubV72ubOy-uwZpqRw6RE2gJ7UOQV8dNu162ve14PN711mkHA2WuuXdHbY7VWv2hxMk0rK9alVw9b0Z82urVz2uH17xrEIv-AQNwvbe14VtfF1WhoIBLFsgG4teNmvPuF-61L1yMAxNr_br19OvoNwxvP10-uscN-v4rg30t7SRuIcOgByNwKMv10RvjZX-ut18WvY10Bv41y2v8N1hvVLX9A6N_oB71yM74N_PP4x-V05V9t1kN_taUV3GvpjAfbJ18fbRVkyKzx1pGG5wSvWke7bTVctpgaOSuNHlSvoEClHSUNMVmkVehArYnBvVV88g1XihQzPABsYEGPILIwZUxa1RvnkkB84DYQJpC0i1kLpIirTGIK4GwR3JFn2LQEVbdJM8z62W8yMpxMl4rQrbUt5_FjLBmr7tGKnYjVcpZIipZ01X-0wBgyvs9EzpR9OsA1GjuZ7DPyuFdAraZg5Cm6tzWBLlNrpTdJbBzdEJxM0Plu-DMRZJB5uZA9MHpKt7uYkSpWrVtBMguHVMB-OJZAIjebAdlEwEeDHwYWKowZtQHTGpoP0ZmqYwYrdeFv7RLSXIkI5uYqLtvW6JKJpLf4A-jMc4jdm8BYgBkPHeq6v5NV_IJFHZQ2Vb6niqshrXtx9BbbarT27HRtbNGXSxTOlgPt7WAvjMtikkUzrk8N1w_EVNE6jfGJtbZiz3mVApQLQmg0RD7IErRlPHg2P6_zezTCPbhbWIDdP1zj7knV09P7t8dMSx-eh3pxWPLJL6u1lxVvQ9L0Oah4kbFh2nPde09vWZ8zhjNEoY8FNzOhqJWUopL-b6jSSRdNJEBTNJCvNhzNZW83KBioBtxxTQLulSJjvkdw_RJ_dsPhatWv1l8PoRt_TvGm0RoHWSqUWxwAp08qzPjlwsP84iBOWd61QbeW0QYFHp7U0E7bcnT8uEN2_pGtxCmfU1mug6NzacN2AoCA23mXx1MAWbV_G_w52ukIvzuM0Fbhud1YgQCG7upA22PV1-Lv_9PcmUqhCtCti-66h2QuajUzuZt3NuFt9ynxU742mje_gXt5a5C15A2r9JabivKPRgaGyq-fNzO2VczgpFXiu_0NXvkNe9rZ8GXvr6BXum96LuZmto3hNIir-h0zuIZ2buLUOzuhd2XQ8FDzuA9iKaQ94Lukd0QARd-IGpd6RoZd1Pu5d5bu_zYruBaLbuZaJHaR7VwZFt-KnCt8JYcAIrpldznVYVzWuVlDrozdPrp6CgzuxN8eOOpEHYrNM5pO918ulNwhXet57pndFpvxNzpuk7TvuHWNivlN5cp_dFuZht3Tvv9_fvFuIbu398ZuLZ9BOzN7BPc08-JGYJbxrN5EHrVRewZ5D-YtO3-Yl4LGKVJ0lmXLUu1ELAJIk3M5YNs8o8CZKo9lEA8LbJPVvGFfQzxV5MleUllYPRSUH8rIVYlkppPhVAFZlLANuqrAHoNMnhZ-DynwXeDpPlV6sgQbOquS9qOxIwT5xk8uXdsO5GAyD97ww4n73_pB3rCIkyGBXBdAVD-eAkubC4IotofZyBGCQ8NBlIzhFFIpNxFdCjfIpt_9qcsBvHgToFzChzDZ4_GKGfssR3gcqMEDa3Bm_UAqkEUa2g-x9LZ2siAEfD5MQQj1c5Aj95FWA5qv5GNmNapC3YyA8eB_3ikIehhy1hIjFLAJe9J1bMlKzCaihIJYXqqOzbQz3LR3HbDMXVgOHCcgHQwY1D6AjZDOqk7lnZLjO0B4qLIL3Poy4AyrGojZNcYcjO0BGAO0eaj4KBeHMvrhjyMfhj8M3VNd1OvrGWk0Qne4HqCYVboq8hL5-VlYQMSHc3QSGeN-IMTCiOo9R78RyZbNV_D5D4-Z4UE8vLs7wjwcf9gEcf1fOcp2gvoaXOzvHbsF53TorEftV4JaqFL2g_Yp4RKoI4eovXoeb-EkUZimik7V7mwxpQWxsx_8GiMjfggT2OsWPmog-Jw6u7p0Tv5Nc9P3V6xBPV-WOyI1TvBM36uKh1pPeDzbB3Z39An7HHaE5FoFnWCr5uZ_NZYsDGvgV_fuE5IPMiT0EeHdzWL9rIFYID6Wu6T9Huxd7QNGT0AegtLuyAZ7fuaT6WvYpC_v46kjr_V3JwTMvp0BTwka796Wus2KKfuT-KeC6C9aWDzMl2D_MkCrIslQ1_kUAT_EUbMt2OYMo4U0VoMVIqNlyrJFyeZ5yLOS12nPVgMaemkHqfYljyf0nKdB69_cfCV3isLNy-JTPjDLLRWgebRVsVCdBMkuJH_L-F5jQGktxgL7vdo2t7WLWsC2KkhCquKFSSVa1T1ZO0AVO7pROJiLWgEhAIwca1XCfDoI6vNzn95id88f8h69OuiBTuMT6UPqd2fvGV3tZVrfGe2T7af5LZyfoV95FYDwBvTN_e9zN8SvQ4LQOXGAJyaORSvDLRymPW1Voe8AWPxOW9NR6j-RMUwIXnKEkKChWJzIpNOeXGP0Kbekge0IHmqAQHqaB5CWqvxIpOMD5UhdAPUpgJOaBQJIPB7tDELoJHyKWOdjIBJJOWHQOZaWs_EAb2Y095O3FXIt0CJ1jO8Z3tISVLN2mKGrRBIxczb1OOasOberxymEMSVBz1Grdz0fhK1XBf__Pdpr_acR_FcZY5J3AYoOkBeL2MlvP6d_SbYAbp_6YAzsrZxY7D2eALl3OLX_Qvud7W5sOp1uU68B1OQOuEWFOSXy4hTWAEhfwgOpxkLy56BnvauxL7zYFty5y5kf15VchZOouT5xHFGhEMdrI586HnbhNxGFOU7Q-yL6L0Y1KL8MkJ9-HBGWgFXWY1yKsuPA1rz6XyxNQKLPWyUgpRRMRQMxQQ9L272Hnpthp--5yeal-LwYgZzVZNpzC2kbUzB3DgKU22pLL-5xxFokMVL1BRHfSxfYhXyLy-eOeW8FKKa1s9c7NiKAUyp0ftasuRjepjZ4kqt6MAHFfaj6NH7-_1EI-hMKN-avykr5TYw5Cju6JHhf6VL_SiL_qAM-NahGdViUs2843U0PQ3sSXm3mG7xki28WfvcwMeDfSLUdu-3Hs20hUGG0YumGwW3WG6xBxQ4Nf0zLUeJM9PQsnEvYIDhgBNmwRpQheRfwL17tXfZZzWL6FfjLwufXB92QMhStee8I8W1BPteBCLBmRbuue4ejgmRbtkdjr0oQSBxCtBTw6xt2zFfxKGGotPDdfrSAVf1-Ud60r51e3r4uft-RTYvr_vzQ9lCPHz_FWc2wNfnSi1fC22w2sSulfBQIzqerwk36r-Df-r01fxr9DeRr8W2eMPDeur6JvzADNf1u5135r9DzFr1vpyZFkhKAExrlz6NZY2G8uQjq0YaL0Ht6bzgq6b-iurpxCuNL-Qvw4Pw4TFU_tTzRahGb_dNPdw4g0946yhby5s8Ax0Yvd8vull2UwwhYxf7qwyWOFL6wSkIY0uGlZfJYMueU2KaZ9TM6YJb6jkK97rfHTMeZYAOXFzzHreTzAbfH3Q4gLbybfLzB4xuyJHt1b07fXfdrf4WO9f9AM7exRf9egKJHt3bxtBQhTwo0lB0pRYqOo35B_JabxYAUL48Qjp96c_RjTMI9q77JHLIoY78MhzdtRNvSone_b8nfYlEOhvzxWYnt9F68ICneE1GsZC71J7WqHfYWrgWe7pyeetPTebKbx0RWlCHeqb05gulIhfMUpuezVWMhI1TZv1eDTQuiBerdStH2JdaDuSkdH3dTCPfHg67gElDDmA6EaNaANH37TNPeTB4awWbOsAQd2niaSdH2BIH6k1ADjAD4iuh9ZFJ2-wDTRqgKbwpQMSZ67fs5Mx8yhoiBOYXQEfeVC-5BGtANMzACffh2QtwYEabw9fngEgBEPeUEfRV2gsfhh4GiZo-1pBNK_xGE8qA_IIOA_ZVJ_fqnt_fuUb_eHcBaBT1as9uPeffvAKg_sWPnAP3BpBEH2fef71gE_7xg-L1SFxmddg-sALg_kEPg_QYx_eXz-hRqH7Q-kEeQ_2yQSZkH6XjWH_Q-h796UFwniZ3QlcAvQlDA7EWABfCQGyDMGA-aAM_fuIEQ_mHyQ_rtGg-MH3iYuHxffSH2g_KjoQ-mH2o-cHxo-8Hyo-84PaZdHzQ_9H3Q-tH4w_T7wo-UH2Y-2H1JSBACFukETnaWH7Y_eH-egvAAz8HHxQ_pPMI_RH3pBxH5I_pHwQBZH5Y-v7y4-lHwY_7H_JSpgOE-_75Uc-H54_KH8nghH-wARH2I-JH7A-8IPA_Dk_I-THzw-MH8Y_Yn5o-P3Ak_pwNE-Un2k__Hxk-pH3A-ZHwg-dH0U-8HzurVniRrjzusA978rwA4cveWjAd7VINH28TN18-n1cwgH3YQfH6k_t3tH2PH2U_eGf0YJ7zquSFaOgmhhkBo-zmzr4ImhcAkYRTgNsBR74DXuvgpAhn5pBZ7xtuQgAvechEvfVb8Ygm6swLjECHTIwBaA7qpUj7n3OTo-1vfuPgc-g3faIRH74TPCT1wIH3NO5vsPe2Se8_rfcYEx7wnlo--E96yQHCTIFgAQn3JAGn4o-_780-DsIOrEAEWbAHzsAwXhU-Jn_U-rH3k_XH8i_Wn4gALINCxmNTgFK4I_eYAHC_jAGUdh0FJsvoPsU-pN-Yl3KSMna-UfVgrRsgJEu4Bprk_wn1fesAhGCuiJA_svY4_Bnz4Aan1k-6n5pB_n5g-3TGK_MnxqBsnxYBpILJBdSmnjDIDjYNX_s_xX0E-IH0c-8d-KtfTH8-oH0k_CAN18DIDq_an8E_hn5i-u4WM-8Rc0AJX4q-pX_8H-Hw4-Zn8pANX1DAvX4ZAVILC_1gIfCuBDYAxa7vf979gArgMMe4X7y_FH_y_0H7Ie0XwdLHt2r5OBHJp2fFG-EXzY_oLGiABX_G_EAK4BNy0cBhNUAJ5IP6AiLQs-pVM_K9X8B757ykMwTJM-BTKvfokj0-N7zWBF4SMThuD3wnwEPxrSWrBWACkBQ5FgASAMqBC0jKUCANwBwgGAAgPooASkcmB7AGuGUgCUjuPrAg4OFgAZ39qBF3-EjF3xUjuPtx8t37u_QPlu_B36VU4AGu-N32-8Z30lBF35ZAr3_GDkMojBvQ1e-VETSSoYJZB53xu-Z3-eASkQpB13wpBL3wpBfCTO_7ACyg8AFu_MAqe-D3wjBdO1B_kwO-_uPjQj0QLABwPyB8TIU4B0ALB-FIGh_kwOu_QPvqA9IIu_7ADjZXAEZB8P8R-VEVu_IoPh_n3zx8oYJR-iPyR-t31R-KP1DB7AFR_w6TR_mP1R_9QAB_mPyB93Efh-mP9u-ePpR-937R-mPwR-GP-R_hP9x8LQOx-WP1u-uP_x-3EWJ-BP4x_-PyJ-OP1ABn3_YBkwHx_mPyp_JP3p-t3zJ-pPyB8t31e-P31--f35e_Z31e-338mB1lG4G232M-lw568Lw0sA3P0eGg3iG8Xn9ATzX8C-wX1fTgX2GraURdupnwuFqgNH3A36m-vpPW_Enx6_4YAc-V0BZbPQ-VBMpPEsRMN8g0AL7TXWCB8jIF1xVIPDho35m_Y3xGDM0EV_uH1gESv7m_832NRaFbTE1n_dQn796ZjuqIdTDywdb-v20XwERgBpogfuIIZ9VzYh1b7zPfq3yc_a3-c_nfKcYcYEF-G30P3gX1vfVO_5_dn2ySYX9H2Wz0s-BAJM-Rn-2-IoJ2_tPmJ3nPikBACE49UIPoID4C-ydO-hBXyaAgVzXj49ILqSlfhAAdMLOA3wJt_bX1zwoX0WBEWLI_TVaEGu8z3mS8IefbN8Zb2ECHTMs7PAeUCHSBJBD_WLzcACgI_04IMlnULND_YhbD_ZwKSVJWT7kCCwPmPh0PnHrMj_oJKj_Dvw9Ijt85u7pdE9gAKnIDE3FJeAM4AUYKHJZoB_R5AE8AP8_k4Qf1kB1wGTb2-bc_pc2z-LmOOqef76B2f06BvEgQXTcw58gg9aO92LNn5s6BX6CyTBAf121QBO6NK1TFgdgEFJEGAJXZfyIgG0BEZRNTjIn8CFgXYDJ8cLMSpdQMRIqdOcpiAAQB-4_buR-EwXPBvMMyC3ZQnwrIkPkoQsnVyCNpjF0BbtJeQQsF0Bq5mWZHr1Uu0CFnBMvHiHzYHwh8nhibJdfKAcNL-KVGtph_fyYIMzLIlw_5H_bgNH-ymlmgcfb6QyMGMB2gGn-o_0ia-IP64DCDQIBHLMvHsx-hPf-LkUhvrdiKKUhvf7eWV_N5Hc_9X_i_yTACXNgOhOHOpeHPMNfpIsFGS5wX3vH7-O_7vJo__zMnwElAsjf0AcjVNBeHMUB8jV0AjgMGpt-gElK_xuRE_2P-VRM6ASVjpm5mNNh6Bs_c2_43-x_xJk5pnChtMPNg32OIW1KichqTISBa6KP-A_53_PxCOgxjR-hr_2gtwSETxxME_-t_y_-GkjpuDgQL5A__um4f_5r7NwWX_63_p68T-CxCEcA1Ig6apzgDQrP_sn-0EqkeqpqHdAfoOPQD15bVvDOWAGn_oABGswiujYkuzjHdAVolgBcSO5iqraynOJwgbJskr1w-Ch5AKxk_3SnfkVQEQAT8D1g1AG6hgyAcpwKwL9sU3DDVFOGlgCUAdPydgCCAeIMsOaCAijgQICljGxgFcBi1ttUpAyt9jVQSf7pmGfmaRpidtZwYAaQasxAAkChUF6GMkCSAHhwkgA-fPkChf4Z_h3-fYzrrJYWvAF0AZf-7f6AAY38qFAMARV6cBCkELYAmdg_4P0Ad9CEAcn-eTSWJJEciZx0yHYBCsC-_lv-df6IoCABoRTFenbuA-ArCgAB_gE7_gRC6AGSMN5E8AGl1oWADgF-AemYLyCQfDLi4JBMMBmQ3NiCiJYWyQEy4h_-OQGogHkBu_6inBkBfvCaoLHm_xSaoEYktQHD5gzY70SVlNfSqkapAbFQaea14COy6lw02hbWIsrVGpYWEZTvuJ8ktrRzMP2qR_5mIIfG8AC1AZ-goy5MxHpAoTR_Vjgo80hGYPPgRv5UWKb-5v7ngOEB7f41mGKkF4pnUJxktAxFGul42mCW5JO6gMQzQDXAtHqcMBGYvGTazF4IXkoWhpsBEUAB8BPI1wEfoBMB80h3AdDQkfDAqpLyWOD_6vDOjKALgFrKmAybFlg2rgCaoLEENADBIpGAMUAGvCBkiAHq4MpSaUDdAWk0_QFjkLzu0IFYgdiSsbKYgbCB2-qCnv0BBmBkgXLWx6BIOr4eWXgwgbSBaUDcZgSMbWyq_pYyMwGhAHMB1PCjJosBBELLAQgumIHXqgRWjIHEgZJg4cg0gcXUmxahNOyQmIFCAK6IkOAJ5BTQRIGtrMbWUR6bYI3kGQET8FwAz4Ys2JqMuoHs2FKB04CIlvqWOoHoAFgAz3axoNqBV6Do8KqBtIGIlnrWuoF55BPwWbi9XiIgFoHBpPaBxdSIllwsetYX8DHGCTYSsjkEV6CoxCJ6bBASQByBqMRjIJakeoz-gfvAaubM3K6BFRwfuNr-MngVSvrUF2Shgd-G2wGUdt00csg1UNcWMVSs9MmBHPrkgHogDpp27uXYoYEigTH-OGhNZNmBNVC5gdlE73jJgYWBmozFgeHIroG1gRv-f86lgSycFYFYEB5enlbvFtmBUEbNgbq0rYFjge6B-RglgdmBZYFpgb2B1YH3SLWBQ4H1gaOBcsjjgRmBCuT5gbOBRYEYRl2BNYHKUiPKXoGDAQqBcIG-lq6BICC-Ws9WtHxVxmKBq4G-lsaBwwHcQPacr2xNpv8-iVAugLd0UwB6QKs8RQGYPiZg45YqgYMBj4EqoNfS_lADAUyB0oHBALFGawGFQHBBQDTPgXSBeCxnHJnGyEELAktmXXrbAc-A-nw0gL4aYoGtrLG4-gDYQYso_Va4gIrA8f5zrkSBR6Dmureg2czEQXOGBr4YQYxBXzCzlCo0vIFv0L2gRZ6VGtDQkxo79OeKoJw5ABcBc0xXAfCKNwGsJECB3PQPAcowcmATQAyAcwAagE6GM_SsQWqC9QDkuFhBxz5iQYAMJBrwgExBLIBSQcCB9QDOAMggeECurHpBbEHGIHssowAUQTpu4Ja2QTgAoIGR4ACK0S4xARj4eAGn7n-gWGB3nHIMUxCw0PyyBQAhhn_O1IFEgeeBFIHfBJiBpwxgdFn-JkYeQb0Sczhs1N6BJoGqQcjU4MQKgbZBVEF_oBkBkSYagVUI9Nis2MKB2IGSgaFBtQTBALjyulTygaMAuoFWgR9A2UGKYDL2zlz02DaBHoF6gazY5oE-AISBgwFqgd5wZoFXoNVB8bb8UM1BdoFdQQ6BUwhOgRaB81IZAUKI8IGaoPGBb8A3gWeAMVAowFBB4oGigWl2V8yjAP6Beoxb2EKIpSREgWBBHYHXgVsAt4GinJE24NCVQa6I0UEKge_apIphHFtBgYHROKMAiKqJQWeBVUEWgS4BGEHgNO_gkx6DAVFBAozLQP4u2OARARkkRiRS8EWQOf7brmKBarxZQO4sbgaRNhccL0HQQclBFkFdeuDE5EH4QUn64wFXoCQmvIbBgdaBZQFqJg1Bf87-HAho-0FFQYRBDoFjkDtGJUGKgU66eZygts1BhoGtSgaB70GdQUjBRYQ9QbpU7UE1QfjBI1C2gaTBI0E-gWNB7UGJgaXKocYmCLHml-rxANwmYYE3gXMw9KBlmpOU-QGKwIKBdXiFQdiSLCCgQeTBV4HzQcdB4aKs9J9BbJY_uMZ46sESgQLB7MFfiFTBh0G6weQAJ0GVzErBUvD3QceAW9gT8CQmJ4HfQQ1qv0EJALDBgMHz4J7-oMGnQH_q6oo2nBySl_oY_nqOIFbijHL-3d75pqtmeBa2zAr-s9zawG5AiTw5wIk8ukifFlX07kgWWtyiK2gfFPg-eB7BWJj-RDqRDE7-fXaRGB8UaIxbtI44JBgp2mnk0hDpGv3WR_SbYD4mP7jT_hMA2Rq5GjsKS_5EYKv-uCgRqPuOf6A-CnceDcZxNOUBisC1JJm048FIaBfy6Tp5_lk0NQy5SGCWEvQiQfuuM_TBqHXBUADr_veB6obKwf-Amz6CxhYslTQHwaWUOS409C8MXgFBgHYsQcEIZq7-c9Q31Eok1gwkVNnMhYys-OZqR2rWalGA6QyYAK_kJZw76i64r8FfiDlB8xzpFoaMQAhPigfBkgG8RASIXJaAxD8QUnbNyuDEwuxTQJIAWAC1ZkSih_5OQSouqcEvDCnBmTCAIXkBYMG-tCjw3PyX7Fk0mcGeDA_CGsp8LBj4_sGkIRnM8HhFND6BhYxMXl0wswHR2K5kI_B6LCM2P-pPNGCkSKDPwbFsp4qfNBAuBfTC-PQh0CyOuCFmD5i-biGOeIAGjpUwicFGWqAITo79iC6OLqp2HoJOGQCl8NfGhQIHmm_ABpibAFEAc3BP3CSmuNynAAZwknA4AMZw_HBO6BZwmpDtANoBtnD2cCR6FmyLLiWOYWzdWDlBK_gX3GJyKJ4HlJlgirBIFOaadAgtqv_AhiET4M2EYRxzhEQ8vDh6jCBku8FeJoqqO060IUQ8waa13jUoWiFIsHQI3d7bngWqRKoDyEohcWYOgMTAtkpOSi9A0iCubiRAy8CqbHYATqTscCYW4AjimI9-Zaqxio6qREDOqlAI92g-ZEbsIEBCABGKVSFSgIcGSCK-qvdoajY4tidoKsBVZg2CEVp1ZiBy9xSxsGuGAsaMCOzGFnhfCPCwtyYH6PHuK4aNopUYiKa7IaQyoKbFBqMGzW5zBvqAmU5APKEGH56T8FGq56BOMioy7qb-_ByuhyFDBtpOTHCuMtRIs26ycCwqrk6ycAEysrIhTqkGmaCxMlZO8TLPMuEaqTLpMsChoKaPIZ6mjyF0Mr5Y9bKlMiwybDLQoUt0WzJI6LsyVEg26AcyRzIXIVA8uW6xihcu6F6ttBcuh9xDELr4t9yqSFw0bSApnhKcPnw49piYCoR9vLH4P1gdVmWw4-5OMrCh1DLwof7IhTKMMnwgzDLlMmASeLLnUHEw9MpSYGCEC5ZZPK08m9BfWPVO61SdMrLsOM4-RL_UTKEINFKEdKBaMsqheDIsvseuZgil3LRg6mbZLJwG4rKaOFhgyqGGMhOgisA3wDNAS7iI5nBInRLmoSy0CvroUDKcmbJEMhLBX5bX-KWkbJIu6AbIlPBaMlWGQ6rC1j1IUqEzIId23yCF9i1gssCdEGYIKVCStj2MryA8YO4kuFbiBlwGGkCsBsNQ3cCcZHJgEdhyYLxkj3B7Vtk8mjiIVLe0bCDcIAuWDBoxVg_A9jLZNvJKtwBQANugdHAB5BQMR4AngNeel4Dx7u7M7gCxCNhAGDiNofYA1v7a1OSAzaF9ob3q7MDcIE-AUMACOBg4mJjyyHWcEjLHdLbSoqDQpvQyJXSL_Hawo6G9of4AdOqk6jPoJ9BjUMd0a6G-WO7ALEYnoYFY7sALBi6456GVBuuhEgacgNGoLpxwmJJgY9oT2uYA4bIHNtBMg6E7oaUgEupNlH4QC6FIxi8hKnRgps8mswYVBoaA4chPJichLQaQYct2QbbHJlshXybMweoInyaugJWUMGFNbnBh0Kas2GhhyGH6AFaBoqBxHPOhRFas9PhhVyaugOHIFGGnJi1EiQAsqnWcyQDhyLwy5tg6MkVk2jpS-sz44TYi1OK8LACugHCgo6HW_h8Aj3BTdv34LKH3kJlg9JiZYPRhkaC1YEuhdjJ9ANk2tWBSYZtgMmHLHJiO3GH-hD3y4LhIYZRhNAA7IYigNGHx7ozqS4ZzxlSmfXi0pgImZHjiYSTAb4RmePew_0jdLhZhb9DtxJkmoFimaHWc_MarJgimswBsJgCm4ch6Ig4OPXCixnNYNmEqIF2AyCYOYUtGSwDFJpG8pSYeYUAhNSZLhglhhsbsAPFhKPR1JtcYZsZ5hIOhQmGYBPA4vGFLZjXIgmG4AJgE4oCYTkzEHuykYfgqB6FAYVw2PQCZvK64q4A-AL6W1WFEYNIGLrjlUPRk2IFvod8GbJJugCfQk3q5YbgAgQCyQAtY8STDYVUw5ACRgITmDGGGSLwy1xjufqz0X8ZOpNPIIlbuECVhV0gJxj9YpmHoCMVhTaF5YaFQnmpIhNNgCQA2ocWk7GGcYa1hgGFkYdIG-2FDoSNhcwLvyLFgE2GbYVLA02GzYbJhk4AxVqz0qdKLYf1hx3QrYbJ89xqiIZNh-WH9xLthb9D3YYdhPyQDYJNho2Hyyi9hcOFvYUhAM2F0VnNh8gzsEr9hOAC-EqUIq-rhsoDhxNirYSDhyOEHYbgAFhBucPuhDdKTYRPi8DiQ4X662OCbYRPisETeYHiW26EtoZo42Pga_p3eyx4woLxqPSHmVhKGtoHk7g9u3-jNIVfBXAjEeI4G66hrapugvDC5krxBMhAfoLeG4qGPgHDhVxos1FbW4uHcbCpqvCF1EIJq62oJAOVhzRh84B0QZfjcIJHe_KhgkOXeypgWoKQQ0uJghCLeGoDtAYcEFuFhYDp6YuoG0K8QHuHZai-MphB_OGrgwND_oV7hYFBB4YDWf4z9RG5qLegWoJ185uEB4fHgPuGNGCG4buGB4QLQEuq4rENgKuFtQIrhQ3ZZaknh_6GOGtLqT7rr7OVgzSGx5vUhDQA4ANvSl2ijXqbQGupqCIDWJFxOSLJk6bDH4ptg-1RdoP4AuuHnNrJq7f4QlHWcpeEruC8g_eGVgfPgGmh9oZUBOmDNIZ7uveHhlL-hUXI6YPq-LICLKMAmi954SLPh8ZrU6l-ILpZzYNnhIWDj4f4AOWFyamy4k-F7aI9-n8CNEnPyNfDj4BWhEShjoa2hFCjloRWgHIiRgPch-XSPITDoSwAgoQZOHyHuMt8hooDq4R-gN-HP4TMgkYE8NpXht-G8yrKA9-HOYMARlaFdADARR-Gf_qcQ36CsbLgh4BECapzqNmqAEV7mbLjhYQbgAGqkEEUQqBFltq5qrmDT4VfgEODb4V2A9uFp0GqqwNSP_OmQ31Cx4b5QlOFJ4b5QtSCN4Ab-W_4j4XkB0WqsEfTq1u6cXlwRxhq4-LAAJyyboFp2tPAsAJ1We4wPasQRksBoEeSmJm59AZgBmmAyETDW5LpX_qcQ1kDZenKg1rq6UN5EIWAKEXgR8QCRYHxeGhFJ1iBhF5xvIbbAYKEYckdwaTKO_AHC8BpmILXAeACB9EQanh4GYGPKbQBIFFAWiJCynuvsczghYI7sJvpYGlTw7hHuerOQCnYEAOi2vhFREVHsTFCxEQLW8BqKHAwg2VC26m5CxBraYGERCd4REbER8RGgqtr-NACpESV6phbu7OERhOZ1etT80ABcEGWks2wwEJ-w7qx0BnS46pqR6kZQHU74dtYIIMTE_jDK2VAFekEEvQHBEXvklMzBUIXhyuGnsNwgLURtZMhqDhgSaDtBAtDZmHMhqciE5qD6hcg_-ima9qhN7vr0TZqinH1kWxHOaBJos3rmnH-gPmHMYNsRexEfRF1UPVS2nGa0mmDnEfMAlxH-mt0A1XrlepMQjxHZAEcRwDa-lhimKu5DSqi26Pajdiy2WLYpAFZoEyGPgGZ6hxFzESGYCxH6NqMRRxjC9oyh03bU9vj2tPZpQGQyGKE7Mq142KGbLIcyxzI-UALQwjKcEOfgad53ugecCLyVbHsRcYLQkXsRte6zqszgI3bq6tjWNWwU9mz2VPbi9ssMTBKbkEsMkeyQAfbuQTzw8tLgTWiKivIROhHb-voRERSgUNzeJBHfJOYR7NhNLloRyuFFELoRrNbCQIn2GeHvkKJCjagnLKqRTcbcEcgRjxC6EQUAkpES2mQRf6HikZgAaADa4Lje-Cz3ZNwWupKWkWqRtAD_SE_gBAHc3nqRqAA2kb9esGby6oaRwyCekd6RoajxXhJAAeYX8KMAfBoZtrhw8xIdNFDIYZGrTudAguz-kahAgZEdXsGRk16Hho_SGxE0BvKR2QEykYoRd2C2fH4AsbLHRvPgJhFpAHKRfgDApuiYl4CzAB002xBmEcWRqTSKkZlgjZF8Xg3SQMHJkbMAxpGzgKaR5tqqasYRKBEFkZWRfF5tkWR62GA8NviGB2o5UC9qAgCzQNdqy16VaEg0_DiBioUKyeDElhiu_N5y3gMkcjbwJqEYGtrJTsN0qQbZkWuRhABtIPA0HUTyQLbAh5GSdLbAVDQB3G3hf6BR3EGmm2Ch3AJgfyEyskEygKHhMgQqHGHGUIF2g3bCREdeP0rSHLHqwFFOKo2cighgUa-RLN7kmI3Iy5yHytBRf6ArkcQcJ06OXBHhPu7hcv9ML0z5tO3cVswoUUxcN2TskMZQ55H4TK8ulWikUag063D5yLr4yPj_kTF2p5FMeBGccqrP7KckSpxhcshRByFVCBZ2tQjf8gO2oBBKnMO2KPpmzj40nlwzVPPGYK4c3re0xHpZrhFE2FFdEekUk_j4UZJRszIgym4cUzqxoCRRECAXkYxRlFEAlH7ONFGKCHRRVlAAUXJ6NlKcUUMOtYC4dsKIWfprpPxRoMC83puRLOxCUUqkPNLh_DosSMxeXrGu4FEAUHpRtWD0UVvsBCqvkE5qEJQ54TU0mWCb7h9AL0wkXK7eagBYqudeCeyu-v5RsFH9oMlR7N6qUbe0TeElIEAYxt4V9g7exnYemJbeZt6jGnmRY6pVGkIRshpualMRCe6ioJRAZ-ES4ZVR99AkjjwUIN4htqRccVFJEcXsqxgk3m1RsVF6BlHssDZDSkHYomHMoZqhIUAa5MNIDKEjUTzIY1GpOIigsXrbEARRX-xt8D5BgxEr-pv-H6B5-Hj4EhFYSLTw60H5NkmUKVGlIGhRUpHZ4EPyjEpBAewayuFYlLqRWqj6kf0Bo_4j4bW2BNgzoJPhLdCs-EnEZ4CLwSdumcbDoAcQrVTOBi0kVy6_cuRRqjh-UYxRgXYTEaUg1YLbXgBQSDQ-URdOgYoI0euRl04ZUfzeDeFRzmvsXlHmAIQs0xoxAZCaFP6MGh8a--GzkeLkhxpDuIBkt2CAwBQ2I37NHqc-YJjncE8a6RHs4PKazxrznBkRJOLv4GQY7hHa4KzRbhFZQNrgyPg6msAA9VEWcqdRI-Y_0OUh5MDHuC2aXRHqBhskoihTeIwAFy79Us4IK6o3ZA2ab-wZAOrRv8Ca0YSWTSA60SrccHZ0kCjAetFCEdVA_Jr9UrVezMDLGrNezMBm0T1e1UA9XmbRcBERKKyartEciGbRQgAiACQRrJrlkZzRRgzDUVKEYmGzUTlg1UBB0UyhM1F8YeNRlUBm0VtkTzZv0GHRwAB1sGbRvlC0mCuquVFOmCeYqdGg0A2YY74xPIVR9t7Z0VN4hprQ0PSggZqX0MfhrGymmorBk6oq0YLSatH3knucRpKyuBAgNZpWUHpRZtG77O3RlWiYdjnRrVAW0aDQZtHW0WoAttFE3tgADtE9UdgATtFT0Rh8_VIe0V0A7tFyrCARAdGCDN7RmPBpAH7RQ5FsuGbREdFyMFHRS2ZJ0XvRIdHR0XNRcdEA5AnRBQBJ0TzABI65NnQKLp4eIN2gAcJAmoLSadEEmBnRpxgXmMXRr9G50Y3g1UB23nlR39GADKXRUNAf0DLRV9DV0XFKX2C10YmANKHkqkYMFBAEmiUg_dEWoIPRrVBm0emgBHyYwMPRrVHT0Rv0dtFqAJPRgfg20cAAztH9UglRj_qu-j3RO15J3h1RXtEvgL7RldFNUTvRJdHjmkgQWJpSAFLR-gA6mmAxm2BkMLAwWmGkxp7gBSFwkPohiAhdELbabE7WiMw8Uc5kTo7etDH9UXIxbN40MTneHVFKMS0IR1F3moROGjHpUTxumK4ETmZo8Jpq3ihOtFQ1gGSR-HrvLtqOao5KbBqAP55MmDBaqo463p_RRVGyiMII2ggZpoXRgDFm3lxOK6A84X2uegDcIIhOQhFaMWZot041KH4x3d7S_lGBRSGT_JYWsYG7tl0QMdo0AF1wD2zholcASTEEAF1wz8Y3gH1QjTKHMnDoqqzNblOgczDyQG-WyEz4NItBHODZiPdm0VBdcPg0e9JVMeygGTF1McugmaBJSCkxT6hP0eqUmTHZMbkxkNrNMkcoNsBFMXRmXTClMQ0W75ZdMBUxY4AxUGmmY4DNMfUx0zGNMXMxtTEReFNEGTEeIqkxXTHrMUZAvTF5MQMxhTHyDtagJTHygGUxkzFw1Isxo6DVMdsxCzEGSpcxTTHRUB4iqzFtMTQAGzGdMeFAojwvMTsxXTA4ADkxezEFMUMxhzHGDKMxJzHjMeUx5zG3MbMxo4QEAI8xY3AXMfJAv3jQsUZATzHVbtFQwSKbMe8xLWCosRMxrba_Mf0x_zFjBsUxwLHtAKcxL1BTMRCx8oBngBkxwSI3MTMxAdbLMciBUMDIsTWASUhosW8x41gMsbsxeLHUSAcxX-hHMUSxJLHXwGSxtLHVMSyxjLGwseSxJDRQsdSxrTHrAG-W6LERQAKxFIa4sU0y-LHDMXyxL1BjMbVG9JaCseCxwrGCiuMxNLFLMVPYBrEysTWAIRYGdvKxVwDmsV4S3zHKsfkx3LEAsbyxQLEasSCxtUYGdmCxc1hwsRSxE4qpRgZ2hrF3MT6xbrF6QEyxK6AZAQimrTyWeGE4bCHcgdHYG8g8QS3w7XZ1cqCyYADJsTZU7wj25swY24HHirWAA5TfYJbBJQHvimzU9lRZsa06RMT2VMqBhbGaYIf-jZTKER9A1bHlsViUjUpagZYWilSF1G1KPGCd5ANBYPrcgRLY1fSNlOHI9bFL2FvYLfAfADggjgCYAH_sEAA6cAnkWABTUGHBGQGOiFGxL1DsIXWciJ6GSLVyePLw4Aux0IGVAdFEA5QlsXBmubEjsSaQjUpFsUvYLgF5gWWx57GClu-K2UF6OA3YzTHC4LUeZG5IDoTYEOaNqK-g4bF3sOgIS7HXwCuxrdAJsYXUSbHQnFlhHiZHMIf-0diyqBkBXIE8gXPGTq6H_qBcGPiWeEqw0BFjscWAWXy_NJQYD7G1MchMtZjcgTzELaFHAP5AWGj3ThQaR0Fn8l8q1voIoCmh7gBbsZYWYQgvDMhM_7HIoDbBJ0GvoNYO-PAtAfLBEzascQ0xAgDLQUzElHGM-KCgNHGXlCkhbagwcdHY8wFpxvLBUHGWFhyBK25ZwKhAD2zxMXMIqnHZ3JakxzGiWqb8xHF-JjsAgJTRsbBx6Agw5oZxUnGcQRQIeBBv0L-xiQD_sa0YVnGGuKZxxcT5gNk8kbEOccuxMbEc4F-xe_YFANZx_7H3iM2xRwBRAjVQUYH7wDGBJGCLVl0QC7G-WhcMtrShccDg6nGvGDHGOKA3gVEC5ZizNu5AsXFKcfFxiQBzMHE4csFdMMOxvlrpIQ6APuQcgd3eX2gXLg6O2sC2qr3A9qrLwO0h2Z4sDhoh1K6IWGD-xB4YWDUh4gwV4TnA0-GtIRBI5kKPyOKYGwQhWoFu1WazIavwiEjdIVqmLDJccM7ozqYJqgdYtBTTcQAy7-hOpgdwC3GupiVu3oq3IRB21IgQ9h52cHaElKEGCdpvtEShKBFvAJShWU4nLCZBHgC0oVZGrHbsZNJkx0AOXNK24QgDcVTeQ3H1BIakVNbNSOiemaEstCJgVAIcQHYAXrLzUNys0QA8mNKcsYaJQMdqNAAO0BWxIIgnMpmRWTJfdlSYg3ESmKFAf4BQyITm3kDySmAAz4Z2AItGRABS0Md0LWGcYKDAekAVCMd0TGHk8fDAZzZFcnEchPHpQMTx2MBU8S0AsbLE8UEiZzYATPjx08iIuJr4Gv7EoTxq1aD8anWgDRCyOrLhKGAK4QaR0NFd5izhdORraiTmrJioAFtqRmpW4crh5QDRhKX4DKbYcA0QcuEd6GFRjmoDwLfU8vEe-IrxoVDG4e8YZuH-4Zbh2xA28WFgx9GjUafR5bhS6q8QjvEH0ayhZTpKkVRyBAA3gOiAJ1DAKJfRs4CLxPbxauDu8TZhOWCakddqcvE7ym4q82EMMQWRBErTURHx-vjLZPWYFVZX0XvYUNFkEBvh_ES9yK02SuGn_oE2wfEYRPUeLazMgdkeBnitrPAyFVBonOHcDoE18XOA2MQwsEHxKQD_WLnxY4B-8SUUrfG46jwReVYl8QfY3-A4EbvIXfEB8ZjAPfHf4AvUisDJ8aHRQ_EkkVXRoRhCehgRKOpb4cdh5XAJ8aYREWGEERAx28beYOygo_F4ABPxlUBLxGlA9qYzcWtxLqbKWNYhiQgmpm6RHGZ9QM0ACETgxAV4fpFMkP7xh_EZ8QPxaThn8TqmXujzcckyvljtOFhEQSBwgIbKAOBIzBDBnZFv8d3xn_Ft8Rrkl2EhEW5q-_Hv8Ufx_S5oDjrxyAklFIHxsAmLxOHxs_FbWJUM2mAcBFgJ4_E4CaXxm2B4Cc7xGES3rLtES3EOpqtxf_HrcQAJybjcoWxIvKGWAFbgVwA_8Y6mjAmX8d7w_qbTdBvhokKd8SgJZAmVQEH4OvHCCb7xognF8XAJ4gkWLjURgjJGpiamxwYlFK64RICmQYdALWwx2ENQbIpDSnEAFxHYCbIJZTgE0EQJMgn98XIJqXoSQNwJF_EbcVfxyglHcIHqZgkkCQ8YYgkTwLqULURd-HHsIWDECSdQqAndAF2B9GroAEYJFgn_WNLYXgmalq7xRfGhCd_g_aSUgQORffHPNjlgcewRCdQ2_myLOM6ypBB58V8skszZCU9cyi6NRN6kMJpuCZMu2ACkEI3xyQm1-OOU5RFOarlAf9RhUbVRvrhhIAvR7KpGUafh7d7r7PuMsaB9ypaaL4w9CQexItz4LuVKw4GG1mXxdtzc3ER4pnb9YFdRuBEVkeEUIOHWnqoR_xFQCUtwcwkk3GhB5pGrCYWRuZGQ5OVSV-EOVugcQS4duorEKThIppDk6gj97AkAbCaSmAnRSsr60eVkppq77Hdef6DzQLvsx7hYYCl20tZfWNWM5rg0bMVyhsiWKtRgXOQgPgh6ityNKnAhw6w9SC3Y8OYaCYpBuYBllj1Ix1a0gRvW-cQJdprKmw6kDGtRxngNxsBmc3AwgRgmAwnCuApAPcb4ibFkYeahNBV4oBCnCYyAVPBh5l1RnjqkOEkADKHoANcJIi4CXlDsHhAXcSfI6-x7OFMe07gmCK_IZ1ABCMaolwlQAKyJM67RMKYs1wnr2hCUy66DTsyJ1wmwJnNyiGGtsfqBTNiVlPFQ1wlPdl2xY65sxlR4VwkmCNr2wkSaiSYIMokmgcrwPTAopoAuLZEewV-6LIAN2OoI2bCVzsWkbwAQeA3-j2qa8UIAiQA3ce0UnIm3cVPgDlGMgGc2mkbMiC2gfon95OoILoEgQCbYp0G0LhU6DNBMiR00WokWiZkwVokSQK4uhtwWmA9QLIA9bGzG2bDXno1Ebokn_u4cEYlBiZPhXvyYyK6JECC1mMvR8BHTGI9RMQnyCZQEasb3geGJAYmRiR3KhirOAN08Mwx3AJGRnQl0yCaJYzqH2rKJQ2T_6u3smS6lLgUJjmpfoFyJK-Ddidk8HRAyNPgW3wSViCak8AoEDo5KydwvClvsBFDM4NSJZuKOznmEQ4k3CRVWddxUphVWtSRtiSvggYmrIRVWs5AVGgEsDpGzif6J84k9iUuJwoArifo0smaYdoRWMjznJiNYqBYGYCkkQRGyzrjUhdRzXsQxlAT67rvsImig0LSYcEmtUHnRjVGMkJwQK3abNHHsI9G7dhhJJdY9XqzYkzY8wUVy9baUlge2HSp0yAr2ARYxiUA06EngtnnWZeDrttWUj3axtoaW8LaItpaBOomyuF9YFwnB_s9yggg-Hs1yTwlfQZDQ2CYP0WwmS4FWUYhhkAC3dlJJlZSX8Jh2m3ZdSvYkF3JV2E0JZHbzUkacOXYRdnl2W-wFdsF2qARBiKV2bpbnNCJJBkncSdDQGkYQ0A80lcxYYF64LdgpdiKIPsDQAIP-2Ca1sRDQl3axiZCBH5DnEWj26ADHMlzkZjKlamoYoCGPUD8KbXruANIAt7yVwJmJPkkUNj0IqQAjgJ7ASkByYNjA8MAsAQlqrBT5gNBWcmCYAPZ8lcBcEEY26wZpofwACKaWKKy8gZzRSQh6-1RJyGFJ5gAvuEeUPGybAfNO44C6hql46UAeuJVIb3QMev6g84A_MuK2zWBTwI6ctGAWgJIAAtjRSVWGQDhsMAycToCfsBOAkAZCEVT0OdpwSMY-CmjjloRWs7jZer0Mv_ptDGWuSQDRSac8FozM6uVJo_yVSS161UmYmLL2HGF_NgNhjEnntraWPElv0ZCYAThz4EY2lZQPSSTw2czpUIo2NtCgBnU8XwJvSbgUaxydjIQUnADbSfwAfpz2mKy8J0mhSedJ_FBk9hJAKUkSRpd4G8rpQG9J7Nj3VN1ARjbFQL5QedHOuEY2FoDwyVEyp-oXSU9YzpgJBj5JxzLHdMDQxJHV6s6YA1AxGFe297YkFqz0VMm2mJ_yo2rPhsDQLJhpwLdoXJgQ8eKYmwryNmsRdwnWgcyY6J5mnB3MPkno8eSYmPGSHKdgpMkfwLTJ3kDW_tiJfPjvcW5An3HOYHE48smpfieYfVDgEOzJsCwKkD4AjS7oyZxhr0mi6tlq0gamyckAJslz4Hz2QhEGesng_OqnEVyMndBzieLYHYlpzAuJrTxm4ce4KmHQ0KYx0NBHtvE2rwlXtlHcTLYq4BUJmlgpOLk28dxXthIyockn0OZE7BIRyX7BJQmWsDI8N3zGweJJjJ7eYBWJWUhVib_ANYkkrCvRWDKNiWgJ_CbrUUNKeQl1nA3Y13HuyfyKsIS1iREocmElCTL4aghcUYXx4JDmCUkJ1AnWCctxs3F6pnYJ3vAWpqFk54CUSPyRKwkX4XdgW_HZ4TXJT6QFkVNe3dgNyQwRnomUANrxdlAvLJkJ14mYpFjMjmpryd6JDclgAQ_-tgCaUDvxlrAWhKX4mUAAauGACrzIzOBJ69EkEShJOfHiMBvxFZH93LvhOUBZCYvJq8n05uvJPonVifPJMvFbCftq7OCfyY-A88lbCUHER8kHyabxLaihUa4hnfiz8r1-ZgCVcWIxozhu9L_AITEZpm_J8o45MN-aAb5Pbl-a1YifMAQx4b7_mtIx6wA9XlxO9wmqiJ0wL1CZsM3JHIjYKesAlAmH0beaCYipGvHRJQksKWSIrVC0mDQpQhF50T4xBO56jvXRpqrUoRSh6tgxMTS-Oj7dcQNMp8CyBL1xUao1cXBAfcAOqqohTqrqIV0hJWZqyRrJlWahWmNxwoDoIbdoukjgcvkyRkSBWEihgqFlMmwyJF746DsgGv5wMSLYwvF8auaAAmprahLx66CNEPLhaGCG8W5qMfFM-gbh-vHpkP4pyuHG8fUJkgkx8buROsCPyQWRz8llUWQMC_Hl4RgRM1GRYMp8E2EL8QGBrCiVwKb6IcHr8T7Rw5FvhNvxC_E68X6KYSmzCbhu25xwKTWAtQkm8bHx2QqZNhmgEEmoBD1esoq-3ryRa17Z8WVRG-HlKXse6UDX8vnwQkmdnksJnkFDSkGwcqByoJlqp7KaUZ7eNABBXmhQtAk7SljEZlH5YP7uJRgnSOPRipgUMQEGrvoWBno0_u5Nxm0pjFGBXnspieYzLiLUQbAnXrS-YGBTKURgX2ATKagAdylRoBUI_lCPKc8pUtBPSfNA7yl-xkcAaQ4eOJHILvjM2P668C56EHiguEjmEHlJPwAWgCXcHTQWgPABLioi1HUJIwAydrOA9gCZvD5wUtqESCRIeTI8cJYpyljWKUKhbDKexG1m6KnOhO3wP2ESQLv4LEZDUGSs1JS4qQUyiKECoUSpFTLApkW8LUTIqdma2rQ3KQIQpppXKdOQFQhPSQ8piLAt4JrQArYl4VpyYoZzjo_ULaR5kfy68jQX6quJ-E5fCgCUna5bKczgbSlKNLfUqKkpAGSprITe8ltypKkYqaL27O5-tDsKfcYv8iwKZnjuHC3wS0Yf0DCKWOAWEGxkOwAIwtmwmIqOqZXAd9FRQNrqsvagVJaM_3TGUDcpYaFo8Fzkq0jfMkWaLQwcHKtIzpTlalLynKmIsNq09dbv4LKpamrIqajU2cxriYbU8IyQ0FhJOfo7KdHAiezvlPxQ1CknKX1RNQADUTzSyKk6qXqptvb8UMtCNanwACap-YH2iIpAWAB8Eu2plkCPCk6p1_QrTocIbJJoCp6pS_gvkb_q4mbm2M4GH4AUDun4qhYWAMd0ahojANJkkJwTwFtU0sh5SeHIUEx9YJiMM6kA5twM8ZZo8Nmyitg1ULIEvZZN1DNA3Nbehoa2CjCXljMWG6nbqWqMjPQG5mu4vdR_bAVst0DJFi-h7thDVgqhc4BoABZAJz5UuNMyCPQmIDCy7X49SFxg-u6l3HJga6BgmKl-rHpcMAneCYBvqVWpRqnkqaxWwozZSTyMy0INYShpM0giAAhpt6kQ9PWpxqk_YX0yHX638OpCWGn6qXhp3_SDhlRp8AzdqdLgrqm0adwMFhC5NkxpaozmQiqW76mM5lxks07nZoFJu1T6spFJwjbc1gjJiVCXXLI4ugBtSFSYiVDcjCIRr6nODBYA8qmHjIa0IxTZqc_guDH-yTmxs9FToEhp6kINqQaphGnkqU2pYkwHoIXIlcDOqb2p-wxmaYvwS_hToBxp2IFalicIMSmUQOMR7Qk04ICpSZjGZuCM1dZHENlIsZwnkaMQ0pjscAFpRxDSmKy2LUSRhPHW5uY5-mCesaDFCIl4NBDckHlJ76AuqfwB7GSp_MTWa7iWmB1IrkDIgM7WQUFTycORFhCLxPRpqWn7DIOGoCo2aRMmHmnHAMggIuBZABVmEjqOuMnyiGGTNmt2HXbYSW1p23az0fhJ1bZxts9R10mhGOvkpEmy9pm0FEnuSdRJKokQtvnWDEmF5LGcsLZGlnQAnbHBBPTk5vikNLNpQlH_dsmpYmbEyajxaLYbacjWA-SxsvZp2JKyyj5JdMmDade26AB9UFtpIYEo8KDAQskSQHopEphlmoCRvknMyUSRhpjAkddpH2lq0MIyPNKcyZ9x3MkRws8afMkl5gsExMnmtL5p62lLYIDYpDTOuOfJB2qjGNUR7sFY4FhgV9pKDFJgAAC9MUmZeJ5uaXDt2OPafWHj2iOApRwPcGXsuSz_dOKgAVI8SYFpX0lfYEAmAdCTZPtp-IyhaYo2hUDFQPR8zszUMFSYnGkIRlu6fQzVTKwBOsyMDD3UCqkoFBKM8VBCdvlgfWS86Q5pl1FuLg1q9orSYFLWkGllpGmpaPDw0B-IJ0Q9SPB6pGkDSSNCgMQ1wOWBEFSNaWaRPdLEyR7kMjgDUEgGYPzL9GjwE0iKwFKAOIBvdNTpUUlzKsE4OoBCaTFwAvbFtKwAYWklkcz2ndxhaYlGVTI_uOhKY4BoaSS0_GnZwG7pwjaewGOY3GlzmAnuuom2AGmYF-yUAEOYzLbvaazpbRBBaWjJ9sHFZIo2YfQ-SZxpLEaiaZt6kMAr4hiOHul8QMjWgfQnaaoIlukuuDI4xzK26SmhTUnabDTpz0QyHgHmFhCuSPnp_NQg7AAcmemFiPN6xekiYHGCijba4IXpvIlTAG3pfPKF1EEWibbe6d00nul96f9SjaiD6eNQ6ekwcFnp80D16QjYU-lotq5IhemioA9pwXKJAKjA2elSyXlwx7g2Jl7paLyVwAPpX0mUyZ9pgZiPsI_pWzQugAHpb-l_aYaYTdKA6ftowOkamGDpmcoJ_swxFZFOqeQYWACX6TXpPen3aVgAG-qJAPPYN-kfcS9p9-nRABvpaVJb6a_pDsnCMp_p2Bk-6ZY2v2nWmAAZnyqiycAZcyG8yZNg4OmI-BAZlSkg4HzgyOnIGaFyqOlV_owZ0Blo4S0AhsnqEdqpyGn6qXPgX7aztoB2AJaE1tnMkWmwVvnmL-zrJr9Embzx1jgAFIZs8nk2-zSVzHTp-2lPaSY28FBs6SQZmhmWNh2Q0OmxnM46-DCkNBMOFlT8GXppGKmv8SApxWmT8ctqG1GMGQjhqACZ2CYsRKbwGVtyU2l51pGErJYF1pIZQszk4QgWd3YUadiAmxZl1npUHEkOGSApyKkNqdfY8hlSGVgAA-TeIHEZQsyyhpLYRNSWGUZpMVaG9kkpkBnd0PlKR2Fzzu2UdWk70sQZJJhJqX-gnDj3PvDASwAIyRrWYoa1gaWU-8ni6Wn6wO5y6diSVwC1gbLgfIylJBppsuCaqT-4ummzfPppcaQCGdiAxmk96ZPwA6kugBZprqlTGcMwtmk_KjwhSGYwSuUaFVZhUe0KYcHOKQ6ETA55xJIxbjHsTrzwuCm8KXw8RCnCCAQppClbKYIpJalSMawI507ccjb03t7rCAwpqt7HwEoxYTFx8FsZb6SmqhVx53GviaWqw56xZiWmx3RyKeAR1gGxikopQ-F9cRew3SYfJgRhbupYYc7uUKbtBkdx4WbXIYJy92hv4aboH-FaZOluOvD1MjMoXLG1WPYpXVg-5AsadgD1yX8Zhb66_gWWuUgtCWXJvclNiaGEC8ZB2Iy8UQBQAJCGPGAFVgYRE8GXHNR2lSkpKQ0hmBG7GiduV_bxahlxmzishCvxlCCJapIyL3FTljmJpGndcTKhLaD7nrnx8SnoEYKZJQRX4F4s0pTamYLhwpndKHFaeJkNMoSZUVjazgjghpjd4cYMRZHITmKq4DYjfnaZteasANmwjpl1FAqQLJm_VOyZZeDy4a5AkwmSOt7xICk0CBgAXJlgEYKZjvDO6Mbo_HDyRM4AMuhmcGeOHhA9idw0_MFs5PsJJf75TpARXQBOSuRUWTQV4TgA5WErMHj4hCz_bqXStWCYmXbA2Jms9K8GH0BlmaoyTyGVmZPJ8-C1yu8ULOwZmYvxrv4YEa2Zxcl4eKXJqZ5yMK2ZWZmg4UgJXmh1iQOZiiTGCbEJqAQtib0p25zeyStyfYllKTOZ74lOYBUpn6CJmUxqptA5-vtuWrHYsdfAhpm1MviZfzEtMmtEG_LR3LIkirF7mcaZBJkqsUeZXsgb8shOW5nRANqxpfjosnUyJpnXmbVYG_IybmMA55kvmQeZppnHmb-RnxprmU5gF4qwoBWx3BZeyUuZVdA48SEAH8DAKcqZ8AAqkAkZCZkloR0QoFkEAFvYdBldyQhZEwxq4LKGKFmyoWhZuZJb2DXmBFmhICqQtTad0MBZNODoWVvYSl7YWdRZ1JATNlRZqFkgWcRZ6PC58YxZx2S5kjtp3BbsoP4JQfhRyYyZFEZCCTeqK9GjmUJZaAk68bAp8FlrmblwuMFqmXgRsCnXyYtAOGpCvDrxSGxbqXhkoGna6eGh_bTLNquBcmAcvnPMroC-CfiAB_IBCI6JeGlwcLqkMkDzrNNI0lbLUPVQzQCrlusGVKwJMLJWFGCtSQah9ZGvqaD0ChF9WCxWHrhsVnJBBdBsYX1Ybqx9QTWGjWEPHn5Z9EDC3JmywtytSb1hwQBKQAEIfxEzqQpp7ABSCf2ZzTZjmeXJpQnPhpQYIkkfagm273QjmcRJIWBNmU_hdYkocUnJQkgugGvxwkSSWYVZMlFFHquWbWFHAMUa_wBcaYTp76H9YV-h2V4VWUnJz4Y1mRWZy6Gs9C1Z3vjMYW3JZDbA0cJEwtw9KoXQWHBGYShha8b7xpshemGWoC2JzNyrWfxho0AImc0GSJkwprFq3Hh7WWBZ6eJPquJZV7ZxHOdZUwCPJqCmDyGUMuoyy6GZxndZARQuyRuQ11lJyUxhCsaXJrRhocEl4dpg1VlP7K2ZdVnZmXpZA5kb4SDZLZkr0VDkoSk68Y-JMSlx1oxaQFmsWTRZuZIb4fNqT3ByWVegTVlyVKC2N3bMweqJhdZOYMtpslE9iZPh08mjsapZznpR-phRpvosWYRZYWBR7PTZKWA9ibvIOJrodphUWQlcWfnmiRlo2czZeFkC2RJgcoEc2W2RVNl82f7wbNljKYrEl_CzmXo458kf6s8J13aM2GfoRAAdEG1K8tmJmeTZWu53cJTZeZHU2R_qRomMoBzZz4YPqrpGqxnhogrZSZkmLDvKKNnFUIbZXFnoWS1EoxCXxjbZVNnDkcrZJ7FIqQuAhlYO2UOAuemsAO7ZiZmn2rJebsxu2VaINtlZiFu6cSFWiM3e8oC6wFbQ8QKEVlbQN0ERVOO67NgWgGnSy-o11AhZJ65irJYM0LSYFPUA2oBM5rRgucC5nvkANnDJAORG296FQKe6k9aXWpa2XYS_chEA4oDTkRJAhyl_eJIi_ZLjumkIMl5fannMTKyFUA5qh9oHanDBEkmE2WrZxNns2O3ZxdlUvuEZRwGMGR_JAGp_7PYZ4qrLCe2UftnW0AE4A2kRAO-BXdnE2G-GTiJMxP3Z9pzOBs0eUD4P2sOAr2yT2SsJefxdgDbZjJZ32Trq12raQM_Zl_BP4DRJt3Yk2ZfwutlJ7k_sApmV4QrZpBAw2dSIrZnskIJRp6r55i2yl4bWga4cMDlxHOypfgj8YLqZsQD--qTR_-RfugpB2sB8zgA4C5g9SXVJLYDs4AmGlNlUuAh677pZQa4c5tmSIvacglFBmT6ZnyQYEeGZlJToiGZEMZkscGZw_i4Z-K4c3dGjUkvxgplPCZCGimFVZDzCONi4LqYJuRn4EeApFjQG9jrqIWbEcXgR6jzoHlsU2jx0gtfixYDEgFUA3gALhL-Akhyv_JCC8FRqwuS8W3qQwIY5IAD8dv0AjllXPI78HJxVHPo5E8DM_FPAN8DDLPfafcB4BOUAIIC6ORMSfTxconjQ-gLMwFhAFjnM_Hw0qKSvUg9sZ9BagFc8GiYeIqpSSMDxQptiTXGFwDE5w7xIwBpSiTmoMC3AMTl6QJDAOAA5hIMCUTnnnt-wMTnYwPk5-TmZOYj-K1L8ABomuTn5Uvk5BTn8_MBw_7BcBAc8GiaJcojAQhJNOdC0wXChcG0Q4XBAYuS8GiZFvPk5uWL3gp3Y2Mg5OXk5XTmZgr-YksBLbG05uTlbeiFwtsGG0oU5k_yGKTMhxik5mDE5RkDlOY05mYKHFH0AxxSnlCXmbTl7ORDABzn3gkc5o4LOihKAuzl5OVc5D3weOT6qn4IgALU5-zmZOTAi4aoxOUW8iMBPOTCCOcGl4lZazvoxOZ05GTnrOfRATD5vnp1mH54o3q7CdjyIAFU8bjxtZg08sLlfPGDemTnxbkVaqTl5Odoi_PxUIWC5GlLmOZC5llrc_AXB5cKxOTgA_zmZOWfhwTmLOTgAYHwAuY-8HjnWgKk5ezldcAk5CkKOME2I3jm4ACuyWlj93sAIuzz4_qY8KbyPcFSMQyHEoBs8CgDyAPIAQAA`} __position={0} __code={'<Map viewport={{ center: [0.026, 123.61], zoom: 5 }} />'} __scope={{props: this ? this.props : props,Map}}>\n  <Map viewport={{ center: [0.026, 123.61], zoom: 5, }} />\n</Playground>\n           </MDXTag>\n  }\n}\n  "],"sourceRoot":""}