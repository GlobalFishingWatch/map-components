{"version":3,"sources":["webpack:///./src/map/glmap/map.css","webpack:///./src/map/lib/Pack.js","webpack:///./src/map/lib/pelagosClient.js","webpack:///./src/map/proptypes/tracks.js","webpack:///./src/map/proptypes/layers.js","webpack:///./src/map/proptypes/shared.js","webpack:///./src/map/module/module.actions.js","webpack:///./src/map/module/module.selectors.js","webpack:///./src/map/tracks/tracks.selectors.js","webpack:///./src/map/constants.js","webpack:///./src/map/utils/buildEndpoint.js","webpack:///./src/map/utils/heatmapTileData.js","webpack:///./src/map/heatmap/heatmapTiles.actions.js","webpack:///./src/map/config.js","webpack:///./src/map/heatmap/heatmap.actions.js","webpack:///./src/map/glmap/viewport.actions.js","webpack:///./src/map/glmap/interaction.actions.js","webpack:///./src/map/utils/map-colors.js","webpack:///./src/map/heatmap/HeatmapSubLayer.js","webpack:///./src/map/heatmap/HeatmapLayer.js","webpack:///./src/map/activity/ActivityLayers.js","webpack:///./src/map/activity/ActivityLayers.container.js","webpack:///./src/map/glmap/Map.js","webpack:///./src/map/glmap/Map.container.js","webpack:///./src/map/glmap/style.reducer.js","webpack:///./src/map/utils/getMainGeomType.js","webpack:///./src/map/glmap/style.actions.js","webpack:///./src/map/glmap/viewport.reducer.js","webpack:///./src/map/store/index.js","webpack:///./src/map/utils/getTrackBounds.js","webpack:///./src/map/tracks/tracks.actions.js","webpack:///./src/map/utils/withReducerTypes.js","webpack:///./src/map/module/module.reducer.js","webpack:///./src/map/tracks/tracks.reducer.js","webpack:///./src/map/heatmap/heatmap.reducer.js","webpack:///./src/map/heatmap/heatmapTiles.reducer.js","webpack:///./src/map/glmap/interaction.reducer.js","webpack:///./src/map/store/reducers.js","webpack:///./src/map/map.js","webpack:///./src/map/basemaps/index.js","webpack:///./src/map/map.mdx"],"names":["module","exports","byname","Uint8","size","Uint8Array","BYTES_PER_ELEMENT","array","getter","setter","Int8","Int8Array","Uint16","Uint16Array","Int16","Int16Array","Uint32","Uint32Array","Int32","Int32Array","Float32","Float32Array","Float64","Float64Array","writeStringToArrayBuffer","str","start","end","buf","bufstart","undefined","length","i","charCodeAt","arrayBufferToString","String","fromCharCode","apply","Pack","typemap","byarray","pack","typespec","value","littleendian","ArrayBuffer","DataView","stringToArrayBuffer","res","Uint8ClampedArray","buffer","name","spec","PelagosClient","this","MAGIC_COOKIE","url","token","Promise","resolve","reject","request","XMLHttpRequest","open","setRequestHeader","responseType","onload","handleData","bind","onerror","send","self","error","readyState","success","status","isFileUri","response","byteLength","dataView","headerLen","cookie","slice","getInt32","offset","headerIsLoaded","header","JSON","parse","rowLen","colsByName","colidx","cols","col","idx","type","multiplier","min","max","orientation","errorLoading","toString","allLoaded","result","rowidx","row","val","colValues","eval","trackTypes","id","PropTypes","string","isRequired","data","object","color","oneOf","layerTemporalExtents","arrayOf","number","fitBoundsOnLoad","bool","shape","hue","filterValues","endpoints","temporalExtents","temporalExtentsLess","field","values","node","startLoader","dispatch","state","loaderId","timestamp","Date","getTime","payload","map","onLoadStart","completeLoader","getState","loaders","onLoadComplete","onViewportChange","interactionState","callback","viewport","zoom","center","latitude","longitude","bounds","canZoomIn","canZoomOut","mouseLatLong","setHighlightTemporalExtent","highlightTemporalExtent","getTemporalExtent","temporalExtent","getGeojsonTracksReady","createSelector","tracks","filter","t","mergeStyles","style1","style2","sources","layers","filterGeojsonByTimerange","geojson","features","featuresFiltered","reduce","filteredFeatures","feature","properties","coordinateProperties","times","filtered","geometry","coordinates","filteredCoordinates","coordinate","index","timeCoordinate","push","filteredFeature","getFullTracksStyles","hasTemporalExtent","hasTracks","timerange","acc","track","source","style","paint","getHighlightedTrackStyles","getTracksStyles","trackStyles","highlightedTrackStyles","TRANSITION_TYPE","BRUSH_RENDERING_STYLE","NORMAL","BULLSEYE","BRUSH_ZOOM_RENDERING_STYLE","CUSTOM_LAYERS_SUBTYPES","urlTemplate","urlParams","templateSettings","interpolate","template","urlTemplateCompiled","getTemporalTileURLs","params","urls","forEach","extent","startTimeISO","toISOString","endTimeISO","tileCoordinates","x","y","z","buildEndpoint","temporalExtentsIndices","indexOf","getTilePromises","tilesetUrl","promises","urlIndex","obtainTile","getCleanVectorArrays","rawTileData","vectorArray","groupData","cleanVectorArrays","columns","currentArray","totalVectorArraysLength","sumBy","a","filteredColumns","column","console","warn","key","cumulatedOffsets","appendValues","set","vesselSatisfiesFilters","frame","Object","keys","every","selectVesselsAt","tileData","tileQuery","startIndex","endIndex","currentFilters","vessels","worldX","worldY","toleranceRadiusInWorldUnits","f","wx","wy","filters","pass","some","vesselSatisfiesAllFilters","vessel","timeIndex","getTilecoverLimits","viewportZoom","Math","ceil","tilesAvailable","min_zoom","max_zoom","flushToReleaseTiles","heatmapTiles","currentToLoadTileUids","currentTilesToReleaseUids","currentToReleaseTileUids","releaseTiles","markTileAsLoaded","tileUids","flushTileState","forceLoadingAllVisibleTiles","currentVisibleTiles","tilesToLoad","tilesToReleaseUids","currentLoadedTiles","visibleTile","find","uid","loadedTile","tilesToLoadUids","tile","getTile","updateLoadedTiles","debouncedFlushState","debounce","updateHeatmapTilesFromViewport","mapViewport","width","height","currentTransition","boundsViewport","PerspectiveMercatorViewport","unproject","wn","es","w","s","e","n","boundsPolygonsCoordinates","limits","w1","e2","geom","viewportTilesCoords","tilecover","tiles","viewportTilesIndexes","indexes","visibleTiles","coords","prevZoom","queryHeatmapVessels","temporalExtentIndexes","uids","heatmap","heatmapLayers","layersVessels","layerId","layer","visible","availableTiles","bestTile","isCluster","isMouseCluster","isEmpty","layerVesselsResult","foundVessels","layersVesselsResults","layerVessels","v","uniqBy","series","_queryHeatmap","highlightedVessels","tilesetId","subtype","clickableCluster","highlightableCluster","clearHighlightedVessels","highlightVesselFromHeatmap","getTemporalExtentsVisibleIndices","loadTemporalExtent","currentExtentStart","currentExtentEnd","indices","temporalExtentStart","loadLayerTile","Error","pelagosPromises","allLayerPromises","all","then","loadedLayerId","parseLayerTile","prevPlaybackData","tilePlaybackData","zoomFactorRadius","convert","getZoomFactorRadius","zoomFactorRadiusRenderingMode","getZoomFactorRadiusRenderingMode","zoomFactorOpacity","getZoomFactorOpacity","columnsArr","c","storedColumns","concat","sigma","weight","hidden","pull","uniq","numPoints","newFrames","timeIndexes","point","getOffsetedTimeAtPrecision","datetime","lngLatToWorld","radius","sigmaToRadius","opacity","weightToOpacity","getTilePlaybackData","getTiles","layerIds","referenceTiles","newTemporalExtentsToLoad","loaderID","join","tilesByLayer","allPromises","heatmapLayerHeader","referenceTile","temporalExtentsIndicesLoaded","queriedTemporalExtentsIndices","visibleTemporalExtentsIndices","temporalExtentsIndicesToLoad","difference","tilePromise","visibleHeatmapLayers","visibleHeatmapLayersIds","loadAllTilesForLayer","updateHeatmapLayers","newLayers","currentLoadTemporalExtent","prevLayersDict","newLayer","prevLayer","interactive","prevLayerId","l","transitionTo","increment","transitionEnd","fitToBounds","vp","fitBounds","minLng","minLat","maxLng","maxLat","padding","getAreaKm2","glFeature","area","toLocaleString","maximumFractionDigits","getFeature","fields","fieldsDefinition","metadata","fieldsKeys","k","fd","fieldKey","def","label","title","isLink","isMain","mainField","getFields","mapInteraction","interactionType","glFeatures","glGetSource","legacyHeatmapFeature","currentStyle","mapStyle","toJS","event","currentLegacyHeatmapData","count","group","clusterPromises","getStaticLayerIdFromGlFeature","cluster","clusterPromise","clusterId","cluster_id","glSource","getClusterExpansionZoom","err1","getClusterLeaves","err2","children","childrenFeatures","child","getCluster","autoClusterZoom","clusterBehavior","clusterZoom","zoomIntoVesselCenter","cursor","onClick","onHover","hsvToRgb","h_","s_","v_","h","parseFloat","floor","p","q","mod","r","g","b","round","hueToRgbDefaults","hueToRgbString","rgb","hexToRgb","hex","exec","parseInt","hueIncrementToHue","hueIncrement","hueToHueIncrement","wrapHue","HeatmapSubLayer","baseTexture","renderingStyleIndex","useNormalBlendMode","stage","PIXI","particles","ParticleContainer","scale","alpha","position","uvs","blendMode","BLEND_MODES","SCREEN","spritesPool","initialTextureFrame","Rectangle","VESSELS_BASE_RADIUS","mainVesselTexture","Texture","_setTextureFrame","clearSpriteProps","spritesProps","spritesPropsCount","destroy","textureFrame","clone","VESSELS_HUES_INCREMENTS_NUM","update","numProps","resizeSpritesPool","sprite","setTransform","numSprites","delta","toRemove","removeChildAt","toAdd","_addSprites","num","Sprite","anchor","addChild","worldToPixelsSimple","m","HeatmapLayer","_build","_destroy","_redraw","nextProps","useRadialGradientStyle","props","setBrushZoomRenderingStyle","rootStage","customRenderingStyle","subLayers","renderingStyle","rendering","setBrushRenderingStyle","brushRenderingStyle","toUpperCase","_setBrushRenderingStyleIndex","brushZoomRenderingStyle","cappedZoomRenderingStyle","newStyleIndex","subLayer","setRenderingStyleIndex","defaultHue","allHuesToRender","currentlyUsedHues","allHues","_createSublayer","_destroySubLayer","_setSubLayersSpritePropsForTile","numFilters","hueToRender","render","viewportLeft","viewportRight","len","fi","scaledX","scaledY","mtx","pixelProjectionMatrix","pitch","worldToPixels","pushSpriteProps","defaultOpacity","defaultSize","removeChild","React","Component","ActivityLayers","pixiReady","touches","queryCoords","clientX","clientY","heatmapFadingIn","heatmapStage","_heatmapFadeinStep","setState","exportNativeViewport","_context","_updateViewportSize","pixi","transparent","antialias","renderer","canvas","view","container","appendChild","baseTextureCanvas","blurFactor","tplCanvas","document","createElement","tplCtx","getContext","diameter","yCenter","gradient","createRadialGradient","rgbString","addColorStop","rgbOuter","fillStyle","fillRect","beginPath","arc","PI","fill","lineWidth","strokeStyle","stroke","getVesselTexture","fromCanvas","ticker","add","_onTick","viewportWidth","viewportHeight","resize","dim","wrappedLongitude","heatmapFadeinStartTimestamp","now","timeElapsed","highlightedClickedVessel","highlightLayerData","highlightFilters","leftWorldScaled","rightWorldScaled","shouldUseRadialGradientStyle","toggleHeatmapDimming","_startHeatmapFadein","gl","getError","err","log","_getHighlightData","ref","onMouseMove","onTouchStart","BaseControl","propTypes","func","contextTypes","getHeatmapLayersAsArray","getTemporalExtentIndexes","startTimestamp","endTimestamp","connect","ownProps","nativeViewport","topLeftPx","bottomRightPx","topLeftWorld","pixelsToWorld","pixelUnprojectionMatrix","bottomRightWorld","northWest","southEast","north","south","west","east","PopupWrapper","closeButton","onClose","offsetTop","tipSize","closeOnClick","defaultProps","Map","onLoad","getBounds","setBounds","glMap","_ne","_sw","lat","lng","window","ResizeObserver","default","_containerResizeObserver","handleResizeObserver","observe","_mapContainerRef","entries","contentRect","setViewport","propsViewport","bearing","lngLat","onMapInteraction","getMap","getSource","isDragging","resourceType","match","headers","Authorization","mouseOver","loadObserver","disconnect","maxZoom","minZoom","onClosePopup","clickPopup","hoverPopup","hasHeatmapLayers","markers","interactiveLayerIds","className","styles","onMouseLeave","onMouseEnter","getRef","transformRequest","onTransitionEnd","getCursor","clickRadius","disableTokenWarning","content","marker","googleLogo","getInteractiveLayerIds","staticLayers","glLayer","glLayerId","getMapStyle","mapStyles","trackLayersIndex","lastIndexOf","finalMapStyles","mergeIn","mapStylesLayers","get","trackLayer","insert","fromJS","interaction","internalCursor","moduleCursor","long","attributions","GL_STYLE","sourceKey","attribution","setLayerStyleDefaults","layout","temporalField","visibility","initialState","cartoLayersInstanciated","basemapLayers","TYPES","geoJSON","INIT_MAP_STYLE","SET_MAP_STYLE","MARK_CARTO_LAYERS_AS_INSTANCIATED","SET_STATIC_LAYERS","SET_BASEMAP_LAYERS","setDefaultVectorTiles","currentSource","refLayerUrl","refLayerUrls","setMapStyle","setStyleTemporalExtent","applyToThrottled","glLayers","currentFilter","getIn","isLegacy","setIn","applyTemporalExtentThrottled","throttle","applyTemporalExtent","updateGLLayer","refLayer","currentStyleLayers","newStyle","glLayerIndex","findIndex","toggleLayerVisibility","isBasemap","refLayerOpacity","labelsVisibility","showLabels","colorPaintProperty","currentGlLayer","glType","defaultStyles","styleType","refLayerStyle","hasFeatures","applyStyleToAllFeatures","allPaintProperties","glPaintProperty","glPaintFinalValue","selectedValue","fallbackValue","paintOrLayout","includes","originalLayerStyle","layerColorRgbString","layerColorRgb","replace","applyLayerExpressions","addCustomGLLayer","tileSize","allGeoJSONTypes","numByGLType","geoJSONType","glTypeMax","getMainGeomType","layerIndex","reverse","splice","instanciateCartoLayers","sourceId","cartoLayersPromises","sourceCartoSQL","mapConfig","options","sql","mapConfigURL","encodeURIComponent","stringify","cartoAnonymousMapUrl","fetch","json","layergroupid","catch","instanciatedCartoLayers","cartoLayer","tilesURL","newSourceId","deleteIn","commitStyleUpdates","bl","currentGLSources","workspaceGLLayers","workspaceGLLayer","finalSource","existingLayerIds","layerToAdd","layerToAddId","sourceLayer","existingLayers","newLayerGroup","newLayerIndex","findLastIndex","updateWorkspaceGLLayers","customLayers","isCustom","glSources","cartoLayersToInstanciate","newSource","cartoLayerInstanciated","DEFAULT_TRANSITION","transitionDuration","transitionInterpolator","FlyToInterpolator","transitionEasing","easeCubic","composeEnhancers","compose","process","MAP_REDUX_REMOTE_DEBUG","REACT_APP_MAP_REDUX_REMOTE_DEBUG","store","createStore","applyMiddleware","thunk","getTrackTimeBounds","time","Infinity","getTrackBounds","tbbox","loadTrack","trackHasData","trackHasUrl","geoBounds","cleanData","vectorArrays","currentLng","createFeature","segId","geomType","currentSeries","currentFeature","fishingPoints","lngOffset","ll","cloneDeep","convertLegacyTrackToGeoJSON","timelineBounds","statusText","fitToBoundsAction","targetMapVessel","finally","removeTrack","trackId","updateTracks","newTracks","prevTracks","newTrack","prevTrack","withReducerPropTypes","propTypesSchema","reducer","onAttributionsChange","withReducerTypes","instanceOf","action","loaderIndex","exact","trackData","removedTrackId","mapReducer","combineReducers","ModuleReducer","TracksReducer","assign","newVisibleTemporalExtentsIndices","indicesRemoved","newTile","layerTiles","tileIndex","tileUid","releasedTileIndex","releasedRefTileIndex","newHeatmapLayers","newToLoadTilesUids","tileUidsMarkedAsLoaded","newCurrentToLoadTileUids","newMapStyle","glyphsPath","currentZoom","mapReducers","replaceReducer","throttleApplyTemporalExtent","setTemporalExtent","updateViewportFromIncomingProps","incomingViewport","viewportUpdate","MapModule","initialized","errorInfo","prevProps","indicesToAddByLayer","heatmapLayer","oldVisibleTemporalExtentsIndices","indicesAdded","layerIdsWithIndicesToAdd","currentViewport","abs","componentStack","MDXContent","components","parentName","__codesandbox","__position","__code","__scope"],"mappings":"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","file":"static/js/src-map-map.ebcfc5d4.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"map\":\"map_map__1TLha\",\"googleLogo\":\"map_googleLogo__3lQ1y\"};","/* eslint-disable */\nvar byname = {\n  Uint8: {\n    size: Uint8Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint8',\n    setter: 'setUint8',\n  },\n  Int8: {\n    size: Int8Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint8',\n    setter: 'setUint8',\n  },\n  Uint16: {\n    size: Uint16Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint16',\n    setter: 'setUint16',\n  },\n  Int16: {\n    size: Int16Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getInt16',\n    setter: 'setInt16',\n  },\n  Uint32: {\n    size: Uint32Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint32',\n    setter: 'setUint32',\n  },\n  Int32: {\n    size: Int32Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getInt32',\n    setter: 'setInt32',\n  },\n  Float32: {\n    size: Float32Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getFloat32',\n    setter: 'setFloat32',\n  },\n  Float64: {\n    size: Float64Array.BYTES_PER_ELEMENT,\n    array: 'Float64Array',\n    getter: 'getFloat64',\n    setter: 'setFloat64',\n  },\n}\n\nvar writeStringToArrayBuffer = function(str, start, end, buf, bufstart) {\n  if (end == undefined) {\n    end = str.length\n  }\n  if (start == undefined) {\n    start = 0\n  }\n  if (bufstart == undefined) {\n    bufstart = start\n  }\n  for (var i = start; i < end; i++) {\n    buf[i - start + bufstart] = str.charCodeAt(i) & 0xff\n  }\n}\n\nvar stringToArrayBuffer = function(str, start, end) {\n  var self = this\n\n  if (end == undefined) {\n    end = str.length\n  }\n  if (start == undefined) {\n    start = 0\n  }\n  var res = new Uint8ClampedArray(end - start)\n  writeStringToArrayBuffer(str, start, end, res, 0)\n  return res.buffer\n}\n\nvar arrayBufferToString = function(buf) {\n  return String.fromCharCode.apply(null, new Uint8Array(buf))\n}\n\nvar pack = function(typespec, value, littleendian) {\n  var array = new ArrayBuffer(typespec.size)\n  new DataView(array)[typespec.setter](0, value, littleendian)\n  return arrayBufferToString(array)\n}\n\nvar Pack = {\n  typemap: {\n    byname: byname,\n    byarray: {},\n  },\n  pack: pack,\n  arrayBufferToString: arrayBufferToString,\n  stringToArrayBuffer: stringToArrayBuffer,\n  writeStringToArrayBuffer: writeStringToArrayBuffer,\n}\nfor (var name in Pack.typemap.byname) {\n  var spec = Pack.typemap.byname[name]\n  spec.name = name\n  Pack.typemap.byarray[spec.array] = spec\n}\n\nexport default Pack\n","/* eslint-disable */\n\nimport Pack from './Pack'\n\nclass PelagosClient {\n  constructor() {\n    this.MAGIC_COOKIE = 'tmtx'\n  }\n\n  obtainTile(url, token) {\n    return new Promise(\n      function(resolve, reject) {\n        this.request = null\n        if (typeof XMLHttpRequest != 'undefined') {\n          this.request = new XMLHttpRequest()\n        } else {\n          throw 'XMLHttpRequest is disabled'\n        }\n        this.resolve = resolve\n        this.reject = reject\n        this.request.open('GET', url, true)\n        if (token) {\n          this.request.setRequestHeader('Authorization', `Bearer ${token}`)\n        }\n        this.request.responseType = 'arraybuffer'\n        this.request.onload = this.handleData.bind(this)\n        this.request.onerror = this.handleData.bind(this)\n        this.request.send(null)\n      }.bind(this)\n    )\n  }\n\n  handleData() {\n    var self = this\n    if (!this.request) {\n      return\n    }\n    if (this.error) {\n      return true\n    }\n\n    if (this.request.readyState == 4) {\n      /* HTTP reports success with a 200 status. The file protocol\n       reports success with zero. HTTP returns zero as a status\n       code for forbidden cross domain requests.\n       https://developer.mozilla.org/En/Using_XMLHttpRequest */\n      var success = this.request.status == 200 || (this.isFileUri && this.request.status == 0)\n      if (!success) {\n        this.resolve(null)\n        return\n      }\n    }\n\n    if (!this.request.response) {\n      return\n    }\n    var length = this.request.response.byteLength\n    var response = this.request.response\n    var dataView = new DataView(response)\n\n    if (length < 4 + 4) {\n      return\n    }\n    if (self.headerLen == null) {\n      var cookie = Pack.arrayBufferToString(response.slice(0, 4))\n      if (cookie != this.MAGIC_COOKIE) {\n        this.reject(\n          'Could not load ' +\n            this.url +\n            ' due to incorrect file format. Cookie: [' +\n            this.cookie +\n            ']'\n        )\n        return\n      }\n\n      self.headerLen = dataView.getInt32(4, true)\n\n      self.offset = 4 + 4\n    }\n    if (length < self.offset + self.headerLen) {\n      return\n    }\n    if (!self.headerIsLoaded) {\n      self.header = JSON.parse(\n        Pack.arrayBufferToString(response.slice(self.offset, self.offset + self.headerLen))\n      )\n      self.rowLen = 0\n      self.header.colsByName = {}\n      for (var colidx = 0; colidx < self.header.cols.length; colidx++) {\n        var col = self.header.cols[colidx]\n        col.idx = colidx\n        self.header.colsByName[col.name] = col\n        col.typespec = Pack.typemap.byname[col.type]\n\n        if (col.multiplier != undefined && col.min != undefined) {\n          col.min = col.min * col.multiplier\n        }\n        if (col.offset != undefined && col.min != undefined) {\n          col.min = col.min + col.offset\n        }\n        if (col.multiplier != undefined && col.max != undefined) {\n          col.max = col.max * col.multiplier\n        }\n        if (col.offset != undefined && col.max != undefined) {\n          col.max = col.max + col.offset\n        }\n\n        self.rowLen += col.typespec.size\n      }\n      self.offset += self.headerLen\n\n      // Add the padding to nearest 4-byte-boundary\n      self.offset += (4 - (self.headerLen % 4)) % 4\n\n      self.headerIsLoaded = true\n      if (self.header.orientation != 'rowwise' && self.header.orientation != 'columnwise') {\n        self.errorLoading({\n          orientation: self.header.orientation,\n          toString: function() {\n            return (\n              'Could not load ' +\n              this.url +\n              ' due to unsupported file orientation. Orientation: ' +\n              this.orientation +\n              '. Supported orientations: rowwise, columnwise.'\n            )\n          },\n        })\n        return true\n      }\n\n      // Empty tile, stop parsing.\n      if (!self.rowLen) {\n        self.allLoaded()\n        return true\n      }\n    }\n    if (self.header.orientation == 'rowwise') {\n      var result = {}\n      for (; self.offset + self.rowLen <= length; self.rowidx++) {\n        var row = {}\n        for (var colidx = 0; colidx < self.header.cols.length; colidx++) {\n          var col = self.header.cols[colidx]\n          var val = dataView[col.typespec.getter](self.offset, true)\n          row[col.name] = val\n          self.offset += col.typespec.size\n        }\n        // self.rowLoaded(row);\n\n        result[col.name] = row\n      }\n      if (self.rowidx == self.header.length) {\n        // self.allLoaded();\n        this.resolve(result)\n      } else {\n        // self.batchLoaded();\n      }\n    } else if (self.header.orientation == 'columnwise') {\n      var colValues = null\n      var result = {}\n      if (length >= self.offset + self.header.length * self.rowLen) {\n        for (var colidx = 0; colidx < self.header.cols.length; colidx++) {\n          var col = self.header.cols[colidx]\n\n          colValues = new (eval(col.typespec.array))(\n            response.slice(self.offset, self.offset + col.typespec.size * self.header.length)\n          )\n          self.offset += self.header.length * col.typespec.size\n\n          result[col.name] = colValues\n        }\n\n        // self.allLoaded();\n        this.resolve(result)\n        return true\n      }\n    }\n  }\n}\n\nexport default PelagosClient\n","import PropTypes from 'prop-types'\n\nexport const trackTypes = {\n  id: PropTypes.string.isRequired,\n  url: PropTypes.string,\n  data: PropTypes.object,\n  color: PropTypes.string,\n  type: PropTypes.oneOf(['geojson', 'pelagos', undefined]),\n  layerTemporalExtents: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.number)),\n  fitBoundsOnLoad: PropTypes.bool,\n}\n","import PropTypes from 'prop-types'\n\nexport const heatmapLayerTypes = {\n  id: PropTypes.string.isRequired,\n  tilesetId: PropTypes.string,\n  subtype: PropTypes.string,\n  visible: PropTypes.bool,\n  hue: PropTypes.number,\n  opacity: PropTypes.number,\n  filters: PropTypes.arrayOf(\n    PropTypes.shape({\n      // hue overrides layer hue if set\n      hue: PropTypes.number,\n      // filterValues is a dictionary in which each key is a filterable field,\n      // and values is an array of all possible values (OR filter)\n      // ie: filterValues: { category: [5, 6] }\n      filterValues: PropTypes.object,\n    })\n  ),\n  header: PropTypes.shape({\n    endpoints: PropTypes.object,\n    colsByName: PropTypes.object,\n    temporalExtents: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.number)),\n    temporalExtentsLess: PropTypes.bool,\n  }).isRequired,\n  interactive: PropTypes.bool,\n}\n\nexport const basemapLayerTypes = {\n  id: PropTypes.string,\n  visible: PropTypes.bool,\n}\n\nexport const staticLayerTypes = {\n  id: PropTypes.string.isRequired,\n  // TODO MAP MODULE Is that needed and if so why\n  visible: PropTypes.bool,\n  selected: PropTypes.bool,\n  selectedFeatures: PropTypes.shape({\n    field: PropTypes.string,\n    values: PropTypes.arrayOf(PropTypes.string),\n  }),\n  highlighted: PropTypes.bool,\n  higlightedFeatures: PropTypes.shape({\n    field: PropTypes.string,\n    values: PropTypes.arrayOf(PropTypes.string),\n  }),\n  opacity: PropTypes.number,\n  color: PropTypes.string,\n  showLabels: PropTypes.bool,\n  interactive: PropTypes.bool,\n  filters: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.string)),\n  isCustom: PropTypes.bool,\n  subtype: PropTypes.oneOf([undefined, 'geojson', 'raster']),\n  url: PropTypes.string,\n  data: PropTypes.object,\n  gl: PropTypes.object,\n}\n","import PropTypes from 'prop-types'\n\nexport const popupTypes = {\n  content: PropTypes.node,\n  latitude: PropTypes.number.isRequired,\n  longitude: PropTypes.number.isRequired,\n}\n\nexport const viewportTypes = {\n  zoom: PropTypes.number,\n  center: PropTypes.arrayOf(PropTypes.number),\n}\n","export const INIT_MODULE = 'INIT_MODULE'\nexport const SET_TEMPORAL_EXTENT = 'SET_TEMPORAL_EXTENT'\nexport const SET_HIGHLIGHT_TEMPORAL_EXTENT = 'SET_HIGHLIGHT_TEMPORAL_EXTENT'\nexport const START_LOADER = 'START_LOADER'\nexport const COMPLETE_LOADER = 'COMPLETE_LOADER'\nexport const SET_MODULE_CURSOR = 'SET_MODULE_CURSOR'\n\nexport const initModule = (props) => (dispatch) => {\n  dispatch({\n    type: INIT_MODULE,\n    payload: props,\n  })\n}\n\nexport const startLoader = (dispatch, state, loaderId) => {\n  const timestamp = new Date().getTime()\n  const generatedLoaderId = loaderId !== undefined ? `${loaderId}_${timestamp}` : timestamp\n  dispatch({\n    type: START_LOADER,\n    payload: generatedLoaderId,\n  })\n  if (state.map.module.onLoadStart !== undefined) {\n    state.map.module.onLoadStart()\n  }\n  return loaderId\n}\n\nexport const completeLoader = (loaderId) => (dispatch, getState) => {\n  dispatch({\n    type: COMPLETE_LOADER,\n    payload: loaderId,\n  })\n  const state = getState()\n  const loaders = state.map.module.loaders\n  if (!loaders.length && state.map.module.onLoadComplete !== undefined) {\n    state.map.module.onLoadComplete()\n  }\n}\n\nexport const onViewportChange = (interactionState) => (dispatch, getState) => {\n  const state = getState()\n  const callback = state.map.module.onViewportChange\n\n  if (callback === undefined) {\n    return\n  }\n  const viewport = state.map.viewport\n\n  callback({\n    interactionState,\n    zoom: viewport.viewport.zoom,\n    center: [viewport.viewport.latitude, viewport.viewport.longitude],\n    bounds: viewport.bounds,\n    canZoomIn: viewport.canZoomIn,\n    canZoomOut: viewport.canZoomOut,\n    mouseLatLong: viewport.mouseLatLong,\n  })\n}\n\nexport const setTemporalExtent = (temporalExtent) => ({\n  type: SET_TEMPORAL_EXTENT,\n  payload: temporalExtent,\n})\n\nexport const setHighlightTemporalExtent = (highlightTemporalExtent) => ({\n  type: SET_HIGHLIGHT_TEMPORAL_EXTENT,\n  payload: highlightTemporalExtent,\n})\n\nexport const closePopup = () => (dispatch, getState) => {\n  const state = getState()\n  if (state.map.module.onClosePopup !== undefined) {\n    state.map.module.onClosePopup()\n  }\n}\n\nexport const setCursor = (cursor) => ({\n  type: SET_MODULE_CURSOR,\n  payload: cursor,\n})\n","export const getTemporalExtent = (state) => state.map.module.temporalExtent\n\nexport const getHighlightTemporalExtent = (state) => state.map.module.highlightTemporalExtent\n","import { createSelector } from 'reselect'\nimport { getTemporalExtent, getHighlightTemporalExtent } from '../module/module.selectors'\n\nexport const getTracksData = (state) => state.map.tracks.data\n\nexport const getGeojsonTracksReady = createSelector(\n  getTracksData,\n  (tracks) => tracks.filter((t) => t.data !== undefined)\n)\n\nconst mergeStyles = (style1, style2) => ({\n  sources: { ...style1.sources, ...style2.sources },\n  layers: [...style1.layers, ...style2.layers],\n})\n\nconst filterGeojsonByTimerange = (geojson, { start, end }) => {\n  if (!geojson || !geojson.features) return null\n  const featuresFiltered = geojson.features.reduce((filteredFeatures, feature) => {\n    const hasTimes =\n      feature.properties &&\n      feature.properties.coordinateProperties &&\n      feature.properties.coordinateProperties.times &&\n      feature.properties.coordinateProperties.times.length > 0\n    if (hasTimes) {\n      const filtered = feature.geometry.coordinates.reduce(\n        (filteredCoordinates, coordinate, index) => {\n          const timeCoordinate = feature.properties.coordinateProperties.times[index]\n          const isInTimeline = timeCoordinate >= start && timeCoordinate <= end\n          if (isInTimeline) {\n            filteredCoordinates.coordinates.push(coordinate)\n            filteredCoordinates.times.push(timeCoordinate)\n          }\n          return filteredCoordinates\n        },\n        { coordinates: [], times: [] }\n      )\n      if (!filtered.coordinates.length) return filteredFeatures\n\n      const filteredFeature = {\n        ...feature,\n        geometry: {\n          ...feature.geometry,\n          coordinates: filtered.coordinates,\n        },\n        properties: {\n          ...feature.properties,\n          coordinateProperties: {\n            times: filtered.times,\n          },\n        },\n      }\n      filteredFeatures.push(filteredFeature)\n    }\n    return filteredFeatures\n  }, [])\n  const geojsonFiltered = {\n    ...geojson,\n    features: featuresFiltered,\n  }\n  return geojsonFiltered\n}\n\nconst getFullTracksStyles = createSelector(\n  [getTemporalExtent, getGeojsonTracksReady],\n  (temporalExtent, tracks) => {\n    const hasTemporalExtent = temporalExtent && temporalExtent.length > 0\n    const hasTracks = tracks && tracks.length > 0\n    if (!hasTemporalExtent || !hasTracks) return null\n\n    const timerange = {\n      start: temporalExtent[0].getTime(),\n      end: temporalExtent[1].getTime(),\n    }\n    const styles = tracks.reduce(\n      (acc, track) => {\n        if (!track.data) return acc\n\n        const source = `${track.id}Track`\n        const style = {\n          sources: {\n            [source]: {\n              type: 'geojson',\n              data: filterGeojsonByTimerange(track.data, timerange),\n            },\n          },\n          layers: [\n            {\n              id: `${track.id}Lines`,\n              source,\n              type: 'line',\n              paint: {\n                'line-width': 1,\n                'line-color': track.color,\n              },\n            },\n            {\n              id: `${track.id}Points`,\n              source,\n              type: 'circle',\n              filter: ['match', ['geometry-type'], ['', 'Point'], true, false],\n              paint: {\n                'circle-radius': 4,\n                'circle-color': track.color,\n              },\n            },\n          ],\n        }\n        return mergeStyles(acc, style)\n      },\n      { sources: {}, layers: [] }\n    )\n    return styles\n  }\n)\n\nconst getHighlightedTrackStyles = createSelector(\n  [getHighlightTemporalExtent, getGeojsonTracksReady],\n  (highlightTemporalExtent, tracks) => {\n    const hasTemporalExtent = highlightTemporalExtent && highlightTemporalExtent.length > 0\n    const hasTracks = tracks && tracks.length > 0\n    if (!hasTemporalExtent || !hasTracks) return null\n\n    const timerange = {\n      start: highlightTemporalExtent[0].getTime(),\n      end: highlightTemporalExtent[1].getTime(),\n    }\n    const styles = tracks.reduce(\n      (acc, track) => {\n        if (!track.data) return acc\n\n        const source = `${track.id}HighlightedTrack`\n        const style = {\n          sources: {\n            [source]: {\n              type: 'geojson',\n              data: filterGeojsonByTimerange(track.data, timerange),\n            },\n          },\n          layers: [\n            {\n              id: `${track.id}HighlightedLines`,\n              source,\n              type: 'line',\n              paint: {\n                'line-width': 1,\n                'line-color': '#fff',\n              },\n            },\n          ],\n        }\n        return mergeStyles(acc, style)\n      },\n      { sources: {}, layers: [] }\n    )\n    return styles\n  }\n)\n\nexport const getTracksStyles = createSelector(\n  [getFullTracksStyles, getHighlightedTrackStyles],\n  (trackStyles, highlightedTrackStyles) => {\n    if (!highlightedTrackStyles) return trackStyles\n    return mergeStyles(trackStyles, highlightedTrackStyles)\n  }\n)\n","export const GL_TRANSPARENT = 'rgba(0,0,0,0)'\n\nexport const TRANSITION_TYPE = {\n  ZOOM: 'ZOOM',\n}\n\nexport const ENCOUNTERS = 'Encounters'\n\nexport const BRUSH_RENDERING_STYLE = {\n  NORMAL: 0,\n  BULLSEYE: 2,\n}\n\nexport const BRUSH_ZOOM_RENDERING_STYLE = {\n  RADIAL_GRADIENT: 0,\n  CIRCLE: 1,\n}\n\nexport const POLYGON_LAYERS_AREA = 'POLYGON_LAYERS_AREA'\n\nexport const CUSTOM_LAYERS_SUBTYPES = {\n  geojson: 'geojson',\n  raster: 'raster',\n}\n","import template from 'lodash/template'\nimport templateSettings from 'lodash/templateSettings'\n\nexport default (urlTemplate, urlParams) => {\n  templateSettings.interpolate = /{{([\\s\\S]+?)}}/g\n  const urlTemplateCompiled = template(urlTemplate)\n  return urlTemplateCompiled(urlParams)\n}\n","import pull from 'lodash/pull'\nimport uniq from 'lodash/uniq'\nimport sumBy from 'lodash/sumBy'\nimport { lngLatToWorld } from 'viewport-mercator-project'\nimport convert from '@globalfishingwatch/map-convert'\nimport buildEndpoint from './buildEndpoint'\nimport PelagosClient from '../lib/pelagosClient'\n\n/**\n * Generates the URLs to load vessel track data for a tile\n *\n * @param {string} tilesetUrl       the tileset base URL\n * @param {array} temporalExtents   all tileset temporal extents\n * @param {object} params           - tileCoordinates: this tiles tile coordinates (zoom, x, y). Will default to 0,0,0\n *                                  - temporalExtentsIndices: restrict to these temporalExtents indices\n * @returns {Array}                 an array of URLs for this tile\n */\nconst getTemporalTileURLs = (urlTemplate, temporalExtents, params = {}) => {\n  const urls = []\n\n  ;(temporalExtents || [null]).forEach((extent, index) => {\n    const urlParams = {}\n    if (extent !== null && params.temporalExtentsLess !== true) {\n      urlParams.startTimeISO = new Date(extent[0]).toISOString()\n      urlParams.endTimeISO = new Date(extent[1]).toISOString()\n    }\n    if (params.tileCoordinates) {\n      urlParams.x = params.tileCoordinates.x\n      urlParams.y = params.tileCoordinates.y\n      urlParams.z = params.tileCoordinates.zoom\n    }\n\n    const url = buildEndpoint(urlTemplate, urlParams)\n\n    if (\n      params.temporalExtentsLess === true ||\n      !params.temporalExtentsIndices ||\n      params.temporalExtentsIndices.indexOf(index) > -1\n    ) {\n      urls.push(url)\n    }\n  })\n  return urls\n}\n\n/**\n * See getTemporalTileURLs.\n */\nexport const getTilePromises = (tilesetUrl, token, temporalExtents, params = {}) => {\n  const promises = []\n  const urls = getTemporalTileURLs(tilesetUrl, temporalExtents, params)\n  for (let urlIndex = 0, length = urls.length; urlIndex < length; urlIndex++) {\n    promises.push(new PelagosClient().obtainTile(urls[urlIndex], token))\n  }\n\n  return promises\n}\n\nexport const getCleanVectorArrays = (rawTileData) =>\n  rawTileData.filter((vectorArray) => vectorArray !== null)\n\n/**\n * As data will come in multiple arrays (1 per API query/year basically), they need to be merged here\n *\n * @param cleanVectorArrays an array of objects containing a Float32Array for each vessel param (lat, lon, weight...)\n * @param columns the keys to pick on the vectorArrays (lat, lon, weight, etc)\n * @returns an object containing a Float32Array for each API_RETURNED_KEY (lat, lon, weight, etc)\n */\nexport const groupData = (cleanVectorArrays, columns) => {\n  const data = {}\n\n  const totalVectorArraysLength = sumBy(cleanVectorArrays, (a) => a.longitude.length)\n\n  const filteredColumns = columns.filter((column) => {\n    if (cleanVectorArrays[0] && cleanVectorArrays[0][column] === undefined) {\n      console.warn(`column ${column} is present in layerHeader.colsByName but not in tile data`)\n      return false\n    }\n    return true\n  })\n\n  filteredColumns.forEach((key) => {\n    data[key] = new Float32Array(totalVectorArraysLength)\n  })\n\n  let currentArray\n  let cumulatedOffsets = 0\n\n  const appendValues = (key) => {\n    data[key].set(currentArray[key], cumulatedOffsets)\n  }\n\n  for (let index = 0, length = cleanVectorArrays.length; index < length; index++) {\n    currentArray = cleanVectorArrays[index]\n    filteredColumns.forEach(appendValues)\n    cumulatedOffsets += currentArray.longitude.length\n  }\n  return data\n}\n\n/**\n * Converts Vector Array data to Playback format and stores it locally.\n * The data structure is an array indexed by a time unit, ie a set of points every day\n * This preprocessing step allows playback to play smoothly as the necessary conversions and data structure set up\n * is done once (after tile has been loaded)\n *\n * @param data the source data before indexing by day, an object containing\n *  - a vector (Float32Array) for each header's column in the case of Pelagos tiles\n *  - an array of points int the case of PBF tiles\n * @param colsByName the columns present on the dataset, determined by tileset headers\n * @param tileCoordinates x, y, z\n * @param prevPlaybackData an optional previously loaded tilePlaybackData array (when adding time range)\n */\nexport const getTilePlaybackData = (data, colsByName, tileCoordinates, prevPlaybackData) => {\n  const tilePlaybackData = prevPlaybackData === undefined ? [] : prevPlaybackData\n\n  const zoom = tileCoordinates.zoom\n  const zoomFactorRadius = convert.getZoomFactorRadius(zoom)\n  const zoomFactorRadiusRenderingMode = convert.getZoomFactorRadiusRenderingMode(zoom)\n  const zoomFactorOpacity = convert.getZoomFactorOpacity(zoom)\n\n  // store all available columns as object keys\n  const columns = {}\n  const columnsArr = Object.keys(colsByName)\n  columnsArr.forEach((c) => {\n    columns[c] = true\n  })\n\n  // columns specified by layer header columns\n  let storedColumns = [].concat(columnsArr)\n  if (columns.sigma === true) storedColumns.push('radius')\n  if (columns.weight === true) storedColumns.push('opacity')\n  if (columns.longitude === true) {\n    storedColumns.push('worldX')\n    storedColumns.push('worldY')\n  }\n  if (columns.id === true) {\n    storedColumns.push('series')\n  }\n\n  // omit values that will be transformed before being stored to playback data (ie lat -> worldY)\n  // only if hidden: true flag is set on header\n  ;['latitude', 'longitude', 'datetime'].forEach((col) => {\n    if (colsByName[col] === undefined || colsByName[col].hidden === true) {\n      pull(storedColumns, col)\n    }\n  })\n  // always pull sigma and weight\n  pull(storedColumns, 'sigma', 'weight')\n  storedColumns = uniq(storedColumns)\n\n  const numPoints = data.latitude.length\n\n  const newFrames = {}\n  const timeIndexes = []\n  for (let index = 0, length = numPoints; index < length; index++) {\n    let point = {}\n    columnsArr.forEach((c) => {\n      point[c] = data[c][index]\n    })\n\n    const timeIndex = columns.timeIndex\n      ? point.timeIndex\n      : convert.getOffsetedTimeAtPrecision(point.datetime)\n\n    // FIXME: this should not be done when headers declare worldX/Y -  if (!columns.worldX) {\n    const [worldX, worldY] = lngLatToWorld([point.longitude, point.latitude], 1)\n    point.worldX = worldX\n    point.worldY = worldY\n\n    if (columns.sigma) {\n      point.radius = convert.sigmaToRadius(\n        point.sigma,\n        zoomFactorRadiusRenderingMode,\n        zoomFactorRadius\n      )\n    }\n    if (columns.weight) {\n      point.opacity = convert.weightToOpacity(point.weight, zoomFactorOpacity)\n    }\n    if (columns.id) {\n      point.series = point.id\n    }\n\n    if (!newFrames[timeIndex]) {\n      timeIndexes.push(timeIndex)\n      const frame = {}\n      storedColumns.forEach((column) => {\n        frame[column] = [point[column]]\n      })\n      newFrames[timeIndex] = frame\n      continue\n    }\n    const frame = newFrames[timeIndex]\n    storedColumns.forEach((column) => {\n      frame[column].push(point[column])\n    })\n  }\n\n  // finally, copy new frames to the overall tilePlaybackData object\n  // frames previously existing here will be overwritten\n  timeIndexes.forEach((timeIndex) => {\n    tilePlaybackData[timeIndex] = newFrames[timeIndex]\n  })\n  return tilePlaybackData\n}\n\nexport const vesselSatisfiesFilters = (frame, index, filterValues) => {\n  const satisfiesFilters = Object.keys(filterValues).every((field) => {\n    if (frame[field] === undefined) {\n      // this field is not available on this layer. This can happen in an edge case described\n      // here: https://github.com/GlobalFishingWatch/map-client/issues/661#issuecomment-334496469\n      return false\n    }\n    return filterValues[field].indexOf(frame[field][index]) > -1\n  })\n  return satisfiesFilters\n}\n\nconst vesselSatisfiesAllFilters = (frame, index, filters) => {\n  const satisfiesAllFilters = filters\n    .filter((f) => f.pass !== true)\n    .some((filter) => vesselSatisfiesFilters(frame, index, filter.filterValues))\n  return satisfiesAllFilters\n}\n\nexport const selectVesselsAt = (tileData, tileQuery, startIndex, endIndex, currentFilters) => {\n  const vessels = []\n\n  const { worldX, worldY, toleranceRadiusInWorldUnits } = tileQuery\n\n  for (let f = startIndex; f < endIndex; f++) {\n    const frame = tileData[f]\n    if (frame === undefined) continue\n    for (let i = 0; i < frame.worldX.length; i++) {\n      const wx = frame.worldX[i]\n      const wy = frame.worldY[i]\n\n      if (\n        (!currentFilters.length || vesselSatisfiesAllFilters(frame, i, currentFilters)) &&\n        wx >= worldX - toleranceRadiusInWorldUnits &&\n        wx <= worldX + toleranceRadiusInWorldUnits &&\n        wy >= worldY - toleranceRadiusInWorldUnits &&\n        wy <= worldY + toleranceRadiusInWorldUnits\n      ) {\n        const vessel = {}\n\n        Object.keys(frame).forEach((key) => {\n          vessel[key] = frame[key][i]\n        })\n        vessel.timeIndex = f\n        vessels.push(vessel)\n      }\n    }\n  }\n  return vessels\n}\n\n/*\nexport const getHistogram = (tiles, propName = 'weight') => {\n  let data = tiles\n    .filter(tile => tile.ready)\n    .map(tile => tile.data\n      .map(frame => frame[propName]));\n  data = flattenDeep(data);\n  if (data.length) {\n    const bins = d3.histogram().thresholds(d3.thresholdScott)(data);\n    const x = d3.scaleLinear().domain([0, d3.max(bins, d => d.length)]).range([0, 50]);\n    console.table(bins.filter(bin => bin.length).map((bin) => {\n      const binMin = d3.min(bin).toLocaleString({ maximumFractionDigits: 2 });\n      const binMax = d3.max(bin).toLocaleString({ maximumFractionDigits: 2 });\n      return {\n        range: [binMin, binMax].join('﹣'),\n        bars: Array(Math.round(x(bin.length))).join('█'),\n        num: bin.length\n      };\n    }));\n  }\n};\n*/\n","import tilecover from '@mapbox/tile-cover/index'\nimport debounce from 'lodash/debounce'\nimport { PerspectiveMercatorViewport } from 'viewport-mercator-project'\nimport { ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING, TILES_LOAD_ZOOM_OFFSET } from '../config'\nimport {\n  getTile,\n  releaseTiles,\n  highlightVesselFromHeatmap,\n  updateLoadedTiles,\n} from './heatmap.actions'\n\nexport const SET_CURRENTLY_VISIBLE_TILES = 'SET_CURRENTLY_VISIBLE_TILES'\nexport const SET_CURRENTLY_LOADED_TILES = 'SET_CURRENTLY_LOADED_TILES'\nexport const SET_CURRENTLY_SWAPPED_TILE_UIDS = 'SET_CURRENTLY_SWAPPED_TILE_UIDS'\nexport const MARK_TILES_UIDS_AS_LOADED = 'MARK_TILES_UIDS_AS_LOADED'\nexport const RELEASE_MARKED_TILES_UIDS = 'RELEASE_MARKED_TILES_UIDS'\n\n// restrict tilecover to a single zoom level\n// could be customized to load less or more detailed tiles\nconst getTilecoverLimits = (viewportZoom) => {\n  let zoom = Math.ceil(viewportZoom + TILES_LOAD_ZOOM_OFFSET)\n  let tilesAvailable = true\n  if (zoom > ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING) {\n    zoom = ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING\n    tilesAvailable = false\n  }\n  return {\n    min_zoom: zoom,\n    max_zoom: zoom,\n    tilesAvailable,\n  }\n}\n\nconst flushToReleaseTiles = () => (dispatch, getState) => {\n  const state = getState()\n  const currentToLoadTileUids = state.map.heatmapTiles.currentToLoadTileUids\n  // console.log('Tiles left to load: ', currentToLoadTileUids);\n\n  // Tiles are released only when all to-load tiles have finished loading\n  // this is to ensure smooth visual transitions between zoom levels\n  if (!currentToLoadTileUids.length) {\n    const currentTilesToReleaseUids = state.map.heatmapTiles.currentToReleaseTileUids\n    // console.log('no more tiles to load, releasing ', currentTilesToReleaseUids);\n    dispatch(releaseTiles(currentTilesToReleaseUids))\n    dispatch({\n      type: RELEASE_MARKED_TILES_UIDS,\n    })\n  }\n}\n\nexport const markTileAsLoaded = (tileUids) => (dispatch) => {\n  dispatch({\n    type: MARK_TILES_UIDS_AS_LOADED,\n    payload: tileUids,\n  })\n  // console.log(tileUids, 'have finished loading');\n  dispatch(flushToReleaseTiles())\n}\n\nconst flushTileState = (forceLoadingAllVisibleTiles = false) => (dispatch, getState) => {\n  const state = getState()\n  const currentVisibleTiles = state.map.heatmapTiles.currentVisibleTiles\n  let tilesToLoad = []\n  const tilesToReleaseUids = []\n\n  if (forceLoadingAllVisibleTiles === true) {\n    tilesToLoad = currentVisibleTiles\n  } else {\n    const currentLoadedTiles = state.map.heatmapTiles.currentLoadedTiles\n\n    currentVisibleTiles.forEach((visibleTile) => {\n      if (currentLoadedTiles.find((t) => t.uid === visibleTile.uid) === undefined) {\n        tilesToLoad.push(visibleTile)\n      }\n    })\n\n    currentLoadedTiles.forEach((loadedTile) => {\n      if (currentVisibleTiles.find((t) => t.uid === loadedTile.uid) === undefined) {\n        tilesToReleaseUids.push(loadedTile.uid)\n      }\n    })\n  }\n\n  const tilesToLoadUids = tilesToLoad.map((t) => t.uid)\n  // console.log('force loading:', forceLoadingAllVisibleTiles)\n  // console.log('visible', currentVisibleTiles.map(t => t.uid))\n  // console.log('load', tilesToLoadUids)\n  // console.log('release', tilesToReleaseUids)\n  // console.log('----')\n\n  tilesToLoad.forEach((tile) => {\n    dispatch(getTile(tile))\n  })\n  dispatch({\n    type: SET_CURRENTLY_LOADED_TILES,\n    payload: currentVisibleTiles,\n  })\n\n  dispatch({\n    type: SET_CURRENTLY_SWAPPED_TILE_UIDS,\n    payload: {\n      tilesToLoadUids,\n      tilesToReleaseUids,\n    },\n  })\n\n  dispatch(updateLoadedTiles())\n  dispatch(flushToReleaseTiles())\n}\n\nconst _debouncedFlushState = (dispatch) => {\n  dispatch(flushTileState())\n}\nconst debouncedFlushState = debounce(_debouncedFlushState, 500)\n\nexport const updateHeatmapTilesFromViewport = (forceLoadingAllVisibleTiles = false) => (\n  dispatch,\n  getState\n) => {\n  // if in transition, skip loading/releasing\n  // else\n  //   collect all tiles in viewport\n  //   save them to reducer: currentVisibleTiles\n  // if not zooming: flush immediately\n  //   if forceLoadingAllVisiblelTiles\n  //     get tiles from currentVisibleTiles\n  //   else\n  //     get tiles from currentVisibleTiles\n  //     make delta with currentLoadedTiles\n  //     get tiles from delta+\n  //     release tiles from delta-\n  //   save to reducer: currentVisibleTiles -> currentLoadedTiles\n  // if zooming: debounced flush to avoid \"tile spam\"\n  const mapViewport = getState().map.viewport\n  const viewport = mapViewport.viewport\n\n  // do not allow any tile update during transitions (currently only zoom)\n  // wait for the end of the transition to look at viewport and load matching tiles\n  if (!viewport.width || !viewport.height || mapViewport.currentTransition !== null) {\n    return\n  }\n\n  // instanciate a viewport instance to get lat/lon from screen top left/ bottom right bounds\n  const boundsViewport = new PerspectiveMercatorViewport(viewport)\n  const bounds = [\n    boundsViewport.unproject([0, 0]),\n    boundsViewport.unproject([viewport.width, viewport.height]),\n  ]\n\n  const [wn, es] = bounds\n  const [w, s, e, n] = [wn[0], es[1], es[0], wn[1]]\n  const boundsPolygonsCoordinates = []\n\n  const limits = getTilecoverLimits(viewport.zoom)\n  if (limits.tilesAvailable === false && forceLoadingAllVisibleTiles !== true) {\n    return\n  }\n\n  if (e > 180 || w < -180) {\n    // deal with the antimeridian situation by splitting the bounds polygon into two polygons\n    const w1 = e > 180 ? w : w + 360\n    const e1 = 180 - 0.001\n    const w2 = -180\n    const e2 = e > 180 ? e - 360 : e\n    boundsPolygonsCoordinates.push([[[w1, n], [e1, n], [e1, s], [w1, s], [w1, n]]])\n    boundsPolygonsCoordinates.push([[[w2, n], [e2, n], [e2, s], [w2, s], [w2, n]]])\n  } else {\n    boundsPolygonsCoordinates.push([[[w, n], [e, n], [e, s], [w, s], [w, n]]])\n  }\n\n  const geom = {\n    type: 'MultiPolygon',\n    coordinates: boundsPolygonsCoordinates,\n  }\n\n  // using tilecover, get xyz tile coords as well as quadkey indexes (named uid through the app)\n  const viewportTilesCoords = tilecover.tiles(geom, limits)\n  const viewportTilesIndexes = tilecover.indexes(geom, limits)\n  const visibleTiles = []\n\n  viewportTilesCoords.forEach((coords, i) => {\n    const uid = viewportTilesIndexes[i]\n    const zoom = coords[2]\n    if (zoom >= 2) {\n      visibleTiles.push({\n        tileCoordinates: {\n          x: coords[0],\n          y: coords[1],\n          zoom: coords[2],\n        },\n        uid,\n      })\n    }\n  })\n\n  dispatch({\n    type: SET_CURRENTLY_VISIBLE_TILES,\n    payload: visibleTiles,\n  })\n\n  const isMouseWheelZooming = mapViewport.prevZoom !== viewport.zoom\n\n  if (isMouseWheelZooming === false) {\n    dispatch(flushTileState(forceLoadingAllVisibleTiles))\n  } else {\n    debouncedFlushState(dispatch)\n  }\n}\n\nexport const queryHeatmapVessels = (coords, temporalExtentIndexes) => (dispatch, getState) => {\n  // use tilecover to get what tile quadkey/uid \"belongs\" to the point\n  const geom = {\n    type: 'Point',\n    coordinates: [coords.longitude, coords.latitude],\n  }\n  const zoom = getState().map.viewport.viewport.zoom\n\n  // get quadkey for tile at current zoom level, but also neighbouring zoom levels,\n  // in case current zoom level tiles has not been loaded yet\n  const uids = [zoom, zoom - 1, zoom + 1]\n    .map((z) => getTilecoverLimits(z))\n    .map((limits) => tilecover.indexes(geom, limits))\n    .map((indexes) => indexes[0])\n\n  const query = {\n    ...coords,\n    uids,\n  }\n\n  // console.log(query);\n  dispatch(highlightVesselFromHeatmap(query, temporalExtentIndexes))\n}\n","// Application settings\nexport const TIMELINE_STEP = 24 * 60 * 60 * 1000 // 1 day\nexport const MIN_FRAME_LENGTH_MS = TIMELINE_STEP // 1 day\n\n// vessels rendering\n// from this zoom level and above, render using circle style instead of heatmap\nexport const VESSELS_RADIAL_GRADIENT_STYLE_ZOOM_THRESHOLD = 6\n// the base radius, it can only be scaled down by the radius factor calculated on the dataset\nexport const VESSELS_BASE_RADIUS = 8\n// in heatmap style, defines how 'blurry' a point will look. Higher = less blur\nexport const VESSELS_HEATMAP_BLUR_FACTOR = 0.15\n\nexport const ACTIVITY_HIGHLIGHT_HUE = 312\n\nexport const VESSELS_HEATMAP_DIMMING_ALPHA = 0.5\n\nexport const MAX_SPRITES_PER_LAYER = 200000\n\n// interaction\n// radius of vessels lookup in pixels,\n// ie how large the clicked region should be for including vessels\nexport const VESSEL_CLICK_TOLERANCE_PX = 10\n\nexport const CLUSTER_CLICK_ZOOM_INCREMENT = 1\n\nexport const MIN_ZOOM_LEVEL = 1\n// user can zoom up to this z level, but it doesn't guarantee availability of tiles\nexport const MAX_ZOOM_LEVEL = 14\n\n// data\n// Limit tile loading for activity layers up to this z level.\n// Beyond, layer is still displayed but with coarse data from the lower zoom level\nexport const ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING = 10\n\n// Sets what should be the discrete zoom level to load tiles, from a non-discrete\n// viewport zoom values. For instance, a values of 0.5 will load z 3 with a viewport\n// z of 2 (ceiling of 2 + 0.5)\n// this has a direct impact on the number of points displayed on the map, thus on the\n// performance of the app.\nexport const TILES_LOAD_ZOOM_OFFSET = 0.5\n\nexport const STATIC_LAYERS_CARTO_ENDPOINT =\n  'https://carto.globalfishingwatch.org/user/admin/api/v1/map?config=$MAPCONFIG'\nexport const STATIC_LAYERS_CARTO_TILES_ENDPOINT =\n  'https://carto.globalfishingwatch.org/user/admin/api/v1/map/$LAYERGROUPID/{z}/{x}/{y}.mvt'\n\nexport const TRACKS_LAYER_IN_FRONT_OF_GROUP = 'temporal'\n\nexport const TILES_URL_NEEDING_AUTHENTICATION = 'gateway.api'\n","import difference from 'lodash/difference'\nimport uniq from 'lodash/uniq'\nimport uniqBy from 'lodash/uniqBy'\nimport {\n  getTilePromises,\n  getCleanVectorArrays,\n  groupData,\n  getTilePlaybackData,\n  selectVesselsAt,\n} from '../utils/heatmapTileData'\nimport { markTileAsLoaded } from './heatmapTiles.actions'\nimport { startLoader, completeLoader } from '../module/module.actions'\n\nexport const ADD_HEATMAP_LAYER = 'ADD_HEATMAP_LAYER'\nexport const UPDATE_HEATMAP_LAYER_STYLE = 'UPDATE_HEATMAP_LAYER_STYLE'\nexport const ADD_REFERENCE_TILE = 'ADD_REFERENCE_TILE'\nexport const HIGHLIGHT_VESSELS = 'HIGHLIGHT_VESSELS'\nexport const INIT_HEATMAP_LAYERS = 'INIT_HEATMAP_LAYERS'\nexport const REMOVE_HEATMAP_LAYER = 'REMOVE_HEATMAP_LAYER'\nexport const UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES =\n  'UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES'\nexport const UPDATE_HEATMAP_TILE = 'UPDATE_HEATMAP_TILE'\nexport const RELEASE_HEATMAP_TILES = 'RELEASE_HEATMAP_TILES'\nexport const UPDATE_LOADED_TILES = 'UPDATE_LOADED_TILES'\nexport const HIGHLIGHT_CLICKED_VESSEL = 'HIGHLIGHT_CLICKED_VESSEL'\nexport const CLEAR_HIGHLIGHT_CLICKED_VESSEL = 'CLEAR_HIGHLIGHT_CLICKED_VESSEL'\n\n/**\n * getTemporalExtentsVisibleIndices - Compares timebar outer extent with temporal extents present on the layer header\n * @param  {array} loadTemporalExtent Current timebar outer extent\n * @param  {array} layerTemporalExtents Temporal extent present on the layer's header (an array of extent arrays)\n * @return {array}                    Indices of the layer's temporal extents that should be visible\n */\nfunction getTemporalExtentsVisibleIndices(loadTemporalExtent, layerTemporalExtents) {\n  const currentExtentStart = loadTemporalExtent[0].getTime()\n  const currentExtentEnd = loadTemporalExtent[1].getTime()\n  const indices = []\n  layerTemporalExtents.forEach((temporalExtent, index) => {\n    const temporalExtentStart = temporalExtent[0]\n    const temporalExtentEnd = temporalExtent[1]\n    if (temporalExtentEnd >= currentExtentStart && temporalExtentStart <= currentExtentEnd) {\n      indices.push(index)\n    }\n  })\n  return indices\n}\n\n/**\n * loadLayerTile - loads an heatmap tile.\n *\n * @param  {string} layerId              layer id\n * @param  {object} tileCoordinates      tile coordinates from reference tile\n * @param  {string} token                the user's token\n * @param  {array} temporalExtentsIndices which of the temporal extents from  temporalExtents should be loaded\n * @param  {string} urls                 tile endpoints provided by header\n * @param  {array} temporalExtents       all of the layer's header temporal extents\n * @param  {bool} temporalExtentsLess    true = don't try to load different tiles based on current time extent\n * @return {Promise}                     a Promise that will be resolved when tile is loaded\n */\nfunction loadLayerTile(\n  layerId,\n  tileCoordinates,\n  token,\n  temporalExtentsIndices,\n  { url, temporalExtents, temporalExtentsLess }\n) {\n  // console.log('loadLayerTile', layerId, tileCoordinates, temporalExtentsIndices)\n  if (url === undefined) {\n    throw new Error('URL/endpoints object is not available on this tilesets header')\n  }\n  const pelagosPromises = getTilePromises(url, token, temporalExtents, {\n    tileCoordinates,\n    temporalExtentsIndices,\n    temporalExtentsLess,\n  })\n  const allLayerPromises = Promise.all(pelagosPromises)\n\n  const layerTilePromise = new Promise((resolve) => {\n    allLayerPromises.then((rawTileData) => {\n      resolve({\n        loadedLayerId: layerId,\n        rawTileData,\n      })\n    })\n  })\n\n  return layerTilePromise\n}\n\n/**\n * parseLayerTile - parses an heatmap tile to a playback-ready format.\n *\n * @param  {Object} rawTileData          the raw tile data, loaded either from the pelagos client or as a MVT/PBF vector tile\n * @param  {array} colsByName            names of the columns present in the raw tiles that need to be included in the final playback data\n * @param  {object} tileCoordinates      tile coordinates from reference tile\n * @param  {array} prevPlaybackData      (optional) in case some time extent was already loaded for this tile, append to this data\n * @return {Object}                      playback-ready merged data\n */\nfunction parseLayerTile(rawTileData, colsByName, tileCoordinates, prevPlaybackData) {\n  let data\n\n  const cleanVectorArrays = getCleanVectorArrays(rawTileData)\n  data = groupData(cleanVectorArrays, Object.keys(colsByName))\n  if (Object.keys(data).length === 0) {\n    return []\n  }\n\n  const playbackData = getTilePlaybackData(data, colsByName, tileCoordinates, prevPlaybackData)\n  return playbackData\n}\n\n/**\n * getTiles - loads a bunch of heatmap tiles\n * @param  {array} layerIds                 list of layer Ids that need to be loaded for this/these tiles\n * @param  {array} referenceTiles           list of reference tiles (tile data regardless of layer) that need to be loaded\n * @param  {object} newTemporalExtentsToLoad (optional) a dict (layerId is the key) of temporal extents\n * indices that should be appended to existing data\n */\nfunction getTiles(layerIds, referenceTiles, newTemporalExtentsToLoad = undefined) {\n  return (dispatch, getState) => {\n    const state = getState()\n    const loaderID = startLoader(dispatch, state, layerIds.join('-'))\n    const token = state.map.module.token\n    const heatmapLayers = state.map.heatmap.heatmapLayers\n    const tilesByLayer = {}\n    layerIds.forEach((id) => {\n      tilesByLayer[id] = [...heatmapLayers[id].tiles]\n    })\n    const allPromises = []\n\n    layerIds.forEach((layerId) => {\n      const heatmapLayerHeader = heatmapLayers[layerId].header\n      const { temporalExtents, temporalExtentsLess, colsByName } = { ...heatmapLayerHeader }\n      const url = heatmapLayerHeader.endpoints.tiles\n\n      referenceTiles.forEach((referenceTile) => {\n        // check if tile does not already exist first\n        let tile = tilesByLayer[layerId].find((t) => t.uid === referenceTile.uid)\n        if (!tile) {\n          // console.log('create tile ', referenceTile.uid)\n          tile = {\n            uid: referenceTile.uid,\n            temporalExtentsIndicesLoaded: [],\n          }\n          tilesByLayer[layerId].push(tile)\n        } else {\n          // console.log('found tile', referenceTile.uid)\n        }\n\n        const queriedTemporalExtentsIndices =\n          newTemporalExtentsToLoad === undefined\n            ? heatmapLayers[layerId].visibleTemporalExtentsIndices\n            : newTemporalExtentsToLoad[layerId]\n\n        const temporalExtentsIndicesToLoad = difference(\n          queriedTemporalExtentsIndices,\n          tile.temporalExtentsIndicesLoaded\n        )\n\n        const tilePromise = loadLayerTile(\n          layerId,\n          referenceTile.tileCoordinates,\n          token,\n          temporalExtentsIndicesToLoad,\n          {\n            url,\n            temporalExtents,\n            temporalExtentsLess,\n          }\n        )\n\n        allPromises.push(tilePromise)\n\n        tilePromise.then(({ loadedLayerId, rawTileData }) => {\n          tile.temporalExtentsIndicesLoaded = uniq(\n            tile.temporalExtentsIndicesLoaded.concat(temporalExtentsIndicesToLoad)\n          )\n          tile.data = parseLayerTile(\n            rawTileData,\n            colsByName,\n            referenceTile.tileCoordinates,\n            tile.data\n          )\n\n          dispatch({\n            type: UPDATE_HEATMAP_TILE,\n            payload: {\n              layerId: loadedLayerId,\n              tile,\n            },\n          })\n        })\n      })\n    })\n\n    Promise.all(allPromises).then(() => {\n      dispatch(completeLoader(loaderID))\n      dispatch(markTileAsLoaded(referenceTiles.map((tile) => tile.uid)))\n    })\n  }\n}\n\n/**\n * getTile - This action is emitted when a new tile is queried from panning or zooming the map\n * This will load a tile for all currently visible heatmap layers\n *\n * @param  {object} referenceTile a reference tile containing xyz coords and uid\n */\nexport function getTile(referenceTile) {\n  return (dispatch, getState) => {\n    dispatch({\n      type: ADD_REFERENCE_TILE,\n      payload: referenceTile,\n    })\n    const visibleHeatmapLayers = getState().map.heatmap.heatmapLayers\n    const visibleHeatmapLayersIds = Object.keys(visibleHeatmapLayers).filter(\n      (id) => visibleHeatmapLayers[id].visible === true\n    )\n\n    if (visibleHeatmapLayersIds.length) {\n      dispatch(getTiles(visibleHeatmapLayersIds, [referenceTile]))\n    }\n  }\n}\n\n/**\n * releaseTiles - This action is emitted when an existing tile is removed from panning or zooming the map\n * @param  {array} uids tile ref uids to release\n */\nexport const releaseTiles = (uids) => ({\n  type: RELEASE_HEATMAP_TILES,\n  payload: uids,\n})\n\nexport const updateLoadedTiles = () => ({\n  type: UPDATE_LOADED_TILES,\n})\n\n// triggered when a layer is added or set to visible\nfunction loadAllTilesForLayer(layerId) {\n  return (dispatch, getState) => {\n    //                current layer, all reference tiles\n    const referenceTiles = getState().map.heatmap.referenceTiles\n    dispatch(getTiles([layerId], referenceTiles))\n  }\n}\n\nexport const addHeatmapLayer = (layer, loadTemporalExtent) => (dispatch) => {\n  const layerTemporalExtents = layer.header.temporalExtents\n  dispatch({\n    type: ADD_HEATMAP_LAYER,\n    payload: {\n      ...layer,\n      // initially attach which of the temporal extents indices are visible with initial outerExtent\n      visibleTemporalExtentsIndices: getTemporalExtentsVisibleIndices(\n        loadTemporalExtent,\n        layerTemporalExtents\n      ),\n    },\n  })\n\n  if (layer.visible === true) {\n    dispatch(loadAllTilesForLayer(layer.id))\n  }\n}\n\nexport const removeHeatmapLayer = (id) => (dispatch) => {\n  dispatch({\n    type: REMOVE_HEATMAP_LAYER,\n    payload: {\n      id,\n    },\n  })\n}\n\n/**\n * updateLayerLoadTemporalExtents - when outer time extent changes, checks if more tiles needs to be loaded\n * by comparing the outer time range with the temporalExtent already loaded on each layer.\n * @param  {array} loadTemporalExtent Current app-wide extent of tiles that need to load, expressed\n * as an array of two dates\n */\nexport function updateLayerLoadTemporalExtents(loadTemporalExtent) {\n  return (dispatch, getState) => {\n    const state = getState()\n    const heatmapLayers = state.map.heatmap.heatmapLayers\n    const indicesToAddByLayer = {}\n\n    Object.keys(heatmapLayers).forEach((layerId) => {\n      const heatmapLayer = heatmapLayers[layerId]\n      const temporalExtents = heatmapLayer.header.temporalExtents\n      const oldVisibleTemporalExtentsIndices = heatmapLayer.visibleTemporalExtentsIndices\n      const newVisibleTemporalExtentsIndices = getTemporalExtentsVisibleIndices(\n        loadTemporalExtent,\n        temporalExtents\n      )\n\n      const indicesAdded = difference(\n        newVisibleTemporalExtentsIndices,\n        oldVisibleTemporalExtentsIndices\n      )\n\n      const indicesRemoved = difference(\n        oldVisibleTemporalExtentsIndices,\n        newVisibleTemporalExtentsIndices\n      )\n\n      if (indicesAdded.length || indicesRemoved.length) {\n        // add new loaded indices to heatmap layer if applicable\n        dispatch({\n          type: UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES,\n          payload: {\n            layerId,\n            newVisibleTemporalExtentsIndices,\n            indicesRemoved,\n          },\n        })\n      }\n      if (indicesAdded.length) {\n        indicesToAddByLayer[layerId] = indicesAdded\n      }\n    })\n\n    // getTiles with indices diff\n    const layerIdsWithIndicesToAdd = Object.keys(indicesToAddByLayer)\n    if (layerIdsWithIndicesToAdd.length) {\n      dispatch(\n        getTiles(layerIdsWithIndicesToAdd, state.map.heatmap.referenceTiles, indicesToAddByLayer)\n      )\n    }\n  }\n}\n\n/**\n * Returns clusters or vessels data from a tileQuery\n * @param {object} state - the application state\n * @param {string} tileQuery - the id of a heatmap layer\n * @return {object} { isEmpty, isCluster, isMouseCluster, foundVessels, layerId, tilesetId }\n */\nconst _queryHeatmap = (state, tileQuery, temporalExtentIndexes) => {\n  const layers = state.map.heatmap.heatmapLayers\n  const startIndex = temporalExtentIndexes[0]\n  const endIndex = temporalExtentIndexes[1]\n  const layersVessels = []\n\n  Object.keys(layers).forEach((layerId) => {\n    const layer = layers[layerId]\n    if (layer.visible !== true) {\n      return\n    }\n    const allPossibleTilesByPreference = tileQuery.uids.map((uid) =>\n      layer.tiles.find((tile) => tile.uid === uid)\n    )\n    const availableTiles = allPossibleTilesByPreference.filter(\n      (tile) => tile !== undefined && tile.data !== undefined\n    )\n\n    const currentFilters = layer.filters\n    if (availableTiles.length) {\n      const bestTile = availableTiles[0]\n      layersVessels.push({\n        layer,\n        vessels: selectVesselsAt(bestTile.data, tileQuery, startIndex, endIndex, currentFilters),\n      })\n    }\n  })\n\n  const layersVesselsResults = layersVessels.filter(\n    (layerVessels) => layerVessels.vessels.length > 0\n  )\n\n  // it's a cluster because of aggregation on the server side\n  let isCluster\n  // its a cluster because or multiple vessels under mouse\n  let isMouseCluster\n  let isEmpty\n  let layerVesselsResult\n  let foundVessels\n\n  if (layersVesselsResults.length === 0) {\n    isEmpty = true\n  } else if (layersVesselsResults.length > 1) {\n    // if there are points over multiple layers, consider this a cluster (ie don't select, zoom instead, or don't highlight)\n    // there's an exception if vessel selection contains an encounter, in which case it will take priority\n    isCluster = true\n  } else {\n    // layersVesselsResults should contain a single result\n    layerVesselsResult = layersVesselsResults[0]\n\n    // we can get multiple points with similar series and id, in which case\n    // we should treat that as a successful vessel query, not a cluster\n    const vessels = layerVesselsResult.vessels\n\n    if (vessels.length === 0) {\n      isEmpty = true\n    } else {\n      // look up for any negatives ids (clusters on the server side)\n      const clusteredVessels = vessels.filter((v) => v.id < 0)\n      if (clusteredVessels.length) {\n        isCluster = true\n      } else {\n        foundVessels = uniqBy(vessels, (v) => v.series)\n        isMouseCluster = foundVessels.length > 1\n      }\n    }\n  }\n\n  const layer = layerVesselsResult === undefined ? {} : layerVesselsResult.layer\n\n  return { isEmpty, isCluster, isMouseCluster, foundVessels, layer }\n}\n\nexport function clearHighlightedVessels() {\n  return {\n    type: HIGHLIGHT_VESSELS,\n    payload: {\n      isEmpty: true,\n      clickableCluster: false,\n    },\n  }\n}\n\nexport function highlightVesselFromHeatmap(tileQuery, temporalExtentIndexes) {\n  return (dispatch, getState) => {\n    const state = getState()\n    const { layer, isEmpty, isCluster, isMouseCluster, foundVessels } = _queryHeatmap(\n      state,\n      tileQuery,\n      temporalExtentIndexes\n    )\n\n    if (\n      isCluster === true ||\n      layer.id !== undefined ||\n      state.map.heatmap.highlightedVessels.layerId !== layer.id\n    ) {\n      const layerPayload =\n        layer === undefined\n          ? null\n          : {\n              id: layer.id,\n              tilesetId: layer.tilesetId,\n              subtype: layer.subtype,\n              header: layer.header,\n            }\n      dispatch({\n        type: HIGHLIGHT_VESSELS,\n        payload: {\n          layer: layerPayload,\n          isEmpty,\n          clickableCluster: isCluster === true || isMouseCluster === true,\n          highlightableCluster: isCluster !== true,\n          foundVessels,\n        },\n      })\n    } else {\n      dispatch(clearHighlightedVessels())\n    }\n  }\n}\n\nexport const highlightClickedVessel = (id, layerId) => ({\n  type: HIGHLIGHT_CLICKED_VESSEL,\n  payload: {\n    id,\n    layerId,\n  },\n})\n\nexport const clearHighlightedClickedVessel = () => ({\n  type: CLEAR_HIGHLIGHT_CLICKED_VESSEL,\n})\n\nexport const updateHeatmapLayers = (newLayers, currentLoadTemporalExtent) => (\n  dispatch,\n  getState\n) => {\n  if (newLayers === null) {\n    console.warn(\"New layers in updateHeatmapLayers can't be null\")\n    return\n  }\n  const prevLayersDict = getState().map.heatmap.heatmapLayers\n\n  // add and update layers\n  newLayers.forEach((newLayer) => {\n    const layerId = newLayer.id\n    const prevLayer = prevLayersDict[layerId]\n    if (prevLayer === undefined) {\n      // console.log('adding', layerId)\n      dispatch(addHeatmapLayer(newLayer, currentLoadTemporalExtent))\n    } else {\n      if (prevLayer.visible !== newLayer.visible && newLayer.visible === true) {\n        dispatch(loadAllTilesForLayer(layerId))\n      }\n      if (\n        prevLayer.visible !== newLayer.visible ||\n        prevLayer.hue !== newLayer.hue ||\n        prevLayer.opacity !== newLayer.opacity ||\n        prevLayer.filters !== newLayer.filters ||\n        prevLayer.interactive !== newLayer.interactive\n      ) {\n        // console.log('updating', layerId, ' with visibilty', newLayer.visible)\n        dispatch({\n          type: UPDATE_HEATMAP_LAYER_STYLE,\n          payload: {\n            id: newLayer.id,\n            visible: newLayer.visible,\n            hue: newLayer.hue,\n            opacity: newLayer.opacity,\n            filters: newLayer.filters,\n            interactive: newLayer.interactive,\n          },\n        })\n      }\n    }\n  })\n\n  // clean up unused layers\n  Object.keys(prevLayersDict).forEach((prevLayerId) => {\n    if (!newLayers.find((l) => l.id === prevLayerId)) {\n      dispatch(removeHeatmapLayer(prevLayerId))\n    }\n  })\n}\n","import { fitBounds, pixelsToWorld } from 'viewport-mercator-project'\nimport { updateHeatmapTilesFromViewport } from '../heatmap/heatmapTiles.actions'\nimport { onViewportChange } from '../module/module.actions'\nimport { CLUSTER_CLICK_ZOOM_INCREMENT } from '../config' // TODO MAP MODULE\n\nexport const SET_BOUNDS = 'SET_BOUNDS'\nexport const SET_VIEWPORT = 'SET_VIEWPORT'\nexport const UPDATE_VIEWPORT = 'UPDATE_VIEWPORT'\nexport const SET_ZOOM_INCREMENT = 'SET_ZOOM_INCREMENT'\nexport const SET_MOUSE_LAT_LONG = 'SET_MOUSE_LAT_LONG'\nexport const TRANSITION_END = 'TRANSITION_END'\nexport const SET_NATIVE_VIEWPORT = 'SET_NATIVE_VIEWPORT'\n\nexport const setBounds = (bounds) => ({\n  type: SET_BOUNDS,\n  payload: bounds,\n})\n\nexport const setViewport = (viewport, interactionState) => (dispatch) => {\n  dispatch({\n    type: SET_VIEWPORT,\n    payload: viewport,\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  dispatch(onViewportChange(interactionState))\n}\n\nexport const updateViewport = (viewportUpdate) => (dispatch) => {\n  dispatch({\n    type: UPDATE_VIEWPORT,\n    payload: viewportUpdate,\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  // Not needed as call the callback with the same values\n  // dispatch(onViewportChange())\n}\n\nconst transitionTo = (increment, latitude = null, longitude = null, zoom = null) => (dispatch) => {\n  dispatch({\n    type: SET_ZOOM_INCREMENT,\n    payload: {\n      increment,\n      latitude,\n      longitude,\n      zoom,\n    },\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  dispatch(onViewportChange())\n}\n\nexport const transitionToZoom = (viewport) => (dispatch) => {\n  dispatch(transitionTo(null, viewport.center[0], viewport.center[1], viewport.zoom))\n}\n\nexport const transitionEnd = () => (dispatch) => {\n  dispatch({\n    type: TRANSITION_END,\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  dispatch(onViewportChange())\n}\n\nexport const zoomIntoVesselCenter = (latitude, longitude, zoom = null) => (dispatch) => {\n  dispatch(transitionTo(CLUSTER_CLICK_ZOOM_INCREMENT, latitude, longitude, zoom))\n}\n\nexport const fitToBounds = (bounds) => (dispatch, getState) => {\n  const state = getState()\n  const vp = fitBounds({\n    bounds: [[bounds.minLng, bounds.minLat], [bounds.maxLng, bounds.maxLat]],\n    width: state.map.viewport.viewport.width,\n    height: state.map.viewport.viewport.height,\n    padding: 50,\n  })\n  dispatch(transitionTo(null, vp.latitude, vp.longitude, vp.zoom))\n}\n\nexport const exportNativeViewport = (nativeViewport) => (dispatch) => {\n  const topLeftPx = [0, 0]\n  const bottomRightPx = [nativeViewport.width, nativeViewport.height]\n\n  // compute left and right offsets to deal with antimeridian issue\n  const topLeftWorld = pixelsToWorld(topLeftPx, nativeViewport.pixelUnprojectionMatrix)\n  const bottomRightWorld = pixelsToWorld(bottomRightPx, nativeViewport.pixelUnprojectionMatrix)\n  const leftWorldScaled = topLeftWorld[0] / nativeViewport.scale\n  const rightWorldScaled = bottomRightWorld[0] / nativeViewport.scale\n\n  // lat/lon corners for miniglobe\n  const northWest = nativeViewport.unproject(topLeftPx)\n  const southEast = nativeViewport.unproject(bottomRightPx)\n  const bounds = {\n    north: northWest[1],\n    south: southEast[1],\n    west: northWest[0],\n    east: southEast[0],\n  }\n\n  dispatch({\n    type: SET_NATIVE_VIEWPORT,\n    payload: {\n      leftWorldScaled,\n      rightWorldScaled,\n      bounds,\n    },\n  })\n}\n","import area from '@turf/area'\nimport { POLYGON_LAYERS_AREA } from '../constants'\nimport { clearHighlightedVessels, clearHighlightedClickedVessel } from '../heatmap/heatmap.actions'\nimport { zoomIntoVesselCenter } from './viewport.actions'\n\nexport const SET_POPUP = 'SET_POPUP'\nexport const CLEAR_POPUP = 'CLEAR_POPUP'\nexport const SET_MAP_CURSOR = 'SET_MAP_CURSOR'\n\nconst getAreaKm2 = (glFeature) => {\n  const areakm2 = 10 ** -6 * area(glFeature.geometry)\n  const formatted = areakm2.toLocaleString('en-US', { maximumFractionDigits: 0 })\n  return formatted\n}\n\nconst getFields = (glFeature, source = null) => {\n  if (source === null || source === undefined) {\n    // console.warn('Couldnt find source when looking for fields of layer', sourceId)\n  }\n\n  const fieldsDefinition =\n    !source || source.metadata === undefined || source.metadata['gfw:popups'] === undefined\n      ? []\n      : source.metadata['gfw:popups']\n\n  const properties = glFeature.properties\n\n  // whitelist if 'gfw:popups' exist, if not return all\n  const fieldsKeys = Object.keys(glFeature.properties).filter(\n    (k) => fieldsDefinition.length === 0 || fieldsDefinition.find((fd) => fd.id === k) !== undefined\n  )\n\n  const fields = fieldsKeys.map((fieldKey) => {\n    const value = fieldKey === POLYGON_LAYERS_AREA ? getAreaKm2(glFeature) : properties[fieldKey]\n    const def = fieldsDefinition.find((fd) => fd.id === fieldKey) || {}\n    const label = def.label || fieldKey\n    return {\n      id: fieldKey,\n      label,\n      value,\n      title: `${label}: ${value}`,\n      isLink: def.isLink,\n      isMain: def.isMain,\n    }\n  })\n\n  const mainField =\n    fields.find((f) => f.isMain === true) ||\n    fields.find((f) => f.id === 'name') ||\n    fields.find((f) => f.id === 'id') ||\n    fields[0]\n\n  if (mainField !== undefined) {\n    mainField.isMain = true\n  }\n  return fields\n}\n\nconst getCluster = (glFeature, glGetSource) => {\n  const clusterId = glFeature.properties.cluster_id\n  const sourceId = glFeature.source\n  const glSource = glGetSource(sourceId)\n  const promise = new Promise((resolve, reject) => {\n    glSource.getClusterExpansionZoom(clusterId, (err1, zoom) => {\n      glSource.getClusterLeaves(clusterId, 99, 0, (err2, children) => {\n        if (err1 || err2) {\n          reject()\n        }\n        const childrenFeatures = children.map((child) =>\n          getFeature(child, glFeature.layer.id, glSource)\n        )\n        resolve({\n          zoom,\n          childrenFeatures,\n        })\n      })\n    })\n  })\n  return promise\n}\n\nconst getFeature = (glFeature, layerId, source) => {\n  const feature = {\n    properties: glFeature.properties,\n  }\n  const fields = getFields(glFeature, source)\n  feature.fields = fields\n\n  // Get most likely feature title\n  const mainField = fields.find((f) => f.isMain === true)\n  feature.title = mainField === undefined ? layerId : mainField.value\n\n  return feature\n}\n\nexport const mapInteraction = (interactionType, latitude, longitude, glFeatures, glGetSource) => (\n  dispatch,\n  getState\n) => {\n  if (interactionType === 'click') {\n    dispatch(clearHighlightedClickedVessel())\n  }\n\n  const currentStyle = getState().map.style.mapStyle.toJS()\n\n  const event = {\n    latitude,\n    longitude,\n    features: [],\n  }\n\n  // Collect and normalize features on legacy heatmap\n  const currentLegacyHeatmapData = getState().map.heatmap.highlightedVessels\n  let legacyHeatmapFeature\n\n  if (currentLegacyHeatmapData.isEmpty !== true) {\n    const foundVessels =\n      currentLegacyHeatmapData.foundVessels === undefined\n        ? []\n        : currentLegacyHeatmapData.foundVessels\n    const properties = foundVessels.length === 0 ? [] : foundVessels[0]\n    const isCluster = currentLegacyHeatmapData.clickableCluster === true\n    const count =\n      isCluster === true && currentLegacyHeatmapData.highlightableCluster === false\n        ? -1\n        : foundVessels.length\n    legacyHeatmapFeature = {\n      isCluster,\n      count,\n      layer: {\n        id: currentLegacyHeatmapData.layer.id,\n        group: 'legacyHeatmap',\n      },\n      properties,\n    }\n    event.features.push(legacyHeatmapFeature)\n  }\n\n  // Try to retrieve 'gfw:id' (generated when instanciating CARTO layer to preserve original style.json id)\n  // In most cases it won't exist, so fall back to source id\n  const getStaticLayerIdFromGlFeature = (glFeature) =>\n    (glFeature.layer.metadata !== undefined && glFeature.layer.metadata['gfw:id']) ||\n    glFeature.layer.source\n\n  // Collect gl features\n  const clusterPromises = []\n  const allGlFeatures = glFeatures || []\n  allGlFeatures.forEach((glFeature) => {\n    const layerId = getStaticLayerIdFromGlFeature(glFeature)\n    const source = currentStyle.sources[layerId]\n    const feature = {\n      layer: {\n        id: layerId,\n        group: glFeature.layer.metadata && glFeature.layer.metadata['mapbox:group'],\n      },\n      ...getFeature(glFeature, layerId, source),\n    }\n\n    if (glFeature.properties.cluster === true) {\n      // lookup for cluster\n      const clusterPromise = getCluster(glFeature, glGetSource).then((cluster) => {\n        feature.cluster = cluster\n        feature.count = cluster.childrenFeatures.length\n      })\n      clusterPromises.push(clusterPromise)\n      feature.isCluster = true\n    } else {\n      feature.isCluster = false\n    }\n    event.features.push(feature)\n  })\n\n  Promise.all(clusterPromises).then(() => {\n    // The whole set of features is considered a cluster\n    // if any feature is a cluster, or there is more than one feature\n    event.isCluster =\n      event.features.length > 1 || event.features.some((feature) => feature.isCluster === true)\n\n    // legacy heatmap layers can yield clusters with an unknown number of features, handle this here:\n    if (legacyHeatmapFeature !== undefined && legacyHeatmapFeature.count === -1) {\n      event.count = -1\n    } else {\n      event.count = event.features.reduce((count, feature) => {\n        let featureCount = feature.count || 1\n        return count + featureCount\n      }, 0)\n    }\n\n    if (event.count === 1) {\n      event.feature = event.features[0]\n    }\n\n    // When autoClusterZoom is set to true, we handle zoom here\n    const autoClusterZoom = getState().map.module.autoClusterZoom === true\n\n    // Check if cluster using customizable isCluster() callback\n    // If not set resolves simply to (event) => event.isCluster === true\n    const clusterBehavior = getState().map.module.isCluster(event)\n    event.isCluster = clusterBehavior\n\n    if (autoClusterZoom) {\n      if (interactionType === 'click' && event.isCluster === true) {\n        dispatch(clearHighlightedVessels())\n        const clusterZoom = event.features[0].cluster && event.features[0].cluster.zoom\n        dispatch(zoomIntoVesselCenter(latitude, longitude, clusterZoom))\n      }\n    }\n\n    let cursor = event.features.length ? 'pointer' : null\n    if (event.isCluster === true) {\n      cursor = 'zoom-in'\n    }\n\n    dispatch({\n      type: SET_MAP_CURSOR,\n      payload: cursor,\n    })\n\n    const callback =\n      interactionType === 'click' ? getState().map.module.onClick : getState().map.module.onHover\n\n    if (callback !== undefined) {\n      callback(event)\n    }\n  })\n}\n","const RGB_MAX = 255\nconst HUE_MAX = 360\nconst SV_MAX = 100\n\nexport const VESSELS_HUES_INCREMENTS_NUM = 31 // 360 / VESSELS_HUES_INCREMENTS_NUM - 1  should give a round number\nexport const VESSELS_HUES_INCREMENT = 360 / (VESSELS_HUES_INCREMENTS_NUM - 1)\n\n// Legacy: this is only here for compatibility with pre-mapbox branch workspaces\nexport const COLOR_HUES = {\n  orange: 0,\n  peach: 22,\n  yellow: 60,\n  green: 85,\n  brightGreen: 145,\n  lightBlue: 182,\n  blue: 236,\n  purple: 284,\n  pink: 312,\n}\n\n// FIXME mark explicitely as legacy. Check all usages.\nexport const getKeyByValue = (obj, value) => {\n  let result = null\n  Object.entries(obj).forEach((entry) => {\n    if (entry[1] === value) result = entry[0]\n  })\n  return result\n}\n\n/**\n * Converts an RGB color value to HSV. Conversion formula\n * adapted from http://en.wikipedia.org/wiki/HSV_color_space.\n * Assumes r, g, and b are contained in the set [0, 255] and\n * returns h, s, and v in the set [0, 1].\n *\n * @param   Number  r       The red color value\n * @param   Number  g       The green color value\n * @param   Number  b       The blue color value\n * @return  Array           The HSV representation\n */\nexport const rgbToHsv = (_r, _g, _b) => {\n  const r = _r / 255\n  const g = _g / 255\n  const b = _b / 255\n\n  const max = Math.max(r, g, b)\n  const min = Math.min(r, g, b)\n  let h\n  const v = max\n\n  const d = max - min\n  const s = max === 0 ? 0 : d / max\n\n  if (max === min) {\n    h = 0 // achromatic\n  } else {\n    switch (max) {\n      case r:\n        h = (g - b) / d + (g < b ? 6 : 0)\n        break\n      case g:\n        h = (b - r) / d + 2\n        break\n      case b:\n        h = (r - g) / d + 4\n        break\n      default:\n        h = 0\n    }\n\n    h /= 6\n  }\n\n  return [h, s, v]\n}\n\n// converts hue, saturation, luminance to an rgb object\nexport const hsvToRgb = (h_, s_, v_) => {\n  const h = ((h_ % HUE_MAX) / parseFloat(HUE_MAX)) * 6\n  const s = s_ === SV_MAX ? 1 : (s_ % SV_MAX) / parseFloat(SV_MAX)\n  const v = v_ === SV_MAX ? 1 : (v_ % SV_MAX) / parseFloat(SV_MAX)\n\n  const i = Math.floor(h)\n  const f = h - i\n  const p = v * (1 - s)\n  const q = v * (1 - f * s)\n  const t = v * (1 - (1 - f) * s)\n  const mod = i % 6\n  const r = [v, q, p, p, t, v][mod]\n  const g = [t, v, v, q, p, p][mod]\n  const b = [p, p, t, v, v, q][mod]\n\n  return { r: Math.round(r * RGB_MAX), g: Math.round(g * RGB_MAX), b: Math.round(b * RGB_MAX) }\n}\n\n// returns an rgb string with default saturation and luminance values\nconst hueToRgbDefaults = (hue) => hsvToRgb(hue, 50, 100)\n\nexport const hueToRgbString = (hue) => {\n  const rgb = hueToRgbDefaults(hue)\n  return `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`\n}\n\nexport const rgbToHexString = (rgb, css) => {\n  const str = ['r', 'g', 'b']\n    .map((channelName) => {\n      const channelValue = rgb[channelName]\n      let channelStr = channelValue.toString(16)\n      if (channelValue < 16) {\n        channelStr = `0${channelStr}`\n      }\n      return channelStr\n    })\n    .join('')\n  const prefix = css === true ? '#' : '0x'\n  return `${prefix}${str}`\n}\n\nexport const hueToRgbHexString = (hue, css) => {\n  const rgb = hueToRgbDefaults(hue)\n  return rgbToHexString(rgb, css)\n}\n\nconst closestNumber = (numberArray, goal) =>\n  numberArray.reduce((prev, curr) => (Math.abs(curr - goal) < Math.abs(prev - goal) ? curr : prev))\n\nexport const hueToClosestColor = (hue) => {\n  if (hue === undefined || hue === null) return undefined\n  const colorHueValues = Object.keys(COLOR_HUES).map((key) => COLOR_HUES[key])\n  const closestHue = closestNumber(colorHueValues, hue)\n  return getKeyByValue(COLOR_HUES, closestHue)\n}\n\nexport const hexToRgb = (hex) => {\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex)\n  return result\n    ? {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16),\n      }\n    : null\n}\n\nconst rgbToRgbaString = (rgb, opacity) => `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`\n\nexport const hueToRgbaString = (hue, opacity) => {\n  const rgb = hueToRgbDefaults(hue)\n  return rgbToRgbaString(rgb, opacity)\n}\n\nexport const hexToRgba = (hex, opacity) => {\n  const rgb = hexToRgb(hex)\n  return rgbToRgbaString(rgb, opacity)\n}\n\nexport const hueIncrementToHue = (hueIncrement) => hueIncrement * VESSELS_HUES_INCREMENT\n\nexport const hueToHueIncrement = (hue) =>\n  Math.round((hue / 360) * (VESSELS_HUES_INCREMENTS_NUM - 1))\n\nexport const wrapHue = (hue) => hue % 360\n\nexport const hueOrColorToHexColor = (color, hue) => {\n  if (hue !== undefined) {\n    return hueToRgbHexString(hue, true)\n  }\n\n  return color\n}\n","/* global PIXI */\nimport 'pixi.js'\nimport { hueToHueIncrement, VESSELS_HUES_INCREMENTS_NUM } from '../utils/map-colors'\nimport { VESSELS_BASE_RADIUS, MAX_SPRITES_PER_LAYER } from '../config'\n\nexport default class HeatmapSubLayer {\n  constructor(baseTexture, renderingStyleIndex, hue, useNormalBlendMode = false) {\n    // this.stage = new PIXI.Container();\n    // the ParticleContainer is a faster version of the PIXI sprite container\n    this.stage = new PIXI.particles.ParticleContainer(MAX_SPRITES_PER_LAYER, {\n      scale: true,\n      alpha: true,\n      position: true,\n      uvs: true,\n    })\n    if (useNormalBlendMode === false) {\n      this.stage.blendMode = PIXI.BLEND_MODES.SCREEN\n    }\n\n    this.spritesPool = []\n\n    const initialTextureFrame = new PIXI.Rectangle(\n      0,\n      0,\n      VESSELS_BASE_RADIUS * 2,\n      VESSELS_BASE_RADIUS * 2\n    )\n    this.mainVesselTexture = new PIXI.Texture(baseTexture, initialTextureFrame)\n    this._setTextureFrame(renderingStyleIndex, hue)\n\n    this.clearSpriteProps()\n  }\n\n  clearSpriteProps() {\n    this.spritesProps = {\n      x: new Float32Array(MAX_SPRITES_PER_LAYER),\n      y: new Float32Array(MAX_SPRITES_PER_LAYER),\n      a: new Float32Array(MAX_SPRITES_PER_LAYER),\n      s: new Float32Array(MAX_SPRITES_PER_LAYER),\n    }\n    this.spritesPropsCount = 0\n  }\n\n  pushSpriteProps(x, y, a, s) {\n    this.spritesProps.x[this.spritesPropsCount] = x\n    this.spritesProps.y[this.spritesPropsCount] = y\n    this.spritesProps.a[this.spritesPropsCount] = a\n    this.spritesProps.s[this.spritesPropsCount] = s\n    this.spritesPropsCount++\n  }\n\n  setRenderingStyleIndex(renderingStyleIndex) {\n    this._setTextureFrame(renderingStyleIndex)\n  }\n\n  destroy() {\n    this.spritesPool = null\n    this.stage.destroy({ children: true })\n  }\n\n  /**\n   * Updates the main texture frame offset to show different brush styles and hues\n   * Both args are optional, if one is omitted, previous value is used\n   * @heatmapStyle bool whether to use heatmap style or solid circle style\n   * @hue number hue value between 0 and 360\n   */\n  _setTextureFrame(renderingStyleIndex = null, hue = null) {\n    const textureFrame = this.mainVesselTexture.frame.clone()\n\n    if (renderingStyleIndex !== null) {\n      // one diameter + tiny offset between 2 frames\n      textureFrame.x = VESSELS_BASE_RADIUS * 2 * renderingStyleIndex + renderingStyleIndex\n    }\n\n    if (hue !== null) {\n      let hueIncrement = hueToHueIncrement(hue)\n      if (hueIncrement === VESSELS_HUES_INCREMENTS_NUM - 1) {\n        hueIncrement = 0\n      }\n      textureFrame.y = hueIncrement * VESSELS_BASE_RADIUS * 2\n      if (hueIncrement > 0) {\n        textureFrame.y += hueIncrement\n      }\n    }\n\n    this.mainVesselTexture.frame = textureFrame\n    this.mainVesselTexture.update()\n  }\n\n  render() {\n    const numProps = this.spritesPropsCount\n    this.resizeSpritesPool()\n\n    for (let i = 0; i < numProps; i++) {\n      const sprite = this.stage.children[i]\n      const s = this.spritesProps.s[i]\n      sprite.setTransform(this.spritesProps.x[i], this.spritesProps.y[i], s, s)\n      sprite.alpha = this.spritesProps.a[i]\n    }\n\n    const numSprites = this.stage.children.length\n    for (let i = numProps; i < numSprites; i++) {\n      const sprite = this.stage.children[i]\n      sprite.x = -100\n    }\n  }\n\n  resizeSpritesPool() {\n    const numProps = this.spritesPropsCount\n    const prevNumSprites = this.stage.children.length\n    const delta = numProps - prevNumSprites\n    // console.log(prevNumSprites, '->', numProps, ' delta:', delta);\n\n    if (delta < -4999) {\n      // sprite needs to be removed. Do that progressively (max 100) to avoid UI lock\n      const toRemove = Math.min(100, -delta)\n      // console.log('removing ', toRemove);\n      for (let i = 0; i < toRemove; i++) {\n        this.stage.removeChildAt(0)\n      }\n    }\n\n    if (delta > 0) {\n      const toAdd = Math.max(5000, delta)\n      // console.log('adding ', toAdd);\n      this._addSprites(toAdd)\n    }\n  }\n\n  _addSprites(num) {\n    for (let i = 0; i < num; i++) {\n      const vessel = new PIXI.Sprite(this.mainVesselTexture)\n      vessel.anchor.x = 0.5\n      vessel.anchor.y = 0.5\n      // ParticlesContainer does not support .visible, so we just move the sprite out of the viewport\n      vessel.x = -100\n      // vessel.blendMode = PIXI.BLEND_MODES.SCREEN;\n      // vessel.filters=  [new PIXI.filters.BlurFilter(10,10)]\n      this.stage.addChild(vessel)\n    }\n  }\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport uniq from 'lodash/uniq'\nimport * as PIXI from 'pixi.js'\nimport { worldToPixels } from 'viewport-mercator-project'\nimport { BRUSH_RENDERING_STYLE, BRUSH_ZOOM_RENDERING_STYLE } from '../constants'\nimport { vesselSatisfiesFilters } from '../utils/heatmapTileData'\nimport HeatmapSubLayer from './HeatmapSubLayer'\n\n// This is a faster version of worldToPixels that omits pitch,\n// and ignores values from the matrix that are consistently = 0\nconst s = 1 / 1.5\nconst worldToPixelsSimple = (x, y, m) => {\n  const fx = s * (m[0] * x + m[4] * y + m[12])\n  const fy = s * (m[5] * y + m[13])\n  return [fx, fy]\n}\n\nclass HeatmapLayer extends React.Component {\n  componentDidMount() {\n    this._build()\n  }\n\n  componentWillUnmount() {\n    this._destroy()\n  }\n\n  componentDidUpdate() {\n    this._redraw()\n  }\n\n  UNSAFE_componentWillReceiveProps(nextProps) {\n    if (nextProps.useRadialGradientStyle !== this.props.useRadialGradientStyle) {\n      this.setBrushZoomRenderingStyle(nextProps.useRadialGradientStyle)\n    }\n  }\n\n  _build() {\n    const { layer, rootStage, useRadialGradientStyle, customRenderingStyle } = this.props\n    this.subLayers = {}\n    this.renderingStyle =\n      layer.header && layer.header.rendering ? layer.header.rendering : customRenderingStyle\n\n    this.setBrushRenderingStyle(this.renderingStyle.style)\n    this.setBrushZoomRenderingStyle(useRadialGradientStyle)\n\n    this.stage = new PIXI.Container()\n\n    rootStage.addChild(this.stage)\n  }\n\n  setBrushRenderingStyle(style = BRUSH_RENDERING_STYLE.NORMAL) {\n    if (typeof style === 'string') {\n      this.brushRenderingStyle = BRUSH_RENDERING_STYLE[style.toUpperCase()]\n    } else {\n      this.brushRenderingStyle = style\n    }\n    this._setBrushRenderingStyleIndex()\n  }\n\n  setBrushZoomRenderingStyle(useRadialGradientStyle) {\n    this.brushZoomRenderingStyle =\n      useRadialGradientStyle === true\n        ? BRUSH_ZOOM_RENDERING_STYLE.RADIAL_GRADIENT\n        : BRUSH_ZOOM_RENDERING_STYLE.CIRCLE\n    this._setBrushRenderingStyleIndex()\n  }\n\n  _setBrushRenderingStyleIndex() {\n    // only NORMAL brush styles support different zoom styles\n    const cappedZoomRenderingStyle =\n      this.brushRenderingStyle === BRUSH_RENDERING_STYLE.NORMAL ? this.brushZoomRenderingStyle : 0\n    const newStyleIndex = this.brushRenderingStyle + cappedZoomRenderingStyle\n    if (newStyleIndex === this.renderingStyleIndex) {\n      return\n    }\n    this.renderingStyleIndex = newStyleIndex\n    Object.values(this.subLayers).forEach((subLayer) => {\n      subLayer.setRenderingStyleIndex(this.renderingStyleIndex)\n    })\n  }\n\n  _redraw() {\n    const { filters, baseTexture, layer } = this.props\n\n    if (\n      layer === null ||\n      layer === undefined ||\n      layer.tiles === undefined ||\n      layer.visible === false\n    ) {\n      this.stage.visible = false\n      return\n    }\n\n    this.stage.visible = true\n    this.stage.alpha = layer.opacity\n\n    const tiles = layer.tiles\n    const defaultHue = layer.hue\n    const allHuesToRender =\n      filters !== undefined && filters.length\n        ? filters\n            // pass is set to true by filterGroupActions when none of the filters fields\n            // in the filter group is supported by the layer headers\n            .filter((f) => f.pass !== true)\n            .map((f) => (f.hue === undefined ? '0' : f.hue.toString()))\n        : [defaultHue.toString()]\n    const currentlyUsedHues = Object.keys(this.subLayers)\n\n    // get all hues, old and new\n    const allHues = uniq(allHuesToRender.concat(currentlyUsedHues))\n\n    for (let i = 0; i < allHues.length; i++) {\n      const hue = allHues[i]\n      if (allHuesToRender.indexOf(hue) === -1) {\n        // not on new hues: delete sublayer\n        this._destroySubLayer(this.subLayers[hue])\n        delete this.subLayers[hue]\n        continue\n      }\n      if (currentlyUsedHues.indexOf(hue) === -1) {\n        // not on old hues: create sublayer\n        this.subLayers[hue] = this._createSublayer(baseTexture, this.renderingStyleIndex, hue)\n      }\n      this.subLayers[hue].clearSpriteProps()\n    }\n\n    if (!allHuesToRender.length) return\n    tiles.forEach((tile) => {\n      this._setSubLayersSpritePropsForTile({\n        data: tile.data,\n        numFilters: filters.length,\n        defaultHue,\n      })\n    })\n\n    allHuesToRender.forEach((hueToRender) => {\n      this.subLayers[hueToRender].render()\n    })\n  }\n\n  _setSubLayersSpritePropsForTile({ data, numFilters, defaultHue }) {\n    if (!data) {\n      return\n    }\n\n    const { startIndex, endIndex, viewport, filters, viewportLeft, viewportRight } = this.props\n\n    for (let timeIndex = startIndex; timeIndex < endIndex; timeIndex++) {\n      const frame = data[timeIndex]\n\n      if (!frame) continue\n\n      for (let index = 0, len = frame.worldX.length; index < len; index++) {\n        let hue\n        if (filters === undefined || !filters.length) {\n          hue = defaultHue\n        }\n        for (let fi = 0; fi < numFilters; fi++) {\n          const filter = filters[fi]\n          if (vesselSatisfiesFilters(frame, index, filter.filterValues)) {\n            hue = filter.hue\n            break\n          }\n        }\n\n        // no filter passes: bail\n        if (hue === undefined) {\n          continue\n        }\n\n        // wrap worldX when point crosses the antimeridian/dateline\n        // world points go from 0 to 512. There is no way to determine if worldX is on the \"wrong\" side\n        // of the antimeridian just by looking at its value (where with lat/lon we can simply look at -/+)\n        // Therefore we compare it to the viewport's left or right boundary, depending on what is currently\n        // \"the right side\" of the antimeridian\n        let worldX = frame.worldX[index]\n        if (viewportLeft > 0 && worldX < viewportLeft) {\n          // worldX is \"behind\" viewportLeft, which means it is \"on the right\" of the antimeridian\n          worldX += 512\n        } else if (viewportLeft < 0 && worldX > viewportRight) {\n          worldX -= 512\n        }\n\n        const scaledX = worldX * viewport.scale\n        const scaledY = frame.worldY[index] * viewport.scale\n        const mtx = viewport.pixelProjectionMatrix\n\n        const [x, y] =\n          viewport.pitch === 0\n            ? worldToPixelsSimple(scaledX, scaledY, mtx)\n            : worldToPixels([scaledX, scaledY], mtx)\n\n        if (x > -10 && x < viewport.width + 10 && y > -10 && y < viewport.height + 10) {\n          this.subLayers[hue].pushSpriteProps(\n            x,\n            y,\n            frame.opacity ? frame.opacity[index] : this.renderingStyle.defaultOpacity,\n            frame.radius ? frame.radius[index] : this.renderingStyle.defaultSize\n          )\n        }\n      }\n    }\n  }\n\n  _createSublayer(baseTexture, renderingStyleIndex, hue) {\n    const subLayer = new HeatmapSubLayer(\n      baseTexture,\n      renderingStyleIndex,\n      hue,\n      this.brushRenderingStyle === BRUSH_RENDERING_STYLE.BULLSEYE\n    )\n    this.stage.addChild(subLayer.stage)\n    return subLayer\n  }\n\n  _destroy() {\n    Object.values(this.subLayers).forEach(this._destroySubLayer.bind(this))\n    this.stage.destroy({ children: true })\n    const { rootStage } = this.props\n    rootStage.removeChild(this.stage)\n  }\n\n  _destroySubLayer(subLayer) {\n    this.stage.removeChild(subLayer.stage)\n    subLayer.destroy()\n  }\n\n  render() {\n    return null\n  }\n}\n\nHeatmapLayer.propTypes = {\n  layer: PropTypes.object,\n  rootStage: PropTypes.object,\n  viewport: PropTypes.object,\n  startIndex: PropTypes.number,\n  endIndex: PropTypes.number,\n  filters: PropTypes.array,\n  baseTexture: PropTypes.object,\n  useRadialGradientStyle: PropTypes.bool,\n  customRenderingStyle: PropTypes.object,\n  viewportLeft: PropTypes.number,\n  viewportRight: PropTypes.number,\n}\n\nexport default HeatmapLayer\n","import React, { Fragment } from 'react'\nimport * as PIXI from 'pixi.js'\nimport PropTypes from 'prop-types'\nimport { BaseControl } from 'react-map-gl'\nimport { lngLatToWorld } from 'viewport-mercator-project'\nimport {\n  hsvToRgb,\n  hueToRgbString,\n  hueIncrementToHue,\n  wrapHue,\n  VESSELS_HUES_INCREMENTS_NUM,\n} from '../utils/map-colors'\nimport {\n  VESSELS_BASE_RADIUS,\n  VESSELS_HEATMAP_BLUR_FACTOR,\n  ACTIVITY_HIGHLIGHT_HUE,\n  VESSELS_HEATMAP_DIMMING_ALPHA,\n  VESSELS_RADIAL_GRADIENT_STYLE_ZOOM_THRESHOLD,\n  VESSEL_CLICK_TOLERANCE_PX,\n} from '../config'\nimport HeatmapLayer from '../heatmap/HeatmapLayer'\n\nconst shouldUseRadialGradientStyle = (zoom) => zoom < VESSELS_RADIAL_GRADIENT_STYLE_ZOOM_THRESHOLD\n\n// builds a texture spritesheet containing\n// - the heatmap style (radial gradient)\n// - the circle style that is used at higher zoom levels\n// - the 'bullseye' style used for encounters\n// as well as a number of hues for each in a 2D grid.\n// Then, only the texture frame (mesh UVs) is modified depending on the zoom level,\n// in order not to have to recreate sprites\nconst getVesselTexture = (radius, blurFactor) => {\n  const tplCanvas = document.createElement('canvas')\n  const tplCtx = tplCanvas.getContext('2d')\n  const diameter = radius * 2\n  const NUM_STYLES = 3\n  tplCanvas.width = diameter * NUM_STYLES + (NUM_STYLES - 1) // + (NUM_STYLES - 1): tiny offset between 2 frames\n  tplCanvas.height = diameter * VESSELS_HUES_INCREMENTS_NUM + VESSELS_HUES_INCREMENTS_NUM\n\n  for (let hueIncrement = 0; hueIncrement < VESSELS_HUES_INCREMENTS_NUM; hueIncrement++) {\n    const y = diameter * hueIncrement + hueIncrement\n    const yCenter = y + radius\n\n    // heatmap style\n    let x = radius\n    const gradient = tplCtx.createRadialGradient(\n      x,\n      yCenter,\n      radius * blurFactor,\n      x,\n      yCenter,\n      radius\n    )\n    const hue = hueIncrementToHue(hueIncrement)\n    const rgbString = hueToRgbString(hue)\n    gradient.addColorStop(0, rgbString)\n\n    const rgbOuter = hsvToRgb(wrapHue(hue + 30), 80, 100)\n    gradient.addColorStop(1, `rgba(${rgbOuter.r}, ${rgbOuter.g}, ${rgbOuter.b}, 0)`)\n\n    tplCtx.fillStyle = gradient\n    tplCtx.fillRect(0, y, diameter, diameter)\n\n    // circle style\n    x += diameter + 1 // tiny offset between 2 frames\n    tplCtx.beginPath()\n    tplCtx.arc(x, yCenter, radius, 0, 2 * Math.PI, false)\n    tplCtx.fillStyle = rgbString\n    tplCtx.fill()\n\n    // bullseye style\n    x += diameter + 1\n    tplCtx.beginPath()\n    tplCtx.arc(x, yCenter, radius * 0.4, 0, 2 * Math.PI, false)\n    tplCtx.fillStyle = rgbString\n    tplCtx.fill()\n    tplCtx.beginPath()\n    tplCtx.arc(x, yCenter, radius * 0.95, 0, 2 * Math.PI, false)\n    tplCtx.lineWidth = 1\n    tplCtx.strokeStyle = rgbString\n    tplCtx.stroke()\n  }\n\n  return tplCanvas\n}\n\nclass ActivityLayers extends BaseControl {\n  state = {\n    pixiReady: false,\n  }\n\n  componentDidMount() {\n    this._build()\n    this.setState({\n      pixiReady: true,\n    })\n  }\n\n  componentWillUnmount() {\n    this._destroy()\n  }\n\n  UNSAFE_componentWillReceiveProps(nextProps) {\n    this.props.exportNativeViewport(this._context.viewport)\n\n    if (\n      nextProps.viewport.width !== this.props.viewport.width ||\n      nextProps.viewport.height !== this.props.viewport.height\n    ) {\n      this._updateViewportSize(nextProps.viewport.width, nextProps.viewport.height)\n    }\n  }\n\n  _build() {\n    const { width, height } = this.props.viewport\n\n    this.pixi = new PIXI.Application({\n      width,\n      height,\n      transparent: true,\n      antialias: true,\n    })\n\n    this.renderer = this.pixi.renderer\n    this.canvas = this.pixi.view\n    this.canvas.style.position = 'absolute'\n\n    this.container.appendChild(this.canvas)\n\n    this.stage = this.pixi.stage\n\n    const baseTextureCanvas = getVesselTexture(VESSELS_BASE_RADIUS, VESSELS_HEATMAP_BLUR_FACTOR)\n    this.baseTexture = PIXI.Texture.fromCanvas(baseTextureCanvas)\n\n    this.heatmapStage = new PIXI.Container()\n    this.stage.addChild(this.heatmapStage)\n\n    this.pixi.ticker.add(this._onTick)\n  }\n\n  _destroy() {\n    this.pixi.destroy()\n  }\n\n  _updateViewportSize(viewportWidth, viewportHeight) {\n    this.renderer.resize(viewportWidth, viewportHeight)\n  }\n\n  toggleHeatmapDimming(dim) {\n    if (this.heatmapStage === undefined) {\n      return\n    }\n    if (dim === true) {\n      this.heatmapFadingIn = false\n    }\n    this.heatmapStage.alpha = dim === true ? VESSELS_HEATMAP_DIMMING_ALPHA : 1\n  }\n\n  onTouchStart = (event) => {\n    if (!event.touches.length) {\n      return\n    }\n    this.queryCoords(event.touches[0].clientX, event.touches[0].clientY)\n  }\n\n  onMouseMove = (event) => {\n    this.queryCoords(event.clientX, event.clientY)\n  }\n\n  queryCoords(x, y) {\n    // bail if all heatmap layers are set to non-interactive\n    if (this.props.heatmapLayers.every((l) => l.interactive !== true)) {\n      return\n    }\n\n    const { viewport } = this._context\n    const [longitude, latitude] = viewport.unproject([x, y])\n\n    let wrappedLongitude = longitude\n    if (wrappedLongitude > 180) {\n      wrappedLongitude -= 360\n    } else if (wrappedLongitude < -180) {\n      wrappedLongitude += 360\n    }\n\n    const [worldX, worldY] = lngLatToWorld([wrappedLongitude, latitude], 1)\n\n    const toleranceRadiusInWorldUnits = VESSEL_CLICK_TOLERANCE_PX / viewport.scale\n\n    this.props.queryHeatmapVessels(\n      {\n        longitude: wrappedLongitude,\n        latitude,\n        worldX,\n        worldY,\n        toleranceRadiusInWorldUnits,\n      },\n      this.props.temporalExtentIndexes\n    )\n  }\n\n  _onTick = () => {\n    if (this.heatmapFadingIn === true && this.heatmapStage.alpha < 1) {\n      this._heatmapFadeinStep()\n    }\n  }\n\n  _startHeatmapFadein() {\n    this.heatmapFadingIn = true\n    this.heatmapFadeinStartTimestamp = undefined\n  }\n\n  _heatmapFadeinStep() {\n    if (this.heatmapFadeinStartTimestamp === undefined) {\n      this.heatmapFadeinStartTimestamp = Date.now()\n    }\n    const timeElapsed = (Date.now() - this.heatmapFadeinStartTimestamp) / 1000\n    let alpha = this.heatmapStage.alpha + (1 - this.heatmapStage.alpha) * timeElapsed\n    if (alpha >= 1) {\n      alpha = 1\n      this.heatmapFadingIn = false\n    }\n    this.heatmapStage.alpha = alpha\n  }\n\n  // FIXME move to container?\n  _getHighlightData(highlightedVessels, highlightedClickedVessel, heatmapLayers) {\n    const hue = ACTIVITY_HIGHLIGHT_HUE\n    let highlightLayerData = {\n      id: '__HIGHLIGHT__',\n      visible: true,\n      opacity: 1,\n      hue: ACTIVITY_HIGHLIGHT_HUE,\n    }\n    let highlightFilters = []\n\n    if (\n      highlightedVessels !== undefined &&\n      highlightedVessels.layer !== undefined &&\n      highlightedVessels.foundVessels !== undefined &&\n      highlightedVessels.isEmpty !== true\n    ) {\n      const sourceLayer = heatmapLayers.find((l) => l.id === highlightedVessels.layer.id)\n      highlightLayerData = { highlightLayerData, ...sourceLayer }\n      highlightFilters = highlightedVessels.foundVessels.map((vessel) => ({\n        hue,\n        filterValues: {\n          series: [vessel.series],\n        },\n      }))\n    } else if (highlightedClickedVessel !== null) {\n      const sourceLayer = heatmapLayers.find((l) => l.id === highlightedClickedVessel.layer.id)\n      highlightLayerData = { highlightLayerData, ...sourceLayer }\n      highlightFilters = [\n        {\n          hue,\n          filterValues: {\n            series: [highlightedClickedVessel.id],\n          },\n        },\n      ]\n    }\n    return {\n      highlightLayerData,\n      highlightFilters,\n    }\n  }\n  _render() {\n    const {\n      zoom,\n      heatmapLayers,\n      temporalExtentIndexes,\n      highlightedVessels,\n      highlightedClickedVessel,\n      leftWorldScaled,\n      rightWorldScaled,\n    } = this.props\n    const { viewport } = this._context\n    const { pixiReady } = this.state\n\n    const startIndex = temporalExtentIndexes[0]\n    const endIndex = temporalExtentIndexes[1]\n    const useRadialGradientStyle = shouldUseRadialGradientStyle(zoom)\n\n    if (highlightedVessels.isEmpty !== true) {\n      this.toggleHeatmapDimming(true)\n    }\n    if (highlightedVessels.isEmpty === true) {\n      this._startHeatmapFadein()\n    }\n    if (this.renderer && this.renderer.gl && this.renderer.gl.getError !== undefined) {\n      const err = this.renderer.gl.getError()\n      if (err !== 0) console.log(err)\n    }\n\n    const { highlightLayerData, highlightFilters } = this._getHighlightData(\n      highlightedVessels,\n      highlightedClickedVessel,\n      heatmapLayers\n    )\n\n    return (\n      <div\n        ref={(ref) => {\n          this.container = ref\n        }}\n        style={{ position: 'absolute' }}\n        onMouseMove={this.onMouseMove}\n        onTouchStart={this.onTouchStart}\n      >\n        {pixiReady === true && (\n          <Fragment>\n            {heatmapLayers.map((layer) => (\n              <HeatmapLayer\n                key={layer.id}\n                layer={layer}\n                filters={layer.filters || []}\n                viewport={viewport}\n                startIndex={startIndex}\n                endIndex={endIndex}\n                baseTexture={this.baseTexture}\n                rootStage={this.heatmapStage}\n                useRadialGradientStyle={useRadialGradientStyle}\n                customRenderingStyle={{}}\n                viewportLeft={leftWorldScaled}\n                viewportRight={rightWorldScaled}\n              />\n            ))}\n            {this.stage !== undefined && (\n              <HeatmapLayer\n                key=\"highlighted\"\n                layer={highlightLayerData}\n                filters={highlightFilters}\n                viewport={viewport}\n                startIndex={startIndex}\n                endIndex={endIndex}\n                baseTexture={this.baseTexture}\n                rootStage={this.heatmapStage}\n                useRadialGradientStyle={useRadialGradientStyle}\n                customRenderingStyle={{ defaultOpacity: 1, defaultSize: 1 }}\n                viewportLeft={leftWorldScaled}\n                viewportRight={rightWorldScaled}\n              />\n            )}\n          </Fragment>\n        )}\n      </div>\n    )\n  }\n}\n\nActivityLayers.propTypes = {\n  zoom: PropTypes.number,\n  heatmapLayers: PropTypes.array,\n  temporalExtentIndexes: PropTypes.array,\n  highlightedVessels: PropTypes.object,\n  highlightedClickedVessel: PropTypes.object,\n  queryHeatmapVessels: PropTypes.func,\n  exportNativeViewport: PropTypes.func,\n  leftWorldScaled: PropTypes.number,\n  rightWorldScaled: PropTypes.number,\n}\n\nActivityLayers.contextTypes = {\n  viewport: PropTypes.object,\n}\n\nexport default ActivityLayers\n","import { connect } from 'react-redux'\nimport { createSelector } from 'reselect'\nimport convert from '@globalfishingwatch/map-convert'\nimport { exportNativeViewport } from '../glmap/viewport.actions'\nimport { getTemporalExtent } from '../module/module.selectors'\nimport ActivityLayers from './ActivityLayers'\nimport { queryHeatmapVessels } from '../heatmap/heatmapTiles.actions'\nimport { MIN_FRAME_LENGTH_MS } from '../config'\n\nconst getHeatmapLayers = (state) => state.map.heatmap.heatmapLayers\n\nconst getHeatmapLayersAsArray = createSelector(\n  [getHeatmapLayers],\n  (heatmapLayers) => {\n    const a = Object.keys(heatmapLayers).map((id) => ({\n      ...heatmapLayers[id],\n    }))\n    // console.log(a)\n    return a\n  }\n)\n\nconst getTemporalExtentIndexes = createSelector(\n  [getTemporalExtent],\n  (temporalExtent) => {\n    const startTimestamp = temporalExtent[0].getTime()\n    const endTimestamp = Math.max(\n      temporalExtent[1].getTime(),\n      temporalExtent[0].getTime() + MIN_FRAME_LENGTH_MS\n    )\n    const startIndex = convert.getOffsetedTimeAtPrecision(startTimestamp)\n    const endIndex = convert.getOffsetedTimeAtPrecision(endTimestamp)\n    return [startIndex, endIndex]\n  }\n)\n\nconst mapStateToProps = (state) => ({\n  highlightedVessels: state.map.heatmap.highlightedVessels,\n  highlightedClickedVessel: state.map.heatmap.highlightedClickedVessel,\n  viewport: state.map.viewport.viewport,\n  zoom: state.map.viewport.viewport.zoom,\n  heatmapLayers: getHeatmapLayersAsArray(state),\n  leftWorldScaled: state.map.viewport.leftWorldScaled,\n  rightWorldScaled: state.map.viewport.rightWorldScaled,\n  temporalExtentIndexes: getTemporalExtentIndexes(state),\n})\n\nconst mapDispatchToProps = (dispatch, ownProps) => ({\n  queryHeatmapVessels: (coords, temporalExtentIndexes) => {\n    dispatch(queryHeatmapVessels(coords, temporalExtentIndexes))\n  },\n  exportNativeViewport: (viewport) => {\n    dispatch(exportNativeViewport(viewport))\n  },\n})\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(ActivityLayers)\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport MapGL, { Popup, Marker } from 'react-map-gl'\nimport 'mapbox-gl/dist/mapbox-gl.css'\nimport { TILES_URL_NEEDING_AUTHENTICATION } from '../config'\nimport ActivityLayers from '../activity/ActivityLayers.container.js'\nimport styles from './map.css'\n\nconst PopupWrapper = (props) => {\n  const { latitude, longitude, children, closeButton, onClose } = props\n  return (\n    <Popup\n      latitude={latitude}\n      longitude={longitude}\n      closeButton={closeButton}\n      onClose={onClose}\n      anchor=\"bottom\"\n      offsetTop={-10}\n      tipSize={4}\n      closeOnClick={false}\n    >\n      {children}\n    </Popup>\n  )\n}\n\nPopupWrapper.propTypes = {\n  latitude: PropTypes.number.isRequired,\n  longitude: PropTypes.number.isRequired,\n  children: PropTypes.node.isRequired,\n  closeButton: PropTypes.bool.isRequired,\n  onClose: PropTypes.func,\n}\n\nPopupWrapper.defaultProps = {\n  onClose: () => {},\n}\n\nclass Map extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      mouseOver: true,\n    }\n    this._mapContainerRef = null\n  }\n\n  componentDidMount() {\n    if (this._mapContainerRef !== null) {\n      this.loadObserver()\n    }\n    this.setBounds()\n  }\n\n  componentDidUpdate() {\n    this.setBounds()\n  }\n\n  onLoad = () => {\n    if (this.props.onLoad !== undefined) {\n      this.props.onLoad(this.getBounds())\n    }\n  }\n\n  setBounds = () => {\n    const bounds = this.getBounds()\n    if (bounds !== null && this.props.setBounds !== undefined) {\n      this.props.setBounds(bounds)\n    }\n  }\n\n  getBounds = () => {\n    if (!this.glMap) return null\n\n    const { _ne, _sw } = this.glMap.getBounds()\n    return {\n      north: _ne.lat,\n      south: _sw.lat,\n      west: _sw.lng,\n      east: _ne.lng,\n    }\n  }\n\n  componentWillUnmount() {\n    if (this._containerResizeObserver) {\n      this._containerResizeObserver.disconnect()\n    }\n  }\n\n  loadObserver = async () => {\n    if ('ResizeObserver' in window === false) {\n      const module = await import('resize-observer-polyfill')\n      window.ResizeObserver = module.ResizeObserver || module.default\n    }\n    this._containerResizeObserver = new ResizeObserver(this.handleResizeObserver)\n    this._containerResizeObserver.observe(this._mapContainerRef)\n  }\n\n  handleResizeObserver = (entries) => {\n    const { width, height } = entries[0].contentRect\n    const { viewport, setViewport } = this.props\n\n    if (width !== viewport.width || height !== viewport.height) {\n      setViewport({\n        ...viewport,\n        width,\n        height,\n      })\n    }\n  }\n\n  onViewportChange = (viewport, interactionState) => {\n    const propsViewport = this.props.viewport\n    if (\n      propsViewport.latitude !== viewport.latitude ||\n      propsViewport.longitude !== viewport.longitude ||\n      propsViewport.zoom !== viewport.zoom ||\n      propsViewport.bearing !== viewport.bearing ||\n      propsViewport.pitch !== viewport.pitch\n    ) {\n      this.props.setViewport(viewport, interactionState)\n    }\n  }\n\n  onMapInteraction = (event, type) => {\n    this.props.mapInteraction(\n      type,\n      event.lngLat[1],\n      event.lngLat[0],\n      event.features,\n      this.glGetSource\n    )\n  }\n\n  onHover = (event) => {\n    this.onMapInteraction(event, 'hover')\n  }\n\n  onClick = (event) => {\n    this.onMapInteraction(event, 'click')\n  }\n\n  getRef = (ref) => {\n    if (ref !== null) {\n      this.glMap = ref.getMap()\n      this.glGetSource = this.glMap.getSource.bind(this.glMap)\n    }\n  }\n\n  getCursor = ({ isDragging }) => {\n    const { cursor } = this.props\n    if (cursor === null) {\n      return isDragging ? 'grabbing' : 'grab'\n    }\n    return cursor\n  }\n\n  transformRequest = (url, resourceType) => {\n    const { token } = this.props\n    if (token !== null && resourceType === 'Tile' && url.match(TILES_URL_NEEDING_AUTHENTICATION)) {\n      return {\n        url: url,\n        headers: { Authorization: 'Bearer ' + token },\n      }\n    }\n  }\n\n  render() {\n    const {\n      viewport,\n      maxZoom,\n      minZoom,\n      transitionEnd,\n      mapStyle,\n      onClosePopup,\n      clickPopup,\n      hoverPopup,\n      hasHeatmapLayers,\n      markers,\n      interactiveLayerIds,\n    } = this.props\n\n    return (\n      <div\n        id=\"map\"\n        className={styles.map}\n        ref={(ref) => {\n          this._mapContainerRef = ref\n        }}\n        onMouseLeave={() => {\n          this.setState({ mouseOver: false })\n        }}\n        onMouseEnter={() => {\n          this.setState({ mouseOver: true })\n        }}\n      >\n        <MapGL\n          {...viewport}\n          ref={this.getRef}\n          transformRequest={this.transformRequest}\n          onTransitionEnd={transitionEnd}\n          onLoad={this.onLoad}\n          onHover={this.onHover}\n          onClick={this.onClick}\n          getCursor={this.getCursor}\n          mapStyle={mapStyle}\n          maxZoom={maxZoom}\n          minZoom={minZoom}\n          onViewportChange={this.onViewportChange}\n          interactiveLayerIds={interactiveLayerIds}\n          clickRadius={4}\n          disableTokenWarning={true}\n        >\n          {hasHeatmapLayers !== false && <ActivityLayers />}\n          {clickPopup !== undefined && clickPopup !== null && (\n            <PopupWrapper\n              latitude={clickPopup.latitude}\n              longitude={clickPopup.longitude}\n              closeButton\n              onClose={onClosePopup}\n            >\n              {clickPopup.content}\n            </PopupWrapper>\n          )}\n          {this.state.mouseOver === true && hoverPopup !== undefined && hoverPopup !== null && (\n            <PopupWrapper\n              latitude={hoverPopup.latitude}\n              longitude={hoverPopup.longitude}\n              closeButton={false}\n            >\n              {hoverPopup.content}\n            </PopupWrapper>\n          )}\n          {markers !== null &&\n            markers.length > 0 &&\n            markers.map((marker, i) => (\n              <Marker key={i} latitude={marker.latitude} longitude={marker.longitude}>\n                {marker.content}\n              </Marker>\n            ))}\n        </MapGL>\n        <div className={styles.googleLogo} />\n      </div>\n    )\n  }\n}\n\nMap.propTypes = {\n  token: PropTypes.string,\n  viewport: PropTypes.object.isRequired,\n  mapStyle: PropTypes.object.isRequired,\n  clickPopup: PropTypes.object,\n  hoverPopup: PropTypes.object,\n  maxZoom: PropTypes.number.isRequired,\n  minZoom: PropTypes.number.isRequired,\n  setViewport: PropTypes.func.isRequired,\n  setBounds: PropTypes.func,\n  mapInteraction: PropTypes.func,\n  onLoad: PropTypes.func,\n  onClosePopup: PropTypes.func,\n  transitionEnd: PropTypes.func,\n  cursor: PropTypes.string,\n  hasHeatmapLayers: PropTypes.bool.isRequired,\n  markers: PropTypes.arrayOf(\n    PropTypes.shape({\n      latitude: PropTypes.number.isRequired,\n      longitude: PropTypes.number.isRequired,\n      content: PropTypes.node,\n    })\n  ),\n  interactiveLayerIds: PropTypes.arrayOf(PropTypes.string),\n}\n\nMap.defaultProps = {\n  token: null,\n  clickPopup: null,\n  hoverPopup: null,\n  mapInteraction: () => {},\n  onLoad: () => {},\n  onClosePopup: () => {},\n  transitionEnd: () => {},\n  cursor: null,\n  markers: null,\n  interactiveLayerIds: null,\n  setBounds: undefined,\n}\n\nexport default Map\n","import { connect } from 'react-redux'\nimport { createSelector } from 'reselect'\nimport { fromJS } from 'immutable'\nimport { TRACKS_LAYER_IN_FRONT_OF_GROUP } from '../config'\nimport { closePopup } from '../module/module.actions.js'\nimport { getTracksStyles } from '../tracks/tracks.selectors.js'\nimport { mapInteraction } from './interaction.actions.js'\nimport { setBounds, setViewport, transitionEnd } from './viewport.actions.js'\nimport Map from './Map'\n\nconst getStaticLayers = (state) => state.map.style.staticLayers\nconst getHeatmapLayers = (state) => state.map.heatmap.heatmapLayers\nconst getInternalCursor = (state) => state.map.interaction.cursor\nconst getModuleCursor = (state) => state.map.module.cursor\n\nconst hasHeatmapLayers = createSelector(\n  [getHeatmapLayers],\n  (heatmapLayers) => {\n    return Object.keys(heatmapLayers).length > 0\n  }\n)\nconst getInteractiveLayerIds = createSelector(\n  [getStaticLayers],\n  // Note: here we assume that layer IDs provided with module match the GL layers that should\n  // be interactive or not, ie typically the fill layer if a label layer is present\n  (staticLayers) => {\n    return staticLayers.reduce((acc, layer) => {\n      if (!layer.interactive || !layer.visible) return acc\n      // We also need to check nested layers interactivity when custom gl layers are provided\n      if (layer.gl !== undefined) {\n        layer.gl.layers.forEach((glLayer, index) => {\n          // layers.length === 1 is used to ensure when parent layer is marked as interactive we have to\n          // have at least one interactive sublayer, then checked eah one individually\n          if (\n            layer.gl.layers.length === 1 ||\n            (glLayer.metadata !== undefined && glLayer.metadata['gfw:interactive'] === true)\n          ) {\n            const glLayerId = glLayer.id || index > 0 ? `${layer.id}-${index}` : layer.id\n            acc.push(glLayerId)\n          }\n        })\n      } else {\n        acc.push(layer.id)\n      }\n      return acc\n    }, [])\n  }\n)\n\nconst getMapStyles = (state) => state.map.style.mapStyle\nconst getMapStyle = createSelector(\n  [getMapStyles, getTracksStyles],\n  (mapStyles, trackStyles) => {\n    if (!trackStyles) return mapStyles\n\n    const currentLayerGroups = mapStyles\n      .toJS()\n      .layers.filter((l) => l.metadata !== undefined)\n      .map((l) => l.metadata['mapbox:group'])\n    const trackLayersIndex = currentLayerGroups.lastIndexOf(TRACKS_LAYER_IN_FRONT_OF_GROUP) + 1\n\n    let finalMapStyles = mapStyles.mergeIn(['sources'], trackStyles.sources)\n    let mapStylesLayers = mapStyles.get('layers')\n    trackStyles.layers.forEach((trackLayer, i) => {\n      mapStylesLayers = mapStylesLayers.insert(trackLayersIndex + i, fromJS(trackLayer))\n    })\n    finalMapStyles = finalMapStyles.set('layers', mapStylesLayers)\n    return finalMapStyles\n  }\n)\n\nconst getCursor = createSelector(\n  [getInternalCursor, getModuleCursor],\n  (internalCursor, moduleCursor) => {\n    if (moduleCursor !== null) {\n      return moduleCursor\n    }\n    return internalCursor\n  }\n)\nconst mapStateToProps = (state) => ({\n  viewport: state.map.viewport.viewport,\n  maxZoom: state.map.viewport.maxZoom,\n  minZoom: state.map.viewport.minZoom,\n  onLoad: state.map.module.onLoad,\n  cursor: getCursor(state),\n  token: state.map.module.token,\n  mapStyle: getMapStyle(state),\n  hasHeatmapLayers: hasHeatmapLayers(state),\n  interactiveLayerIds: getInteractiveLayerIds(state),\n})\n\nconst mapDispatchToProps = (dispatch) => ({\n  setViewport: (viewport, interactionState) => {\n    dispatch(setViewport(viewport, interactionState))\n  },\n  setBounds: (bounds) => {\n    dispatch(setBounds(bounds))\n  },\n  mapInteraction: (type, lat, long, features, cluster, glGetSource) => {\n    dispatch(mapInteraction(type, lat, long, features, cluster, glGetSource))\n  },\n  transitionEnd: () => {\n    dispatch(transitionEnd())\n  },\n  onClosePopup: () => {\n    dispatch(closePopup())\n  },\n})\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(Map)\n","import { fromJS } from 'immutable'\nimport uniq from 'lodash/uniq'\nimport GL_STYLE from './gl-styles/style.json'\nimport {\n  SET_MAP_STYLE,\n  MARK_CARTO_LAYERS_AS_INSTANCIATED,\n  INIT_MAP_STYLE,\n  SET_STATIC_LAYERS,\n  SET_BASEMAP_LAYERS,\n} from './style.actions'\n\nconst attributions = uniq(\n  Object.keys(GL_STYLE.sources)\n    .map((sourceKey) => GL_STYLE.sources[sourceKey].attribution)\n    .filter((source) => source !== undefined)\n)\n\nexport const setLayerStyleDefaults = (layer) => {\n  if (layer.layout === undefined) {\n    layer.layout = {}\n  }\n  if (layer.paint === undefined) {\n    layer.paint = {}\n  }\n  if (layer.metadata === undefined) {\n    layer.metadata = {}\n  }\n  // initialize time filter for time-filterable layers\n  if (layer.metadata['gfw:temporal'] === true) {\n    const temporalField =\n      layer.metadata['gfw:temporalField'] === undefined\n        ? 'timestamp'\n        : layer.metadata['gfw:temporalField']\n    layer.filter = ['all', ['>', temporalField, 0], ['<', temporalField, 999999999999]]\n  }\n\n  if (layer.metadata['mapbox:group'] === undefined) {\n    layer.metadata['mapbox:group'] = 'temporal'\n  }\n\n  // set all layers to not visible except layers explicitely marked as visible (default basemap)\n  if (layer.layout.visibility !== 'visible') {\n    layer.layout.visibility = 'none'\n  }\n  return layer\n}\n\nconst setStyleDefaults = (style) => {\n  style.layers.forEach((layer) => {\n    setLayerStyleDefaults(layer)\n  })\n  return style\n}\n\nconst initialState = {\n  mapStyle: fromJS(setStyleDefaults(GL_STYLE)),\n  cartoLayersInstanciated: [],\n  staticLayers: [],\n  basemapLayers: [],\n  attributions,\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case INIT_MAP_STYLE: {\n      const newMapStyle = state.mapStyle.setIn(['glyphs'], action.payload.glyphsPath)\n      return { ...state, mapStyle: newMapStyle }\n    }\n    case SET_MAP_STYLE: {\n      return { ...state, mapStyle: action.payload }\n    }\n    case SET_STATIC_LAYERS: {\n      return { ...state, staticLayers: action.payload }\n    }\n    case SET_BASEMAP_LAYERS: {\n      return { ...state, basemapLayers: action.payload }\n    }\n    case MARK_CARTO_LAYERS_AS_INSTANCIATED: {\n      const cartoLayersInstanciated = [...state.cartoLayersInstanciated, ...action.payload]\n      return { ...state, cartoLayersInstanciated }\n    }\n    default:\n      return state\n  }\n}\n","// This utility looks at GeoJSON features and returns the predominant geometry type\n\nconst TYPES = [\n  { gl: 'line', geoJSON: ['LineString', 'MultiLineString'] },\n  { gl: 'fill', geoJSON: ['Polygon', 'MultiPolygon'] },\n  { gl: 'circle', geoJSON: ['Point', 'MultiPoint'] },\n]\n\nexport default (geoJSON) => {\n  // collect all geoJSON geom types\n  const allGeoJSONTypes = geoJSON.features.map((feature) => {\n    const geom = feature.geometry\n    if (geom === undefined) {\n      return null\n    }\n    return geom.type\n  })\n\n  // collect number of geometries by GL geom types\n  const numByGLType = TYPES.map((type) => {\n    let num = 0\n    allGeoJSONTypes.forEach((geoJSONType) => {\n      if (type.geoJSON.indexOf(geoJSONType) > -1) {\n        num++\n      }\n    })\n    return { gl: type.gl, num }\n  })\n\n  // get feature types with the higher count\n  let glType = 'fill'\n  let glTypeMax = 0\n  numByGLType.forEach((t) => {\n    if (t.num > glTypeMax) {\n      glType = t.gl\n      glTypeMax = t.num\n    }\n  })\n\n  return glType\n}\n","import { fromJS } from 'immutable'\nimport convert from '@globalfishingwatch/map-convert'\nimport uniq from 'lodash/uniq'\nimport throttle from 'lodash/throttle'\nimport { hexToRgb } from '../utils/map-colors'\nimport { STATIC_LAYERS_CARTO_ENDPOINT, STATIC_LAYERS_CARTO_TILES_ENDPOINT } from '../config'\nimport { CUSTOM_LAYERS_SUBTYPES, GL_TRANSPARENT } from '../constants'\nimport GL_STYLE from './gl-styles/style.json'\nimport { setLayerStyleDefaults } from './style.reducer.js'\nimport getMainGeomType from '../utils/getMainGeomType'\n\nexport const INIT_MAP_STYLE = 'INIT_MAP_STYLE'\nexport const SET_MAP_STYLE = 'SET_MAP_STYLE'\nexport const MARK_CARTO_LAYERS_AS_INSTANCIATED = 'MARK_CARTO_LAYERS_AS_INSTANCIATED'\nexport const SET_STATIC_LAYERS = 'SET_STATIC_LAYERS'\nexport const SET_BASEMAP_LAYERS = 'SET_BASEMAP_LAYERS'\n\nconst setDefaultVectorTiles = (currentSource, refLayerUrl) => {\n  if (currentSource.type !== 'vector') {\n    return currentSource\n  }\n  const tiles = currentSource.tiles\n  const refLayerUrls = refLayerUrl === undefined ? [] : [refLayerUrl]\n\n  const newTiles =\n    tiles !== undefined && tiles.length > 0 ? uniq([...refLayerUrls, ...tiles]) : refLayerUrls\n  return {\n    ...currentSource,\n    tiles: newTiles,\n  }\n}\n\nexport const initStyle = ({ glyphsPath }) => ({\n  type: INIT_MAP_STYLE,\n  payload: {\n    glyphsPath,\n  },\n})\n\nconst setMapStyle = (style) => ({\n  type: SET_MAP_STYLE,\n  payload: style,\n})\n\nconst setStyleTemporalExtent = (dispatch, getState, temporalExtent, applyToThrottled = false) => {\n  const state = getState().map.style\n  let style = state.mapStyle\n  const currentStyle = style.toJS()\n  const glLayers = currentStyle.layers\n\n  let start = Math.round(temporalExtent[0].getTime() / 1000)\n  let end = Math.round(temporalExtent[1].getTime() / 1000)\n\n  // TEMPORARY, remove later - temporal layers points should have a timestamp, this is legacy\n  // logic for legacy encounters layer that only have a 'timeIndex'\n  const startIndex = convert.getOffsetedTimeAtPrecision(temporalExtent[0].getTime())\n  const endIndex = convert.getOffsetedTimeAtPrecision(temporalExtent[1].getTime())\n\n  for (let i = 0; i < glLayers.length; i++) {\n    const glLayer = glLayers[i]\n    if (glLayer.metadata === undefined || glLayer.metadata['gfw:temporal'] !== true) {\n      continue\n    }\n\n    if (\n      (applyToThrottled === true && glLayer.metadata['gfw:temporal:throttled'] !== true) ||\n      (applyToThrottled === false && glLayer.metadata['gfw:temporal:throttled'] === true)\n    ) {\n      continue\n    }\n\n    // if layer is temporal, a filter must always be preset on the style.json object\n    // because each layer can have a different time field to be filtered\n    const currentFilter = style.getIn(['layers', i, 'filter']).toJS()\n    if (currentFilter === null) {\n      throw new Error('filter must be preset on style.json for temporal layer: ', glLayer.id)\n    }\n\n    // TEMPORARY, remove later - temporal layers points should have a timestamp, this is legacy\n    // logic for legacy encounters layer that only have a 'timeIndex'\n    const isLegacy = glLayer.metadata && glLayer.metadata['gfw:temporalField'] === 'timeIndex'\n    currentFilter[1][2] = isLegacy ? startIndex : start\n    currentFilter[2][2] = isLegacy ? endIndex : end\n    style = style.setIn(['layers', i, 'filter'], fromJS(currentFilter))\n  }\n  dispatch(setMapStyle(style))\n}\n\nconst applyTemporalExtentThrottled = throttle((dispatch, getState, temporalExtent) => {\n  setStyleTemporalExtent(dispatch, getState, temporalExtent, true)\n}, 400)\n\nexport const applyTemporalExtent = (temporalExtent) => (dispatch, getState) => {\n  setStyleTemporalExtent(dispatch, getState, temporalExtent)\n  applyTemporalExtentThrottled(dispatch, getState, temporalExtent)\n}\n\nconst applyLayerExpressions = (style, refLayer, currentGlLayer, glLayerIndex) => {\n  let newStyle = style\n  const currentStyle = style.toJS()\n  const glType = currentGlLayer.type\n  const defaultStyles = currentStyle.metadata['gfw:styles']\n  const metadata = currentGlLayer.metadata\n  ;['selected', 'highlighted'].forEach((styleType) => {\n    // get selectedFeatures or highlightedFeatures\n    const features = refLayer[`${styleType}Features`]\n    const refLayerStyle = features && features.style ? features.style[glType] : {}\n    const hasFeatures = features !== null && features !== undefined && features.values.length > 0\n    const applyStyleToAllFeatures = refLayer[styleType]\n\n    const defaultStyle = defaultStyles[styleType][glType] || {}\n    const layerStyle =\n      (metadata && metadata['gfw:styles'] && metadata['gfw:styles'][styleType]) || {}\n    const allPaintProperties = { ...defaultStyle, ...layerStyle, ...refLayerStyle }\n\n    if (Object.keys(allPaintProperties).length) {\n      // go through each applicable gl paint property\n      Object.keys(allPaintProperties).forEach((glPaintProperty) => {\n        const selectedValue = allPaintProperties[glPaintProperty][0]\n        const fallbackValue = allPaintProperties[glPaintProperty][1]\n        const paintOrLayout = ['icon-size', 'icon-image'].includes(glPaintProperty)\n          ? 'layout'\n          : 'paint'\n        let glPaintFinalValue\n        if (\n          hasFeatures === false &&\n          applyStyleToAllFeatures !== true &&\n          applyStyleToAllFeatures !== false\n        ) {\n          // style reset when no features filter is declared and neither is applyAll\n          const originalLayerStyle = GL_STYLE.layers.find((l) => l.id === currentGlLayer.id)\n\n          if (originalLayerStyle !== undefined) {\n            // for reset: do not repaint with default style when layer as a custom main color property\n            if (\n              currentGlLayer.metadata &&\n              currentGlLayer.metadata['gfw:mainColorPaintProperty'] === glPaintProperty\n            ) {\n              glPaintFinalValue = null\n            } else {\n              glPaintFinalValue = originalLayerStyle[paintOrLayout][glPaintProperty]\n            }\n          } else {\n            // this will happen when no style exist in the original definition (ie custom layers)\n            // in this case set glPaintFinalValue to null and we'll just skip applying\n            // any selected/highlighted style for this layer\n            glPaintFinalValue = null\n          }\n        } else if (applyStyleToAllFeatures === true || applyStyleToAllFeatures === false) {\n          glPaintFinalValue = applyStyleToAllFeatures === true ? selectedValue : fallbackValue\n        } else {\n          let layerColorRgbString = ''\n          if (refLayer.color !== null && refLayer.color !== undefined) {\n            const layerColorRgb = hexToRgb(refLayer.color)\n            layerColorRgbString = `${layerColorRgb.r},${layerColorRgb.g},${layerColorRgb.b}`\n          }\n          glPaintFinalValue = [\n            'match',\n            ['get', features.field],\n            features.values,\n            typeof selectedValue !== 'string'\n              ? selectedValue\n              : selectedValue.replace('$REFLAYER_COLOR_RGB', layerColorRgbString),\n            typeof fallbackValue !== 'string'\n              ? fallbackValue\n              : fallbackValue.replace('$REFLAYER_COLOR_RGB', layerColorRgbString),\n          ]\n        }\n\n        if (glPaintFinalValue !== undefined && glPaintFinalValue !== null) {\n          newStyle = newStyle.setIn(\n            ['layers', glLayerIndex, paintOrLayout, glPaintProperty],\n            glPaintFinalValue\n          )\n        }\n      })\n    }\n  })\n  return newStyle\n}\n\nconst toggleLayerVisibility = (style, refLayer, glLayerIndex) => {\n  const visibility = refLayer.visible === true ? 'visible' : 'none'\n  return style.setIn(['layers', glLayerIndex, 'layout', 'visibility'], visibility)\n}\n\nconst updateGLLayer = (style, glLayerId, refLayer) => {\n  const currentStyle = style.toJS()\n  const currentStyleLayers = currentStyle.layers\n  let newStyle = style\n\n  const glLayerIndex = currentStyleLayers.findIndex((l) => l.id === glLayerId)\n  const glLayer = currentStyleLayers.find((l) => l.id === glLayerId)\n\n  // visibility\n  newStyle = toggleLayerVisibility(newStyle, refLayer, glLayerIndex)\n\n  if (refLayer.isBasemap === true) {\n    return newStyle\n  }\n\n  const refLayerOpacity = refLayer.opacity === undefined ? 1 : refLayer.opacity\n\n  // color/opacity\n  switch (glLayer.type) {\n    case 'fill': {\n      newStyle = newStyle\n        .setIn(['layers', glLayerIndex, 'paint', 'fill-opacity'], refLayerOpacity)\n        .setIn(['layers', glLayerIndex, 'paint', 'fill-outline-color'], refLayer.color)\n        .setIn(['layers', glLayerIndex, 'paint', 'fill-color'], GL_TRANSPARENT)\n      break\n    }\n    case 'line': {\n      const color = refLayer.color || (glLayer.paint && glLayer.paint['line-color'])\n      newStyle = newStyle\n        .setIn(['layers', glLayerIndex, 'paint', 'line-opacity'], refLayerOpacity)\n        .setIn(['layers', glLayerIndex, 'paint', 'line-color'], color)\n      break\n    }\n    case 'symbol': {\n      if (glLayer.metadata && glLayer.metadata['gfw:isLabel'] === true) {\n        const parentLayerIsVisible =\n          newStyle.getIn(['layers', glLayerIndex, 'layout', 'visibility']) === 'visible'\n        const labelsVisibility =\n          parentLayerIsVisible && refLayer.showLabels === true ? 'visible' : 'none'\n        newStyle = newStyle.setIn(\n          ['layers', glLayerIndex, 'layout', 'visibility'],\n          labelsVisibility\n        )\n        if (refLayer.showLabels !== true) {\n          break\n        }\n      }\n      newStyle = newStyle.setIn(['layers', glLayerIndex, 'paint', 'text-opacity'], refLayerOpacity)\n\n      if (refLayer.color !== undefined) {\n        newStyle = newStyle.setIn(['layers', glLayerIndex, 'paint', 'text-color'], refLayer.color)\n      }\n      break\n    }\n    // Event layers and custom layers with point geom types\n    case 'circle': {\n      newStyle = newStyle\n        .setIn(['layers', glLayerIndex, 'paint', 'circle-opacity'], refLayerOpacity)\n        .setIn(['layers', glLayerIndex, 'paint', 'circle-stroke-opacity'], refLayerOpacity)\n\n      if (refLayer.color !== undefined) {\n        const colorPaintProperty =\n          glLayer && glLayer.metadata && glLayer.metadata['gfw:mainColorPaintProperty']\n            ? glLayer.metadata['gfw:mainColorPaintProperty']\n            : 'circle-color'\n        newStyle = newStyle.setIn(\n          ['layers', glLayerIndex, 'paint', colorPaintProperty],\n          refLayer.color\n        )\n      }\n      break\n    }\n    case 'raster': {\n      newStyle = newStyle.setIn(\n        ['layers', glLayerIndex, 'paint', 'raster-opacity'],\n        refLayerOpacity\n      )\n      break\n    }\n    default: {\n      break\n    }\n  }\n\n  newStyle = applyLayerExpressions(newStyle, refLayer, glLayer, glLayerIndex)\n\n  return newStyle\n}\n\nconst addCustomGLLayer = (subtype, layerId, url, data) => (dispatch, getState) => {\n  const state = getState()\n  let style = state.map.style.mapStyle\n  const currentStyle = style.toJS()\n\n  // add source if it doesn't exist yet\n  if (currentStyle.sources[layerId] === undefined) {\n    const source = { type: subtype }\n    if (subtype === CUSTOM_LAYERS_SUBTYPES.geojson) {\n      source.data = data\n    } else if (subtype === CUSTOM_LAYERS_SUBTYPES.raster) {\n      source.tiles = [url]\n      source.tileSize = 256\n    }\n    style = style.setIn(['sources', layerId], fromJS(source))\n  }\n\n  if (currentStyle.layers.find((glLayer) => glLayer.id === layerId) === undefined) {\n    const glType = subtype === CUSTOM_LAYERS_SUBTYPES.geojson ? getMainGeomType(data) : subtype\n    const glLayer = fromJS({\n      id: layerId,\n      source: layerId,\n      type: glType,\n      layout: {},\n      paint: {},\n    })\n    const layerIndex =\n      subtype === CUSTOM_LAYERS_SUBTYPES.raster\n        ? // if raster, put at index of last raster layer except labels\n          currentStyle.layers.length -\n          1 -\n          currentStyle.layers\n            .filter((l) => l.id !== 'labels')\n            .reverse()\n            .findIndex((l) => l.type === 'raster')\n        : currentStyle.layers.length - 1\n    style = style.set('layers', style.get('layers').splice(layerIndex, 0, glLayer))\n  }\n\n  dispatch(setMapStyle(style))\n}\n\nconst updateWorkspaceGLLayers = (workspaceGLLayers) => (dispatch, getState) => {\n  const state = getState()\n  let style = state.map.style.mapStyle\n\n  workspaceGLLayers.forEach((workspaceGLLayer) => {\n    const { id, gl } = workspaceGLLayer\n    const finalSource = setDefaultVectorTiles(gl.source, workspaceGLLayer.url)\n    style = style.setIn(['sources', id], fromJS(finalSource))\n\n    const existingLayerIds = style\n      .get('layers')\n      .toJS()\n      .map((l) => l.id)\n    const layersToAdd = gl.layers.filter((layer, index) => {\n      const layerId = layer.id || index > 0 ? `${id}-${index}` : id\n      return !existingLayerIds.includes(layerId)\n    })\n    layersToAdd.forEach((layerToAdd, index) => {\n      // doesn't add a sufix in the first elements but it will for the following ones\n      let layerToAddId = layerToAdd.id || index > 0 ? `${id}-${index}` : id\n      const defaultGlLayer = setLayerStyleDefaults(layerToAdd)\n\n      const glLayer = {\n        ...defaultGlLayer,\n        id: layerToAddId,\n        source: id,\n      }\n\n      // set source-layer - defaults to source id\n      if (gl.source.type === 'vector') {\n        const sourceLayer =\n          layerToAdd['source-layer'] === undefined ? id : layerToAdd['source-layer']\n        glLayer['source-layer'] = sourceLayer\n      }\n\n      // find correct z-index\n      const existingLayers = style.get('layers')\n      const newLayerGroup = glLayer.metadata['mapbox:group']\n      const newLayerIndex = existingLayers.findLastIndex((l) => {\n        return newLayerGroup === l.toJS().metadata['mapbox:group']\n      })\n      style = style.set('layers', existingLayers.splice(newLayerIndex, 0, fromJS(glLayer)))\n    })\n  })\n\n  dispatch(setMapStyle(style))\n  dispatch(applyTemporalExtent(state.map.module.temporalExtent))\n}\n\nconst getCartoLayerInstanciatePromise = ({ sourceId, sourceCartoSQL }) => {\n  const mapConfig = { layers: [{ id: sourceId, options: { sql: sourceCartoSQL } }] }\n  const mapConfigURL = encodeURIComponent(JSON.stringify(mapConfig))\n  const cartoAnonymousMapUrl = STATIC_LAYERS_CARTO_ENDPOINT.replace('$MAPCONFIG', mapConfigURL)\n\n  return new Promise((resolve) => {\n    fetch(cartoAnonymousMapUrl)\n      .then((res) => {\n        if (res.status >= 400) {\n          console.warn(`loading of layer failed ${sourceId}`)\n          Promise.reject()\n          return null\n        }\n        return res.json()\n      })\n      .then((data) => {\n        resolve({\n          layergroupid: data.layergroupid,\n          sourceId,\n        })\n      })\n      .catch((err) => {\n        console.warn(err)\n      })\n  })\n}\n\nconst instanciateCartoLayers = (layers) => (dispatch, getState) => {\n  dispatch({\n    type: MARK_CARTO_LAYERS_AS_INSTANCIATED,\n    payload: layers.map((layer) => layer.sourceId),\n  })\n  const cartoLayersPromises = layers.map((layer) => getCartoLayerInstanciatePromise(layer))\n  const cartoLayersPromisesPromise = Promise.all(cartoLayersPromises.map((p) => p.catch((e) => e)))\n  cartoLayersPromisesPromise\n    .then((instanciatedCartoLayers) => {\n      let style = getState().map.style.mapStyle\n      const currentStyle = style.toJS()\n      instanciatedCartoLayers.forEach((cartoLayer) => {\n        const tilesURL = STATIC_LAYERS_CARTO_TILES_ENDPOINT.replace(\n          '$LAYERGROUPID',\n          cartoLayer.layergroupid\n        )\n\n        // replace gl source with a new source that use tiles provided by Carto anonymous maps API\n        const newSourceId = `${cartoLayer.sourceId}-instanciated`\n        style = style.setIn(\n          ['sources', newSourceId],\n          fromJS({\n            type: 'vector',\n            tiles: [tilesURL],\n          })\n        )\n\n        style = style.deleteIn(['sources', cartoLayer.sourceId])\n\n        // change source in all layers that are using it (generally polygon + labels)\n        currentStyle.layers.forEach((glLayer, glLayerIndex) => {\n          if (glLayer.source === cartoLayer.sourceId) {\n            style = style.setIn(['layers', glLayerIndex, 'source'], newSourceId)\n            style = style.setIn(['layers', glLayerIndex, 'metadata', 'gfw:id'], cartoLayer.sourceId)\n            const refLayer = layers.find((l) => l.refLayer.id === cartoLayer.sourceId).refLayer\n            style = updateGLLayer(style, glLayer.id, refLayer)\n          }\n        })\n      })\n\n      dispatch(setMapStyle(style))\n    })\n    .catch((err) => {\n      console.warn(err)\n    })\n}\n\nexport const commitStyleUpdates = (staticLayers, basemapLayers) => (dispatch, getState) => {\n  // Store a copy of static and basemap layers. This is not used directly by\n  // the Map component which only needs a prepared style object\n  dispatch({\n    type: SET_STATIC_LAYERS,\n    payload: staticLayers,\n  })\n  dispatch({\n    type: SET_BASEMAP_LAYERS,\n    payload: basemapLayers,\n  })\n\n  const layers = [...staticLayers, ...basemapLayers.map((bl) => ({ ...bl, isBasemap: true }))]\n\n  const currentGLSources = getState().map.style.mapStyle.toJS().sources\n\n  // collect layers declared in workspace but not in original gl style\n  const workspaceGLLayers = layers.filter((layer) => layer.gl !== undefined)\n\n  if (workspaceGLLayers.length) {\n    // Adds the gl layers again in case the source is a dynamic geojson source\n    dispatch(updateWorkspaceGLLayers(workspaceGLLayers))\n  }\n\n  // instanciate custom layers if needed\n  const customLayers = layers.filter(\n    (layer) => layer.isCustom === true && currentGLSources[layer.id] === undefined\n  )\n  if (customLayers.length) {\n    customLayers.forEach((layer) => {\n      dispatch(addCustomGLLayer(layer.subtype, layer.id, layer.url, layer.data))\n    })\n  }\n\n  const state = getState().map.style\n  let style = state.mapStyle\n  const currentStyle = style.toJS()\n  const glLayers = currentStyle.layers\n  const glSources = currentStyle.sources\n\n  const cartoLayersToInstanciate = []\n\n  // update source when needed\n  staticLayers.forEach((refLayer) => {\n    const sourceId = refLayer.id\n    if (currentGLSources[sourceId] !== undefined && refLayer.visible === true) {\n      if (refLayer.data !== undefined) {\n        style = style.setIn(['sources', sourceId, 'data'], fromJS(refLayer.data))\n      }\n      if (refLayer.url !== undefined) {\n        const newSource = setDefaultVectorTiles(currentGLSources[sourceId], refLayer.url)\n        style = style.setIn(['sources', sourceId], fromJS(newSource))\n      }\n    }\n  })\n\n  for (let i = 0; i < glLayers.length; i++) {\n    const glLayer = glLayers[i]\n    const sourceId = glLayer.source\n    const glSource = glSources[sourceId]\n    const layerId = (glLayer.metadata !== undefined && glLayer.metadata['gfw:id']) || sourceId\n\n    const refLayer = layers.find((l) => l.id === layerId)\n\n    if (refLayer === undefined) {\n      if (glLayer.type !== 'background') {\n        // console.warn('gl layer does not exists in workspace', glLayer);\n      }\n      continue\n    }\n\n    // check if layer is served from Carto, which means we need to instanciate it first\n    // TODO BUG: check if layer is not instanciatING too\n    const sourceCartoSQL = glSource.metadata !== undefined && glSource.metadata['gfw:carto-sql']\n    if (sourceCartoSQL !== false && sourceCartoSQL !== undefined) {\n      // only if layer is visible and has not been instanciated yet\n      const cartoLayerInstanciated = state.cartoLayersInstanciated.indexOf(sourceId) > -1\n      if (\n        refLayer.visible === true &&\n        !cartoLayerInstanciated &&\n        !cartoLayersToInstanciate.find((l) => l.sourceId === sourceId)\n      ) {\n        cartoLayersToInstanciate.push({ sourceId, sourceCartoSQL, refLayer })\n      }\n      continue\n    }\n\n    style = updateGLLayer(style, glLayer.id, refLayer)\n  }\n\n  if (cartoLayersToInstanciate.length) {\n    dispatch(instanciateCartoLayers(cartoLayersToInstanciate))\n  }\n\n  dispatch(setMapStyle(style))\n}\n","import FlyToInterpolator from 'react-map-gl/dist/esm/utils/transition/viewport-fly-to-interpolator'\nimport { easeCubic } from 'd3-ease'\nimport { MIN_ZOOM_LEVEL, MAX_ZOOM_LEVEL } from '../config'\nimport { TRANSITION_TYPE } from '../constants'\nimport {\n  SET_BOUNDS,\n  SET_VIEWPORT,\n  UPDATE_VIEWPORT,\n  SET_ZOOM_INCREMENT,\n  SET_MOUSE_LAT_LONG,\n  TRANSITION_END,\n  SET_NATIVE_VIEWPORT,\n} from './viewport.actions'\n\nexport const TRANSITION_DURATION = 500\n\nconst DEFAULT_TRANSITION = {\n  transitionDuration: TRANSITION_DURATION,\n  transitionInterpolator: new FlyToInterpolator(),\n  transitionEasing: easeCubic,\n}\n\nconst initialState = {\n  viewport: {\n    latitude: 0,\n    longitude: 0,\n    zoom: 3,\n    bearing: 0,\n    pitch: 0,\n    width: 1000,\n    height: 800,\n    bounds: {},\n  },\n  maxZoom: MAX_ZOOM_LEVEL,\n  minZoom: MIN_ZOOM_LEVEL,\n  prevZoom: 3,\n  currentTransition: null,\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case SET_VIEWPORT: {\n      return {\n        ...state,\n        viewport: action.payload,\n        canZoomIn: action.payload.zoom < state.maxZoom,\n        canZoomOut: action.payload.zoom > state.minZoom,\n        prevZoom: state.viewport.zoom,\n      }\n    }\n\n    case SET_BOUNDS: {\n      return {\n        ...state,\n        bounds: action.payload,\n      }\n    }\n\n    case UPDATE_VIEWPORT: {\n      const viewport = { ...state.viewport, ...action.payload }\n      return {\n        ...state,\n        viewport,\n        prevZoom: viewport.zoom,\n      }\n    }\n\n    case SET_ZOOM_INCREMENT: {\n      const currentZoom = state.viewport.zoom\n      const zoom = Math.min(\n        state.maxZoom,\n        action.payload.zoom || currentZoom + action.payload.increment\n      )\n      const viewport = {\n        ...state.viewport,\n        ...DEFAULT_TRANSITION,\n        zoom,\n        latitude:\n          action.payload.latitude === null ? state.viewport.latitude : action.payload.latitude,\n        longitude:\n          action.payload.longitude === null ? state.viewport.longitude : action.payload.longitude,\n      }\n      return {\n        ...state,\n        viewport,\n        canZoomIn: zoom < state.maxZoom,\n        canZoomOut: zoom > state.minZoom,\n        prevZoom: state.viewport.zoom,\n        currentTransition: TRANSITION_TYPE.ZOOM,\n      }\n    }\n\n    case SET_MOUSE_LAT_LONG: {\n      return { ...state, mouseLatLong: action.payload }\n    }\n\n    case TRANSITION_END: {\n      return { ...state, currentTransition: null }\n    }\n\n    case SET_NATIVE_VIEWPORT: {\n      return { ...state, ...action.payload }\n    }\n\n    default:\n      return state\n  }\n}\n","import { compose, createStore, applyMiddleware } from 'redux'\nimport thunk from 'redux-thunk'\n\nimport { TRANSITION_DURATION } from '../glmap/viewport.reducer'\nimport { fitToBounds as fitToBoundsAction, transitionEnd } from '../glmap/viewport.actions'\n\nlet composeEnhancers = compose\nif (\n  (process.env.MAP_REDUX_REMOTE_DEBUG || process.env.REACT_APP_MAP_REDUX_REMOTE_DEBUG) &&\n  process.env.NODE_ENV === 'development'\n) {\n  const composeWithDevTools = require('remote-redux-devtools').composeWithDevTools\n  composeEnhancers = composeWithDevTools({\n    name: 'Map module',\n    realtime: true,\n    hostname: 'localhost',\n    port: 8000,\n    maxAge: 30,\n    stateSanitizer: (state) => ({ ...state, map: { ...state.map, heatmap: 'NOT_SERIALIZED' } }),\n  })\n}\n\nconst store = createStore(() => {}, {}, composeEnhancers(applyMiddleware(thunk)))\n\nexport const targetMapVessel = (id) => {\n  const track = store.getState().map.tracks.data.find((t) => t.id === id.toString())\n  store.dispatch(fitToBoundsAction(track.geoBounds))\n\n  return track.timelineBounds\n}\nexport const fitToBounds = (bounds) => {\n  store.dispatch(fitToBoundsAction(bounds))\n  setTimeout(() => {\n    // needed as the transition end is not being called on first fitToBounds trigger\n    if (store.getState().map.viewport.currentTransition !== null) {\n      store.dispatch(transitionEnd())\n    }\n  }, TRANSITION_DURATION + 1)\n}\n\nexport default store\n","import tbbox from '@turf/bbox'\n\nexport const getTrackTimeBounds = (geojson) => {\n  const time = { start: Infinity, end: 0 }\n  if (geojson && geojson.features) {\n    geojson.features.forEach((feature) => {\n      const hasTimes =\n        feature.properties &&\n        feature.properties.coordinateProperties &&\n        feature.properties.coordinateProperties.times &&\n        feature.properties.coordinateProperties.times.length > 0\n      if (hasTimes) {\n        feature.properties.coordinateProperties.times.forEach((datetime) => {\n          if (datetime < time.start) {\n            time.start = datetime\n          } else if (datetime > time.end) {\n            time.end = datetime\n          }\n        })\n      }\n    })\n  }\n  return [time.start, time.end]\n}\n\nexport const getTrackBounds = (geojson) => {\n  const bounds = tbbox(geojson)\n  return {\n    minLat: bounds[3],\n    minLng: bounds[0],\n    maxLat: bounds[1],\n    maxLng: bounds[2],\n  }\n}\n","import cloneDeep from 'lodash/cloneDeep'\nimport { targetMapVessel } from '../store'\n\nimport { getTilePromises, getCleanVectorArrays, groupData } from '../utils/heatmapTileData'\nimport { startLoader, completeLoader } from '../module/module.actions'\nimport { getTrackBounds, getTrackTimeBounds } from '../utils/getTrackBounds'\n\nexport const ADD_TRACK = 'ADD_TRACK'\nexport const UPDATE_TRACK = 'UPDATE_TRACK'\nexport const REMOVE_TRACK = 'REMOVE_TRACK'\n\nconst convertLegacyTrackToGeoJSON = (vectorArrays) => {\n  const createFeature = (segId, type = 'track', geomType = 'LineString') => ({\n    type: 'Feature',\n    geometry: {\n      type: geomType,\n      coordinates: [],\n    },\n    properties: {\n      type,\n      segId,\n      coordinateProperties: {\n        times: [],\n      },\n    },\n  })\n\n  let currentLng\n  let currentSeries = vectorArrays.series[0]\n  let currentFeature = createFeature(currentSeries)\n  const fishingPoints = createFeature('fishing', 'fishing', 'MultiPoint')\n  const features = []\n  let lngOffset = 0\n\n  for (let index = 0, length = vectorArrays.latitude.length; index < length; index++) {\n    const series = vectorArrays.series[index]\n    const longitude = vectorArrays.longitude[index]\n    const latitude = vectorArrays.latitude[index]\n    const weight = vectorArrays.weight[index]\n\n    if (currentLng) {\n      if (longitude - currentLng < -180) {\n        lngOffset += 360\n      } else if (longitude - currentLng > 180) {\n        lngOffset -= 360\n      }\n    }\n\n    const ll = [longitude + lngOffset, latitude]\n    if (series !== currentSeries && index !== 0) {\n      features.push(cloneDeep(currentFeature))\n      currentFeature = createFeature(series)\n    }\n\n    currentFeature.geometry.coordinates.push(ll)\n    if (weight > 0) {\n      fishingPoints.geometry.coordinates.push(ll)\n      fishingPoints.properties.coordinateProperties.times.push(vectorArrays.datetime[index])\n    }\n    currentFeature.properties.coordinateProperties.times.push(vectorArrays.datetime[index])\n\n    currentSeries = series\n    currentLng = longitude\n  }\n  features.push(fishingPoints)\n\n  return {\n    type: 'FeatureCollection',\n    features,\n  }\n}\n\nfunction loadTrack(track) {\n  return (dispatch, getState) => {\n    const { id, url, type, fitBoundsOnLoad, layerTemporalExtents, color, data } = track\n    const state = getState()\n    const token = state.map.module.token\n    console.log('loadTrack -> token', token)\n\n    if (state.map.tracks.data.find((t) => t.id === id)) {\n      return\n    }\n\n    const payload = {\n      id,\n      url,\n      type,\n      color,\n      fitBoundsOnLoad,\n    }\n    const trackHasData = track.data !== undefined && track.data !== null\n    const trackHasUrl = url !== undefined && url !== null && url !== ''\n    if (trackHasData) {\n      payload.data = data\n      payload.geoBounds = getTrackBounds(data)\n    }\n    dispatch({ type: ADD_TRACK, payload })\n\n    if (trackHasData || !trackHasUrl) {\n      return\n    }\n\n    const loaderID = startLoader(dispatch, state)\n    if (type !== 'geojson') {\n      // Deprecated tracks format logic to be deleted some day\n      const token = state.map.module.token\n\n      const promises = getTilePromises(url, token, layerTemporalExtents)\n\n      Promise.all(promises.map((p) => p.catch((e) => e))).then((rawTileData) => {\n        const cleanData = getCleanVectorArrays(rawTileData)\n\n        if (!cleanData.length) {\n          return\n        }\n        const rawTrackData = groupData(cleanData, [\n          'latitude',\n          'longitude',\n          'datetime',\n          'series',\n          'weight',\n          'sigma',\n        ])\n\n        const data = convertLegacyTrackToGeoJSON(rawTrackData)\n        const timelineBounds = getTrackTimeBounds(data)\n        const geoBounds = getTrackBounds(data)\n\n        dispatch({\n          type: UPDATE_TRACK,\n          payload: {\n            id,\n            data,\n            geoBounds,\n            timelineBounds,\n          },\n        })\n        dispatch(completeLoader(loaderID))\n      })\n    } else {\n      fetch(url, { headers: { Authorization: 'Bearer ' + token } })\n        .then((res) => {\n          if (res.status >= 400) throw new Error(res.statusText)\n          return res.json()\n        })\n        .then((data) => {\n          const timelineBounds = getTrackTimeBounds(data)\n          const geoBounds = getTrackBounds(data)\n          dispatch({\n            type: UPDATE_TRACK,\n            payload: {\n              id,\n              data,\n              geoBounds,\n              timelineBounds,\n            },\n          })\n          if (fitBoundsOnLoad) {\n            targetMapVessel(id)\n          }\n        })\n        .catch((err) => console.warn(err))\n        .finally(() => dispatch(completeLoader(loaderID)))\n    }\n  }\n}\n\nconst removeTrack = (trackId) => ({\n  type: REMOVE_TRACK,\n  payload: {\n    trackId,\n  },\n})\n\nexport const updateTracks = (newTracks = []) => (dispatch, getState) => {\n  const prevTracks = getState().map.tracks.data\n  // add and update layers\n  if (newTracks) {\n    newTracks.forEach((newTrack) => {\n      const trackId = newTrack.id\n      const prevTrack = prevTracks.find((t) => t.id === trackId)\n      if (prevTrack === undefined) {\n        dispatch(loadTrack(newTrack))\n      } else if (prevTrack.color !== newTrack.color) {\n        dispatch({\n          type: UPDATE_TRACK,\n          payload: {\n            id: newTrack.id,\n            color: newTrack.color,\n          },\n        })\n      }\n    })\n  }\n\n  // clean up unused tracks\n  prevTracks.forEach((prevTrack) => {\n    if (!newTracks || !newTracks.find((t) => t.id === prevTrack.id)) {\n      dispatch(removeTrack(prevTrack.id))\n    }\n  })\n}\n","import PropTypes from 'prop-types'\n\nconst withReducerPropTypes = (name, propTypesSchema) => (reducer) => {\n  if (process.env.NODE_ENV === 'development') {\n    return (state, action) => {\n      const result = reducer(state, action)\n      PropTypes.checkPropTypes(propTypesSchema, result, 'reducer', name)\n\n      return result\n    }\n  }\n  return reducer\n}\n\nexport default withReducerPropTypes\n","import PropTypes from 'prop-types'\nimport withReducerTypes from '../utils/withReducerTypes'\nimport {\n  INIT_MODULE,\n  SET_TEMPORAL_EXTENT,\n  SET_HIGHLIGHT_TEMPORAL_EXTENT,\n  START_LOADER,\n  COMPLETE_LOADER,\n  SET_MODULE_CURSOR,\n} from './module.actions'\n\nconst initialState = {\n  loaders: null,\n  token: undefined,\n  temporalExtent: [new Date(1970), new Date()],\n  highlightTemporalExtent: null,\n  cursor: null,\n  onViewportChange: undefined,\n  onHover: undefined,\n  onClick: undefined,\n  onLoad: undefined,\n  onLoadStart: undefined,\n  onLoadComplete: undefined,\n  onClosePopup: undefined,\n  onAttributionsChange: undefined,\n}\n\nconst moduleReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case INIT_MODULE: {\n      return {\n        ...state,\n        ...action.payload,\n      }\n    }\n\n    case SET_TEMPORAL_EXTENT: {\n      return {\n        ...state,\n        temporalExtent: action.payload,\n      }\n    }\n\n    case SET_HIGHLIGHT_TEMPORAL_EXTENT: {\n      return {\n        ...state,\n        highlightTemporalExtent: action.payload,\n      }\n    }\n\n    case START_LOADER: {\n      const loaders = state.loaders !== null ? [...state.loaders] : []\n      loaders.push(action.payload)\n      return { ...state, loaders }\n    }\n\n    case COMPLETE_LOADER: {\n      const loaders = [...state.loaders]\n      const loaderIndex = loaders.findIndex((l) => l === action.payload)\n      loaders.splice(loaderIndex, 1)\n      return { ...state, loaders }\n    }\n\n    case SET_MODULE_CURSOR: {\n      return { ...state, cursor: action.payload }\n    }\n\n    default:\n      return state\n  }\n}\n\nconst moduleTypes = {\n  loaders: PropTypes.arrayOf(PropTypes.number),\n  token: PropTypes.string,\n  temporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  onViewportChange: PropTypes.func,\n  onHover: PropTypes.func,\n  onClick: PropTypes.func,\n  onLoad: PropTypes.func,\n  onLoadStart: PropTypes.func,\n  onLoadComplete: PropTypes.func,\n  onClosePopup: PropTypes.func,\n  onAttributionsChange: PropTypes.func,\n}\n\nexport default withReducerTypes('module', moduleTypes)(moduleReducer)\n","import PropTypes from 'prop-types'\nimport { trackTypes } from '../proptypes/tracks'\nimport withReducerTypes from '../utils/withReducerTypes'\n\nimport { ADD_TRACK, UPDATE_TRACK, REMOVE_TRACK } from './tracks.actions'\n\nconst initialState = {\n  data: [],\n}\n\nconst tracksReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case ADD_TRACK: {\n      const data = [...state.data, action.payload]\n      return { ...state, data }\n    }\n\n    case UPDATE_TRACK: {\n      const trackData = action.payload\n      const data = state.data.map((track) => {\n        if (track.id !== trackData.id) return track\n        return {\n          ...track,\n          ...trackData,\n        }\n      })\n      return { ...state, data }\n    }\n\n    case REMOVE_TRACK: {\n      const removedTrackId = action.payload.trackId\n      const data = state.data.filter((track) => track.id !== removedTrackId)\n      return { ...state, data }\n    }\n\n    default:\n      return state\n  }\n}\n\nconst tracksTypes = {\n  data: PropTypes.arrayOf(\n    PropTypes.exact({\n      ...trackTypes,\n      data: PropTypes.object,\n      timelineBounds: PropTypes.array,\n      geoBounds: PropTypes.exact({\n        minLat: PropTypes.number,\n        minLng: PropTypes.number,\n        maxLat: PropTypes.number,\n        maxLng: PropTypes.number,\n      }),\n    })\n  ),\n}\n\nexport default withReducerTypes('tracks', tracksTypes)(tracksReducer)\n","import difference from 'lodash/difference'\nimport {\n  INIT_HEATMAP_LAYERS,\n  UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES,\n  ADD_HEATMAP_LAYER,\n  UPDATE_HEATMAP_LAYER_STYLE,\n  REMOVE_HEATMAP_LAYER,\n  ADD_REFERENCE_TILE,\n  UPDATE_HEATMAP_TILE,\n  RELEASE_HEATMAP_TILES,\n  HIGHLIGHT_VESSELS,\n  UPDATE_LOADED_TILES,\n  HIGHLIGHT_CLICKED_VESSEL,\n  CLEAR_HIGHLIGHT_CLICKED_VESSEL,\n} from './heatmap.actions'\n\nconst initialState = {\n  // a dict of heatmap layers (key is layer id)\n  // each containing data, url, tiles, visibleTemporalExtentsIndices\n  heatmapLayers: {},\n  // store a list of tiles currently visible in the map\n  // those are necessary when adding a new layer to know which tiles need to be loaded\n  referenceTiles: [],\n  highlightedVessels: { isEmpty: true },\n  highlightedClickedVessel: null,\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case INIT_HEATMAP_LAYERS: {\n      return Object.assign({}, state, { heatmapLayers: action.payload })\n    }\n\n    case UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES: {\n      const heatmapLayers = state.heatmapLayers\n      heatmapLayers[action.payload.layerId].visibleTemporalExtentsIndices =\n        action.payload.newVisibleTemporalExtentsIndices\n\n      // also removing indices within each tile\n      // adding is done after tile has actually loaded\n      heatmapLayers[action.payload.layerId].tiles.forEach((tile) => {\n        tile.temporalExtentsIndicesLoaded = difference(\n          tile.temporalExtentsIndicesLoaded,\n          action.payload.indicesRemoved\n        )\n      })\n      return { ...state, heatmapLayers }\n    }\n\n    case ADD_HEATMAP_LAYER: {\n      const heatmapLayers = Object.assign({}, state.heatmapLayers, {\n        [action.payload.id]: {\n          tiles: [],\n          ...action.payload,\n        },\n      })\n      return Object.assign({}, state, { heatmapLayers })\n    }\n\n    case UPDATE_HEATMAP_LAYER_STYLE: {\n      const newLayer = action.payload\n      const layer = { ...state.heatmapLayers[newLayer.id], ...newLayer }\n      const heatmapLayers = { ...state.heatmapLayers, [newLayer.id]: layer }\n      return { ...state, heatmapLayers }\n    }\n\n    case REMOVE_HEATMAP_LAYER: {\n      const heatmapLayers = Object.assign({}, state.heatmapLayers)\n      delete heatmapLayers[action.payload.id]\n      return Object.assign({}, state, { heatmapLayers })\n    }\n\n    case ADD_REFERENCE_TILE: {\n      return Object.assign({}, state, { referenceTiles: [...state.referenceTiles, action.payload] })\n    }\n\n    case UPDATE_HEATMAP_TILE: {\n      const layerId = action.payload.layerId\n      const newTile = action.payload.tile\n      const layer = { ...state.heatmapLayers[layerId] }\n      let layerTiles = [...layer.tiles]\n      const tileIndex = layerTiles.findIndex((t) => t.uid === newTile.uid)\n      if (tileIndex === -1) {\n        layerTiles.push(newTile)\n      } else {\n        layerTiles = [\n          ...layerTiles.slice(0, tileIndex),\n          newTile,\n          ...layerTiles.slice(tileIndex + 1),\n        ]\n      }\n      layer.tiles = layerTiles\n      const heatmapLayers = { ...state.heatmapLayers, [layerId]: layer }\n      return { ...state, heatmapLayers }\n    }\n\n    case RELEASE_HEATMAP_TILES: {\n      const uids = action.payload\n\n      // remove tiles\n      const layerIds = Object.keys(state.heatmapLayers)\n      const heatmapLayers = { ...state.heatmapLayers }\n      layerIds.forEach((layerId) => {\n        const prevLayer = { ...heatmapLayers[layerId] }\n        uids.forEach((tileUid) => {\n          const releasedTileIndex = prevLayer.tiles.findIndex((tile) => tile.uid === tileUid)\n          if (releasedTileIndex > -1) {\n            // console.log('releasing', layerId, tileUid);\n            prevLayer.tiles.splice(releasedTileIndex, 1)\n          }\n        })\n      })\n\n      // remove reference tiles\n      let referenceTiles = [...state.referenceTiles]\n      uids.forEach((tileUid) => {\n        const releasedRefTileIndex = referenceTiles.findIndex((tile) => tile.uid === tileUid)\n        if (releasedRefTileIndex > -1) {\n          referenceTiles = [\n            ...referenceTiles.slice(0, releasedRefTileIndex),\n            ...referenceTiles.slice(releasedRefTileIndex + 1),\n          ]\n        }\n      })\n\n      return { ...state, heatmapLayers, referenceTiles }\n    }\n\n    case UPDATE_LOADED_TILES: {\n      const newHeatmapLayers = { ...state.heatmapLayers }\n      return { ...state, heatmapLayers: newHeatmapLayers }\n    }\n\n    case HIGHLIGHT_VESSELS: {\n      return Object.assign({}, state, { highlightedVessels: action.payload })\n    }\n\n    case HIGHLIGHT_CLICKED_VESSEL: {\n      return { ...state, highlightedClickedVessel: action.payload }\n    }\n\n    case CLEAR_HIGHLIGHT_CLICKED_VESSEL: {\n      return { ...state, highlightedClickedVessel: null }\n    }\n\n    default:\n      return state\n  }\n}\n","import uniq from 'lodash/uniq'\nimport {\n  SET_CURRENTLY_VISIBLE_TILES,\n  SET_CURRENTLY_LOADED_TILES,\n  SET_CURRENTLY_SWAPPED_TILE_UIDS,\n  MARK_TILES_UIDS_AS_LOADED,\n  RELEASE_MARKED_TILES_UIDS,\n} from './heatmapTiles.actions'\n\nconst initialState = {\n  currentVisibleTiles: [],\n  currentLoadedTiles: [],\n  currentToLoadTileUids: [],\n  currentToReleaseTileUids: [],\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case SET_CURRENTLY_VISIBLE_TILES: {\n      const currentVisibleTiles = [].concat(action.payload)\n      return { ...state, currentVisibleTiles }\n    }\n\n    case SET_CURRENTLY_LOADED_TILES: {\n      const currentLoadedTiles = [].concat(action.payload)\n      return { ...state, currentLoadedTiles }\n    }\n\n    case SET_CURRENTLY_SWAPPED_TILE_UIDS: {\n      const currentToLoadTileUids = uniq(\n        state.currentToLoadTileUids.concat(action.payload.tilesToLoadUids)\n      )\n      const currentToReleaseTileUids = uniq(\n        state.currentToReleaseTileUids.concat(action.payload.tilesToReleaseUids)\n      )\n      // clean to load tiles of tiles that needs to be released\n      const newToLoadTilesUids = currentToLoadTileUids.filter(\n        (tileUid) => currentToReleaseTileUids.indexOf(tileUid) === -1\n      )\n      return { ...state, currentToLoadTileUids: newToLoadTilesUids, currentToReleaseTileUids }\n    }\n\n    case MARK_TILES_UIDS_AS_LOADED: {\n      const currentToLoadTileUids = state.currentToLoadTileUids\n      const tileUidsMarkedAsLoaded = action.payload\n      const newCurrentToLoadTileUids = currentToLoadTileUids.filter(\n        (tileUid) => tileUidsMarkedAsLoaded.indexOf(tileUid) === -1\n      )\n      return { ...state, currentToLoadTileUids: newCurrentToLoadTileUids }\n    }\n\n    case RELEASE_MARKED_TILES_UIDS: {\n      return { ...state, currentToReleaseTileUids: [] }\n    }\n\n    default:\n      return state\n  }\n}\n","// TODO MAP MODULE remove whole reducer\nimport { SET_MAP_CURSOR } from './interaction.actions'\n\nconst initialState = {\n  cursor: 'progress',\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case SET_MAP_CURSOR: {\n      return { ...state, cursor: action.payload }\n    }\n    default:\n      return state\n  }\n}\n","import { combineReducers } from 'redux'\n\nimport ModuleReducer from '../module/module.reducer'\nimport TracksReducer from '../tracks/tracks.reducer'\nimport HeatmapReducer from '../heatmap/heatmap.reducer'\nimport HeatmapTilesReducer from '../heatmap/heatmapTiles.reducer'\nimport ViewportReducer from '../glmap/viewport.reducer'\nimport StyleReducer from '../glmap/style.reducer'\nimport InteractionReducer from '../glmap/interaction.reducer'\n\nconst mapReducer = combineReducers({\n  module: ModuleReducer,\n  tracks: TracksReducer,\n  heatmap: HeatmapReducer,\n  heatmapTiles: HeatmapTilesReducer,\n  style: StyleReducer,\n  viewport: ViewportReducer,\n  interaction: InteractionReducer,\n})\n\nexport default mapReducer\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { combineReducers } from 'redux'\nimport { Provider } from 'react-redux'\nimport throttle from 'lodash/throttle'\nimport { trackTypes } from './proptypes/tracks'\nimport { heatmapLayerTypes, basemapLayerTypes, staticLayerTypes } from './proptypes/layers'\nimport { viewportTypes, popupTypes } from './proptypes/shared'\n\nimport Map from './glmap/Map.container'\nimport {\n  initModule,\n  setTemporalExtent,\n  setHighlightTemporalExtent,\n  setCursor,\n} from './module/module.actions'\nimport { updateViewport, transitionToZoom } from './glmap/viewport.actions'\nimport { initStyle, commitStyleUpdates, applyTemporalExtent } from './glmap/style.actions'\nimport { updateTracks } from './tracks/tracks.actions'\nimport { updateHeatmapLayers, updateLayerLoadTemporalExtents } from './heatmap/heatmap.actions'\n\nimport store from './store'\nimport mapReducers from './store/reducers'\n\nconst mapReducer = combineReducers({\n  map: mapReducers,\n})\n\nstore.replaceReducer(mapReducer)\n\nconst throttleApplyTemporalExtent = throttle((temporalExtent) => {\n  store.dispatch(applyTemporalExtent(temporalExtent))\n  store.dispatch(setTemporalExtent(temporalExtent))\n}, 16)\n\nconst updateViewportFromIncomingProps = (incomingViewport) => {\n  store.dispatch(\n    updateViewport({\n      latitude: incomingViewport.center[0],\n      longitude: incomingViewport.center[1],\n      zoom: incomingViewport.zoom,\n    })\n  )\n}\n\nclass MapModule extends React.Component {\n  state = {\n    initialized: false,\n    error: null,\n    errorInfo: null,\n  }\n\n  componentDidCatch(error, errorInfo) {\n    console.log(error, errorInfo)\n    this.setState({\n      error: error,\n      errorInfo: errorInfo,\n    })\n  }\n\n  componentDidMount() {\n    // First trigger synchronous actions that should happen before any map render\n    // At the end of this, set a flag to allow map rendering\n\n    if (this.props.viewport !== undefined) {\n      updateViewportFromIncomingProps(this.props.viewport)\n    }\n\n    // TODO\n    if (this.props.glyphsPath !== null) {\n      store.dispatch(\n        initStyle({\n          glyphsPath: this.props.glyphsPath,\n          // TODO apply URL updates here\n        })\n      )\n    }\n\n    if (this.props.onAttributionsChange !== undefined) {\n      this.props.onAttributionsChange(store.getState().map.style.attributions)\n    }\n\n    if (store && store.getState().map.module.token === undefined) {\n      store.dispatch(\n        initModule({\n          token: this.props.token,\n          autoClusterZoom: this.props.autoClusterZoom,\n          isCluster: this.props.isCluster,\n          onViewportChange: this.props.onViewportChange,\n          onHover: this.props.onHover,\n          onClick: this.props.onClick,\n          onLoad: this.props.onLoad,\n          onLoadStart: this.props.onLoadStart,\n          onLoadComplete: this.props.onLoadComplete,\n          onClosePopup: this.props.onClosePopup,\n          onAttributionsChange: this.props.onAttributionsChange,\n        })\n      )\n    }\n\n    if (this.props.highlightTemporalExtent !== null && this.props.highlightTemporalExtent.length) {\n      store.dispatch(setHighlightTemporalExtent(this.props.highlightTemporalExtent))\n    }\n\n    if (\n      (this.props.basemapLayers !== null && this.props.basemapLayers.length) ||\n      (this.props.staticLayers !== null && this.props.staticLayers.length)\n    ) {\n      store.dispatch(\n        commitStyleUpdates(this.props.staticLayers || [], this.props.basemapLayers || [])\n      )\n    }\n\n    if (this.props.tracks !== null) {\n      store.dispatch(updateTracks(this.props.tracks))\n    }\n\n    // Now trigger async actions\n\n    if (this.props.temporalExtent !== null && this.props.temporalExtent.length) {\n      throttleApplyTemporalExtent(this.props.temporalExtent)\n    }\n\n    // eslint-disable-next-line react/no-did-mount-set-state\n    this.setState({\n      initialized: true,\n    })\n\n    // heatmap layers\n    if (this.props.heatmapLayers !== null) {\n      store.dispatch(updateHeatmapLayers(this.props.heatmapLayers, this.props.loadTemporalExtent))\n    }\n  }\n\n  componentDidUpdate(prevProps) {\n    // tracks\n    if (this.props.tracks !== prevProps.tracks) {\n      store.dispatch(updateTracks(this.props.tracks))\n    }\n\n    // heatmap layers\n    if (this.props.heatmapLayers !== prevProps.heatmapLayers) {\n      store.dispatch(updateHeatmapLayers(this.props.heatmapLayers, this.props.loadTemporalExtent))\n    }\n\n    // basemap / static layers\n    if (\n      (this.props.basemapLayers !== null && this.props.basemapLayers.length) ||\n      (this.props.staticLayers !== null && this.props.staticLayers.length)\n    ) {\n      if (\n        this.props.basemapLayers !== prevProps.basemapLayers ||\n        this.props.staticLayers !== prevProps.staticLayers\n      ) {\n        store.dispatch(\n          commitStyleUpdates(this.props.staticLayers || [], this.props.basemapLayers || [])\n        )\n      }\n    }\n\n    // loadTemporalExtent\n    if (this.props.loadTemporalExtent !== null && this.props.loadTemporalExtent.length) {\n      if (\n        prevProps.loadTemporalExtent === null ||\n        !prevProps.loadTemporalExtent.length ||\n        this.props.loadTemporalExtent[0].getTime() !== prevProps.loadTemporalExtent[0].getTime() ||\n        this.props.loadTemporalExtent[1].getTime() !== prevProps.loadTemporalExtent[1].getTime()\n      ) {\n        store.dispatch(updateLayerLoadTemporalExtents(this.props.loadTemporalExtent))\n      }\n    }\n    // temporalExtent\n    if (this.props.temporalExtent !== null && this.props.temporalExtent.length) {\n      if (\n        prevProps.temporalExtent === null ||\n        !prevProps.temporalExtent.length ||\n        this.props.temporalExtent[0].getTime() !== prevProps.temporalExtent[0].getTime() ||\n        this.props.temporalExtent[1].getTime() !== prevProps.temporalExtent[1].getTime()\n      ) {\n        throttleApplyTemporalExtent(this.props.temporalExtent)\n      }\n    }\n\n    // highlightTemporalExtent\n    if (this.props.highlightTemporalExtent !== null && this.props.highlightTemporalExtent.length) {\n      if (\n        prevProps.highlightTemporalExtent === null ||\n        !prevProps.highlightTemporalExtent.length ||\n        this.props.highlightTemporalExtent[0].getTime() !==\n          prevProps.highlightTemporalExtent[0].getTime() ||\n        this.props.highlightTemporalExtent[1].getTime() !==\n          prevProps.highlightTemporalExtent[1].getTime()\n      ) {\n        store.dispatch(setHighlightTemporalExtent(this.props.highlightTemporalExtent))\n      }\n    } else {\n      if (this.props.highlightTemporalExtent !== prevProps.highlightTemporalExtent) {\n        store.dispatch(setHighlightTemporalExtent(this.props.highlightTemporalExtent))\n      }\n    }\n\n    // viewport - since viewport will be updated internally to the module,\n    // we have to compare incoming props to existing viewport in store, ie:\n    // update viewport from incoming props ONLY if zoom or center is different\n    // from the internally stored one\n    // TODO FFS incoming lat lon should be an object, not an array\n    const currentViewport = store.getState().map.viewport.viewport\n    // stop propagating updates from outside when zooming in\n    if (\n      this.props.viewport !== undefined &&\n      store.getState().map.viewport.currentTransition === null\n    ) {\n      if (\n        currentViewport.latitude !== this.props.viewport.center[0] ||\n        currentViewport.longitude !== this.props.viewport.center[1] ||\n        currentViewport.zoom !== this.props.viewport.zoom\n      ) {\n        // if zoom delta is precisely === 1, zoom with a transition\n        if (Math.abs(currentViewport.zoom - this.props.viewport.zoom) === 1) {\n          store.dispatch(transitionToZoom(this.props.viewport))\n        } else {\n          updateViewportFromIncomingProps(this.props.viewport)\n        }\n      }\n    }\n\n    if (this.props.cursor !== prevProps.cursor) {\n      store.dispatch(setCursor(this.props.cursor))\n    }\n  }\n  render() {\n    if (this.state.error !== null) {\n      console.log(this.state.error)\n      return (\n        <div>\n          <h2>Map component crashed!</h2>\n          <p className=\"red\">{this.state.error && this.state.error.toString()}</p>\n          <div>Component Stack Error Details:</div>\n          <p className=\"red\">{this.state.errorInfo.componentStack}</p>\n        </div>\n      )\n    }\n    // won't render anything before actions in componentDidMount have been triggered\n    return this.state.initialized !== true ? null : (\n      <Provider store={store}>\n        <Map {...this.props} />\n      </Provider>\n    )\n  }\n}\n\nMapModule.propTypes = {\n  token: PropTypes.string,\n  viewport: PropTypes.shape(viewportTypes).isRequired,\n  autoClusterZoom: PropTypes.bool,\n  isCluster: PropTypes.func,\n  tracks: PropTypes.arrayOf(PropTypes.exact(trackTypes)),\n  heatmapLayers: PropTypes.arrayOf(PropTypes.shape(heatmapLayerTypes)),\n  temporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  highlightTemporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  loadTemporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  basemapLayers: PropTypes.arrayOf(PropTypes.shape(basemapLayerTypes)),\n  staticLayers: PropTypes.arrayOf(PropTypes.shape(staticLayerTypes)),\n  cursor: PropTypes.string,\n  // customLayers\n  hoverPopup: PropTypes.shape(popupTypes),\n  clickPopup: PropTypes.shape(popupTypes),\n  glyphsPath: PropTypes.string,\n  onViewportChange: PropTypes.func,\n  onLoad: PropTypes.func,\n  onLoadStart: PropTypes.func,\n  onLoadComplete: PropTypes.func,\n  onClick: PropTypes.func,\n  onHover: PropTypes.func,\n  onAttributionsChange: PropTypes.func,\n  onClosePopup: PropTypes.func,\n}\n\nMapModule.defaultProps = {\n  token: null,\n  glyphsPath: null,\n  autoClusterZoom: true,\n  isCluster: (event) => event.isCluster === true,\n  highlightTemporalExtent: null,\n  tracks: null,\n  hoverPopup: null,\n  clickPopup: null,\n  heatmapLayers: null,\n  temporalExtent: null,\n  loadTemporalExtent: null,\n  basemapLayers: null,\n  staticLayers: null,\n  cursor: null,\n  onViewportChange: () => {},\n  onLoad: () => {},\n  onLoadStart: () => {},\n  onLoadComplete: () => {},\n  onClick: () => {},\n  onHover: () => {},\n  onAttributionsChange: () => {},\n  onClosePopup: () => {},\n}\n\nexport default MapModule\n","import GL_STYLE from '../glmap/gl-styles/style.json'\n\nconst AVAILABLE_BASEMAPS = GL_STYLE.metadata['gfw:basemap-layers']\n\nexport default AVAILABLE_BASEMAPS\n","\n  import React from 'react'\n  import { MDXTag } from '@mdx-js/tag'\n  import { Playground, PropsTable } from 'docz'\nimport Map from './index.js'\n\nconst layoutProps = {\n  \n};\nexport default class MDXContent extends React.Component {\n  constructor(props) {\n    super(props)\n    this.layout = null\n  }\n  render() {\n    const { components, ...props } = this.props\n\n    return <MDXTag\n             name=\"wrapper\"\n             \n             components={components}>\n<MDXTag name=\"h1\" components={components} props={{\"id\":\"map\"}}>{`Map`}</MDXTag>\n<MDXTag name=\"h2\" components={components} props={{\"id\":\"description\"}}>{`Description`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`This component displays and load fishing activity and fishing-related layers on a map, used in various GFW projects:`}</MDXTag>\n<MDXTag name=\"ul\" components={components}>\n<MDXTag name=\"li\" components={components} parentName=\"ul\"><MDXTag name=\"a\" components={components} parentName=\"li\" props={{\"href\":\"https://github.com/GlobalFishingWatch/map-client/blob/9c5179358d4870c0fd4c2c0742917e72e6025c59/app/src/map/components/MapWrapper.jsx#L5\"}}>{`Map client`}</MDXTag></MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\"><MDXTag name=\"a\" components={components} parentName=\"li\" props={{\"href\":\"https://github.com/GlobalFishingWatch/vessel-profiles/blob/aa0e17395f6a4947bb3fdf3106cb9d0a744ba64f/src/profile/components/MapWrapper.js#L3\"}}>{`Vessel profiles`}</MDXTag></MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\"><MDXTag name=\"a\" components={components} parentName=\"li\" props={{\"href\":\"https://github.com/GlobalFishingWatch/data-portal/blob/96b1e24efcff58ade672a67229da0610d9d241ab/src/map/MapWrapper.jsx#L2\"}}>{`Data portal`}</MDXTag></MDXTag>\n</MDXTag>\n<MDXTag name=\"h2\" components={components} props={{\"id\":\"available-properties\"}}>{`Available properties`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`TODO: fix crash on PropsTable docz component`}</MDXTag>\n<MDXTag name=\"h2\" components={components} props={{\"id\":\"basic-usage\"}}>{`Basic usage`}</MDXTag>\n<Playground __codesandbox={`N4IgZglgNgpgziAXKCA7AJjAHgOgBYAuAtlEqAMYD2qBMNSIAPOhAG4AEE6AvADogAnSpQL8AfIwD0LVmJABfADQg0mXACsEyEFRp0CDSQCojvVO3YAVPBDjsAwpUwBlAIYYARpSzs8rux4wdOyuAK4ElESuBBDkrlBQAJ7sAOZ0MALRMOjsoXBoKWYWAAZUmHDu6F5YGcU47ACSYOyJlKEA5AIw7OShAhBtdniUAO7sBH4Evq4ADjPp6IotbT3uRT14MOQA1uxtU20C7OiU5EMZMIi-BAQzcIiSkikQE6EeOFREkqiUrGiJkjK8Eq1QyZnWTWWoXY2Hm_To5G67mScAIAlCKRSsDsIxeeHGNjsFU83iWM1g_m6mVsSPMtjgoRg62oqTxb3qiAAlGYjJIzBAiDNKAIpgAlGCuchTMBCIjsToSqXtADc_MFwrFioIABEAPIAWXYMsi8q6koIAFoTkQVWqhSKHJEhah9EbZfKcJJsK5BbBbagzOLzXr9TguhgMgAKdbMNhidYWRh4ADMYkc6pdNE46pF2XYuImPScwJJNQEiCkKfj5gs7EYMzEkYaUyiyRdedc6BYMWo8XYMyEd3GlFSMCmL3Y4cw_VQKXzMASnKkDYTdfTztdkmriekccUZhOvSI-hwaQIAFFYMeaAAhRINdCRzrCAjtbmoTnKhTKb2-mA4TQyB0ahaHoRAVBzKZ9VmN0TXaT04AEchJCiGZJFUbAALgf0BXtTVzVguUFXNdo7Q1dhgHYTQfHkQj5QAARgIgRAGVBAWFGBSIDVBdFRY5TgAL2cAhEmxdhuAo9YogEZ5UCudoAAZ2GTGYsHafcaxmTsWFneSABZVPYAA2VT1PWMAQIAMR9aBEnk_hnEORFHUwdgAAUhH4JZmJ-OAtMRMyawsmhnAgATLnYABGPSNPkcEeOoPiAEE5nE9hI0o8gbCgdBw3YeROXEsR0pjGR2FRUSYG4YBDyEkTsXkbda2ALLoFy4IADIOvGRJ5koZpWpyvLuBG-UwFCHie1Qdp2AAfg2Nrw0jQqrkG9rUDimspBkat3zMWFyMwMAwigKZlqKkqtpSlca0TIMpRwSzMhSa8CCa2s62gmZ2D-GARjw6rMv0DIrgAbQUnAFIAJiMpZIqh5McCMyKAF0lgE4QiCuABWfLaK3VcpHughHue16mqka7drMb8QEQ5DUPQiMNC0CgQP0BgDodSijpOqZaONIjPVQriuamSjIAISxKBvNoMDgJYCFcGSxy-gA1eA4AXfK6PgyRUQ40WsDwijRylzIdllib0AVs3LAt7ZLAFGArflnXBY9SRwmgOAnjHe3JW2V2baNk2eZgY7QlOkI7CStWkoaAAZJKb0T88AH0byS5xz31JK3Ocd33T1jxKVQ7CaaUOmkJQ2Za5mLCgN0UCDHA3DyOJ3WzSVMiHQ8ygZksXr4F1gcB4tET5gr1B2-5osiA8NAYHFdBQkRAQ7AF4uulXtTe_F9yhD-aci7g7vLR30I95nyCCSEG5YF1qAnH8PBJAme-CD9ffTbRQOh6nqfIWkgx4zEnvAd-Dtp6zwPpsaIqFE6uESBkAB8Alily1ggpBKDh621RNEWIiDkECFQZvXWnpQHgN9lAbBG8uIwNNr9f6GpSFkgHqEQeuCgGe0obg_Wfgd5cR_l9chTwoCMy-h8ECrgl4CHobfYA6w0AvH1E4KOMANIWC1lLJi9p4jniwC3TR5UxwAAkIApDwFACxhBLC6OFPowx-hjHaPsH0OAwpYqiOYqvWAKE1GwBwOaVi0CFG5BmOgLIasIB_TworTIqB8hTWlgALUxtwvWWJGZMLwkEqUIT5Fh04DPAgwlKpLE-EQF4ZTYAAFUIlZFtrMckiQ7E5kcS3DJnosl1wqoE4JiVCnkUohwyJtAA47DIR7PWf9JmQMDnAPJU1QlFNGVkUxEpiCzCIRkW2azaA7IEInSgnY2l6KgAYluUzi6ejgVstCdzUJLIKfFBhBsuiiPeZxH-qEV5r12Z8iIXRJCX3XtPMwvEWyzD-evNKnxF4uhhbsjKUlZhXF-dkf5G9Yp7USUC_8XRySSmXpi9ekYMWr3XriyFd8RBfxgNdJIZyHEXKcVmCSH86WwEjJGWg7TWUt0KtwYqiiaxfJwCwPy0QsqRmaUy-xmQBX6F5Qqjp-hOTvi0fiiVtgtIEBldo5lirLnKr5eck1NANVmCUFFIy1LEpTH2TAaJsSNRPUiA0BKVTZz9yHBJSMaBPgFBdcwkUQqRXrHFZKvVMrVxOpDXhFFt1aw0JiAQUImAriBsiMGmJoaSaIj0AIcGaNVwWGfrOF4GaIrZu9SkBNGoPjA2LajYxH0MaRCzV63NrqRQ4A7UQNt-VNXsHfJtCFNC4B2C-qo3x3RsCgRtuwYmOB1zUFdKKrVWQ0qbtrMomI8QwrZCuMdKAWsh0ZCEOWdgqAo5QAvQIK9nqLJXFvQkYx46ayfA3DQbUXB7DSrwJGS9niYSPuFM-yghVd0WF4pQQJz8UjAfAwIJYIGBCQZHRYCYtgcDaOElkJNH0LDoauOhodJGUOQbI1R1AFkh0FXWJ-2DTp12_q4KoiaBBzowfYI8dglkIAbymGiCxaQjhwESDxPAQgfh5BCPkxKBJojlWGFHHIfg5jBECBZD5yJ2CoUnHQacq5-NJRE5sGEGA9jNBw3gscIQjQ0LnBEEICRRgGZglODIBR4ofQgM0XlhIcCgMWTk8iABCUa1sI5L3QNBst4SxnOrzXhd1RBPVBp9YOOAQXcOhZwOFsNq5mO1n45YXUepVwBfSnZkLOXTxJBmHgOAbloj4iixJN9UAEvJq1RxHVUr9VAcSxYfdNSYBEeIx9LEvUWttYmFcOrBXZvNda-1ijxHyuVd1CEOYSR2C1NFInJLjTfAXFG8OxLWH8p-b3YF5bDXqDmdEx4b2iV7B-FnN0TruQIyQBdPFySfWCT5ae6gF7_Q3vLM--4NIkZxVngI7QZaOAnl9P_NEV773Ek3dK2NwLXz2BdXKtqpHSsUecjR7MNHAT_wRG2MEEaEkYsA-yL16bUbdWAejCDsbJTZ3qKm9N7DlBGdyVB4sgrDO6CbY-mECI9goB5FoAINJnbJf1YHoshXlAlcq4yOrwdl2xtwH16iEGmuCu2HN6ruXtZqANpFLD77S3gsFcd6ljULu0j24sNQUxvxLePe1zgAPQfUMm72KgJXsRthu7B6H6gsedh--j8czsCepfg4z4sKP1Bc8EZFFnrXdww-oEL0rEUaeC8nPQOuWAtAS8e4r3XhvY4NH55j8_LWbl2EzGb-DpXlBe_95rxDm4UOcdm6-2kQfSeJ_Y5h7PzvfOrsg7x3dgntX3cNZsJY6xlidH8otVMX73XifdRD2X_fVibHH_NWykmsBZwTA58RrnQ2DVmJsYf2xqqlUaA8ts9Q9b8_8H8WVT8rVk18dOBAtEtgDS9FkMEmJtlaE7Bz871L8rcGsUCsFiFFkX8Ug392AAAfUghA6_RZfBGIcgQ5DA0aC_EnKgvDCnQhdAnAIgt_Vcd_D6T_GNEbNfSpapeqGAepZLXLFgmg9gggsg0g9gUGNGHA0PPAtA2Q8ghQlGG7CwTfbifzB7XfUPWZbYBgrrO9Xg2sfgnnJ1CZEwxA6XKBaAj6WA_jAAOQ81E0xAyBjik3IAU2WS3zgJ30TzLzNUgKf3YEwISGwJYLCONSf04LoGILwAsOwxky5QZX21aQANP3sIaziLVUtRK0CP43gGsRoCtFsFcA8FgAtBdEMQtHKKpC1G-EoEqPQAtGYi4wtG0R6IpyZGTTq3w36OFz3RKQgEPXCnQCW3RFX2cNxQ-n40eRghoQIOqwMJCMWWWJmHoMiMYPMOB0521WjWsIaVoA2XgTUORRYO2PoMVkMLL2flORyKfycNrE2gsFK2_TYx1C4HEMIwHBgFYF9TgAsP42MLgHWOCJANCKgT2IkkBOBPyMcMOI_2OO52G0jBsKgTyKMMcN0NM0kHO0uO-lWN2ShNxJv02XwIBV-0RJBPwGpKuI3lSNJwGxOMxKdQuPuXoMpK2KZJ2PQPuM2M4LryNUKIIDeM-JKKJNUO-iJOkL8LJI3gpMoIeOQLLmZNMJvSwOYPVJwDlPoMSNfxSLkLVJFMVN2KiKgBiP1MtI4K4JSJ4NRP0MuhF2ULL0NPQPhP7C6CRJUM1MFPUIoLXykLYLoO9LpL9IZPtLWI3xdLRPZIxNjTXxYyICqVKVEP-NoEkLtPDN2I0MUOFJhI1MwS1LkM0O0NrCrI-PeJlPYCePQHFMANEGTRqz5NFOeJPwiOtNtJFMbObNP2NOSNZPbMu3pIawHJeM6WZx1OiPIMuwiwnNDynO7JbmHMLAXNDP1NXMfxbhLVPH9mdnOijKBIZN3PCP3IUhRkPKlmPMKi3PdJYIvPiP3NRlvKdmPBPNGmXMeLFOnP0FBnfLPE_MmyrNZP6y6EGwEKxLOJgEOVz0HKf1zP7P_LXPVRrOKOTXBIApoApNiNwrP32OiL1JFIKJbI3NNN423153dN_MWXItP3EmIptMfJFyXOjPyMIsorNO3LIsIoPJAvvJ9PopwEYqf0EqPK_IfJDKfP1PErfJvKEukpEs4qMIEuAqkrAuuwTI-k5QfkyJaSQpbg7IUvVUS1rOlL0LKyJLAPv2Mv0Hwv1LsqPwcqzF7NIpLPwF_3su4sdNHPgLX1Epcv_3QvZRYt4vdI4rPL3x8tcr8qSM3NkpFxuLitCr3MAuvI_OEs6yj2CrSogNfMyqUq0vOjYum1SoP18rCoICApKrvJUtytTN9JitAIKrctqs0oau0vjOossPRK_yA20XMSqvipqo7JCsKolKlLrJgJhDPW6D6vbMqrvzGoyvcp_LUpv3asIogrZKgo5O_wIBGtWvSsvNNWcp2pqpmqsucPrKKymAtHKkDW6AevzGgBtMCFO1oByDQFV1QHiAO1cwmG6B8XUSHX4xGG6D8FYG6Fc2_WVm6FrQKF9O12HBhCwFsBiFnB-i9wdDQH2o0U4EuEJO-terxulHdGRpxtC3YF1FcMTgAE0giB09gjhC1VdOA7AWAwAwALg8LsKiSPYQbil_rAaUR8Uch11SaKs9QBNLJC5qa5xU0GyWQ4A1Mcp2Avr3A9gPB1AtgCAlgfgpgdblZMhEhVwaVehH19AncpgJJEcxxkcwLqcG4HrCsKbSaDZvpQFXAUgCEcanU7APZ9h8hXIRhNhzAB0Ua0BVSQcWC3rftWc4tL9EtHbMzCMqcnl3brbwxzZ3AklWJmKzCEhnSlrAr3Tc7baKbOCCF01XJfsE6a6OaMgS1IqRcq6aA7bRTK166ftRom7e0C1m06r27ptO6CBu7WbG79T3aB0dK-qLB-MatWbMBTpXAuaWryAaQDtZzIp0Z0kCx8QN6_5EkXhWJLt2zoIJggkPBcsJ6p70knrB781-1MYhVRpIo9rIL_xDqgNT7C7qBUlMYOyHqbr3j5qtZdLiN40Kb0tMsc1sttdQGKaqzbriNLLbtrKaKWDraPEjhTz_Sy88HhRWSrDMTXF3FhQOySGBAZrazazvMBAeMnLcMaD_x0MfTutWS4MENKAkMhj-icB0Mqyuh00BBzBaKRdYxZAo8kwoYxARFvjMwphyBMh1bsgItKwFG5HvpyBJ04BXCfQqp-Ad5xBgBBGshhGUM-zqChH0MxLKBhIZwkNOR5Blx3ppGdo10VH2ACMdh2BzwbHtQxwZEz0KxdxZHmr6wegDGjHjw-BBBshzHLHaBrGn06NKApEMx9B_Hth3GQFPGPpto4xrssLFiiSRhqB2gpgmGQhUBEgcMcadMOJ_CQlil54f1fj0BOMswYbuhAhghPDxNknk0xG-hzBUn_x90JjrEpifS0RGQ5o5ybSrgpHin-5j5vCvlqovlGpLtGARFgAcATmqD8Yim6xJBNmuAMhPGR1NpP0Z06dS9SEd11gZcJdfVSFWCXHjEHqrgvncE8NNNJsHrSEqdbBxQABHUIITbIYxXXW3Q3TGAFwcb5rweDYxG3ZXC3a9QFqeHAcaHiYxCE1Fgeb5s2pBXUMASMfF-AYRrAc0XlB2cFzkYxW49AslzhAlylxIal2ltFoF9W2YSbDl4hVlklwirlilx9KlmlulxZNAfBHiGAfl7ULIDVdlq69aggaVoF3l_lhVnAJVpWFVtVjVtl9YF8iUvVnl2Vvl-VwVglk19wREc12gTV9YL0gg21-lg1x18loVkFyMb1nBKeT1sVfMzlw-QNu182w1p1-l4V-YBHKN8V3BCN2DKhvFxNux359YfjXoA2Igeg9YYYWGgQPvGYDhX16g4NoUat7l-AS1r9axHYKtmtmNptutkVyMBtjhcF4xVbebdrWtn5goYxT3Ien3CKI1ol8gSd1vTPLt75-dxdyvZWXVldoFtd5kJd-vJ0RvWd3NwliaBdvdlPePbdgl3dmscPCtsd29_3RfKfZfOHY92N-lp96PYfUfRtx9s92KeKJ5udCVCOPmEEt5msD519O9IdprEdxbFZhF8IPXHF1XI3GYxkLFs3dDy3YDWGy1C6IEk8bFg3I4WcxZuY3wbV86mgWD99d5qBBj-9MtiPDtgfZD9YfRuPDjlj9lgU-g_j95qVrjmsa1ls4TmsUNjeKTrdWgoTsTrNjeYUOT6PO2mdtZ8NCiJQPd3PLTi6YAXTu9_dovLd86YVHT9dtvQ9jvAzyzozxdy9-zkVYz59wPB99KbTxzvdyHCAaHEJTTrzwztzn9nvGAPj4Lhz4zz9MWY4cDqOKCWYQXWASuZQemeufWfFJmNQRubQZuDmNuMJb489HoM0WgYSDiJYOVRIfULgdAWAEYRGjJS-a-BhV4VAXYaZVriePACabYIRG-IpSwUUJKVw5wBoSwBoem9ObUI7JKKb-mrpbpcROud20FDIIZOeSWaWYOOwfwI0F4XbuWG2JKRTVAeJAu8-6gc8azLeOCE5sRbJGugZRJQbxvTpkfGAW7r7MFOFVjLWfkCu9KMeREKdYR1AVgHAPONydOUUc8ObgADTh9zl1EsAzm1HPBvFqQAHEKzQfNYIeof4ekp7BLB0585YeYeUekeUf9Q0eMesfcfCoup1gCfwe6AofXDKsM5zxXC1Zi75RMBYbn4ZhXouJ38raAeYAAB1PEEJ1gaWeDOwCSLoGFuFp8LoZiWgC0Hr4XiIZXt8bJoULWOXiYBXpXs9bj6Xn711gFCSEr2X-XoEy33LXjAG48eSERMGv0IdM0U6Z2LD6jiwYYVED3iKdoZ-OIKAUP18IdPCK4AADgUhT6HSiCwCSjn2UgUiHXYbcHGPCmvVTY1YugynYBOdYKyG8jRVNgr_YddqWG2Pkm5_J5zlFAaCSkTgaBSQR5mlogKg_THXihpSJwd_K5gEq66B5W85tUc8-61lt5VY3llSyLq67Ea8RqC3641VxTi5pSrzPHVk1m1n9S4G8-t7xXGAdjSnTudtRyeQhIlWiFcEJdUB5UlIuhJi4EF64EcecYKGWgjpyGMqHbjLBO5wAzuU0ZloHEPJgDrYoJBYkZnEaTMHYYlZ2E0T27Wp9oxsciDSlAF7c0oIbcAef0jZJlBqkYfAeAMgGsQiB8At4oamdj7Bp-hnUmu2EwA5ADuItABtd3MDGZN6xtLWjABRrR9YAUtcwJAGEyHcpYcAt2MMzBBtlCcZOJ2iMSzo04c6fQPOgHDPpTQuGBxPqsAP_oJJAGqAW7o-HoZMYlgI3MbhN0W6uFZu83WwewAADUUUIftxDi68xEuhNNLtXAZh1xvYZ6P2PnUtjgC8ubMPQGBAggmwCAHgaoLrHojiMwAkgWId4EG578HUdsFls7AIH-o0glATQNQBIEsZL-MQY8DulJybsrgz6fdIkDQwYArgSkWsu2TyEFDzAJOFoR4lQCEtNkfQZtgmQ6HUBuh0QXoYsl0znhJQQGCgT0K6BFDiMNKPwHAFAoq9LsfNYYVBVAQZAYgI8VnmvlWHiN_wGwkUDEkWRUBhQOkLIL6k2HHDU6uw6YQcMHBXD6WpwgQOcNoCXCjh9LUodsI6grC7hpeR4ScOEAvC0AFwh4R8IYrOxCCiVfEMVAUiJZ2yCwpYXtT2G9D_h4IqRGcJBFvCwRWwiEceFGHChxhMqSMMli-GzD3S7ZUkc7DrDjBnYlfMNNAwqp0j8EDoCSFSOPBR5aIC4KBpSKyBfD2AxUL4RDyByL1iMQovgWyL5HOxORl2RjCDkwZyj0G4zCRgoSFEsjDatI48MKJRhYD3BOAh0DShAoOwch6UAYR-BYFfoMhXgeAWlBiHVBIwZokdMqPMC8ZvUiCLdtaPligxkwpaZNG6N0ha1wBJaNPq4CwDuirgnom2HVRDFhiAxkYuAKDChi-irKm0WmBl0ZhylfYGEFmE3HZiRCGEOPROOnGcCWBGaacchCt0ZhYg-ilUX2BjiwjVNh-GQuOAnGTipwM4WcHODD0LgSRCxxY0sWnDRyhMxkrgUGO0BSBgARgiAOUo0XQLtAdReok2J4Ojgtik4KcNOJnGzi5x84zgHwemLri8Ip48ySZGEOAgRDW4UQ8iAq1HiDgJ4uCNIfqNUYZDjCrzCSLui4BjtUQLjY1nAGhawsd4xiPoFAE_GiZZwxiEcWO0oB60DaxiKgM_Bzafs82E7d5sPEgkuh-WY4s0epHlDzBnMI-bCcnUBxaFjEypDqvcGvZ-t7WCbRCUEiokBtu2OAW9AvAyCZspBe3XUPuzHYYtWOG0PcTXEZiHiIEypRZIBHy55iLxDCa8dMlAR3ip4D4k2PMME60JXxqJD8RRKQmzgfxf4uFnnmg7QB4AY4B8CBPzZio3g4CYychJrB_B8gNRD9gxO4nstGQY7JiYEEjx3t_ILwOyOpMYmhBmJbkiwJAFOi7Ix2_rdZt5OTaTY-qSxJZhHn6DlAGytCXwEsxqzaJEsfXOyd8xckZBNs_GQKarjVjxBGQdgWwI5hYDndlYyQAmhHViD4hFQ-IRnJVP26HcgpmQWyYdwXC6Tps_GSoD9EKkjwSppte1jZjcw2kTeNkx-KwD6l2BIwuoUUM1NVxVll6EUPKRkAKnK54AVwTKFkBSDCgvJoMbGEsCMgowsG02FaQIDWlFTIJ0EqUAxhHQtsQ-EoacJ-ODa8ZjMQoP6uRKNZQT9aN0y2srzvDxMMpQLb6TBNXBmUaAn0k9qFKNbQyT2WUuhvdNrDgyCAcAROJrC4nCAeJnxCFr-JgDq8AJSiItMElhoYzMWuo7AQpKtGBlDkKk98dMXCmgSUgfzWwP51gCkyeJsXR8UWEv6xkw2I8N8UonplGsvxBQLSXjP_HwsC2RJWWrthh7sB6ec3csQ0DsATAVMbAjsNZhSkjgI6FtKySzNsnsyXEC4A2sem8kOTI0xsqUNkEsh3DIZNEiKaMUgAdSLJYE1cJNPWl2yGJsM-2YzMRkD8y2BVU2Ua3Nk1h984Ba2bbOem9teMTsnKC7KZluyppIUuiQKx9kuM_ZiMgeJKE8nOTfJrk2CfBlU4MyTJWiYYCMEQSBBwmZszGViyJn5ISZ1csmUFGgCq5PZMreNvRPblytU5DEkWbOFYk24VcGuYOTXMjRmTUJ3k9dBhMInwt5QWEpYJ0H8Cq55xiMoCfHPAnP8rpP0w2usCxBbzQZvE1AGmP4kHjBwVCfhIjXQCniCu-Y2-FJOLgySqE8k3ARkP7bdsoOxQluM5OLAkS661aXOX5LFn4zJZ4nagM8D7oALXJQCiWbpM5mUzL-YLLhALJrADpIF2U7js2mTkdye5mUvOSxKA5Hyq4-4tCD0jQiSJm4MiF0AIGvniSGADCTKNQBdBSgWuWoXXpija7Fdx-zgS2UChYVaxYAPcIbsMkIgAApQuPdyIgCgiA4Qaot_CEVzwrB9gAANLOB04ycRmueFFDpwGgdgyyKKHprk9dQlkdODj30W1I3Iy3diHRgsRbcD4-jL7hx0sU-8YA_iUDq9xEkrJhFRohZBNmuQPdPQEJY8SYTww8LhQHi2xabFQiepVcr3LpEzBiXndnkiULCBEsojaI9uSwbRHbUu7aDWIpguJe7XcUpLhEMEaZJ6C-iDdDRygghBGVkL-p2G2nevujlEKV8FO6BCFBkLPDckaSG8QgQ0ouhNKac2xRkiSVLYJRL-Z4aJRkABpQA3EKnCjulH6WWdBlDcP6hkFe4fBs2HSiZarDpxzL8GfS_oo0qEZPJnFmy-ZU2Mv4LDul5ZMfpsgn6hLmG6wUGF0qUkEFkx6UMVrsnJFICJmdNa6STAam5YvlLJHirCKYxmB3wVSggFMotgxBYahyB8CrzK73LuFAioFFIxeXVK2l7y4xG4REARRNgHyKGjHAZBlDVZUwZUo0G1B2Ax4WzHIEfQMx05PMw2AkN0ELEJTZCFK1TG0ByhSzBBotdZfXO6DCgb0IgJYDEh6gzBYg4tNlc1JtJUqasG9GhJXM5XeESpgJLWALQsDF8cV3yi0R9GdEVC9VG8MMKSkmyypyAC7NVXQwNXEZ2yEWZUsazrnwrugGhR1bQg9rjSYAhUI1ZKHICJZ-MMvJEGehHBsD0aWULYLsBdAW4cgwkwVXCrYCeT8wkdHoEPLlBYgbV-3D5HSpuboB4RgWJ1ZmqTr_Y4se1ItVAFroEFCWhIiYTyixCHIJVzMH5V1KJLCSeKe9TenkDzCuY6ADIYlamq0h50bVm9aSIzg4HFSXVbAboCSv6bDgo8SxVwLDRCCUqJQfEddAmuJndAGQNRWhPcWCCRqdgeYCUPiA3WqAk1q8cWlHjHLNVy0nqrEFWt2QdrP6Y9d0qaKgCHIhxSsEcT6Rnk5B2hH6z1ceG_XP9MJk4xAGssTWw15xgvKjmg2rKMi5hnSwDcQgfBpQG1nq7_hoWzECj2ASkeaMUAAAkwAJ1VwHkAWhiN2Y-QMUHYBXBSN-a29QpnIAhY8gQGDDahviwyi18iojBpA0WqXZ_VLG9WpGHo2YUQcfqq1SViWCKF7mkKy5XxEP6zBfFhykvsspOU056xqECbNsoU2qwlNohOFFwseWYrFNMwXxUsG8WTJfFHy8lPptrGXcdgvin5Q6uMJObflKorTaIUhLYNuZfECeochx5CAOEyKzzbWMSyOMxFy0cLe2rOk8oesF0StcBs7DP9f1pawHFWVdpxbtOiW4caBvaCoRqgiAFIEFpmAry_pJQh2PQU9RqA4UGg_QAFpK2EEl51W7APy0UUqK1FSUDRVop0Xpw9FBi9OEYpMVmK3IhUFwZFECIfcAc8QL6MpokihbsQQ4lWJ6kjBjiPEfQMHvOIc3bBfFeGJyM21XAfcFt8AXYvNrs2LazwT4YSW-DBkOxdtMW2tcSOMKNrOALazzGZq82nb3tvio0kq02HQCdgVW5mM4M4BLBBYkW57bQnoY3ZptUAWbV5rSiw74dtYkJdxkj5zjq-H22sfQRuxGqkd52-ABCo_DyapgZ4fZaKruVZA0VBtahs8smVFoZl5O1DGbBS4wAmdNmyDYzuzbeQ9l2bZzYFmcVM7dBi4aBkasF1bKYCq4I1ZzviBM6idUKjIZ5qyDSxIO9So5aX13T_NjV_4bOjXQerGJ0-mHbXa7Q9pD1qcWAI3AbrQBG6Vlpu1-t6kt16c68VwW3WctrydhYJ2bK4GTuza6qfVJLMXHQBd3qaG4Zyj5gboJ3e69NWO7lA0vZb-AblQZYKdMDgCJ7eScewmQktdWIqbYUemFVOoRW0IkVfultnKJ01QoZgf6QairpyyEC_62nKbFkopprN9dm687s7R-V_0EcY4O2pGFb2QbXuHe-5kbIIB7c1m8YzvcmSGpjg9utA-WG8VC5RKp11ANZuAiWCpp19YCsHbbIqR4dmdWIHHk7X22T7yBS-rPTQLX0JSNRFaJmUaB32xNyOFmqAIftKTH7h9THK7lNFMEucEyXe7gV_owCACLBF7cLpFws4Rpk0Xe-xX-w4RAGawMXXflzOXFPjUATC7jKig-3K7KAIJCPZXqn017tckKyMF9HfDHy_BaEZxa4vURJLEkNC88ZzC5k0odFk3dOArNqTliJI7QZg-TzYNpxQ4L8y_jnHJ7o99QbkWaZ33TjnhEe6PVwpYDSjtAhD6cEQ2IdG5FipDMhywPwYNEZDFDpiBoDj1MRd8DDwh3OCoYkPqG-echzg7of0OGHbDJh0Q-IbUPSHLDWhlA3xBLFJRRQ5PROLqCSiY85p1hywF4Z8N-GAjbh3zVMHsAGg3IacdHmorCOaL5D0R0Q3EYzi-H_DmiiIzSkUO8GM49gI7M4FmnyHcjlWdg_kcKOzTn52hy_vulZ2EDQsDe-vXaq728ZzJjQVwiwbyPx8kEjZK4KFkH7kz6i8CviOqNzzeF_Uf9TJf0U32dgMgD4WYfv0hFKxBQaUF0GMHVaU5sq0lC_rpqoVZB0A4xjDDkAkiNl5jOQEtUdBToEbiNZx44_IHTjEavh-CQUNRto2aj4AKxmYOsFaNgyJ5nh7wwkcyOigejokZ3aOH2M_UjjD4QYzWHbKu7nm7u9AGZ1S1XH0tCZBE6ByRNmcot8B9YEaruMPghj6Qy_t-iPZHHCBhJoHJZxJFT6LN2Kn1S0an2jF2jKR2I-eHiMZGAjoJvo6rTmPHHYTxQ0Y_0XQ0MncTQpylXXnt7G7TlzzO495poqOqpTpqx0tgUxPUGkT7eWgKidizoneM6pwJJqds6U4idcCgQ-utQAacV8hAgfe3vV00mpjZsDvXapH4imJI5OTOrsdUaA1S4ATB2iHtpxYnLTFNGdndnbIiDfTuwWcn-osLOiidEp3GkPRv4BmHqd2CM4HFGK2mpoztIdKgsTOv056mMIdC3WvSgx3a7tVNFWkwBLByzNdG_VWZgAfKLA8Yq4O7XjHFn3ARuT1K2ebqdnMYnqDs6gCNy6hwgPZs3XECHOYwRzO8v0YMHgrRBjkAY92l0S1jujFzCc-A24IpnmmpghqQioQORkN7d07RxQ8oacOSGXDsh4xFpDBPLtkZOKeKCSdGM_5RqZ1Iquyk-W0d3zH_Gk8ef-Mcn04ehgw0YdMQOGzDzhjQ9ed6PgnJqHVB84uJ3OxMHF_eQgU0bpNOn7TEBhM-w1FMZ0TTcJxQVY1lNBnf2EXFC5cd1Ps4MTAZt3d3mQuNtxTWDM0zUefMEAhd_qWhkeZQnzArgpRxWRUdFBFGQTbPaC8u1obwWyDmXUhZIEKXncPFuY-g0VyKSSwMl_YCADUDPTSwZewoTWhIvlAPVOiGQOIECgtBjxt5qSsmonqdjYh0sdtSxdsUkDbFrLfrOSxZanb5oZ2TiunFQf6SuWf4lEewInFqQljNF6cQKw0GUXpwUkuoA0NotcL2B4e-oSw5Yt0CQAUgM0bbHLTll5HHzjBnQwBZvC6hakrhbUD2PlCKHCrxV0q9kfyvk81YDQc8DLxUNWHyrAF-q41eas1XL-5i7UAtwzjtWmrs0lq-0B6t9X04A1zq9uZYtTBFD0V2KzooSu5xkr1hgC3Nf1BxXFrSV2Q11Y8MAX6ewV9IwtwSOuE8eK1ng0VZzidbQjJ1na1MCsHjdJu03OwXz21DyH7rNgp65IZKu3W_GAF1wgtwaBqx-rDVwa94ZKN_WAbQN8ayDcmsIXprJiUfeAMIET6Nd3FiKBVaKslXnAUF28_TPbPWpEDIx3cz3opqED-9y-1AM6YdNT7ZhvxwYv-bqsw2hrPJ8E_rqYwjou9XJAUs5bgC2WKacBiwF3vct4QZ2AaCm0PuJN5XL-sDJM_6gerZlGT1NwarTeZNtGJ5o1-IxNeZurgbzvJ-W3BUFPHBmTXNkkjzb5tD0BbfGIku4SmDqyJ1qwaIiLXTMBNGVItCoGUPdlFT-VQt4M9OxXxwHP0-_IwTwOlg2meIWvZxFfobNrG4OqtXutWhjvvp2ArNEuvFqVsCEVb5AtWzxd-vk81rG1xK5YZZvLslq4dpiM4kSyVm-6m2es9XcSwDoGMhtzm3BSsv6TebsoXvW8R9tWn32Ad3K0Tav6f7WIwDE0HLdQal9mjDnH48yf_3D3KAkYbrDWeboj1ryS98cyPVbT5nckA6aAsxfcMiZg7ABk41F2Ki0nlbTJrO38ZzvvXHrM3F603eNst3ubbd82_mktvd2Qz_t3e_3cQsDpollADWFOgXD2Bm0lJv-dWbjvgLq0B9UeyszQvn2p7NYP_YfbnuRhArwV9HlovCuRX87C1wu1eajvV3IHDZmB0QG_tw397Ug47jaP9Qo307gGek3hcVtYXIj2u3C3fxHQ0pWA30CSCpfAGjEWzChUGPGLRxoBE4YEwMfANEcV5ogShYR6EPT7iPb9IjxR7I6bPvV0ASHW3bWbN24hNHeAIdJsHvzB6iLagvXTXSMdH4ejXYAoDjBz7s3p75A2e0A3nuL2foDcKu9A_cc90oHED7h2_UiDkOprlDsWEY1dV2X_UANcJ-PfofDZFjz4geGjLAAEA3IPgCSODCWDXkvTgYm4JEFFD35UnaUUGFE-nXd09HEwI2gQlhrd1LHhABcfyu_ThBugsAZJ_UxyD9Aj8NmMANohVkjhMAfYRle4C-FxSJidIKdIyGycRAdiEcAgNpYECa0ES6l7kVpZ0uPgpnSTlJ1gEqfROzd0qjS7UlQBmWDarEa-v0CwCcOrRdKPJ_fjmcLO1LGlxYZQFuePgvAuTogPk6PypPtnpTmuns4XAHOjn53U5-pYueX8Wnsz1Z84Gj55gOUiTmZ887bpEkSn1TmunAGhfZOOnhAZ51C_iAwucnEQd5zc9WeIub0VTlLGbrRe4u7s_GVNJIArRFgJGAKXTAZmURYgoJAxBMz8BFB4Bg1fELrGS-7oTRAX3GdZzM9SegvRj-wPAOML5ekudnr9IV0IG3lEC3nHzwgOK-yfxiP5tYLl0h11c8vPj0Y1cOtq0dSuZXnVdR1DVRCvoNQBr1EMGNXBrqt2Jr6V0vIdd4nrKdNvSgzfTj_WpuUNrW94eLv0y-q4L7F9C86nEZMXEL-Z8iYjebZ8bMBWE6mKIUnySFq3NCPWKKWiTwhLcOhWEnB3iLdYUimRbZIiW6AK2lNOCPRDZelwoAkAdWgUCa7DZ64FoCt5sIiUTQIAULJ-C_HVpewZ4ULCJfpXpS9vIk_bkd3IvoXnYsA0sUUCkA8CWKAhvsVCG28Ll0J_LfjYI1N3sCdbutqi-wCEd1BfXtQYhnRZYCWCeGd3e7zRQe6PdKGk454VRS9bPeyGUr1ANKxZYKMljYr6i298WNqQ3hSxbkJ90sD7HvW3IXh5K3pfgiehIUQzzxQ6D7Eliyx54URNWIxx1iWlrQiy9okOQTYQmkcU6H4uAT1iNu1CzQBEsU1oBD9kQVBBWK9gxBAh1H1ALR6ICoJqjlD7g6wfzj9jUP8h7j9TxQ98HgnrD3I7x-E9oezrPH2HpJ5-t5xRQSisK_e7_eCWKeqinRZ4fisd90er1zgwp6U-HvvDx71T6ouzhxWtP9gHT731E85GALV7iKze8Evg3W-27xz6Z5-sVWtx1PUzy583FdjePHnknQjcI98wNYUoYUDzcIET1HIG2oml0DACHJak8z2YeGbq0hR9tYlYeD6XaCw0IvciWM2OD-Uxf9t8Z1h0x_5lpqbaGXuL2gOxAYuI4SX-Z8ioS9NebS0ZtLXmHmiKF3joMVr7QmS9QB6nloy_usai98BBibdnU2zn_VX427YKvDcsy7dQtVtFffr8QkG-2wK-FXuAFoXePreMgm3_E0V5VG8YK-JXuL0Oh2-vo_oPNj9JLYHvjYDN_qSiMO3WyFgCoqN6DhPME8SeBx54HG7yd4xveFsBj4AxtHtQ8zo9E2Q5ZVC4vfec74n2T_98B_gmMc8F8vQjYmwdU696Fj07QEViEVquWRaWNYE_iiDEd8QLWPE55lumMLmdE3RjitYOYMcyZ0xzHo5esOYvz30nJVAi3OBGLholDdKe598_hJd2D7uqLSjX08AYYE7iqhqqSVuq50IkpFBT4KQR0H3CUfLPaxy_rYCvnVnVW2NgU-MUUdX4gPKymHxDooRmksC15B4r93hZ-gASzX9hKAH0nlepmmDLqT6yxn0DMGLKb1YA_tcgLrKXptr-GsQI0KKuD-ShkgCIOWK3JHXcrqAB2OdRvRqbOwWt18bC1Xnz01aHe1ASt7eWpbdOO8TZZ2OZg8hbAWZ1AA33R1qpZVlKYFCV1MGMzZ__ukPTYSX95raJsgoFKv10G3r5A6_yMo3837gPmRRVImhzBADSgKRlQnAGkexqfWOlF_EAJwU4IsJC_Dk6G4XxvFBgQAFxrpB0fv6_XJalYgvP9RWRX_UKktI4sDVOPIowbG6sxHhiBDQATPJdPmm9dNhX5GVKAMnwyITjAelmJsCW_3P8H_ccXA1yKRAEndsgF_1ADGQGSgQIauUn3SIDKEAN4cqfboAA1P1e_zy0JxJ_wAI4AjAPpR0AGDUo43_MukSxm4T_058rKUmhqxFVFWQAJqueaW8JpFPiHiAmuRIACBugTVQcwWQN22w9OhXWm3lSaQIDiBu1GEAmER1Cc298kQI215p-aETGpFY5HIFcwvqM6VGYPoK2nS8CAQTBalkzPn3p1VtdHQIJsJCAAXkzpFeX59GLGignojAzmlnJuGaBk5QxgdY0CYUMJ8DOkDMFXAFVBAg4HMB6xVoWj8jgcihtV5IJ_U_Uz-LChlorfUbht87fJiAd9U0J33GAXfeNXekIZT301p0_D4xeMA_SXCD8YAEPzD8bKVWmeA_CZl1j9Q_KzCoAuMAFCpUU_VADT8l1JQMz9jwbPy4g9AjIVsA0ZcoL398A3LUv88AoDVGDRxaAOID-UQTA6lKA0aC6CYAHoMtoDA5wNbpUYRMWOkJIAYLKC4_ZZnVEO_ExxFBVg6r0MCW5VuiTEtgtKF2Chg-aHb9gdMjAwBjXHn3rFtEFbTHFrtCVRsCLguRCUJC3SMCcDfghfUccYKbRGR1Y9UQiCdxlbgJJ9CKIAMwDbRMgO5Qz7AQkYcczTIOuo7VYYkqgOqVEIYd6fAn0xCdWeJGQDrUJYD0gU-Qm0Qs0A_c39RDzCezx8GTWYRxDYAPEMdN8fImkPN1gWkJqoEQ8gPxDhsdEJmNiQhvy3MYQk2iyJDkAxE1UR_RJFh9YAFIMS891KrzzoceffxiCi9ZtTtUPudYxh9_TSqGydRfR-ANDAkCIEi1W_VICgB6PB3gMD1Qz9XARsnZAzm1VQ3JhaUCApWEf9EATD3nFsnD0I3pbQs4PtCJgkDSVh1gZUDW0eFBAIXlJqBAJvIxhOtVTZcQ4eB-V-MM8BMR0VCOTWER4UVVjD0AG2WzCFTWsDwFbZNKAO9i0IjWAAMcVBHkACw_YTgBigY_2LCMhcsP1C79QsOwIURLoDsZKoZZi7Ck2UQheVrQ4eGOlNpTBnmF_AOsJGFEdUsI8puofsO1Jr_EnAXDCsKaQW84RZNBpQaubH0oAkoBICnDuwssMa9aEUGGrCRwwIhpRnQnnyvDaxU8NEJUEFGCHCHwisiM5ytPiGVJ9QhAn9DsCf0K9CfQ46RJxfw6YO9CvNecTvDkw-YD28NCV8M3CMhQGjaw_qd4VxFyhCvhvDFQ8vhOYPw0QiWA1vY8OIQYfWAnbJdQAFRwAgVWVASAEImgCQjjhKnH8poGNMJHBOUDEFqk5AuVBlU2pTNS0g_qVGjhARIRLGIjt5UiJgA-A8iKgBKIlJxxEaImtQEAiRSYSxBxIpCMSA3tbCyjD0AC6W6AJIeCMoUJIgeABEhwhSJxFEgR8KychCDIVPQoASM3Ui0oLSMQjJI-AH0jtIxSMfDUYS7BpQuImgF1AjkJBH2AindoFiBqAHoiPRsJPyN0ALQAUD9pOIG8kDRlccoFP8DI3SJFAlIqPHmgLA_YF6C31eSHcjXwS7A-55I7SMEwZldSMvpged0gWEDw_mVGhT0KBh2E31PbBaQdwvcKgByo7Uio4bhWqO3D7w3cP3DZwyqJwDLsb-ittefR-G7CHMCOmCAfgdsPrCOAo4BKlMAfRkvk2nG9CEEQaGaP24siRqKjwaUYUAsQQRffzbDkPf70fVTVAHEfARNbLWNYsA10JoBgw4hAujEBCkUCxto2SHiB8PAzQosZvAaPD9wgozG0QrgE4DFVamGACyj3qQsGQMhomdVTUqVA7g3oi2Al08wCaOCVFVDhPiMY1f_WqOLC7Qs_2_Cao9GOU41QrGMmCvQqIDQBHAeCXijeIxIAWD3TMSMcjDIqPB0JENabDyi_qAqPiArI1O3pidYbkX41GNCwGZiaAVmKgB2Ytmh2iZlV6MqhQYLKM8iiEfYEfD-YnSIpimw2qMwZpsLkQWpGYyoLsx3qaIk0x5gcwDGjzACaNZ9sALGg6YRaJ6N2j4uAHB4F0oSVVhiTQYSXg0KmM2MJBVgKBm0QrQ8SMFirI1zAvwepKGkj4bSdQACC4AbYAgBvoGrl8xGNbqQaYMwk2XQBHLQORyBWfZly1jlSTmPljvYvqUTsoALjXdI1YnkUCwOo3EK6imo0sKoClmDQmLi2Q0uOajBeKqMZNRRPmJpiWY3aOFjq4mAGlhGouuIrjugeaH4V44qyJPQfTQOCKjuNPjQ1iPuZUlJjhQedw8B_-HGk4N0oh6PShywqRHglhdG0hJw14xGIIZosTrxFFOYmlGnj13OeLShNgWd0oA54yMB3j13J2JTRaEGeIEA54heLnAJISsJPj4JOeLDAlAW40fjT4hd1PBf4kjX_iv4wBI8BqNPOLfVM4tuOzj0nTmPy1AMQKFxjMJMcGwkVwjQPUd3SFcM9s0ETmPAR-oOOKtk1I7ON-x2gPuXStOYiwH7jVIseNxiLAF3VoS-pM1SJREQJ8EI14eSyFU8wrXUF8MtFUUBx4bwbCU_jZ4hd1fjEZWqIITmgcyMsjSExYIoTl49GPmgZE0eL6kqE94xUSdgdSJYSaENhPaAOE88C4SutUK2iM-EuHkEThE0BNET5432TTwlYjBkCIT_GBMKi5ElnAPjwAluIFjYE9aU3iBovUJ59_Evn3eDUAMKXdJPgjHStDEVZmDJBtI6WO8jwgJ_XJjNhIyLTxm4r2O8Sv_WqPg0VY9fDupNzY72QElokYG01D5THwiBMQWAEORokGyWgBk1NXXKQjMZUOIRNQ1DW1DEHBM2sl_OWpJEgjwppIyAvVVmQ0ikAvuP0t9ZP0HeN2gH4BdB0oo1TeDDJEJPCTLAlpPmNok-UFWI0oheU6TF4axBEgttXGhqSdkpKNKSJQsmkLFd_epPQjb_GE0aTDkGnz80DAtsPrFzQgX0tDjQ-czqUrozMjF92lcTgcxAkk0PBi0zZDSiSC_T5ImwjSE6Oz8stBLQujBeK5M40RvBTX39atM4PBSOCE6OhTLOStW_5ZyeFIt8iSLZO6SKg_5I0jhwCpPeTVpfWSJSF7P6AmwlQl7SuTm1MM0Cw142wBvBAyWDTf8EyI1RJSidBrz6SBAXUA8kek1Xjwj-krOW3oRU_eLRMuvKKH28xU6hQlTPJalyJJd4yQCVSUYrRALAsod9QdCUwhMjiAoGdoECkoAdoE2lEsElLWNaU0QkuxUdD4IsDdkbCUZS1ABeSyjgok1ItANUymKUJywoVOzkRIeDTtSFkh1LoRlkjDFWT2gN1J-CEgT1PCAmiNd3gk9k2-PglA04JPMCvgyJK1CXUnCW0j3Uj6gTThQPZPA9Rucbkg94eWQyrIPAM0G2BymYsMpA1kpeDNToGKXg3jRUgVPXjRVDQlP9P1YGPGDborKM-Cl4AtL-CqyS1K6xrUw0LXwg09NIiTnU7AFdTc0heXjSvUpNIVS_UyVKOT3SadMWTHUsNOz8F0v6mCj403eL2Td4ytOrTa02DHrTyExIAXh4MJtPLpdUkMIv8N6PtP6SgIogIg1UZaogXAqYq_mQDENNyMRoaARFTgBqkwZPEgo8ElNvJ7UjNLnStnNZPiS4-UZIOTPJFeUF5cvMZO-RTIsFx_Sz0cDO2S6kvKmAyCAUDIIzH4beIVTgWUYArluRTlKWYUorZPGT5IKZOwz3SMdKKSJsadKjwd00NMzTWk7NNSjwgYKMJTDkrbSjwVVbkQIyiU_qOKjV4qjPVoaMvDJaiuUpuK1oL07jQsoLUidIBToMtNN4zsIPdIjSo0-UFoAGiFdJ9S104VKOSC1eTPbTd46bzLVENDjL0z5kmdKWT-MlZMEyTMmpgXRh01dPsy74rTJBwq0iUBrTv_Z2PPBCOSlW9Iepe2LlB41RlRyDSdGABNAqES2mvTt6JCD9BzUkHBcydMhgOIxt0kNMMzPM8NO8zF0-UCyz9GGAE9TrMgLMOR10zyVTS3MgzKdT9_fdJzTD0heWqzaiL8UD06s_1O9T6U2hCayA0xxKCIb4qjIcz3opzNFEW04UCSTEoyDOapb_DxJGDQw19O6gIAj9PA1iYmPHXcls3ZPsT3SeaB2zCY4CP2yn4o7O9TOY-SF6zask9Mux8s4pJaU00njJKz2skFPnSusmgGwld4m7KwSo3abPXdZM-UUSxQs1wHCy8kvQOvT1GZeVyzpsF7K4z3stfDayjMirO6zTQJeQyBBsjdPEy18X1OsyymELI0yYc2sGQNEc4jEhzoc2akYCawDjJq5pQ42G7C5Q3LBJSRs5pLKyMc7AEQEeUgrKGMtwrsDcRi2M5MSl6lceXmB19IvUWBcgeZyWARxeBzRDCQ5h1RJXTbdHdMxTTXxZ9XggM000CdI0IeTdcvn2eTcTflW0hyofbSCIJwE4HgBpoNv0xo-IZBFbJHAo3KCT9tBMWVIHwbYOlTKLQ-NgieZK3LfEpVCKB3VwEE6XuxFlSXKGSJIb9wqx1rUzwA8gPRmhA9nAWAVaEyGTLx_VJRMMLmpuYybLDzsvWcjjzf3YxLU9nAQD2A8n3MMBxzbVfQUy8dvIpyAkTsy3Nq8KvUKHCg0oKGGxgjIS9PBiTAwJH0zyEj3MsSONf4NlBItdbSQgfVWTWso0vVFJaUYtN_m7SodC6AgCcU0aC9zqTX3I-iDU5DRtDyoaPMF4S8hPLLzVFCvOTzU89PLECzsvTRo9Us9j2HgSRZ_hWhD8jwEdCA8pFPOTRFAXyWp6ZLfM2wp8xEDo0ZczbHaMsQVBBrskMscM2wsomApKwbsY-KzTsAFbM5wj84vIwdS8_dyTyq8tPPhz5BU7MGiasfAuZ1q2E2nHBgdQhMnRamWvJHVsAREDAQEpSuSLDK6N3IQwHSaEXYALQKPEiguCzaLYL_wcX0Y1X-FqUxTiobFIuNFgyTLPQbtYQr9JdkHqlxjX-DAChSzomFPDzZyReVxZZC90lWgBCo6KhETSLgqigXg3sNND_wbRCu0Ik-sUu1PsqnD8g22SbC9zVknPjKyQQz12ZNwQgnSTDYAaEJpQnUOZxMJ_IGADFyPkyMCqYBAIIuJRQi_VVicsoYUNU0WHdXO1NNcph0YtJfXXPZ9WCPn2O07sCIqiLEQGIuOjHtSYXyKpUQosThbku1QTNKILgCf0dYCSDKLgioorfDpQXaNi9p8m_jHBQvRLnC8gUHm1P89tS73zBhQAopCLKiz1SAkbsVn3MLisoAvgArA9AHHzIgSLVh0OixEGgJWijGixoCgHPWRUmfEHFvIrCywIy1TcjLVQgxChsjuiti4SS7iuwPfwMKRC1XDi0VQ7MTe0kCjjTSh6NCshw1YRZZkrCyNCjWAAqNGjSzQGNabCNUIsE2NRBdimXMVYeIGKPgARNGXLxwbsW4t3CuwaSNkiXi8VgxLZct4uqLKg23LgB7ckIHuKN6BkEgAfAAmhFoJBPiGNlXoAIHCBOAKYFxBoiVOMswLIdzFxAcaddBYKU0BzFIk8StDVONlJPEthTsNYHT-KbjYEvQByNSjWZg3jMEtoCMhZAxuiJjBG3FjYAHouI9kS3EqSguwe6ObCJlZFOQUt0k5jVKNQy-n_yxSg0vQAYTS7HmKwSzbFgIvoj2PmLZxYhGMLkDXp1bzOirgFszBi-Yqy95gDDLy8gUN8EAyMheYvOSJM20q7A1tfbU9LNuH3LcSZUnIHmhv-EAv1KEy4fLi9kyv4Muxb_RMvzLlSSgL9LEQQ5GCzA1IWlUAGXIfymABIMKOZgVSy_mhLsaFIC-0bCscGOLHUqshpR1jBrTaAeHMrMgC8tArW8AitErV9CQcAcr-hvstJ22KYS2cAhTVARBFRBVCtOxYcISk70Nj5y2hEC1hywXkrUziscs9DEEmYEK1itYcpnLVYqshmLwY1HV7K-M9sthLq1BwtiBJsQcuQKEM1woBDb_HfgQKHHDwvIEvCjnx8KZ80EJ5xeQnVj90TdMPV2pxQ6FQAwRQSgCiTlWbelBEc0KBhe8Ky5YNlz5ilCoiBnAAAEUTsT73aTWHVCEcBrFN-NNhhJMGFqL6ZeYuuSB4ZZE2lyoKFmAk8KoiqcYyKnWHkBjpWshpRqKj9wsQjsE7AkgE_TACOwIrVjBUZIwMRXppx2StDABEgWzRmAaKtKzeIraTdl3Cpk29MGAvoQbzSgHPXd0TyjPCrBPdX3SwB0TiUdhJh5ojVwksh9DbCVEraKiSr5zdyopJjYqkLWB5Ruw-DFhoflPmkxI4gVCqSgDKlc2MqUvcLRBoQkqbNBJCSk_27DWleTDEAJISkI18NY3hn_AmuCRkjBigRshRoqCxKWOh9JHIGI0WKuUuKB74_uD8qCUGAGVd74nlLvRZRS7CNVUq1oQcD3iU4sjoeURXOSrawQKqgBYaUYmmxlSa8o4Q1JEcSOipq6VUjd3SaqvtweNeYnC1jLYkUvRlI3zXgw8q5WBCStqiynuYkK_oLxRXWCYloBeKr7T1LYi0-w5DmQi-xgps7CKAM9lPYzyc8zPDT3G5gjbTz6ttQYN2zKn1C4purbVLFM9VqqjOSNC9K-gnqqaQZFXbVga5Um04ydaGq1CMKi6oi5ZQGkBBqdKjIXCqIgGGqxqtYVrCJrSU2Gq1ggkBIEBDUaggnJr6WYGpmBtOBuA2rJhVXJnzOHGmt2Q6akmuwrCssSn6qxbdGoOMrq9Aje0MiswpVz7-DTXdCDc2crxqBCgfPpxKAC0PhEzqniAxr68TmuKKZIxMPxq0K1fMorx6Z8TbsJK0yrc9zKs_LeqrKqbjThn3Eqxsq7KthKjx9E1T1MUirNyAaBtQZBLfU9az9UmqStAMrXwjS52MJRdE7oEzV5ikGOPofKyOu5UZAxvNzV2BLWmSBeK-pmoBDK-THLh2AfOAaBXIjIT1D9tEUvYBKw32vBrC6uUubKhan6mKBHS43MHy3Mj7PmLSsguri9vctPABC1M7DAnlcvGnTkRUk2kWxAwYHbwkqgctaqDqJsrVAlr6xNeg7x7Upuv-ytaoYunzvc4OsqCsod9jwqOmQGld9uVZrjyAY6M6DSB9jBIGSAhQJIB2lzAFwWkLQSVyP0KHtHWuJFb_HnPOchqpxLP9I62clLrboiGo1jJ6gFLmT89dzN3SyszrLzLp8vZJbrl6hFNxiHygBtgzZ0jrIjT_Q4KM_SuAU9MXqIao-JbCFUr4vRTl8rcquLWUy6K_r-kiGrNUBUzmIfKnUIoogqw0i6M5yWJKBLvKjqibK70wKibAgrodVcA-AecZDFBrty40o8RAkfKoOrH0VEoe9ELYQi-S6kOCmRVdVGQl2R0EamVFrGQwagSKPWO1X4xJ-JQKoAZgZIEITFSRaLlIs1eoGsASpEqQEFu1HIBYAGyg7A8AKg8EkswlGeStdBqpHVNT82wIICXQN6QEiHU8wVnxBkpQKCsxJnq3i3s9zaj6oBrjVBRuxRgKwW1Vsr7dGwKtvPQLzPyommTgVhgK7J3jV0nOvjTZFGjCINJlG6tWBqaiI80KaaiCVTgB2Ussk45WogqE5BhvBMwnpCxdYsq9OQqWobh9cjn3sD7Cj3JVSiwBIANpXfOaJoQd4DpiaLiULWmZKBBAmgtiZlK0MBTEU1ktGLyi8Yq-0l80QpxqEte9RtJZs9LWZT0oSZoqKjSOiN4wzMLsBVlLMTNXjU_aShQ6ZDUuGksxI6gaWOApMGyD8IzRPCtXBm7ZLECK1mootyxjm9ZtFrZ8_lRdZ1a7dHizXfGrDttDc4tg2a8G0QtXBtmsGtujB5YtnozcA7qBabE4Nps9zMNJYqv8D49YBHQ0vBFo4KTSbf3TUIUkopxKWJIaq71tIEXIJcaGp1ULypcm1XoauWoCWlzboxXPEaPXbJxwtUijh0Z8bU35N3NMitJlyLlmsFLrqlalWrlbb_ZFTeSDC7JyxB8WlFLzoUc_puspdK1CvoJpYT1CrrSUxQgGanUTeoNilo7IF0Dom2pSfUEw4kXLCflEfnLrek2IPBLI8wELtC8Wj3NPDy646X2a8wSjPbSmMmPP_TG4wMrXif1YNv9ylqhVrmKR8zJXLqF5EcT2SAQmNpfyxNabHbI14oCUcy9TPOtG9aUoPJC8EuU6D6LIvNux9agwv1ri8Exaqssz20qYtrqp6t7NaywGzbRTbW6pYrB0J8gX0gaNinNrpz18KfyOAZ_ccHn91_Zf339DC5InX9N_bf2BTxcsrITEj_LYuqrhgsuri8tizVrLb92htoDbe2-xI-LzjQgXOzNswtpDbtsgmM2yvQtBqgj5CaqovDsGgVNwbq1DFLUKsU2FNnIt8o0rzacGjr3TKAqJ9Nujw8shMjMpqjAEjLRRQtkShdqnABEanwG5sSliSgGKXKUZCZtWbgir7Kh1VQcHLlqaAegPiDBaDYCjUgiFgJMQBAWGhyAPYXiqWA3G_EGPAC6ecBtbNAkcAhbMK7UwnA6Sl3MqCZZdgGx4ceVaE2AAmZgMSkLGkQGKQq6nRTx4DeTdv21eK0iskqrQtprPKN6ONo8T1O3bKnE9anoi4rby71sIq9KlTp9IG4tUyU7TO_irjbWSfjA8bKOyTrsBw2xaIWEMOwZjpA1a7jrzBnc1sr80tak1tNZvO4-3r4SGjeEC7zqg42dU1Aflh_rioC0Am0QcNGJ3Kw2rDKxa2o9ijC6IuyFp-oMu6bAiwwux52y7vO5QtOiCGytS3bZyTBt6pXIrWqK6vOjGqE0gMNJVTaeK6zsTgGGo4FWrR2voOI7b0QrNgIqGuChob0fUcrqKbkqHT5SCLdKEK7jWhrqsYzmn5uZMuOjGpFqCCamsNb0CObtNb3C4JqOoIQybAxxyHSS0ZhAlR_mzdWYM8TzclLXAQrQYAEJiBix3V-EBA7uh7tK1N3A_mj1AHfhUsUvkQbmnchKWAG5rGHJXAlBLTXuqSh7WW2HmrNjDehg9HuZd0ctn7bUuf5cPPPyOMKkY03gplTLyznQfLTHD8t5FA-Es0g4cAUYdbCUCgIF4ez0ER6Sevbk49WHfw21AlDUbmUV5DJnpZ7SeJRR-sNbDOHa15DXns57lFH60StdQKG357ODUXvF7We7nuC923EUEGC4_CnsoBaPJStcIybCHqh67k1RnH5yovpTKDrkjQtMyHYJ1IfyD89oETgl4V-MjLfzRJvkhyo72r5iH8scAEAvJPqnAKze4eE2xnhV4Q2lNCRux1s7I8iXd6vetOgN7Fq5sMxEonTGoSjcRKnKZF8RMGCBzQuT4lhNmfVRgMClHdPrBSfMSr3DLhQSHvNpqCXPoTETI8tAcwnAu4UM17lcqNradWkvstCG3GwB9R3fXIMp1aAWvuNTbAZvvSsfgxt1nBgo_UES4IAPvEPTG-8uM0Js-qAFnBS_D2IkgNw8dvSgPuHDXn719Tgokh8-gQEL6kEJrTTRq0SinX9gdRgAbJoRQ_rUAl2vfKh94QZFU37t-vgJCVr-w_2ZhT2jIVrsE7Dfs16i-nxwbMn-tQBf7cMvftcgP-_Lzv7d-n_uzF_-viChp78NKFv6oepDqEEj8X_uwAmm71v81-5aBnbI3-1yCep0BucGP6Eu5PnLUZ-3vwcwnBCSGTAjIDcNViJ4rAbAVo7XAcz6caYqEigiBxDWn6UgWfocwLQCgaoHgsvJJuL2vBQmwHugK-pIGy_a_XAdGzCki1hr-n0hi8S-7Ahw1fsbKr6oVw6tmE17FF0De66-_QHKjwGSvuzDq-rIFr7ZBmiNI69AtYL-E8hYDVd6MRYEWj6pcVjRE0esCkmgHOnWEVZIm-goFH6IZWAVsHEgewd96nB4TUXBEsbwZb6PpNEVxEghrERj7eI44TQF8RJrr71P-nfqf5aAL4WQGsALQj7zDB_YWiHEhn3riHqIz4UhEUhuAa_72RGAGyHchnzQUG5Bh2hL7TgvOiUcvi-gb7oyvdQecGIhlIF8GUZLysKTQm-UHKjSY9FVYhHeyaJGF7vY5PnYdBAcgdgAdbYHfwjVQUPiKVc11oyEmKpYF5aQ8sHReB2Jfdj5aUEQilthd4hXJS1aIDlAdhN2unw6bEChJ3Fw2fGVppww9QPXqGEOvhiQxI-MUmv4LQQUXeHsJD5gA7CLF4YbhH-Waq_afzQUV_bRoM_lZI4zb_y2LdbOvG1d_MCPosBeWxLDX0VS-CU2w-HeAQ4lc8BjC2LjCUxH8BYe20VQFY2nfJTpmCakZS1rSUkYdhyRuABMqWceZ2vbZvOXL2aIqEnALayExROWoWRikZfzoGFEc7AMhgMOOBn-RLAlGr5PIRNE6e_h0Vy-81oxDyrgDnva0Yk3GzHaFBWrBFG4ASkfdUyR_wEG8ER3cosHBGyU35NPatnwV7lTNYYMdtdG7GWpsvMhKwk7OokhCZASYyx7U4SXTCiBJTaoPRovqGety6PEMoUiQKg3rr4gPmZ4Z11Xh55g-YJstyNJrkVQHpj6Gq3LF2Hw9G1TIlV6umspqoAPtnTHMtPtiZqeGzEmAxtOdmv5q6AAKtcARgZy1h7tqq2gpBUASkdSLQe9wCrat-qHpvimxlsZfyJ6ybIK6Ox2HsooBoxEfzji2viEyBmxh2C7HUgErVh7AQicef5pNZ2s8dMASYemwfh-O13G08doGqG9x4jHISS-s8Y-h2gdwcIArx2sHISLEKIHvG6hucamBs87mUrdFe0P2V7Veoo1cJBxxccDhWxt8Y-MMBJG1SKKe7IRVGRxnDN00ZBJdEgnjRGCaVhV6-Jsvtmqdo0F7tR4jNxt4-t9TqLOYkcX7rFRsnvwT0BJeAyVORFavg0oDLHqOMRNZU09rwGbroLieY06THAZUXYcog4EacGD7s68IGGB-gASAIQV9eUBvAJQLoCOAZoFwXjH--QNPiqAqvoUNqRcQDrsZhhOwAyr2ALKsKgPAnyqCYr0RKrSrFhBdBarvKrqs6Eeqseq3TFJ5_NQnX660bAnKJiCcyF_4aCfgE7J1wHviqlBCYzH_YZCY8nVR5qi9d0YrCbchereIxwnGNeUfwnaowid5iZRpWH7qne3yeSmnJl0ConGNFPpFxuu3NsCwCR-WCJG68T6PGBlYUzW-6FwANGga31HJOxlbUlmp5Qtqi6FyqkO_ar4bwGCwGULxaZgUs46Jv8AORHRwk21BAKiLKYtgve31hpbCA8wdgFjL7y7qc7KXr56Ze1HxLtbtQOAdL4DDH2GNELbEgWRCBMbzhJ0nPbziLnRzkO16WqRXkOnJa1QXBGoEKUfNzyS6zEtahCmigOmFkCwjemTxJ1smFPp5YaGqg7daePtfpi6L86pgREimmESP0lsJRhZfOhHxgWEeuHAZqsnbJwZ6_mA6_cvai70FhjM1-mWJ2gcCxUZmARmzGCW71QEz0xDRCmnydW3CmxrKKdqiYp3-s4B6ZYGfincY3eJu8gJnYA7T_JGqZon-B3qqm6vomrJ1oOEP7CsbB7SZDZ4oZu6e-meUQmZ2B-ddKAixfpuwHdUVZ0rvf5tOL_kuj5Z7YDujWSLvQmnO4xYd1n9Z2tLlEU3dLjTckekkhtn7kGg3ksxJRS0vEHQHmj5pwwZyGmRn4cdzfg3Z_mgCgf4Zbye7-3Zb07dB3O8GDm34ZbzvBUlXeSPIge9MaHYxwHsfB6QBqHqHZVxzcbjm7yIHtWJIzWHqNl0VCqbPRzMLxDKUaepj19gnLfSVh6LLMdWcskoVGSlMcgeHrtnUIHmwdm0ezdgx7Omckxx7qe_Hvx7O5n-3hsOe0xHPAFuHzzLz2e7UGZ7x5yedSbutHnppn4jeecsAp57rT48ODeUEF615jedCs5PWz2bFZ5lHkshNFPnnsA-ex9xnnmezhPPn4rK-ZE9tp-GyAs7DYw3Gsn3HODxb5DV-ZAs6rT-fPA8Wn624895xedvcBPTo3J5QF2HiC9n5yh0WnALCefXmwFwI3lAEF6Bac9l5iKYzgMF7hLPNVDC8w0NVFLkwR44rbUAisn3VAp3mV5nBaQX95rRXwXzDS80sBiFxI2Z6dFchcvnnALBbGsMFm2qk9qF7BcQWF52Hn4WRewBYnnLrPhcfcyrdoHh404LcWEXkF0RZkWeFzkzYWH3W2oF6aFoE0x5me_he4Wj5y_l_n7DMKy75lFUhaBtnAL-Z_nbDP-bMWIrJRUsWAFxOB-tArCea0UTF9-ewcnF5nqsWbFzg3cWvDQCzsXTFnxecXrFwBcG5jAUwHMAjAO2FOHyM5YIwBPyuwCep1wRGhVlnYUuCOB9gbwgXRXGvEFFDFUDGiuQWqLVWCC5VKlV4mCC-Jfogh1H0AsBgAXllogJOJijmVh1L4RyW9gJpyOACl7VTqWGluUAogWl_MdOGrAF336WwZkaKzBhAyzDLLzgfk3ShBpc2mGkplkIC16igOpaNVml-1loh6E6bGq1Ul4aRFoFl4pb7Aplq5pUxFMr3y-pw2rZb5A6MM9h0EQKRJawyjlsHkYmuyEkLGWaqJKt3R9As4NPwUTU4zQpDfJv1KpXkgwNPx8lUFe-WG_cf0hXsnc9TB4inJsNIlThrEsTD7zYpDUBNhkoUIoQV85ZbIS0UkcIpYV4ldPw6qfCnJXrMLSYnpgVvPxiJCVplcYBAwvOhhWMAUchSWweFIbeLzZp0W8qUVwnWOSYlrZb5NDjZSX0ljCxsn25zAbYgHr_wLZfFX6l5WEaWKIChNaWZcg5cVVwSwZbVXhl4AECaCAWiAq9HAKPrOwxRaVeKHHBuiAS9_ZuGn0kVVoZaaXNV4cCeGDluVW7U5EXp3FxnVg1aaXRl5GTgAPlkeCY6TlyzEiDLluiEpXkKPIJyAvqM4z1X2AVVcyBDVt1aAk7AT1cVWrMdAGSzaVI-DzVk64khMw4llNZdWRlvZdjWyl6bG3rCE05doRyEkte8Io15Cn9W01ppe4lTV04bRkp0PSjAC2RapgPtkgVzEbJlA92ddBG8lAjEFPkj41KXHKMtfogdlumv2Xs12sA3o6a5TFZKPqAVRGraOlNSGZpVkqSTWHlswDmGi6Rshpl9JKRgAL3mfSXNWHBxpAD1xcSVj-XQ1zJprARkeXOrX9AW2GDXe1zeEhVUSeDsSREOxDCu068K9d94bVQ3vvWgRYIcJ831nlYO1purEk5H0Z3fLaN0iTwL-hvAwyZGtjsL0AwB818QOGapOk2kmloAWRRFVJmV2J28xwRZenAdCiPLciFwP2hHxua3C2ctuatDfvR3V2XB_WIZJYDaM4Ni1ZzIrvU4ffWJNv5YA3DbLcISBDkTjYkgixwGj7Y2NnaR5rsxxATPaSEfSU3Xx0sYDpqlJoRuCrCSwGkU2yx2yYXHhx-yZUmLAPdcikco5uZz1AagUw6qhxmuazn5RQVrqnrKAkylWE53mqGMxVstaHVVzALe6AnqMLZHgdaBVYq90aHxrznA4NhU7BkgQMeiAcAZVcXWK14AAEiDaWiGs3PNy_zfURaBcZzXiJiVePU8QbwmFpLMXCXY27AHjldBRVaGPlk1YSwCuYbwSyB-he6xVfbX1V3ZfNpaIOCWqbEgQGVxjw-OwHrXLMOCV8l5QwQKzAaSyzDK3G87lXDUtApGgRLq0X6lo3ugWHX7AktgJhHF-tw1eNXTV0TcfWcyJkUfgbVs7A9h7Vj2cdXUubLYDXK1obYum3IQ7e2BKR4jEjA2K1iHiBCoBGPrTIxx1bKF1lprn24oAM0HQBkgJNe-itYir2J89YjjpKDjtxdZ2W8tqUFXW11iwCJREgSMxS3YdgzAyA0gaxtlG4lx5fPWWQaLag3JsQrZR6kpwZtG3AZRWAu2ENj7a-3Wx1Eg-50do0I7G-x0AdwsU5wXYHGGd-7tgnBbFLXdNM5pWHXGwe0XaL6lgLHcBVhI--n-kxt4xjeIiIkiLIjFc59Xn7CvQpPNahWuVvx3856Xbtg9Nrnef5PJzHrPQAZYxjZ3YAB9Y536SG3dQmCkv5XN3gJinc_QQt9gHiXMxtJYlWmpN7GkxhpOLbbsTtwNarWt8rNc9XrEddWaAqVJFS3X2O0Meadm5hHcJB34TYCgYdvGPbe2kEArYjgHVqL1qik9g4GaAHthECe2R4XlGlWf1LoH9oXhbECm2U91fLW2vGzPcq3k11NYG2ztopLIlpYXPHSh_t3sHi0N6MqTOgt8zehFoGpQqHrXJlttbLXhVq5d3MNaBNaRAtMCMFR3XynGnR3A9qneeWi6YPZBqkVJUPL227I2lu9Th0fdRG0yjGdRJVh-6qYd8V4Uw1zrpm4qYm9PCoQdH-TJ0emMq-GDZtgAIVvqfALQN8AeGShd4YTH4K5MfeGtikFX2KAzYZRQPSRtuzvBv8mCI-h49rFeJEz-Iap29sDk8K4BtghQgr4UDw_yWK6veAHsTuu-TbEj0xtFcm04Sgg8mF_2_6YyEQVC4hPgJIag63ybyGpYEBQZ3-FOHENnVlRlNYe3ZZ3jGBotr4TmXg8elvCHJP8L0N4kh5JaEPg_6S3pVvpRk6D7zUSxa9lVg7nZZqbInXTD_SW2rC2MTt2AaseLfQ6BBeIBh34_R3LaLhMHKIcx4tjlCwPEgQ5FBghDjWd5QtZnAFhZLokw8RBnLMI7iC18FzWsONYkDaEbBC_hifA1Ge5RzXsJSI87j9JGI-qmnyaVbNL0Y8I6uBsj6I_CP-64NffXxjemSLImGlKj8OAjoI40H_6aw9lEJ4tTKSOwN1I-NSTuRVayOy9x7fKPYj2cZ81YxqYBhZc-pskk3kN5YWaoxve_bQrH92kcBxOY-aEEOZcm8nDayJd9buzh9xY9zxAjzY9HH9-GY7Kl4AB_c7A0oP2ce3Qk4jEmP4QaY6Q3zjj9ckTcjqo9mOajsHNAmKvfTYlW6du47wPQCqPDKP3j9nbiHXjkrfeG08D45ePLjjEeIxO6nkcqOJD_BJ7WZD-o4-g0JkaW5qUh349JrsT_E95r6xhKsogk1nPTt8PNxnbh7tq7DHeOzj1JZqO0oZb0BOrVs0IZOweGo6kQeIaIHr9vzENdmP4T--PviKvKUbShadiLdZPDVKk4l2kprBod3Nd48H7rQTs0PBPHByo9yOj9t9WxP0Jp6vwTqZoRekW04fuoZmkTu9Q406NZzeBOEppHc5jsp5hu40ayQVtXAVNqmvgj0xqnFsm3tPqfJAO8BiaGnwGLvXrn9JRuZqOLD6_cW1gairy1ncj8I5GnrJsae4gA9oPfjnItqwFdjYlEqSYgXgXLutaN6LwPi2SpB45iQ6O90C0hUDEqqOBo6HGhFpUIcVbMacQHdbHXffR-GZdt6iegOwXOhVZenYlwPfLXXto1YBVS9yw6iPpVjemyOc1ihWUQcaLAESABIIsDOE5VnIHCPT1uBaNBT9lkEzHwzoY4SPd0V_aZD39wkspmkZCeQ56758tMvnNFgHzlHRLemRVPg-XJMcnw2tPW9JRWlQRN10Dt5XJJP8qYGfOvz8LsQn_lQSLIi_z0ZVFqniqMAQIiDyzlAutDgghoOtjtLt7ieCQInbJYLnpRDWwDxbpBwu9c_fQutSS_YUJ7zrQl0IUxeKGTOjMCkC1govJ6gbO2mFkCzOMyXM9TUdaA_Zcwj1uwCNnSzk0HLOZ4XkqrPMYFGlrPZgIvcG2S93IC4Asl4aIjgJLpdFcwugKi45deQIxfnHjZSkHG90ocI6SrbehHwih5FyRdoWRFq8-xsRLPCdkuP1svTXP_CuChqONL8A3Sg_zHO0F6SF_RZkWtp8Eg6cRmBlRYuR1AaS7A8wUVQ9jXMe5aeXJoC9brxGos22FBDkC_fjb3NSRjf2qbARv4xPViehtVquaIgnPC9n88aSIz9pq1yPzgUnIa8r_ktwvUz3LCOOx8q_Z3PsQdwr3tWHbSBfOvS_1GVJZjJ451YlcwDHOmMVv5Y_b-kkQ7EpThvbua67e7OpPncFsvKia-qCvlauay4pHPpZVLHDkDw16bbhoV9spfX2Nl8mm9Uo6-a4PQbSPJZkin8RLG2OOTv3teW_lpJffXWTtpafx7cHq6kPrsAPvyS58wtU9UXO3uIsIsZiK4SAorryOIQQas2Y9d6rmlCNmmrjUqqnOruJ0eqecYYfQW6FlBamv4RCPtC4LZ8i5MBxVp1AQowVhvxD3rWw67nX1l9eu-wzhuw-KlmgZiA-RG8tgV9LE15ufFX7GzpmVghLyzAJv-RBJDSBdrrgX3MXDx6Th3s9lkDqkuW0S9GXbrzpA6XXQZpAtA9HedAiJ61qb272e1EcEbI0MFnOP5k16GPMBeWE5aqZEpkVeP3RPanfMAsb2hEQpThr5fauxQl_e8qgDjYcJLki0lPuHkD_89QOsiz87Au4ycY9xXUlu4vQBSD5q505AiFXaEiRIlA6pxzDrg7s3WHEFXPiXbyq_OMW80496uBD_85GVpwQa7-WxD-DDUisMnY9mPY7j2_6TTr549SWxD9YySW87l46423l71WuunN-Fe_N7cYNZJyxD9fbtK8XG47r3WT8u9zuzryE-mxs7iu77uW7ojr4h198UGYh91tkQCwRzybEuxB73u5Luwee3B7vvVSu9LuN8CbPbI27_y6vlVTSUpeOJ7oPD3voRPam6l7irwPh3Nr1zG7PJO5oDYi4gWyUuxjziqgNPeFhG5gWy8pQ0SCmFohd0XSFjhYoWTL5qlNPOY29cY1V7wZPXvl7zmPHvUg2jrTx7TgWcI68p22NmP27k-6pbENdfd9v_b1uiEObg9B93v-Z3zdJpg93a82u3Zm4rhKzePAHfXfbtKGDuyInB7xK8HuhgpJ492h_ofxS7C-mwu9IsvKvYruAC4fBTvEuAOwRkZXtn7z22BYe7Sth_ApzZ4LYxuy18UGQFGtvfSm2jgWGiAcz0RKY3oPYFs5gASKxkFd6Y9wc-3laIHC2fpLMB-9EmQg_ojMe3Vir2MeMgZIGsekaKWnvvNDwzHTiMd7yvMf8t02FsBzwQUBEgqmpFmZ1bATjC1gInsHRO5i522AALFV94JbnVzmlHTgHjxIET0VNIkOceTH2oUE38_bAGUmki1_tfOZTIZSKuMDuVsODgdDlEIps_eyLL7WHB4NBTkZRp4TEXIuVuEkEn1g-somHtXZBrQSDg_pbjjD_ZiyA74SXjvjjexKwH3rtLtf8AMvqhnGeuhq4oiR8Ne78Pq_We9tF9JFx7sGtL8sbjOioSu09UdvYI-jPP-WM43yWcEY-rItipdTCZqNjS_giNnqB62fsjiC6eUQcRvd8Krnx-C07mCTU8ZGVju1p0JX20kzWDfg-Gs9UzpfkvbJHnqjdskO53h6Q1L-QIFRBnLayMo2VVNkLbtSVkHB6fj-M9BSHRRWa7XxtH_hXIkB4qUASfzMENk-NojirbyfXH4A5FBOs1p5-ygQlqVBIXS0i71GEzIl50fcZBkGI8-rjeASevnsKRBqEn7LVoRJXyl-5F1w0loGaXgJtZhi99QQWkCoGQhL9pitPYJ0E5l7dQyAK2Z6kwBs-sjlxZwWrDo1fyOLV7CAdXo4GkUA-X0563hXv7BPgVzTn2X64AaJ7Z099C17gAQnsBAqCp4-V-JeRXxLmz6LIa2ASfDmoZ4SfxQUV4MPVTWclUHqsIN9Cfkga4cySuY9WLmeCCRN_gBEuedsLAWBsEiJIHDolSRAc1fQ6m3TX515iBXX4SUx6z6E-C1jbX3FltjugE4FJKaXjUVZoTWR6SWBRVXt5qYaOV80lJSaFaM4g5VjGgYKdBGrEVebSft6Lopz-UNYuEoJoMif9YmwB1THmlku1ibSJWEZxfSAYH6BNUvdFw47XnN8582JhMhpd0CIt-TeiQLfe5klYAmgpKCgaS-TfDtcN-Fek3rwVFLC3iN8A_iPAl9JoSVBQPTDG38OMfgSNxlXyAqkMZuo7rhHqXG6qpPd_xBHmyD-3U33tEE2R091rYZArVTWHGgbSZd_YBMno2mk7O31XC2Ll3mF-IRn3xLkKwI31C8CxGPg3bw1RyTN5DeqR3N8-IOjua-fgxccJG-j9MF0H9pXVYqSXR1x8jim3dt6jtNew6H1TEP9GcjmyBenj_uFepXvvW04oeb_mP6NfQMo0_cWLT4jepx7B-veu3294sphP3YXieI35k_Dn1Kxj6WB9Pi6Ch4zBlDYpFfXucwifEdJz90_VTFgZIeI8r4jKfJn_96pewP-2lBeMynTneNlSFj9Ogjou7B2WuaYN7CeuaWJ65o_XvL5jeMABJ-OGuuiRodAjb2JkkmTqcOTUiI3lhhrAdl0a68XQLD-ciW8WpG6S6-PkSCD5vettm2BqNiJ-HiFqZ67IuKHdc7CuWQSamLn0sRPV-ejH_J8kOG_Dp5WGbbxK8wtL-z_ZSLv9nK7JPXi7r4KfLXu3Hy-AvvfTifY35z6uH2ADJ_ye5vtOhmNsRvZ8W_sRhp-Zh9b-55_8Soq98C_e419XNP-k7_i07yqfqjduqnpOMle5937Ho0aA0e4meMgNrF1GJvd0ipUMNuLGSiVmKPFimCJm0vRaETgo-xBDJHH_6T6NmFTx-RcDloih2W6PLSmRD1zbTv0FLKcSwX7k85zsWv_-fa_gHuilvOsfoE-IRXNhH5Vvr1A77TweOHYEG-99LNBs-XA4ZJ-L_P7tR-_hktPEmpxf8jkl_AvxZ4fPTpYL6peVqvl5KwHPvh-ZNhZgQBq_78Cz-FfLbdBgeYR5yh0mpL2c35-7T-WXMjvT7Ry4ig2fhxYsW_FlxZWmQ3arAj7wH1PoJsbfrnwpATfpOPt-6vnR9Qs5pjUYcAFFzxdCXvF8xd8W2vr-a2mnzR1CftC73pUid9ygggqRM-nG-_MG9Ya6TmmHIDcor2yb8rqUWKZdtA3hGtqf4BXCXDfjUCaE2zguAUCc3HevqbrH4BcdS0Y9cEzREnoI_0ZhTfOGfJ5HdvO_lUmspz7jgSem4KLNXWAa_x1rpaaU8uQNqBGnTaLrV_6hUDqvbkf9Xaj_ggjH_aqIQ4pIT_iYwS-vRnaq-GnwbSAKBR884yrImWrsHBvmGPf8L-zgs2-uo8cA3_tUBMz9In6hc65-Hz-RdzS6JOD3-AyTakn1wpmzJkbIkVxfs0V1oQsVxYmgZXHIwAPmeO1zABm_1uiLnWB-H0Cv-1CnSkXDHABJAMriyVGmwxALDw1mTIBeAPFSdAMIBtYBoBcL3oBn6jYBzALx2WAPRaBen7oBm1iCfAIXol2C6O9_3aA-yCf-pX2uSM0EZUomV2St-wYB1CnDatEwSamEzfuq8w_uTni3m15xAe3P0ZmakmgBrM3Ri4bQ5mIAKwy_dXSkpgM9U6Un7qXqSsBt0S9S_dThe9gP6ScL37qWZmnULgP3-fAMQefMxQeo7UsuQsw7G4nwmg4sxemQFwNoId1ywxAKNGsQElIIz1LGQJBz0is0jAys3IBMM0AM37XEKCMwumyQINmzJjBu_50SBrADyBAq11EJ3V6Q2XHI8js1zchXBdmdikiACKBJQlKABQMHla4_3VvgrOiRQRwHLmg8zOU5HgiU0M26BDHjO6d0wGBP8ET0wwN6BDlmGU4wKJ67AFbs2ICmBNyFuQApDbmswA7mcwIYQdtGWB_iie4a3BroWwNvgE2F2BQsErElQL58RwJNgsKle4pwI9A5wLQgHgMGEcwMx8FKCxQ_3AXgS8G6BbvCkgdOCuAXQPNUPM1JYVgCgQ3QIE4JJCuAkwMBB4IPuQPNkhByPXgAYIMjQohF4sohCRBesiHoVwB2B0IMz0QqimgVQgps6IMsuHggraFem6BfEnIM-wLQg63EBBdBmu69QIEwTKEoAsKjPq0QFFU3XFYUq7ixAu4FRAXoDgAXwER6zjjYgBljAASQAngbREg0rIIjKm7jXUbOjeAUfhg86AGTAFoFlBFln1AvWnzsacCBsHXXlkSUGR4moPPA2oPfctFQssN9lsEShhTyaHgHm8HghkscxrAGNiqsnP1zs0Ng6s2thrAgvUDcF7nWAs1his61jwcS1ivM3oL2sF1kOs11hx4xiDNBn1nvsQYPJ4frkBswNldBQbmtQoiFksyyAZ6NKEjBM3Dm4o3EcEEkGxgKfGC8mPEsgSUHYMwhhLSH1iW4RRyFB2oD6AdjyuAmYLsE2YIBs9NBJYKDmoALIPgwbIOvQXgUsgTII7BqaGoYiMiFBMrlscsgRie8oPPYxyRpQMzHiAztG1cWul4wO4wig9jmTQIgwaEuZhRYykCHQgQGZuAYhXBRAJeAWUHXBq4HKceACuAavlT4q4FqcW7GT4-4NrAgjh84m01RQFuk3BecH1BvoLUUhoMAWVuknMGuHVBdggNB2oOvMfpCN0yYE90ZwS0Exgik49VzBiRtz90hDwWuUAAxCr3HfwcAG1S-IEtUU0BDKUbU3C9aUUMnoKx-TXynSJzHYY9uC10GynlG9uAnMXZglwFENvOATjlAx_UGUL4MiAVEL7MkQGnMVwDohuNgYhuGiaU1uiLMmAKBINuiEYhZlYh4X1gIB7wdBWNkIh_j1tSJEIe-a-EEc3EMF-_gPpysOSgYHoKZs3hix-XDlJsweTyaVjFb0FfBUhqIxySREPNKrSk1-tYDZsQVBAhm4LEhxuDUhWDAyyUDB9B81nis-DksAukPlqZwSNw8B0chYhxTsOvhvo3qFZOzEMd0a-FMhko1ZoGhAno_kJcE0UKvkgaAjs2qmIw_ZQyEb1CKO02EMhaTFshlkKLBJYMTgZYOsEt9lcI9uAbsOUSkGiACjwSUNrogAwjaF-H7iokLrMUg3eMdUKXB91w6G_8lqhiSnlG3_T7ogvCahxugrM3UNcgXEL6h9EJEGLpWMOckOIhVkLIhFNDYhv4IywEuFZoTEPU0LEKchldHYhRAE4hydnSQxUH4hK0PtwiJBEhRkJrolUKEIBgUghPAnrB5YLKhFoJA8OADWsM0KRGuELchwYIOsV1mOsInVF0_j0KapEKZU3ajXMYCgmhWEPlGEeXUhdaSgYDYJPcskKGGgMJFCE9Fuh-IJWYUMJchH0O6AihjjBAbm0h3kP-hiMNyhRNBMhk0N1GCokCIlOVmhhSXYYppgpBUlgzcYiBrE2ICy4fPlaEClnpBu6H4AFbDlC_ACT4xiH4Ab3j5h7AH4AhAFuA9wEeAC41PAbIDewsgxvkBaEiAkgHVCUEniAgmH76KQBl4gGFbc1Yje8tcFxYkgHTg-wDIKkgGAAwUBRkSsB2A8gBNhHNxgA8gBCwHgDAAs0AXG3ACo4XkHWA_AD8gF7yZASABFhIADFhdwAeAIKCbG0sNeAssKMs4kmyYSsOfgdbjVhPfU1hLbi5BUAB6IA4BeAECCiA-sP2A-sBThOZDdhNYH4A_oWFhvGHzhswCvKjWkLhiWH4AM4ig6QWmeCPsMog_AHD4wsMrhgZAtA1cJO4_AHygm2A9h4ZELhvsMbhPsO7hNSg7hSD34A5FF7hDcOMYTcJAAY8JAAncIrh08KgQ48JAA_cKuAo8MXhs8JHhIABnEumDKCNcPzUdcL7hk8IHhW8JbhO8Og6-8Ixh2U0Fh4GhnE4vh9hoMESw9cJUA-8NXhdMCyACQFThXkF9h0hSnhbgFoAH8NoAw8M2wT8IDKx8OK0NSnUQkJBAASwH4AtgCFSU0GFh9TWARvsNARr8NLgEwFvSLvQto0CJQRcAHgRF9B9h9TVXA6jmvhU4kw85cJBwHsNUiFCPdI_ABNSNCLfUdCPzSu8WFhD8MEAC7lcAkYAMSRiU3mpiVmk5iRvAmThwA2MG5AOCNMYHCMjAOfCkRigBM-IABbyQfzXw_AAeyDCNoROgCEwNWT6IQgEZw0ty4AEwFYRUMCER2MFHqtYCUR6iL6yaIAGyLCPvh4iNLgkiJkR9iNkRMCPYRtiOkRUiNERxiIsApiOyytWUyALADyArCMigB0jw08iIxhCiOmwosKTiKiOIwXiJqyUSPCRaiO8RmiMsRoOWsRIAAAAxLzQwAF_D-AGkj1fPwAQkTkkKYU-C84XTB-mnXDVwB7D34TslvYVj9R4dHtrEYoi_YTcAA4Y8AiAAQBIoKeBhAFiB_wJ8AZLAQA6XIkAN4NwA4AB1AsANVAsAPIAOoIkBqoIkBJkQJBqoAJA4oNAjLsKLDmkRLCUIAQAoYJ0j-GIEhekawB-kUkAhkSMixkcAAJkVMiZkXMiFkUsj7cKsjxYYHC2kYjAdpDsiekYrD9kQMijkaMjxkZMjpkcABZkR1B5kcABFkfwBEsEDlR4cPAp4SQVc4fEj28kehhYd3lYYPPCscK-wCEa_CRED-oAAJVQwBSCsDdgA48LpHoRTFHYoxPjsAf6zOAJKBLAHRTngHHgNASwSXoVwD6gF3qxAOwAAAdrrAG9BkwEcG4A7QH9h6yJGAfKO2R3SMjhf1CgARGwtAgiXTgwViR6UADQgquCIAcAHTg5cHwAxAFNSYgDsQAgDlRw0lqQWsCkArgAkAVaXjAIACk0FSOXhtrj6IysDiRvsML2DSNURPKMDhxBDbsVoBEA0t1WcFoF6GFoET4UMAAA7EEg5gH5ARAJHDWAJFB34G3YxwN8BfYBV5ZoCcizkT8i_kQCigUYaiQcKCjp4eCjj4ZCjlkZQjp4fpIO8jUj2APCijUcmh-ANfULUXUj6vNaiRcLciWkU8AdvI6jLQBEUcoK6ju-gUB3UV6ifUXcAhQArCvgIGjg0QT9-kYkhr6t2iYAJGivkecjfkZcjAUUsiQUV3Dk0fMAIUbXkoUdEjM0bABs0XCie8vmiPoILDMgLQRIEcWiQAAXDykY0jP0vp04AFxUp4f28-zh7BwEVuixIGNEPkJS5YAAkhtgNwA9IMCj5RFOjHQsfDN-i-jnCEOhm4RgiAhjui90Tz9fYYei9KgZ1c4sfCv5ueAyeH2d-tIaB0EXgBMEWiB9Gi8JvCIzdMAGAg8AF-iMGG-iU0a_DP0Qmjv0cajBQEM4AMZMELUZ4iQACBjUKmBjT0TwoYMfopDQCMA81q4B04D8B04Ce8YAAqitIFAibkZRjwNG_IoEWDAo8CAiX4YfCORBvC08CJip4UxiuIvvCnET_Dj4TLxT3ElBqVEAjhMSgjRMbAi14KgB04MZZskSAAFMa_CGgLUh7AOr0AMLQAdpKY8JMepjYEZpiQAOUALEOnAkiPpjDMb7CQmPkAUgCU5qAGpjmqFJjU0UDF04IjRXAD5jaon5jX4WxiOMSFi31GFjfYTQR_EdZjfMRpjT0RTg8gOnBBkVFj3SDFjBYb8B2MSmi54YljbMVPCogLOBAsYJMMsSLgssSAAK2AFhysdNhKsbYBKAMmBh4ZdgW8pvD30Xhje6lhiwkSYjd0UOpQgKRjNsuRjgMeBoj0SeiIMRItoMfEtYMfmBmMenBuwqJhiEunBu1Fxj_APOj4kZ-kBMawibMc_Cp4f3D8saFikscfCZMTIg5Md_C8MlPClMZB5VMQliDsYVjj4RABtMbpjogC5jzscfDjMaZiHANtJdpLVjETodjX4Q5iUgE5jZwC9jK5FPD3MRYgvMQGAbsdFi_sb7DCUIFizQD9iPoJViIsVDlvYftiYcXdjX4XFioERjjMsbDjB4emh5UeljocfjisccBicse-i8cRViCcbui4cKVi9EaTiaceTjuYT5gskUzi6sbTiGsU1iN4S1iLKDhiZ0R-jOsQRj3iD-iQAEEABIANiX0kNjSEYgBRseBjX4ZBjoMXrUqgOnBxuiDR04DYN91JriH8unAoaB4BjwEhAuwfSZewGUIDuOHwF5BLjEADNANCEQAZIN_wDuC3tWIGrjZcnkJw-DHAjMHhACgKxindvKArcTbj5CHbjngPbZCUBqBvcd_xpsRLi1sQuiNsf3hBMQoQUcUfD8oK1iBcTmjWcfl5o8RRikUf5wccFPDzwOeAUkORJpILIgygiEgw8DJAusdTiIkZYgtYKtj90fEjAMYhpZcfLjf4RNi5DEYBN9FDRmGE7jqAEQdHcaXjqAC7iBMAxiJ3i1g11JniesbHjG2PHjQYJVie8TPAL4bPxacWIYmaDjwZuInkoPElBh4Snj54e1jfYfhi10T1ix4LQBiEkSgXQKIB68QujG8aKJm8aBjj0QrjfYUrj28XRBj8fHEz8WOAJ8RRip8cFotsQVidscfC9sUg9kcbTjjsaAj5Ma9jX4ZdiVMZ7Ukcc1AucY9i9MWIiDMRATfYe9izMV9irMdTjOcSzj7MfABHMc5ikCa5j-AODjPMXY9YCU0tacfDigseQTTYDgTUcYzgaCZViccYwTacTji0saIcOcb9icCTtJWALljBcVgSuCf_jX4cVjAcQrhMMZwTgCTgTqseziBCZIShCbgjGsc1i18DviM0Xvj08UCgJ8fwBs8QFxvMcfDRDI3MrgHyiRgFrgT8T9R38STBz8ZXir4YIAwAMxApccdtL8etiRsXfixsYri28WyodcaxCPCTYM9cTAADcUZZjcasBUKqrjxup0BbCZQBrcRWQBAGABF3P3ivcSVjQidETmIJESNCNETYiZxcB8TpjxumkSPcaHijhCViLcZOAYicPiDQEUS7CemjVEd_i7gKwi58TESgEbQT5CfwAV8YzQ18XYIN8STxt8fzjd8bhj98cLjD8RRjyADMA5seET7CbKNHCTHjnCdRj78a3i04NBiNcVrjvCbrj9cYbjjLKBgVcR4AXcRKp8SiHjiidNjwqvCABAOnA8IPEBhicxB04DYA5sYToKieWi-MVOJNsffDaiR4B6iZVjmia0SPqhTwOiRvCVCdCieieoThQFYSxcTURGQADhTiZQBRiWGFxieujbiXLiXCQ_iHIO4T5iQ_ltcT4TliQESgUBUg9KiEScgNNigSbqZQSZXjusVCS1CVVi-iUm5jUb3lISb7Dr8SsjoSS3jj4Wej4lh7BtgNsAhifPieMTSSqiTPjE8VEBnicvjeEi0T18ZbVN8Z0TX0d0TBcR1iM8SLjCSb7DT0NsAaEPLBdMYlATXmQTKSfnCyMZSSv8ZMSIgDRjxsbMTn8dNjZSfKSbYIqTEkMqSEEdcSnCXcS48TUTaceR8oAD7jxMZ3CGiagjfYRjAXQLyScCUFj04MejtgEQARSarFU8VPCD8WSSC0eLit3kWh5UTIh48X1QwUeKTeiZKS30fUik-v0TfYSRwIZOnBehjujiSfhjEyaWihMY0jbUY8BpPn9AkED6iIAI1gVYfW5G0bOBm3FlBy8SkBpAM_wenDlw-ShMREAOkFeQWmSUZMkJEgLJIXFL0MB0b7Bx0SbCJkSbDZkQST2AAwcxcV2T5UQn5t3lmTfiSSSEybvikyQoQaSYWSngFkBeAmWSKyXW5ehrWTZfMKAGySOJmyaoBWya4B2yY0h-kTOSeyX2SiNo0Ei0IOSTYYsiRyVbDR0ROSk0dSSD0fxjrSQ8TacV2SXcf6SHEiGSoSTOTNcSJdVSdOi08UuSNCRaSesVaj8yTai1kXaityaWTZgOWTa3PEB9yYBh6yY2SlYKeSMAOeTLyTmRrydFlfYPY07yf7QZUW3ZnyW-TRye-SpSbWBPyeqSgMbLj7iYxV_ydFlAKV8SJIdOSyKUcSNQAuS4yX8SOCbmSriYhSbiRuTiyduT0KbuSsKdWSUgAeTcKSeSGNi2SY1G2SOyaRTf1reTwECAgNQE-Thyaci3yeOTGKRYBmKYNiNScNirSdPibSTgSAKaAjk8bxTjUWBS5yUWh04Mu8hKdBSzRJoSdAAG9CEbMQp0WZ9VcNBAtocLC1fFOiHCaxSoKVPDRhvBhxhroTeMQuFWEa1iUyfwAwKVRT3KcS9PKVPDvKXBSBiX5TevvPCgqRkAQqUbgwqXeCoSZFSm8dFTj4bFShmudxP8TKTbZMlSnKaGSwKXhBMqTo9sqWAjUsq0IfKcVSOCYVSM0QNTSqZjByqRFSxiVFTiSXVT4qVDjEqc1T74SlSQKT1j0QPejoyWKSvKb1TOhD5SqqTfiaqa_CZqcc4EqTSSkqYtTWqVCTVqbshTLHW9uqa_DcqRNSISVNTFyYdSGqXlSesadTkyc5CGGALDkCWsQy0U0t54S6Tm4TsBz4T5SvyaoiJylgApysOUp4VXDA4KDTTKQITYydBS24dbAfKeslwgDLiqsVSlDkkGSsMhOTN4VlEsaajSMAMOkp4bkjsUXpBKBgTSUyTGTGiW_D_4dUiwaSxTqqZDToaRwhYaS3CSafvCuiaoTFyWmip0fMVT0VUjP4W9TC0UhksaaJllUh-j8aYjSFREOg6aUDSTUdy4zUaJT54eDSbiWzT5qpzTamq3D4aXvCCaYGTU0XOixaaUjd2gATTUSyIASauBFaXZj4MYhirMVOiNaQ3iS4ZOVtacfC4aSDSDaXLSjaa_D6EabShaR7T2sA7TsEYLSkyunEg6X-isET5SiaZZSmETGkrERJTVERbhvjG9SPoGwizwPpj0MYziPEb7C0kZFAYAMmA9IEZAA1GnTawBeCKqTcT86a4AoYGAAjIDzi08FijLwc1QckdFAYYNjBsYI1SLAMmB1fGnhW6diiwAHpBgsWXSLAFlVK6fEjckegBIoB4AqaV3T2APmDm6bVEckQpBXAJFB66U8SR6cZBe6VHhl6cjBIoMmAoYHPTPUdvSW6ekiFID3T0AFDBh6WnhbwePSF0bki1fInwC6ROSzKYlT80vsBj0ikjX4S1gaEHYi8NAABSOGAp8QBk8fRqnx0pOFepLbEqAItBSg72FbjAzFLwc1FyI-Bnz0ZBlbgvDQUhOGBLUwjHJoW2lFY8s4X4p2ks0vala0krTJYoeE-0jalTw_2lh082nCEghk-Uj0oR0-hkkYxinZTPBnHw4jEVEItGm052kTEqcQDBFAlUcXjGkMmGn0knuGUMvmnCUumC3pLwDgY2hnT5fBmsMhRmIgAspKMvCim0jGkX4qal-ZDQJTw4ADh8a5E0kszKWgM2FQM0UBQSEQAjgVRATRS3pH4fJG8YkxmBRcKDlU86nNQQGl2Y4jHogZmkWUqKmiMjmniMihm80n4nSMmhnzwwOksM7xkB08Om0IJRlRM2mkeMuJmhAWcTMFHxnS4uOnQkwRmg4_ynYcGkn-M1OnY4iRnBMhdHEkyTB3peRnhM0rycMvrGMMmJnEIJJno0iWkZMpxl6M4-EGM4xhGMxpEtMkCDmMyxmuYGxkjgOxmEABxnGMvzL5AFxk-wtXxuMgGkZopWlR43hnEMvJmu0qGnu0wplBM0UlSM6ClhMjNERM1MkwASXHRM0sqxM4-HzMhJmzMuzES4lJnciNJm7UjkngaLJkLgRBEBUpZmXlN2lkMwJm0EQ2lUM-kmyM-DC1Muhl7Mg5kqM2rLMMwFmNM1oCY05pm6MmJB8qNpmGMsBnTw3Rk9M1JEWM15zWM6gCDM-_AjMrpljM2FGTM6gbAUnBnI4xJnHw2_C149kkZovhlQk_JnkMz5mSMkJlbMj6j_MxRmksmxDks5lmqM0FnV4sfF14s5nxIpWlkstdRXMq3gLM3xnVU1BrfpbJlDUiGnLM9mkFM2LFFMjZkMs09G_Mipk7Mqpnf0tlnj4w5nT5NRmssmvHasqdFaMrGktMmFl2Y4ADz4sjQIs7pkaMoTEgAVFlWM-WQYs9gBDMi_HGI0eG4siZnngglnk5aUkcM1-FJEsEmis9Jl-M2VmrMhVnrMgMnfMv2lMsnVmIgCFEjEuNkgs45kBsxNl8shdFK0wYn4k4Nm3MxpE0sj5mxAL5mbM6hmxs4FlTwrNmBsjlnJs-pnHwitlps5akzM_ll209aQgkytk5syams0sNnvMtZl0s4plEkxcnbM-JG7MyuEtstADZs4Fl6stBGjsnTFts9NlQkpWmBs4VkUshvGLM78kCMyVmPMnJnWQijH5sntmFs-lklMxcllMuRlVshNnlEidlcsmwnns-eHGsqFkNEVpmvwi1lAxMPEFEjpnWspFm2stcn2svpnos2xlYs5BmjMhojjMnNFTMr6kK0klmvwiklEMsVkkMrtliMvdml0vtnwUgdmlsypkAs_gBQctDm6sy9kUkudk9YpWlGQJdk3Mjtl7UiVm0ZB_HCMl5mlw-DkRs3tlKsw9nSM49l_MpNlTwzDnqso5k1syDngs_YAms6FkdSfRke8VwCdM1RE2s7Rlfsh1n9M51mus7Fkicz1kgcn1mrPdhkQc32Gv40_Hykj_Htsx6mds15krM7tm0c_dlIcijHEkwdkLo4dkgAVTlmE9TmEMrDmcslNkqc--Bv4qznW03BnKc_gAWc7IDmEojmac4elRUsjlCM55l5suDkBMhDlFs5Vk_M8pmns4-HucvNZOcpNmTs-zkEqNTnuADTlGsppk6M-9lmsgTlvssukes-9nIsu1kSc39mYs-xkAcnFlAcvFnes6ZnQMHAmGkyoDyo3iBmkghHQckNnac6jnBc_TmIc-jn9s0Jmoc9jkssv2nxAOUl1ck0myDSaTmki9l2cuhGDco0n1cpUk0dFUl4cijFK02rkKkhrnzcqaBec5rm5syon3MjdkUcgLkysnTlys2lkGcrrnIcxjmqsyLkDcqABDc1blzcsblNcmznVssEDHwlbnGktbkPc46kZo29npc0xmZctpl2kh0m2w99l5cz9lsIwrlOsv9klc91mIs8rless3xVc_1mpk_imZk7zlY0z9Izw6Vma0oLnysj1n8oULkMc6CnKIljknMlHkKUqtnxc_gDIGGOnaRLGkPZXXidgB7Hx4sCE0k-nmJ0vOlnzJ-lY8BFn08_rLaI08HCwiGAHSVnlmI2rJ88x7Jf0vOnq-PJFy0xbmcU39ZA4h8n0fNHkZMjHkAEJ5m5MwLlHc8Nl4885AE87rlE80XlXc5HkK81ynK8ibmcc32HU802mx0qKn083xFM84WEs8xpFs8yXk5I88A95PSCeo7UA880XlJI_nm6I8QkNCYRG8Y3nkWI7RHs85enS8uESy8htnVc-mlm83ZCBY2wA-U4knE8stknM8MmtyZPnLs0zl1Ml7mvw_NbEcrTmkcmALq8rdm8YtXmzBf7mvwr4TZ-BFm7sy1Hl8wzkqc2nkZM13nwScmkwAT3meouTEi8xJEO8-LFXAZ3mqI-nmQMn2EQwAACcofL954vLxy0tIaEiPNc5YZKV5SfKjJhsLjSS8FT5i5PT5T3KnhifI3gOfIp5l7KL5KvN85ZfPx5FfLuZMwXOQcwVhZtfKz8LZRy50JKuyh2VpisfWwRr8LD5WiIl5nfOf5jfN15LKH15R-Lb5dvL95kfL9hcAF_prhQUgIDNgFmTlERM_MSRc_IgFaSO75RkC95ffJd5s_PD5tWQF5kzKQFGiMH58eN7yYHJtpy_PSpEFN9pvsN35fXPjZpPIV5VFOP5k3NwJRHms5lLNXZO3Jv5QAqv5WvLa5uPMRZl_Jb5bnNAF1VPt5jPKH5W4P75GiNQFlkDPmnqKSgMfMIF5iJ_5OiP0cgvJD50gpUFySL_5r8Ipp0vJppcfKR5aVP4peEG350jNoFQ7I1ZJvPTJZgri5l7Ot5W3JI51_LgC5fKx5LtO15enMAFiqGAFFGNt5Ygr95xAqd5ygt_5_xOPhaSL0gekCSgkUBvAk_N95yAtwFagsZxwfOF52AoSFqgtQF0fJj5S_POZ-_P4pB_M6p_CmN5JgtN5WfIyAhQs3Z1Ao9hl3LP5rXLeZNHO8F8QARZn6XIRllIoxeYSGx87NCi4UTSAUDIKFk1H0xB_PyRmJ1We0pIoxP3Oqp_kVQAYUSiAvQsz5q_LVpjSKmFFoEBoowE9SFbBoQ8rNdhZApc5uQoYF6ZIKFy71YxeCkWFVgvQ54uPyFZQsOJHlNNppTJqFTgpL5VHPqF7XMaF4GOEF4AF-CUDIWE-mOSyipK4wMnIXREwr2pprP45bTN-FSvMCxsQj9IGtWE5NxNE5vTLRZ8smyAD2L9JpXNk5cPJA5BiMA5loFdYQk1hpVziIAjRBmcIPMtA_UAkGrCIhgifCWAFoAhgSYneF_guBFfmT8Az8DJppLKgFf9PgFZvlgFiAuxFFoGZFbRHwFVwEPpOwuJZewtfhlAqGJNwoz54ov4pGVKlF0bNix9wvVpnAux5ngoaFggr15z_JaFXmk6FvsI6FbQvw53QtmFOaIzpswHOJBVH0xTArkRIwvQYRLMBFaXMmFRooiiOVKoFNJOWFqwpGA6woyAmwo15hWVtF1OOMFFwsYFZoqOF8MmKFQYvTJcoqyptwqPZSoo4FMHKeFunPVFM8PeFZ0i-FdeKcR4IsT8AIqhJQIt5FD7N9hwACzFXGEhFoWT-ABxlhF0KI_ZYnPB5P7KRFfiNRFMPKcZwHLCpWIrK5OIukwYQrQRBIqJFyThJFnqVIGNYspF1ItpF3xIXRDIt5F_ItZF39PZFMApAZF4P_pPIvbFfIviAAosD5cKJyFTbLyFCvI6p8oroF0FPapGoAqFarLC52OLjFK7ITFfAueFAgpnhlfPA0rQqAx7QsiRBoqW5TormFdrI6pAwqQJdgpCR_ot9ZouJvZDor2pywp6F0FLsFvGPdF3JS9F8zggpQfE3FGbIuZpgqPFoYpOF4YsPFIoGPF5gugpTHJPFV-JVFHgv4FU8JTFZ3IoxaYtSR3wu_F-hz-FGjKTReYuXFBYv4ARYqolEIuqIZYphF_YrMZKLLrFDKIbFOYpKZcnNbFjjL8yuIq7FvsNecBLl7F7AvRFpIsHFFIpwAVIq4Ko4vpFogsZFDRCnFEAp_pHIvnFwDKXF0kpXFLIsFFuaPgl87Lsxl6NiAkCMaIS8Fz51LPwlV-Jx5OtNQIMwFdRHEARp7wuJJTRHDFZkt6ApaIt5BfOAxm6PMlPkvnhZErtZI0H0xhGnfRTiMt6LoFfifEr8FKkppJn9N0FedMignqMpCifGfRz_OXSxOQNFzcMB4BAp3pdMCmcM-IyceGhwAnqLkcCkohgFUuk00_LKlSYgKRvGPjShkqF5xkvw5pkoCl3kvgAm3OVFl4sO5hEqDputLPh3tLclsYoi5JPLupnUu3R9gpYFXkumlU6JClX7LClSBIilKaKilVvUZkcUrOxELLE5qkr-5oIsfZmAH1e8AHkAAAC6OJflzxOdxLkRb5JGgErA22FtKKMThLTLGHVXoFPCPJc_znpeUVfMLlKT4flLzwX3SipYQZ74d6IlgAvTKpUAyU-CjBGpbyKWxb9KUCGFTAZd7QSpWBD2ADVKFCJ6i4YA1LZREJKGiI3hVcMnDs5MDiJ-TgBhRVGyM0ROLlxRpLZxZk5tJdyL-xVOKWpZoLlxQAx0gqwiEulgzcZZaB1JW7zIBdALaZYdJE-HAKcAHpBJ-bpK4RX5lx-Y-KxJZSBEZYVLkZawjSpZvZQYApLlZXVLryAUi2pUty7MTwyHhT5y6hUmKXhX9LHJc5KW9iNKSJZaj-aSbTpRWdjUmWwzwOWKK4ceogVSBNKnZWtSsJe9Kt-bULYOWqKjZQbwRWcpK_qFjT40j7NeWPojOZYlKh0oZK2ETh8cEWwjlpfAzM6UgTbAC38RgA4zI2koQOkUEiunqrE5eTgTLqQIAepfuKIUc7LrJedzsJeeL7RTtLeORlyDpYWLpCpWLTOaqyXpcSg3pcfCPpVzKVhVBKI8D6LeBXpKyRalJ74a4UaRfJKmxdWLf8UvSdALLLN6fHLEmInKUubgjU5enKqOLnS2EdUifBXHL-ABDyeJSiL8kavLC0anCN5fAzt5VJz_2dDKWsZ3K4ZXazY5fAyE5V-yk5U4iU5X9Bl5bMRM5ajL4YGOKbJX1LVRQNLa-ZjIoEVrLKCaXLrqR9JwxQXK4ACAqIZB7La2UbybeQlK0hUQKJBTPilEdPLb5XPL75QvLYEYYxn5WgyV5YdIlgD6IQhfPy-IgVKEFdoLtEVLK8NBJD1gAuJLZr4JMuKlYLEHSC6gWZh9sDKodBNogOyt5pM_lYAGgElYu-K4QM4CFYLFBJAoYHpA-zlQMJFUpB4lhXTBorwVoxipcoIL1o9FElAkrJ-CTrJYBTEKwYyrFNx-FZSj-xOeALFPxh5FUghyLgSlnPkwwo4rlJ3QFrFWaLAAReItFqiEHgUghGAjgPvUcaA9l-8kO8rjoQltiIor2AP4tAFqopRuOQsJDKYp_DA1ZZDNoCorB-DNFfDxnAKYheEn_tSBY40BmPWliBRKpvTOYAHOl9Q70XmATgCMBzAIzdStkgqjQOaBRVNHxvJQcZo8HKoVKa2QeFYEq8Wv54M4CErjMWVZE-GYBl6PKsBSODEFcpRYhgB5h2gECTH0JTFHMMlkj3qrQxcPUATqBqV29lrRlcKIcrLhkJGlaooMFqnAjsH1pSeBVhUFhDBAkSH8aUFsrAbJNxGaCEtgLKYtTELUgBFsmB4YPsrllS4tVlZoDyFvqB_wTjwKeInA3IKYgVMfP1hEbcrL-G-DixG5B2-OjxVFCB4tFKp4u8tHyzFW3oEEWxAiSMQLhpIx9JldsBRZgTQ_nGegNIEtJfAB5gxmpzcnbP188wPPj41gKpmXNFEM0CjRGPv4rGlZ78lPBVg04CWlLzm5BEeGlBQOf4r0HCFYsHCn8YlR5DNrMtYTCuN8aUP-CuVQnkvwap1EuvxhvVqsAo6OkhRZsDRXYvOd7FQuB0EMyUbcpQA7cuO8UgKEA1VnoAkQDi9qiESkTltHsllX8q9QUKrPwUaCJINFAoVejt-MJb0MyDmtiqjjQ2zvXJk1PGoZVYxE5VSf0ReJltYVUJ1hItQBnfk51ScDuto0GSQE1syVGVFQBlYFAwf1LVss9l3iDoQ7ESOLnEjVclAyeEcrSxO8T_lYBDAFleddFnJ1mVQv0fVdwosOhHRrlm-8vqCLRJUOkdtTHYqk1ejQx1jt5-2iaB8zgFEq1WIwBiPxg3qKzRcEosgBMKKouOkTQN6D2rhpELyJlWOt5zsmBdrkOrPaD6r5zoQkoYDN0hBOUQ5wPOqQdELz3wI40SpG51p9nCxmFLhACIEa8dSH5JhpCRsQ1dggZ1sJdigq8BFPmypOlUSQ4QOlsVWBGsd9g3B_FQYtdFqaqjFArQOTPP4flfyqdDBE0LKve4X3LqBz3FQtuUchTHgHrU5KVWT1YUpSjyV7BZBpIBOwN6hkNdKoZLEGjUILNBGFSkBuAIRpHKvTQXKjjxPPIBrLapZVj3O-qQNWBqkfvKANydBrMKbBqe-vBqZIIhqMgMhr0AKhr0KRhrMuIRpXaiNpParRTXyWOS7YUQB9kemCMhO1piFl_dlFfooolUNo3auYp5DM_5flXxB31RJVfXPnjyFidYKeLUhNFZYYIrM2D1epwZpKWhTpVFxAKgTKioEEEpi-uiowlMwrb5EUh0jlTpHlHwoeFBZYLrj8sulF-YJSLj11EEPN-3mEpxNTspghCYRlxiXoBlAGYIRhTt_FWeBaPK0IhgXzdjBhVxjNNnNoZgXN1gEsNtLoKIZZr8FNZp_wxTrZ05NNxARKqTsJ-AjoLkjAB96ODEoYPD4tEB7kOKnk1KoB0im6jhEFIZVAtkU3UMcQxVKDm1rYAB0iW3kjD2tQYVfRJZc8BL8E4tZ0I7wKBQbYRe0tqdQBhNv_sNRHwIKKiw4HVF813VGaIhhPWFfVN5U-_nK0FwusFxmprl8hJ0IttSMIzVC0CeUDoF8wvfp-wuM8U9EsIqFh9B-woUNvhOEM_hMjEihvBsShkH08urWAXtZ9qnhN9ro-qUM8RG9qQcADqg-rEMQdVDrnjMq99RpGBERJCJ3_JfxrtTOFswv4MsEdDrGkBdr_kKycKBL8FsgK7sITpj0xNkTQCSlHcvbl8JiddH10dQUNAdYCIydaDqkhvZEIBptF-ggKdQKE0RdnseAaddugtJlL4gXrzrgddug2Vrmtr1IFhbAJ6gudUvASptdq-dTmRsdYrqWjoCERdR6xOYvLq1dWUNkhirrqdVrr74rVNhqt5VNdWTr-SnaLOcbdscyEn02don1NCKEjR0IGUIsNdqldfSw6InjpCdTdrCwqmMzIh7q9etlCisicx-wvbgbBlgjpZRXwXtSHqkMSL8tdeRJndZbq8EtxpToUH0w9YHqPtUH1o9Uzrk9YzNnjCegPdSzr-7jlNdfuF8ApL7rbZCkNrtfoM-8u7qWpFmF6whYJKyBq05tagBDtXi4zvCcwzREOgFwiehbZC3rI3IwxvKmaJe9YLlOlGOBLIHehoZi6EnNclrbNd88LAFiopqC2RGHBNqgGKCC-bjZocVhCR7tYiI6QoU9mVjVR4dV7dERFdMISDEQ7pqF8qFQjqIsNvqaqBWQr9f4BoZjtrCkntrMDobiN6v7qt0MXhCnkr5QKMtBNsMZglsBpR6qD_qJEhjDXTLWIqRgshcdU7Ufnv6pttNtUXNAyN7JhJoA1GMdHJh_Vi6k8ZUBGRpbCDXU4JlK0Jampkm6tLK59fMUUYMQaWfhHx55OokIJNNFl9agAptc7AbYUsMpRjbr1lN9gQDfnFfAXGUfWGuTGNGacmZlcBKwsYQLovIBopfABigGlN5imlN2jJHxG0mlM4CozNrxs1LA-U2l96OokLALIaXQP5kZiETN13GlMgCdhjOYvwa1JEIasDXKV-hg2FJDftppDd3UHsveNTpL8EwYIglhsNhJUEpEAsEX2S9kmOJgov0M9ksIyylQtRc6UQDtIuQbrxuIK_EdhArgDFB1DVVlwBeu4m0sIbzhuokDDebqRcMYjDdWLpStb4pLVNaojui3yWug20YClmok-hjCB_jTCdRR65IfLppjqEnFbCJPqjNDPqTNC-ZTqAvrT8Evqm9QlrUtjZpYLET4JZiYQt9ffqd9T0ab9SThhjTqwD9Y5Mj9XtNEZpMhT9ZAbz9QpyHVNfqdWLfqpjZMhH9X8pn9TldhnG_roGOqIrgGMaEVhCtlfBwbc1gcbvNSSsuqMAaSRjldMPBAaTxBtw7jjka4DQ5MEDTAJBqsgaTjtGUy2qYaYBGRpTfkfh-_A7BcDZXRoyjz5CDfVrGZse1p8mQbFDXH9xxE3r7DcRgaDWdI6DQwbX9d9hmDcy9GDe-xTjeTLlYmnhutQ_C-DeokTDZga_jXKUATYQBsgGIbLDeokpDeokZDU0QkTcEa_qKEaHxsob9HKoa0phoakpYWl5IBkjeaCyaAJVlM7EitUOqt5VDcWkBsjbAbwYjWRkEUQarOMUa7dZgwyjX8pyEZUaVNSlkQtXAB6jaioUtTWB59WPrfrlAhzNGbAqTT9Q6jV5p19XdovNI3xajbabaxCkCr9Q6bA4G5ojVK5oKjYapJTVkavNEsMzTXmErTU6b5dPTCqxIzCngV0ILuhzC6gQwggsfEJEhMhqzQBZZXiYKTsCpvjjQcqwUZBZZjfhaaHftyJd9NV8I_viqo_j90B5jMCiru4oLLH_YaAAA5iXiA4i0AUoXuIT1_FYoYxDG5BFNdJ42zeYo3Fgn904F2aRFfKAgllop-zZ549rLx4CjIJZijNJ5qeBOahLJUoR9QQBIehKAlFEQAF1bkIy4tmFzpkFjfSWuazfIHt4lhaAjIH2cgsaf5yopjqkMY31hQEGNcuppFq0qubHGMchoXK_EnwHQALQMFZsJJRB0-AKBfJE9BXuH-hwFORJGhIKtCkulsbgKMxA7Aua7-YBdTzXcIe2p0VU7Kl5CcEHkIqBoQP6jf8H3qqlPhntUCqu0BHAOpgswCdErWpDFhAGHFHVeyCzWR3sbVNhJqutDCxtR1IjRrqYbYjRqLABFhI6qhbMvN-FUfoDgKyMGVdOogABMX-k_1IlhuvC3kXdBxaLspySZytk4GdXv4zzQzqBmtVJ_4abEasMBEBLZh0JVM0ABBH6pS6PtqKLUoo1dow9ddoM8sQHJag-uHdctSi0_ppZwNAgxbrYlhDU3qNAlIBoQbLYR4ZmIMIv2mABqTMVBPLTkC_pnG0VXvq0fdfRbEdHpa1duWMNAvpalIvbdMoXAl2pDlBIrYLwUzW0ShSSTxlmGeAlza4AVzVDAYLZub3jAzrQYBFbhIpAN3xjJdeHBRbXLeMR3LcvlPLdpwfLTc84regBIrTJRA7jldpCtccI4LXRVVM5azWZFapdHNDc2vTJCrbUJTnpXJNsLgkwCi8A2ZBgaQEpXJ5AFcBiNLglqNJtgBgmgAr2EdAfxNFLtgMtbfXpQo_oh1aonpQobjaQ85WvtkoLU9qGrRkDTomABarT-JoIATQ4AcD8bLcEdrrRdAwADkDJksYxIyo9aKLc9abrfVa_IhQEUAsmgbLRB9UNqdazWVyMLCODaOpLdb7mnZ8h_vFcLrcPrgtT9931OVEn9C_o2mudMBqUXUTLWnrY-kUM99IBSanu61qYmeahacq0kIQe1n9Efo4vAjhy6paEx4A1UrUoZtSasZsgqvF4mqgbQflIe1p8reQInjKEruNQAjcPJ9cWNck-GlVqd7ENVebYiB-bXvo0ZB0F76HvprkpPz1ZR59L0AYiFoENA6APAbAsJeheChoQNbdOMubVKArJqMLHJmtBwwD3EtbetByxmtBw0FHgzwLX01oE_ozzfRon9Fjawcu6QHNuNViMFdDaopba6AM1E_AQ6cEzjxojVEzaaQMjbqjX7q0bbBbQDnBaNii6YzIlX1_dQzrvdBub6denqyvHRacoH5NzgvRacrfsJE7Wp8goH8IbLSFb6LQM0X9Eyp3whABGcAdh-wrSJ6UH6FKFGdayrfRbfra9bYbfdbhkiOgXtWmgAUtDaFnAl9lmHPt0UG3azWauF1pBl9jdXcJyvpQ4z9HiCi6KfwKbJAVCHF45poVaFg7VaFMbcfpS-GX9s5s7RK_qtrJdWvai8osFRfgNwvrkb8w_rmb68MWbi5pbZIvpC8F8hLV7huK0cigTpemkCk2ytFk0RhvbqzIdoxoQ-cu9f71BZoNExhsM0epFy4ogHMw9tqWEWQHUFkgH4q5Wv5o9gqH5E9MuMP7VP8wfpO88zVbxJWif1ygonpyovG90HSQ6BSJONgnlm8FmKpktikV8SzXRlmLRjEf_hg6snlQ7n-DWoLvu68uLWC9iMCJbLsHoU2HZQ6SSJONGHXG8crjJbeHNr8lXg5b5-sswevCehZHWegCXl7cjvhqUKHXH4sHVw6r7Sr9bPsMktikrzzrabgFfre9sCFo7MHZw6lYN5RJ3vo7pftgEFqJdh5oAl0hHdH4eHVS9KKIdp2HaQ7U7ZgMpfgz8jalxgoCnz9sHvTJLHRw6xHVw73bUWUStPJBkHYnozxkg8GdUdbawF2SztalUVdQk6BSJXrTdl9F7YCOsRwGIx4QMupgImg1TROkBN0XmBrWit0A6HOByNcn4RwIIEaOiKoOnJbFQgmIE7nvxhPULXbvTMTVD3lUxSSu2UU2gEbPqIHB0aC80vWtCpkcDE0HwOlh1QrHai7b0IHbcmglnVBQnVN-FAXre03bc-koAqg0KAk-1VwHjaMdey1SvHP8iSFA7mFJmokqWg699EptJ-nK1AaAs6J-sc6pooWQmwk87M7edrzDq87lndFbcMp8UJ_iao5nbKBnndmE1naXavbuga1Wk3Vpnt7kGHX47Q3LQggMWpJA_iLh5qhnadnbdFsYts6_hBs6LsvkyCcviaA9beRa-r86ugFICCKsfobjRSRyXfcICbU8JNXnACopBH4xcKLNmXANT1Pnc7SasLs99BC6MbbTbp8p6cBagNTtqi9qBqXCgA3rcIMdcY6HeHvoPgNlB1oM1EvHd5taAty7eaiEMgMANS6alWQXtRo6FlNsLnCAADntX8J9XZT4nHaNMSMNFkMnfSwVdXdqsmjWBXTiWNtXR6cSTj1NkrtLJLMBHRdqgjZhpAuFN6LxAbmOM06PgQVKgkqpY4k3bXmgNSR3hEFq3qOpWmKrJslS6Aphl0BHXNa6zXSw6rXSeAVwufqDbfIR0nSuFQdldq7hLVbTXQE6KOH3b6yMg7vHisRvSAoFEgBDaBqY2dCwCLNOuD8BClUerXJH6779F9gGuE80t1RcAaoQjrsnSSQ9els7iHdo6cnX8JZXaNAEuqyR0nbK6uCol0jXfnk-qAu7E_GlAC3WXrHjarrgnSm7VcmS8HMP2E8LR-ZxXRu6NCMu6RcEapjHS4Jj3dmLX0aAz3oSf513VxhBeF_RoGFu6jBlJVrXQuE1HbNRSaDLwWLqhwInv5CSpEFdGIgFS2Or27H4KzRq3g89gPXvp_IUC6XaMRZqDIixEPekhkLj5p-MJ9gKOjVgJXe4q5wPFkwoNRtcvny7CoM7Zacl9FIQAIIPYg5siQLhAgaCOACOOqhiOOm7y3Vi0jHXvoJJjDRz3uw53zqh7AkPq6WPUURk0Ok6M3Q_pcWDx6l1Oe8OPsssEPeRwjcKB0xbOfogGBfbODFfaZoCThxPRx7mXc_db7YWb8HUw6z0Jb80Xn5oMPbA5P3fWEDyBK7tPT-7bZDZ75XfPQ18F3pqzREBi5vWbnip1DiHEQ4BqUp6R2tDDy-hn15lJu77PYWEeKClFksptx3jHtrn3ex6zHZG0eGNmx5DAOhmyoolYCMz8TzGObYeLObZpLAU9AeJYgKh8NSTCPE_TKrVVPagAbQpfb-vjNBb8mkUbpoGYNTN3g48O8YcHUmMgzB5x5BBSRKPZDbm0qV7tgCJ6p3qNM0boQorZpSDpLJIgc3Fd0YzbfBO4ByCSID_B75HBBH5PeISlDMBCxAtqOOEsBoIJEVVDl3BOQbMALQFiAIlBeVqgEd6RUZKh-kZDTzvR8Ap0KaCZFhKjjsBpqEeHJ0dNXprZDAZrHBNaCxKpQl5gdQI_gCJBdiL0DiZJ5JJAP97PJEaR13v0lKPD_A7jWUp64Ld7wUCckOODLxMgFpgFlKWNtcOdM9vg1DN9IeMiaIHaLuEhYtYDeBwgBEAifcnhwuAodQsF7sVRGFJGABxxTng1DqoEuCckiIMWfSA61DuFxSfbk5UANVBoDC7AyfdQAckpT6vuNVBRfVrAckiJKBAIkxxJZEAJyQPL_YAPBqoAl0FIDkkm3tmjqoHpAufV9wOJJexqoA3FMGBcwWoIq7wwJgwpABxwmoOKEUfWj64QC8wkFDztqod5J4ZNAodJCRIQHWgp9_rjJgFJG5Cfd_JMAK76CZK2wvuDz7yfezJA_SApn2KRYAOMSwhjDb7mkP0lkDKrpUSBL6IoPZdHwYHYDGDr5voP0sl0CugfGBugvTOiB8vJj67gBYQGQHCBS_TfVBiMFgRWtAwvXrqBPOJRzLXZrgFUbMAaKh-8qFOKBmgBzE8nZ9wVGH-gemIn4Gvif46sG37NKtIhZEN37fEu4FgsI2RiIqNyowPy80iGwwZ9Pw4wWpaIcmOxh0AArYR_UjJa_Wv6PJhv7n2GPt_UCkCWCEiZeve719SEiZECGeBZ9OYI-_ekoXJun6tilq4OUMFh7_ev6KSFq45wh6Ri-ojYbRLZ1Z_RaRD_fLA59DbB-XqVgv_TQ4T7AmQXNJ_64dLMANjSqItjV7dKIKxiiaN6SxgFd86sFiBJEDAHwA2qbTvBalbXFcBMA_VDAClK5yA2hDKA4lgrXFuxsA5wRXZCDgnXOQGXQMwGNzOTlIvlv7ZnB9QDnF0QgCBYRlqMFgTSZ36MgEm8j0Av6TXgy1r_bhgxA5QoJA3gTwoNIGWndQoq1YwoDaD1UGGBL468KoHTXppFJMDxA4A7xh2yHItlA6qw76DIG5EBM0zyWMBZyA3EUdXxBnFNZEmuBOAYEJrwLA56krA2oHrqUkATUsxsPoDyUClTgBJAyoGfAwYGmVKBwwg5YHF_UcBbcc8xqeS36x_VD7n4hYH9AxqUvAjEGMg8ww6sNB6SUMBycgzdgUg5P6u_ekGIg-KkKg4gRx_R37FA2kHrrRA78g9kGKgxj79ANf17tZRBTwY3xEBoQAFDm0HjhDZ7xJOKAgmrt8t7BqBMlCTYkzLgH1SHJ7wioHyfSO7RTwRWRrwQsGLHD0GP-PoJJg2_ZRRBXx8oSLgug5dhrwXr9hvXdhhbN7hrTGPYh6E2oKvUldNvtMttcBE5__XbozBQjq5Rjlhu6EuDVg2bpPg8wDQsB8GQHV8HX6CIM_vjxEwMpdD0kL9hHISCG_gzXQdwS4xAQ7kg4QyjRfg-8HfnIeCOsKNB3aNKphsDD8KqHaQtg4mhybDcGjlIo9rKNQAvoDcDzuIQIuyYrB9UipMWCEvbE1HX5sRqH1WA9a6OBu6IjXGyGTwByHogO65psFZ7phtiNEA3vbd2smhj_dHhOva0Hosj8o6sOSHZgJSGoBDSHaNRHhmNqVhKfS17_UF2TZQ8Fh5QzMBFQzQJlQ-0BNPRKGzwNP7_UAl4UgQl4Z_XIHFkPgGYIG2lbyF9AzbXgGaba_o4vEiFcMPaGG4EjhMvAig1nIgGSDKSHs5uxYHLlzRtQM9BZIHOAVtXcHTYLQwFDlQRuvcl7XAnoJqYX8pbABGG9XijQUouAjYhE_8JkrmH0vX1bCkrQwIHQAxAxn-JPjIQJdhoFU4vKggOg_xtzANMHNiPhQ4Dn_7aw9PkqvZwZnLFp7uoEBJqcJiQ1NU97BFS97tNSWD3vTu5DNRqhCYX8pRRGvJkTocGVDrJxTYElBBJttERJmjD2gBJNEaNJMQdHJM3odwHZ7a4q9_TUUTrktDEsIbpBISDgHdFeGKqG2CTBBgBNsMdpNsKn6tvWq7eOGPg0pOxxPwyDhrlC7cnw8rBGcLE0kunwC9igxhPQyWRAiKsNEsDIxrSokw6zojTYMHExjGLswvNK7QMjZyjgABYdaTq373KuIH6g70lZRIbryQ3OYFbbDRqoK_7MJgf60ip-a5zI37LcBZ1cpu8RiI6gA_XrdxVcBRGcI0MQxTLRHu1PRHr0PU1skjkkLmImAvoIWJhMbsGKaIbr7NphG8A2OBu_dJHB7IkgKw-LJPjNVA6sOWGrzZWHUQIpGV9UPYbuBgB1I_eHTBLpH92OpHdQ_uxTI1KHzI7hh72BkBTI_r6LGBZHL2IpGfdPMobI3aHk5tmxFI8dpqoMdofI6GIjcH5HAo5jAfIwJDIgH5Hwo0QBTIz3ZvsB5Hy8LFG0gIpGPAYXoONHABqoClGKUscY4AIpGr7aKAkFVr7FI5Khnnu8NNYRIwCgEZHGQIbqRI81A_wzn9tSBZ0ScIwBwfYD7vSFuBFIy1B-vo4px3Vfbuo3yNuoFKdawAz7-8Kj6E_YsqdVlIN-fV1H-8PVCGzIpG8DiA6pox-HG2ANDq0PNHiwtz6hfagb3SKn7xfXRYYDDMB1ozVG6sb1GZo_LD1oxb6Ro7b7bmFHg3GMJipmLTg-IwYGZfqMbvw42wuRtgRy2PD9yLP1G3SOjFho42xRo-j71EkuDqoF9HK2DNHWfSDHFo8ABwYxxxVo5gB1o0hGQ_VtGDfTgEjo-olYY29GOENycW4BdGrmFdGxo8dHR0B1Gx1LSR-o5zEyYyqZOCn8UcYrVEqY4shgalTGJVKX8EpocxAI94QGpBlGtVsz7gAFTHZo33RWljDH-YyIN9mAlMmlvzHzo-okpADt6gI8TGdCHdG18DLHZgIWIaozIxYmP4BDGChGqwmhGnkd0jjkDtJzmDBHImHcw6YdxBJEKAhaZO8x3huvJ1gFrovpCRFIWOLI3fRgYJsPvIHoE7GffbBJpo_-xJ5ACp2WNjHOOA7Ht5BHotoZ76I_ZG4bw8PI4ZCcKI4yPo7aDH7mNJ7GYFCPox9N5Jv2IyHXuInHrOMuw52IBwQDPRZO2HnHY_dBxjI_UJ04_nGv0F7pi5JZIQ-AnoXbuH7k4y7GawAzGsFN3IXTiewHZEi6GoeHGm40H6Jqh77nfbHG-45H60Xl_JnfT_IivToRa5OfpUo-cY25PqwU5MLJbEkMZJEEn7a9FWCbY0pxYmMtHO2IvY2OBWxIuPvGW4wqGKbD_pHwSf7wTOn7QuK-H-8OfHQuMODy49fHwIfgw1OK3Ht45lG9impxn_fAIrgH-oCFKJ4wYl9BQzXXByzabZ5vFGanZvSD2uPpIqAKa9pkPRBIaQOi13BWwcuNgAIlJgBPRJ7Ni4N7Nnupgm5YAHN5gZRA3ILsh5gMKoGUUbigUHZYYPAZYViV2DTLEq4DaBZZDlfVYM1Ynks1R-CtQTmr-FnmqTrJYIHvVyZP1XIKhDMaDP3P5ZUtfpJjEApdZQXd4A5JO8ZvrKBE9IBIbLs3NZExtBREMMpKzVqbnQROby0pYAmaNDYJuO2JjLn55dE5YYDE_VYjExuIDFqObyeGYnZDAYmXLiYnpPPYn9EycqnEzYmWzQBZXEwYnnADLxKeKQseE7UhParItFDD4mTlX4mAk65cNxMEnqrP4rXqmpqQk-p5_7n_t2gAkmHvbEnPqiknxFgotLrAZ5AkxkmQk_IZ9Loot8k9Emn3BKiQk9Es4VZ8Z-gMwoKvHAmW1iOAv3rOAYPekgFVcmr4OrctugMR75mKOtURnMrRVJTce3qEwKqsk9MfJmNGk0cgBQC8A5Gg9QlPTqEHMMFCZfE2hoAH3oKaAlDeFbbUP1fnYv1UIZtcmoFsQElBdVbADI2kohAsKzRioCwnjlZmqTVdmqixDwmuTHJ0LCMFDrk2wnLahwnf3CKrc1U8mTrGDI27McmnnqcmG4mV4LIbWBvUOnA8zP7bwU6GJIU5uDoU3ScjkycnFQmbHMfKKDWNHO41LtRcpvGf7VGsrkzpsnbafF_snbmg6boUsdTkPpJakJJd4Drg7wE4toUYeSmK_HUhJLg04sLaKRvhlF5wXPWrwTP9kyU4hRKU5JdPwAM0ovM1xpE5SAxBAdg8zo7Y2iA2qpvHOprYhow41HXgo4l9EtYiVJe1IkhehOVBmICIB8QNZJNVce97w_wECAFDRggLWqReEWEHVAyn-U8ymsLqfdYwyjC27JinFLlSnALrbpq5vSmyU-KBFLs5ZXU_yVRASkdvhhNFhk8k9uUx7pKLmuoUaLymIIU6mr4limxCIKmCOh9BDZvGmBio6nsQM6nZQX6mZqJl6J5CUm8k14ZU_oknSrLdJUUymqoUJEUG5k3M5jMfZ5vtmm8U11cYbiE1Rrukntk5knkky5comhV4_U4bYA0-ym605JcYwh0FDuDPBFUxKsn_kKmkHMyZ0U-rRM0-pca2n4UzIjiw8AM5Y5wf6hdMJWVlU7OBGohXccUwEbqfA2mhQnbdKKg7d-PZ6ZSU2cFd02JB_TKD86U08IDAlen3vh9wdvPCc-ngmYX03GmXU9SmjpvG8N09j1GedumEgI-mVeH3aEyB-nT_Z8lgM0xhjXVz4i_jWmNLu6mEQScI4M-wIebBeEH07nd5vOYdtjgkco7vPlWhqomsM7DNQjuEdBeDhnAkMc8-HXFdrthcdGUxUNMM74UJIUaV_NIRnFtBHdWMwe7TPhhnNnmxniM_lrSM3-0OM3kcP6E_tMNpdgP096ms05JcUhkmthjvkdFORKGljBmnGU36ndnspnc8OWM4ZiTA4zqymG_oGnfAsKBnIA6qUgNbi4ntPlc8AUAd0wxnfPoNEWpuBtMMt6po03nRgM5lp7aDCM4ziOg-0_ZnGyECNY07nhs07pnkjv2mFQIpdfM8pnJM5SAAszWAvMz0cLQHFmoDogJwM3XgEgZc8VJmVcc5pNhozsdVhriyYfXOEmUk8Zcomg_RrM5CdAgUbYMJt65EfN4mjsHonfE_4m3ICB5yk5UmS0zrY9Ae70_M3Xge0499ws_Gmus8tSys780sgLZcF0xzZp08um509insQH3ZitRkJ04Pgmz2NbJl02un0oJPYWHF3oZ0yums0SoI3BJeE_CQQnFs6xpls_NmVWJGA5s3tmFs_mElsyKEF6dSF4bB3925i_YO7PpD0oH-mLM4BmhYiVnzXQemaTIfaawJyET7cBtK3s0AaSveHMlGHFSSFumGyWKn8gMDjos0SRuYvyoWMPVSTaI7YpvATRUzHDnLCMOmQaHKB5LoCDhHc5mSs-C1NLdJ1qziZmnMKxpswMeAWAO_CHGkSRt8K9nIc1ZnvVNaFDVV9EZsN4cpvB7Biszxn3vilc-NIjnawOmFG8tznuM-896vJjmPoFEBT3mvRL_BGqUM_342c4NEOc4cmR4B7BZc64AnBILmZI4pdQ0-rmFwErBuCpLnyoNjminfjnIM59n_hp8lhsxLmvoivRBLgGJjs4iA6OsumEtqwB3fDkAS0duotIKiLW7TMBHg2163aDOqOks9nUIN3QMc97Yw1LR9uSvUwR1tKtLWqvB4Q0KDppB2d9Gm0FkgDvZ-VG4HpQKKoRaHwJVrkpHjBNymxPipg3qD1Ix1kGNWoDWclcw6pFg_MH3VO7QVg7bjZgN3QUYfeGbQ8WGJmBA6ulaa1HMG9QB1ejR0wrS56XB7A0XF0AhmAPAT-sk5ZSASLJwDAN4xJq5wBI8GvAiQmN4GQnXVBQnViedJ-bGAxF87AHiTR9B4xIK5DnIwnTbaVLryCAaj8zXRFXPkItA2WYa6F0Gxg32hrwcRIaFb_a-IKDBClWhhdvGlAF83K1P85ko0MEbQKDp_nUAMGIYQJ08lCE08lCIUq6qE2EaUPGI-8OfUPsDHq-ntk0Zk1h1IJrAmI8LarZk-smzdJnnUNtYgMyBCIkU0CmTQr1F1YsuFDM_-mdICkBmc-LmR4Br8jdl3m-_e2RugCwNk-BWQxgAQNWBum8yOv04bSK7YbHsR1DcVwBRnM9R00HY9i1h-UbgCzcBmEjYz6okAL6qLRGIrrclCxfV-SjSgRgLwUpKrho-C8swxgIYSQdJQMFOTShKtcyquC09QIYCnxL3QmYRgLubCBmYWMhDABdzRwWooFwX7gsYVTC-8ZCsogX4MMoWUC6bqUhqDBQizoXgC9JpKtREWFCFEXyoHI5wi3EXpNAkXUANDK6hofnwBEgXAi4kgFdba7nBqEXP85raUi5EXCi3I5XC5kp4i5rbdvEkWSi9DL7mDBn_C8gXsizHqQi2EXoi6DAiaEUWYi-UWki90WFCCMBgC7UWIHT5M5QP7qZDUP0A-JkWL6pMN49eRIGi1kWzcDHqZhvypCPYqspk4w52ALOd5zvFsfevtwcQAuAbSAdwYWJ2AGpLitintNJw-Mudv-ExFLEHKpmkJaEwWG3ZXdsioGkxHhDDg6IkSQ2QMC9X6Q80PQebB081M1sBXi9mIkSgsTiC7Mn7i59mf09ZQHi9iAniwkCdiyzH_nXxABM0_mMswKc1AKzrirQmqRiwucXhAmI6RQjrLk6IrWSORnci8JpRRGasY9dLKoabiWoxKvYo8F5Idi1yHaonmYmS0mIi9WvgKjiw1hvYgJjzll67EzVnzEycrLEw0BjEwYsomqSXSs9psOdX69APUEAoAEbgUaGdp_c7857ISaBIQ-CH5fa9dbYnL9TeJsAFwIqXF4pQWD07xh1s-Nmts4RhGcwBn6C0BmSswvoYM07mDs-rQ7-PXoy0zwrMnonptPjN14Nn-tXvhiWstStmDzrcHd0OKqC9tgXTXq5h0wqWrVc1R9NVegAGpF7Bv-JXCFwGApccbKqBAvodG9bA5hhu0BfDcWYqSwoQdiwjGCfT6WBY9WgPlMJUMhMFDA888HG0IFDznWbBYy8cXhIgjsxzsF7h1OanFVdM0Ucx4glojYhrRPCHOy-irwWuYAD3mlchy6Gm3OgIIPOn3sWgB_i5WlpcinA3ZsS8YVJbekhxtPYlyxgJBkaqmcpk7gWUZJGBtyzdhyxmCWBhv89ASxWxoumcX3i14TTywgJuGsDVgSwGWnyyWhpS5fxMngA7zvD6Wh0Fpcli5jm7M6kdMnpOndTjzhpvsS9ZvgKRIwNR9Cnit83BBZrGPD7BW3LvEagdN7IhDSgBEjeAePEyrRFR3TMfBcqM4G-C0oKYXMfM4A1YFhWC1YWqGlfcrALJcqvqjyrZDKopXCLUhDQBQNeCvxgfC0SQVlTRWKk_6CtrCwtfXMxXVy6XJeVDkBngD75JwH0cwxeWmAldRX8K3RWvIURXJFUSRIwFxW5KwXYAwfxWmK4aAnqF_QoVd-MvJGqnFPmn4LgN9EEaDEBCMj0kksl0BOiMsz1MriKRipEU1mtwqpbHxA-EZ4taK9q4HEK7gMGWzw6pEKK2xRYBkENyUrgFQMM5kEAJcInxUhc2Zo3IFpwq-eC9IFFXPi0fgbwOtJzwR6jjELiShRZQNrzH0BfTkKKMpdeZVrcPz4YAAmfVS5VEeElZPMJEUMaOSBYgKnCDsAdxkHfUBcPQExt6nkAIoosgYtWOBIrXeBhYn9s9aDWY-pLMIPuN2EgPhj8awMHd-g0iVvpOHd1_m0GorSpN2CzQBXeqPRZyLgkdtcm9N3ctXEgH-7w7eZNi3qdAlHr2d4ljRVK3HO8MK4M1RVLgl0aKYhSK81Wi_Lsgi6IGMo4MFiy1slowEHmAPYP7DA4XQAkOvXbw4siKX-AhrcQGHFJALdWyK7vFvScEVvVX2dG5mSoR4PvpquNZhYiR8gofTts5VB7FSpd3kjEW05xVs6IhgIAXFohwAltsa8pgErKbyFls-zgPthliSiThfZsRcNYBmiDkAHMrgki9rTXj1akAGa9c1x86OX13L1IZ7S9sO1hYBXCHTWtaFzWBmD4kWa2ok_HoUls6kNJaoozWFgaRXPcTMs2CN5jKdv4qZIB4BpYKYg4ABwB_UHNilgJrijax4Bzpgso5sab5saxq00oJrjLa7hW5Wou4JIOnBF3ESQra4FbL-OnxpfLr50-DfELNOghLQt6gva6FC0AL7XUgP7Xs-phi5WvrXPMFgB38--M0oJ7WnqN6hhWgnXQxILx8NIt4_oqb50-PG9Pa7ORvUBYR8QAo7upFlBZQEPD4DDBm0IeiH0oOnweGOkqh3aVEL2sYVTa6b4cgC4IHRDSJF3PNAjzQ0J4NDTlaAvWkTM4cHkbMYVbVESQ260ZKlIWTk5hPWkPAA3WRcEXXV4sYUUgIVBx6yDpn0VPWwskz9SQfPXpsIvWFObAR8QJIAJIKQLoYUapQYM6NbYKwBaFVCr5elh0bASbnxGHY919L5IQRE-rXMDrQta6RsRgzwqWsIrwr4gu5CBHgB04JkoQGz9B04OdNF6zyhgG-wB_6QsDLlVhXV6_2Ao1TABewSchuMPhXEG4VB4lqfXWHPsV04ILxSK-RX5oLwU1mPKjYG34wyK2-CkG9Fs0G7yciG9Q3snNHXeCYQ2qG3qDlmKQ30oCw24Gww29QTQ2UG3Q3uMLw3EeG-Wx7kHXZfKKCgRIjrG-ufFjChABpLbAM-zpGBeCk9Rvi6w4e3Bv0lGyo2jQH2c1G_vxFG_EtlG8YUjG09QXrfEs9G4ronADcEKG7g3QbkU5WAEsAoWGSBnG-MAazI-EfEPAXOlEU4NRA42foI42XGzMB3G04BPG-i8inMUEr1TWZIm1R8gm0sVZ7YjDr0Csm94TfE-zhhXEGxZp_gbr4km3OB4lqk3qG-ggMmzfQkm4u4cm-KjqG4mc71fFc53l_WKErtcwYhUAn6zoJy86_WAaE-qe1Zj50pHO4F3DqVMC58oAMpZw_6502PAIjrsOPPTXCheDbs7b9GQIM3X4kA2-m6U9L-F_WBDlM2AGx4Bum8CoyQo19vKsUAta1wiLWYAkBADahiNFrWgEksAjm-AkCoLgaQbi2EF3DrXsADM2LQwu4KkFOhzpl-JfIn3U55MFEPAEZ1OpsDVibi6AoAIDJ3injUvsP83hYlrXQYH82FwIDIW8h9xIW0hC0QHCgQWwuBtEsRVGZMo27UKZ8kW0LFs4sf016XtQ4W84w0oMUAFIMRoCW2iBIEs5CZIyWGsW84wp47WBwDiHX2gMxs0xrFhFymcAQM-Y6UomkiZoPJAFIDn5EbZWFASFSV5AFVVyW5c3tEx02VmxsgsAPc3emwT7nm4Sn5xoA2lm53EVm2s3hm5C7EbVrXbmzK20W1rWnm9X6ILaSZwuKiARa8erInCcK7-hZoTkFuUV_pa37WFAaLVIiRv_vw10oCsnqiPfQNBMvWbW4VBj-u6276MUDvW4DtlmLnQ8rX6RNitJXJW6RZUQE_FZm5xnUNqQCqM8sGlmCmGRdEaohLWg713KYhGQOpFkVAM8RIm5XuK84AbpjyhF9hdBC23JXQYA1I0i6H8vuKiBs26SkBfaa2Tharr4JA23c243wNm1S2_lGeAeq4kB1Img5eEvwi5K7vo628dQNm1c2rlNgBBm0A3ecoq3AYptWJIJIAAAHppI2aCraVwCuo3gC8AJYrAAKGAFQDdtbtndsowPdsHt0GCbtrJHHt09ucgQjToQBlhbARHW85Wn3mAUauHV5NDzQUUTXoaLbRKRKqJcaMS2oPE2pAfowoNn9uvt2qjslgDv24OevINjeDJLbjBgd70SZyu1AHh2sAscaO21MG5srN1wCytm-KPNvYDWZbTjbNiRFnN94AHN05t7N94ApAQ5sUdg0jUdr1IXNiVvLNueLYdxmRxtkd4Ed-duTgZVtJSVVtzxdVvpSYC1_KbVtYd5836t_DtDZcUK_16dtYd2dsIZL1Jm17jsXxQZuPt85zPtrjva1kTt6tvDvydhe3R3RkCZYVKHSCBttxtgzvl2Ijj9N_Ttl2V6B9nVSu0V9St8Vxjuqthtumd6zv-oATsnPGsCJN-Xwat03ymF7BvpQWzs8VzyEaVxiuCVnSsRtnhUjANH3GdtztzNnjsUN4iv_qq5SMgTyJPxHVuxtjix6GnjuIWuVtX-zvMqiSVtzxaVvPmh-twaCB3Xu0HKHyeCs2ggw5Te-WEMGAezFpawRlpXlWdACRGuImRGcgILWqah6HmgqvLauNazyQNayBQSdt8QC-aY2TByyLW7gLCpH08Km8CigYKxaK8tIBGV72SebVzc8UUB5wRODHgmsDY8Soo5wDRRCi0qtzdhbsJK01XLdzRSrd_7zauVpVhK1pWWGHbsWAKzyigdxYAy3Ts0oJK3vE9M2cGT7vtEiebddqIyYFU_LYFC_K4FbVxmieSBUGxr615eSAkFEbsgJ9NyMwMjy0guru0KG7rbcAdoZIEtxKwMtyBzQdyRzAdzduCJQHRfjzw-jDxeaVmGBIHDziJ-0HZe7QHGIV6rkar7tfVSzzWef6oQgSBYyeensxg_sQA2C2r7uYxBeeALyf3AXvJg-H1ZuZs0nJbQnT4Fz7duKRj5t3LAk9wcRN1Y8vA1eYpNWi6BK988BL1MHjQmxECRWm8jS9qaDHl2LT02uLyNKK3KFa4nRJd1ixale7qkguRpI1O1QFvfpJaM4logdBMhOqN3tviHQNEFz1TAxKjMWEJ1QB9lq3oMF3t3-SYLu95_aLg3Z2W7XA4R5LpWIQo9BzrPwKpxZ2ANolqSke8IHh9jTpehZ_yplRL2xh8ijt2057YuiS0X82_lmswS0ktNfApRZ4xfGRRIfQOn58W4vtV9-xJOqPwLpOdoCA0Vw3tAMQBAjAAhQWzJxyOdoCMAAfvV8jqRLAVW3T9mfvT98-VsFt65l9-9qne68XV9j3sx9pfsvpMcSEuig6-ZflDpRUrD8YD2Lb1eNS-xaToudegpAxOH69KWEBtseqvJAMmP22FzokiUkFa0QMhktRfuu9pDIwA_VVkJcNqwdP963RLRk_9w5LyGVjIH9tTu-PI1usWAjwO9hULxtv-qCFdFLr_J3sqTPDy0IWAdsC3LBI1OJqI2g4rQDigqIQ5bO7oY7QnoAdrd6aRr29rAeRgLXusSQrrFdDWrW65EE1KRTh1HaTjFNZPRsDiwBG9kJDHdpAyv9uCF1-mcHwtkA4oQ1EhV11lSYQ1iDYQ7fz1pX7zI-VDw-QktojAA7o0p7-1D5N7x7JOqEg-drCiMAGHEwzHRuxopKqDopEaQ7GF09yTwIw2cNIwkA6kD-i5dCSGGmDmGHmD1zx89j6pWD07w2DokK8yZcNJQy-GuQlwfNK-hbOADwcuiLwdE0DJrgw6QeODvIb1pRnsqeIUks9n6pWeP6pKD_zqbdAggMD6pW5NBSFWMegfzdH6itamgwhYW84t5TL4GDoIkE1dAhZD3LpODwWw71tMMqiWmHA3BHsIV5jx35Vjye9eYD2ai8TlYV2IBCF1UkW_bhTAP8ZLcf109SfGtyqQEjWgN-spZdw1IYkPLBeMHvwJT9ZWheJ1yG0cDK1f8ZOGsQ3W9BeTjFmIC7DxmQwaULivebipd9BICm9LYf00Jw2TF6pj7D4fp3D6aBCVYxBnD-7Ki8q4dq9W4f6HQfqPDn4cvDswDDeEkFsCip3XD1wizCeDrI5kaSbDtXqbD3HO4IbJxPO1LJq9FSR5CNXo2uxmOzAYt25WlSbDFunWoiSPWmPBHU2DKPtiZ8TS7atqot-o1Q2DbCEOuoWZxU4ZrwyYaSEj64SM3DlQkj9LJytJiR3gQsQH5XAqaZukMCNXUK3S-fqrgJEdgj1djr_NEf_jesNDVN0bdD6UfKVbMT8sRUeyGfVLxdd92iiJiSb-JjP5dsId7yEPKNYI2i3Shhj4pRstN2qhBc3SzC34bwhK87PoQFIvJjQD6jpRXKLDheYAhU-fx2togA8j4qHDwFLPn-nyRygYqAOj90ehiVkghj0lIkwLECJYCMcejjlCBjsoF-bAfVujgYh0K4hRtDquYIgycao952YMIatjslHBN9uN-D5j01J497twE90Oaw-3yQRzL2ZFj_WDVjymKbuXkPSCZ5wZIWhNok4UAMJ2_OCKBhB31-IQMa7CkJww7131iJRvYNqCmCcZXw-scc5QCcc_Dxb3qbEfCx4V0C9A6xAeAEBALj3DgxIP7Lo3Y6u4oyp1nYEWgSVX0pjrSj7GEPR4SfPrZxLRx6Myc7Y9okyp4h-vYexFAiHYY7BmPINbjLbgeo5ntHEredZQKwWuNLAJ7Y7GDs-gBPbukZ-hqnRpBZ4UNPbF1AuHloswbFpYBKReoBy8aIhgxVzCuI8Va47T1bO-Je5-9ebF1JkTDuqgySFPSdQvHFVaTD4AB39HHb0JFZZIITVHHYYOi55ujZOrDWsnJDzUsoX1MMT6sPzOM5DpBJb78nGJJprZFRGcc6aZrNAs1gZUB8nCUiqzeQjFOO9BaEBIFTLJtR4rJEuOoeZxtYISc7oTBjsFnsi_RoZYMUdE59rZgvQMICQaTkCf0ibqgNAIows29gCbGSbBTLV8uOMKye6gZ81VkUycGrRZDGYUCjOTmyd2T4DASUVGCenZkFFGVyd95FGYeTug45F_5aJYdydCTnACLlfSeRT5oux1kHCxT8yfZvYCdyopKfBFmMa1gNKdZT-c4IkCKeUl4IvOegQY5XAtoSQacfoAWcd_UXja8TkA75T6v1x0agHFTwycctyNoghpchtT3CcyTm85xT2E6pLK8tYAflgElDUe4hmBjNeFIattHktqdzNZHV8VbcKcOr-wAAicTxOCdV1ic8KzMb3O-b7aIQbyKwaE4kTwScgTrSfnTSO39OqEsJmMSeQTVaeUphie7TscD7To6eZTtRvMuSdo8jDvyr9E_pGFDkYkvNfwfTo_rfThdoAz8_pb-BMjnTsktAYFfMbjpcdCBsPDv5ShTOWXjYJiICTZ-JQjAjCUMR29Mbvdhc0i7NIZ8BQgTi7bnbCofEwyncR25a1IZpzc2gGffGe-JHcfirRubnjtko2kT4CbbfwIuvR-C8saaS8FOEDZ1D2qxl1x6SAZBDKwN_v5AEQRKRfdSeNJW4CqKU15gOD1Xj_8dygYWapzIFBC7Wif6NZoDGrRralBlGgb0QRsH0u_rfRIW6UfF1bIla_Tza-cD34CviaofVYdrWbZEAeUIL7Ay2uYaVQBMQ9WVDHfpL9aIB4-xjrrBtDD6oG2cprSYc60Y1bvvShS6zxkHoNg2dDSZlxC3HOoo8SwBHYQRXM9JxbM0M2c-zy2dWOGEABz1c5bT2XbSjeXa9jfGdnDeDBzbAMsArVUpx9l-1xjEQBsxYudoyH6eH5b0fqVZWeK7HfoefLyYXQF_giDKcZx16aJE60ucOz1VqDz2gym9-2fmiRauBYVufFztugk4aedUznfoloCFsjzgvsxmZtJsp5DqlAEefsAUlsjz2iAaqVWsdMZUg6HahQjbR3ZlCaHAYdGkpN7Z_i1VRofiCPqJUj7yqGugV79zg9jK4IecJAsttpZ0DTVtmyf6zqGB39XlC1zoWL1z0-50jk_rtl_QB39bPpHgF6s_ULgY9NwtUJmBP3FfKaSECb-cCNB_zVtp8oT0O_pVtoq2F_Z14HGRBdqN0rBvT5fp1PDBlAzwsByuhXbFzg_qnFnwDH9f6fZiC_q8YPBdDSOhdFzhed8BWoargTXUfz0ed0tVBckJD2SIFXyTwL7ICkL5wTsraBcOtnueOkUFPeVdHb-7ZR59nU6ubCOwB9jOWurLH9SuYT7ZIISMzhBIMaLRL5DFSSUzizmGvxLRWs_qL8RrwfYSb0dWdMLvMCM3X3xlCLtwaiSVQUlIQLNAEjYkcV3oyjMPw2L12K-NIQBg8GHNzgFOkjSUYC0qL7bo0fHbapl8BWIZICcCSzBMKTWAVST8aPVpTA9SOxeLMKUBapj2Ic0tfbc0DdTUAZyCyoZJwtraVZudGctJrG2cx7fRfPNK3I_qFpgfIbMQo0NDFIIJGvf1lAyd-lVPxLYwpDq3raRgABd39QqCxzuQIiHJtbjzl2I9J-tKEJEhN4SKS763IZdPUZxeEJEjbcRJ2yLL5oBuQLrbjJxWfM7c-dPNHpMjzgtYGSWZZKfOpV9K2VEp0YpUhoqYAiHBUy2zxpYlTy7YjwBDIFPSXHHL93ZGL33aX-EOdgIAHajSaEWDAA7Dw7X44e7Deja3cIosXGxzV5soQ2wm2ePLLaepnQxcE7QFcFzirZnzxU5chCCfibTnYArnYDEz-Ztxja3Ykr77aW7f5dYr0lfS7Ue0iWsNtnkGFd9z4KEfL4IYMQ7JwDoayD5efKMRGzvzF-M8BG4XldAofldM8uCeBObleYwUVezxJBXigVxUFAWdCNth6t9oYVcyr8pXPxeVfGYHzCzgZVeSrshzSryICyrwVJ0Awvxd-NVdjgEVearsbLqVQgv8qInDb1RF64vc5dCL3Yt9L9gBAqI0IXLrSfert1eF9Qy3AXQZ54rwFvW8f1ePoeEubDN1cQtig4vzsrOQjsuflQMhMBYEs7FrapZLhwZplz7PpfId-eJro6bcnYyyttsueF9D_velt1d4YJ8YBhUDM5r0mJlzlIaLyCI3MbcMwXLhAYwDOAE1rltcq69oArpUtdFrz-fAhvT3JoDtflrrtd1o9ACI8QIOE0XNefz0derORmhqh85Nlrutf1WuDTUWDiDTr2gxdrnz7YQCUP2dO1XDq7lTMzgVSaR9VGuLiOCtMQIAo0HNcJL-Jc_qANDNOFTBW5sdeM0TzNEkBzo1YGwD-XCXCtRUUF-0TegexKb5Lh8MLhJBqFHpEB3BRU8bxhdf5wSFIEhr4xjLzobykjlOhxQjXaAyBDfCHerhM4UDN9UEsepsdde1roef27KAOvrtzC8BWlRYEDzFRARaK3jfjq4b4ddlzheSUb1wDBRGjfMbejdDz2Xsredje44PudMSCw3XHaJ1SDFV3ZOdYy_m_ES-ruVp18t77IqE3YBSafyUL0FKuFVN5Hqiw1n9FAosL0_pML9hfeOsGb6HCTd9BcNfUKcw7kAN7TJZGNcCbz0LkAR8Js6mAjMZ42rdBKhfjzsHX18kHDzQZLIs6lzfTYVaCqrqMdjgRBeK548CD-GvxyhPtj6HDIZjgZ2BGlfjDlVpKxQTm5aa0acs9vDdTWtF5fxceaLEqVZyI8SQDM0J6hjjJzdIdTLf1_D_NjrxHiMdOdcUHZscrOWNyradzdb22rdSDTOU3YdzclbtKAlbnWxhb59etbudezB_LdMb1kjub-FXmr4vxMbudxIK1k7ubpjcVQjVd8r7VeKrvVeTxtfA8rzVfir_xGb3Fv3Nr8tc0b_rdhbr1KCr7vw0b6WC2r0Ld_UVtdZzpbf5eW1fL-ybL5bog44bsLfbr8U5hbg_7_uy_WibtNb2RKTd_9Vkifbs4t4nR_l4rMQ4ygeQ4-9-774bltfGbkediu97cIbubYgFszfjz-fuh24jBvb4xgJiH7c5DRHTvb1srY0QT6gGsyLvblm1ibj7f_blAYvBMHflriHdCLt7RA748Aw7h2c3kFXXw7lec-bTGFfRWHRJATHp6NHyo07keDplvYAVsberQrqleUjY1b8qHneXLv4AQrtw47FHGhxuo9dfUCPBRdnM50AO9YOb_0spZkncv1ekOUrulfUrz0Lo7ig4o7_ESgwA3e4Dj0067i3a55Ubu_nYl5_w2wBOyXmzQvQgQ875Sc_ZM6S5tl5sEIOAAO7w7V5toy0iRd3dTSKnABL9SoE6jqQpAnncFWs1mrzg-K3_LWIaBfgS0fZFM0bEoJOqdM4lSBQK6xYICfvXgToATm4HvcoBqMfzj8Or6LVvA42Qap4AywyOHKwmOEKU-OFZQJCvWIfQDoQcZwQIIyDIwNJH0gRkCVIfQAWgZMBF00WUYCoyBxC8kcgWx-f_i6vX5SKaRR7jqRRRZmD8sSPeYJWoaFQcacvXbttNDr3c-76F7odt178KO3fe744TdxJ3frp97eu7hDJwvT3cxAA_fwAI_c8vEK08vbhqm9l63WWkodGTyt3JoPbRfkAnUtSGmc6Pffdb7nl4UCU_dML_YYtSL54e7wTsb7q_cO72_etyHGdQ-IuYRvczAHmIrauAZ3YLfVl6Lajl4qFVZLcvVuTnTRFVQl7JydBzLdlb2Ny2-YcD3ou3grbgU7POA5yzJhMNPfVx53YChdHu-0ZFPLACL-ZoDH9Tl6cHo0DabnK487gEuw9Aq2zPfKYE7wPvvvEjrA2-Tez-adpL-Y_o87grexuRHiMLjfxgzvqjaFxcpKHkreH-RO4ZCEYAZTnQ9zrvQ9b3L74fQVIF4H1fycFDQjLvf_eH7_cLQvIA--46wKfJX3fThumPEYEYA-ALSYtb5-i7VBJCIgGg-eoOg8lIOwCeHoIPMLxoqZbvcMBH6g9IKkI-rOeg9YdCI-1gQw8CiaI_kH4woRAKg8qsYI-oAUI8MH1I8WAdI9i6zreyTOI95HhI8FHpI9hH4QF4G3fcn8Fq2XYBXvOH48CzVh-qTCTBcaxZd4ELoyKY7-DfVt0w-OnS7DLvDzdULrJEUvSz4q65d4BeiL5qdilWirWJbormo0GwcBE4l3adkgQcDjbTgysb4asOYD8bZXD6BSvHw6CiXI6uHVXtYj04-Kre6aHFC4pCH6y3Q70BDQtjVBJp88e8OVNCgQHQaK5N4-8iGx2ovBMwIoZFRKg7yhrHtNao4D-DwAYYB52kkSIwSE-KZHKBQuOlCcgTybAVxyaLlEE95KsQ3KwVHDWgShSraVwognn2tAnhXIXQTB4jkBSdMG0qX5grQhvHoUyIdHHvcoIE9SvBFAXQBFBTjcsYIoIFvovNAB1ccwBsiRGBhQrk8Pm04C4uZ82fm0MTfmogC_m87j_m2ZNCi4dB0nxyYIoOMfHAQU-hiENhoAIKePmsU9otiU-Y0aRTSnpkOdjHaIoyBU8FQJU_r7l0TubbyvCOXk9oAdBC8n0MQ3kdQAQHdoCAAYz-3wFB2o1ZqN7WMQZMm_L4sAJqeuhP5QNUAy2Qku0BAABGkXp-eyvkgjEaABVdqsSVPDTTePDzAI6yl1G99CsZglBn6BKPcu69XfR7UwCW9REBW9ckh_gR9G6BrzF6BiPQrPgINIQdoIsAgnjKMxpx57jCwgsRdh57HvzbPhCw7P9oOCMgJhIWwlhrAbJjSM_9yHPFgD4s5RjCslRiHPrczOUWiZmztRnGIs4Lp8u6HlManBg4Hrz9yr6x1YYMC8Cfk8igk_OPpbLB8qfk8aaWrEneHVDU4tDDU4ZwedwK-D_jB8UXYUocfP6ZSc4_X1fP256d0y7H_j35-RMefk_PM3hzjB7H6mEUF_PJnFIskXHAvz7D84OhOyLD563PQF533zimGBaui_2wg-Qh53BZC6EOWWiSnAQsg6gYTZ_4soQ8Q0Bg_khxQ8oh1CvqGeEIAs3Z4sMshhIvOwdyHBPnEzonCShKHcC9bsUCHXZ5_u7Z4YvM4ZID80NIhhwYuNp-CiHgwkovX1IvCeEP7PoRmBMaQ5tGfE3gO8pk3iijuJhnZD4mo4QedA8f5MmrqkHEl9vOeg6JhzF6JoKl6KRAQ4cAMRlHPg54UvlW1z-PWqshGl92Q-h7BcTEyoX8plK6m5Wy0gvCShVZA8vH5TYShJlWSuldH31g4qHZl6tGV6U-h51n4s058nNooEYv4Q-_-r8fsHJQ_JhkV6tifMF3rRuvKNWQDLTIlTpwVsdAUul7bjDrBwUQLHhkQ4K3jy8ZLkhT1Kv1EgYkA6vdYM-UXYiUaBkN7Erj7nAjw2cZAMceB6vJnH04FcZLjl8c7AZnH6vI15AvvpybwQ18nBUftAMd8Zmvi7Fgv0-CC4xccnBMENf7tZ5aBJCFwQT4GcUblUKvGbHJQdOG6BpBlTclINGBkBvI8PQ_zcJsGLPOElvET8g-6LLC4QA80Ek4aKgQESi2vWKCrPKwIzHkgG-v68HrPryDCQWo2Wmh2B0W2o2XQqPGl6XPTiU53Ul704OXPIg-2-u6BoNbA4IHfRtxk215yepKQwvIoTEHlFQkHOqX0vXQnwvBqXrSYN656tl4_GoMHUvFWyShZQ_0HJl4uGl_nMvWMIhvQi3a0tl-MIy4yShYhw_G9fFmqUZwdgutoNGFJrod2K7uiiNuMIEpqGGUeG28DsDTwit-xX4ptVdoV88HFQ5_U7N7MH0N_p4sN-UUtl64uthCLqdUOMIRJlh-7x-N0kIwpnxhC1mZhp9Ixt5mm8matPihwWh5451vFOQaHGt_seeV5aHi57jGUCCKvUuyVg9V5pYHcZok3oFNt011OYL16ngm2BoNwcYPkCfQXAzk1_j3kl5Ym2FIm6d6NYUd-4woojdE0QE999uH9E5OaNY8MhLvoYnDEQ8b8kld9jEZd5jjtd6OqpaZrApehD-YMUBvfMlywNTE-v22kWER14hIp19aHYCakeeZ-jNDmsOgM9wdWBPc7uKrAbPHRhYME11F77oJ0WS99CsdF-YWrC0yM7CxKsQD2MQY800BqnmMQu80PvX90k8xiHhuRlyPv6wDPOhiXvml534Wx99XvmgMfv6wHzThl2UWhWfWAHvxWVT96EWHibcu396T-rX3CW3v3a-xiCHNpyrfmID5T-ES3T-YvZuQ6wIbgC58x8-N6_2IZaJIO6uYUvip6V8akjAJxePWknWqmpRDkC67xRoFW1zGN-32SUD2HuocgbjVnAdX-KEcwVewNVYkFTz1D7akJNfe0_KgmAX3C2uS0QiXWS7zOiK7nA-Z1b-iUlcw2wHbdKahqkoafW2I4DpuNaeO8s9zhB4DtDk4PwjeHFRodIbyD4GOLzCkf2Lm0EPbvAg43OISSEHyN8wvxvfEHOF9JvMg4pvhF857a98EsJF-DumsYhxGUBtQQMJ4m9D78HrE2kvmkOfvV96_uG97_uTicAeXC1svKB3gO1Tz3rcdw6hmxxgBbIT7uJjvXWZMMbIjEj-gQ916nE2W6koaiMwk9xjo-dyPoBNCFuFXjmuj_xxos0Q3UrgGqXEQVqX0MUKXsqhPWv4bifaT-SzQR3Oe5h1SzAjT0o9J16nTJ2nuKgVuOUeFFOg085OzczTwdULgek9xL3H3yR33puMv7t6ifnt6iv3QAPvQT-60kT5duga8iBbj88xHj_Ee_4BQOwm0uw57bafko3IO0suu8aj9qipMIhht5w5L8z5yvfylcfU6Hcfc_C8fNbqT0vSj8f1F4Cfhp1Pvm80sH68-UH3-X5vlt5R-bt_r41B0MBfbUKae_3t1iknqjKERMvkjwwu0mlhfsJqpU5kOZvSz-2fKz64vet7F6H9_oWWz-RfEkFefHmJCSHz6EYYd23rR7C-f9BDOf9z54h5B3vnEQIegez-pfnj5FC3j-Rfvz4svt97PmF50fm54BcfJES5fBz-10C2ukeYMHUv0j2q45z6JaAr45vJ96Mu_C1svc-00iSr6OiFt6Nqyg6xe2r5Zf6T7KfEL9XalEHUvGxzHy9urDe4rD3TdN8wiZzzbsLl4pXsAE-n-YyIzOB7UAeWss42mfqtY3mueLt8myFXk-ns7s1HVULtfi2hV1Ab8Yz8ohgzvPxQQ9r4Vvjr8jfSbEcKf9JDfzajTwMb-3Z9LZTfib8W0UAs_K83w7842kA72DOIwTqkbywHwLf730P12z4MhqL-Ofwg02Orm3t15Q5ZvjL-9IBL4Pe796UW1PAMWtl8XLRr-iHt5xyfNSZmfRy_1f74ThKOz4egZEWhfLtwyhU7fJfUL9pf-L9L788YSBLvyjKl_GIBKL7RfWpDhdyr8uwhzy6fAqa8tOVWwailyZTyS1BSNAM6fqgFUK3T5uPAmYHoF7_vigHRvfzlg78Go5KmMWe-G0OckBCdsVWrqbRP9Mx4BxP3m8AV_p28advfnWRCvysVlETp3Hf-T4d8WVyVzeBwcw0jyKc8r8GOdex5sLeTPf6_27T0Fx6fjk2hz2QG79P76oX0j08vzMHf4uGbOPFGZXXH77kyU2Rvf1H_0kv76XdxtpUfSb-EKJzDo_Rb7YSrhUo_6AC4_br6zfnMVwi_H8Lf6b_E_kn7vfKBTLfdiXaq6t_ZfFr87fzb5w_Pb_rSzlw0Wg75BffEHWMH_2En4Q8Pf3z8A2Pt7XfIBxQOHMzM__g7-f3QB_v9yvFfgkUlfNL5AOPEw0fwr3EvDg9vOj504vB7w9-oD7T-gC0SvFQ_0fj9uJe_n7SvY6z0_UDEgfoX9gfYD6_mkX-0_RZrjwBDpY4Tn5-a3t53KuV8AR_t_grI94ezi2muvOY-gTt8CDmtY59mhPaHcNPYnP1WdFAtWeFLVk9FL1icAftPYFLrX6FLBWfFLPPfyzkSYazBSZiTISYZ7haeMuzWayTnabfvEi1KThabG_FScyTZc0QfHqZcsaYOC8aD9Rv3HDFzyLzbsTA6rjP_w4z5Ei4HnyXhOvqckuR37xi-gAmzOR1tTZ35G1xj5BHgg7p8O38HVWF-sf1ddsf5N44XNF96_bX8MTnX9FfIQ-M_UC67okJc0IBa95Ovl80_SV4tzvOes_5U91vYScFLDifcThn5kWtl5Yz8GftfN5F0Aha7h_Nn60_7t9x_qGam8iX8CHw3_qzjWdzVmSZx_fKbFIF7-RULJ1rqeQ6Z_FKce_MP-4wZt46znYCiz02GXf9yQghn6ZkTLP8434UKEYDKYizk2YTTYB0J_sP51fEmd6zgqZJyraiq-OtH6TVx0by8tzEgitzkuCj-aIN77Lut3kZTPNlUzci5oAl35Z_Ur0uwA6cvfMv9TTtv-VHNLFI_2-QkgrjrW3hX7Cvnb-tTzP8e_HMxt_2IB7TF37F_86ce_eX45vraZW_SSfM8Ll0Z_ov5tT8v9duaTH9_XP5T_Yh3d_O1t296AFDO2exHfBl9xspv5GAEt2t_5v4l_Vv-kEyf79Tdv7XwDv5jOj39lj2QHz_NaeGn_LHd_ImaXd6v-Byiz6Bh6f9vffqY5mZf-r_Af5T_Uf91vfb7KT034Z_Al7CHFQ6d_PqZZ_JRoJfVMJs_zQ7G-8FeksEZsdbFHnzPaPZAAmVllk-cHlkzZ7Q8RsxTUPrvI8m7iR8cV6EscSh3_KD5OSH3-1cN54ev_DFZy8PfG-sENMf8EJ2CFj4JvL79d0GJvDCENlD-_Cy9b_1y9BK85_1s_IkI3_18fNUYCv17_dU0HHhK_c69MuBzPZ5gAtVNUKr86gRWPHHw0Lw0aNTQsigQqGqhtEy81S88d9XC1YgCJHjOUQ41vzFaHEH0RIDB9Z1VWo2rUVIMbr0LPOMNNA2YUNoFWFHaBTdwp9QeUGfVXNXRUctwfN37HaOF5KTg1LWFV3BHHGUFHxDCcH5wpgwY8aSxUwReQIhMElhv1AeZMANA4bADEPCmAFqN_Dm9IeH0jAPoICywPSwFIXp4yzTWBDb8dcEJ6adxBVRUVNRU04A0VLRV9QCLcXoEcNXnNYLVHP0IA1XJEMxJISz8xlAmTMxAXbkbmQ2d2-mEA3uomjWOoF25ujSXfVSdHMApff3dgVCXfcsYyPwcucLQlDjjucg5bpBuwAD9ZUGIDLW4QzQDvbU0OqH-LKIDqdBL9OnQVpxqodfVdqCSA9UQlhC-MW0QBKGONYA0tii8nP3xVjAkgFZMfaxe-RXwrjXvIMAp2gKANYSgXBCcA0bgXAL54HHhNFW0VFC5bjTz8d1876x78CQYAtwZQCSJgtxoEZoCegMZqLoCvXxQKIbdu_DPAfzcK_EC3LYDh_ENDDAAWgP98YoCFCFqebNJeDybCTaAqjQr0Z2gCDD9QRZQNvimwPMIEnhMcCR50Dl8_HX45ExaNInUYvx0eAEDExgbgIECjPQMfYl5mZExBCp4g8zN0PYM8zG0ccxwCC1vDLt8eDVeUeqMIgL9PDPRfkmSccNxcXGYqFMw6zHhcSFx43HxMIlxY3BxcUQQoQJN0dbg6QMRPGkDoOD9LM4s89AqA6TcS9C2mESpZgCr0AQhPgLkaR0xRgFQAEEhatQFnV3pPS00fb0tFzn4nCUgVviPOZkxLAJJIBJ5VdQVAmCtpNwX0YxBQnAFcZvQuGxicLBdmTH1A-VxCQ1QYd_QIfBe_PmBuZDQMKRgldHGQbAwcsFwMIUDAMBFAogwzANFqVodpLCeQdltx7wvEV2hUSDl9LGA8NDePa8FvWVgFN49wXAaEN48TeDuhEIA76FLnWgA3j2jcWMDrY044Bfx1gFPBSMD_6TePJspsxBxgAjpP0CK0KQCbSFdoaoBqxClAeZxGiH4YEcA0b11QVYgbXBdAYsD0bncgFCwMzzMAUsDKyXL4SGlqxDfkNdxzxGDA_WkTuGbAn7AYECGcOMCKn3JzJSAIsAnAmgBWwO4gbsC63F7A5Zl-wP7wFYVOxULlEMDVwJ05dcDG2AngcOINIGXAvsAKwO8AfcCOEE3ArKBOxxDA3XgYBjPArAALwKclJt5jwIY1XcDKwKThAcDpfVbhHsUuUwfAp8DDwO-gXdAvABQxQuUpnGHSK4A0kShgGekwAEn5SdU5wMggScChjBPA8sC-wM_AjcDvwKmcd8DzwPQgg8CXwK7At8D_wNwgy8DMIPHgaNxsIMfA4iDnwKPAgiCywIoggCDSIKclP8C0IOupPCDw4mDAs4RcclvA9mZ2ACggmCC4IMiIecCCAEXA2iCewKIg1iCSIK3AySV6IKogwCCOINAgu8Cj8Agg3iDoIL0gWCD4IKEgkSC5IEIgliCvwKkg8iDxIIHApt55IOnASSVlIL4gtSCBIIQg44kFwOQgnSC1wNkggX1W4S2jVEgCwOZgc8FUwOMcJd1E-FUgN48pnCFFXyCvWBHA62BzIMyRN48QINMg4gU7HDzAvb95lH6MfQ4MgDePM9UvJDQAeNIaiFOAbYBwwPWDIUUFIECgzSAR8ATAj1tkwJgAPyCjBEDGHQ0-0UIwC0B8wRAZaqDuRTePHMDc0Vygzg8w1yLkKCDJ-UiFZPgpwJEfH8C3nACglqDxOCHSCMCwwKn8CohgOXPBEyABoJLA-yC9wMcg8LhnIN59RABwY2HAr2kTuFCg3mgtIJQgmSCJIKclJyDocDD9CyAi2BT9TfkXQDHArSDjAH53S9AbmGz9OIQOVDEUfvIP6ygAMjceVDGABGhmFFZ8DM8toPEg6sCk4W0JVEgtIB6g_yDc0UMgayCNQCQgzSBpwN6gglx-oMEgxCDbIJPje3EJcCUgNXxDIBRgnwA0YNhgmyDhILZ4AqC0YQUuMlxuoLoLRSDCACFFAyAfAFBgkUBwYObMYKDSaR4gwU1mgApg01hsYOk4TiDC5Sig5SBUYKhgTmDDIBUgAaCLAClpHr4aOC_XfMDmyjUAK4Bp-02gmaCPwLbcNEBfoMnwfzgloIjwVEgBYK8kcNpJYLog76DZYJWFeWC560QAGp9OaArnc8R5IH9AZTgUryi9AQA4wNxg1iAuISTA5XAUwK9YAkV0wMa-LyCswPYHVaCQoNAlP-N5nCfACCRQJX1gVgAUgCcELAASAGVAdepYOwIAbgBwgDAAd1FFAH_pZMB7AD1rFIB_6SxRJhBZYCwAOODtQGTg4-lk4OAZLFEsURzg_OCvURzg4ODp-jgADOCs4P9hOOCkoGTgyyAa4KMJJDpEYCPJGuCm6VgFKGBLIETgrOC44PPAf-kFIEzghSBq4IUgSfk44PsAPVA8ABzgk1Jy4KLghGB-9xng5MBO4KxRD1JLqUngz1E0yScAdAB54IUgdeDkwEzgr1F9QD0gZOD7ADV8VwAjIAPgk-Cm6RzgyKAD4Nbg7FEoYCvg4-DT4Jzg6-DL4KhgewBr4IS6W-CX4Ovg_UAh4Jfgz1FV6QPg5-Dc4OxRK-CC4Lvg5-DD4Mfgi-CQEKxRC0AP4NfgnODv4IAQlelwEMAQp-CAENAQz-CoAFbg-wBkwH_gl-DUEKgQ_BCc4NgQ6BDPURzgmuCu4J7gvuDq4PjgmuCO4OTAc8A3wHCgmmCOiB4grWtOEWxrJYBOENzRDulDETRPRqCxFTygh6QvIMEQvmDAxCwAZxlRwQigriDvADePFWCezG9UcKDWYIZ5CI1zwS5gqaD4oEQTQGtyoHSOYIAepHJQNAAkhTPBNGUjIB8gl-pd0C-gliCfoO1g17BjEEsQhyCZYJrA7QlEAD1g2p9f9EbApBAzoL4weJYZAh4HFkAC8wsgAlQjgAzPMb4zAAFRSpI6wP-gq2CxJiKgu2CSoOZ8ZJwcYCEQ_FwNcGxgZJDGoPb3ZJDhoJhgZJC3_3Ng5hD3YNJpT2CeRifADclFURSARUhI4VQgQKQIEHQpPvd0IGNFX2A9Y1gAPSBziTzWcskZgAH6NE9uaWcZCKApk0XA-CtEemqnWqcaAE4AhkEzUHSCAnsJkKyAYdxdEHSCYtUuFSmQuZDnNTkLWcBZu34HEEd6p2WQokImp1mEaZDktVWQipDnVFVwWBk0oBNhLCMH4V4ASEheAGcAFGAnBFmgNxgrYUKABcseJ22QtnQnQDGTep5fQEIwICQGp3V1TZtCkl-Qt5D1wAqqXjYzJzlROCt0AMZgVcd1xxWXWGcSYFwAyIQLoLKIP6hKiAqANqROwPmBNrAAmHh9bFCBuGH4LP1llwa2eFC1cgdQYv0MVAsIOrA84GpRXdxojF1AJRQGrCU1NpF-W3VDBGc0ACRnXMZ3hhYLVANcNiM2cIZf_wc2FIJt5D2oOrA1eCKke2hxqxXiXlBh4EISCqtE4FMQZpFtIyIoeUA_1AAHKiNcMDFQqsMDNnYAOVCFUNuAJVCzbSE-Vd0Rn2w2eUBdUMVQ1SMx7m5oKohbJAoCdT85KA1Q-AAObSPCEzY_RX39R1Dt5CPCCQI-KEWQTVDUQFoBBsZ2gBx4DkwCJG_WMrs4jgewLlCNYlFQy1CSYG0QJVCT5yfAVcNeH2EmOx5sJGKAbcMpJh3nCxh3hmo0bJJxM2CwP1CSYG7CZ0BqLkdHbvt7WDewIZ9G-3dQ31DY0PLwMdYP_VwwfINJxn9DYAh4NBjQyY5_UPXQGxgm0K2ISoBqTgNIN_g7MA7QwtD60K1UR8BuGAsoIdDADBHQxYDoYRbQ23YLCEmkCTAFwB79SXAKSAiwTtDxUItGZAQwpw2ITycUMF3Qv5QX504vEQNHUK7Q4tC-bjXTTKo7OniWUCxLAAsUPIksOhI-CJcp1SagpSAccVMaTkppVmPxU4A_mT5wZ9CiQDXgN9DGVEL4LJgFgUsAR9DKm2TsDIBmkyakZgk-cCBAb6JdMEXgL9cyuA2efiB9siMwS9CNpwXrCvdheBTLO31mIAEgD6ggaxY1W7hJAC1Rb3FzUP1Q2NCDbhBwFdDD8lI-PtY-0LNUS9DjJmYoD9CKyEQIWwAjAjEIfoBbGHYw8VDOMMctZGZAsFYtEDDNYBFQsdDXUIXscwg5b1YLXOUn3W9aLdCx0I4wktClSWPQiRg-8iYw5Tdt0M-MM1Q_UVNJA0hGmHgoaERE5COATTDTSQgjYTDDMOswwHhk0CYwkcQQ0F8nZ_gQ0ESqUtDS7Q4eTgpj-nEVFwQ9IG0wnzRtJ0JwNdD6fiOQLDc4HGgYJjDThDDiMmoYBF5YUn0hn2lgUTt4AC8wvDB031cKQLDxMPlAuLC9iE1walDHPDpQhlDzwBkwj1CtA2dqPC0Et2k6MdYZJnwSYLAC2i1zRjQZoFXgOGhOOgSgG2hmFBqQkxcMtkdAMXAYkCcNZwR6sNwwWLDJVCaw3GJ5xBrQ8F5CckH-ZTCw-nrccLCG5ws3VwAQ0BgyGgAD6UjAGKBEvQmyfhQ3rUV9CVD_MO0mfdCl-l8wjMI9sMHFEHRdsMWwnW05_2Ow1IErsJEOZWQajjIYMLCRDjSgdEdotlZOPFDaJHNoJLD3ZhSwvVs0sKVJDLDi3yuw_bCJgwWw_bDLsNewpcMG53AYe8owsKEAcuQmcAv1TnAYcP5MdeI5DjKEEHcIdWn8GLD4MC4ARcoF_EGaQnCaRAewpcNMcMYXOCRCcIEPd0h8cKEGcnCMcJG2BDdCcJCROCQLojZbAnD0ABSnJap0cPTuODdad3Zw8PgKDjgkPOoTylwQMhM0oG-w8BAnkHsacPgEN2whVAZUHlbbNHBh-lqrbwgosEQvOkYcWngwaRx8sLXnNTJ2cMDrQvxEtAJoeJYjcLVwpvdxoxymdj92cKhwzXClwh1w03DzAAdw2Pcr32dw_7gPcJcEO3DZJU0yCNCy11VwjmcYkD3iLXDuLTnnXXDPa1dw9ft2dUS0NOsTcPN0Ps4LcKDw0N1lMKlQn3CJBn1w9xJw8Njw8mDRMzmyGPCE8Pjwz2tvcN1w_bD1P0dKRHCaMmCAcgZBmmwhPyAtgArXFxlKWzOwsPALsJrwxnDpwAbnVD87SimHacD0aBdATJYpgD0gVuEzMJ_A62AKpHmw87CM8JrwzbDjGw7wjIAlsLgbbLCKGw3rSfDwsKewgv8zkyS6ULCFsIGubaJ9AGkLTXDnwD5RGkBewxbwvfD4QBoAQ_CNPRHnXEAtYDVQ3nCFsPQwN7MkMDUyffCr8LRhefDFUkvwtWsLuBGfJxhGZBPQX_8SpmgjBKZcLRErDDpasKGwm04GsM5GcbD6EhawpZhXMAmgCv08IE-raVZ38N_w-oBPIi3HX_D5IGgIg5Y5Qx_w6Qt4CImw-oBnAA4QNAipaGII9ioJKxPw0rhx5zvw_8ApsPShaiZkP0UwlURT0Je3DX9svjjzdCJvaBg7SJcYa0ABJWYrsKRwuHDENCuw8zZm5kNQmW9ZiCovE_wv8PLxXAjpC0WCJHCmCIfw4jAmMLA7fTdiMDenRfwwcLbwlvDxCOCAMXV_pzEI0YAacI0PUY8RZyRw3QitfgnaenDScPn6RfxqcO5wsnC-cP6SEbYqcK5wrABacLfUenCuil3winDmcLcInIYo8CYw92RlsJDQBXCqEDITW8hVcBRgbvRIcMHFUkJNW29tUYAFcOFw2AYmhWaoQwjp8PjwuIiG8JbFP3D3SCP7SvDy5BkIpHDJ0wlNZN4siOMYCg4kcOL1AvIKiOcIpoZgiIxwgE8tsAVIMLDpCJrTZaBLT1rQozCObV_bU6AayHjfSoIrsPQRLKAwznA_RTl8ZkWUTwjv8JUInQRL7Vvw0_CSSxFnOCRc2xziE65bCIOrCVD4-xP8UL52iKnwj2IXBCUI1UxzGwqIiQjRRDenJwj3CJcIknD3CKYhJYjKcP-nMIj_CLpwrYj4MCCIt60BrlCI3wilcI7oeDAdiO1Qgjh4gBVwoojmNF5YDVBBoxkjYzCKahE_Q7owsPBwlvCocJLw8XCp4HiI4DldGzeI_yhboyjwfIjziNOI8LCeKHNw3XDoSMbwgYgQTgOI-ojjwBFw0EippHLwtfByiIWwvoj2BAGIgtDHULkwsDt4NA9NeQipL39vQBNX-yJQjTZ4UNaHGs88QErPIFhEUIkkO-Rc2BvEceAnrzKAqOpugWvESJxfcUtjXBAoXE2AKIAG9HI8HLtMfQiXIngcAG54THgvrAF4TQpCMNF4cXhuUMkYIGFCb3I_UG4DiKPCba8_dEVfY3tEsCNYQ9RtgAVYUv1SEF1I1AgUgmTeBeQBgUqcdo8Jsk6qA4jSQ1dva_9jkmBHW0DO70rYXNhGANYAgEAvQOrUOUjbrw7gLUAFtV_NF6BXQD4Ahb15gXiWA7gPakR4BoBR4HUscskYfSxQxUjpJEevVb1NAJqad5Dlq1-I4sipQBsrJyVjvSbHFcpogCq3XSxdYHbHShNOx2Fcee8BmxWbRyReOzESRmRpyJc7O79KAAbbYxAou1mAZcj1gEC7eSsQuwErfUA1vz2BRHo5APXcAwDUSC4rTsQWlQiVYKxjEFUrTQF1lS0UYsEyeDy9G-801VYTE5UPfnwrK8jZK0eVPhUXlTeVD5VyUQ3I6itbuyLEcJVyFksMaJV87DiVJ9xElUTgdnsawCpVHxYlDF4STRQxuAZVUrcEHz2BbwCJgX_OBjwHLA_-HwDRjC32LVFl4EZ5eIBAtEZ5N0IJagNXbTh1oRkrDn44eAiVO7sIlTAoyTxTVUgohJUklShVaqcmpBMZIpds4ShPIIB-l3DnWHN-MHceL59-8kHGGnMbSHARFgBzKB9VUSjPFVZ8blQSpHFmFTAbRwEuRNULUwqbUSihlTvQLWBkEBmgVnxxZljnK4VvNG6kPYtoiFa2JkdfFSKkI2c5Ak_eXNFXrGK0X_gKm0ZrCn108zlUHiiPkCEPclAoT0OwNWAkqhKkHxAU13yVIGJjMBKqJT4hywxVSt5slVAgjDob7lNzIzAhAKTXL2FvNGhUYuY7EEMQLVMLQyQVdBAFlRNXc6ZbgFmUdwBJpGBPU4BfJBPAIQDLwDM7NHQJzBKo5ltnxHJAewACAEXKQqiAMEh4fwB-bXZgQxAnwChgQG0nQgmIYDQNSnhVeJYyZVYcLSttATKsJrFoOEao4qiOqKWDae5jGE5oeJZxqMk8QuB26xWo_7xC4HC7QaJ1qOYrCajVy05AJbB_gC6cJ8cxwFNTcwAF1XF3d5gZqPao_kg21yNsRajvCHiWTcj7O0sMULtDQBcEF6jeKzeonciWD1kPZ5dLO3SOVzswwJ47BciswGP6L6jguz4rd6jF_HSkMGiCAC-I1hwMpxpzQajgkNBoqztXQBcEOGiMaLShBMxEgE89DUpkgBcEIIVsPVsoHpUDiiw_KYBFyhJor25pKNwI20RGqOaoj4Bx-HFXUiiHeWVQRLAtnESwfGjm0E2wYaj5lT6AE1dNsC5okHAeaKLQPmikFXnQyY0U23RooGjFyIbbDVt4aJgOJVsbEnhDFVtpmzRbATsjnXZo0ZDmWnXcSrgZgD_pLWtxEgheFWjpzA1KScjr4lXImYAFaNIBFwQe6RPPZPhIZRuwOmiTwD1o-CQDaOUbJYAiO1sREjtzaOoUMjts0K1rf2iTmyDohdwQ6IgSBAU75x80VqimaJNSNsJXaNxo8YBGaNwAE1Jhg24wVwoCnhRojvBmdGzohaR6yAUoiVoPoB8AGvC86O8IcbRBomxoDWcM8MCAE1Nwq1zRN0BUdzBkFOiDSFLxCUD2sB6qWOjcAGVgcgBIwG-XAmjmdAyVahcF1XiWFZMPajB0HAJigxbo-OiefGNozaVBiGnoj6gzcjI6N7AEgD0o7dQi6NrAEuiFqNRokHQ7C2To2ZQmaMCAWSBQfE7oluie6L7oxCcB6MpOAVd4lghgLbDXChHokKFZfHHo_dN0iIPopqjU6I-oNsI56JcYZujD6K_oqmop6IAY1uiT6I7o4BjP6NokXuj-6N5oycBSlTvonABJ-SCRR-i-zjHomlE36IgYpmimiDl4fRxmVX_oyBjxeR_o2ci_6IXokBjxeUYsUrAPTRuokqjBciz9TMiAUFz9OwBWyI79IQAbSGAA1c8dbBrIoMBYdmG-c9Ahixcabf1emG4wSlDRA2qnTujqIzv4HDcuGL5udwVHzh4DLpgUJygAAQNh_REY-QNygAsRdSoJQ2KsMlEz5kVJXgNFGOGDIQRYaBBIGlJDEElAsDN9SDNA5QC37BKDPQBDEFrLYrBPvj-jD6B6iAViMLAH83mDGegRSDrzXBjmAVcYhkhG83WDBZhZ6DWDLFlxQxADRZAlsTgoO2hs0VMYtxiHGJJgR_N_GIawQJj78CgDO7Bna1hYHKATw1YcToNA-W6DGAZmwy8oCPMa_XywGsibJwrIhoAcAEZQdhUaBD6oA4MWn3vwMAojBD8aejhI2k2wIZxZmAmIciRm_THqMGQx0NcVDUplsBrIs1RBmOtwlf0ThFmo54t3cBGYphB-mJGwqZjsikCQeMDViPlAWJCmnEG4PShgsA4A0RdPsDagRAhaqP8AI0pLGE5uNjC9nHLJfBBehWK9PiAUCAyo_YQ2qJKo3Cx0qIXQXoQVK2orM8j6KPIWS8jaKK_mB5UjLlvIzZUHyNFAYoNgsFuYl5iPkGU2BoBKyJwAO5jUREFgB5j_ABDYdS5wWLZ0KZjjmOCwbYgCMFOYnypKmNXQUoMl_XmY9SY0gCCQYXJFXUQITFilYDSAdFiymMxoNAQj1GoUbSBqgyAYOPAJQzOzfrJNGIsYmljyyXUYoQBNGIgdKJjksBiYo9B8C3zQHBiKnFRLDZA0mM5YutCxmKMw4ViHqDFY50YHqElYo_AJQ3KSbpEsHSkUAAQWADIceAMD0Ms_LFiI2gNw--c7sJ1YrFpvtwxYnJ1rSx6dRx1HMP_FPIMBSENYympmsGlGM1jfvnmga8ijLieVH8jO-D_I94xL3XVDSr02gCygIlZBvWdNdJ0IgDXgfPYrPmWeWbDVnjqwTJ4ni0G9Rxgo2OgLD4Am9xoAUrcYQGtdSNjI1FL6An8M2IIAF9cIHRIjbtRVEGXULUMZQ0JKBNj8niTYhd1C2KzY-tjcCOLYvv1E2J9LS-iWgAreN_toACCIbepb7lkIZrhwPTFUaYVMo1YYLygUDmEYCthQ93K6Y5Dl7WXUZgsgsIyvGlBKIDeoIpicADEDBdAtikCOEB1pcgahCg53aBvzZVxQYG-XV8ZVwVGia6NDjABDUFZ8fTcGC9j1zGjsTgt-C2mwa2j5gEvY_H0uCl4GA-sFiPCKO9iAQ14LNgZ6mN_Y99ia8MS7FH9HJk_zUg8HKxygRmgKt37IlsdVnFW0F9iaTR3YwB1GzDhgOzdYDlyPII9qj0KPHpt4KM5VWlVkKIfmPs0mVQJSVFx0XBjo_Ug1QPuQDUDH4Sc2fH1DCSA43xxc306hS7ASt3twZ9cm7kqPbDiIjUSPWNxkjwL1MYUng3aeaTcpaNKwQ2FKvU1DEwMx2Ms_ayA6CxtYl6Mr8EtYkkgnWPiAF1iaRHDfeOhRA22IOTihBEpsWgBDaPSY6yhvSTz8Uh05jBDrVRj-SFHda1j-Ty3wrZjm0KtYzAA0ADM4W4DegNDwu1pxOJ048zj9OKBiHJjz0Ks4-5BdOOc4vPxXOJ4cdC1bQ1k47ziXOL2AtKA7J0YkUYBtAxf1b7hNhS1gWtM4uPbdc6BrHgc46zinOP04zdhQuKQbCukdNzcwdTi2MIpYiKJnWL8AEHQTG01wcrjiWLU4vwB_Oy-ES8BZgFS4ikgGuI3oLSZNONrWaVEquItVYUNsuMC4mzivswG6QliDWMpYzHBeuOlGDrju8yJIGLc0PEnfeGh8WIEAWaB1gB1xGo1J3jXGP4CI3ntNOECIQP4UboN6oyK3AGjSUjeTV8jgHygWS5ViuMmoQ5Blxj_yeSB04CgfexZ04DPGEwF2mMSwOwEooE2wSwFs6mfIm5M3yMuVVJ0gvVHxcAhfd3EnE_w0pGBAujItnUh4oz0IfkSkGHjfwyh4kl4JHWc-RHi962R4xVgDvjodXHcnA13MfbRv8gnYr9oZ2PqtbbiQvkJaKsgbuNoQO7iQePvwW7jNxkBhAnjEpBySSagweIEOTHjuHWK-Sz5galmPWP496015bBJfglzbaWVt1zBgMY9t13SNPl5__nzyBEQsvyPUYz0O80tvGMpV2iJ4_BpzolJ4uXjx1GLmI6JriiR4yd56eMv8YPIqeOIQAuZGeLi8XfwWeIKoNnjeDUyxKPAbASjwQPcPZHINUXiFCGi_bL9jPQuiXOkDDSQeBg49R2gYY3iMgHS1PXiWjV93VJ1ayEuJY8NjuOgYBFNawGOfQYCdWA6eb7jMeKT4vbj3eOLmGuwqQPpA9kCISlZAuNwyQPAjM5icsC2KFdjSbDXYjdjDEGL4-5wIAG4Y5IA12OaHW4ZN2HdfETj_Sz_dBMxeDzaAmqgOnmpWCqctYFZo5_QdaMoHG_hCKN74kij--PIokKBRCCoo2YMyeM8dbR8ekmMnCLj1WNgATVj0yAAEcND_xVl4uHjLPjn47N5sNwG4yJj1RDM43LjEuIR1GNCxmKEwphh-kkzUTyhRmOnAK_jK1DPAAyZRVGADTQ8XC0fQWzDL-OoUB9RH-J8CHLC-Gh9IbKoAKyQwQ6oVMJqKWnij8AN4tA9wBMIAMHiy-IoAlo01xlh4sEDjPUE46ASfqHhAnR5vuJduRYC_eLuOWCMZsLAACiNLQwcmCZjcYzqDQiNuNEN1DHBAYDd8KCE1mNtgjZi8YHnuViM5zHLYqqAnI1sjFgSy2KDwFiNpYCjYszh4oxccfgS8_GEjS7AixWkY1LZ0uhJwQaNGAALI8mAjDQnYxGot_mcY_6MP_hiNLmMQElx-JGMH4mIQFn1aEG0EkvUeXj0E26JOAVknFGADBNRLaqAHqAsEx4DsAFQjRvjFShiNXg9qoF4PCwSwWMyoroB4o3cE_YQLBKEAEQBDWPijOrjgeXFjXIAR-MkosiiZKIn4yqBqoG7UPviIhNwIibALBPiyBVdpwAKACbBAYHkACwSHqA2cFn1M-LZAskCshIpoNVwI4ItZXPiGQOyAbQSCYEY0DVB1ow4Eolj-AXc47kZ4SKGjNQSQhK5jbllavhfpN9RlSDBjAqhIBIsEuF5ehMneX3dChKHoKwSpIxiNWwSTkSmEiwTnBOAAVwSYjW8E3oQvBORYjwTghOzWPwSM6DSAQITHWIm4iwTYhNH4-ISKKNgAGISwhNmYI4SohNgAJIT01BSE3VcUgHSE4ABw4DYFW1cAZUyvRLhs0XPBJgSQhOyEmZxchJJA6kCChJiNB6hihOqgaNxSQNEESoT5YxJjORhJADkE_QAao0VjabASmCiYLE4y03oY01RtSMAQIo48zHLvE4UYQQwuUq8dz2W-aTdCRNBA2r5_gL9jEOMyRLN-B-00-Ni_SkTk72lAyJ0aOLlAta89QMUAg0CkQLZEhJCY3HyExkCa73zkWkCj8HBEoORG70FE45J0RMBEOxipYAd9TXRDQKTvX6QEyI2Q20DJRNaHGFDvsOzI8CBkUKLfCohiowxQx5YmMLlw4HdUSCpTGgBE-HwmcaDDsD-oRPg7-hwAG8BGaGBVPs1QrAkWPish0F5Ye3oniAIAaOdzaEmGM8BVcEh7R6drRMmGThVLcAvGAgBTRIIARPhvalC4aJRzRIxMI9ACQUjE20T7RMdE0FVJDDTgV0SxR3tYD0So50AXe1hfRLHAf0S55EDEs0TgxMLE0MS9pyDEj9Bj7z-oNekLRITEq0SaADXpZMSHRIqTNMSXRN7PeXBsxJGGT0TvRKQQAsSwLWvQBE1wxNrEoyAyxMHE-SBKxKbEscTqxIhAacT6xPCgRMTmxIdbFMS2xOdEjMTOxPXWbsT2gHGXfMSh0D9E0MT6dHaRGcTjXHLEocTgkmPE6MSaxPWwqGAFxIigCMS-xMCGVcSQVXXEjSs3RO3E3cSfRP3Es8SAxJHEm8TxxKLEsMSHxKhgK8S5xK9E28T4xMXExoAbxJbE1MTXxMzE5NB3RJ7E3MS7-gHEwCSjxIPpACSKxPmScCTQJJrAABc7xKuAT8TSyWfEp0StFA7EwMFEJI_E3sS8xK_Eo50fxOLEwwIaJKwk88TR9WYk2cT8JM9EjAVCJMjnaIAMBVgktcTyJI3EyiSuxPNoHMS-JKiFPcT6JInExiTBGwwFFiTJxLYk9Bt5JI4kz9AmMKV3CrhGZC7ie1g_sI1KN79mdHVEOoRZcirQpVVunDz8d_AlqxACRoSLCG18L8REzwjyeEwmVnC4l4JN2E9HBG12yCrQqXxnJOTQTySnJMW1LoY8cJFnOfwb0xFAGdoeDwwARdprCJ8k0IAwAEP8YwopfBcEXyTN2AoOOySw4McATAB6XggAFng8NCwAXmgy0yYwihJtJN-wmKT3ZkR0X_8vxDZeJbUuVmVgkWddsIgjeN4JRDzwotoxPWswf0xqFCUXdyTCLFZEJqSqLH1MPySCWVrIbQjKvC8CCMTE-CVwf3wW_z9PPgRVG3Mk7MCvYVfiIqSkEF0k5hgKpMW1IySQyIQFNTtUqirQ92YhjCYwxLCSpJQQAAi1aIm-c7gQ2Bik1b5CklfiQlhZQFhwAQB0pMxwLIh5MKTsEaTrRKAXKtDoQiYw_yAozFOkqARoSMGrdaR19BzOWAAwqPcAd_B9pK4XHyo7-mWk6VDsSOKIo9AR0H3PdzC80FlQe1hOQBN3CXDiiLPEpIjXCnGtT4sDKFBk63tXbwOk5LDjpIAEWEi9pJFnPFDtXBlwmvheMCNEz3hk6gtxVcB7GiQki-MMcW-k4DtU8B5CHSTDpJIQMmSAxBJk_7CBZK4DUnAXGEWkxIBlpOD0cWTdwl5koZ8VyPmkrSTZZOKkoZ9GONThBaTlZKWkvmSCFHuIkWd3cQJoaXDh4Flw95p2jxqkiTBJcOU2GARaZIbgBmSahmFwyNB4iPdxflwOREddK2SjZJpwVmT7WFPCeIjeWBSkshNdOzBiPFDh7zWBD_4xkIYQOb1t4C1ACJR7r0jSJsiyz3mBWr9Cx3q_SsdSyI9xSpjqyNpYusjp3DHXFXQlnF0eGhMKaEMsUcjC5XHIzdx5u0W7FHgSrEu7bTVz7yE6U7stFXzsC7t2-Brk67tvvTVqLM1N3DsPTfdjhFgEhjxEeg2_WuYsKJU4t4Bd_Hh9RPQKCI8AQ5Bqk3T3YqQmpGOgLt4eYSLoQhIc5OwMPOSN9j2AEgs1LCFCCpt0Pk8xDiBnOnQXWNUWVDOcIj5Ua0SgLGh9AF3oC_UR-GZVU3ws5Ux8FeS3IDXk0KA_wEIEb5dvIHOmMABFyjsAQxsiADboeJYS6IMwUGA9IGOkeJYiaKAUj-VG-gynH-Sa632kUBSWgBB0P-T96Rrbc-sv5LB0IyJaGM1jBYFsKMYY5dAtQDxY3gNSUN4DQf0hGJyYsf0xGMUzARi-AwSAZRiuMDIU0QMeWMoAPli-_WUYfQBB_V39Szj12J3gBcYKGLuwbRikoF0Y1hSaAAMYrYAjGPiGdnIF0HMY0wNAsGSY0PADhPCEgfiYfC8Yryh5FPOExRSoQgiY1HQbwHRAdWgjcFuElxgOGlkUsvBVFLZo8fjKByM4tbiKFNjDPb4uck2Ew1idhjOE0xTIhMoHQv5i2H0UtISDNDXYmn1SmOoIEeTyniOIzXBLFVnAT8JCXmsBDNcScCdUAa4glLnAeaBIlIpw6JT3jGSEnVcDFIlaMbj0lB0UvAB3FOCUyfiz-NSE7JSgkihCNJSZ9AyUvRTklI8UyqAsSEcUsfjnFImwalj6hIqYqFiqmNqDWRBl6MNUF8BVONJY_ZiTmM1bUrB0lNY0LJT7hMn4h8py5LO7JuSru1Q8M0jZpC27YQMHsBlQ5oAZinkSY4cLWNwwKtJ-lLKU_JSAUhGUpbsXrGrk15VJPHAiM0JKAHqQOEAAMH8qRpp9fmNQrTiVlIyUgZTHkk3o_0Ux_T6U9WhblNEIKFIJQyeUvABSlLm3QZSKlJMU6pSEhI0UrDZrlNY0L5S8lJ-Uk0IYpyqUi4TB-Kw9QgotlPO7HZTm5L2Uw6IgKOG0JijZDDcdeFTG5MRU8ZTBxGe7dxYxuO9JYpS1lO-UibA3lP5Yj5SXlMqgN5SMLWjwA7ANuy27dTJKczuNVAjJ7yGfV0BWaA1NL244gC0wdABQVLuEkJS8Q2BU55T1lPBUiNp4VLGUluSJlIZUzvhlmDqwVZTdFMxgKlTH4EX5HK4SUib40FiblNFUmHxvcIT9PlSlVO1U-5TJsnVUup4B6AGYsFSyVO1CWNi90OSDc1SBVNeUqhcTVLUAVcBg7h7VRAgd1Bx0BIEPVOUE_QQ_FO_qeSNDVOpUhj9clPtUoNSAd1s3fljuFKbGHJjl2OmiW2AlhIpdEdQvFKL4pxi7jhR-FC0qAR0E6_4epJyAZgEq3xxTUe081OwBCDIHA3H3BDQIuMuY_8APrjfok1jQBM1wStTEn0jHQUj7OPqEyrjpRidUSBlrmNVzJj4oP1tzRyZkDBi7Llp0pAeeBIAG20ecfRSUnzYBcd04Xnsk6bBlEm33aOJ71SwUsD1vDgg9JZhGblRNErRqBCUwa1pWMmfVONSkbUXU-ZdpohXGI8owPUoIjUBXFxHWeZZEpBeXGT8n9xutbjEVMi7bdGJwrQb0f4iU20ZXeUAFIB5bI0B8AEZAP_g0W3jOEXAwYAHUgDTUWxcYZaAsS1TzIij0ADHUud9VdhEiIYg_VO-Uesh0wj7YoqQR3k1oGB1n5RyuQGh4NLcSOXt8NKKkTFNXFR5_XQYaACSAWDSx1IjbZ7V_qKX8J4i5_GP6YjTXdU03dQ88ePi7TSJR1KKkYY9lcJY08dTklPb_Glh3O1nIOd1ENH4wAQQWQC8CdKRyJHDGbdQ3gF8eB1DImMYUxIAJ5JiuZDTJ5PQIC-tGQBrbPh5jZG1MDTSmX3SkNnCP_H66Zoj8M0vkxIBqNKKkITSNWy7_MTS4OiRcaTp_EPyCS6QUVG3QHdRFNJSoWv0UNIP8YzTbMN0xLhQFNNQBBNSuQjtUlJSw1J-yLWjm8MM0rTTjNPTYySZnAD4okxiCSEv1fjTSNPTuN3U42MRTL9gSPyY_TRSiVNKQXzTdTWS0nLBLIGrablBRRBoNUU5iJljPaU9oXlz1Hl5KKHtwMDTrIVYmI0p0tLjTMjTzDkK7ZJS3tFi0-C5etNcVG8gmGG0DVlj8MGK0pLSvYRBIcrTdNkq0vR5jR3q0nl4-lTYFYztPvGkUpWZBqmtUpTDuCMcmNJRlgNWSXg817HzQUA9W5GO0vCANnHO0jUBihITDGYMfNFYPNQI1dyOArA9mYEX8dHcaRF4PN7TNd0RohMwHjz0eE3dNd2BIxUwedwo9UzSv_HCGejSV-moXF_ABjy1EErc1D0BnF_A1Nz8IqKTkfgcwYdT_cO_3JPwk23dUGdSuiP540lJWtPtQkXAHtMO4eQ9IABpEJiRfdy4PdjSr31R1X4J791bkKPdfxUmyLuToDx7kpw8XdxAPaaJwDyD3EqZE2x50jHTcYn7rZqhDdVdKSoIJoj8CJ9S_elLgaAB2P0TbbySA7TB0t1DOL2dia2ioOPHXA9ZzAHGVNRgNnl53EQthnHELdwA8KVTvd0lWSMqYVZw3fA98HaQ6ICUgVzBsYHhgb9CTKyk6fMA6J1cwTAB7l2TdGrAWtxKkQ9V-ACi7MBQO4VU-EQE311swA3TGDSN08wBg4huY_m5-sJxoFTAGD2ureFcTK0ZUYfMWQCg-HWgkPhaQJFUV1C4KSQAt_BD09M4LgB3hNjoEaA6XQic5VAeoJtYuU1FUciDIxAqkPpUUdnColNQE9Ma2AwIkgEL00eFlthgGYPTZ4QLzTpixCxpzbaNIFw107CtG6Lh0zLd-F0x0n4TWnFpjbqAWt2P6GfSNgwXUC3SVD03oZMtm-gvhJfTGOiw-EnZWOncDOwB-AEPVaNwO4X700QsfMCH0qPAWtxrwh3TRqJoGGXjOPgpoDZwaRCUgEnAWt2KgYESpWLUyPw88wRuVP3DQJjyVTXTMjxygJlV4lndoPJUADIjcZmheHHe3ZQ9oONqGPs5wDIo40E0Pa2ao2AY0Qw0sfuBt5BOcaIAznC-NS_hj2MQnbYIIiLRDVlQ03jWODXTc5IecF-TfTgRwCNws2MAMig9mUPviBhJKDNXkh5xVtEAMhgyoDKUIZgzRxnbIHw8l3Vf07qBmF1RLP6tcGPG0YQyEFI1HKQzkgEX00JjOnEkMgaIBtN2QbTTGzCa6KbTU4RMYzmIRaNxiYa1GNCUPXbdlElgMr1IEDJLwaJSuMmQMW1cnAVgM-FVjDOMYGvIIjTMMwJTA1MCQZ0JYUWaofNChSOhhQLTUVGC0gG5QtJcVC1SHVOzSdzsOF2jKXzSbJ3Hk3zS7jkCM2aFSVJCM-dI0pAF4sURNVJJU4IyzClGgCVScVKlUwcQ9uzxac8ANFClo0gSG1OZaMljvVO_qCbj7gIqM0N1xOJU0nJjXVKmkd1TitI6PbEox_RU0tTTPVDbQkdCQWLYYCbiwOHZYsvg_fU6nRg4thgkrfwSJuNu0lsMxmHaU_oyjZj2Y7JjulNZYjoyYjJqMuvI0lLmM-B42dHKM3zTK-CpY41xdjPqMzGdklJyY1qodLVCQ1ABQ5MxEyrw1z2RdBkTFRPs2WYyIondjGcx-YPlEk9hjVhcQA7SxYIFEwJ1c1mz8Yu9zIAa0jO97WAyrVYT9hBeMwCQoVPUUyqBDZD2_NxTXDPavelhPjLtjJ_SZnEBMjEF80GKEjEyNrxBHVoTSvxDkx1jdjM1Ew_8g9jog9OSMzwYQSNIRmKzksJBJW2c7HGiNREho-itNK0ErAeYDyOHHI8iLLFPIxRZWlW-Y_5VnAEBVSbhBJKc8URMbFBtArwR5oj7WaIzNNK9KQ2D7FxL9QIyjMASMyLSEMgfrbtR3CHVReIAUq2MwZVcRuK7Y7pSGlOhY5pSqFC5IsjoRaA0nWggXdmW4pxcylQXknJdslTD07oB05M9hVOEw51kQDYyIoiNMqpih1CtM-lhLTNiAa0yr8JaUgUyhTLgksFVJrj2NaFxZGM_HF1iYzNoEhMDemJgYVgAemIO5ZB4T_A1Mq81tTJfwIf0gBmNLHCEhVNbU2yQMAD1MyFjoWPbEEqxWDB54NPJnAEWsPngMryGIPijWsExkcHjHJmEHWFiugCJ3b0zQgwNoOHBuUESwO-k76R5My6w-TMLgEajNsGHM88ivmLHMyetURJ8U6nA0AGeYtYTuzI7MybAlTPbMlFiid16Mg_iVpzWEoncpshVMqT9QjI2bMbjjfk0M7ERkGEUzMP5zzPEU-hS2GCbM5P0-qBpLHsEaJKAXUMygVRFM1TxTjS8kF8yUJL9Pd8zhTJfEiMzutFONC8kfKmIk9SoALPDMpzxTjXIkX8zogEfE4gwTVUFMj8ygLJgsoHj61IfMnLAT3QlQgaS7sBaOG8yTGPfkkIBMlE4U10ycyAZILAATd1r9LCztcBwsig4ecKGI8iz4AAZIHatGzJSokEh6LLSgXKd2LNThHmoy8FHEXiyKLOwsxPwKDlerFtS8MFossvA0dxosjiyRLK4wFKS0lKkshYsuMB1HJ_0A1MPM5T8gzwsMxIzzEMJUvcw9zPe3A8yMjKPMp9s-_SOM6VjJLI4slsze_QkshtT6jMygU30g9BGM3dd1FwsAeJYFbCuaUGh7mk8ovbYCdyhw1zBFMjGAWe8pgAVU_EA7jR6kGTSEwHiWWWAW3RkgbNQRVBBXSfYNLWjwJGgptiYuWeRESAGAeTBrq2UotrjboDqWCljewm4kA9YVonRoGQIFVgCaCTAucJ6AUXklmlrAQqylmCZHUgFrq1ro86jFvB6kUDj3LMeWCwBCtNXM_cydLNVMnOJO21JSNwJwjIJWQyzjRLqwfbIlzIKGJQ8tBh6oCkhBrNMs3PCELXoiN9dk3TLoo4BZJmOoqHC2rProy6j3tzN1TIJJrK1ERcpJzM-YtpU-zifo5aytLJB0W6zPN120mihSAWtIVkgPuGxouWiPzHpMwGjDOzs0wMoPrMM7QXhmTK8hd6iDqMQ0AGzqqLck1PCxRE3M2AyMpwhs6ztnqPeY3kyLyJnMu_TvWgRs10BPBkQ0XyyidxwAImiVW3hoqi8xuJms4l5VzJukqazYbMnheczSbJ0ecmynUF4UpMdI-NjDPjcN40wsuSy6LPvdCSzuwiPQG8zmzPgwVpT_tUh0-Q8mNJU3HLBIpI405izbMIbUwn1eNLM9XcxpbOUsvDA5bL4IPijUdEghQMZ3VKVsqiyj_GLIKyy-LNYsvQ9CazUbVWyvYTbUxWyObIEslWzWd0cmJiQ-bOls_ozCfVnU76J3p2CksWztcDCko9U-bIls8H9kqLdMtjCZbKcssAsN2hBwZiz4pzSgVX0D63K7CwM-bL7wAWyo-NZstGgA7OUsnCzkRj9IM1t7bIDsx2yg7Ods3bN16BjsIgBIOCi2dOzfJD5s0mggBOKBDOymzIXkf4ZsJETsu4AF5Hi4dehTMybs1CYCOgpIDXMaRAtAUWVVbVv-KWyabl72Li56gG1Ad1UVMDHgfV43nxF4ZIBbNHRgqkI3cw9zQ7AqyKj4Kj1HJgiAI-4K2Ofo6RxlG1T4LgoNc0WkTC09M2CzCaYo0wOndeyfVEGI0nS3bOJw0Wy17K2Mn2yKS1r9TYyZnwWMvP8M6LmPQiJAsE7s7GzX-NgOHvC-gO9rDU8F6UJPA3MvJjmuCuzu-xEfeUADpztKOYjSBMCxLsA-bOAXGBzgwxrAeBzkTCbM-TDdWJjkYWzGNMp03yR77LEOSj5tUNxYm8zECFps_hRVzKrIMY9pfXDs75VO6UYw4l4gkC3A_Gzf1XocjX8AzJqyBYtgzKoUfiAR4Fo9C9SHQEbUkZ0SVGj0lsAHfDdsPiielmr2SvTg8y0IxhzFykjsua4xj2LM3MyyakaUu0TXAOZ6BWRq8lrM-Hg-eEGIztVGHMGEufUV83UcmdSUq0Fo3LVwqTV8c5SrlNbUsoz9mNmPUkM6FW-kirj2YSgTOoEuYWXhI-Ev-WLAYkAqgG8AXHJfwF9OedFWcQ3gFFFfYRsLSGBQnNwJMfNw4nNJV-EVMSz0x-BgnMfgdDFn4GQQZc5IlyMwc0A13HKAEEBAnNOFKklKFCnhbMQsIBic9DEdV3VqcSkEyFMYLUAp4WXbNel5JSRgaPE3OTjkmpz-AEac7GAkYFJlVpykmF3gBpy9IEhgHAAJtDgpOpzcnNa4BpzunI6RUZyxcVwTdWhBnJGc71F96T6cnrgOuBrSY-Fl2y2RRGAlBWNRe3wdeD14IEh_ZXjxTpyheRGctjkoSQSEPoAkhBSEWOtNnKMgYZzZnL2cgyR0VEWcmws-nOx7ajY3nMhgXXhmNBuVMZzsaSHoIuSt8y7HCQJ7nJGckZy-nJrcMsDBxwb3Q8iLVzE5QWEZYUQAGvdVYTr3WQDOTIRc1ZyDvR7IuEkQAGXbIZyZnL6cpUEVQWnlV-EOkValAFyrnOiJRM0JQAach5zdlT6c671ox02coXlEYCec0MlEE2WZZBMpkwacnZzenIBc85jynOPhIZzlnOxc3JzrQAacppzE-BackXEHmDTEApzcABw1BsQj5A8cyIRFEA1FNmUkACURcfgUti7I5pB-AHkABQBMhKAAA`} __position={0} __code={'<Map viewport={{ center: [0.026, 123.61], zoom: 5 }} />'} __scope={{props: this ? this.props : props,Map}}>\n  <Map viewport={{ center: [0.026, 123.61], zoom: 5, }} />\n</Playground>\n           </MDXTag>\n  }\n}\n  "],"sourceRoot":""}