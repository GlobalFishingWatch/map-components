{"version":3,"sources":["webpack:///./src/map/glmap/map.css","webpack:///./src/map/lib/Pack.js","webpack:///./src/map/lib/pelagosClient.js","webpack:///./src/map/proptypes/tracks.js","webpack:///./src/map/proptypes/layers.js","webpack:///./src/map/proptypes/shared.js","webpack:///./src/map/config.js","webpack:///./src/map/module/module.actions.js","webpack:///./src/map/module/module.selectors.js","webpack:///./src/map/tracks/tracks.selectors.js","webpack:///./src/map/constants.js","webpack:///./src/map/utils/heatmapTileData.js","webpack:///./src/map/utils/buildEndpoint.js","webpack:///./src/map/heatmap/heatmapTiles.actions.js","webpack:///./src/map/heatmap/heatmap.actions.js","webpack:///./src/map/glmap/viewport.actions.js","webpack:///./src/map/glmap/interaction.actions.js","webpack:///./src/map/utils/map-colors.js","webpack:///./src/map/heatmap/HeatmapSubLayer.js","webpack:///./src/map/heatmap/HeatmapLayer.js","webpack:///./src/map/tracks/TracksLayer.js","webpack:///./src/map/activity/ActivityLayers.js","webpack:///./src/map/activity/ActivityLayers.container.js","webpack:///./src/map/glmap/Map.js","webpack:///./src/map/glmap/Map.container.js","webpack:///./src/map/glmap/style.reducer.js","webpack:///./src/map/utils/getMainGeomType.js","webpack:///./src/map/glmap/style.actions.js","webpack:///./src/map/store/index.js","webpack:///./src/map/tracks/tracks.actions.js","webpack:///./src/map/utils/withReducerTypes.js","webpack:///./src/map/module/module.reducer.js","webpack:///./src/map/tracks/tracks.reducer.js","webpack:///./src/map/heatmap/heatmap.reducer.js","webpack:///./src/map/heatmap/heatmapTiles.reducer.js","webpack:///./src/map/glmap/viewport.reducer.js","webpack:///./src/map/glmap/interaction.reducer.js","webpack:///./src/map/store/reducers.js","webpack:///./src/map/map.js","webpack:///./src/map/basemaps/index.js","webpack:///./src/map/map.mdx"],"names":["module","exports","map","googleLogo","byname","Uint8","size","Uint8Array","BYTES_PER_ELEMENT","array","getter","setter","Int8","Int8Array","Uint16","Uint16Array","Int16","Int16Array","Uint32","Uint32Array","Int32","Int32Array","Float32","Float32Array","Float64","Float64Array","writeStringToArrayBuffer","str","start","end","buf","bufstart","undefined","length","i","charCodeAt","arrayBufferToString","String","fromCharCode","apply","Pack","typemap","byarray","pack","typespec","value","littleendian","ArrayBuffer","DataView","stringToArrayBuffer","res","Uint8ClampedArray","buffer","name","spec","PelagosClient","_classCallCheck","this","MAGIC_COOKIE","url","token","Promise","resolve","reject","request","XMLHttpRequest","open","setRequestHeader","concat","responseType","onload","handleData","bind","onerror","send","self","error","readyState","success","status","isFileUri","response","byteLength","dataView","headerLen","cookie","slice","getInt32","offset","headerIsLoaded","header","JSON","parse","rowLen","colsByName","colidx","cols","col","idx","type","multiplier","min","max","orientation","errorLoading","toString","allLoaded","result","rowidx","row","val","colValues","eval","trackTypes","id","PropTypes","string","isRequired","data","object","color","oneOf","layerTemporalExtents","arrayOf","number","fitBoundsOnLoad","bool","shape","hue","filterValues","endpoints","temporalExtents","temporalExtentsLess","field","values","node","VESSELS_BASE_RADIUS","MAX_SPRITES_PER_LAYER","TILES_URL_NEEDING_AUTHENTICATION","startLoader","dispatch","state","loaderId","timestamp","Date","getTime","payload","onLoadStart","completeLoader","getState","loaders","onLoadComplete","setHighlightTemporalExtent","highlightTemporalExtent","getTemporalExtent","temporalExtent","getHighlightTemporalExtent","getGeojsonTracks","createSelector","tracks","filter","t","getGeojsonTracksReady","mergeStyles","style1","style2","sources","_objectSpread","layers","_toConsumableArray","filterGeojsonByTimerange","geojson","_ref","features","featuresFiltered","reduce","filteredFeatures","feature","properties","coordinateProperties","times","filtered","geometry","coordinates","filteredCoordinates","coordinate","index","timeCoordinate","push","filteredFeature","getFullTracksStyles","hasTemporalExtent","hasTracks","timerange","acc","track","source","style","_defineProperty","paint","line-width","line-color","circle-radius","circle-color","getHighlightedTrackStyles","getTracksStyles","trackStyles","highlightedTrackStyles","TRANSITION_TYPE","BRUSH_RENDERING_STYLE","NORMAL","BULLSEYE","BRUSH_ZOOM_RENDERING_STYLE","CUSTOM_LAYERS_SUBTYPES","getTemporalTileURLs","urlTemplate","params","arguments","urls","forEach","extent","urlParams","startTimeISO","toISOString","endTimeISO","tileCoordinates","x","y","z","zoom","templateSettings","interpolate","template","urlTemplateCompiled","buildEndpoint","temporalExtentsIndices","indexOf","getTilePromises","tilesetUrl","promises","urlIndex","obtainTile","getCleanVectorArrays","rawTileData","vectorArray","groupData","cleanVectorArrays","columns","currentArray","totalVectorArraysLength","sumBy","a","longitude","filteredColumns","column","console","warn","key","cumulatedOffsets","appendValues","set","getTilePlaybackData","prevPlaybackData","tilePlaybackData","zoomFactorRadius","convert","getZoomFactorRadius","zoomFactorRadiusRenderingMode","getZoomFactorRadiusRenderingMode","zoomFactorOpacity","getZoomFactorOpacity","columnsArr","Object","keys","c","storedColumns","sigma","weight","hidden","pull","uniq","_loop","point","timeIndex","getOffsetedTimeAtPrecision","datetime","_lngLatToWorld2","_slicedToArray","lngLatToWorld","latitude","worldX","worldY","radius","sigmaToRadius","opacity","weightToOpacity","series","frame","addTracksPointsRenderingData","hasFishing","_lngLatToWorld4","getTracksPlaybackData","playbackData","vesselSatisfiesFilters","every","selectVesselsAt","tileData","tileQuery","startIndex","endIndex","currentFilters","vessels","toleranceRadiusInWorldUnits","_loop2","f","_loop3","wx","wy","filters","pass","some","vesselSatisfiesAllFilters","vessel","getTilecoverLimits","viewportZoom","Math","ceil","tilesAvailable","min_zoom","max_zoom","flushToReleaseTiles","heatmapTiles","currentToLoadTileUids","currentTilesToReleaseUids","currentToReleaseTileUids","releaseTiles","markTileAsLoaded","tileUids","flushTileState","forceLoadingAllVisibleTiles","currentVisibleTiles","tilesToLoad","tilesToReleaseUids","currentLoadedTiles","visibleTile","find","uid","loadedTile","tilesToLoadUids","tile","referenceTile","ADD_REFERENCE_TILE","visibleHeatmapLayers","heatmap","heatmapLayers","visibleHeatmapLayersIds","visible","getTiles","updateLoadedTiles","debouncedFlushState","debounce","updateHeatmapTilesFromViewport","mapViewport","viewport","currentTransition","boundsViewport","PerspectiveMercatorViewport","bounds","unproject","width","height","wn","es","w","s","e","n","boundsPolygonsCoordinates","limits","w1","e2","geom","viewportTilesCoords","tilecover","tiles","viewportTilesIndexes","indexes","visibleTiles","coords","prevZoom","queryHeatmapVessels","temporalExtentIndexes","uids","_queryHeatmap2","_queryHeatmap","layer","isEmpty","isCluster","isMouseCluster","foundVessels","highlightedVessels","layerId","layerPayload","tilesetId","subtype","HIGHLIGHT_VESSELS","clickableCluster","highlightableCluster","clearHighlightedVessels","highlightVesselFromHeatmap","heatmapTiles_actions_objectSpread","UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES","UPDATE_HEATMAP_TILE","getTemporalExtentsVisibleIndices","loadTemporalExtent","currentExtentStart","currentExtentEnd","indices","temporalExtentStart","layerIds","referenceTiles","newTemporalExtentsToLoad","loaderID","join","tilesByLayer","heatmap_actions_toConsumableArray","allPromises","heatmapLayerHeader","_heatmapLayerHeader","heatmap_actions_objectSpread","temporalExtentsIndicesLoaded","queriedTemporalExtentsIndices","visibleTemporalExtentsIndices","temporalExtentsIndicesToLoad","difference","tilePromise","Error","pelagosPromises","allLayerPromises","all","then","loadedLayerId","loadLayerTile","_ref2","parseLayerTile","loadAllTilesForLayer","layersVessels","availableTiles","bestTile","layerVesselsResult","layersVesselsResults","layerVessels","v","uniqBy","updateHeatmapLayers","newLayers","currentLoadTemporalExtent","prevLayersDict","newLayer","prevLayer","interactive","prevLayerId","l","transitionTo","increment","callback","onViewportChange","center","canZoomIn","canZoomOut","mouseLatLong","getFields","glFeature","fieldsDefinition","metadata","fields","k","fd","fieldKey","pow","area","toLocaleString","maximumFractionDigits","getAreaKm2","def","label","title","isLink","isMain","mainField","getFeature","mapInteraction","interactionType","glFeatures","glGetSource","legacyHeatmapFeature","currentStyle","mapStyle","toJS","event","currentLegacyHeatmapData","count","group","clusterPromises","getStaticLayerIdFromGlFeature","interaction_actions_objectSpread","cluster","clusterPromise","clusterId","cluster_id","glSource","getClusterExpansionZoom","err1","getClusterLeaves","err2","children","childrenFeatures","child","getCluster","autoClusterZoom","clusterBehavior","clusterZoom","zoomIntoVesselCenter","cursor","onClick","onHover","hsvToRgb","h_","s_","v_","h","parseFloat","floor","p","q","mod","r","g","b","round","hueToRgbDefaults","hueToRgbString","rgb","hexToRgb","hex","exec","parseInt","hueIncrementToHue","hueIncrement","wrapHue","HeatmapSubLayer","baseTexture","renderingStyleIndex","useNormalBlendMode","stage","PIXI","particles","ParticleContainer","scale","alpha","position","uvs","blendMode","BLEND_MODES","SCREEN","spritesPool","initialTextureFrame","Rectangle","mainVesselTexture","Texture","_setTextureFrame","clearSpriteProps","spritesProps","spritesPropsCount","destroy","textureFrame","clone","hueToHueIncrement","VESSELS_HUES_INCREMENTS_NUM","update","numProps","resizeSpritesPool","sprite","setTransform","numSprites","delta","toRemove","removeChildAt","toAdd","_addSprites","num","Sprite","anchor","addChild","worldToPixelsSimple","m","HeatmapLayer","React","Component","_build","_destroy","_redraw","nextProps","useRadialGradientStyle","props","setBrushZoomRenderingStyle","_this$props","rootStage","customRenderingStyle","subLayers","renderingStyle","rendering","setBrushRenderingStyle","brushRenderingStyle","toUpperCase","_setBrushRenderingStyleIndex","brushZoomRenderingStyle","_this","cappedZoomRenderingStyle","newStyleIndex","subLayer","setRenderingStyleIndex","_this2","_this$props2","defaultHue","allHuesToRender","currentlyUsedHues","allHues","_createSublayer","_destroySubLayer","_setSubLayersSpritePropsForTile","numFilters","hueToRender","render","_this$props3","viewportLeft","viewportRight","len","fi","scaledX","scaledY","mtx","pixelProjectionMatrix","_ref3","HeatmapLayer_slicedToArray","pitch","worldToPixels","pushSpriteProps","defaultOpacity","defaultSize","removeChild","TracksLayer","Graphics","nativeLines","clear","highlightTemporalExtentIndexes","overInInner","overExtent","drawFishingCircles","fishingCirclesRadius","drawOverTrack","_drawTrack","substr","lineThickness","lineOpacity","prevSeries","prevWorldX","prevWorldY","_ref$worldOffset","worldOffset","circlePoints","lineStyle","duplicateWorld","currentSeries","_worldToPixels2","TracksLayer_slicedToArray","moveTo","abs","atDatelineWorldY","isWestToEast","worldXEnd","atDatelineEndWorldX","atDatelineStartWorldX","_worldToPixels4","x1","y1","lineTo","_worldToPixels6","x2","y2","beginFill","circlesLength","drawCircle","endFill","ActivityLayers","pixiReady","touches","queryCoords","clientX","clientY","heatmapFadingIn","heatmapStage","_heatmapFadeinStep","BaseControl","setState","exportNativeViewport","_context","_updateViewportSize","_this$props$viewport","pixi","transparent","antialias","renderer","canvas","view","container","appendChild","baseTextureCanvas","blurFactor","tplCanvas","document","createElement","tplCtx","getContext","diameter","yCenter","gradient","createRadialGradient","rgbString","addColorStop","rgbOuter","fillStyle","fillRect","beginPath","arc","PI","fill","lineWidth","strokeStyle","stroke","getVesselTexture","fromCanvas","ticker","add","_onTick","viewportWidth","viewportHeight","resize","dim","_viewport$unproject2","ActivityLayers_slicedToArray","wrappedLongitude","heatmapFadeinStartTimestamp","now","timeElapsed","highlightedClickedVessel","highlightLayerData","highlightFilters","ActivityLayers_objectSpread","leftWorldScaled","rightWorldScaled","shouldUseRadialGradientStyle","toggleHeatmapDimming","_startHeatmapFadein","gl","getError","err","log","_this$_getHighlightDa","_getHighlightData","react_default","ref","onMouseMove","onTouchStart","react","heatmap_HeatmapLayer","tracks_TracksLayer","propTypes","func","contextTypes","getHeatmapLayersAsArray","ActivityLayers_container_objectSpread","getTracksWithData","getTemporalExtentIndexes","startTimestamp","endTimestamp","getHighlightTemporalExtentIndexes","connect","ownProps","nativeViewport","topLeftPx","bottomRightPx","topLeftWorld","pixelsToWorld","pixelUnprojectionMatrix","bottomRightWorld","northWest","southEast","north","south","west","east","PopupWrapper","closeButton","onClose","esm","offsetTop","tipSize","closeOnClick","defaultProps","Map","Map_classCallCheck","Map_getPrototypeOf","call","Map_defineProperty","Map_assertThisInitialized","_mapContainerRef","mapContainerStyle","window","getComputedStyle","setViewport","Map_objectSpread","lngLat","onMapInteraction","glMap","getMap","getSource","isDragging","resourceType","match","headers","Authorization","mouseOver","addEventListener","_resize","setTimeout","removeEventListener","_this3","maxZoom","minZoom","transitionEnd","onClosePopup","clickPopup","hoverPopup","hasHeatmapLayers","interactiveLayerIds","className","styles","onMouseLeave","onMouseEnter","assign","getRef","transformRequest","onTransitionEnd","getCursor","clickRadius","ActivityLayers_container","Map_PopupWrapper","content","getInteractiveLayerIds","staticLayers","getMapStyle","mapStyles","trackLayersIndex","lastIndexOf","finalMapStyles","mergeIn","mapStylesLayers","get","trackLayer","insert","fromJS","interaction","lat","long","attributions","GL_STYLE","sourceKey","attribution","setLayerStyleDefaults","layout","temporalField","visibility","initialState","cartoLayersInstanciated","basemapLayers","TYPES","geoJSON","INIT_MAP_STYLE","SET_MAP_STYLE","MARK_CARTO_LAYERS_AS_INSTANCIATED","SET_STATIC_LAYERS","SET_BASEMAP_LAYERS","setMapStyle","setStyleTemporalExtent","applyToThrottled","glLayers","glLayer","currentFilter","getIn","isLegacy","setIn","applyTemporalExtentThrottled","throttle","applyTemporalExtent","updateGLLayer","glLayerId","refLayer","currentStyleLayers","newStyle","glLayerIndex","findIndex","toggleLayerVisibility","isBasemap","refLayerOpacity","labelsVisibility","showLabels","colorPaintProperty","currentGlLayer","glType","defaultStyles","styleType","hasFeatures","applyStyleToAllFeatures","allPaintProperties","style_actions_objectSpread","glPaintProperty","glPaintFinalValue","selectedValue","fallbackValue","paintOrLayout","includes","originalLayerStyle","layerColorRgbString","layerColorRgb","replace","applyLayerExpressions","addCustomGLLayer","tileSize","allGeoJSONTypes","numByGLType","geoJSONType","glTypeMax","getMainGeomType","layerIndex","reverse","splice","instanciateCartoLayers","sourceId","cartoLayersPromises","sourceCartoSQL","mapConfig","options","sql","mapConfigURL","encodeURIComponent","stringify","cartoAnonymousMapUrl","fetch","json","layergroupid","catch","instanciatedCartoLayers","cartoLayer","tilesURL","newSourceId","commitStyleUpdates","style_actions_toConsumableArray","bl","currentGLSources","workspaceGLLayers","workspaceGLLayer","finalSource","workspaceGlLayer","sourceLayer","source-layer","existingLayers","newLayerGroup","newLayerIndex","findLastIndex","addWorkspaceGLLayers","customLayers","isCustom","glSources","cartoLayersToInstanciate","newTiles","cartoLayerInstanciated","composeEnhancers","compose","process","MAP_REDUX_REMOTE_DEBUG","REACT_APP_MAP_REDUX_REMOTE_DEBUG","store","createStore","applyMiddleware","thunk","targetMapVessel","geoBounds","vp","fitBounds","minLng","minLat","maxLng","maxLat","padding","timelineBounds","ADD_TRACK","UPDATE_TRACK","getTrackDataParsed","time","Infinity","getTrackBounds","tbbox","getOldTrackBoundsFormat","addOffset","geo","lng","updateTracks","newTracks","prevTracks","newTrack","trackId","prevTrack","trackHasData","trackHasUrl","cleanData","rawTrackData","statusText","_getTrackDataParsed","finally","withReducerPropTypes","propTypesSchema","reducer","onAttributionsChange","withReducerTypes","instanceOf","action","module_reducer_objectSpread","module_reducer_toConsumableArray","loaderIndex","exact","tracks_reducer_objectSpread","tracks_reducer_toConsumableArray","trackData","removedTrackId","DEFAULT_TRANSITION","transitionDuration","transitionInterpolator","FlyToInterpolator","transitionEasing","easeCubic","bearing","mapReducer","combineReducers","ModuleReducer","TracksReducer","indicesAdded","heatmap_reducer_defineProperty","heatmap_reducer_objectSpread","heatmap_reducer_toConsumableArray","newTile","layerTiles","tileIndex","tileUid","releasedTileIndex","releasedRefTileIndex","newHeatmapLayers","heatmapTiles_reducer_objectSpread","tileUidsMarkedAsLoaded","newMapStyle","glyphsPath","style_reducer_objectSpread","style_reducer_toConsumableArray","viewport_reducer_objectSpread","currentZoom","interaction_reducer_objectSpread","mapReducers","replaceReducer","throttleApplyTemporalExtent","setTemporalExtent","updateViewportFromIncomingProps","incomingViewport","viewportUpdate","MapModule","initialized","errorInfo","prevProps","indicesToAddByLayer","heatmapLayer","oldVisibleTemporalExtentsIndices","newVisibleTemporalExtentsIndices","layerIdsWithIndicesToAdd","currentViewport","componentStack","react_redux_es","Map_container","MDXContent","map_map_classCallCheck","map_map_possibleConstructorReturn","map_map_getPrototypeOf","components","_objectWithoutProperties","dist","parentName","href","index_m","__codesandbox","__position","__code","__scope","map_map"],"mappings":"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","file":"static/js/src-map-map.a56587a4.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"map\":\"map_map__1CWd_\",\"googleLogo\":\"map_googleLogo__2KshJ\"};","/* eslint-disable */\nvar byname = {\n  Uint8: {\n    size: Uint8Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint8',\n    setter: 'setUint8',\n  },\n  Int8: {\n    size: Int8Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint8',\n    setter: 'setUint8',\n  },\n  Uint16: {\n    size: Uint16Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint16',\n    setter: 'setUint16',\n  },\n  Int16: {\n    size: Int16Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getInt16',\n    setter: 'setInt16',\n  },\n  Uint32: {\n    size: Uint32Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint32',\n    setter: 'setUint32',\n  },\n  Int32: {\n    size: Int32Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getInt32',\n    setter: 'setInt32',\n  },\n  Float32: {\n    size: Float32Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getFloat32',\n    setter: 'setFloat32',\n  },\n  Float64: {\n    size: Float64Array.BYTES_PER_ELEMENT,\n    array: 'Float64Array',\n    getter: 'getFloat64',\n    setter: 'setFloat64',\n  },\n}\n\nvar writeStringToArrayBuffer = function(str, start, end, buf, bufstart) {\n  if (end == undefined) {\n    end = str.length\n  }\n  if (start == undefined) {\n    start = 0\n  }\n  if (bufstart == undefined) {\n    bufstart = start\n  }\n  for (var i = start; i < end; i++) {\n    buf[i - start + bufstart] = str.charCodeAt(i) & 0xff\n  }\n}\n\nvar stringToArrayBuffer = function(str, start, end) {\n  var self = this\n\n  if (end == undefined) {\n    end = str.length\n  }\n  if (start == undefined) {\n    start = 0\n  }\n  var res = new Uint8ClampedArray(end - start)\n  writeStringToArrayBuffer(str, start, end, res, 0)\n  return res.buffer\n}\n\nvar arrayBufferToString = function(buf) {\n  return String.fromCharCode.apply(null, new Uint8Array(buf))\n}\n\nvar pack = function(typespec, value, littleendian) {\n  var array = new ArrayBuffer(typespec.size)\n  new DataView(array)[typespec.setter](0, value, littleendian)\n  return arrayBufferToString(array)\n}\n\nvar Pack = {\n  typemap: {\n    byname: byname,\n    byarray: {},\n  },\n  pack: pack,\n  arrayBufferToString: arrayBufferToString,\n  stringToArrayBuffer: stringToArrayBuffer,\n  writeStringToArrayBuffer: writeStringToArrayBuffer,\n}\nfor (var name in Pack.typemap.byname) {\n  var spec = Pack.typemap.byname[name]\n  spec.name = name\n  Pack.typemap.byarray[spec.array] = spec\n}\n\nexport default Pack\n","/* eslint-disable */\n\nimport Pack from './Pack'\n\nclass PelagosClient {\n  constructor() {\n    this.MAGIC_COOKIE = 'tmtx'\n  }\n\n  obtainTile(url, token) {\n    return new Promise(\n      function(resolve, reject) {\n        this.request = null\n        if (typeof XMLHttpRequest != 'undefined') {\n          this.request = new XMLHttpRequest()\n        } else {\n          throw 'XMLHttpRequest is disabled'\n        }\n        this.resolve = resolve\n        this.reject = reject\n        this.request.open('GET', url, true)\n        if (token) {\n          this.request.setRequestHeader('Authorization', `Bearer ${token}`)\n        }\n        this.request.responseType = 'arraybuffer'\n        this.request.onload = this.handleData.bind(this)\n        this.request.onerror = this.handleData.bind(this)\n        this.request.send(null)\n      }.bind(this)\n    )\n  }\n\n  handleData() {\n    var self = this\n    if (!this.request) {\n      return\n    }\n    if (this.error) {\n      return true\n    }\n\n    if (this.request.readyState == 4) {\n      /* HTTP reports success with a 200 status. The file protocol\n       reports success with zero. HTTP returns zero as a status\n       code for forbidden cross domain requests.\n       https://developer.mozilla.org/En/Using_XMLHttpRequest */\n      var success = this.request.status == 200 || (this.isFileUri && this.request.status == 0)\n      if (!success) {\n        this.resolve(null)\n        return\n      }\n    }\n\n    if (!this.request.response) {\n      return\n    }\n    var length = this.request.response.byteLength\n    var response = this.request.response\n    var dataView = new DataView(response)\n\n    if (length < 4 + 4) {\n      return\n    }\n    if (self.headerLen == null) {\n      var cookie = Pack.arrayBufferToString(response.slice(0, 4))\n      if (cookie != this.MAGIC_COOKIE) {\n        this.reject(\n          'Could not load ' +\n            this.url +\n            ' due to incorrect file format. Cookie: [' +\n            this.cookie +\n            ']'\n        )\n        return\n      }\n\n      self.headerLen = dataView.getInt32(4, true)\n\n      self.offset = 4 + 4\n    }\n    if (length < self.offset + self.headerLen) {\n      return\n    }\n    if (!self.headerIsLoaded) {\n      self.header = JSON.parse(\n        Pack.arrayBufferToString(response.slice(self.offset, self.offset + self.headerLen))\n      )\n      self.rowLen = 0\n      self.header.colsByName = {}\n      for (var colidx = 0; colidx < self.header.cols.length; colidx++) {\n        var col = self.header.cols[colidx]\n        col.idx = colidx\n        self.header.colsByName[col.name] = col\n        col.typespec = Pack.typemap.byname[col.type]\n\n        if (col.multiplier != undefined && col.min != undefined) {\n          col.min = col.min * col.multiplier\n        }\n        if (col.offset != undefined && col.min != undefined) {\n          col.min = col.min + col.offset\n        }\n        if (col.multiplier != undefined && col.max != undefined) {\n          col.max = col.max * col.multiplier\n        }\n        if (col.offset != undefined && col.max != undefined) {\n          col.max = col.max + col.offset\n        }\n\n        self.rowLen += col.typespec.size\n      }\n      self.offset += self.headerLen\n\n      // Add the padding to nearest 4-byte-boundary\n      self.offset += (4 - (self.headerLen % 4)) % 4\n\n      self.headerIsLoaded = true\n      if (self.header.orientation != 'rowwise' && self.header.orientation != 'columnwise') {\n        self.errorLoading({\n          orientation: self.header.orientation,\n          toString: function() {\n            return (\n              'Could not load ' +\n              this.url +\n              ' due to unsupported file orientation. Orientation: ' +\n              this.orientation +\n              '. Supported orientations: rowwise, columnwise.'\n            )\n          },\n        })\n        return true\n      }\n\n      // Empty tile, stop parsing.\n      if (!self.rowLen) {\n        self.allLoaded()\n        return true\n      }\n    }\n    if (self.header.orientation == 'rowwise') {\n      var result = {}\n      for (; self.offset + self.rowLen <= length; self.rowidx++) {\n        var row = {}\n        for (var colidx = 0; colidx < self.header.cols.length; colidx++) {\n          var col = self.header.cols[colidx]\n          var val = dataView[col.typespec.getter](self.offset, true)\n          row[col.name] = val\n          self.offset += col.typespec.size\n        }\n        // self.rowLoaded(row);\n\n        result[col.name] = row\n      }\n      if (self.rowidx == self.header.length) {\n        // self.allLoaded();\n        this.resolve(result)\n      } else {\n        // self.batchLoaded();\n      }\n    } else if (self.header.orientation == 'columnwise') {\n      var colValues = null\n      var result = {}\n      if (length >= self.offset + self.header.length * self.rowLen) {\n        for (var colidx = 0; colidx < self.header.cols.length; colidx++) {\n          var col = self.header.cols[colidx]\n\n          colValues = new (eval(col.typespec.array))(\n            response.slice(self.offset, self.offset + col.typespec.size * self.header.length)\n          )\n          self.offset += self.header.length * col.typespec.size\n\n          result[col.name] = colValues\n        }\n\n        // self.allLoaded();\n        this.resolve(result)\n        return true\n      }\n    }\n  }\n}\n\nexport default PelagosClient\n","import PropTypes from 'prop-types'\n\nexport const trackTypes = {\n  id: PropTypes.string.isRequired,\n  url: PropTypes.string,\n  data: PropTypes.object,\n  color: PropTypes.string,\n  type: PropTypes.oneOf(['geojson', 'pelagos', undefined]),\n  layerTemporalExtents: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.number)),\n  fitBoundsOnLoad: PropTypes.bool,\n}\n","import PropTypes from 'prop-types'\n\nexport const heatmapLayerTypes = {\n  id: PropTypes.string.isRequired,\n  tilesetId: PropTypes.string,\n  subtype: PropTypes.string,\n  visible: PropTypes.bool,\n  hue: PropTypes.number,\n  opacity: PropTypes.number,\n  filters: PropTypes.arrayOf(\n    PropTypes.shape({\n      // hue overrides layer hue if set\n      hue: PropTypes.number,\n      // filterValues is a dictionary in which each key is a filterable field,\n      // and values is an array of all possible values (OR filter)\n      // ie: filterValues: { category: [5, 6] }\n      filterValues: PropTypes.object,\n    })\n  ),\n  header: PropTypes.shape({\n    endpoints: PropTypes.object,\n    colsByName: PropTypes.object,\n    temporalExtents: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.number)),\n    temporalExtentsLess: PropTypes.bool,\n  }).isRequired,\n  interactive: PropTypes.bool,\n}\n\nexport const basemapLayerTypes = {\n  id: PropTypes.string,\n  visible: PropTypes.bool,\n}\n\nexport const staticLayerTypes = {\n  id: PropTypes.string.isRequired,\n  // TODO MAP MODULE Is that needed and if so why\n  visible: PropTypes.bool,\n  selected: PropTypes.bool,\n  selectedFeatures: PropTypes.shape({\n    field: PropTypes.string,\n    values: PropTypes.arrayOf(PropTypes.string),\n  }),\n  highlighted: PropTypes.bool,\n  higlightedFeatures: PropTypes.shape({\n    field: PropTypes.string,\n    values: PropTypes.arrayOf(PropTypes.string),\n  }),\n  opacity: PropTypes.number,\n  color: PropTypes.string,\n  showLabels: PropTypes.bool,\n  interactive: PropTypes.bool,\n  filters: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.string)),\n  isCustom: PropTypes.bool,\n  subtype: PropTypes.oneOf([undefined, 'geojson', 'raster']),\n  url: PropTypes.string,\n  data: PropTypes.object,\n  gl: PropTypes.object,\n}\n","import PropTypes from 'prop-types'\n\nexport const popupTypes = {\n  content: PropTypes.node,\n  latitude: PropTypes.number.isRequired,\n  longitude: PropTypes.number.isRequired,\n}\n\nexport const viewportTypes = {\n  zoom: PropTypes.number,\n  center: PropTypes.arrayOf(PropTypes.number),\n}\n","// Application settings\nexport const TIMELINE_STEP = 24 * 60 * 60 * 1000 // 1 day\nexport const MIN_FRAME_LENGTH_MS = TIMELINE_STEP // 1 day\n\n// vessels rendering\n// from this zoom level and above, render using circle style instead of heatmap\nexport const VESSELS_RADIAL_GRADIENT_STYLE_ZOOM_THRESHOLD = 6\n// the base radius, it can only be scaled down by the radius factor calculated on the dataset\nexport const VESSELS_BASE_RADIUS = 8\n// in heatmap style, defines how 'blurry' a point will look. Higher = less blur\nexport const VESSELS_HEATMAP_BLUR_FACTOR = 0.15\n\nexport const ACTIVITY_HIGHLIGHT_HUE = 312\n\nexport const VESSELS_HEATMAP_DIMMING_ALPHA = 0.5\n\nexport const TRACKS_DOTS_STYLE_ZOOM_THRESHOLD = 2\n\nexport const MAX_SPRITES_PER_LAYER = 200000\n\n// interaction\n// radius of vessels lookup in pixels,\n// ie how large the clicked region should be for including vessels\nexport const VESSEL_CLICK_TOLERANCE_PX = 10\n\nexport const CLUSTER_CLICK_ZOOM_INCREMENT = 1\n\nexport const MIN_ZOOM_LEVEL = 1\n// user can zoom up to this z level, but it doesn't guarantee availability of tiles\nexport const MAX_ZOOM_LEVEL = 14\n\n// data\n// Limit tile loading for activity layers up to this z level.\n// Beyond, layer is still displayed but with coarse data from the lower zoom level\nexport const ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING = 10\n\n// Sets what should be the discrete zoom level to load tiles, from a non-discrete\n// viewport zoom values. For instance, a values of 0.5 will load z 3 with a viewport\n// z of 2 (ceiling of 2 + 0.5)\n// this has a direct impact on the number of points displayed on the map, thus on the\n// performance of the app.\nexport const TILES_LOAD_ZOOM_OFFSET = 0.5\n\nexport const STATIC_LAYERS_CARTO_ENDPOINT =\n  'https://carto.globalfishingwatch.org/user/admin/api/v1/map?config=$MAPCONFIG'\nexport const STATIC_LAYERS_CARTO_TILES_ENDPOINT =\n  'https://carto.globalfishingwatch.org/user/admin/api/v1/map/$LAYERGROUPID/{z}/{x}/{y}.mvt'\n\nexport const TRACKS_LAYER_IN_FRONT_OF_GROUP = 'temporal'\n\nexport const TILES_URL_NEEDING_AUTHENTICATION = 'dot-world-fishing'\n","export const INIT_MODULE = 'INIT_MODULE'\nexport const SET_TEMPORAL_EXTENT = 'SET_TEMPORAL_EXTENT'\nexport const SET_HIGHLIGHT_TEMPORAL_EXTENT = 'SET_HIGHLIGHT_TEMPORAL_EXTENT'\nexport const START_LOADER = 'START_LOADER'\nexport const COMPLETE_LOADER = 'COMPLETE_LOADER'\n\nexport const initModule = (props) => (dispatch) => {\n  dispatch({\n    type: INIT_MODULE,\n    payload: props,\n  })\n}\n\nexport const startLoader = (dispatch, state, loaderId) => {\n  const timestamp = new Date().getTime()\n  const generatedLoaderId = loaderId !== undefined ? `${loaderId}_${timestamp}` : timestamp\n  dispatch({\n    type: START_LOADER,\n    payload: generatedLoaderId,\n  })\n  if (state.map.module.onLoadStart !== undefined) {\n    state.map.module.onLoadStart()\n  }\n  return loaderId\n}\n\nexport const completeLoader = (loaderId) => (dispatch, getState) => {\n  dispatch({\n    type: COMPLETE_LOADER,\n    payload: loaderId,\n  })\n  const state = getState()\n  const loaders = state.map.module.loaders\n  if (!loaders.length && state.map.module.onLoadComplete !== undefined) {\n    state.map.module.onLoadComplete()\n  }\n}\n\nexport const onViewportChange = () => (dispatch, getState) => {\n  const state = getState()\n  const callback = state.map.module.onViewportChange\n\n  if (callback === undefined) {\n    return\n  }\n  const viewport = state.map.viewport\n\n  if (viewport.bounds === undefined) {\n    return\n  }\n\n  callback({\n    zoom: viewport.viewport.zoom,\n    center: [viewport.viewport.latitude, viewport.viewport.longitude],\n    bounds: viewport.bounds,\n    canZoomIn: viewport.canZoomIn,\n    canZoomOut: viewport.canZoomOut,\n    mouseLatLong: viewport.mouseLatLong,\n  })\n}\n\nexport const setTemporalExtent = (temporalExtent) => ({\n  type: SET_TEMPORAL_EXTENT,\n  payload: temporalExtent,\n})\n\nexport const setHighlightTemporalExtent = (highlightTemporalExtent) => ({\n  type: SET_HIGHLIGHT_TEMPORAL_EXTENT,\n  payload: highlightTemporalExtent,\n})\n\nexport const closePopup = () => (dispatch, getState) => {\n  const state = getState()\n  if (state.map.module.onClosePopup !== undefined) {\n    state.map.module.onClosePopup()\n  }\n}\n","export const getTemporalExtent = (state) => state.map.module.temporalExtent\n\nexport const getHighlightTemporalExtent = (state) => state.map.module.highlightTemporalExtent\n","import { createSelector } from 'reselect'\nimport { getTemporalExtent, getHighlightTemporalExtent } from '../module/module.selectors'\n\nexport const getTracksData = (state) => state.map.tracks.data\nexport const getGeojsonTracks = createSelector(\n  getTracksData,\n  (tracks) => tracks.filter((t) => t.type === 'geojson')\n)\nexport const getGeojsonTracksReady = createSelector(\n  getGeojsonTracks,\n  (tracks) => tracks.filter((t) => t.data !== undefined)\n)\n\nconst mergeStyles = (style1, style2) => ({\n  sources: { ...style1.sources, ...style2.sources },\n  layers: [...style1.layers, ...style2.layers],\n})\n\nconst filterGeojsonByTimerange = (geojson, { start, end }) => {\n  if (!geojson || !geojson.features) return null\n  const featuresFiltered = geojson.features.reduce((filteredFeatures, feature) => {\n    const hasTimes =\n      feature.properties &&\n      feature.properties.coordinateProperties &&\n      feature.properties.coordinateProperties.times &&\n      feature.properties.coordinateProperties.times.length > 0\n    if (hasTimes) {\n      const filtered = feature.geometry.coordinates.reduce(\n        (filteredCoordinates, coordinate, index) => {\n          const timeCoordinate = feature.properties.coordinateProperties.times[index]\n          const isInTimeline = timeCoordinate >= start && timeCoordinate <= end\n          if (isInTimeline) {\n            filteredCoordinates.coordinates.push(coordinate)\n            filteredCoordinates.times.push(timeCoordinate)\n          }\n          return filteredCoordinates\n        },\n        { coordinates: [], times: [] }\n      )\n      if (!filtered.coordinates.length) return filteredFeatures\n\n      const filteredFeature = {\n        ...feature,\n        geometry: {\n          ...feature.geometry,\n          coordinates: filtered.coordinates,\n        },\n        properties: {\n          ...feature.properties,\n          coordinateProperties: {\n            times: filtered.times,\n          },\n        },\n      }\n      filteredFeatures.push(filteredFeature)\n    }\n    return filteredFeatures\n  }, [])\n  const geojsonFiltered = {\n    ...geojson,\n    features: featuresFiltered,\n  }\n  return geojsonFiltered\n}\n\nconst getFullTracksStyles = createSelector(\n  [getTemporalExtent, getGeojsonTracksReady],\n  (temporalExtent, tracks) => {\n    const hasTemporalExtent = temporalExtent && temporalExtent.length > 0\n    const hasTracks = tracks && tracks.length > 0\n    if (!hasTemporalExtent || !hasTracks) return null\n\n    const timerange = {\n      start: temporalExtent[0].getTime(),\n      end: temporalExtent[1].getTime(),\n    }\n    const styles = tracks.reduce(\n      (acc, track) => {\n        if (!track.data) return acc\n\n        const source = `${track.id}Track`\n        const style = {\n          sources: {\n            [source]: {\n              type: 'geojson',\n              data: filterGeojsonByTimerange(track.data, timerange),\n            },\n          },\n          layers: [\n            {\n              id: `${track.id}Lines`,\n              source,\n              type: 'line',\n              paint: {\n                'line-width': 1,\n                'line-color': track.color,\n              },\n            },\n            {\n              id: `${track.id}Points`,\n              source,\n              type: 'circle',\n              filter: ['match', ['geometry-type'], ['', 'Point'], true, false],\n              paint: {\n                'circle-radius': 4,\n                'circle-color': track.color,\n              },\n            },\n          ],\n        }\n        return mergeStyles(acc, style)\n      },\n      { sources: {}, layers: [] }\n    )\n    return styles\n  }\n)\n\nconst getHighlightedTrackStyles = createSelector(\n  [getHighlightTemporalExtent, getGeojsonTracksReady],\n  (highlightTemporalExtent, tracks) => {\n    const hasTemporalExtent = highlightTemporalExtent && highlightTemporalExtent.length > 0\n    const hasTracks = tracks && tracks.length > 0\n    if (!hasTemporalExtent || !hasTracks) return null\n\n    const timerange = {\n      start: highlightTemporalExtent[0].getTime(),\n      end: highlightTemporalExtent[1].getTime(),\n    }\n    const styles = tracks.reduce(\n      (acc, track) => {\n        if (!track.data) return acc\n\n        const source = `${track.id}HighlightedTrack`\n        const style = {\n          sources: {\n            [source]: {\n              type: 'geojson',\n              data: filterGeojsonByTimerange(track.data, timerange),\n            },\n          },\n          layers: [\n            {\n              id: `${track.id}HighlightedLines`,\n              source,\n              type: 'line',\n              paint: {\n                'line-width': 1,\n                'line-color': '#fff',\n              },\n            },\n          ],\n        }\n        return mergeStyles(acc, style)\n      },\n      { sources: {}, layers: [] }\n    )\n    return styles\n  }\n)\n\nexport const getTracksStyles = createSelector(\n  [getFullTracksStyles, getHighlightedTrackStyles],\n  (trackStyles, highlightedTrackStyles) => {\n    if (!highlightedTrackStyles) return trackStyles\n    return mergeStyles(trackStyles, highlightedTrackStyles)\n  }\n)\n","export const GL_TRANSPARENT = 'rgba(0,0,0,0)'\n\nexport const TRANSITION_TYPE = {\n  ZOOM: 'ZOOM',\n}\n\nexport const ENCOUNTERS = 'Encounters'\n\nexport const BRUSH_RENDERING_STYLE = {\n  NORMAL: 0,\n  BULLSEYE: 2,\n}\n\nexport const BRUSH_ZOOM_RENDERING_STYLE = {\n  RADIAL_GRADIENT: 0,\n  CIRCLE: 1,\n}\n\nexport const POLYGON_LAYERS_AREA = 'POLYGON_LAYERS_AREA'\n\nexport const CUSTOM_LAYERS_SUBTYPES = {\n  geojson: 'geojson',\n  raster: 'raster',\n}\n","import pull from 'lodash/pull'\nimport uniq from 'lodash/uniq'\nimport sumBy from 'lodash/sumBy'\nimport { lngLatToWorld } from 'viewport-mercator-project'\nimport convert from '@globalfishingwatch/map-convert'\nimport buildEndpoint from './buildEndpoint'\nimport PelagosClient from '../lib/pelagosClient'\n\n/**\n * Generates the URLs to load vessel track data for a tile\n *\n * @param {string} tilesetUrl       the tileset base URL\n * @param {array} temporalExtents   all tileset temporal extents\n * @param {object} params           - tileCoordinates: this tiles tile coordinates (zoom, x, y). Will default to 0,0,0\n *                                  - temporalExtentsIndices: restrict to these temporalExtents indices\n * @returns {Array}                 an array of URLs for this tile\n */\nconst getTemporalTileURLs = (urlTemplate, temporalExtents, params = {}) => {\n  const urls = []\n\n  ;(temporalExtents || [null]).forEach((extent, index) => {\n    const urlParams = {}\n    if (extent !== null && params.temporalExtentsLess !== true) {\n      urlParams.startTimeISO = new Date(extent[0]).toISOString()\n      urlParams.endTimeISO = new Date(extent[1]).toISOString()\n    }\n    if (params.tileCoordinates) {\n      urlParams.x = params.tileCoordinates.x\n      urlParams.y = params.tileCoordinates.y\n      urlParams.z = params.tileCoordinates.zoom\n    }\n\n    const url = buildEndpoint(urlTemplate, urlParams)\n\n    if (\n      params.temporalExtentsLess === true ||\n      !params.temporalExtentsIndices ||\n      params.temporalExtentsIndices.indexOf(index) > -1\n    ) {\n      urls.push(url)\n    }\n  })\n  return urls\n}\n\n/**\n * See getTemporalTileURLs.\n */\nexport const getTilePromises = (tilesetUrl, token, temporalExtents, params = {}) => {\n  const promises = []\n  const urls = getTemporalTileURLs(tilesetUrl, temporalExtents, params)\n  for (let urlIndex = 0, length = urls.length; urlIndex < length; urlIndex++) {\n    promises.push(new PelagosClient().obtainTile(urls[urlIndex], token))\n  }\n\n  return promises\n}\n\nexport const getCleanVectorArrays = (rawTileData) =>\n  rawTileData.filter((vectorArray) => vectorArray !== null)\n\n/**\n * As data will come in multiple arrays (1 per API query/year basically), they need to be merged here\n *\n * @param cleanVectorArrays an array of objects containing a Float32Array for each vessel param (lat, lon, weight...)\n * @param columns the keys to pick on the vectorArrays (lat, lon, weight, etc)\n * @returns an object containing a Float32Array for each API_RETURNED_KEY (lat, lon, weight, etc)\n */\nexport const groupData = (cleanVectorArrays, columns) => {\n  const data = {}\n\n  const totalVectorArraysLength = sumBy(cleanVectorArrays, (a) => a.longitude.length)\n\n  const filteredColumns = columns.filter((column) => {\n    if (cleanVectorArrays[0] && cleanVectorArrays[0][column] === undefined) {\n      console.warn(`column ${column} is present in layerHeader.colsByName but not in tile data`)\n      return false\n    }\n    return true\n  })\n\n  filteredColumns.forEach((key) => {\n    data[key] = new Float32Array(totalVectorArraysLength)\n  })\n\n  let currentArray\n  let cumulatedOffsets = 0\n\n  const appendValues = (key) => {\n    data[key].set(currentArray[key], cumulatedOffsets)\n  }\n\n  for (let index = 0, length = cleanVectorArrays.length; index < length; index++) {\n    currentArray = cleanVectorArrays[index]\n    filteredColumns.forEach(appendValues)\n    cumulatedOffsets += currentArray.longitude.length\n  }\n  return data\n}\n\n/**\n * Converts Vector Array data to Playback format and stores it locally.\n * The data structure is an array indexed by a time unit, ie a set of points every day\n * This preprocessing step allows playback to play smoothly as the necessary conversions and data structure set up\n * is done once (after tile has been loaded)\n *\n * @param data the source data before indexing by day, an object containing\n *  - a vector (Float32Array) for each header's column in the case of Pelagos tiles\n *  - an array of points int the case of PBF tiles\n * @param colsByName the columns present on the dataset, determined by tileset headers\n * @param tileCoordinates x, y, z\n * @param prevPlaybackData an optional previously loaded tilePlaybackData array (when adding time range)\n */\nexport const getTilePlaybackData = (data, colsByName, tileCoordinates, prevPlaybackData) => {\n  const tilePlaybackData = prevPlaybackData === undefined ? [] : prevPlaybackData\n\n  const zoom = tileCoordinates.zoom\n  const zoomFactorRadius = convert.getZoomFactorRadius(zoom)\n  const zoomFactorRadiusRenderingMode = convert.getZoomFactorRadiusRenderingMode(zoom)\n  const zoomFactorOpacity = convert.getZoomFactorOpacity(zoom)\n\n  // store all available columns as object keys\n  const columns = {}\n  const columnsArr = Object.keys(colsByName)\n  columnsArr.forEach((c) => {\n    columns[c] = true\n  })\n\n  // columns specified by layer header columns\n  let storedColumns = [].concat(columnsArr)\n  if (columns.sigma === true) storedColumns.push('radius')\n  if (columns.weight === true) storedColumns.push('opacity')\n  if (columns.longitude === true) {\n    storedColumns.push('worldX')\n    storedColumns.push('worldY')\n  }\n  if (columns.id === true) {\n    storedColumns.push('series')\n  }\n\n  // omit values that will be transformed before being stored to playback data (ie lat -> worldY)\n  // only if hidden: true flag is set on header\n  ;['latitude', 'longitude', 'datetime'].forEach((col) => {\n    if (colsByName[col] === undefined || colsByName[col].hidden === true) {\n      pull(storedColumns, col)\n    }\n  })\n  // always pull sigma and weight\n  pull(storedColumns, 'sigma', 'weight')\n  storedColumns = uniq(storedColumns)\n\n  const numPoints = data.latitude.length\n\n  for (let index = 0, length = numPoints; index < length; index++) {\n    let point = {}\n    columnsArr.forEach((c) => {\n      point[c] = data[c][index]\n    })\n\n    const timeIndex = columns.timeIndex\n      ? point.timeIndex\n      : convert.getOffsetedTimeAtPrecision(point.datetime)\n\n    // FIXME: this should not be done when headers declare worldX/Y -  if (!columns.worldX) {\n    const [worldX, worldY] = lngLatToWorld([point.longitude, point.latitude], 1)\n    point.worldX = worldX\n    point.worldY = worldY\n\n    if (columns.sigma) {\n      point.radius = convert.sigmaToRadius(\n        point.sigma,\n        zoomFactorRadiusRenderingMode,\n        zoomFactorRadius\n      )\n    }\n    if (columns.weight) {\n      point.opacity = convert.weightToOpacity(point.weight, zoomFactorOpacity)\n    }\n    if (columns.id) {\n      point.series = point.id\n    }\n\n    if (!tilePlaybackData[timeIndex]) {\n      const frame = {}\n      storedColumns.forEach((column) => {\n        frame[column] = [point[column]]\n      })\n      tilePlaybackData[timeIndex] = frame\n      continue\n    }\n    const frame = tilePlaybackData[timeIndex]\n    storedColumns.forEach((column) => {\n      frame[column].push(point[column])\n    })\n  }\n  return tilePlaybackData\n}\n\nexport const addTracksPointsRenderingData = (data) => {\n  data.hasFishing = []\n  data.worldX = []\n  data.worldY = []\n\n  for (let index = 0, length = data.weight.length; index < length; index++) {\n    const [worldX, worldY] = lngLatToWorld([data.longitude[index], data.latitude[index]], 1)\n    data.worldX[index] = worldX\n    data.worldY[index] = worldY\n    data.hasFishing[index] = data.weight[index] > 0\n  }\n  return data\n}\n\n/**\n * A simplified version of getTilePlaybackData for tracks\n * Converts Vector Array data to Playback format (organized by days) and stores it locally\n * @param vectorArray the source data before indexing by day\n */\nexport const getTracksPlaybackData = (vectorArray) => {\n  const playbackData = []\n\n  for (let index = 0, length = vectorArray.series.length; index < length; index++) {\n    const datetime = vectorArray.datetime[index]\n    const timeIndex = convert.getOffsetedTimeAtPrecision(datetime)\n\n    if (!playbackData[timeIndex]) {\n      const frame = {\n        worldX: [vectorArray.worldX[index]],\n        worldY: [vectorArray.worldY[index]],\n        series: [vectorArray.series[index]],\n        hasFishing: [vectorArray.hasFishing[index]],\n      }\n      playbackData[timeIndex] = frame\n      continue\n    }\n    const frame = playbackData[timeIndex]\n    frame.worldX.push(vectorArray.worldX[index])\n    frame.worldY.push(vectorArray.worldY[index])\n    frame.series.push(vectorArray.series[index])\n    frame.hasFishing.push(vectorArray.hasFishing[index])\n  }\n  return playbackData\n}\n\nexport const vesselSatisfiesFilters = (frame, index, filterValues) => {\n  const satisfiesFilters = Object.keys(filterValues).every((field) => {\n    if (frame[field] === undefined) {\n      // this field is not available on this layer. This can happen in an edge case described\n      // here: https://github.com/GlobalFishingWatch/map-client/issues/661#issuecomment-334496469\n      return false\n    }\n    return filterValues[field].indexOf(frame[field][index]) > -1\n  })\n  return satisfiesFilters\n}\n\nconst vesselSatisfiesAllFilters = (frame, index, filters) => {\n  const satisfiesAllFilters = filters\n    .filter((f) => f.pass !== true)\n    .some((filter) => vesselSatisfiesFilters(frame, index, filter.filterValues))\n  return satisfiesAllFilters\n}\n\nexport const selectVesselsAt = (tileData, tileQuery, startIndex, endIndex, currentFilters) => {\n  const vessels = []\n\n  const { worldX, worldY, toleranceRadiusInWorldUnits } = tileQuery\n\n  for (let f = startIndex; f < endIndex; f++) {\n    const frame = tileData[f]\n    if (frame === undefined) continue\n    for (let i = 0; i < frame.worldX.length; i++) {\n      const wx = frame.worldX[i]\n      const wy = frame.worldY[i]\n\n      if (\n        (!currentFilters.length || vesselSatisfiesAllFilters(frame, i, currentFilters)) &&\n        wx >= worldX - toleranceRadiusInWorldUnits &&\n        wx <= worldX + toleranceRadiusInWorldUnits &&\n        wy >= worldY - toleranceRadiusInWorldUnits &&\n        wy <= worldY + toleranceRadiusInWorldUnits\n      ) {\n        const vessel = {}\n\n        Object.keys(frame).forEach((key) => {\n          vessel[key] = frame[key][i]\n        })\n        vessel.timeIndex = f\n        vessels.push(vessel)\n      }\n    }\n  }\n  return vessels\n}\n\n/*\nexport const getHistogram = (tiles, propName = 'weight') => {\n  let data = tiles\n    .filter(tile => tile.ready)\n    .map(tile => tile.data\n      .map(frame => frame[propName]));\n  data = flattenDeep(data);\n  if (data.length) {\n    const bins = d3.histogram().thresholds(d3.thresholdScott)(data);\n    const x = d3.scaleLinear().domain([0, d3.max(bins, d => d.length)]).range([0, 50]);\n    console.table(bins.filter(bin => bin.length).map((bin) => {\n      const binMin = d3.min(bin).toLocaleString({ maximumFractionDigits: 2 });\n      const binMax = d3.max(bin).toLocaleString({ maximumFractionDigits: 2 });\n      return {\n        range: [binMin, binMax].join(''),\n        bars: Array(Math.round(x(bin.length))).join(''),\n        num: bin.length\n      };\n    }));\n  }\n};\n*/\n","import template from 'lodash/template'\nimport templateSettings from 'lodash/templateSettings'\n\nexport default (urlTemplate, urlParams) => {\n  templateSettings.interpolate = /{{([\\s\\S]+?)}}/g\n  const urlTemplateCompiled = template(urlTemplate)\n  return urlTemplateCompiled(urlParams)\n}\n","import tilecover from '@mapbox/tile-cover/index'\nimport debounce from 'lodash/debounce'\nimport { PerspectiveMercatorViewport } from 'viewport-mercator-project'\nimport { ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING, TILES_LOAD_ZOOM_OFFSET } from '../config'\nimport {\n  getTile,\n  releaseTiles,\n  highlightVesselFromHeatmap,\n  updateLoadedTiles,\n} from './heatmap.actions'\n\nexport const SET_CURRENTLY_VISIBLE_TILES = 'SET_CURRENTLY_VISIBLE_TILES'\nexport const SET_CURRENTLY_LOADED_TILES = 'SET_CURRENTLY_LOADED_TILES'\nexport const SET_CURRENTLY_SWAPPED_TILE_UIDS = 'SET_CURRENTLY_SWAPPED_TILE_UIDS'\nexport const MARK_TILES_UIDS_AS_LOADED = 'MARK_TILES_UIDS_AS_LOADED'\nexport const RELEASE_MARKED_TILES_UIDS = 'RELEASE_MARKED_TILES_UIDS'\n\n// restrict tilecover to a single zoom level\n// could be customized to load less or more detailed tiles\nconst getTilecoverLimits = (viewportZoom) => {\n  let zoom = Math.ceil(viewportZoom + TILES_LOAD_ZOOM_OFFSET)\n  let tilesAvailable = true\n  if (zoom > ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING) {\n    zoom = ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING\n    tilesAvailable = false\n  }\n  return {\n    min_zoom: zoom,\n    max_zoom: zoom,\n    tilesAvailable,\n  }\n}\n\nconst flushToReleaseTiles = () => (dispatch, getState) => {\n  const state = getState()\n  const currentToLoadTileUids = state.map.heatmapTiles.currentToLoadTileUids\n  // console.log('Tiles left to load: ', currentToLoadTileUids);\n\n  // Tiles are released only when all to-load tiles have finished loading\n  // this is to ensure smooth visual transitions between zoom levels\n  if (!currentToLoadTileUids.length) {\n    const currentTilesToReleaseUids = state.map.heatmapTiles.currentToReleaseTileUids\n    // console.log('no more tiles to load, releasing ', currentTilesToReleaseUids);\n    dispatch(releaseTiles(currentTilesToReleaseUids))\n    dispatch({\n      type: RELEASE_MARKED_TILES_UIDS,\n    })\n  }\n}\n\nexport const markTileAsLoaded = (tileUids) => (dispatch) => {\n  dispatch({\n    type: MARK_TILES_UIDS_AS_LOADED,\n    payload: tileUids,\n  })\n  // console.log(tileUids, 'have finished loading');\n  dispatch(flushToReleaseTiles())\n}\n\nconst flushTileState = (forceLoadingAllVisibleTiles = false) => (dispatch, getState) => {\n  const state = getState()\n  const currentVisibleTiles = state.map.heatmapTiles.currentVisibleTiles\n  let tilesToLoad = []\n  const tilesToReleaseUids = []\n\n  if (forceLoadingAllVisibleTiles === true) {\n    tilesToLoad = currentVisibleTiles\n  } else {\n    const currentLoadedTiles = state.map.heatmapTiles.currentLoadedTiles\n\n    currentVisibleTiles.forEach((visibleTile) => {\n      if (currentLoadedTiles.find((t) => t.uid === visibleTile.uid) === undefined) {\n        tilesToLoad.push(visibleTile)\n      }\n    })\n\n    currentLoadedTiles.forEach((loadedTile) => {\n      if (currentVisibleTiles.find((t) => t.uid === loadedTile.uid) === undefined) {\n        tilesToReleaseUids.push(loadedTile.uid)\n      }\n    })\n  }\n\n  const tilesToLoadUids = tilesToLoad.map((t) => t.uid)\n  // console.log('force loading:', forceLoadingAllVisibleTiles)\n  // console.log('visible', currentVisibleTiles.map(t => t.uid))\n  // console.log('load', tilesToLoadUids)\n  // console.log('release', tilesToReleaseUids)\n  // console.log('----')\n\n  tilesToLoad.forEach((tile) => {\n    dispatch(getTile(tile))\n  })\n  dispatch({\n    type: SET_CURRENTLY_LOADED_TILES,\n    payload: currentVisibleTiles,\n  })\n\n  dispatch({\n    type: SET_CURRENTLY_SWAPPED_TILE_UIDS,\n    payload: {\n      tilesToLoadUids,\n      tilesToReleaseUids,\n    },\n  })\n\n  dispatch(updateLoadedTiles())\n  dispatch(flushToReleaseTiles())\n}\n\nconst _debouncedFlushState = (dispatch) => {\n  dispatch(flushTileState())\n}\nconst debouncedFlushState = debounce(_debouncedFlushState, 500)\n\nexport const updateHeatmapTilesFromViewport = (forceLoadingAllVisibleTiles = false) => (\n  dispatch,\n  getState\n) => {\n  // if in transition, skip loading/releasing\n  // else\n  //   collect all tiles in viewport\n  //   save them to reducer: currentVisibleTiles\n  // if not zooming: flush immediately\n  //   if forceLoadingAllVisiblelTiles\n  //     get tiles from currentVisibleTiles\n  //   else\n  //     get tiles from currentVisibleTiles\n  //     make delta with currentLoadedTiles\n  //     get tiles from delta+\n  //     release tiles from delta-\n  //   save to reducer: currentVisibleTiles -> currentLoadedTiles\n  // if zooming: debounced flush to avoid \"tile spam\"\n  const mapViewport = getState().map.viewport\n  const viewport = mapViewport.viewport\n\n  // do not allow any tile update during transitions (currently only zoom)\n  // wait for the end of the transition to look at viewport and load matching tiles\n  if (mapViewport.currentTransition !== null) {\n    return\n  }\n\n  // instanciate a viewport instance to get lat/lon from screen top left/ bottom right bounds\n  const boundsViewport = new PerspectiveMercatorViewport(viewport)\n  const bounds = [\n    boundsViewport.unproject([0, 0]),\n    boundsViewport.unproject([viewport.width, viewport.height]),\n  ]\n\n  const [wn, es] = bounds\n  const [w, s, e, n] = [wn[0], es[1], es[0], wn[1]]\n  const boundsPolygonsCoordinates = []\n\n  const limits = getTilecoverLimits(viewport.zoom)\n  if (limits.tilesAvailable === false && forceLoadingAllVisibleTiles !== true) {\n    return\n  }\n\n  if (e > 180 || w < -180) {\n    // deal with the antimeridian situation by splitting the bounds polygon into two polygons\n    const w1 = e > 180 ? w : w + 360\n    const e1 = 180 - 0.001\n    const w2 = -180\n    const e2 = e > 180 ? e - 360 : e\n    boundsPolygonsCoordinates.push([[[w1, n], [e1, n], [e1, s], [w1, s], [w1, n]]])\n    boundsPolygonsCoordinates.push([[[w2, n], [e2, n], [e2, s], [w2, s], [w2, n]]])\n  } else {\n    boundsPolygonsCoordinates.push([[[w, n], [e, n], [e, s], [w, s], [w, n]]])\n  }\n\n  const geom = {\n    type: 'MultiPolygon',\n    coordinates: boundsPolygonsCoordinates,\n  }\n\n  // using tilecover, get xyz tile coords as well as quadkey indexes (named uid through the app)\n  const viewportTilesCoords = tilecover.tiles(geom, limits)\n  const viewportTilesIndexes = tilecover.indexes(geom, limits)\n  const visibleTiles = []\n\n  viewportTilesCoords.forEach((coords, i) => {\n    const uid = viewportTilesIndexes[i]\n    const zoom = coords[2]\n    if (zoom >= 2) {\n      visibleTiles.push({\n        tileCoordinates: {\n          x: coords[0],\n          y: coords[1],\n          zoom: coords[2],\n        },\n        uid,\n      })\n    }\n  })\n\n  dispatch({\n    type: SET_CURRENTLY_VISIBLE_TILES,\n    payload: visibleTiles,\n  })\n\n  const isMouseWheelZooming = mapViewport.prevZoom !== viewport.zoom\n\n  if (isMouseWheelZooming === false) {\n    dispatch(flushTileState(forceLoadingAllVisibleTiles))\n  } else {\n    debouncedFlushState(dispatch)\n  }\n}\n\nexport const queryHeatmapVessels = (coords, temporalExtentIndexes) => (dispatch, getState) => {\n  // use tilecover to get what tile quadkey/uid \"belongs\" to the point\n  const geom = {\n    type: 'Point',\n    coordinates: [coords.longitude, coords.latitude],\n  }\n  const zoom = getState().map.viewport.viewport.zoom\n\n  // get quadkey for tile at current zoom level, but also neighbouring zoom levels,\n  // in case current zoom level tiles has not been loaded yet\n  const uids = [zoom, zoom - 1, zoom + 1]\n    .map((z) => getTilecoverLimits(z))\n    .map((limits) => tilecover.indexes(geom, limits))\n    .map((indexes) => indexes[0])\n\n  const query = {\n    ...coords,\n    uids,\n  }\n\n  // console.log(query);\n  dispatch(highlightVesselFromHeatmap(query, temporalExtentIndexes))\n}\n","import difference from 'lodash/difference'\nimport uniq from 'lodash/uniq'\nimport uniqBy from 'lodash/uniqBy'\nimport {\n  getTilePromises,\n  getCleanVectorArrays,\n  groupData,\n  getTilePlaybackData,\n  selectVesselsAt,\n} from '../utils/heatmapTileData'\nimport { markTileAsLoaded } from './heatmapTiles.actions'\nimport { startLoader, completeLoader } from '../module/module.actions'\n\nexport const ADD_HEATMAP_LAYER = 'ADD_HEATMAP_LAYER'\nexport const UPDATE_HEATMAP_LAYER_STYLE = 'UPDATE_HEATMAP_LAYER_STYLE'\nexport const ADD_REFERENCE_TILE = 'ADD_REFERENCE_TILE'\nexport const HIGHLIGHT_VESSELS = 'HIGHLIGHT_VESSELS'\nexport const INIT_HEATMAP_LAYERS = 'INIT_HEATMAP_LAYERS'\nexport const REMOVE_HEATMAP_LAYER = 'REMOVE_HEATMAP_LAYER'\nexport const UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES =\n  'UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES'\nexport const UPDATE_HEATMAP_TILE = 'UPDATE_HEATMAP_TILE'\nexport const RELEASE_HEATMAP_TILES = 'RELEASE_HEATMAP_TILES'\nexport const UPDATE_LOADED_TILES = 'UPDATE_LOADED_TILES'\nexport const HIGHLIGHT_CLICKED_VESSEL = 'HIGHLIGHT_CLICKED_VESSEL'\nexport const CLEAR_HIGHLIGHT_CLICKED_VESSEL = 'CLEAR_HIGHLIGHT_CLICKED_VESSEL'\n\n/**\n * getTemporalExtentsVisibleIndices - Compares timebar outer extent with temporal extents present on the layer header\n * @param  {array} loadTemporalExtent Current timebar outer extent\n * @param  {array} layerTemporalExtents Temporal extent present on the layer's header (an array of extent arrays)\n * @return {array}                    Indices of the layer's temporal extents that should be visible\n */\nfunction getTemporalExtentsVisibleIndices(loadTemporalExtent, layerTemporalExtents) {\n  const currentExtentStart = loadTemporalExtent[0].getTime()\n  const currentExtentEnd = loadTemporalExtent[1].getTime()\n  const indices = []\n  layerTemporalExtents.forEach((temporalExtent, index) => {\n    const temporalExtentStart = temporalExtent[0]\n    const temporalExtentEnd = temporalExtent[1]\n    if (temporalExtentEnd >= currentExtentStart && temporalExtentStart <= currentExtentEnd) {\n      indices.push(index)\n    }\n  })\n  return indices\n}\n\n/**\n * loadLayerTile - loads an heatmap tile.\n *\n * @param  {string} layerId              layer id\n * @param  {object} tileCoordinates      tile coordinates from reference tile\n * @param  {string} token                the user's token\n * @param  {array} temporalExtentsIndices which of the temporal extents from  temporalExtents should be loaded\n * @param  {string} urls                 tile endpoints provided by header\n * @param  {array} temporalExtents       all of the layer's header temporal extents\n * @param  {bool} temporalExtentsLess    true = don't try to load different tiles based on current time extent\n * @return {Promise}                     a Promise that will be resolved when tile is loaded\n */\nfunction loadLayerTile(\n  layerId,\n  tileCoordinates,\n  token,\n  temporalExtentsIndices,\n  { url, temporalExtents, temporalExtentsLess }\n) {\n  // console.log('loadLayerTile', layerId, tileCoordinates, temporalExtentsIndices)\n  if (url === undefined) {\n    throw new Error('URL/endpoints object is not available on this tilesets header')\n  }\n  const pelagosPromises = getTilePromises(url, token, temporalExtents, {\n    tileCoordinates,\n    temporalExtentsIndices,\n    temporalExtentsLess,\n  })\n  const allLayerPromises = Promise.all(pelagosPromises)\n\n  const layerTilePromise = new Promise((resolve) => {\n    allLayerPromises.then((rawTileData) => {\n      resolve({\n        loadedLayerId: layerId,\n        rawTileData,\n      })\n    })\n  })\n\n  return layerTilePromise\n}\n\n/**\n * parseLayerTile - parses an heatmap tile to a playback-ready format.\n *\n * @param  {Object} rawTileData          the raw tile data, loaded either from the pelagos client or as a MVT/PBF vector tile\n * @param  {array} colsByName            names of the columns present in the raw tiles that need to be included in the final playback data\n * @param  {object} tileCoordinates      tile coordinates from reference tile\n * @param  {array} prevPlaybackData      (optional) in case some time extent was already loaded for this tile, append to this data\n * @return {Object}                      playback-ready merged data\n */\nfunction parseLayerTile(rawTileData, colsByName, tileCoordinates, prevPlaybackData) {\n  let data\n\n  const cleanVectorArrays = getCleanVectorArrays(rawTileData)\n  data = groupData(cleanVectorArrays, Object.keys(colsByName))\n  if (Object.keys(data).length === 0) {\n    return []\n  }\n\n  const playbackData = getTilePlaybackData(data, colsByName, tileCoordinates, prevPlaybackData)\n  return playbackData\n}\n\n/**\n * getTiles - loads a bunch of heatmap tiles\n * @param  {array} layerIds                 list of layer Ids that need to be loaded for this/these tiles\n * @param  {array} referenceTiles           list of reference tiles (tile data regardless of layer) that need to be loaded\n * @param  {object} newTemporalExtentsToLoad (optional) a dict (layerId is the key) of temporal extents\n * indices that should be appended to existing data\n */\nfunction getTiles(layerIds, referenceTiles, newTemporalExtentsToLoad = undefined) {\n  return (dispatch, getState) => {\n    const state = getState()\n    const loaderID = startLoader(dispatch, state, layerIds.join('-'))\n    const token = state.map.module.token\n    const heatmapLayers = state.map.heatmap.heatmapLayers\n    const tilesByLayer = {}\n    layerIds.forEach((id) => {\n      tilesByLayer[id] = [...heatmapLayers[id].tiles]\n    })\n    const allPromises = []\n\n    layerIds.forEach((layerId) => {\n      const heatmapLayerHeader = heatmapLayers[layerId].header\n      const { temporalExtents, temporalExtentsLess, colsByName } = { ...heatmapLayerHeader }\n      const url = heatmapLayerHeader.endpoints.tiles\n\n      referenceTiles.forEach((referenceTile) => {\n        // check if tile does not already exist first\n        let tile = tilesByLayer[layerId].find((t) => t.uid === referenceTile.uid)\n        if (!tile) {\n          // console.log('create tile ', referenceTile.uid)\n          tile = {\n            uid: referenceTile.uid,\n            temporalExtentsIndicesLoaded: [],\n          }\n          tilesByLayer[layerId].push(tile)\n        } else {\n          // console.log('found tile', referenceTile.uid)\n        }\n\n        const queriedTemporalExtentsIndices =\n          newTemporalExtentsToLoad === undefined\n            ? heatmapLayers[layerId].visibleTemporalExtentsIndices\n            : newTemporalExtentsToLoad[layerId]\n\n        const temporalExtentsIndicesToLoad = difference(\n          queriedTemporalExtentsIndices,\n          tile.temporalExtentsIndicesLoaded\n        )\n\n        const tilePromise = loadLayerTile(\n          layerId,\n          referenceTile.tileCoordinates,\n          token,\n          temporalExtentsIndicesToLoad,\n          {\n            url,\n            temporalExtents,\n            temporalExtentsLess,\n          }\n        )\n\n        allPromises.push(tilePromise)\n\n        tilePromise.then(({ loadedLayerId, rawTileData }) => {\n          tile.temporalExtentsIndicesLoaded = uniq(\n            tile.temporalExtentsIndicesLoaded.concat(temporalExtentsIndicesToLoad)\n          )\n          tile.data = parseLayerTile(\n            rawTileData,\n            colsByName,\n            referenceTile.tileCoordinates,\n            tile.data\n          )\n\n          dispatch({\n            type: UPDATE_HEATMAP_TILE,\n            payload: {\n              layerId: loadedLayerId,\n              tile,\n            },\n          })\n        })\n      })\n    })\n\n    Promise.all(allPromises).then(() => {\n      dispatch(completeLoader(loaderID))\n      dispatch(markTileAsLoaded(referenceTiles.map((tile) => tile.uid)))\n    })\n  }\n}\n\n/**\n * getTile - This action is emitted when a new tile is queried from panning or zooming the map\n * This will load a tile for all currently visible heatmap layers\n *\n * @param  {object} referenceTile a reference tile containing xyz coords and uid\n */\nexport function getTile(referenceTile) {\n  return (dispatch, getState) => {\n    dispatch({\n      type: ADD_REFERENCE_TILE,\n      payload: referenceTile,\n    })\n    const visibleHeatmapLayers = getState().map.heatmap.heatmapLayers\n    const visibleHeatmapLayersIds = Object.keys(visibleHeatmapLayers).filter(\n      (id) => visibleHeatmapLayers[id].visible === true\n    )\n\n    if (visibleHeatmapLayersIds.length) {\n      dispatch(getTiles(visibleHeatmapLayersIds, [referenceTile]))\n    }\n  }\n}\n\n/**\n * releaseTiles - This action is emitted when an existing tile is removed from panning or zooming the map\n * @param  {array} uids tile ref uids to release\n */\nexport const releaseTiles = (uids) => ({\n  type: RELEASE_HEATMAP_TILES,\n  payload: uids,\n})\n\nexport const updateLoadedTiles = () => ({\n  type: UPDATE_LOADED_TILES,\n})\n\n// triggered when a layer is added or set to visible\nfunction loadAllTilesForLayer(layerId) {\n  return (dispatch, getState) => {\n    //                current layer, all reference tiles\n    const referenceTiles = getState().map.heatmap.referenceTiles\n    dispatch(getTiles([layerId], referenceTiles))\n  }\n}\n\nexport const addHeatmapLayer = (layer, loadTemporalExtent) => (dispatch) => {\n  const layerTemporalExtents = layer.header.temporalExtents\n  dispatch({\n    type: ADD_HEATMAP_LAYER,\n    payload: {\n      ...layer,\n      // initially attach which of the temporal extents indices are visible with initial outerExtent\n      visibleTemporalExtentsIndices: getTemporalExtentsVisibleIndices(\n        loadTemporalExtent,\n        layerTemporalExtents\n      ),\n    },\n  })\n\n  if (layer.visible === true) {\n    dispatch(loadAllTilesForLayer(layer.id))\n  }\n}\n\nexport const removeHeatmapLayer = (id) => (dispatch) => {\n  dispatch({\n    type: REMOVE_HEATMAP_LAYER,\n    payload: {\n      id,\n    },\n  })\n}\n\n/**\n * updateLayerLoadTemporalExtents - when outer time extent changes, checks if more tiles needs to be loaded\n * by comparing the outer time range with the temporalExtent already loaded on each layer.\n * @param  {array} loadTemporalExtent Current app-wide extent of tiles that need to load, expressed\n * as an array of two dates\n */\nexport function updateLayerLoadTemporalExtents(loadTemporalExtent) {\n  return (dispatch, getState) => {\n    const state = getState()\n    const heatmapLayers = state.map.heatmap.heatmapLayers\n    const indicesToAddByLayer = {}\n    Object.keys(heatmapLayers).forEach((layerId) => {\n      const heatmapLayer = heatmapLayers[layerId]\n      const temporalExtents = heatmapLayer.header.temporalExtents\n      const oldVisibleTemporalExtentsIndices = heatmapLayer.visibleTemporalExtentsIndices\n      const newVisibleTemporalExtentsIndices = getTemporalExtentsVisibleIndices(\n        loadTemporalExtent,\n        temporalExtents\n      )\n      const indicesAdded = difference(\n        newVisibleTemporalExtentsIndices,\n        oldVisibleTemporalExtentsIndices\n      )\n\n      if (indicesAdded.length) {\n        // add new loaded indices to heatmap layer if applicable\n        indicesToAddByLayer[layerId] = indicesAdded\n        dispatch({\n          type: UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES,\n          payload: {\n            layerId,\n            indicesAdded,\n          },\n        })\n      }\n    })\n\n    // getTiles with indices diff\n    const layerIdsWithIndicesToAdd = Object.keys(indicesToAddByLayer)\n    if (layerIdsWithIndicesToAdd.length) {\n      dispatch(\n        getTiles(layerIdsWithIndicesToAdd, state.map.heatmap.referenceTiles, indicesToAddByLayer)\n      )\n    }\n  }\n}\n\n/**\n * Returns clusters or vessels data from a tileQuery\n * @param {object} state - the application state\n * @param {string} tileQuery - the id of a heatmap layer\n * @return {object} { isEmpty, isCluster, isMouseCluster, foundVessels, layerId, tilesetId }\n */\nconst _queryHeatmap = (state, tileQuery, temporalExtentIndexes) => {\n  const layers = state.map.heatmap.heatmapLayers\n  const startIndex = temporalExtentIndexes[0]\n  const endIndex = temporalExtentIndexes[1]\n  const layersVessels = []\n\n  Object.keys(layers).forEach((layerId) => {\n    const layer = layers[layerId]\n    if (layer.visible !== true) {\n      return\n    }\n    const allPossibleTilesByPreference = tileQuery.uids.map((uid) =>\n      layer.tiles.find((tile) => tile.uid === uid)\n    )\n    const availableTiles = allPossibleTilesByPreference.filter(\n      (tile) => tile !== undefined && tile.data !== undefined\n    )\n\n    const currentFilters = layer.filters\n    if (availableTiles.length) {\n      const bestTile = availableTiles[0]\n      layersVessels.push({\n        layer,\n        vessels: selectVesselsAt(bestTile.data, tileQuery, startIndex, endIndex, currentFilters),\n      })\n    }\n  })\n\n  const layersVesselsResults = layersVessels.filter(\n    (layerVessels) => layerVessels.vessels.length > 0\n  )\n\n  // it's a cluster because of aggregation on the server side\n  let isCluster\n  // its a cluster because or multiple vessels under mouse\n  let isMouseCluster\n  let isEmpty\n  let layerVesselsResult\n  let foundVessels\n\n  if (layersVesselsResults.length === 0) {\n    isEmpty = true\n  } else if (layersVesselsResults.length > 1) {\n    // if there are points over multiple layers, consider this a cluster (ie don't select, zoom instead, or don't highlight)\n    // there's an exception if vessel selection contains an encounter, in which case it will take priority\n    isCluster = true\n  } else {\n    // layersVesselsResults should contain a single result\n    layerVesselsResult = layersVesselsResults[0]\n\n    // we can get multiple points with similar series and id, in which case\n    // we should treat that as a successful vessel query, not a cluster\n    const vessels = layerVesselsResult.vessels\n\n    if (vessels.length === 0) {\n      isEmpty = true\n    } else {\n      // look up for any negatives ids (clusters on the server side)\n      const clusteredVessels = vessels.filter((v) => v.id < 0)\n      if (clusteredVessels.length) {\n        isCluster = true\n      } else {\n        foundVessels = uniqBy(vessels, (v) => v.series)\n        isMouseCluster = foundVessels.length > 1\n      }\n    }\n  }\n\n  const layer = layerVesselsResult === undefined ? {} : layerVesselsResult.layer\n\n  return { isEmpty, isCluster, isMouseCluster, foundVessels, layer }\n}\n\nexport function clearHighlightedVessels() {\n  return {\n    type: HIGHLIGHT_VESSELS,\n    payload: {\n      isEmpty: true,\n      clickableCluster: false,\n    },\n  }\n}\n\nexport function highlightVesselFromHeatmap(tileQuery, temporalExtentIndexes) {\n  return (dispatch, getState) => {\n    const state = getState()\n    const { layer, isEmpty, isCluster, isMouseCluster, foundVessels } = _queryHeatmap(\n      state,\n      tileQuery,\n      temporalExtentIndexes\n    )\n\n    if (\n      isCluster === true ||\n      layer.id !== undefined ||\n      state.map.heatmap.highlightedVessels.layerId !== layer.id\n    ) {\n      const layerPayload =\n        layer === undefined\n          ? null\n          : {\n              id: layer.id,\n              tilesetId: layer.tilesetId,\n              subtype: layer.subtype,\n              header: layer.header,\n            }\n      dispatch({\n        type: HIGHLIGHT_VESSELS,\n        payload: {\n          layer: layerPayload,\n          isEmpty,\n          clickableCluster: isCluster === true || isMouseCluster === true,\n          highlightableCluster: isCluster !== true,\n          foundVessels,\n        },\n      })\n    } else {\n      dispatch(clearHighlightedVessels())\n    }\n  }\n}\n\nexport const highlightClickedVessel = (id, layerId) => ({\n  type: HIGHLIGHT_CLICKED_VESSEL,\n  payload: {\n    id,\n    layerId,\n  },\n})\n\nexport const clearHighlightedClickedVessel = () => ({\n  type: CLEAR_HIGHLIGHT_CLICKED_VESSEL,\n})\n\nexport const updateHeatmapLayers = (newLayers, currentLoadTemporalExtent) => (\n  dispatch,\n  getState\n) => {\n  if (newLayers === null) {\n    console.warn(\"New layers in updateHeatmapLayers can't be null\")\n    return\n  }\n  const prevLayersDict = getState().map.heatmap.heatmapLayers\n\n  // add and update layers\n  newLayers.forEach((newLayer) => {\n    const layerId = newLayer.id\n    const prevLayer = prevLayersDict[layerId]\n    if (prevLayer === undefined) {\n      // console.log('adding', layerId)\n      dispatch(addHeatmapLayer(newLayer, currentLoadTemporalExtent))\n    } else {\n      if (prevLayer.visible !== newLayer.visible && newLayer.visible === true) {\n        dispatch(loadAllTilesForLayer(layerId))\n      }\n      if (\n        prevLayer.visible !== newLayer.visible ||\n        prevLayer.hue !== newLayer.hue ||\n        prevLayer.opacity !== newLayer.opacity ||\n        prevLayer.filters !== newLayer.filters ||\n        prevLayer.interactive !== newLayer.interactive\n      ) {\n        // console.log('updating', layerId, ' with visibilty', newLayer.visible)\n        dispatch({\n          type: UPDATE_HEATMAP_LAYER_STYLE,\n          payload: {\n            id: newLayer.id,\n            visible: newLayer.visible,\n            hue: newLayer.hue,\n            opacity: newLayer.opacity,\n            filters: newLayer.filters,\n            interactive: newLayer.interactive,\n          },\n        })\n      }\n    }\n  })\n\n  // clean up unused layers\n  Object.keys(prevLayersDict).forEach((prevLayerId) => {\n    if (!newLayers.find((l) => l.id === prevLayerId)) {\n      dispatch(removeHeatmapLayer(prevLayerId))\n    }\n  })\n}\n","import { fitBounds, pixelsToWorld } from 'viewport-mercator-project'\nimport { updateHeatmapTilesFromViewport } from '../heatmap/heatmapTiles.actions'\nimport { onViewportChange } from '../module/module.actions'\nimport { CLUSTER_CLICK_ZOOM_INCREMENT } from '../config' // TODO MAP MODULE\n\nexport const SET_VIEWPORT = 'SET_VIEWPORT'\nexport const UPDATE_VIEWPORT = 'UPDATE_VIEWPORT'\nexport const SET_ZOOM_INCREMENT = 'SET_ZOOM_INCREMENT'\nexport const SET_MOUSE_LAT_LONG = 'SET_MOUSE_LAT_LONG'\nexport const TRANSITION_END = 'TRANSITION_END'\nexport const SET_NATIVE_VIEWPORT = 'SET_NATIVE_VIEWPORT'\n\nexport const setViewport = (viewport) => (dispatch) => {\n  dispatch({\n    type: SET_VIEWPORT,\n    payload: viewport,\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  dispatch(onViewportChange())\n}\n\nexport const updateViewport = (viewportUpdate) => (dispatch) => {\n  dispatch({\n    type: UPDATE_VIEWPORT,\n    payload: viewportUpdate,\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  dispatch(onViewportChange())\n}\n\nconst transitionTo = (increment, latitude = null, longitude = null, zoom = null) => (dispatch) => {\n  dispatch({\n    type: SET_ZOOM_INCREMENT,\n    payload: {\n      increment,\n      latitude,\n      longitude,\n      zoom,\n    },\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  dispatch(onViewportChange())\n}\n\nexport const transitionToZoom = (zoom) => (dispatch) => {\n  dispatch(transitionTo(null, null, null, zoom))\n}\n\nexport const transitionEnd = () => (dispatch) => {\n  dispatch({\n    type: TRANSITION_END,\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  dispatch(onViewportChange())\n}\n\nexport const zoomIntoVesselCenter = (latitude, longitude, zoom = null) => (dispatch) => {\n  dispatch(transitionTo(CLUSTER_CLICK_ZOOM_INCREMENT, latitude, longitude, zoom))\n}\n\nexport const fitToBounds = (bounds) => (dispatch, getState) => {\n  const state = getState()\n  const vp = fitBounds({\n    bounds: [[bounds.minLng, bounds.minLat], [bounds.maxLng, bounds.maxLat]],\n    width: state.map.viewport.viewport.width,\n    height: state.map.viewport.viewport.height,\n    padding: 50,\n  })\n  dispatch(transitionTo(null, vp.latitude, vp.longitude, vp.zoom))\n}\n\nexport const exportNativeViewport = (nativeViewport) => (dispatch) => {\n  const topLeftPx = [0, 0]\n  const bottomRightPx = [nativeViewport.width, nativeViewport.height]\n\n  // compute left and right offsets to deal with antimeridian issue\n  const topLeftWorld = pixelsToWorld(topLeftPx, nativeViewport.pixelUnprojectionMatrix)\n  const bottomRightWorld = pixelsToWorld(bottomRightPx, nativeViewport.pixelUnprojectionMatrix)\n  const leftWorldScaled = topLeftWorld[0] / nativeViewport.scale\n  const rightWorldScaled = bottomRightWorld[0] / nativeViewport.scale\n\n  // lat/lon corners for miniglobe\n  const northWest = nativeViewport.unproject(topLeftPx)\n  const southEast = nativeViewport.unproject(bottomRightPx)\n  const bounds = {\n    north: northWest[1],\n    south: southEast[1],\n    west: northWest[0],\n    east: southEast[0],\n  }\n\n  dispatch({\n    type: SET_NATIVE_VIEWPORT,\n    payload: {\n      leftWorldScaled,\n      rightWorldScaled,\n      bounds,\n    },\n  })\n}\n","import area from '@turf/area'\nimport { POLYGON_LAYERS_AREA } from '../constants'\nimport { clearHighlightedVessels, clearHighlightedClickedVessel } from '../heatmap/heatmap.actions'\nimport { zoomIntoVesselCenter } from './viewport.actions'\n\nexport const SET_POPUP = 'SET_POPUP'\nexport const CLEAR_POPUP = 'CLEAR_POPUP'\nexport const SET_MAP_CURSOR = 'SET_MAP_CURSOR'\n\nconst getAreaKm2 = (glFeature) => {\n  const areakm2 = 10 ** -6 * area(glFeature.geometry)\n  const formatted = areakm2.toLocaleString('en-US', { maximumFractionDigits: 0 })\n  return formatted\n}\n\nconst getFields = (glFeature, source = null) => {\n  if (source === null || source === undefined) {\n    // console.warn('Couldnt find source when looking for fields of layer', sourceId)\n  }\n\n  const fieldsDefinition =\n    source === undefined ||\n    source.metadata === undefined ||\n    source.metadata['gfw:popups'] === undefined\n      ? []\n      : source.metadata['gfw:popups']\n\n  const properties = glFeature.properties\n\n  // whitelist if 'gfw:popups' exist, if not return all\n  const fieldsKeys = Object.keys(glFeature.properties).filter(\n    (k) => fieldsDefinition.length === 0 || fieldsDefinition.find((fd) => fd.id === k) !== undefined\n  )\n\n  const fields = fieldsKeys.map((fieldKey) => {\n    const value = fieldKey === POLYGON_LAYERS_AREA ? getAreaKm2(glFeature) : properties[fieldKey]\n    const def = fieldsDefinition.find((fd) => fd.id === fieldKey) || {}\n    const label = def.label || fieldKey\n    return {\n      id: fieldKey,\n      label,\n      value,\n      title: `${label}: ${value}`,\n      isLink: def.isLink,\n      isMain: def.isMain,\n    }\n  })\n\n  const mainField =\n    fields.find((f) => f.isMain === true) ||\n    fields.find((f) => f.id === 'name') ||\n    fields.find((f) => f.id === 'id') ||\n    fields[0]\n\n  if (mainField !== undefined) {\n    mainField.isMain = true\n  }\n  return fields\n}\n\nconst getCluster = (glFeature, glGetSource) => {\n  const clusterId = glFeature.properties.cluster_id\n  const sourceId = glFeature.source\n  const glSource = glGetSource(sourceId)\n  const promise = new Promise((resolve, reject) => {\n    glSource.getClusterExpansionZoom(clusterId, (err1, zoom) => {\n      glSource.getClusterLeaves(clusterId, 99, 0, (err2, children) => {\n        if (err1 || err2) {\n          reject()\n        }\n        const childrenFeatures = children.map((child) =>\n          getFeature(child, glFeature.layer.id, glSource)\n        )\n        resolve({\n          zoom,\n          childrenFeatures,\n        })\n      })\n    })\n  })\n  return promise\n}\n\nconst getFeature = (glFeature, layerId, source) => {\n  const feature = {\n    properties: glFeature.properties,\n  }\n  const fields = getFields(glFeature, source)\n  feature.fields = fields\n\n  // Get most likely feature title\n  const mainField = fields.find((f) => f.isMain === true)\n  feature.title = mainField === undefined ? layerId : mainField.value\n\n  return feature\n}\n\nexport const mapInteraction = (interactionType, latitude, longitude, glFeatures, glGetSource) => (\n  dispatch,\n  getState\n) => {\n  if (interactionType === 'click') {\n    dispatch(clearHighlightedClickedVessel())\n  }\n\n  const currentStyle = getState().map.style.mapStyle.toJS()\n\n  const event = {\n    latitude,\n    longitude,\n    features: [],\n  }\n\n  // Collect and normalize features on legacy heatmap\n  const currentLegacyHeatmapData = getState().map.heatmap.highlightedVessels\n  let legacyHeatmapFeature\n\n  if (currentLegacyHeatmapData.isEmpty !== true) {\n    const foundVessels =\n      currentLegacyHeatmapData.foundVessels === undefined\n        ? []\n        : currentLegacyHeatmapData.foundVessels\n    const properties = foundVessels.length === 0 ? [] : foundVessels[0]\n    const isCluster = currentLegacyHeatmapData.clickableCluster === true\n    const count =\n      isCluster === true && currentLegacyHeatmapData.highlightableCluster === false\n        ? -1\n        : foundVessels.length\n    legacyHeatmapFeature = {\n      isCluster,\n      count,\n      layer: {\n        id: currentLegacyHeatmapData.layer.id,\n        group: 'legacyHeatmap',\n      },\n      properties,\n    }\n    event.features.push(legacyHeatmapFeature)\n  }\n\n  // Try to retrieve 'gfw:id' (generated when instanciating CARTO layer to preserve original style.json id)\n  // In most cases it won't exist, so fall back to source id\n  const getStaticLayerIdFromGlFeature = (glFeature) =>\n    (glFeature.layer.metadata !== undefined && glFeature.layer.metadata['gfw:id']) ||\n    glFeature.layer.source\n\n  // Collect gl features\n  const clusterPromises = []\n  const allGlFeatures = glFeatures || []\n  allGlFeatures.forEach((glFeature) => {\n    const layerId = getStaticLayerIdFromGlFeature(glFeature)\n    const source = currentStyle.sources[layerId]\n    const feature = {\n      layer: {\n        id: layerId,\n        group: glFeature.layer.metadata && glFeature.layer.metadata['mapbox:group'],\n      },\n      ...getFeature(glFeature, layerId, source),\n    }\n\n    if (glFeature.properties.cluster === true) {\n      // lookup for cluster\n      const clusterPromise = getCluster(glFeature, glGetSource).then((cluster) => {\n        feature.cluster = cluster\n        feature.count = cluster.childrenFeatures.length\n      })\n      clusterPromises.push(clusterPromise)\n      feature.isCluster = true\n    } else {\n      feature.isCluster = false\n    }\n    event.features.push(feature)\n  })\n\n  Promise.all(clusterPromises).then(() => {\n    // The whole set of features is considered a cluster\n    // if any feature is a cluster, or there is more than one feature\n    event.isCluster =\n      event.features.length > 1 || event.features.some((feature) => feature.isCluster === true)\n\n    // legacy heatmap layers can yield clusters with an unknown number of features, handle this here:\n    if (legacyHeatmapFeature !== undefined && legacyHeatmapFeature.count === -1) {\n      event.count = -1\n    } else {\n      event.count = event.features.reduce((count, feature) => {\n        let featureCount = feature.count || 1\n        return count + featureCount\n      }, 0)\n    }\n\n    if (event.count === 1) {\n      event.feature = event.features[0]\n    }\n\n    // When autoClusterZoom is set to true, we handle zoom here\n    const autoClusterZoom = getState().map.module.autoClusterZoom === true\n\n    // Check if cluster using customizable isCluster() callback\n    // If not set resolves simply to (event) => event.isCluster === true\n    const clusterBehavior = getState().map.module.isCluster(event)\n    event.isCluster = clusterBehavior\n\n    if (autoClusterZoom) {\n      if (interactionType === 'click' && event.isCluster === true) {\n        dispatch(clearHighlightedVessels())\n        const clusterZoom = event.features[0].cluster && event.features[0].cluster.zoom\n        dispatch(zoomIntoVesselCenter(latitude, longitude, clusterZoom))\n      }\n    }\n\n    let cursor = event.features.length ? 'pointer' : null\n    if (event.isCluster === true && autoClusterZoom === true) {\n      cursor = 'zoom-in'\n    }\n\n    dispatch({\n      type: SET_MAP_CURSOR,\n      payload: cursor,\n    })\n\n    const callback =\n      interactionType === 'click' ? getState().map.module.onClick : getState().map.module.onHover\n\n    if (callback !== undefined) {\n      callback(event)\n    }\n  })\n}\n","const RGB_MAX = 255\nconst HUE_MAX = 360\nconst SV_MAX = 100\n\nexport const VESSELS_HUES_INCREMENTS_NUM = 31 // 360 / VESSELS_HUES_INCREMENTS_NUM - 1  should give a round number\nexport const VESSELS_HUES_INCREMENT = 360 / (VESSELS_HUES_INCREMENTS_NUM - 1)\n\n// Legacy: this is only here for compatibility with pre-mapbox branch workspaces\nexport const COLOR_HUES = {\n  orange: 0,\n  peach: 22,\n  yellow: 60,\n  green: 85,\n  brightGreen: 145,\n  lightBlue: 182,\n  blue: 236,\n  purple: 284,\n  pink: 312,\n}\n\n// FIXME mark explicitely as legacy. Check all usages.\nexport const getKeyByValue = (obj, value) => {\n  let result = null\n  Object.entries(obj).forEach((entry) => {\n    if (entry[1] === value) result = entry[0]\n  })\n  return result\n}\n\n/**\n * Converts an RGB color value to HSV. Conversion formula\n * adapted from http://en.wikipedia.org/wiki/HSV_color_space.\n * Assumes r, g, and b are contained in the set [0, 255] and\n * returns h, s, and v in the set [0, 1].\n *\n * @param   Number  r       The red color value\n * @param   Number  g       The green color value\n * @param   Number  b       The blue color value\n * @return  Array           The HSV representation\n */\nexport const rgbToHsv = (_r, _g, _b) => {\n  const r = _r / 255\n  const g = _g / 255\n  const b = _b / 255\n\n  const max = Math.max(r, g, b)\n  const min = Math.min(r, g, b)\n  let h\n  const v = max\n\n  const d = max - min\n  const s = max === 0 ? 0 : d / max\n\n  if (max === min) {\n    h = 0 // achromatic\n  } else {\n    switch (max) {\n      case r:\n        h = (g - b) / d + (g < b ? 6 : 0)\n        break\n      case g:\n        h = (b - r) / d + 2\n        break\n      case b:\n        h = (r - g) / d + 4\n        break\n      default:\n        h = 0\n    }\n\n    h /= 6\n  }\n\n  return [h, s, v]\n}\n\n// converts hue, saturation, luminance to an rgb object\nexport const hsvToRgb = (h_, s_, v_) => {\n  const h = ((h_ % HUE_MAX) / parseFloat(HUE_MAX)) * 6\n  const s = s_ === SV_MAX ? 1 : (s_ % SV_MAX) / parseFloat(SV_MAX)\n  const v = v_ === SV_MAX ? 1 : (v_ % SV_MAX) / parseFloat(SV_MAX)\n\n  const i = Math.floor(h)\n  const f = h - i\n  const p = v * (1 - s)\n  const q = v * (1 - f * s)\n  const t = v * (1 - (1 - f) * s)\n  const mod = i % 6\n  const r = [v, q, p, p, t, v][mod]\n  const g = [t, v, v, q, p, p][mod]\n  const b = [p, p, t, v, v, q][mod]\n\n  return { r: Math.round(r * RGB_MAX), g: Math.round(g * RGB_MAX), b: Math.round(b * RGB_MAX) }\n}\n\n// returns an rgb string with default saturation and luminance values\nconst hueToRgbDefaults = (hue) => hsvToRgb(hue, 50, 100)\n\nexport const hueToRgbString = (hue) => {\n  const rgb = hueToRgbDefaults(hue)\n  return `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`\n}\n\nexport const rgbToHexString = (rgb, css) => {\n  const str = ['r', 'g', 'b']\n    .map((channelName) => {\n      const channelValue = rgb[channelName]\n      let channelStr = channelValue.toString(16)\n      if (channelValue < 16) {\n        channelStr = `0${channelStr}`\n      }\n      return channelStr\n    })\n    .join('')\n  const prefix = css === true ? '#' : '0x'\n  return `${prefix}${str}`\n}\n\nexport const hueToRgbHexString = (hue, css) => {\n  const rgb = hueToRgbDefaults(hue)\n  return rgbToHexString(rgb, css)\n}\n\nconst closestNumber = (numberArray, goal) =>\n  numberArray.reduce((prev, curr) => (Math.abs(curr - goal) < Math.abs(prev - goal) ? curr : prev))\n\nexport const hueToClosestColor = (hue) => {\n  if (hue === undefined || hue === null) return undefined\n  const colorHueValues = Object.keys(COLOR_HUES).map((key) => COLOR_HUES[key])\n  const closestHue = closestNumber(colorHueValues, hue)\n  return getKeyByValue(COLOR_HUES, closestHue)\n}\n\nexport const hexToRgb = (hex) => {\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex)\n  return result\n    ? {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16),\n      }\n    : null\n}\n\nconst rgbToRgbaString = (rgb, opacity) => `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`\n\nexport const hueToRgbaString = (hue, opacity) => {\n  const rgb = hueToRgbDefaults(hue)\n  return rgbToRgbaString(rgb, opacity)\n}\n\nexport const hexToRgba = (hex, opacity) => {\n  const rgb = hexToRgb(hex)\n  return rgbToRgbaString(rgb, opacity)\n}\n\nexport const hueIncrementToHue = (hueIncrement) => hueIncrement * VESSELS_HUES_INCREMENT\n\nexport const hueToHueIncrement = (hue) =>\n  Math.round((hue / 360) * (VESSELS_HUES_INCREMENTS_NUM - 1))\n\nexport const wrapHue = (hue) => hue % 360\n\nexport const hueOrColorToHexColor = (color, hue) => {\n  if (hue !== undefined) {\n    return hueToRgbHexString(hue, true)\n  }\n\n  return color\n}\n","/* global PIXI */\nimport 'pixi.js'\nimport { hueToHueIncrement, VESSELS_HUES_INCREMENTS_NUM } from '../utils/map-colors'\nimport { VESSELS_BASE_RADIUS, MAX_SPRITES_PER_LAYER } from '../config'\n\nexport default class HeatmapSubLayer {\n  constructor(baseTexture, renderingStyleIndex, hue, useNormalBlendMode = false) {\n    // this.stage = new PIXI.Container();\n    // the ParticleContainer is a faster version of the PIXI sprite container\n    this.stage = new PIXI.particles.ParticleContainer(MAX_SPRITES_PER_LAYER, {\n      scale: true,\n      alpha: true,\n      position: true,\n      uvs: true,\n    })\n    if (useNormalBlendMode === false) {\n      this.stage.blendMode = PIXI.BLEND_MODES.SCREEN\n    }\n\n    this.spritesPool = []\n\n    const initialTextureFrame = new PIXI.Rectangle(\n      0,\n      0,\n      VESSELS_BASE_RADIUS * 2,\n      VESSELS_BASE_RADIUS * 2\n    )\n    this.mainVesselTexture = new PIXI.Texture(baseTexture, initialTextureFrame)\n    this._setTextureFrame(renderingStyleIndex, hue)\n\n    this.clearSpriteProps()\n  }\n\n  clearSpriteProps() {\n    this.spritesProps = {\n      x: new Float32Array(MAX_SPRITES_PER_LAYER),\n      y: new Float32Array(MAX_SPRITES_PER_LAYER),\n      a: new Float32Array(MAX_SPRITES_PER_LAYER),\n      s: new Float32Array(MAX_SPRITES_PER_LAYER),\n    }\n    this.spritesPropsCount = 0\n  }\n\n  pushSpriteProps(x, y, a, s) {\n    this.spritesProps.x[this.spritesPropsCount] = x\n    this.spritesProps.y[this.spritesPropsCount] = y\n    this.spritesProps.a[this.spritesPropsCount] = a\n    this.spritesProps.s[this.spritesPropsCount] = s\n    this.spritesPropsCount++\n  }\n\n  setRenderingStyleIndex(renderingStyleIndex) {\n    this._setTextureFrame(renderingStyleIndex)\n  }\n\n  destroy() {\n    this.spritesPool = null\n    this.stage.destroy({ children: true })\n  }\n\n  /**\n   * Updates the main texture frame offset to show different brush styles and hues\n   * Both args are optional, if one is omitted, previous value is used\n   * @heatmapStyle bool whether to use heatmap style or solid circle style\n   * @hue number hue value between 0 and 360\n   */\n  _setTextureFrame(renderingStyleIndex = null, hue = null) {\n    const textureFrame = this.mainVesselTexture.frame.clone()\n\n    if (renderingStyleIndex !== null) {\n      // one diameter + tiny offset between 2 frames\n      textureFrame.x = VESSELS_BASE_RADIUS * 2 * renderingStyleIndex + renderingStyleIndex\n    }\n\n    if (hue !== null) {\n      let hueIncrement = hueToHueIncrement(hue)\n      if (hueIncrement === VESSELS_HUES_INCREMENTS_NUM - 1) {\n        hueIncrement = 0\n      }\n      textureFrame.y = hueIncrement * VESSELS_BASE_RADIUS * 2\n      if (hueIncrement > 0) {\n        textureFrame.y += hueIncrement\n      }\n    }\n\n    this.mainVesselTexture.frame = textureFrame\n    this.mainVesselTexture.update()\n  }\n\n  render() {\n    const numProps = this.spritesPropsCount\n    this.resizeSpritesPool()\n\n    for (let i = 0; i < numProps; i++) {\n      const sprite = this.stage.children[i]\n      const s = this.spritesProps.s[i]\n      sprite.setTransform(this.spritesProps.x[i], this.spritesProps.y[i], s, s)\n      sprite.alpha = this.spritesProps.a[i]\n    }\n\n    const numSprites = this.stage.children.length\n    for (let i = numProps; i < numSprites; i++) {\n      const sprite = this.stage.children[i]\n      sprite.x = -100\n    }\n  }\n\n  resizeSpritesPool() {\n    const numProps = this.spritesPropsCount\n    const prevNumSprites = this.stage.children.length\n    const delta = numProps - prevNumSprites\n    // console.log(prevNumSprites, '->', numProps, ' delta:', delta);\n\n    if (delta < -4999) {\n      // sprite needs to be removed. Do that progressively (max 100) to avoid UI lock\n      const toRemove = Math.min(100, -delta)\n      // console.log('removing ', toRemove);\n      for (let i = 0; i < toRemove; i++) {\n        this.stage.removeChildAt(0)\n      }\n    }\n\n    if (delta > 0) {\n      const toAdd = Math.max(5000, delta)\n      // console.log('adding ', toAdd);\n      this._addSprites(toAdd)\n    }\n  }\n\n  _addSprites(num) {\n    for (let i = 0; i < num; i++) {\n      const vessel = new PIXI.Sprite(this.mainVesselTexture)\n      vessel.anchor.x = 0.5\n      vessel.anchor.y = 0.5\n      // ParticlesContainer does not support .visible, so we just move the sprite out of the viewport\n      vessel.x = -100\n      // vessel.blendMode = PIXI.BLEND_MODES.SCREEN;\n      // vessel.filters=  [new PIXI.filters.BlurFilter(10,10)]\n      this.stage.addChild(vessel)\n    }\n  }\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport uniq from 'lodash/uniq'\nimport * as PIXI from 'pixi.js'\nimport { worldToPixels } from 'viewport-mercator-project'\nimport { BRUSH_RENDERING_STYLE, BRUSH_ZOOM_RENDERING_STYLE } from '../constants'\nimport { vesselSatisfiesFilters } from '../utils/heatmapTileData'\nimport HeatmapSubLayer from './HeatmapSubLayer'\n\n// This is a faster version of worldToPixels that omits pitch,\n// and ignores values from the matrix that are consistently = 0\nconst s = 1 / 1.5\nconst worldToPixelsSimple = (x, y, m) => {\n  const fx = s * (m[0] * x + m[4] * y + m[12])\n  const fy = s * (m[5] * y + m[13])\n  return [fx, fy]\n}\n\nclass HeatmapLayer extends React.Component {\n  componentDidMount() {\n    this._build()\n  }\n\n  componentWillUnmount() {\n    this._destroy()\n  }\n\n  componentDidUpdate() {\n    this._redraw()\n  }\n\n  componentWillReceiveProps(nextProps) {\n    if (nextProps.useRadialGradientStyle !== this.props.useRadialGradientStyle) {\n      this.setBrushZoomRenderingStyle(nextProps.useRadialGradientStyle)\n    }\n  }\n\n  _build() {\n    const { layer, rootStage, useRadialGradientStyle, customRenderingStyle } = this.props\n    this.subLayers = {}\n    this.renderingStyle =\n      layer.header && layer.header.rendering ? layer.header.rendering : customRenderingStyle\n\n    this.setBrushRenderingStyle(this.renderingStyle.style)\n    this.setBrushZoomRenderingStyle(useRadialGradientStyle)\n\n    this.stage = new PIXI.Container()\n\n    rootStage.addChild(this.stage)\n  }\n\n  setBrushRenderingStyle(style = BRUSH_RENDERING_STYLE.NORMAL) {\n    if (typeof style === 'string') {\n      this.brushRenderingStyle = BRUSH_RENDERING_STYLE[style.toUpperCase()]\n    } else {\n      this.brushRenderingStyle = style\n    }\n    this._setBrushRenderingStyleIndex()\n  }\n\n  setBrushZoomRenderingStyle(useRadialGradientStyle) {\n    this.brushZoomRenderingStyle =\n      useRadialGradientStyle === true\n        ? BRUSH_ZOOM_RENDERING_STYLE.RADIAL_GRADIENT\n        : BRUSH_ZOOM_RENDERING_STYLE.CIRCLE\n    this._setBrushRenderingStyleIndex()\n  }\n\n  _setBrushRenderingStyleIndex() {\n    // only NORMAL brush styles support different zoom styles\n    const cappedZoomRenderingStyle =\n      this.brushRenderingStyle === BRUSH_RENDERING_STYLE.NORMAL ? this.brushZoomRenderingStyle : 0\n    const newStyleIndex = this.brushRenderingStyle + cappedZoomRenderingStyle\n    if (newStyleIndex === this.renderingStyleIndex) {\n      return\n    }\n    this.renderingStyleIndex = newStyleIndex\n    Object.values(this.subLayers).forEach((subLayer) => {\n      subLayer.setRenderingStyleIndex(this.renderingStyleIndex)\n    })\n  }\n\n  _redraw() {\n    const { filters, baseTexture, layer } = this.props\n\n    if (\n      layer === null ||\n      layer === undefined ||\n      layer.tiles === undefined ||\n      layer.visible === false\n    ) {\n      this.stage.visible = false\n      return\n    }\n\n    this.stage.visible = true\n    this.stage.alpha = layer.opacity\n\n    const tiles = layer.tiles\n    const defaultHue = layer.hue\n    const allHuesToRender =\n      filters !== undefined && filters.length\n        ? filters\n            // pass is set to true by filterGroupActions when none of the filters fields\n            // in the filter group is supported by the layer headers\n            .filter((f) => f.pass !== true)\n            .map((f) => (f.hue === undefined ? '0' : f.hue.toString()))\n        : [defaultHue.toString()]\n    const currentlyUsedHues = Object.keys(this.subLayers)\n\n    // get all hues, old and new\n    const allHues = uniq(allHuesToRender.concat(currentlyUsedHues))\n\n    for (let i = 0; i < allHues.length; i++) {\n      const hue = allHues[i]\n      if (allHuesToRender.indexOf(hue) === -1) {\n        // not on new hues: delete sublayer\n        this._destroySubLayer(this.subLayers[hue])\n        delete this.subLayers[hue]\n        continue\n      }\n      if (currentlyUsedHues.indexOf(hue) === -1) {\n        // not on old hues: create sublayer\n        this.subLayers[hue] = this._createSublayer(baseTexture, this.renderingStyleIndex, hue)\n      }\n      this.subLayers[hue].clearSpriteProps()\n    }\n\n    if (!allHuesToRender.length) return\n    tiles.forEach((tile) => {\n      this._setSubLayersSpritePropsForTile({\n        data: tile.data,\n        numFilters: filters.length,\n        defaultHue,\n      })\n    })\n\n    allHuesToRender.forEach((hueToRender) => {\n      this.subLayers[hueToRender].render()\n    })\n  }\n\n  _setSubLayersSpritePropsForTile({ data, numFilters, defaultHue }) {\n    if (!data) {\n      return\n    }\n\n    const { startIndex, endIndex, viewport, filters, viewportLeft, viewportRight } = this.props\n\n    for (let timeIndex = startIndex; timeIndex < endIndex; timeIndex++) {\n      const frame = data[timeIndex]\n\n      if (!frame) continue\n\n      for (let index = 0, len = frame.worldX.length; index < len; index++) {\n        let hue\n        if (filters === undefined || !filters.length) {\n          hue = defaultHue\n        }\n        for (let fi = 0; fi < numFilters; fi++) {\n          const filter = filters[fi]\n          if (vesselSatisfiesFilters(frame, index, filter.filterValues)) {\n            hue = filter.hue\n            break\n          }\n        }\n\n        // no filter passes: bail\n        if (hue === undefined) {\n          continue\n        }\n\n        // wrap worldX when point crosses the antimeridian/dateline\n        // world points go from 0 to 512. There is no way to determine if worldX is on the \"wrong\" side\n        // of the antimeridian just by looking at its value (where with lat/lon we can simply look at -/+)\n        // Therefore we compare it to the viewport's left or right boundary, depending on what is currently\n        // \"the right side\" of the antimeridian\n        let worldX = frame.worldX[index]\n        if (viewportLeft > 0 && worldX < viewportLeft) {\n          // worldX is \"behind\" viewportLeft, which means it is \"on the right\" of the antimeridian\n          worldX += 512\n        } else if (viewportLeft < 0 && worldX > viewportRight) {\n          worldX -= 512\n        }\n\n        const scaledX = worldX * viewport.scale\n        const scaledY = frame.worldY[index] * viewport.scale\n        const mtx = viewport.pixelProjectionMatrix\n\n        const [x, y] =\n          viewport.pitch === 0\n            ? worldToPixelsSimple(scaledX, scaledY, mtx)\n            : worldToPixels([scaledX, scaledY], mtx)\n\n        if (x > -10 && x < viewport.width + 10 && y > -10 && y < viewport.height + 10) {\n          this.subLayers[hue].pushSpriteProps(\n            x,\n            y,\n            frame.opacity ? frame.opacity[index] : this.renderingStyle.defaultOpacity,\n            frame.radius ? frame.radius[index] : this.renderingStyle.defaultSize\n          )\n        }\n      }\n    }\n  }\n\n  _createSublayer(baseTexture, renderingStyleIndex, hue) {\n    const subLayer = new HeatmapSubLayer(\n      baseTexture,\n      renderingStyleIndex,\n      hue,\n      this.brushRenderingStyle === BRUSH_RENDERING_STYLE.BULLSEYE\n    )\n    this.stage.addChild(subLayer.stage)\n    return subLayer\n  }\n\n  _destroy() {\n    Object.values(this.subLayers).forEach(this._destroySubLayer.bind(this))\n    this.stage.destroy({ children: true })\n    const { rootStage } = this.props\n    rootStage.removeChild(this.stage)\n  }\n\n  _destroySubLayer(subLayer) {\n    this.stage.removeChild(subLayer.stage)\n    subLayer.destroy()\n  }\n\n  render() {\n    return null\n  }\n}\n\nHeatmapLayer.propTypes = {\n  layer: PropTypes.object,\n  rootStage: PropTypes.object,\n  viewport: PropTypes.object,\n  startIndex: PropTypes.number,\n  endIndex: PropTypes.number,\n  filters: PropTypes.array,\n  baseTexture: PropTypes.object,\n  useRadialGradientStyle: PropTypes.bool,\n  customRenderingStyle: PropTypes.object,\n  viewportLeft: PropTypes.number,\n  viewportRight: PropTypes.number,\n}\n\nexport default HeatmapLayer\n","/* global PIXI */\nimport 'pixi.js'\nimport React from 'react'\nimport PropTypes from 'prop-types'\nimport { worldToPixels } from 'viewport-mercator-project'\nimport { TRACKS_DOTS_STYLE_ZOOM_THRESHOLD } from '../config'\n\nclass TracksLayer extends React.Component {\n  componentDidMount() {\n    this._build()\n  }\n\n  componentDidUpdate() {\n    this._redraw()\n  }\n\n  _build() {\n    const { rootStage } = this.props\n    this.stage = new PIXI.Graphics()\n    this.stage.nativeLines = true\n    rootStage.addChild(this.stage)\n  }\n\n  clear() {\n    this.stage.clear()\n  }\n\n  _redraw() {\n    const { tracks, zoom, startIndex, endIndex, highlightTemporalExtentIndexes } = this.props\n\n    this.clear()\n    if (!tracks.length) {\n      return\n    }\n\n    const overInInner =\n      highlightTemporalExtentIndexes === null\n        ? undefined\n        : [\n            Math.max(startIndex, highlightTemporalExtentIndexes[0]),\n            Math.min(endIndex, highlightTemporalExtentIndexes[1]),\n          ]\n    const overExtent = overInInner && overInInner[1] - overInInner[0] > 0 ? overInInner : undefined\n\n    let n = 0 // eslint-disable-line no-unused-vars\n\n    const drawFishingCircles = zoom > TRACKS_DOTS_STYLE_ZOOM_THRESHOLD\n    const fishingCirclesRadius = 1 + (zoom - TRACKS_DOTS_STYLE_ZOOM_THRESHOLD) * 0.5\n    const drawOverTrack = overExtent !== undefined && overExtent[0] > 0 && overExtent[1] > 0\n\n    tracks.forEach((track) => {\n      n += this._drawTrack({\n        data: track.data,\n        startIndex,\n        endIndex,\n        drawFishingCircles,\n        fishingCirclesRadius,\n        color: `0x${track.color.substr(1)}`,\n        lineThickness: 1,\n        lineOpacity: 1,\n      })\n\n      // Draw the highlight over the track when the user hovers over the Timebar\n      if (drawOverTrack === true) {\n        n += this._drawTrack({\n          data: track.data,\n          startIndex: highlightTemporalExtentIndexes[0],\n          endIndex: highlightTemporalExtentIndexes[1],\n          drawFishingCircles,\n          fishingCirclesRadius,\n          color: '0xFFFFFF',\n          lineThickness: 2,\n          lineOpacity: 1,\n        })\n      }\n    })\n\n    // console.log(n);\n  }\n\n  /**\n   * Draws a single track (line + points)\n   *\n   * @param data track points data in 'playback form' (ie organized by days)\n   * @param extent extent, in day indices\n   * @param offset object containing info about the current situation of the map viewport, used to compute screen coords\n   * @param drawFishingCircles whether to draw fishing circles or not\n   * @param fishingCirclesRadius radius of the fishing circles\n   * @param color\n   * @param lineThickness\n   * @param lineOpacity\n   * @param worldOffset offset to use when a track crosses the dateline (ie 512 to add a second world to the right)\n   */\n  _drawTrack({\n    data,\n    startIndex,\n    endIndex,\n    drawFishingCircles,\n    fishingCirclesRadius,\n    color,\n    lineThickness,\n    lineOpacity,\n    worldOffset = 0,\n  }) {\n    const { viewport } = this.props\n\n    let n = 0\n    let prevSeries\n    let prevWorldX\n    let prevWorldY\n\n    const circlePoints = {\n      x: [],\n      y: [],\n    }\n\n    // line thickness is ignored in native mode anyways.\n    this.stage.lineStyle(lineThickness, color, lineOpacity)\n\n    let duplicateWorld = false\n\n    for (let timeIndex = startIndex; timeIndex < endIndex; timeIndex++) {\n      const frame = data[timeIndex]\n\n      if (!frame) continue\n\n      for (let i = 0, len = frame.series.length; i < len; i++) {\n        const currentSeries = frame.series[i]\n\n        n++\n\n        const worldX = frame.worldX[i] + worldOffset\n        const worldY = frame.worldY[i]\n\n        const [x, y] = worldToPixels(\n          [worldX * viewport.scale, worldY * viewport.scale],\n          viewport.pixelProjectionMatrix\n        )\n\n        if (prevSeries !== currentSeries) {\n          this.stage.moveTo(x, y)\n        }\n\n        // more than a  world of distance between two points = crossing the dateline\n        if (prevWorldX && Math.abs(worldX - prevWorldX) > 256) {\n          // worldOffset === 0 -> this is the first time drawTrack is called\n          if (worldOffset === 0) {\n            // set a flag to call drawTrack again at the end of the loop\n            duplicateWorld = true\n          }\n\n          // get Y coordinate where track intersects with dateline\n          const atDatelineWorldY = prevWorldY + (worldY - prevWorldY) / 2\n\n          // whether tracks crosses dateline from west to east\n          const isWestToEast = worldX - prevWorldX < 0\n\n          const worldXEnd = worldOffset + (512 - 0.000001)\n          const worldXStart = worldOffset\n\n          // get X coordinate ending at dateline\n          const atDatelineEndWorldX = isWestToEast ? worldXEnd : worldXStart\n\n          // get X coordinate starting at dateline\n          const atDatelineStartWorldX = isWestToEast ? worldXStart : worldXEnd\n\n          const [x1, y1] = worldToPixels(\n            [atDatelineEndWorldX * viewport.scale, atDatelineWorldY * viewport.scale],\n            viewport.pixelProjectionMatrix\n          )\n          this.stage.lineTo(x1, y1)\n          const [x2, y2] = worldToPixels(\n            [atDatelineStartWorldX * viewport.scale, atDatelineWorldY * viewport.scale],\n            viewport.pixelProjectionMatrix\n          )\n          this.stage.moveTo(x2, y2)\n        }\n\n        this.stage.lineTo(x, y)\n\n        if (drawFishingCircles && frame.hasFishing[i] === true) {\n          circlePoints.x.push(x)\n          circlePoints.y.push(y)\n        }\n\n        prevWorldX = worldX\n        prevWorldY = worldY\n        prevSeries = currentSeries\n      }\n    }\n\n    if (drawFishingCircles) {\n      this.stage.lineStyle(0)\n      this.stage.beginFill(color, 1)\n      for (let i = 0, circlesLength = circlePoints.x.length; i < circlesLength; i++) {\n        this.stage.drawCircle(circlePoints.x[i], circlePoints.y[i], fishingCirclesRadius)\n      }\n      this.stage.endFill()\n    }\n\n    if (duplicateWorld === true) {\n      ;[-512, 512].forEach((offset) => {\n        this._drawTrack({\n          worldOffset: offset,\n          data,\n          startIndex,\n          endIndex,\n          drawFishingCircles,\n          fishingCirclesRadius,\n          color,\n          lineThickness,\n          lineOpacity,\n        })\n      })\n    }\n    return n\n  }\n\n  render() {\n    return null\n  }\n}\n\nTracksLayer.propTypes = {\n  zoom: PropTypes.number,\n  rootStage: PropTypes.object,\n  viewport: PropTypes.object,\n  startIndex: PropTypes.number,\n  endIndex: PropTypes.number,\n  highlightTemporalExtentIndexes: PropTypes.array,\n  tracks: PropTypes.array,\n}\n\nexport default TracksLayer\n","import React, { Fragment } from 'react'\nimport * as PIXI from 'pixi.js'\nimport PropTypes from 'prop-types'\nimport { BaseControl } from 'react-map-gl'\nimport { lngLatToWorld } from 'viewport-mercator-project'\nimport {\n  hsvToRgb,\n  hueToRgbString,\n  hueIncrementToHue,\n  wrapHue,\n  VESSELS_HUES_INCREMENTS_NUM,\n} from '../utils/map-colors'\nimport {\n  VESSELS_BASE_RADIUS,\n  VESSELS_HEATMAP_BLUR_FACTOR,\n  ACTIVITY_HIGHLIGHT_HUE,\n  VESSELS_HEATMAP_DIMMING_ALPHA,\n  VESSELS_RADIAL_GRADIENT_STYLE_ZOOM_THRESHOLD,\n  VESSEL_CLICK_TOLERANCE_PX,\n} from '../config'\nimport HeatmapLayer from '../heatmap/HeatmapLayer'\nimport TracksLayer from '../tracks/TracksLayer'\n\nconst shouldUseRadialGradientStyle = (zoom) => zoom < VESSELS_RADIAL_GRADIENT_STYLE_ZOOM_THRESHOLD\n\n// builds a texture spritesheet containing\n// - the heatmap style (radial gradient)\n// - the circle style that is used at higher zoom levels\n// - the 'bullseye' style used for encounters\n// as well as a number of hues for each in a 2D grid.\n// Then, only the texture frame (mesh UVs) is modified depending on the zoom level,\n// in order not to have to recreate sprites\nconst getVesselTexture = (radius, blurFactor) => {\n  const tplCanvas = document.createElement('canvas')\n  const tplCtx = tplCanvas.getContext('2d')\n  const diameter = radius * 2\n  const NUM_STYLES = 3\n  tplCanvas.width = diameter * NUM_STYLES + (NUM_STYLES - 1) // + (NUM_STYLES - 1): tiny offset between 2 frames\n  tplCanvas.height = diameter * VESSELS_HUES_INCREMENTS_NUM + VESSELS_HUES_INCREMENTS_NUM\n\n  for (let hueIncrement = 0; hueIncrement < VESSELS_HUES_INCREMENTS_NUM; hueIncrement++) {\n    const y = diameter * hueIncrement + hueIncrement\n    const yCenter = y + radius\n\n    // heatmap style\n    let x = radius\n    const gradient = tplCtx.createRadialGradient(\n      x,\n      yCenter,\n      radius * blurFactor,\n      x,\n      yCenter,\n      radius\n    )\n    const hue = hueIncrementToHue(hueIncrement)\n    const rgbString = hueToRgbString(hue)\n    gradient.addColorStop(0, rgbString)\n\n    const rgbOuter = hsvToRgb(wrapHue(hue + 30), 80, 100)\n    gradient.addColorStop(1, `rgba(${rgbOuter.r}, ${rgbOuter.g}, ${rgbOuter.b}, 0)`)\n\n    tplCtx.fillStyle = gradient\n    tplCtx.fillRect(0, y, diameter, diameter)\n\n    // circle style\n    x += diameter + 1 // tiny offset between 2 frames\n    tplCtx.beginPath()\n    tplCtx.arc(x, yCenter, radius, 0, 2 * Math.PI, false)\n    tplCtx.fillStyle = rgbString\n    tplCtx.fill()\n\n    // bullseye style\n    x += diameter + 1\n    tplCtx.beginPath()\n    tplCtx.arc(x, yCenter, radius * 0.4, 0, 2 * Math.PI, false)\n    tplCtx.fillStyle = rgbString\n    tplCtx.fill()\n    tplCtx.beginPath()\n    tplCtx.arc(x, yCenter, radius * 0.95, 0, 2 * Math.PI, false)\n    tplCtx.lineWidth = 1\n    tplCtx.strokeStyle = rgbString\n    tplCtx.stroke()\n  }\n\n  return tplCanvas\n}\n\nclass ActivityLayers extends BaseControl {\n  state = {\n    pixiReady: false,\n  }\n\n  componentDidMount() {\n    this._build()\n    this.setState({\n      pixiReady: true,\n    })\n  }\n\n  componentWillUnmount() {\n    this._destroy()\n  }\n\n  componentWillReceiveProps(nextProps) {\n    this.props.exportNativeViewport(this._context.viewport)\n\n    if (\n      nextProps.viewport.width !== this.props.viewport.width ||\n      nextProps.viewport.height !== this.props.viewport.height\n    ) {\n      this._updateViewportSize(nextProps.viewport.width, nextProps.viewport.height)\n    }\n  }\n\n  _build() {\n    const { width, height } = this.props.viewport\n\n    this.pixi = new PIXI.Application({\n      width,\n      height,\n      transparent: true,\n      antialias: true,\n    })\n\n    this.renderer = this.pixi.renderer\n    this.canvas = this.pixi.view\n    this.canvas.style.position = 'absolute'\n\n    this.container.appendChild(this.canvas)\n\n    this.stage = this.pixi.stage\n\n    const baseTextureCanvas = getVesselTexture(VESSELS_BASE_RADIUS, VESSELS_HEATMAP_BLUR_FACTOR)\n    this.baseTexture = PIXI.Texture.fromCanvas(baseTextureCanvas)\n\n    this.heatmapStage = new PIXI.Container()\n    this.stage.addChild(this.heatmapStage)\n\n    this.pixi.ticker.add(this._onTick)\n  }\n\n  _destroy() {\n    this.pixi.destroy()\n  }\n\n  _updateViewportSize(viewportWidth, viewportHeight) {\n    this.renderer.resize(viewportWidth, viewportHeight)\n  }\n\n  toggleHeatmapDimming(dim) {\n    if (this.heatmapStage === undefined) {\n      return\n    }\n    if (dim === true) {\n      this.heatmapFadingIn = false\n    }\n    this.heatmapStage.alpha = dim === true ? VESSELS_HEATMAP_DIMMING_ALPHA : 1\n  }\n\n  onTouchStart = (event) => {\n    if (!event.touches.length) {\n      return\n    }\n    this.queryCoords(event.touches[0].clientX, event.touches[0].clientY)\n  }\n\n  onMouseMove = (event) => {\n    this.queryCoords(event.clientX, event.clientY)\n  }\n\n  queryCoords(x, y) {\n    // bail if all heatmap layers are set to non-interactive\n    if (this.props.heatmapLayers.every((l) => l.interactive !== true)) {\n      return\n    }\n\n    const { viewport } = this._context\n    const [longitude, latitude] = viewport.unproject([x, y])\n\n    let wrappedLongitude = longitude\n    if (wrappedLongitude > 180) {\n      wrappedLongitude -= 360\n    } else if (wrappedLongitude < -180) {\n      wrappedLongitude += 360\n    }\n\n    const [worldX, worldY] = lngLatToWorld([wrappedLongitude, latitude], 1)\n\n    const toleranceRadiusInWorldUnits = VESSEL_CLICK_TOLERANCE_PX / viewport.scale\n\n    this.props.queryHeatmapVessels(\n      {\n        longitude: wrappedLongitude,\n        latitude,\n        worldX,\n        worldY,\n        toleranceRadiusInWorldUnits,\n      },\n      this.props.temporalExtentIndexes\n    )\n  }\n\n  _onTick = () => {\n    if (this.heatmapFadingIn === true && this.heatmapStage.alpha < 1) {\n      this._heatmapFadeinStep()\n    }\n  }\n\n  _startHeatmapFadein() {\n    this.heatmapFadingIn = true\n    this.heatmapFadeinStartTimestamp = undefined\n  }\n\n  _heatmapFadeinStep() {\n    if (this.heatmapFadeinStartTimestamp === undefined) {\n      this.heatmapFadeinStartTimestamp = Date.now()\n    }\n    const timeElapsed = (Date.now() - this.heatmapFadeinStartTimestamp) / 1000\n    let alpha = this.heatmapStage.alpha + (1 - this.heatmapStage.alpha) * timeElapsed\n    if (alpha >= 1) {\n      alpha = 1\n      this.heatmapFadingIn = false\n    }\n    this.heatmapStage.alpha = alpha\n  }\n\n  // FIXME move to container?\n  _getHighlightData(highlightedVessels, highlightedClickedVessel, heatmapLayers) {\n    const hue = ACTIVITY_HIGHLIGHT_HUE\n    let highlightLayerData = {\n      id: '__HIGHLIGHT__',\n      visible: true,\n      opacity: 1,\n      hue: ACTIVITY_HIGHLIGHT_HUE,\n    }\n    let highlightFilters = []\n\n    if (\n      highlightedVessels !== undefined &&\n      highlightedVessels.layer !== undefined &&\n      highlightedVessels.foundVessels !== undefined &&\n      highlightedVessels.isEmpty !== true\n    ) {\n      const sourceLayer = heatmapLayers.find((l) => l.id === highlightedVessels.layer.id)\n      highlightLayerData = { highlightLayerData, ...sourceLayer }\n      highlightFilters = highlightedVessels.foundVessels.map((vessel) => ({\n        hue,\n        filterValues: {\n          series: [vessel.series],\n        },\n      }))\n    } else if (highlightedClickedVessel !== null) {\n      const sourceLayer = heatmapLayers.find((l) => l.id === highlightedClickedVessel.layer.id)\n      highlightLayerData = { highlightLayerData, ...sourceLayer }\n      highlightFilters = [\n        {\n          hue,\n          filterValues: {\n            series: [highlightedClickedVessel.id],\n          },\n        },\n      ]\n    }\n    return {\n      highlightLayerData,\n      highlightFilters,\n    }\n  }\n  _render() {\n    const {\n      zoom,\n      heatmapLayers,\n      temporalExtentIndexes,\n      highlightTemporalExtentIndexes,\n      highlightedVessels,\n      highlightedClickedVessel,\n      tracks,\n      leftWorldScaled,\n      rightWorldScaled,\n    } = this.props\n    const { viewport } = this._context\n    const { pixiReady } = this.state\n\n    const startIndex = temporalExtentIndexes[0]\n    const endIndex = temporalExtentIndexes[1]\n    const useRadialGradientStyle = shouldUseRadialGradientStyle(zoom)\n\n    if (highlightedVessels.isEmpty !== true) {\n      this.toggleHeatmapDimming(true)\n    }\n    if (highlightedVessels.isEmpty === true && tracks.length === 0) {\n      this._startHeatmapFadein()\n    }\n    if (this.renderer && this.renderer.gl && this.renderer.gl.getError !== undefined) {\n      const err = this.renderer.gl.getError()\n      if (err !== 0) console.log(err)\n    }\n\n    const { highlightLayerData, highlightFilters } = this._getHighlightData(\n      highlightedVessels,\n      highlightedClickedVessel,\n      heatmapLayers\n    )\n\n    return (\n      <div\n        ref={(ref) => {\n          this.container = ref\n        }}\n        style={{ position: 'absolute' }}\n        onMouseMove={this.onMouseMove}\n        onTouchStart={this.onTouchStart}\n      >\n        {pixiReady === true && (\n          <Fragment>\n            {heatmapLayers.map((layer) => (\n              <HeatmapLayer\n                key={layer.id}\n                layer={layer}\n                filters={layer.filters || []}\n                viewport={viewport}\n                startIndex={startIndex}\n                endIndex={endIndex}\n                baseTexture={this.baseTexture}\n                rootStage={this.heatmapStage}\n                useRadialGradientStyle={useRadialGradientStyle}\n                customRenderingStyle={{}}\n                viewportLeft={leftWorldScaled}\n                viewportRight={rightWorldScaled}\n              />\n            ))}\n            {this.stage !== undefined && (\n              <HeatmapLayer\n                key=\"highlighted\"\n                layer={highlightLayerData}\n                filters={highlightFilters}\n                viewport={viewport}\n                startIndex={startIndex}\n                endIndex={endIndex}\n                baseTexture={this.baseTexture}\n                rootStage={this.heatmapStage}\n                useRadialGradientStyle={useRadialGradientStyle}\n                customRenderingStyle={{ defaultOpacity: 1, defaultSize: 1 }}\n                viewportLeft={leftWorldScaled}\n                viewportRight={rightWorldScaled}\n              />\n            )}\n            {this.stage !== undefined && (\n              <TracksLayer\n                tracks={tracks}\n                viewport={viewport}\n                zoom={zoom}\n                startIndex={startIndex}\n                endIndex={endIndex}\n                highlightTemporalExtentIndexes={highlightTemporalExtentIndexes}\n                rootStage={this.stage}\n              />\n            )}\n          </Fragment>\n        )}\n      </div>\n    )\n  }\n}\n\nActivityLayers.propTypes = {\n  zoom: PropTypes.number,\n  heatmapLayers: PropTypes.array,\n  temporalExtentIndexes: PropTypes.array,\n  highlightTemporalExtentIndexes: PropTypes.array,\n  highlightedVessels: PropTypes.object,\n  highlightedClickedVessel: PropTypes.object,\n  tracks: PropTypes.array,\n  queryHeatmapVessels: PropTypes.func,\n  exportNativeViewport: PropTypes.func,\n  leftWorldScaled: PropTypes.number,\n  rightWorldScaled: PropTypes.number,\n}\n\nActivityLayers.contextTypes = {\n  viewport: PropTypes.object,\n}\n\nexport default ActivityLayers\n","import { connect } from 'react-redux'\nimport { createSelector } from 'reselect'\nimport convert from '@globalfishingwatch/map-convert'\nimport { exportNativeViewport } from '../glmap/viewport.actions'\nimport { getTemporalExtent, getHighlightTemporalExtent } from '../module/module.selectors'\nimport ActivityLayers from './ActivityLayers'\nimport { queryHeatmapVessels } from '../heatmap/heatmapTiles.actions'\nimport { MIN_FRAME_LENGTH_MS } from '../config'\n\nconst getHeatmapLayers = (state) => state.map.heatmap.heatmapLayers\n\nconst getHeatmapLayersAsArray = createSelector(\n  [getHeatmapLayers],\n  (heatmapLayers) => {\n    const a = Object.keys(heatmapLayers).map((id) => ({\n      ...heatmapLayers[id],\n    }))\n    // console.log(a)\n    return a\n  }\n)\n\nconst getTracks = (state) => state.map.tracks.data\n\nconst getTracksWithData = createSelector(\n  [getTracks],\n  (tracks) => {\n    const tracksWithData = tracks\n      .filter((t) => t.type !== 'geojson')\n      .filter((t) => t.data !== undefined)\n    return tracksWithData\n  }\n)\n\nconst getTemporalExtentIndexes = createSelector(\n  [getTemporalExtent],\n  (temporalExtent) => {\n    const startTimestamp = temporalExtent[0].getTime()\n    const endTimestamp = Math.max(\n      temporalExtent[1].getTime(),\n      temporalExtent[0].getTime() + MIN_FRAME_LENGTH_MS\n    )\n    const startIndex = convert.getOffsetedTimeAtPrecision(startTimestamp)\n    const endIndex = convert.getOffsetedTimeAtPrecision(endTimestamp)\n    return [startIndex, endIndex]\n  }\n)\n\nconst getHighlightTemporalExtentIndexes = createSelector(\n  [getHighlightTemporalExtent],\n  (highlightTemporalExtent) => {\n    if (\n      highlightTemporalExtent === undefined ||\n      highlightTemporalExtent === null ||\n      !highlightTemporalExtent.length\n    ) {\n      return null\n    }\n    const startTimestamp = highlightTemporalExtent[0].getTime()\n    const endTimestamp = highlightTemporalExtent[1].getTime()\n    const startIndex = convert.getOffsetedTimeAtPrecision(startTimestamp)\n    const endIndex = convert.getOffsetedTimeAtPrecision(endTimestamp)\n    return [startIndex, endIndex]\n  }\n)\n\nconst mapStateToProps = (state) => ({\n  highlightedVessels: state.map.heatmap.highlightedVessels,\n  highlightedClickedVessel: state.map.heatmap.highlightedClickedVessel,\n  viewport: state.map.viewport.viewport,\n  zoom: state.map.viewport.viewport.zoom,\n  heatmapLayers: getHeatmapLayersAsArray(state),\n  tracks: getTracksWithData(state),\n  leftWorldScaled: state.map.viewport.leftWorldScaled,\n  rightWorldScaled: state.map.viewport.rightWorldScaled,\n  temporalExtentIndexes: getTemporalExtentIndexes(state),\n  highlightTemporalExtentIndexes: getHighlightTemporalExtentIndexes(state),\n})\n\nconst mapDispatchToProps = (dispatch, ownProps) => ({\n  queryHeatmapVessels: (coords, temporalExtentIndexes) => {\n    dispatch(queryHeatmapVessels(coords, temporalExtentIndexes))\n  },\n  exportNativeViewport: (viewport) => {\n    dispatch(exportNativeViewport(viewport))\n  },\n})\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(ActivityLayers)\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport MapGL, { Popup } from 'react-map-gl'\nimport 'mapbox-gl/dist/mapbox-gl.css'\nimport { TILES_URL_NEEDING_AUTHENTICATION } from '../config'\nimport ActivityLayers from '../activity/ActivityLayers.container.js'\nimport styles from './map.css'\n\nconst PopupWrapper = (props) => {\n  const { latitude, longitude, children, closeButton, onClose } = props\n  return (\n    <Popup\n      latitude={latitude}\n      longitude={longitude}\n      closeButton={closeButton}\n      onClose={onClose}\n      anchor=\"bottom\"\n      offsetTop={-10}\n      tipSize={4}\n      closeOnClick={false}\n    >\n      {children}\n    </Popup>\n  )\n}\n\nPopupWrapper.propTypes = {\n  latitude: PropTypes.number.isRequired,\n  longitude: PropTypes.number.isRequired,\n  children: PropTypes.node.isRequired,\n  closeButton: PropTypes.bool.isRequired,\n  onClose: PropTypes.func,\n}\n\nPopupWrapper.defaultProps = {\n  onClose: () => {},\n}\n\nclass Map extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      mouseOver: true,\n    }\n    this._mapContainerRef = null\n  }\n  componentDidMount() {\n    window.addEventListener('resize', this._resize)\n    this._resize()\n\n    // useful with FOUC\n    window.setTimeout(() => this._resize(), 1)\n\n    // there is a problem with the container width computation (only with \"fat scrollbar\" browser/os configs),\n    // seems like the panels with scrollbars are taken into account or smth\n    window.setTimeout(() => this._resize(), 10000)\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('resize', this._resize)\n  }\n\n  _resize = () => {\n    if (this._mapContainerRef === null) {\n      console.warn('Cant set viewport on a map that hasnt finished intanciating yet')\n      return\n    }\n    const mapContainerStyle = window.getComputedStyle(this._mapContainerRef)\n    const width = parseInt(mapContainerStyle.width, 10)\n    const height = parseInt(mapContainerStyle.height, 10) + 1\n\n    if (width !== this.props.viewport.width || height !== this.props.viewport.height) {\n      this.props.setViewport({\n        ...this.props.viewport,\n        width,\n        height,\n      })\n    }\n  }\n\n  onViewportChange = (viewport) => {\n    this.props.setViewport(viewport)\n  }\n\n  onMapInteraction = (event, type) => {\n    this.props.mapInteraction(\n      type,\n      event.lngLat[1],\n      event.lngLat[0],\n      event.features,\n      this.glGetSource\n    )\n  }\n\n  onHover = (event) => {\n    this.onMapInteraction(event, 'hover')\n  }\n\n  onClick = (event) => {\n    this.onMapInteraction(event, 'click')\n  }\n\n  getRef = (ref) => {\n    if (ref !== null) {\n      this.glMap = ref.getMap()\n      this.glGetSource = this.glMap.getSource.bind(this.glMap)\n    }\n  }\n\n  getCursor = ({ isDragging }) => {\n    const { cursor } = this.props\n    if (cursor === null) {\n      return isDragging ? 'grabbing' : 'grab'\n    }\n    return cursor\n  }\n\n  transformRequest = (url, resourceType) => {\n    const { token } = this.props\n    if (token !== null && resourceType === 'Tile' && url.match(TILES_URL_NEEDING_AUTHENTICATION)) {\n      return {\n        url: url,\n        headers: { Authorization: 'Bearer ' + token },\n      }\n    }\n  }\n\n  render() {\n    const {\n      viewport,\n      maxZoom,\n      minZoom,\n      transitionEnd,\n      mapStyle,\n      onClosePopup,\n      clickPopup,\n      hoverPopup,\n      hasHeatmapLayers,\n      interactiveLayerIds,\n    } = this.props\n    return (\n      <div\n        id=\"map\"\n        className={styles.map}\n        ref={(ref) => {\n          this._mapContainerRef = ref\n        }}\n        onMouseLeave={() => {\n          this.setState({ mouseOver: false })\n        }}\n        onMouseEnter={() => {\n          this.setState({ mouseOver: true })\n        }}\n      >\n        <MapGL\n          ref={this.getRef}\n          transformRequest={this.transformRequest}\n          onTransitionEnd={transitionEnd}\n          onHover={this.onHover}\n          onClick={this.onClick}\n          getCursor={this.getCursor}\n          mapStyle={mapStyle}\n          {...viewport}\n          maxZoom={maxZoom}\n          minZoom={minZoom}\n          onViewportChange={this.onViewportChange}\n          interactiveLayerIds={interactiveLayerIds}\n          clickRadius={4}\n        >\n          {hasHeatmapLayers !== false && <ActivityLayers />}\n          {clickPopup !== undefined && clickPopup !== null && (\n            <PopupWrapper\n              latitude={clickPopup.latitude}\n              longitude={clickPopup.longitude}\n              closeButton\n              onClose={onClosePopup}\n            >\n              {clickPopup.content}\n            </PopupWrapper>\n          )}\n          {this.state.mouseOver === true && hoverPopup !== undefined && hoverPopup !== null && (\n            <PopupWrapper\n              latitude={hoverPopup.latitude}\n              longitude={hoverPopup.longitude}\n              closeButton={false}\n            >\n              {hoverPopup.content}\n            </PopupWrapper>\n          )}\n        </MapGL>\n        <div className={styles.googleLogo} />\n      </div>\n    )\n  }\n}\n\nMap.propTypes = {\n  token: PropTypes.string,\n  viewport: PropTypes.object.isRequired,\n  mapStyle: PropTypes.object.isRequired,\n  clickPopup: PropTypes.object,\n  hoverPopup: PropTypes.object,\n  maxZoom: PropTypes.number.isRequired,\n  minZoom: PropTypes.number.isRequired,\n  setViewport: PropTypes.func.isRequired,\n  mapInteraction: PropTypes.func,\n  onClosePopup: PropTypes.func,\n  transitionEnd: PropTypes.func,\n  cursor: PropTypes.string,\n  hasHeatmapLayers: PropTypes.bool.isRequired,\n  interactiveLayerIds: PropTypes.arrayOf(PropTypes.string),\n}\n\nMap.defaultProps = {\n  token: null,\n  clickPopup: null,\n  hoverPopup: null,\n  mapInteraction: () => {},\n  onClosePopup: () => {},\n  transitionEnd: () => {},\n  cursor: null,\n  interactiveLayerIds: null,\n}\n\nexport default Map\n","import { connect } from 'react-redux'\nimport { createSelector } from 'reselect'\nimport { fromJS } from 'immutable'\nimport { TRACKS_LAYER_IN_FRONT_OF_GROUP } from '../config'\nimport { closePopup } from '../module/module.actions.js'\nimport { getTracksStyles } from '../tracks/tracks.selectors.js'\nimport { mapInteraction } from './interaction.actions.js'\nimport { setViewport, transitionEnd } from './viewport.actions.js'\nimport Map from './Map'\n\nconst getStaticLayers = (state) => state.map.style.staticLayers\nconst getHeatmapLayers = (state) => state.map.heatmap.heatmapLayers\n\nconst hasHeatmapLayers = createSelector(\n  [getHeatmapLayers],\n  (heatmapLayers) => {\n    return Object.keys(heatmapLayers).length > 0\n  }\n)\nconst getInteractiveLayerIds = createSelector(\n  [getStaticLayers],\n  // Note: here we assume that layer IDs provided with module match the GL layers that should\n  // be interactive or not, ie typically the fill layer if a label layer is present\n  (staticLayers) =>\n    staticLayers.filter((l) => l.interactive === true && l.visible === true).map((l) => l.id)\n)\n\nconst getMapStyles = (state) => state.map.style.mapStyle\nconst getMapStyle = createSelector(\n  [getMapStyles, getTracksStyles],\n  (mapStyles, trackStyles) => {\n    if (!trackStyles) return mapStyles\n\n    const currentLayerGroups = mapStyles\n      .toJS()\n      .layers.filter((l) => l.metadata !== undefined)\n      .map((l) => l.metadata['mapbox:group'])\n    const trackLayersIndex = currentLayerGroups.lastIndexOf(TRACKS_LAYER_IN_FRONT_OF_GROUP) + 1\n\n    let finalMapStyles = mapStyles.mergeIn(['sources'], trackStyles.sources)\n    let mapStylesLayers = mapStyles.get('layers')\n    trackStyles.layers.forEach((trackLayer, i) => {\n      mapStylesLayers = mapStylesLayers.insert(trackLayersIndex + i, fromJS(trackLayer))\n    })\n    finalMapStyles = finalMapStyles.set('layers', mapStylesLayers)\n    return finalMapStyles\n  }\n)\n\nconst mapStateToProps = (state, ownProps) => ({\n  viewport: state.map.viewport.viewport,\n  maxZoom: state.map.viewport.maxZoom,\n  minZoom: state.map.viewport.minZoom,\n  cursor: state.map.interaction.cursor,\n  token: state.map.module.token,\n  mapStyle: getMapStyle(state),\n  hasHeatmapLayers: hasHeatmapLayers(state),\n  interactiveLayerIds: getInteractiveLayerIds(state),\n})\n\nconst mapDispatchToProps = (dispatch) => ({\n  setViewport: (viewport) => {\n    dispatch(setViewport(viewport))\n  },\n  mapInteraction: (type, lat, long, features, cluster, glGetSource) => {\n    dispatch(mapInteraction(type, lat, long, features, cluster, glGetSource))\n  },\n  transitionEnd: () => {\n    dispatch(transitionEnd())\n  },\n  onClosePopup: () => {\n    dispatch(closePopup())\n  },\n})\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(Map)\n","import { fromJS } from 'immutable'\nimport uniq from 'lodash/uniq'\nimport GL_STYLE from './gl-styles/style.json'\nimport {\n  SET_MAP_STYLE,\n  MARK_CARTO_LAYERS_AS_INSTANCIATED,\n  INIT_MAP_STYLE,\n  SET_STATIC_LAYERS,\n  SET_BASEMAP_LAYERS,\n} from './style.actions'\n\nconst attributions = uniq(\n  Object.keys(GL_STYLE.sources)\n    .map((sourceKey) => GL_STYLE.sources[sourceKey].attribution)\n    .filter((source) => source !== undefined)\n)\n\nexport const setLayerStyleDefaults = (layer) => {\n  if (layer.layout === undefined) {\n    layer.layout = {}\n  }\n  if (layer.paint === undefined) {\n    layer.paint = {}\n  }\n  if (layer.metadata === undefined) {\n    layer.metadata = {}\n  }\n  // initialize time filter for time-filterable layers\n  if (layer.metadata['gfw:temporal'] === true) {\n    const temporalField =\n      layer.metadata['gfw:temporalField'] === undefined\n        ? 'timestamp'\n        : layer.metadata['gfw:temporalField']\n    layer.filter = ['all', ['>', temporalField, 0], ['<', temporalField, 999999999999]]\n  }\n\n  if (layer.metadata['mapbox:group'] === undefined) {\n    layer.metadata['mapbox:group'] = 'temporal'\n  }\n\n  // set all layers to not visible except layers explicitely marked as visible (default basemap)\n  if (layer.layout.visibility !== 'visible') {\n    layer.layout.visibility = 'none'\n  }\n  return layer\n}\n\nconst setStyleDefaults = (style) => {\n  style.layers.forEach((layer) => {\n    setLayerStyleDefaults(layer)\n  })\n  return style\n}\n\nconst initialState = {\n  mapStyle: fromJS(setStyleDefaults(GL_STYLE)),\n  cartoLayersInstanciated: [],\n  staticLayers: [],\n  basemapLayers: [],\n  attributions,\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case INIT_MAP_STYLE: {\n      const newMapStyle = state.mapStyle.setIn(['glyphs'], action.payload.glyphsPath)\n      return { ...state, mapStyle: newMapStyle }\n    }\n    case SET_MAP_STYLE: {\n      return { ...state, mapStyle: action.payload }\n    }\n    case SET_STATIC_LAYERS: {\n      return { ...state, staticLayers: action.payload }\n    }\n    case SET_BASEMAP_LAYERS: {\n      return { ...state, basemapLayers: action.payload }\n    }\n    case MARK_CARTO_LAYERS_AS_INSTANCIATED: {\n      const cartoLayersInstanciated = [...state.cartoLayersInstanciated, ...action.payload]\n      return { ...state, cartoLayersInstanciated }\n    }\n    default:\n      return state\n  }\n}\n","// This utility looks at GeoJSON features and returns the predominant geometry type\n\nconst TYPES = [\n  { gl: 'line', geoJSON: ['LineString', 'MultiLineString'] },\n  { gl: 'fill', geoJSON: ['Polygon', 'MultiPolygon'] },\n  { gl: 'circle', geoJSON: ['Point', 'MultiPoint'] },\n]\n\nexport default (geoJSON) => {\n  // collect all geoJSON geom types\n  const allGeoJSONTypes = geoJSON.features.map((feature) => {\n    const geom = feature.geometry\n    if (geom === undefined) {\n      return null\n    }\n    return geom.type\n  })\n\n  // collect number of geometries by GL geom types\n  const numByGLType = TYPES.map((type) => {\n    let num = 0\n    allGeoJSONTypes.forEach((geoJSONType) => {\n      if (type.geoJSON.indexOf(geoJSONType) > -1) {\n        num++\n      }\n    })\n    return { gl: type.gl, num }\n  })\n\n  // get feature types with the higher count\n  let glType = 'fill'\n  let glTypeMax = 0\n  numByGLType.forEach((t) => {\n    if (t.num > glTypeMax) {\n      glType = t.gl\n      glTypeMax = t.num\n    }\n  })\n\n  return glType\n}\n","import { fromJS } from 'immutable'\nimport convert from '@globalfishingwatch/map-convert'\nimport uniq from 'lodash/uniq'\nimport throttle from 'lodash/throttle'\nimport { hexToRgb } from '../utils/map-colors'\nimport { STATIC_LAYERS_CARTO_ENDPOINT, STATIC_LAYERS_CARTO_TILES_ENDPOINT } from '../config'\nimport { CUSTOM_LAYERS_SUBTYPES, GL_TRANSPARENT } from '../constants'\nimport GL_STYLE from './gl-styles/style.json'\nimport { setLayerStyleDefaults } from './style.reducer.js'\nimport getMainGeomType from '../utils/getMainGeomType'\n\nexport const INIT_MAP_STYLE = 'INIT_MAP_STYLE'\nexport const SET_MAP_STYLE = 'SET_MAP_STYLE'\nexport const MARK_CARTO_LAYERS_AS_INSTANCIATED = 'MARK_CARTO_LAYERS_AS_INSTANCIATED'\nexport const SET_STATIC_LAYERS = 'SET_STATIC_LAYERS'\nexport const SET_BASEMAP_LAYERS = 'SET_BASEMAP_LAYERS'\n\nexport const initStyle = ({ glyphsPath }) => ({\n  type: INIT_MAP_STYLE,\n  payload: {\n    glyphsPath,\n  },\n})\n\nconst setMapStyle = (style) => ({\n  type: SET_MAP_STYLE,\n  payload: style,\n})\n\nconst setStyleTemporalExtent = (dispatch, getState, temporalExtent, applyToThrottled = false) => {\n  const state = getState().map.style\n  let style = state.mapStyle\n  const currentStyle = style.toJS()\n  const glLayers = currentStyle.layers\n\n  let start = Math.round(temporalExtent[0].getTime() / 1000)\n  let end = Math.round(temporalExtent[1].getTime() / 1000)\n\n  // TEMPORARY, remove later - temporal layers points should have a timestamp, this is legacy\n  // logic for legacy encounters layer that only have a 'timeIndex'\n  const startIndex = convert.getOffsetedTimeAtPrecision(temporalExtent[0].getTime())\n  const endIndex = convert.getOffsetedTimeAtPrecision(temporalExtent[1].getTime())\n\n  for (let i = 0; i < glLayers.length; i++) {\n    const glLayer = glLayers[i]\n    if (glLayer.metadata === undefined || glLayer.metadata['gfw:temporal'] !== true) {\n      continue\n    }\n\n    if (\n      (applyToThrottled === true && glLayer.metadata['gfw:temporal:throttled'] !== true) ||\n      (applyToThrottled === false && glLayer.metadata['gfw:temporal:throttled'] === true)\n    ) {\n      continue\n    }\n\n    // if layer is temporal, a filter must always be preset on the style.json object\n    // because each layer can have a different time field to be filtered\n    const currentFilter = style.getIn(['layers', i, 'filter']).toJS()\n    if (currentFilter === null) {\n      throw new Error('filter must be preset on style.json for temporal layer: ', glLayer.id)\n    }\n\n    // TEMPORARY, remove later - temporal layers points should have a timestamp, this is legacy\n    // logic for legacy encounters layer that only have a 'timeIndex'\n    const isLegacy = glLayer.metadata && glLayer.metadata['gfw:temporalField'] === 'timeIndex'\n    currentFilter[1][2] = isLegacy ? startIndex : start\n    currentFilter[2][2] = isLegacy ? endIndex : end\n    style = style.setIn(['layers', i, 'filter'], fromJS(currentFilter))\n  }\n  dispatch(setMapStyle(style))\n}\n\nconst applyTemporalExtentThrottled = throttle((dispatch, getState, temporalExtent) => {\n  setStyleTemporalExtent(dispatch, getState, temporalExtent, true)\n}, 400)\n\nexport const applyTemporalExtent = (temporalExtent) => (dispatch, getState) => {\n  setStyleTemporalExtent(dispatch, getState, temporalExtent)\n  applyTemporalExtentThrottled(dispatch, getState, temporalExtent)\n}\n\nconst applyLayerExpressions = (style, refLayer, currentGlLayer, glLayerIndex) => {\n  let newStyle = style\n  const currentStyle = style.toJS()\n  const glType = currentGlLayer.type\n  const defaultStyles = currentStyle.metadata['gfw:styles']\n  const metadata = currentGlLayer.metadata\n  ;['selected', 'highlighted'].forEach((styleType) => {\n    // get selectedFeatures or highlightedFeatures\n    const features = refLayer[`${styleType}Features`]\n    const hasFeatures = features !== null && features !== undefined && features.values.length > 0\n    const applyStyleToAllFeatures = refLayer[styleType]\n\n    const defaultStyle = defaultStyles[styleType][glType] || {}\n    const layerStyle =\n      (metadata && metadata['gfw:styles'] && metadata['gfw:styles'][styleType]) || {}\n    const allPaintProperties = { ...defaultStyle, ...layerStyle }\n    if (Object.keys(allPaintProperties).length) {\n      // go through each applicable gl paint property\n      Object.keys(allPaintProperties).forEach((glPaintProperty) => {\n        const selectedValue = allPaintProperties[glPaintProperty][0]\n        const fallbackValue = allPaintProperties[glPaintProperty][1]\n        const paintOrLayout = ['icon-size', 'icon-image'].includes(glPaintProperty)\n          ? 'layout'\n          : 'paint'\n        let glPaintFinalValue\n        if (\n          hasFeatures === false &&\n          applyStyleToAllFeatures !== true &&\n          applyStyleToAllFeatures !== false\n        ) {\n          // style reset when no features filter is declared and neither is applyAll\n          const originalLayerStyle = GL_STYLE.layers.find((l) => l.id === currentGlLayer.id)\n\n          if (originalLayerStyle !== undefined) {\n            // for reset: do not repaint with default style when layer as a custom main color property\n            if (\n              currentGlLayer.metadata &&\n              currentGlLayer.metadata['gfw:mainColorPaintProperty'] === glPaintProperty\n            ) {\n              glPaintFinalValue = null\n            } else {\n              glPaintFinalValue = originalLayerStyle[paintOrLayout][glPaintProperty]\n            }\n          } else {\n            // this will happen when no style exist in the original definition (ie custom layers)\n            // in this case set glPaintFinalValue to null and we'll just skip applying\n            // any selected/highlighted style for this layer\n            glPaintFinalValue = null\n          }\n        } else if (applyStyleToAllFeatures === true || applyStyleToAllFeatures === false) {\n          glPaintFinalValue = applyStyleToAllFeatures === true ? selectedValue : fallbackValue\n        } else {\n          let layerColorRgbString = ''\n          if (refLayer.color !== null && refLayer.color !== undefined) {\n            const layerColorRgb = hexToRgb(refLayer.color)\n            layerColorRgbString = `${layerColorRgb.r},${layerColorRgb.g},${layerColorRgb.b}`\n          }\n          glPaintFinalValue = [\n            'match',\n            ['get', features.field],\n            features.values,\n            typeof selectedValue !== 'string'\n              ? selectedValue\n              : selectedValue.replace('$REFLAYER_COLOR_RGB', layerColorRgbString),\n            typeof fallbackValue !== 'string'\n              ? fallbackValue\n              : fallbackValue.replace('$REFLAYER_COLOR_RGB', layerColorRgbString),\n          ]\n        }\n\n        if (glPaintFinalValue !== undefined && glPaintFinalValue !== null) {\n          newStyle = newStyle.setIn(\n            ['layers', glLayerIndex, paintOrLayout, glPaintProperty],\n            glPaintFinalValue\n          )\n        }\n      })\n    }\n  })\n  return newStyle\n}\n\nconst toggleLayerVisibility = (style, refLayer, glLayerIndex) => {\n  const visibility = refLayer.visible === true ? 'visible' : 'none'\n  return style.setIn(['layers', glLayerIndex, 'layout', 'visibility'], visibility)\n}\n\nconst updateGLLayer = (style, glLayerId, refLayer) => {\n  const currentStyle = style.toJS()\n  const currentStyleLayers = currentStyle.layers\n  let newStyle = style\n\n  const glLayerIndex = currentStyleLayers.findIndex((l) => l.id === glLayerId)\n  const glLayer = currentStyleLayers.find((l) => l.id === glLayerId)\n\n  // visibility\n  newStyle = toggleLayerVisibility(newStyle, refLayer, glLayerIndex)\n\n  if (refLayer.isBasemap === true) {\n    return newStyle\n  }\n\n  const refLayerOpacity = refLayer.opacity === undefined ? 1 : refLayer.opacity\n\n  // color/opacity\n  switch (glLayer.type) {\n    case 'fill': {\n      newStyle = newStyle\n        .setIn(['layers', glLayerIndex, 'paint', 'fill-opacity'], refLayerOpacity)\n        .setIn(['layers', glLayerIndex, 'paint', 'fill-outline-color'], refLayer.color)\n        .setIn(['layers', glLayerIndex, 'paint', 'fill-color'], GL_TRANSPARENT)\n      break\n    }\n    case 'line': {\n      newStyle = newStyle\n        .setIn(['layers', glLayerIndex, 'paint', 'line-opacity'], refLayerOpacity)\n        .setIn(['layers', glLayerIndex, 'paint', 'line-color'], refLayer.color)\n      break\n    }\n    case 'symbol': {\n      if (glLayer.metadata && glLayer.metadata['gfw:isLabel'] === true) {\n        const parentLayerIsVisible =\n          newStyle.getIn(['layers', glLayerIndex, 'layout', 'visibility']) === 'visible'\n        const labelsVisibility =\n          parentLayerIsVisible && refLayer.showLabels === true ? 'visible' : 'none'\n        newStyle = newStyle.setIn(\n          ['layers', glLayerIndex, 'layout', 'visibility'],\n          labelsVisibility\n        )\n        if (refLayer.showLabels !== true) {\n          break\n        }\n      }\n      newStyle = newStyle.setIn(['layers', glLayerIndex, 'paint', 'text-opacity'], refLayerOpacity)\n\n      if (refLayer.color !== undefined) {\n        newStyle = newStyle.setIn(['layers', glLayerIndex, 'paint', 'text-color'], refLayer.color)\n      }\n      break\n    }\n    // Event layers and custom layers with point geom types\n    case 'circle': {\n      newStyle = newStyle\n        .setIn(['layers', glLayerIndex, 'paint', 'circle-opacity'], refLayerOpacity)\n        .setIn(['layers', glLayerIndex, 'paint', 'circle-stroke-opacity'], refLayerOpacity)\n\n      if (refLayer.color !== undefined) {\n        const colorPaintProperty = glLayer.metadata['gfw:mainColorPaintProperty'] || 'circle-color'\n        newStyle = newStyle.setIn(\n          ['layers', glLayerIndex, 'paint', colorPaintProperty],\n          refLayer.color\n        )\n      }\n      break\n    }\n    case 'raster': {\n      newStyle = newStyle.setIn(\n        ['layers', glLayerIndex, 'paint', 'raster-opacity'],\n        refLayerOpacity\n      )\n      break\n    }\n    default: {\n      break\n    }\n  }\n\n  newStyle = applyLayerExpressions(newStyle, refLayer, glLayer, glLayerIndex)\n\n  return newStyle\n}\n\nconst addCustomGLLayer = (subtype, layerId, url, data) => (dispatch, getState) => {\n  const state = getState()\n  let style = state.map.style.mapStyle\n  const currentStyle = style.toJS()\n\n  // add source if it doesn't exist yet\n  if (currentStyle.sources[layerId] === undefined) {\n    const source = { type: subtype }\n    if (subtype === CUSTOM_LAYERS_SUBTYPES.geojson) {\n      source.data = data\n    } else if (subtype === CUSTOM_LAYERS_SUBTYPES.raster) {\n      source.tiles = [url]\n      source.tileSize = 256\n    }\n    style = style.setIn(['sources', layerId], fromJS(source))\n  }\n\n  if (currentStyle.layers.find((glLayer) => glLayer.id === layerId) === undefined) {\n    const glType = subtype === CUSTOM_LAYERS_SUBTYPES.geojson ? getMainGeomType(data) : subtype\n    const glLayer = fromJS({\n      id: layerId,\n      source: layerId,\n      type: glType,\n      layout: {},\n      paint: {},\n    })\n    const layerIndex =\n      subtype === CUSTOM_LAYERS_SUBTYPES.raster\n        ? // if raster, put at index of last raster layer except labels\n          currentStyle.layers.length -\n          1 -\n          currentStyle.layers\n            .filter((l) => l.id !== 'labels')\n            .reverse()\n            .findIndex((l) => l.type === 'raster')\n        : currentStyle.layers.length - 1\n    style = style.set('layers', style.get('layers').splice(layerIndex, 0, glLayer))\n  }\n\n  dispatch(setMapStyle(style))\n}\n\nconst addWorkspaceGLLayers = (workspaceGLLayers) => (dispatch, getState) => {\n  const state = getState()\n  let style = state.map.style.mapStyle\n\n  workspaceGLLayers.forEach((workspaceGLLayer) => {\n    const id = workspaceGLLayer.id\n    const gl = workspaceGLLayer.gl\n    const finalSource = fromJS(gl.source)\n    style = style.setIn(['sources', id], finalSource)\n\n    gl.layers.forEach((workspaceGlLayer) => {\n      const sourceLayer =\n        workspaceGlLayer['source-layer'] === undefined ? id : workspaceGlLayer['source-layer']\n      let layerId = workspaceGlLayer.id\n      if (layerId === undefined) {\n        layerId = gl.layers.length === 1 ? id : `${id}-${new Date().getTime()}`\n      }\n      const defaultGlLayer = setLayerStyleDefaults(workspaceGlLayer)\n\n      const glLayer = {\n        ...defaultGlLayer,\n        id: layerId,\n        source: id,\n        'source-layer': sourceLayer,\n      }\n      const existingLayers = style.get('layers')\n      const newLayerGroup = glLayer.metadata['mapbox:group']\n      const newLayerIndex = existingLayers.findLastIndex((l) => {\n        return newLayerGroup === l.toJS().metadata['mapbox:group']\n      })\n      style = style.set('layers', existingLayers.splice(newLayerIndex, 0, fromJS(glLayer)))\n    })\n  })\n\n  dispatch(setMapStyle(style))\n  dispatch(applyTemporalExtent(state.map.module.temporalExtent))\n}\n\nconst getCartoLayerInstanciatePromise = ({ sourceId, sourceCartoSQL }) => {\n  const mapConfig = { layers: [{ id: sourceId, options: { sql: sourceCartoSQL } }] }\n  const mapConfigURL = encodeURIComponent(JSON.stringify(mapConfig))\n  const cartoAnonymousMapUrl = STATIC_LAYERS_CARTO_ENDPOINT.replace('$MAPCONFIG', mapConfigURL)\n\n  return new Promise((resolve) => {\n    fetch(cartoAnonymousMapUrl)\n      .then((res) => {\n        if (res.status >= 400) {\n          console.warn(`loading of layer failed ${sourceId}`)\n          Promise.reject()\n          return null\n        }\n        return res.json()\n      })\n      .then((data) => {\n        resolve({\n          layergroupid: data.layergroupid,\n          sourceId,\n        })\n      })\n      .catch((err) => {\n        console.warn(err)\n      })\n  })\n}\n\nconst instanciateCartoLayers = (layers) => (dispatch, getState) => {\n  dispatch({\n    type: MARK_CARTO_LAYERS_AS_INSTANCIATED,\n    payload: layers.map((layer) => layer.sourceId),\n  })\n  const cartoLayersPromises = layers.map((layer) => getCartoLayerInstanciatePromise(layer))\n  const cartoLayersPromisesPromise = Promise.all(cartoLayersPromises.map((p) => p.catch((e) => e)))\n  cartoLayersPromisesPromise\n    .then((instanciatedCartoLayers) => {\n      let style = getState().map.style.mapStyle\n      const currentStyle = style.toJS()\n      instanciatedCartoLayers.forEach((cartoLayer) => {\n        const tilesURL = STATIC_LAYERS_CARTO_TILES_ENDPOINT.replace(\n          '$LAYERGROUPID',\n          cartoLayer.layergroupid\n        )\n\n        // replace gl source with a new source that use tiles provided by Carto anonymous maps API\n        const newSourceId = `${cartoLayer.sourceId}-instanciated`\n        style = style.setIn(\n          ['sources', newSourceId],\n          fromJS({\n            type: 'vector',\n            tiles: [tilesURL],\n          })\n        )\n\n        // change source in all layers that are using it (genrally polygon + labels)\n        currentStyle.layers.forEach((glLayer, glLayerIndex) => {\n          if (glLayer.source === cartoLayer.sourceId) {\n            style = style.setIn(['layers', glLayerIndex, 'source'], newSourceId)\n            style = style.setIn(['layers', glLayerIndex, 'metadata', 'gfw:id'], cartoLayer.sourceId)\n            const refLayer = layers.find((l) => l.refLayer.id === cartoLayer.sourceId).refLayer\n            style = updateGLLayer(style, glLayer.id, refLayer)\n          }\n        })\n      })\n\n      dispatch(setMapStyle(style))\n    })\n    .catch((err) => {\n      console.warn(err)\n    })\n}\n\nexport const commitStyleUpdates = (staticLayers, basemapLayers) => (dispatch, getState) => {\n  // Store a copy of static and basemap layers. This is not used directly by\n  // the Map component which only needs a prepared style object\n  dispatch({\n    type: SET_STATIC_LAYERS,\n    payload: staticLayers,\n  })\n  dispatch({\n    type: SET_BASEMAP_LAYERS,\n    payload: basemapLayers,\n  })\n\n  const layers = [...staticLayers, ...basemapLayers.map((bl) => ({ ...bl, isBasemap: true }))]\n\n  const currentGLSources = getState().map.style.mapStyle.toJS().sources\n\n  // collect layers declared in workspace but not in original gl style\n  const workspaceGLLayers = layers.filter(\n    (layer) => layer.gl !== undefined && currentGLSources[layer.id] === undefined\n  )\n  if (workspaceGLLayers.length) {\n    dispatch(addWorkspaceGLLayers(workspaceGLLayers))\n  }\n\n  // instanciate custom layers if needed\n  const customLayers = layers.filter(\n    (layer) => layer.isCustom === true && currentGLSources[layer.id] === undefined\n  )\n  if (customLayers.length) {\n    customLayers.forEach((layer) => {\n      dispatch(addCustomGLLayer(layer.subtype, layer.id, layer.url, layer.data))\n    })\n  }\n\n  const state = getState().map.style\n  let style = state.mapStyle\n  const currentStyle = style.toJS()\n  const glLayers = currentStyle.layers\n  const glSources = currentStyle.sources\n\n  const cartoLayersToInstanciate = []\n\n  // update source when needed\n  staticLayers.forEach((refLayer) => {\n    const sourceId = refLayer.id\n    if (currentGLSources[sourceId] !== undefined) {\n      if (refLayer.data !== undefined) {\n        style = style.setIn(['sources', sourceId, 'data'], fromJS(refLayer.data))\n      }\n      if (refLayer.url !== undefined) {\n        const { tiles } = currentGLSources[sourceId]\n        // Using default tiles url as a fallback\n        const newTiles =\n          tiles !== undefined && tiles.length > 0 ? uniq([refLayer.url, ...tiles]) : [refLayer.url]\n\n        style = style.setIn(['sources', sourceId, 'tiles'], fromJS(newTiles))\n      }\n    }\n  })\n\n  for (let i = 0; i < glLayers.length; i++) {\n    const glLayer = glLayers[i]\n    const sourceId = glLayer.source\n    const glSource = glSources[sourceId]\n    const layerId = (glLayer.metadata !== undefined && glLayer.metadata['gfw:id']) || sourceId\n\n    const refLayer = layers.find((l) => l.id === layerId)\n\n    if (refLayer === undefined) {\n      if (glLayer.type !== 'background') {\n        // console.warn('gl layer does not exists in workspace', glLayer);\n      }\n      continue\n    }\n\n    // check if layer is served from Carto, which means we need to instanciate it first\n    // TODO BUG: check if layer is not instanciatING too\n    const sourceCartoSQL = glSource.metadata !== undefined && glSource.metadata['gfw:carto-sql']\n    if (sourceCartoSQL !== false && sourceCartoSQL !== undefined) {\n      // only if layer is visible and has not been instanciated yet\n      const cartoLayerInstanciated = state.cartoLayersInstanciated.indexOf(sourceId) > -1\n      if (\n        refLayer.visible === true &&\n        !cartoLayerInstanciated &&\n        !cartoLayersToInstanciate.find((l) => l.sourceId === sourceId)\n      ) {\n        cartoLayersToInstanciate.push({ sourceId, sourceCartoSQL, refLayer })\n      }\n      continue\n    }\n\n    style = updateGLLayer(style, glLayer.id, refLayer)\n  }\n\n  if (cartoLayersToInstanciate.length) {\n    dispatch(instanciateCartoLayers(cartoLayersToInstanciate))\n  }\n\n  dispatch(setMapStyle(style))\n}\n","import { compose, createStore, applyMiddleware } from 'redux'\nimport thunk from 'redux-thunk'\n\nimport { fitToBounds } from '../glmap/viewport.actions'\n\nlet composeEnhancers = compose\nif (\n  (process.env.MAP_REDUX_REMOTE_DEBUG || process.env.REACT_APP_MAP_REDUX_REMOTE_DEBUG) &&\n  process.env.NODE_ENV === 'development'\n) {\n  const composeWithDevTools = require('remote-redux-devtools').composeWithDevTools\n  composeEnhancers = composeWithDevTools({\n    name: 'Map module',\n    realtime: true,\n    hostname: 'localhost',\n    port: 8000,\n    maxAge: 30,\n    stateSanitizer: (state) => ({ ...state, map: { ...state.map, heatmap: 'NOT_SERIALIZED' } }),\n  })\n}\n\nconst store = createStore(() => {}, {}, composeEnhancers(applyMiddleware(thunk)))\n\nexport const targetMapVessel = (id) => {\n  const track = store.getState().map.tracks.data.find((t) => t.id === id.toString())\n  store.dispatch(fitToBounds(track.geoBounds))\n\n  return track.timelineBounds\n}\n\nexport default store\n","import tbbox from '@turf/bbox'\nimport { targetMapVessel } from '../store'\n\nimport {\n  getTilePromises,\n  getCleanVectorArrays,\n  groupData,\n  addTracksPointsRenderingData,\n  getTracksPlaybackData,\n} from '../utils/heatmapTileData'\nimport { startLoader, completeLoader } from '../module/module.actions'\n\nexport const ADD_TRACK = 'ADD_TRACK'\nexport const UPDATE_TRACK = 'UPDATE_TRACK'\nexport const REMOVE_TRACK = 'REMOVE_TRACK'\n\nconst getTrackDataParsed = (geojson) => {\n  const time = { start: Infinity, end: 0 }\n  if (geojson && geojson.features) {\n    geojson.features.forEach((feature) => {\n      const hasTimes =\n        feature.properties &&\n        feature.properties.coordinateProperties &&\n        feature.properties.coordinateProperties.times &&\n        feature.properties.coordinateProperties.times.length > 0\n      if (hasTimes) {\n        feature.properties.coordinateProperties.times.forEach((datetime) => {\n          if (datetime < time.start) {\n            time.start = datetime\n          } else if (datetime > time.end) {\n            time.end = datetime\n          }\n        })\n      }\n    })\n  }\n  return {\n    geojson,\n    timelineBounds: [time.start, time.end],\n  }\n}\n\nconst getTrackBounds = (geojson) => {\n  const bounds = tbbox(geojson)\n  return {\n    minLat: bounds[3],\n    minLng: bounds[0],\n    maxLat: bounds[1],\n    maxLng: bounds[2],\n  }\n}\n\n// Deprecated tracks format parsing\nconst getOldTrackBoundsFormat = (data, addOffset = false) => {\n  const time = {\n    start: Infinity,\n    end: 0,\n  }\n  const geo = {\n    minLat: Infinity,\n    maxLat: -Infinity,\n    minLng: Infinity,\n    maxLng: -Infinity,\n  }\n  for (let i = 0, length = data.datetime.length; i < length; i++) {\n    const datetime = data.datetime[i]\n    if (datetime < time.start) {\n      time.start = datetime\n    } else if (datetime > time.end) {\n      time.end = datetime\n    }\n\n    const lat = data.latitude[i]\n    if (lat < geo.minLat) {\n      geo.minLat = lat\n    } else if (lat > geo.maxLat) {\n      geo.maxLat = lat\n    }\n\n    let lng = data.longitude[i]\n    if (addOffset === true) {\n      if (lng < 0) {\n        lng += 360\n      }\n    }\n    if (lng < geo.minLng) {\n      geo.minLng = lng\n    } else if (lng > geo.maxLng) {\n      geo.maxLng = lng\n    }\n  }\n\n  // track crosses the antimeridian\n  if (geo.maxLng - geo.minLng > 350 && addOffset === false) {\n    return getOldTrackBoundsFormat(data, true)\n  }\n\n  return {\n    time: [time.start, time.end],\n    geo,\n  }\n}\n\nfunction loadTrack(track) {\n  return (dispatch, getState) => {\n    const { id, url, type, fitBoundsOnLoad, layerTemporalExtents, color, data } = track\n    const state = getState()\n    if (state.map.tracks.data.find((t) => t.id === id)) {\n      return\n    }\n\n    const payload = {\n      id,\n      url,\n      type,\n      color,\n      fitBoundsOnLoad,\n    }\n    const trackHasData = track.data !== undefined && track.data !== null\n    const trackHasUrl = url !== undefined && url !== null && url !== ''\n    if (trackHasData) {\n      payload.data = data\n      payload.geoBounds = getTrackBounds(data)\n    }\n    dispatch({ type: ADD_TRACK, payload })\n\n    if (trackHasData || !trackHasUrl) {\n      return\n    }\n\n    const loaderID = startLoader(dispatch, state)\n    if (type !== 'geojson') {\n      // Deprecated tracks format logic to be deleted some day\n      const token = state.map.module.token\n\n      const promises = getTilePromises(url, token, layerTemporalExtents)\n\n      Promise.all(promises.map((p) => p.catch((e) => e))).then((rawTileData) => {\n        const cleanData = getCleanVectorArrays(rawTileData)\n\n        if (!cleanData.length) {\n          return\n        }\n        const rawTrackData = groupData(cleanData, [\n          'latitude',\n          'longitude',\n          'datetime',\n          'series',\n          'weight',\n          'sigma',\n        ])\n\n        const vectorArray = addTracksPointsRenderingData(rawTrackData)\n        const bounds = getOldTrackBoundsFormat(rawTrackData)\n\n        dispatch({\n          type: UPDATE_TRACK,\n          payload: {\n            id,\n            data: getTracksPlaybackData(vectorArray),\n            geoBounds: bounds.geo,\n            timelineBounds: bounds.time,\n          },\n        })\n        dispatch(completeLoader(loaderID))\n      })\n    } else {\n      fetch(url)\n        .then((res) => {\n          if (res.status >= 400) throw new Error(res.statusText)\n          return res.json()\n        })\n        .then((data) => {\n          const { geojson, timelineBounds } = getTrackDataParsed(data)\n          const geoBounds = getTrackBounds(data)\n          dispatch({\n            type: UPDATE_TRACK,\n            payload: {\n              id,\n              data: geojson,\n              geoBounds,\n              timelineBounds,\n            },\n          })\n          if (fitBoundsOnLoad) {\n            targetMapVessel(id)\n          }\n        })\n        .catch((err) => console.warn(err))\n        .finally(() => dispatch(completeLoader(loaderID)))\n    }\n  }\n}\n\nconst removeTrack = (trackId) => ({\n  type: REMOVE_TRACK,\n  payload: {\n    trackId,\n  },\n})\n\nexport const updateTracks = (newTracks = []) => (dispatch, getState) => {\n  const prevTracks = getState().map.tracks.data\n  // add and update layers\n  if (newTracks) {\n    newTracks.forEach((newTrack) => {\n      const trackId = newTrack.id\n      const prevTrack = prevTracks.find((t) => t.id === trackId)\n      if (prevTrack === undefined) {\n        dispatch(loadTrack(newTrack))\n      } else if (prevTrack.color !== newTrack.color) {\n        dispatch({\n          type: UPDATE_TRACK,\n          payload: {\n            id: newTrack.id,\n            color: newTrack.color,\n          },\n        })\n      }\n    })\n  }\n\n  // clean up unused tracks\n  prevTracks.forEach((prevTrack) => {\n    if (!newTracks || !newTracks.find((t) => t.id === prevTrack.id)) {\n      dispatch(removeTrack(prevTrack.id))\n    }\n  })\n}\n","import PropTypes from 'prop-types'\n\nconst withReducerPropTypes = (name, propTypesSchema) => (reducer) => {\n  if (process.env.NODE_ENV === 'development') {\n    return (state, action) => {\n      const result = reducer(state, action)\n      PropTypes.checkPropTypes(propTypesSchema, result, 'reducer', name)\n\n      return result\n    }\n  }\n  return reducer\n}\n\nexport default withReducerPropTypes\n","import PropTypes from 'prop-types'\nimport withReducerTypes from '../utils/withReducerTypes'\nimport {\n  INIT_MODULE,\n  SET_TEMPORAL_EXTENT,\n  SET_HIGHLIGHT_TEMPORAL_EXTENT,\n  START_LOADER,\n  COMPLETE_LOADER,\n} from './module.actions'\n\nconst initialState = {\n  loaders: null,\n  token: undefined,\n  temporalExtent: [new Date(1970), new Date()],\n  highlightTemporalExtent: null,\n  onViewportChange: undefined,\n  onHover: undefined,\n  onClick: undefined,\n  onLoadStart: undefined,\n  onLoadComplete: undefined,\n  onClosePopup: undefined,\n  onAttributionsChange: undefined,\n}\n\nconst moduleReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case INIT_MODULE: {\n      return {\n        ...state,\n        ...action.payload,\n      }\n    }\n\n    case SET_TEMPORAL_EXTENT: {\n      return {\n        ...state,\n        temporalExtent: action.payload,\n      }\n    }\n\n    case SET_HIGHLIGHT_TEMPORAL_EXTENT: {\n      return {\n        ...state,\n        highlightTemporalExtent: action.payload,\n      }\n    }\n\n    case START_LOADER: {\n      const loaders = state.loaders !== null ? [...state.loaders] : []\n      loaders.push(action.payload)\n      return { ...state, loaders }\n    }\n\n    case COMPLETE_LOADER: {\n      const loaders = [...state.loaders]\n      const loaderIndex = loaders.findIndex((l) => l === action.payload)\n      loaders.splice(loaderIndex, 1)\n      return { ...state, loaders }\n    }\n\n    default:\n      return state\n  }\n}\n\nconst moduleTypes = {\n  loaders: PropTypes.arrayOf(PropTypes.number),\n  token: PropTypes.string,\n  temporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  onViewportChange: PropTypes.func,\n  onHover: PropTypes.func,\n  onClick: PropTypes.func,\n  onLoadStart: PropTypes.func,\n  onLoadComplete: PropTypes.func,\n  onClosePopup: PropTypes.func,\n  onAttributionsChange: PropTypes.func,\n}\n\nexport default withReducerTypes('module', moduleTypes)(moduleReducer)\n","import PropTypes from 'prop-types'\nimport { trackTypes } from '../proptypes/tracks'\nimport withReducerTypes from '../utils/withReducerTypes'\n\nimport { ADD_TRACK, UPDATE_TRACK, REMOVE_TRACK } from './tracks.actions'\n\nconst initialState = {\n  data: [],\n}\n\nconst tracksReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case ADD_TRACK: {\n      const data = [...state.data, action.payload]\n      return { ...state, data }\n    }\n\n    case UPDATE_TRACK: {\n      const trackData = action.payload\n      const data = state.data.map((track) => {\n        if (track.id !== trackData.id) return track\n        return {\n          ...track,\n          ...trackData,\n        }\n      })\n      return { ...state, data }\n    }\n\n    case REMOVE_TRACK: {\n      const removedTrackId = action.payload.trackId\n      const data = state.data.filter((track) => track.id !== removedTrackId)\n      return { ...state, data }\n    }\n\n    default:\n      return state\n  }\n}\n\nconst tracksTypes = {\n  data: PropTypes.arrayOf(\n    PropTypes.exact({\n      ...trackTypes,\n      data: PropTypes.object,\n      timelineBounds: PropTypes.array,\n      geoBounds: PropTypes.exact({\n        minLat: PropTypes.number,\n        minLng: PropTypes.number,\n        maxLat: PropTypes.number,\n        maxLng: PropTypes.number,\n      }),\n    })\n  ),\n}\n\nexport default withReducerTypes('tracks', tracksTypes)(tracksReducer)\n","import uniq from 'lodash/uniq'\nimport {\n  INIT_HEATMAP_LAYERS,\n  UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES,\n  ADD_HEATMAP_LAYER,\n  UPDATE_HEATMAP_LAYER_STYLE,\n  REMOVE_HEATMAP_LAYER,\n  ADD_REFERENCE_TILE,\n  UPDATE_HEATMAP_TILE,\n  RELEASE_HEATMAP_TILES,\n  HIGHLIGHT_VESSELS,\n  UPDATE_LOADED_TILES,\n  HIGHLIGHT_CLICKED_VESSEL,\n  CLEAR_HIGHLIGHT_CLICKED_VESSEL,\n} from './heatmap.actions'\n\nconst initialState = {\n  // a dict of heatmap layers (key is layer id)\n  // each containing data, url, tiles, visibleTemporalExtentsIndices\n  heatmapLayers: {},\n  // store a list of tiles currently visible in the map\n  // those are necessary when adding a new layer to know which tiles need to be loaded\n  referenceTiles: [],\n  highlightedVessels: { isEmpty: true },\n  highlightedClickedVessel: null,\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case INIT_HEATMAP_LAYERS: {\n      return Object.assign({}, state, { heatmapLayers: action.payload })\n    }\n\n    case UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES: {\n      const heatmapLayers = state.heatmapLayers\n      let indices = heatmapLayers[action.payload.layerId].visibleTemporalExtentsIndices\n      indices = uniq(indices.concat(action.payload.indicesAdded))\n      heatmapLayers[action.payload.layerId].visibleTemporalExtentsIndices = indices\n      return Object.assign({}, state, heatmapLayers)\n    }\n\n    case ADD_HEATMAP_LAYER: {\n      const heatmapLayers = Object.assign({}, state.heatmapLayers, {\n        [action.payload.id]: {\n          tiles: [],\n          ...action.payload,\n        },\n      })\n      return Object.assign({}, state, { heatmapLayers })\n    }\n\n    case UPDATE_HEATMAP_LAYER_STYLE: {\n      const newLayer = action.payload\n      const layer = { ...state.heatmapLayers[newLayer.id], ...newLayer }\n      const heatmapLayers = { ...state.heatmapLayers, [newLayer.id]: layer }\n      return { ...state, heatmapLayers }\n    }\n\n    case REMOVE_HEATMAP_LAYER: {\n      const heatmapLayers = Object.assign({}, state.heatmapLayers)\n      delete heatmapLayers[action.payload.id]\n      return Object.assign({}, state, { heatmapLayers })\n    }\n\n    case ADD_REFERENCE_TILE: {\n      return Object.assign({}, state, { referenceTiles: [...state.referenceTiles, action.payload] })\n    }\n\n    case UPDATE_HEATMAP_TILE: {\n      const layerId = action.payload.layerId\n      const newTile = action.payload.tile\n      const layer = { ...state.heatmapLayers[layerId] }\n      let layerTiles = [...layer.tiles]\n      const tileIndex = layerTiles.findIndex((t) => t.uid === newTile.uid)\n      if (tileIndex === -1) {\n        layerTiles.push(newTile)\n      } else {\n        layerTiles = [layerTiles.slice(0, tileIndex), newTile, layerTiles.slice(tileIndex + 1)]\n      }\n      layer.tiles = layerTiles\n      const heatmapLayers = { ...state.heatmapLayers, [layerId]: layer }\n      return { ...state, heatmapLayers }\n    }\n\n    case RELEASE_HEATMAP_TILES: {\n      const uids = action.payload\n\n      // remove tiles\n      const layerIds = Object.keys(state.heatmapLayers)\n      const heatmapLayers = { ...state.heatmapLayers }\n      layerIds.forEach((layerId) => {\n        const prevLayer = { ...heatmapLayers[layerId] }\n        uids.forEach((tileUid) => {\n          const releasedTileIndex = prevLayer.tiles.findIndex((tile) => tile.uid === tileUid)\n          if (releasedTileIndex > -1) {\n            // console.log('releasing', layerId, tileUid);\n            prevLayer.tiles.splice(releasedTileIndex, 1)\n          }\n        })\n      })\n\n      // remove reference tiles\n      let referenceTiles = [...state.referenceTiles]\n      uids.forEach((tileUid) => {\n        const releasedRefTileIndex = referenceTiles.findIndex((tile) => tile.uid === tileUid)\n        if (releasedRefTileIndex > -1) {\n          referenceTiles = [\n            ...referenceTiles.slice(0, releasedRefTileIndex),\n            ...referenceTiles.slice(releasedRefTileIndex + 1),\n          ]\n        }\n      })\n\n      return { ...state, heatmapLayers, referenceTiles }\n    }\n\n    case UPDATE_LOADED_TILES: {\n      const newHeatmapLayers = { ...state.heatmapLayers }\n      return { ...state, heatmapLayers: newHeatmapLayers }\n    }\n\n    case HIGHLIGHT_VESSELS: {\n      return Object.assign({}, state, { highlightedVessels: action.payload })\n    }\n\n    case HIGHLIGHT_CLICKED_VESSEL: {\n      return { ...state, highlightedClickedVessel: action.payload }\n    }\n\n    case CLEAR_HIGHLIGHT_CLICKED_VESSEL: {\n      return { ...state, highlightedClickedVessel: null }\n    }\n\n    default:\n      return state\n  }\n}\n","import uniq from 'lodash/uniq'\nimport {\n  SET_CURRENTLY_VISIBLE_TILES,\n  SET_CURRENTLY_LOADED_TILES,\n  SET_CURRENTLY_SWAPPED_TILE_UIDS,\n  MARK_TILES_UIDS_AS_LOADED,\n  RELEASE_MARKED_TILES_UIDS,\n} from './heatmapTiles.actions'\n\nconst initialState = {\n  currentVisibleTiles: [],\n  currentLoadedTiles: [],\n  currentToLoadTileUids: [],\n  currentToReleaseTileUids: [],\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case SET_CURRENTLY_VISIBLE_TILES: {\n      const currentVisibleTiles = [].concat(action.payload)\n      return { ...state, currentVisibleTiles }\n    }\n\n    case SET_CURRENTLY_LOADED_TILES: {\n      const currentLoadedTiles = [].concat(action.payload)\n      return { ...state, currentLoadedTiles }\n    }\n\n    case SET_CURRENTLY_SWAPPED_TILE_UIDS: {\n      const currentToLoadTileUids = uniq(\n        state.currentToLoadTileUids.concat(action.payload.tilesToLoadUids)\n      )\n      const currentToReleaseTileUids = uniq(\n        state.currentToReleaseTileUids.concat(action.payload.tilesToReleaseUids)\n      )\n      // clean to load tiles of tiles that needs to be released\n      const newToLoadTilesUids = currentToLoadTileUids.filter(\n        (tileUid) => currentToReleaseTileUids.indexOf(tileUid) === -1\n      )\n      return { ...state, currentToLoadTileUids: newToLoadTilesUids, currentToReleaseTileUids }\n    }\n\n    case MARK_TILES_UIDS_AS_LOADED: {\n      const currentToLoadTileUids = state.currentToLoadTileUids\n      const tileUidsMarkedAsLoaded = action.payload\n      const newCurrentToLoadTileUids = currentToLoadTileUids.filter(\n        (tileUid) => tileUidsMarkedAsLoaded.indexOf(tileUid) === -1\n      )\n      return { ...state, currentToLoadTileUids: newCurrentToLoadTileUids }\n    }\n\n    case RELEASE_MARKED_TILES_UIDS: {\n      return { ...state, currentToReleaseTileUids: [] }\n    }\n\n    default:\n      return state\n  }\n}\n","import FlyToInterpolator from 'react-map-gl/dist/es5/utils/transition/viewport-fly-to-interpolator'\nimport { easeCubic } from 'd3-ease'\nimport { MIN_ZOOM_LEVEL, MAX_ZOOM_LEVEL } from '../config'\nimport { TRANSITION_TYPE } from '../constants'\nimport {\n  SET_VIEWPORT,\n  UPDATE_VIEWPORT,\n  SET_ZOOM_INCREMENT,\n  SET_MOUSE_LAT_LONG,\n  TRANSITION_END,\n  SET_NATIVE_VIEWPORT,\n} from './viewport.actions'\n\nconst DEFAULT_TRANSITION = {\n  transitionDuration: 500,\n  transitionInterpolator: new FlyToInterpolator(),\n  transitionEasing: easeCubic,\n}\n\nconst initialState = {\n  viewport: {\n    latitude: 0,\n    longitude: 0,\n    zoom: 3,\n    bearing: 0,\n    pitch: 0,\n    width: 1000,\n    height: 800,\n  },\n  maxZoom: MAX_ZOOM_LEVEL,\n  minZoom: MIN_ZOOM_LEVEL,\n  prevZoom: 3,\n  currentTransition: null,\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case SET_VIEWPORT: {\n      return {\n        ...state,\n        viewport: action.payload,\n        canZoomIn: action.payload.zoom < state.maxZoom,\n        canZoomOut: action.payload.zoom > state.minZoom,\n        prevZoom: state.viewport.zoom,\n      }\n    }\n\n    case UPDATE_VIEWPORT: {\n      const viewport = { ...state.viewport, ...action.payload }\n      return {\n        ...state,\n        viewport,\n        prevZoom: viewport.zoom,\n      }\n    }\n\n    case SET_ZOOM_INCREMENT: {\n      const currentZoom = state.viewport.zoom\n      const zoom = Math.min(\n        state.maxZoom,\n        action.payload.zoom || currentZoom + action.payload.increment\n      )\n      const viewport = {\n        ...state.viewport,\n        ...DEFAULT_TRANSITION,\n        zoom,\n        latitude:\n          action.payload.latitude === null ? state.viewport.latitude : action.payload.latitude,\n        longitude:\n          action.payload.longitude === null ? state.viewport.longitude : action.payload.longitude,\n      }\n      return {\n        ...state,\n        viewport,\n        canZoomIn: zoom < state.maxZoom,\n        canZoomOut: zoom > state.minZoom,\n        prevZoom: state.viewport.zoom,\n        currentTransition: TRANSITION_TYPE.ZOOM,\n      }\n    }\n\n    case SET_MOUSE_LAT_LONG: {\n      return { ...state, mouseLatLong: action.payload }\n    }\n\n    case TRANSITION_END: {\n      return { ...state, currentTransition: null }\n    }\n\n    case SET_NATIVE_VIEWPORT: {\n      return { ...state, ...action.payload }\n    }\n\n    default:\n      return state\n  }\n}\n","// TODO MAP MODULE remove whole reducer\nimport { SET_MAP_CURSOR } from './interaction.actions'\n\nconst initialState = {\n  cursor: 'progress',\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case SET_MAP_CURSOR: {\n      return { ...state, cursor: action.payload }\n    }\n    default:\n      return state\n  }\n}\n","import { combineReducers } from 'redux'\n\nimport ModuleReducer from '../module/module.reducer'\nimport TracksReducer from '../tracks/tracks.reducer'\nimport HeatmapReducer from '../heatmap/heatmap.reducer'\nimport HeatmapTilesReducer from '../heatmap/heatmapTiles.reducer'\nimport ViewportReducer from '../glmap/viewport.reducer'\nimport StyleReducer from '../glmap/style.reducer'\nimport InteractionReducer from '../glmap/interaction.reducer'\n\nconst mapReducer = combineReducers({\n  module: ModuleReducer,\n  tracks: TracksReducer,\n  heatmap: HeatmapReducer,\n  heatmapTiles: HeatmapTilesReducer,\n  style: StyleReducer,\n  viewport: ViewportReducer,\n  interaction: InteractionReducer,\n})\n\nexport default mapReducer\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { combineReducers } from 'redux'\nimport { Provider } from 'react-redux'\nimport throttle from 'lodash/throttle'\nimport { trackTypes } from './proptypes/tracks'\nimport { heatmapLayerTypes, basemapLayerTypes, staticLayerTypes } from './proptypes/layers'\nimport { viewportTypes, popupTypes } from './proptypes/shared'\n\nimport Map from './glmap/Map.container'\nimport { initModule, setTemporalExtent, setHighlightTemporalExtent } from './module/module.actions'\nimport { updateViewport, transitionToZoom } from './glmap/viewport.actions'\nimport { initStyle, commitStyleUpdates, applyTemporalExtent } from './glmap/style.actions'\nimport { updateTracks } from './tracks/tracks.actions'\nimport { updateHeatmapLayers, updateLayerLoadTemporalExtents } from './heatmap/heatmap.actions'\n\nimport store from './store'\nimport mapReducers from './store/reducers'\n\nconst mapReducer = combineReducers({\n  map: mapReducers,\n})\n\nstore.replaceReducer(mapReducer)\n\nconst throttleApplyTemporalExtent = throttle((temporalExtent) => {\n  store.dispatch(applyTemporalExtent(temporalExtent))\n  store.dispatch(setTemporalExtent(temporalExtent))\n}, 16)\n\nconst updateViewportFromIncomingProps = (incomingViewport) => {\n  store.dispatch(\n    updateViewport({\n      latitude: incomingViewport.center[0],\n      longitude: incomingViewport.center[1],\n      zoom: incomingViewport.zoom,\n    })\n  )\n}\n\nclass MapModule extends React.Component {\n  state = {\n    initialized: false,\n    error: null,\n    errorInfo: null,\n  }\n\n  componentDidCatch(error, errorInfo) {\n    console.log(error, errorInfo)\n    this.setState({\n      error: error,\n      errorInfo: errorInfo,\n    })\n  }\n\n  componentDidMount() {\n    // First trigger synchronous actions that should happen before any map render\n    // At the end of this, set a flag to allow map rendering\n\n    if (this.props.viewport !== undefined) {\n      updateViewportFromIncomingProps(this.props.viewport)\n    }\n\n    // TODO\n    if (this.props.glyphsPath !== null) {\n      store.dispatch(\n        initStyle({\n          glyphsPath: this.props.glyphsPath,\n          // TODO apply URL updates here\n        })\n      )\n    }\n\n    if (this.props.onAttributionsChange !== undefined) {\n      this.props.onAttributionsChange(store.getState().map.style.attributions)\n    }\n\n    if (store && store.getState().map.module.token === undefined) {\n      store.dispatch(\n        initModule({\n          token: this.props.token,\n          autoClusterZoom: this.props.autoClusterZoom,\n          isCluster: this.props.isCluster,\n          onViewportChange: this.props.onViewportChange,\n          onHover: this.props.onHover,\n          onClick: this.props.onClick,\n          onLoadStart: this.props.onLoadStart,\n          onLoadComplete: this.props.onLoadComplete,\n          onClosePopup: this.props.onClosePopup,\n          onAttributionsChange: this.props.onAttributionsChange,\n        })\n      )\n    }\n\n    if (this.props.highlightTemporalExtent !== null && this.props.highlightTemporalExtent.length) {\n      store.dispatch(setHighlightTemporalExtent(this.props.highlightTemporalExtent))\n    }\n\n    if (\n      (this.props.basemapLayers !== null && this.props.basemapLayers.length) ||\n      (this.props.staticLayers !== null && this.props.staticLayers.length)\n    ) {\n      store.dispatch(\n        commitStyleUpdates(this.props.staticLayers || [], this.props.basemapLayers || [])\n      )\n    }\n\n    if (this.props.tracks !== null) {\n      store.dispatch(updateTracks(this.props.tracks))\n    }\n\n    // Now trigger async actions\n\n    if (this.props.temporalExtent !== null && this.props.temporalExtent.length) {\n      throttleApplyTemporalExtent(this.props.temporalExtent)\n    }\n\n    // eslint-disable-next-line react/no-did-mount-set-state\n    this.setState({\n      initialized: true,\n    })\n\n    // heatmap layers\n    if (this.props.heatmapLayers !== null) {\n      store.dispatch(updateHeatmapLayers(this.props.heatmapLayers, this.props.loadTemporalExtent))\n    }\n  }\n\n  componentDidUpdate(prevProps) {\n    // tracks\n    if (this.props.tracks !== prevProps.tracks) {\n      store.dispatch(updateTracks(this.props.tracks))\n    }\n\n    // heatmap layers\n    if (this.props.heatmapLayers !== prevProps.heatmapLayers) {\n      store.dispatch(updateHeatmapLayers(this.props.heatmapLayers, this.props.loadTemporalExtent))\n    }\n\n    // basemap / static layers\n    if (\n      (this.props.basemapLayers !== null && this.props.basemapLayers.length) ||\n      (this.props.staticLayers !== null && this.props.staticLayers.length)\n    ) {\n      store.dispatch(\n        commitStyleUpdates(this.props.staticLayers || [], this.props.basemapLayers || [])\n      )\n    }\n\n    // loadTemporalExtent\n    if (this.props.loadTemporalExtent !== null && this.props.loadTemporalExtent.length) {\n      if (\n        prevProps.loadTemporalExtent === null ||\n        !prevProps.loadTemporalExtent.length ||\n        this.props.loadTemporalExtent[0].getTime() !== prevProps.loadTemporalExtent[0].getTime() ||\n        this.props.loadTemporalExtent[1].getTime() !== prevProps.loadTemporalExtent[1].getTime()\n      ) {\n        store.dispatch(updateLayerLoadTemporalExtents(this.props.loadTemporalExtent))\n      }\n    }\n    // temporalExtent\n    if (this.props.temporalExtent !== null && this.props.temporalExtent.length) {\n      if (\n        prevProps.temporalExtent === null ||\n        !prevProps.temporalExtent.length ||\n        this.props.temporalExtent[0].getTime() !== prevProps.temporalExtent[0].getTime() ||\n        this.props.temporalExtent[1].getTime() !== prevProps.temporalExtent[1].getTime()\n      ) {\n        throttleApplyTemporalExtent(this.props.temporalExtent)\n      }\n    }\n\n    // highlightTemporalExtent\n    if (this.props.highlightTemporalExtent !== null && this.props.highlightTemporalExtent.length) {\n      if (\n        prevProps.highlightTemporalExtent === null ||\n        !prevProps.highlightTemporalExtent.length ||\n        this.props.highlightTemporalExtent[0].getTime() !==\n          prevProps.highlightTemporalExtent[0].getTime() ||\n        this.props.highlightTemporalExtent[1].getTime() !==\n          prevProps.highlightTemporalExtent[1].getTime()\n      ) {\n        store.dispatch(setHighlightTemporalExtent(this.props.highlightTemporalExtent))\n      }\n    } else {\n      if (this.props.highlightTemporalExtent !== prevProps.highlightTemporalExtent) {\n        store.dispatch(setHighlightTemporalExtent(this.props.highlightTemporalExtent))\n      }\n    }\n\n    // viewport - since viewport will be updated internally to the module,\n    // we have to compare incoming props to existing viewport in store, ie:\n    // update viewport from incoming props ONLY if zoom or center is different\n    // from the internally stored one\n    // TODO FFS incoming lat lon should be an object, not an array\n    const currentViewport = store.getState().map.viewport.viewport\n    //                                        stop propagating updates from outside when zooming in\n    if (\n      this.props.viewport !== undefined &&\n      store.getState().map.viewport.currentTransition === null\n    ) {\n      if (\n        currentViewport.latitude !== this.props.viewport.center[0] ||\n        currentViewport.longitude !== this.props.viewport.center[1] ||\n        currentViewport.zoom !== this.props.viewport.zoom\n      ) {\n        // if zoom delta is precisely === 1, zoom with a transition\n        if (Math.abs(currentViewport.zoom - this.props.viewport.zoom) === 1) {\n          store.dispatch(transitionToZoom(this.props.viewport.zoom))\n        } else {\n          updateViewportFromIncomingProps(this.props.viewport)\n        }\n      }\n    }\n  }\n  render() {\n    if (this.state.error !== null) {\n      console.log(this.state.error)\n      return (\n        <div>\n          <h2>Map component crashed!</h2>\n          <p className=\"red\">{this.state.error && this.state.error.toString()}</p>\n          <div>Component Stack Error Details:</div>\n          <p className=\"red\">{this.state.errorInfo.componentStack}</p>\n        </div>\n      )\n    }\n    // won't render anything before actions in componentDidMount have been triggered\n    return this.state.initialized !== true ? null : (\n      <Provider store={store}>\n        <Map {...this.props} />\n      </Provider>\n    )\n  }\n}\n\nMapModule.propTypes = {\n  token: PropTypes.string,\n  viewport: PropTypes.shape(viewportTypes).isRequired,\n  autoClusterZoom: PropTypes.bool,\n  isCluster: PropTypes.func,\n  tracks: PropTypes.arrayOf(PropTypes.exact(trackTypes)),\n  heatmapLayers: PropTypes.arrayOf(PropTypes.shape(heatmapLayerTypes)),\n  temporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  highlightTemporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  loadTemporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  basemapLayers: PropTypes.arrayOf(PropTypes.shape(basemapLayerTypes)),\n  staticLayers: PropTypes.arrayOf(PropTypes.shape(staticLayerTypes)),\n  // customLayers\n  hoverPopup: PropTypes.shape(popupTypes),\n  clickPopup: PropTypes.shape(popupTypes),\n  glyphsPath: PropTypes.string,\n  onViewportChange: PropTypes.func,\n  onLoadStart: PropTypes.func,\n  onLoadComplete: PropTypes.func,\n  onClick: PropTypes.func,\n  onHover: PropTypes.func,\n  onAttributionsChange: PropTypes.func,\n  onClosePopup: PropTypes.func,\n}\n\nMapModule.defaultProps = {\n  token: null,\n  glyphsPath: null,\n  autoClusterZoom: true,\n  isCluster: (event) => event.isCluster === true,\n  highlightTemporalExtent: null,\n  tracks: null,\n  hoverPopup: null,\n  clickPopup: null,\n  heatmapLayers: null,\n  temporalExtent: null,\n  loadTemporalExtent: null,\n  basemapLayers: null,\n  staticLayers: null,\n  onViewportChange: () => {},\n  onLoadStart: () => {},\n  onLoadComplete: () => {},\n  onClick: () => {},\n  onHover: () => {},\n  onAttributionsChange: () => {},\n  onClosePopup: () => {},\n}\n\nexport default MapModule\n","import GL_STYLE from '../glmap/gl-styles/style.json'\n\nconst AVAILABLE_BASEMAPS = GL_STYLE.metadata['gfw:basemap-layers']\n\nexport default AVAILABLE_BASEMAPS\n","\n  import React from 'react'\n  import { MDXTag } from '@mdx-js/tag'\n  import { Playground, PropsTable } from 'docz'\nimport Map from './index.js'\n\nconst layoutProps = {\n  \n};\nexport default class MDXContent extends React.Component {\n  constructor(props) {\n    super(props)\n    this.layout = null\n  }\n  render() {\n    const { components, ...props } = this.props\n\n    return <MDXTag\n             name=\"wrapper\"\n             \n             components={components}>\n<MDXTag name=\"h1\" components={components} props={{\"id\":\"map\"}}>{`Map`}</MDXTag>\n<MDXTag name=\"h2\" components={components} props={{\"id\":\"description\"}}>{`Description`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`This component displays and load fishing activity and fishing-related layers on a map, used in various GFW projects:`}</MDXTag>\n<MDXTag name=\"ul\" components={components}>\n<MDXTag name=\"li\" components={components} parentName=\"ul\"><MDXTag name=\"a\" components={components} parentName=\"li\" props={{\"href\":\"https://github.com/GlobalFishingWatch/map-client/blob/9c5179358d4870c0fd4c2c0742917e72e6025c59/app/src/map/components/MapWrapper.jsx#L5\"}}>{`Map client`}</MDXTag></MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\"><MDXTag name=\"a\" components={components} parentName=\"li\" props={{\"href\":\"https://github.com/GlobalFishingWatch/vessel-profiles/blob/aa0e17395f6a4947bb3fdf3106cb9d0a744ba64f/src/profile/components/MapWrapper.js#L3\"}}>{`Vessel profiles`}</MDXTag></MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\"><MDXTag name=\"a\" components={components} parentName=\"li\" props={{\"href\":\"https://github.com/GlobalFishingWatch/data-portal/blob/96b1e24efcff58ade672a67229da0610d9d241ab/src/map/MapWrapper.jsx#L2\"}}>{`Data portal`}</MDXTag></MDXTag>\n</MDXTag>\n<MDXTag name=\"h2\" components={components} props={{\"id\":\"available-properties\"}}>{`Available properties`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`TODO: fix crash on PropsTable docz component`}</MDXTag>\n<MDXTag name=\"h2\" components={components} props={{\"id\":\"basic-usage\"}}>{`Basic usage`}</MDXTag>\n<Playground __codesandbox={`N4IgZglgNgpgziAXKCA7AJjAHgOgBYAuAtlEqAMYD2qBMNSIAPOhAG4AEE6AvADogAnSpQL8AfIwD0LVmJABfADQg0mXACsEyEFRp0CDSQCojvVO3YAVPBDjsAwpUwBlAIYYARpSzs8rux4wdOyuAK4ElESuBBDkrlBQAJ7sAOZ0MALRMOjsoXBoKWYWAAZUmHDu6F5YGcU47ACSYOyJlKEA5AIw7OShAhBtdniUAO7sBH4Evq4ADjPp6IotbT3uRT14MOQA1uxtU20C7OiU5EMZMIi-BAQzcIiSkikQE6EeOFREkqiUrGiJkjK8Eq1QyZnWTWWoXY2Hm_To5G67mScAIAlCKRSsDsIxeeHGNjsFU83iWM1g_m6mVsSPMtjgoRg62oqTxb3qiAAlGYjJIzBAiDNKAIpgAlGCuchTMBCIjsToSqXtADc_MFwrFioIABEAPIAWXYMsi8q6koIAFoTkQVWqhSKHJEhah9EbZfKcJJsK5BbBbagzOLzXr9TguhgMgAKdbMNhidYWRh4ADMYkc6pdNE46pF2XYuImPScwJJNQEiCkKfj5gs7EYMzEkYaUyiyRdedc6BYMWo8XYMyEd3GlFSMCmL3Y4cw_VQKXzMASnKkDYTdfTztdkmriekccUZhOvSI-hwaQIAFFYMeaAAhRINdCRzrCAjtbmoTnKhTKb2-mA4TQyB0ahaHoRAVBzKZ9VmN0TXaT04AEchJCiGZJFUbAALgf0BXtTVzVguUFXNdo7Q1dhgHYTQfHkQj5QAARgIgRAGVBAWFGBSIDVBdFRY5TgAL2cAhEmxdhuAo9YogEZ5UCudoAAZ2GTGYsHafcaxmTsWFneSABZVPYAA2VT1PWMAQIAMR9aBEnk_hnEORFHUwdgAAUhH4JZmJ-OAtMRMyawsmhnAgATLnYABGPSNPkcEeOoPiAEE5nE9hI0o8gbCgdBw3YeROXEsR0pjGR2FRUSYG4YBDyEkTsXkbda2ALLoFy4IADIOvGRJ5koZpWpyvLuBG-UwFCHie1Qdp2AAfg2Nrw0jQqrkG9rUDimspBkat3zMWFyMwMAwigKZlqKkqtpSlca0TIMpRwSzMhSa8CCa2s62gmZ2D-GARjw6rMv0DIrgAbQUnAFIAJiMpZIqh5McCMyKAF0lgE4QiCuABWfLaK3VcpHughHue16mqka7drMb8QEQ5DUPQiMNC0CgQP0BgDodSijpOgglgIVwZLHL6ADV4DgBcliS0WkoaAAZJKb3l88AH0byS5xz31JK3OcfK6PglDZi42n6eNtDUKwoDdFAgxwNw8jicNs0lTIh0PMoGZLF6-BDYHL2LRE-ZsPdqZMqdShJaWcgzVoYSOJjyIPDQGBxXQUJEQEOAllmclEn1Lh0FgEYhe6WjjSIroM7UsOKPcoQ_mnA3K9NLULWr0Ja9QR2HVeVBdlbhUa6DvAJu2Lje6mCYhBuWBDagJx_DwSQZ5EAg_Tryi0UlbYfZDlv3SNgOZmD-BV8yHZQ57yD682aJUPl1xEgyff4CWDxKUf5_X99nPysFjEcgT8X4CDfnYCuR9PQnzPnASQUAf7Z0nrfSiv1_oanAWSL2oRvZ_0PnBaBg5YGSDgH4auXE65fUNp6LEjMvofBAq4VOAhkF4XrmgF4-onChFgEsSWBBLBMXtPEc8WA7Z8LHAACQgCkPAUAZGEEETmERYjXSQIIShbhsBNEZ1gDgc0rFr5T3rpAARlAbxtAwP_HB6AsiiwgH9PCAtMioHyFNSwlAABamN8FERoVARmaC8L6KlIY1h5FKIcIIMJSqSciBEBeDE2AABVGYtjaD_zzkkJRwioCiLtr4j0TwAmzBIfVf8BjErhO5rkNJWRLCX22BA6hF9d5wJ3lfEJU0jEoNqekmAkiJTEFmCAjI1i6m0FGQIeWlBOw5OFCou2zSh6envsMtCayraVNcdUqYABxeWqtnCWAAJoqxabQ0pWILQVWxGUyqWFqAUJvmwrhui07ZEzhkFpzF3k6J4f-TuWddlWEaXAdOXyjgrNaVfGFTSwyfOBXXQZD9ZgQqzi0zZpSsUzARRnJFLzyIovWZYaA8B0XfOhTiyQOLSXYjxZCkF9jHEagpVCqBxTAkOPQSKBlBLjFJI-fiylHLLloVuYCxFGQQUND0JfKabKLklLQmgWg8rWJ8ulfFXiLY0VSqOBJT4KcXRsrgBlKSWiIpvIBWyjSFgOlNKuA0tptr1g4quMS1Crqay0rJfcdgnrZh0vJfqu1ADKpXEFd6iwQSNRXGZTygg0bOByu2VcWVartneoKvFWAUxPhCklueVAfgeJjLSgWqOTJuIQGaNGGskYA6IjgHAHAdBWA4B1m5VWopzzamSQADR7drXUlg1banPDeZJez2AAB9Z39iEM21t7acC9qSvYSwqtdbdq7cO_tQ7e36lHeOyd07CpdXWE2iWbbUAdoAHK6gnarc897RbiVGu0TArAFxe1elxQqwB1g6qLOqSWAB1PE2oYCsA8ZQKAdgJJdAAI6hAgF0J8XRmK0A7p8rAVoYMRHg9hTkDCwMwEgxMaDsHhAIeA5HItJb3BZ0Q6BwtFGoMwbgwh81t12CoB9BFdoVDfkAsCh9M0p0BQRTRIyMNFhhiogE8eeSi84hQEU6-eT_Y43sAABwKUM9pqIWAkppCuMmBS2nURZDcD3GI4VyzpRs7QQq3BioZXYDgbzLmYDeVmFcSi3mcC-ZwKhJY7r5SPq3VrUUDQkrywaJ4vtM1aIFTDTmja2rEpTFRBxCtccYAJww_RogxqhWQrNUBvjqErhetDesdL6xgBKFK-x4tpaWORiyQXIuJcy6Rn7tsTk749oJVcdPPAs8N4wGutkoRCy8mqKzBJNec8YCRkGwtzIS27ZueKtViweWug4BYH5aIWVutzHm8o3b-gtu3fyfoEb6xjv_jO1pAgl3-HzJ209mgD3cn_YIC9jacMjJjZAzYux3K8JPUiLKz4BRPZDgkpGNASPZwJrwvtySNY3undsJ9y7q5oe0GxxqXjH0LAIJiAQUImArgY8iAUCnvLERyvBmjVcNPqDPHp4zlNmOUhs5JhztVoNUbaYsBjSITOEoJKx7DjUOBZdEG05liw75NpmHIAglt7AvrWvntgUC6A7DExwOuagrpDsAKyGlO3FgokQHiGFbIVxjoIb841-KFhK2Zh1FwewF28CRgyEIAQSwI_CllRZQDq5eLwf_IvFI4eBCR-jxn2PqB4-rgmLYELY5hJZCp9TmPTmK_S5hNngQcfKBXAr_XjX74LA65rAH_Q2ouBcImgQc6Tv2CPHYJZdDfE0QyLSEcOAiQeJTeoIMEIoTEoEmiOVYYPCch-DmMEQIFkughFQMkVCk46DTlXMPpKk3uhn72M0Av_9-EhCNAgucEQQgJFGOwE_U4MgFD97WLWulA_jgCfK2rGg6AAISjQTRHSpzoAJ58YWBk4wCi7w5ECI4s6zgo5mogFgE4AQEg6rjt4fTD6WBPq6irhAGDaEigGDitpYi9R4BwBuTRD4jQESSwEwCQAugIF47U4AIcSE7nZfZh486AH2aCpl4CEWCMEzDMGsETBXB4H0GnhJDyEsFsHV6kGSBWAUEhDXbJDJKijyx9JZDnBdDiFt6t7U42Ft4AHO51oqFeytrUBX4T4eDhCGL2ClppDsAcG5ARg8HZCIECHOF3A4BuE3D9CeHdI-HuBpCRgE5ngl60DLRhazAhblL6LREQCxGGJ2H5QOGcB1pvbsBdSCEnYpGAIbakZWyiZ6IRDbDBAjScFBHwGhHU4E4fah71oyEpqcKWrSEyFNF0DKG0H4GjGoDaG1jUCi7xGzgyYTGqFzHK4igLFpAzEWDUCSK_AgwEiF74E7F7FR5WGzGoD2DyI7DjGHErEXFXHbBbF7CoAzKdgl4ig3GtpHEvGzLoDvH8xnHbE_Gdjrh5pLG3EuGRHAnoCgljg-5IHU7UCXFVpuTYIzCfF0GQlImLySyokzA4JPFREeFeGJQbHglfF3HuExEkmuJkkzGa62HEHFHUHhGto2CyLyKyICLbaLKugBGoA8JQDlHdSsn4AKKcmKI8l3Y0A4CwCzgTCdEfTdFE69H8LSIckKLcmPbLb96inslyKam_a8k0Cg4fQkGAF1riE0EQkRGfySzfygJ2ABFcHBE5AVGil2lMQjKIKtpykpAKlzqzpWmikuaxBTJOkwHtG8HCkHEUmQmhnAI-myl0D-l4CFGKm1jKkiEk4In-6RAJLRLlKpL9K4HLHxmAJhk-mBnsCgxoyxmYm2lfzemOnVm1mFFa5MncQfQsllkREOoRltFwG8EZlHYRAnY9GiGRgoHOpXzWlxl9lgqmm1jmkWDD73pf4T6YjfL-Cz7kBL7dLMlOG9mtq0DakFLOlRl5junHk4CnlA46nJnylpn8HU5rYzZzaJBGnSm6k3l3mLbA6FErlD66HwDyI0BWi2CuAeCwAWguhiIWhgVUhajfCUAQXoAWjMR943Jjg3I1H560H8KpEbaD7O72au7yLhToDKHojwlmk2Hmmd40Dd7oDFml4DgwY4EZnD79lUFHk2knlgr-GjTsWsA4G3mLkvlKljnvYqmTnTlgpzkNkCVtJLn2Fdm1jD44rsAIKOm8XAE3k4rhlCUSQiViWGU-kjmVEyXZlh4oGBozDhmKX4HmWOkCw3mLxzJSkAWAXFHD6ekn66EJnaU-l6V9HU5OWqH-XNnloXlDlXkik3lRUOVJl-kBnzrBk3kJlGWxXcHwExkhkVmJmOmPmpnpmSWZnSXCHE5iG5mgYFmCqsUZIRXlnRCVktnzo1l1kelNnJXtULptniE-XqWrm6EeXoBfnA6hWiljUTU6nGWBFxVukJX8Wym_GzV2wlUBkkUlGXT9GmWqEzVeVzWtELW5XRnpW1WQH7WQmHVnknipX4gXX9HTVrVHV2xc6nhjikrHjnQBHXURG3X3nvUKQoyfUCLSbnRPUjHuWvV3U0CS6g1njfW1HzX_W-mw1A36AI1g3I3LSDXlVSVCETmXYoFTKvHjVvX6ClkrWA3_k6mqXLmdk6HjCU00BTW_ms1TA5Wun5Uc1w0kwPWWXUFnFo23mc0fqDlnV5hQ0CFXVdCiWqF_l_YPkPWBlnGilK3GkEAfVI0Q2FR_Xy1iWa3fk61fV61q21Ua2c3Y260_X63CWG2K3W2ow416343bX2rz7rYfnrX3ZW383tlFF8ZAWaXimGmc3s0rX6kSlamY1Zj8mCm81R1h1cm-0ymC0E07VhUCGi3R3h380S38aJ0y3U5y0cWqF52p2c2bWPVBmW0GUp2Sn82m3g123GWAmLrl2QmV1N1x3a0g2u1t0l0fR6mN2x103vUu220o0cEd251j1p3a1T1m123u1nFZnVVJFSIL2c3NURE93j3K17aB2bRmkwje6Z09nJ0alV0F0G1d37070B2Z2jlE2yXfbb03290T1-0N1f2H1a0M1qVmm-W6GEHsAWjlQY7dDgO4gJDsCBBmG0A5CqoZACYJDJDv4TDdANG0UaW6EjDdB-A_rDhsZlxC5YFzhgGkPYC2AxCzg_RrHjjmBvZLAOKIAX66EoGMMsoOitzM6K5UP0HsC6j3rywnI7Vq57BHDi7fK2DHC1pgAXBs18bD6tzYMppqroNJBWU5A26cN6F6gj6WT6wCMFDBVTCLwsMb45QIO0h7AeDqBbD8z8YiCH4hAZ7PyJ45Y9B9DhgECi5pTJHF41HpFWyEEEFMMGP9ExOxNxOCHfQnyuApCtUMMoF2Ctz7D5CuQjCbDmBq7mNoChXiGingPc15WXoInBOFml51GZERO9AZ76DOquIvCsSF0CkJCrhC2Wm1WNP-Oi6ymtUC7dABGlNMMfDAwCBc4W39H9P6CDNWP84M6jOjTjO8Ni5TMI2zMyHzM0CDNSNjM3kRNq5r21XD5AFSOYCnSuCcB2DsXkA0g6MnWRTow-IFj4i3M7ytNTRnHUHQQTD6IeBmp7MBMTNSOQPrOJqq6YxuajSRSWWE3jnv1h7fNuKsQeLeKRB73gHguwuB1t7n2Swv21goFoGyiYGCM4E4uRMbMEtB0CGn2M01hMu_4CAD6R2tqhYV7zUukdGZ1J56Kp6KXcu16B1dD04CDmDZ3U6xiyAd1JhQxiBUKMX5qZCkLZCQGVhKsKvfR67-BwD3qCZ8CCDZDiDAAgGiuR5J1cs1Ftq163mUDCQzhp6cjyDLjvQyFytpiRyB7sAl47DsDni17sDQaCzQD3DbRxi6s9D66GvGv8DVzmuWt2tN656UBkYbghSCw7DuuSA3T9FRvysIlDXM0jBPJTBsuH6JAF4MN775bbJ2BoBsY25MU96WJTDEPdCBDBCblT5mt8YSt9DmAptZA4Au5u6UXzWybdDzSdNClXAyuJiexNzfJvbVRvaNRnGMBULADBasn4yes7grtcAZCev0VmDt5G6WoNngKO7rBTFXAo7gJZEuthqEFPuDgvukKzAbaEHgKchhr9mftewvtCyZCJC6hgCRjPt_xtpYDmiDaNIAeAdupDIOljIge4Ihz6KeOQfQewc4c_vzCRguW_whwjZAec1Ydgd4dQcwdftwdoA2Zlr0fahZCUdupP1900dwfgfPz0eEfwDjsTbMYwBscceoc1i01H36C8c4f8f4cMegdMeiesfQfseuZScWBJXhnyfCeKeCeMdEfb4ba6eIIodhpZU-n6etqGcEfGfCfEcbbWegKWfrDD69B5ZEDhluonF4k4K2chameNpokAdhp66xDbABfokNwqcme_uhf4nYfwDaepDqEKFsFBeohvvMioDzG-ERRCetrjQ8RhrUDk3_FBelfkDlfQmwm0DVcTS1d5eXFRdNdld5e7E_pObFc4A1d1dUl5E0lwBkkdctc1jYkolonjexTxTXvvKnbcF8w4H3s-rcc_00BXDztzfcRcxTC8w8JQSzDG7Vr7RYBsIgaCzCwEBiwSwLhpTo58HuYvlXeNJBOVXVG1MZG4r9mnbRCuD9eqCbYg4XQkxcCF1cCOvOsFDLQ2Eb29GmIeIWKwG4GNKfXmKWLm6g7rBDtSvjDo8xDHiIUo9WKXvxRkH6FdqG5PrJLnJRDNGcBTC3M1e_NwWXc-MyxyyKzKxqwaxaxdr6wSQHJHKnIqxhZjidgA-gztApBgAjCIBJUIU-ntAow0xKB0xIQWz5tEJ_xwqtqATaC2wcwOy3zFf-yDhBx_zPL7dFgTYE-7x3sSR25cDZcT6zjjvgowCobobZBhp9BQBu8uue_ig-_VwRfwbChB8FBAe-xBc270cy9pCUCaBPJLB8u8Eoxpc6Wvyc3-p9f2fKcpd2d0cOfxfCcCllYZCcdBQvCk_m66jQlBdeDwa7dmxa-MwwJ685_ZzWxG_sxgQQRsLm9DwnxW8hw28XfkQgZkdgJ4LO_rCu9xfF-vsFAh_e9obh8Pt-pjgPjR-zhWdvBnz78pDvu2B5GwDN-0ZhpjxFeOetqV-BCnGTf-QvB2TL8vuP8ZBhqQCnSYcf98dS-MrPrs52GIjVfAjIPYD136DlBgqoCCAd0CAL8JxCt_ILl_2f4CE1G0ANVKLHiCMgm2dgW5iwGXwCYBAyQZtrk1iD4hFQ-IZouQMIFGhsBGQKCvPEgALhFg4hYfJUB-h4C_Y8jdwB4wg534P8QpQtPkGgowNeBdgSMLqFFCMC_-AgQOhcwii_8cBUgwLKsFoApBhQ7_UGNjCWBGQUYDLanKoIyC4CoA-A-Po42cYt51gaXe-NOGy4hdB8Z-IUKqnz739Ii1gqUNplsBuQbwlkK_q328YIY7wRrFTAAJw6UBvBAJPjMbWBweDy-JfCDkZySG4cUhZfFfugJr4j08-8sCWEEKgAZZSMtgUPpvz96L9U0oSH9IUN27ncOe9vczm53n4vkl-IA93qf3WB_BxBl_SIcJxb5FDyee3Kfg6BAyudyOfsBfjWDaGeCcua_UoRv194cCawlPIxtT2PT9pzkDQOwBMDXzthMAOQbgUgJHC5NEgXQ8_hINqGvYFwzjD3H0NbQDCrONwqUNkEshDI-g8AJwYl0HxsCcoJ_bTKwHUH3D0hAnTId-w6Fpcms63f-ncL66PCuOWITUq8PeFdBEhK_UAT8IcR_DgRcwg_quEBEWDPhwIwvu0JdaQi0uXsSUG_zQGhAq-GAosIvF66zCOhVnYYCMCfiBAEMVw6YVUJiA1DgR8I2vgoLRG0cMhRfUUaCPFFwdcRKQHIXc3sB5AIgWMAUdf1exH84-wIhPtB1BgZ8_e8oZPqn2mhLBOg_gNVKrzS4B9_h6wdJK4CsFOMfB6wLEHaJsFDD2-DMUpF3xDgkIyE2QPvmzD0CD9jEI_I-GP1gST8GhfEIUMlyd6vcB-BANAcWDDS04XgKzGkXSPX5h8Kh0nPnCmMFx9d0BGY8ocsPby28QM_7FoXbjVxpin-EXKZkFxJGeDshbfDXubEZhipJA9CW2EwhdACA_RwEAMfbCH4RI7eLoKUIUmIhShcMNcEFJlEKzOBnhY5ccaiIXEzjCIAAKX1jqIiIAoIgOEBYGcQt4VgUUBugADSzgVWIrBOTnhRQqsBoPelViWRRQojLdLqEsiqw9kT45JG5HHHeZ2IueGRKuL1zTdkuP4z0Lg3-R6JG2WEVcUjTBSCplkUCT0P2X15F5YAUoYUAbx6RsJKIqEbrt_2_yzA2ugbLcUUlQbqpqAXSQxNBMPH8JRczidwOi2oDFocgJEo2BEygmaAQUVCaFF9GeQgYvuQCIymjl8y45QsVsCVFkVapFUxk2We3meAzTMDqhMAKZA-FYyxwhkRWBccKDCqgwBJbVMZNzhWG6F1yjXXwBcHnAhAW0tI7oLsMsaIJGg2oe5o3FPY5APm3-S1ARNEIEhugByOAeWlsnr42gOUDzroUQZkSDEJDYUK4xcYOIeoMwWIPEB0YaNf-QpHvjtVuYIJORfko4PI3YqSwVGFgJIoVXDL7ZVw4w3vqYPZaRgoAuOKACJ0zRKTC6M7GMnVO6EX9ugJ1GdnUxmCbYapF0OqVwFGyyS-IZ4L6PBMe4iSLoYkzIhJNQiCpdcPjUabMEFQFYNJ84tCWOR0lLSZg8EpYLBLaTwTDJhUuaeUn_gOp4JuOQfNQUgLnTTphUPHuYBOmVQ4AxREDKCymR7IhAOCVjE9OxDiFHWG4vGgiSGbFVKpvU2qRL0Fg2jeWl5BAv9NQjgz-pkMqXoLBl6oRqgiAFIF9JmDmjvG9vB1OGVlRqAK0fjfQB9Oxm-lTRRM7APR0sDHj7AZ4i8UlCvE3i7xD4p8fehfFviPxuoL8YVAADUUUYonmkYHoMxpp0tKL9OE7HhhYsqSMDLzgBOR4AqveiTsHgkhYlZcAQoiLKllwAhJBEnaadLBpPge-JGfPI0nVmmz-uwoc8JKDDxIdd4UyNhpdPEK6z9ZbspMsxwyC6lGkhM5mOwEFkQAlglcQGQTMQQM0GSFgHgvEHFnPS0o0cqALHPpT8ITZKvfzIbOeklTiiD00WTHOWmnTfcH4YabqkNn1JKAq3YSTUSWCjBUAnFC6GXg_b25aAP3WltC0IJhoTMWLZUdNNxQRNO5mMDuWgC7lXAe5rc4JIri7kRc-gispzKPPCkkCPg084UB3PzkRpRwt3VebACKkccw088vkcpMQSqSrg8k3kWwAPmgJVJ281zLFEhw-NUI3eGyh4grnpRiaz5F7mXlolMNF2hBF2Xxlflb0wWGzSMD_PooryZgeEpzNVOiBLAlmwclEalwuiD5_5uEk4lApcawKjQ8CrWaAqkiESHii7WnDAr5xwLogHwrWYgtXDIK8FUXNBUQoP6YLSFqIpcq1hrBos2mTEjAIu1_kfR_5bCqaMxLh6NY6uyJXEjN3SjcLaw_8oCaIuS6CKWWN8-KLb0O6nQRxzjMKidLLk4EwFD86qk_PoJmBOQkYL6O-DdHa9wJuDSiYlD7HG9B-pYnxneIaBboNhdPc8GlHaAOKnFtPFWFxDsX28tYW6MdPqDciyCEsL6AdGOk5luL_FqsQJcEuPGHJzw4S19JYB8UjD80PjaJZIgaB7JJEiWHJQEu1hxLQliSiJZYCiXngt0WSnJXkskQFKglIShJUks5mpKIxUwY5ElFFBbp5YuoJKBOjkESR2g7SzpReJ6V9KWl0_HxvYANBuQVYY6EZb0uvFuKplQS2ZWrG6ULLRQ4YiZfbyiSndHuYBXHJGFfkSL_5g-Y_o0HvSOLVYzilWNpi0iiRfiVwMAsUKGH1DtlfEGzCKHJrfI0cr8vhDUQkUgYxqGQB8GlBdBjBNOtRQerUWtEothi5yoZV0tGXXi7lz8MalcGBV15lh1hRfqUTtb1Eb2FXX4v8RhmLUMyo8ixUSreLXd-8F7GsDnMxUPhXl7Pd5ekr_CTJfiPy9KIyue4eY_l68oioCp8a-Y0oAkmFR3h8aYrWMuoGIfohbQyJUAGUJQE3P_AErFuUqmwqcvzwajllMyipWsuRWihUVDyzsBis5VYqXl0wutJASlU10YyFKwlfVydBglSVUtPgoPgdWLcqVMJZ1XCSBlqUSxaSu3nxFWIbMySj3Q5fyrFVCr7eIqiSGKv9XBr80iUz-IGwkieqAUUJArgkTO5Wr0o6mKAKmt2AnVdR7q1cA9MLl5l7e4DdNfivqZRN1K1BCJl4FR6F1S1GZCtSywAIFqi1wxKsTwzbl4tIg2mWRk5lBgRMImyYkZksAnUTMlmuYmAEdNrAtqrEVwZtVjxziJ53AXc2VGuomZxBUAO66YlusPWYxdQ4QPdRsw-Dbqz14QYzIMAPkEAZkukAdePIfVPwn1xCxrNrkUVBqxhX1cWmjniH0165duBFRUpiWFKGlYS0pWGnuXoqWa_NBRcMNaXlRP6BpW-n3Ue4H1F6hysDRqMyXZLclRGupUUsaWwar0aKx5b4A26ycaAyGt5aMJ8bSKYAMXCNfXKjUhMOOFCiVbGpqKiquNaRGwtQQzV6IpuMinBK6tdLkq61uKSlfcWAk4JE1m0TaKYrbHKpJA7EkgZhJthxiGAxiSiKYnr7_x4pNQBDB4nAzChbGrEwghhQyBxAxyFoAOPaNfCHi7K6HINH6nQKBNWJv46lL6npSNtVxoaxNOGt81gTLUEEipNptXH2B5YySY5NeNVhxaGgDM1WJ4l1AGhbx96ewEemSWgS_xkAFIDNFWG6hDcusGnpsPPC_rUN0S0WA0HPDgY4lZSgZXVoa1NbZBKSxjekvt5fjtQSUOZfVsa3Na3FfWgbWrCG0dbOl4ypjX4og0Zastd43LdrHy2tb5tmW_UNluW36hklM2nrXxGiXHoEtaygbSMvvQzo1tni47UzKRXna9tSao8UlHvTOBHFDQURi-nvTag3FdMp7S9ssBvb7xr6bUPdpAzRL70A2hoKLAm3taRtl21WODv-1Q7VYk25rVstm0fKxwgTNHD_I40osTlcKs5QRog0o7OtxqhDe3O_WwqbKU5CZAMg83ewvNsoUXHIosD_yQteEMknIsDWoayWTDR7oQUaowBI1eOnjazoJ3ar5gVwMbYNph2k7Vw8G6jQLtp2Wqxd1O9zaigZ3YhvNTDFnQo2p3s6NQnO0HO3je4MT2FqADxI9wxxYZ9AMC4ZiszBWCk6FyzVyBJB27sApGbuwUsLpsr47qdhOyXf63W2LacteWzmWTuo3bVrdTEW3eISnUrNq8866deITVwa4VdeuzeurpJSM7IgzOpcmzvy5MMjdP6lDayod4_MMWXiHxGjjVw-7qqfuzenwsr2Rh3drep3R7vxbMrfF4-FxIxNQDMT2N7845aLoz29EA9EUH7c9te3vagd6e_-VntQjBo4A2uoBfnrhUG71ihXLnTVrL1q4M0lAcWC2gXD2Apmj3ePZgGd0Lq69oeBvb0Sb3UAPEkYOLQlrHQ3iUtaWhbZtqW1h7LAduunAnu0o5iRmxunfejulAvBkeG6x7iuux646bKe0wTULpH1jD-N8axA4mrLHfQJIRmjdcMRgP-pQYoMfA2FjQDyx6FxBxXB-rrJEGN1GRLAGQdP4INaDJmKg0uosC4h0AShFVS3NnVXqODEwbTJsE1IjzZNY8lXBEyENclUVXYAoDjCsyU6awvC3vebsf3u7WAuKc_X5h-gaGgDAB9QzC0iAgHS9YBmEGkqNb7ysd6UATBYaYbX7RCMa8fF7HyFgACAbkHwBJHBhLAQa9GRoevEiCihNSbhtKKDGsNnzBm_BvAEsFCM_pBmkhwgGr3UqecnQ4QboLABcOH4cg_QLknfjAD8IdhI4TAH2DcnuAief-FgAIPpCMgfDjhhytwQICWaBAtjEyhADM1wALNVmx8BEFqMuG3DUR1qjEYmamaFwySVAM5ucasQAW_QLADYRAxeAbg_hzUg0aaP9gWjC4No5QCWOPg5jSogI1yV6P8Z-jqBQY6sagAjGxjJAyYy0ZmOSq6jmx5wOpjzCrYnDtxjozM10LRGjjV6uAA8eqOVtFjHR-4_EEeNMH5jRAXY4QE2NvGDjNhr4z8cSOjVog8CFkFQClblp983-DhFiGiHVoq1fEH4CKDwDgZ4AUwN3YccGYTRzjupZ4z0emO_Hyo-wPALbL4ikmYT0LCk0IBc2RhtjCxvY7Sd418R8Da3D6Pia4MinCTxJhGtZgZMjyGTTJpemwfnCohtuGocU6iC5zaYJQSp-k-EEZOmj1ThcqnZvXH2RoINCOyHdDuG1y6-MCu01ZnTSP1GATDx7FdTiyMQnHTQJ50x9HwNp6FDqmlsR3yuQaaJJHE1mP2Ltj6bekIczcYbB3F7iJBq4zYFgA8SigUgHgArV4QQwWwLQVARkVhOHHtL_t9gJmSzPPH2AOl5BD7dqGCV3jf9_rSwBDqLOXjrxpZ8s7qBiUKxzw54oHdWciXhbCtAEw8fYBf1Zamzooc8c4GSQ3hTkbkTs0sBF6T7nAbkDpflr7M6oSjeZh0CL2ORnJXF0Ka5BKjgQSTDRIKJaWgD2QwBIgb8ahJ6AzNwJTzqAc85ed9ho79tUwDxdct1ii8dzbi983um3PeLutD2w7Z-f_OuK4df5sXueBB0-MdYooE8cltbPFnmz26c8XePaU5b4sY6L7QMtgvwWyznSts6OfPGaxst6F-wJhZSyAXQdEGgs6lqQtjnylMWes4WfovOBoLc2rdPz21ifmiLjF9WJrG4vdoiLL5h7VEhWlo5KIchTLoWAKigaH2Go38yBcgtwaqNtpwfFJc0ICGhFl7W-bGpFibyOpzmcpHhvkuB7gL3aUCypZNVUVw0vCHS6AdfMGF84i9R7sBr2xwHqqCBmpq5mQPCrUDAq0Jt1KyKVR1gIsiVB9zHZSy6ToLcS7Zf_ARBAZ1xuSVAH1kxXsips7tX5aFgknDcbBMMFj0Bybd-6iNFeijV0KRRDMCkJK3xFvwSQAWeAfK7AUKt0b5T0K86OVcqtjYo5UU6qWOE4BpQFIyofq4wHS7hka6Q1iAPzP5kZl-JKV-yfGrmuOlQYEABI92TrRYgpkyM6GSWthnVkNriCLa9L1l7y9EAxtVXtOxoqWVbYaAKo8HVAY7U0p8jY2rnHkFqpv8ioj_KXESABBugeUvqyyA0ZHnFZ5gaIS5oMaBA4geQG_HbOymrBzAXbZ_CwDABKN_G4waTIwPYGkNEGlUgdh9DemkyaAo-BQR9weQnz5Z7QU2epE4DGjKp5ogGc4ETWOF81BNggETbesnV52llNeGMHBVBta8T4Sqe9YFO_XlxBwFhtkUNFGgopxtbKfJD2mLWMg47OGXdb4ygs2bGQBGqDChhGDa12VxPCzfVvTNtbWtnWzCAwBlTykJNvRPwjlky9KbbDGm0wJYR1kozkYNW07eYWGnVS-ljOVvIlRGGFp9vHrFMkNusYipsSU_GACdm-MmmNAPZArajyjXD5zMBw-ODaNSlxI-t2OwQHjubXjwUMgHlJoqbdRQWudg6_nZRmuAk-J1s6zrbWY0UAC1BLoFHYOuVTEMkZMleVWoK2AvyTUy65nWHzUAdGzRGAN9BltaQHQ3AvXBKHMCSavOSo16zJIRIXNmgj1nYVKWjxiJ5U3ktG8eEXtHAJ74B7OKIARL43s7htkmdnbLugIgeCgkLFcQ2xWZlI4rMcMOzitF4CAttim2nKTsXzmYjthQSrPXEM33bCgiOUS0QF1pS7Cd2-29fKbDlM6OciSdczhJf37bv9kFf_bGhO3cZKtiTK_fx4SoDTRkh6_ZKesb3TDHSa_Lve6CC3D7jA4-9FYNtO20oPdjO_NGgebXKp992II_aWDJgVoNZdoIlNV50nwVF9w1Mw7vu6AHNkYZu1w6dtazceBD8Ww8htuKq7bP9_a3_bUAAOzRLt2UIDPEce2S9gdviMHcQSiI8p-QFfJXIjvyPEEMcFm9ffwnaPMHagCRSLPBWxWiH_J_NCzZ8fZEErDN6q1MCxBXnJHV9mB2fDpPKLCyccyJ_40FSHXUZx1hXgedEd-Pv8kvbazHf8YuPexFdm0esGVAKyFx2QKm-0APoVPQa--W2ZdnDuwA34Ei8AWeDQ0bTkRjCv2FFOqfoA3hXTl6arZ8ZKMBnaUBx6AlBjFAAAJMAAlRvx5A_TyVvAGKCrXawM_fwIs7IXxysF81edjGRGdLOByp1HmhUQOdkKCCUgu1cVAUh4zzHhhQVB4iSgJBNnqIsZ9wSmSgw5nvsBI7c4O7LcjusVuJ_BM-flI34KMXSVADBfVkWsvz7KeJatJFPC7FRRF6k7l7pPTp515Fzk6OtovEAGT8F18_mBZ9oXTLXE8zwSCsFVUKOb2Q4lYxBZvMQL8pEsGCw98VppLrOjKpc04A6BZqRKZS5oDUuRQtL0jBnW2pArEEjgRkSmbTMSREzyZ1M3I_ecHWczwoQOuK9ASSvhQ0rp6Mk1ehpRpnwAHvpq4EDSuwwSgGZ0a8j4mvUzp4c14a4ldWvTXHgeQMUE4G6FtBBIL6bIhhAw2skCUiQel37DdipgJ8b2WcIRKcvnG3LmAN9e6wUvg3grmIKl2tkCB6n9srEPy9cODgw3LT6nP-o6foBzBkAiSHy4TfZuhX8ACF5m8TeJBwX3hvpsM5TW7wi3hl0t1S_LdJu4AVbst17DDfgvUYZxEDFpFVS6hpkz8fYKKqgDVuO3yQE6u0FiDUAbk7uGaPNG_utBwgM0eSMO5oBcR-iIsjN8G9HzoMW3fzXprEz8DL6dnJ1L3MS0qaxMesDzygE86gAvO_YYzGisKQ7oPvQXT755zs4CI3ucTMhRFvgziun4n8uTYID8AYWHP97dzY4FsAQTVwMj_GGAHiDkaEDDCz7juiBmFAyI0A8QKZLFa3OQWQZYyIHhgERkvcBpOQE6pw4OuDSO6B71VEe_iAtu0oeH2SIR8QSCpQY27ggKO5AT7BwXzHgVzO9WeMsIHWdb95VEed_vRnnUj9x1Rk9NPf3L7q96NEA8gfZCU7w9wR6gDseS39zn98-9fft3VsH7-aJLALfsfPcTbnYCe9qq0Q1j3QD2rWFE-s39Phnmsh3QsDtAogohcTHEyT5jgqbZz1EUD3YEKn-i4X4TgSPwFPF7UvsfqO09uGFveB81doDKN3fxM5oqXl4el8JG-fawI88p4V8ZAIpyQkoDbO0Cme9pLIo55LbqG6U3jRQeyG8FTctdSvUzOrl6M9kS9xSLzzQL3IWubcZeAiWXjoTl_ibzQRvRaxz7l_YB2eEg833gZV4QSIgnwdX88A1-ZlJaplLXntO1868OvuvHgXr69DS79EJP1OICsKb-ixXvH2RdR0u2pyaPHSVNtx3Xiwf8fBP47u9el2ne9uRQtbp4h59Y8GfeBZxE-qW3yg2Ec5T3kK1lm4hXdKAmIWAFMnsTiDoAb_CaUy8jvR2vv1M6Y75erUXCcfIkN5y3ZvttSA3inyAau9p9-glv8oH4C6By9IPnvu_DR2u7GSfeE7xP40TpX2CVPafFPxIEA7F_yIRIpj8bHxBQIHIpkePiO0T8WAE_w5pPviGlcqhW34rlARK0w-zuCpUrAT9KyFWk59XEf88WtUj7pNE__ZiT_QMb6TI8F0AxPqj8VBo-F1VfoTjBwajydO_ykY113x7-0pK3vfAv5WyFMYbY_pf4biwFb8MsRB0f58sweT7j8t6Hv-P8Z644F8p3G7daHP72NsA3geqfdxkB2pUeoeRg80rtepRAwTsoAiv-a-wBI87myPFU4HtVIhkQ8TqPvuk0X91Cv9KfSGJVzfcpGPMR_Hdt1Xl8igs-i_kRYf-G-j8quBAkgCf2_1ewFgso6UL77eV9gzXKQ2DhIO0ECziFE_YKrP0j_6If20HWjvP7o_lD8fKnKUi0Bv5EhAPB_S_-lrf55_oP7fj_u0DP-ADlABv-4QIhTZmVrp_5j-itqv4_-L3u958-8tipJYOQAcG4v-0AKAGr-QDvObHiz2kua9onMoHQeAZoNsBM0azkf4U2qcKf6Z0F_m7pX-sAGcS_-5Nv_4P-2AMaLAB8oBAHv-EvnWRf-VIjL5MBCAbz5IIyAcnaABnAVQEugkAYyLQB1PrAFWuxAaQHkB_uJQEz4ZWPBg0BUeutYwOKLrcwVEe_noHV2CvLYAciC4Odb0-SBm55DuZcDQAqScAFj7tSmdrVQJ-DAf-Bk2iAaIF--gvlwH_eWmPKBS-b_OaKF07QEz4HiDbvbyZSaxo4Epwcfs4GxME9mTKHyDgRcLzwFRAv6kIowGYEIY5frOwBBqQZxAs-7QGz7hB_RHQHV-yTi94d0ngdhBiBOjuwG-B67v4GhB6fkEHRe1OFEEIYMQeL7Q-p7ulAZBbItkFHOXUiSw6cygU57iE7Lq4E1-ltvQEzB1_jITMBNQfz4oBEgegHGitAPBQ8BcgVMhD-AgYkDwB3PiwH3-qwQ0FoBqqJU6bBloNgF8BMAb2JwB4hCQESgZAXg6ge54D-hZgpsih7z2JoF8FuSbglmDJ8coLAhbqxLO0CPMSEH6Bn-CJOUGJ-QgUcHLBdQe45nBkgRCHT2b_kv47BiCHsGT-BwfCGf2f_icHiBKIesHygaITBQ3BSwAv4PBtVMwHVBIgbUHeBqAaiHoY6IZkAsAeQCrId0jfs3432_HjLzkhMAB3CdgEAJyE3eH0IcEEhr3h9CIhTIWsEXBxooKG4UQgM0QyBwoFyEuBAxDEDxAvIYrb8h4IayEwUOXJQCqhNwdWTtAAAMSVW03oyS0hVQZqGyhAASSEKhZIYaFChxoaqERGGobEw8h8sJtb6hSoR6FChXoUYIdUkUL0EIkTwa4AvBIDKraUB6rGaLQhAhLCFuBdIbVSOhbAVgAcBpISaKogGQBiH7B3oTIT8BuIYNSPB4wbGE8K_zqdBJh1OFGExhzLGpTrA5QRY6gIodpn7zBvCOr6gISIYnZOhfJtMGxWrYRkBWOqIjY6uIHYYKhUhdwb2G9hxPl1an4krOYBwhyPmY7M8XYAqLecuof75JE6ovMB26F8mr4B8SwDaJ2GWUF5aCqmvrlj-WCajYRhWswdwbiS2RFFZZO2vtb7v2wTkDK4qzNkb7PemsqDA98D4HXaS00muVRjCSso7iDeI8nuHlwoVAyAeAZ8IXRDmxyCOZ7eY5kciTm05p2YY8hopZSKyfQIiD_cgsGlDFOwdFJ4iaMEUhHDmm2kRYYRU5icgzmzgGGCmi1fJnT4RSEPFZ-owRgHzih2phxG3kZKKFDhQaUFDDYwRkCoFgeNvtbYIhWXprIneh4QY6RAgMuxGIgnto2pQOpvg8hWyIfpGBfeuOHv69-o0IBHPc0_qBGD4s1hE7lQlESdTIR5BDRFoR45phEMR2EQaLA2eXveaPmRAG_BHKAPII7wRMTkM7JWSvtgaGODNlHo2WxkdXgqREUJFElMGouE6-wien4GBYLCjnTBuKUbYKBRfEIBEO-4hP5G-wVEShH2RJZnRFYRTEQmFggtVPNAr2k4CxGJ2-JMzzMMxMil764lbHVGw22AIiCnwwVJyKDOsTG-Ep4KVCmSFgFoB3Rz-o0ZqEDRHfn1FxMsDlGDd-SMhDwTenQWbKahFgAig9cksIzYxMFHm77MwofnVKIRc7hVEsI9LKtCaRQrENFPkEDELJ8Y4VlJH_gKcgyFU2EkmeCpyH3qRh-QD9lAr1BWYewBP2ekXSpe2k5PwhJyLnMZay-IGNpANGTSP5AwA24WHblsAgLDHVeCMWeGRGAVtxovcduCgYO4aBt5biqNOH1b3Rj4TNLPhBlgARIxKMYiAIxKbmm6bYVMedg0xfoRr7YxsLr375gwoNTHwxLMTfZcAsLliBpQjMXDHbhahLC4JyjkARGGWrtliAayUsYUQkxEksIHRRjIVwAu2-npLEcRC4WS7ZSrGLWSrgssdpE2ydsptj0wBTrm46xX3kKaLBPmEhAFOMxNFFM4nptTiyRUscrygINAVwDV4UwbrGgEeQGHh6RxBNrEPaCcvrKu2psgrEPhSsWODvRSAe_ZvRz0aRgyO0QJGChxFlPRQLh_8qDEGWjTkLoLhpWuVrfiNytVokO8-rTpgxcPKqCrhcvmE5jgIeCKCUAKASxyPMWQJ7AJIxLBJZ8RiIA-B8ISsvXERAzgAACKphLJZsxWTqhCOA_4nODO8usWDCRINltFE9xewKfCGIGgnADIYgfF3EwA_cU6zDxBsPIBGCTLCBgTx1AEVrGEphBJAIgxYMYSpavrPdgbiojKvyzgtaIkCRgJ8VPFLkb0tlZPubPokCYUcAF9DJIjRmlC0WjZg5EIWBFpWY9mlgOt7VeW3l2hTK96JZDZKVNu_FnxJhAuEI-f0HFztxG2Iq6KyUAD-i5uSjJORxADcUlC_x_8YAmNGgdLeR5Mm2Ewoj6AhE3ZOcgCHkDsAYgBJB6QhmNp7BqyeDgClwUrJGDFAY1OYwtR9ksdBkoOQDM6Lx6AC670sFgG3E0gCKJyYKJi4W_bzsZxD7EWAOchF6Gi20TirAy2DIqo-RgsBbG1gqIvBg_oYAh0GIIWMm0DxSNljaId-9iTghexHdLIn0kMPv9IOaDThHjmJuJvwmCJiqv4mTBGccyoN-anC3G0AO8frI_RYyOjEXhAKiPpaqcQhqK4WECRWa0RJFmhb1mGFuNragEeraZWyCMvEmKC_UgdayJ5ItFbfx4ZEomSwrGCUmzAvUqzHFQZ4LEnJ2zca7i0A9SRtg98n8cxq1JPpL0ksEsoDSBpQvSfogJAbtkMmOkIyT9ybYMwLji4ovifbJIGL3HnEzGsyWMgjJvSauB0JdAJtjMcgsDxDdJ2QB0mOk5ifeE6--MURRhMZMQ8gvhAhGfZJOUcUE76-ITuITHJzGGckwk2yRVLGxDTmQkRAUyAEkPaMQNiDnxICcxZ0WtEfhYVm_2irBdmn2tAmwJm3h3S1eo5jzJfiDQMDpPEwKY3EHWPfK4mOJEYWcTD4XQFV7OQgsdFH5geIM_i82tKQFJQ2aNmJABwq7DkAeAyQDvGH41AH_GL4qEHYC6wDQIO4-M3jkrKgqEkAa4Epm1rInyAFoN8mnJWQOgCuutVIrFc-UofSEqxVNuKlSxQEU8Su2bniPQaioQc4zqhA3hClEioMJalwA58e0F0UZKecy6EWUDmpbxKaCIK6xq-MzwH4eQIUxnQaQKgA7YOjEKBJA2guYCCyK0fSxTRRsam4mxukQnZzhKdkwkyE1BHv60pdHv8lyxHEQ-C8Jo5Dcnv2wgawGnBf0a7EcRQDrqnZpytvEzqpajjJFFpxISWl6BlTri5cAQDjKmVJEqVWlxMIGEX5pQ2kV359S1HgijyBxfrR6jQ7aTfZVJw6VMjFeJMQr68xUYBKi9hSttOEjpaidolw-YScUSq6m9NnG-24MZVARyhRNeqTk6eOUljxzyYlBBJQsCEkZ4gFLL7d6bKvVRFktOmHblS_8E0IJJHlqHhJJWMQdjR-xWEiBFgMwMkApeQVNwJJUvsVYCEg8Hj8BTAUNjkAsAXQFKA6MXKdH4aMKrHfFZglAjv5D2bYEEDm4z-OxSJBOQOFag2zjMDGXYxpkHpMWDZqxZFJC8cVI-kc-uLppJZlhBpcWe6ERYMZVwJ-nZwlqnSZfBHhsFjvpzLt5h8ZraKUnQUeGl5jiZRQncyl-9pAFgE8kAgVCcgPzq-HOO8sJrHNoAmgTH3JuKLNIGW9NukQqxABEkYJAzjJ6mYA-rMh4UCXMUzHds4QNFLupnHvp6BuvjjrHCxqMQunZwfaS75O2MrGUm1SB1oLHwO8VAH5x22mf-E98StsBHHO8BHYLfhkYN5nMxY1qK6UKcKtDEOZIsb5lmoqWTzElSQMSQ6Kp0Sd0A_BcoF8FAE-wrjYPaFWfrL9pCgkFn9JFSXzGjcioiaCWBMZKXbRZUsV26xZasW2qwySWXmpu2HWT5xXRpVGBHjZwfoCn2yLWRenU4_8tpCbhSotuFlJIWDBEHhitl7HZSOAMeF7Zp4fenEOOsXGqYxQmi3KeZ2lMTFvJkVhTGaZv4fmkSSn4b75feakhdGDRulFk5YgOmZMKRZ8TtbaaymVvbwTpYyB4iyoXSXjGdUABOia9W44ANYTWdYH76-kw0XgATWU1jNaLSCdpO7hky1jd7gReqbR5--WaYiACxUAL9mTuv2V26yJ-OZKqHyROfGl522LsRHhZS1MTlGBaTogCtpxLh1SyJr0j4y9pEkP2mUeC0UOmGRQufTnBxLCSOlDZndtoG7-0TgVETeRaq4kYAb4CSxJGriNelCJsvKlL2SJwH7BwZphnQxNs5gAVkrB4clXGMs4hNdYCkQHk2GqMzqZsCBsQBGvZoaAgD-g5ArcDvFLAOGfiDHgDEhZL7CpDKVlnJTPAw6ogBjOQRGMU6HsirQzubsCu5ZDnYBG5oedEB3iM6ERiwu0UTvFDxF8ely_ZKTrcys5MZD9lKyRecYGIABKTcgbxmTmtbOYfcd_F5581IB72qjeQ3HN5rOZZSD2qADoxJ58AvIxhBKHhe4uZPbHSBRJvyS0BjgNuYMkNxTcScllZROaFig52cBDkL5vySJxqA9HFUkcJEDOGEIkwtLVQL-Q-V1l3uMhJAQr5a-T8nKpn7pdQr56xlflKpzcjpGDpnviTkwAkqaNBVJZzHMz_JD-RPljs-JKQieYniVvG55w8aulK-kco2F5uIEDdb25QdBbb5p86VMi5xy6btlF-xWUzYzJc-T6Tg5ABc3IZZf8nCpp5MSX_k4FIKXgWUAj-WVlqRlGWHh7pUhP7Yl6amqUjISf3CGa6aA4hGZsIBAB4DVAhsPRCSsYAJID8F3gKuLXc20ofrWeBWqhDPIBmo6Jm0sACMlho7SRSD5cZqQIBJQeHJuo1gJKZpyuAYaNpAzkTSKiTuC4oBGAusBhaoVfUYKG5A6URatYWXs15pIC3mNKPTrBoBhauKfKn6p2D4SBaGCTfKRwH2bmKN7EFoOWD2r0ragMSvTInibilEUxFp4uxZ8Q0umrA_aDMqNpuQ_WnMrpFJ4skVigI6Ejq5Fbikei6gRRbEV8Si0rYW7wBhawTZwwJrpEXmuEVeE0OkET4Xpo_4vZiJA0eJwr_RxgqmlNFbkQYGDFFErF7kK6liMWoA_XFgp0xcabF7mJ6zm0bSYiGGcSxeDZDS7CcVAMKA6QrcR260uAkceB2AZ-QIRrFobhW6toWxQIA7FPSXsXCcpRijnXR1zl8l1oF7sjTjFqxfArrF5xQwjbFBHjcXA-nbgcXCcdTnGn9IpRmCnYFYJejYjWpRpJIiguaTQ5wlOVlCXHgHdM54X01BCiXdAxULCVn4CJbiUYAJEVkClGaJVokn0QcZWoPagpqthiFWAI0Up8wNq9kXmxmtbEWAlBtEC8ZG6qDDJgCppQYvq-BvqY1YrgPQYclTBqjySmq4Cwb8lXJdrYZYyjkuHlUrkdQDaYyfMZraYpRiTwbqYMLCU-FAsNJi3o6AEuoqaFPLoTQYDzDfn9kUtgIABeQbtnD_4NcevK6gOUCYXGalkMKA2lvygDy5wXYFBy5GfVtgbxAksKnatFUwlJTZWHRTwRv8Gpr0XyGdfpbEXmrJRiYvEopXHhRI3RZKXClH6lcAWgqZV0XGYpBi-q5lUZRmX0GL6jmWdFxZXGVWl3Kn1YQAA1jAqo5RJYLBERY4PqUPUiOSNbtlnABjlgRPjFiVNlgPFiV45oVP2Uwl-pT4Vc245TSpNlrZaiVkRLnlnT9lOJfqV4lmdASVE5WJZ2SwutOAOVDM_-pgDDlfGNQQ7lI1snwkGyZaDzbUZ5eyU5WtOMQTkRdaDuVtJF5nQYfqllNeWZla-BLkn2sYauAiyUAAwwSQziUnorMh5fXndYPpcjZP4lgT0zcqDDCNZVWJLABVzg_MhJDJgRkDc4Ik7Luy7Hl8FaOAZsfJbKKZ015QWXTx2lLOD3lC5bhVzgz5QRWZls4O-UvlUpWRXIV5AeaTcU73LHBRwDSTvYlG0mDAKu46kbv5MV9FXOCQMJFS8QMMxUMmDYwSkBUTaQvpdBWaegZVYHlqVfmeBOl41I0iul7pSnE2iziBX4nZ6ifjxnK0mNqVTl2VnqXHgBpQqbJ8cpdXGs87TDNSNInmLtkHZZ8MHJ18G6o3zk022WAh58ScIyJw-L5DnJHKKLL-k-Wi2adk3h6BoURAq5qrikRWXyuaphV8BiqqFEImqIZ_cziTpGg8L3ODxjpEkINKWUnar-XEF_unFGB6CRbkXV4NpjZZue7ibVTHh6tIlGipjIjMQ4GqPD5W_E3sZlHgViERN5Kl00N3mmlo9shkWlglPvg2lqeLEBY23QCg7IM9Jnva2I8frAX4yJoS0SkxcmjexTEM-fbwBwuCaxi60yhWMkNJU5I0YCwG1dMTZSi9P_CUQksPCBwAJKU7Gbpw1LWCTJiUo2inV0ss0mNoyySel-JuOJskHJJiZkAjAnhb5HJpeNsxrqFBhXpmXEM9uLDoSWhToVyOrgODVkoBhcHHgVF-bDUA8NdLwmlVMhBuk9p6NSYVw18atjIGFbtnjWCwSwKDAYpmhkF79EFNroaYAzNTIRfoxJdJgc1AhFl5_4ysk8TtAhDJqS81LsfkAvQrgGLUWAWfNulrOPjD-jI12hUIIluXYCYUsElAOYVn4f-LODU1YNeTW-Roqb4atq-MZpUulG6m6XWlKcfrWNIWNXLU7pY-h3TnKqRYkUMyTxHVW1hPoc7H9ENosfLVFV8PYXPwjhQDzAKmhcrXPwV3jEyqlWpWKVWIGPBanSYmpajyclqPECVPEqUcTX0sUir6ocqfheyyMq2oEAyvVZ9AuXbUJCSTQ0JTAcYkMJCClFUpphfqwmkKdgJwnsA3CYhXc21fnzaR4-CZJL046dmIhqJuicJz6J9LNAUfQINZtinhUNWtV8QklpMUIGmPKjxWVC4KnAsltEPjEG1gsHUWSwj4KeEd0qSfEzO1WReNqu1J4gN4e1owdTiNVi3r7X4VhogN6yEzJRuoP1NDknVWIA3hnX9EY9VfV1onVVYjdVnYPiVCwUhfdxQAT3OulklTAasmbY_iRdCCs_4MElnpRdetEJySQJti442deyrKSKVQXUjYsPsaUo-AuUxB7EJha5aNIOaXJasKGoqUXlFp4lZYIaZyuQ3OmLCplhUWPjPJRtIj3OCrq1wRsS5D64VednrJ_6Vk4iUPDbcmBWLctlUA80ftpAoe3DBlajZ3DRJSD4SjW0izFDTqo07ACxT4wOokqdX4mFStntWRi8tKQ0mUJjWCi7RIPLjgFVfdrvA5pzxelCiN73DtZy5ZxP_LOVu8B2EmFRdeiXEs1BE427wDCEFX8kf0AY1wBJLAfUxMR9dkVpFsRe7WqW9VcV5L8mjdsArpxXqv7bcoTejyr-6dV4mTBFJXX4r-6hbUiBECGQ7xXwV6OY1qNIJQ04BNWjcmnXSKTXYAdUkBE02WNg2NY3h-J1HU2pNxVZnT_yWGCQ0uVPTUrYRyvpurzKArYtij067hRrqWKriNYp6apvGwhI2KNgiC0OR8IvC2IpCLuDI2yjAFB1wE0BADIYC8EvA7NRzchggoFzXeCnN2zSvDXNEvlvCKF4NCdUs4DSTYUEACNe4BI1Y5OHXfWqhVTVelzzcGiB1iQMHV011whtLSFaxlfixQLhW4UBaMAF4WHir6FMrJInMs2YFaa5jQAbm4cARLIxwaElB6ynKixKYoHhX6jzNuLfXA-FQRXEjkgcJEEWyFkWhYrhFxho5YJFkiOeADaXGWhHxF2oNEWct3LTxZoR-RewAu1grZYA8tLMl-bnIAyuK1ctkrcK3StoFqK0JF9XteKotaRR2Z8t0Req2EB9gFq0AWLKiYZVKxGvkrI6nZlrDaZbiqa01KW6FDrOAVrWxZsN9vO-YStUrZi0DKbrQq0etY5qK00NasO61KtiygMoBtqsEG1CWIrS60pFx9XMoRt9FpBr1K8SjBrJK54usoTo0RXeLagqWp2bxB8oPK1CtkbdK2xK0GiUqpt8yhm3Za2bQa3OtxrY5YFtird2iIpYFvm2xtgbT62fmzbf63ngKsAJbhtHbU20dmQvPKC9ovbVrD9thbe2ZIporS7XptfaFO25tcrW20Vt87c221tj6QGhEadrclqJYDMvO0OtVrTa1btJGju2paJ4vu2WtPbaK1xaXLTeK2tJ7e_rnt0RQe09tSyr213tx7ea2PtF7Y61XtFPCYBFARgOvK3VMQbABEyvDnYCQM64GXA7C0mJ_BHA-wN8im4roG5Iy2yHTi2d0-UmLY72aUg4KVR7AEB30QE9j6AWAwAIpy0QMnFrQOALNjQ7wdewCkZHA6HT-WEdxHXKAUQ5HTdV58VgBnZMdmHa6AA2mwNlJZeZknnXpQAgopzCCvHYpxKO5gIR05yZHXhy0Qi3tTjgdumSl4aMPfMJ1odOpDsKTAgUpvh2MMfu1KAdfILnjNcU0MB158oHR_kYAEHdVIY0RVn5W3VnRC8n6AwOCSpC5DnS1Yt0uNL76gswOAPqednlM3TL0rdITGiWtnbpkeGqzj3y3V6jfbJuWtuimgeOyaVdyc0HnYhp90XOLC6JdNAIF2ZdRVgjRTUnNAPot1_nTqQkq7pOl3TljAI755dOpMxJC0kXcJxAFYeBhADhMBQyQ5yqgBB3MqxgKYCydgBp2BTIwaDdFjUhAvDb06rKf-CAdgHewBEdQsCR0UQMohR305i3o9boAc3Qt2ZAbHcADkZUoLRCWpjgL8XWGfsK-RkoRYCd3mEdEM3b7NNkmShbdrHaR0rdw4M0RrRr5IJ1Q2LCPkZvdj3Yt27dHHbl0EAcAKp1-wfucIIaM2nUsh0QBXS1ZEgNjJympGJLX907dz3R0K0QAfHYDKd03WbboAAIcD2LovwC5IIMyQHh0CAKPUt0KdEHId1cdAhIlIQ9gnZp3nAonVD1U0FPbt0DCNPfzR6yEsCPQfuQFRWwE8mDCOBjUCjHs2o2NqQgyUgejOYCgsrRUx3s9pHZz13M_gpZDY99qPz2n4nYDj3-AhuKLBlKgsqr3TdVIWwTfIuwrPb5ADDG5ALgyTFHCxsDiAVJydVfsAC9JSner0WAtzL0lepdKfAyIMliYQl5gkHiOwXd8jMCqbdsnaZ2OVLIGNQjdZKGFSxRrCmSjHdVxX8XvwD7FdVUc3PaD26FpHbkAXVsPVrRnSeQhLBsMLBAEJB0nRJrkEJKeGj4myvxLH1-gflUvFHdwgCn2ndRfVn3NdMndgUB8suW6oZkHdbzbBs3de0DnxXoBgD49dgPt1p2Lma4CAi0APuLPEsZNN15GIndOBvglJUO4292gqMlvNf2cdWsa31WajuVGfQX3fkd1fnhJ9rfdcVp9cQnnzZ96pcX0tovgmX2WQ6elDEJAUyCMkTJ31VMlgN8wK_hRwIyQuHqur8GShe9cwTgk0gNdQQlEJyaYlJf9R_RPVo1GNbABY109f73WJbnmH0qSEUfTkzE-tZjVAtWFcdkssmCVX6xd4A99V9dAHYN0T2ksA33dAkDPQN-wAglpSWppDLcxVeYLbvC4YnYMkBTV0QDgCzdg3dt2U9kbgd21RqA0i2F2UTYJ1g1OPfpVDdBwjCDoe7KCaAaMAA7b12AkXPx1HAuvbcz6g-vZIBG9itYuKWpivex2KdDInABhCgmPEzKY3TvfiCdOZrSKuIfHVmDNsGjAoOS9AUsHnv4YUjxAWCKg14OCdCcv2AOFu8McDSNog090UQ0_Yd1X9V3RkhhEF3ZcU39GTO6C3d4YM5AWDsQ_92kdHHaZSRDOwHDXhUXsFNDxAhUM2xxAxLIrJ72pRpQ4odBg1ABmg6AMkBh91ZQ_jG9TlrfhYMMGaREEd83fJ0SDBAG73u9EQ0HW8DbQ8fgZAaQIhkxDBHZH3md7TCwOMDKAxDV01Ng3YPHgpfar16lsAMn0ZDZIIbQlD2wOgN24IsoMNZ0fguX0wVXdme4umZNUQPERLjTP7D0_hIQNoD-NarQfDXwzIOoyINH3080Hw5ASjD0brG7_DBhR9QRxNdN0yIOVfvrGvBrOoXZIYzw98OAjoNFbKT9jWFJ7mRMNYjVh1OhfDXqFPzcKB_NZqFCOG1f8qiOpAgLYLA01hI0rU6FSwOCM8ubtsRg7DecaFRsjMbmainhdqidSIV21DnJIjlYcYJDuZwxTXAd4A1KMh1lCsQPQ1oQokDhCeDPahJDbfeYQv9-w_LqnDUw6UOLD7APD5V-3A-C2uANAwN1DDB_ZB3KDDAp4Rz4wguwN-olg1T3Pwq3YeFY9ynfIghqq9vZKqS3vf4MjgiDJ0PomD-KvCbAxLDakujHHdkPrNS-nEzejBwM0CxjZaCv3AEF3dDJdAKTFcXYgU_b6OgIhUH4MEZc1coO42LHQUPxDMQrRDcNefB4jk06UBUOsQVQ4jaxAZ0MZHweGjHQKFQ6nTx06dc3T126ZAUpkEGdiDHnDa1OQO_i0MqIOYyDDvIGYBR95gNaNlJqkqul3dS-lEahNtY43G_EaUO2ohVVfqlWeWgjbm64xtAHpl3JcVZKoJV2FvbjJVedYeM_p6VTl1XVEVs3JqqmartVZRnbPTr6yo8jij4AP4-b7Q1-Mn6h3gwURRDsuxkSVxzZRybyprloE4kAfOg2cJneYs_F25qxAkdiA3e0BR_1TuR_bw3Cy9OdBOxpDTsZHaN9vLPwoozcLK6ATS1sZGg0ZPUY14tQPR3190PPc_0q9AQoFW2DKo_YPr19cMFiUTEoM3A-xUOMAk0TGulMhUTitq4Ka1OLZhPwActSmOIgS-vF011azWWjBoYKZ5wJ5O1BwMG5KeW4zxAMw8bl8QkAIw61UIshwOrYCEx870T7TXlU4l-2eLmR2a42SjOTXacwnWqlqbwlV9_CcKzghhWDj1U2ykzADBoHk2onWTl9cgRL8oU-FNoY3tSMT39Xfd8o2WtZOnVO1tk4ggAR9OaDStdg2GSij1eIx3R-TQrLX3tAFkLATTdIU9wRuTeiAlOj19tQ9qoYAtRTSd9xApMId0NY9z11jO428OukxXvNBoTOUwpGRMPQmFPJTHUzNGxMmTeDVbj5NCNMgqhpU1Npd7UxB29T2vUBWKMd3dKG1gLU_CBtTbEw_2ZTjRJNMQdqU46lzMOjVQN79fafX0WccfR3QJ9sTHFPuTLfckO39sTFMRPELE9n0bTiUx9BGppLBdXFeLExalP9OfXEy3Db_aSW1U2NbWB8uSA_lOWpvSfDPqjrzbgnIDlEDgP4DUg5sO3Mo8cI1fTb02dPNoqU7uM9wyGLtMj0JM2tNkzJLQwg8QKcb9Nd9_02omRT7k7k5rDD01vLFeVIxC3vdOZjxOqjA3tDMDer040Qajxw6DOczho_0RozkiqxmH1Gog217ozbefUJNntQmP05Zqn4XoAuAy_WWpH9enWj13icHTBxH1dMmIze_VrLID5iZg30tuddOD2dedbilF1VCgS1koRLalOKuGkypMUtpST5Ng87kw1NHphcu3j9dc3Qf03R1gPwIkC8HkxAvAi1UH0Mp2CRwPyM-0w4he57oFpCoAPcAwxRSBTAwwaMqEHN2xzOIJgHKDz-BwPom9PaCw6MQ-VpQKNBHS6MJDrkzkNhTF3bcyhTOPV2IcIDDFgCJAAkJd1XFE3TkAJTJnYBYLjMo1vISzqlfSoHjnGgTG5ukTcalVV_LcOiWQGrTlqGt54LVWaz7c3GNkofVfLVk-40_ZT6yt4S3L_jaE7C5hBF8z6T-jEkLyOxu987RMJJc0eyxWkg0hdBvzkkz6TLWhpWNNOBlgd0yHk6UH_PrIhMubgE1_TXCpLjkCxhyr55uPTVzzWfPg0Wjc3V0AUgksPGOQM5c_uTtM8jInM3AgfXkzuMU4_Qxv4IfXYCDNnuXRC5z-c3OCFzmMOYwlzswNGPWDCU7B3zwzdrkBcA-Rqfg4LOJnON1tD2tguamnc2JBo43CyZZUNgeqO1ct47fG1rt9DdRrcLDGmItQ4tOqlPxjaOHItJegerO3Iq0Raov2W3EBxWT4FwK5LkLGUsnkhAXYHmBRST-O_hhB84ysPR9vxM-5L6ltagVkT-4wqUPjohBFVCN5VMPjKdcvT3y5w8DD3NRjX44fOaTXEeI3fcVsP-Nzz006PqTkS44tNYqtwX7NSLqXHSrc6ZetpAPz8AmjhRLyg7hrfp9hi0WxdXHRLk32ZPWLTc99BfCoaiHLQO30WPGZnQsujjm65ah5FDozRAObPiDg96nYJ2s9GHQOOsDB-EPluSjfvR1qok1AiRhBt1dn1-1ADOf3Wd2fbtOUd35DMT1LrSyWw-mZAwX7cqB1ifn12FfuVTuNXiwkA-LwoH4sMeCBEUsRFPacQ0_oZS1yrgNNS1lC36k5NRlht8baOY9L4UacuGJEc7QNDDpNIgjk0t1TdEpziHUcCNDvHS6mLE_8FlBbATSDtTMQB-JL37Cgi8GPI9g3VylkMLrDvbIrrRS4h-EqHZMvi0xk8JMdDJLUv00Ce2ZwvU9VS-LQKi2dk5YWgHBjfhzU6nVxFFjeYO_hjUm9tY5ljlku4wSd6neWzRDGSJPNiL087CugI8K3nwuzh00VadEoVUvOXhddaeOGWt4bC5oTr46qqZEN8-_PZw7MazNPuXYGBMt-MLnxgvzZqGhOkYNTfNmS509TPzWraUMNP0TTE2f0JC_q9asATedS0tsTQa_BiFuBQestd9oa__M0-ca6TOKTp9mKl_Q1nfGtTTemSB0FBuy2cT7LwODMQsTZYems7KXfUlCOLG5dtMdzu0-CpZrqa5DMCEMa42t0zaawITwz3dpWvVrsC255cCXYJ3WdDMy4ItNzZDs0B-ucQBIJ_Mdq1WvoAjqxM70TrDj2sHCbjUrNRNKs8u0graEYm1kaKbZzJptJi1W05tzgPE3WWWs3u74DSTSutZisTJ_W3e5JebP3W1o3SmFgI62L1gA25UROUYeAH9P2rROa6vo4s6w6uIT4cqFRQTP63-tzrfa-IT_yZxEuMQbeIFBtdg_yndm4oaS7VMdz648l3rT_6wuvV8Za-KMENZgJHODd4oEuE6DFgnmF-ZUUj-hH6OQdDKtwXzGSiDxjIGQKK9e3VWMqqN0RoyTrrVCyC-YHGy92WprGxkDJAkLIJ0Q8KXrcxjroCFt3ydbc5EhwA54IKAiQpfZcSKi-ErYC94ksBpvUbwcljzQtCGE31q-NqbvwsSyqyBiqw-04kD2UePlkAHDMAKJtkCAsJzTE-tdUTMPaQmVtXhr6yL5tILM0bjEigxPmlBA97m1271uOsWfghbq2G5vMwlbgO5ZOpskZt6xGmRYCAbsI56stJh4SeN055S7rE5LQEbC58u3Fe1JL6d4B5CYb6zaFssbbG4kAeTkmb9UNTRUHHoHWNqQ5OFTwc_VMuTDU2AvxLc_UwiZSTTkksiCqJPKoSC5W4kCVb-S5_OveBU7ADWNF3SXnukssyzmmRiWXxjBxrnYTaKO_mTfZt2oVANsL9E2xS1EFl6Y0LEmo3SW7z9Q2wUsRbvEclugNXxP7E2JNOP0u1UdG9Z7-o1ns4wpbV-FyaXbq24YXTdzm90W3jBIY_7RbWDqA5qoWst7H4NIA3ltjIKW-KAMgp0I0k-kKW7NurgZSSlshZoCFjufbaxlc7_RI2dH4vAwnbcx64mm0cAQ2YQMSzSbmIFmP8bINiOyCdD1T1xQMmAKFa1lo3FRtqo5OwT1U7_O98h07LKVFK7iUmPS0_QT26dRHA_8UB4iy2mw-p6bAuxb5p2Km6fCrV_5Yggo78AEdw870oIZtPbwOXxAXuxaFQB945aHwB8Yj2_Rte8aO8D2zbuO6A347ZgqA0d-m2QhEFRJ1Ki28yGLWOYiujZZ6yYVyWXbtfbqO0dwPFqZIXTCjVBMpuqbs7iplAevjZA4XLjpHruO70e4WDFQc_hUSQE5uwlBW72cFxS6EQBNgwH45DJP1QC3yJLsxA0u6bJJwrTM3DdDwuzTvpQsUicDTQuWAuJvMJoMcnCT1ckcBd77QJ2xj0hRNxSbAXQJTvmAnUaPYWdQBETtCkP2_HN9z7gwIJXxxe2wxm5NgDv61DiAlMBwMQpILCM8A4AMD9AIkPHuq7XKjOy4jpdQYxAEhDNMAkMMmxODFGs-0XtyodgJUsspE4M2xn7eHpfuO5O1EbkadmO09uR76O_p22Ma-8_iW9WIEhSO7f5brsQH-uyoqyu_gBbsdsS9gITzQ4e2saQHTuy_koH9G27sCARm57v5R8wIXR-76La_rOAgdBirgH9u4Qf3b91k_sHq68u9ZS788NXtuS-QAkhIe7ubS4oeD1bS4kp2-_mC77-IPvsGMT-8OO2MaIEMje9Bg1ZHkAy6ONBCkS--wA2bURkZOxsNO3fOy7jS-7ssHaByTBL7gzqFSWHgo6NBx7B-Qnta7oWw3bzlF9NtTD4i8CaElNtc0fioeKTPvJEgAtU9XYy-aiLs0bbO90Ac7a7KexquMNTTvZAKW2lA2HYMsAq44HaGIfwAJKUjlVWDjTTXxHhbk9swbtVLYDX7_vrftYVxU7VSVTGAIkdtExzXeCh19u0sCpHv80XiPV9LMrtQ2pR_HLG79uyTv751ua8EMUSO_7498me0dzAjeVPNAtYLPmMeoHjux34AE8nXcya7am_KJhHpfTpvbxGx1LawEKW35VB0xS3wweLsvRSACA6pBhqEACR09scsC8wqXUZ97ea0vt2mWCtfJjhyJDUUcmDbkPE-4qUfLe0cMQT2VRx9KAnHNGv_RGb6BPZTzbTm3Vuub_NOFu6ri8wI3RqqXVlZnjyS0Jqwu2M444rHie-ps7HnR7ps7H1RwUf27BsBJDWbdW1Cd5RVciUy1bYm9Xhhb8WxktS5j5S8tF251Auh_j9OmKQwipJ19sd-oKgEQDZZagiSrzr5BqKPHtSha2_tLxyLQHzQMz3wXrKaXgN8xAM-d3Yg5m0wc32Zm5_bqnSpDBHanitlQdqjMTGT1GnvYmT25N3Ie8fplk0T8cSCfx-sft7XWR1SEn2xy6fXLppwIQH0vx2EdM4fO-3vvuXx5qEkn-x1onw7lFW4ewbcKtPZCwFxzHTXH9u7rrAMhx-8s-MB9ERLNE_Jw9zCSQRxIfZSFDe_L4agelKdbo37c-2Xt8sGotqWZUvmfYy2mM9P5Qmixu1xn5x2PTnJDxEmcyF-i5Q2GLEUDe0dK4bZ-3SnFZzKdWtLZ3-rsNtOt8t-ZaOOCrhkTjtnYarz9O_L0FHzURQGKLRSJThk3eGOIYnUKqks8nt8_CYOLhwoSXyNQE9X6zZJE_bILnrSb2WRBa3XMGbW_MfEs7nLfh-eOke59rSBrR5XWhfnPyutsIO7h86lXpZU2njCOMhrODyRS04HTLZXYLOcdh0du9JedgDIBSVHXk443y0m1kPkhN7IpcsFBMZPefJr407kEgedy52DeLXmk8uIIy468v5NB-Y8M50OF4RdkX-F7hdEXHwxYCAXlp5AIcXB1rfw7MLFzBibWPAbs5_QYl0v7CX1OLxefzRziReK2bdjJcfQcl3vJnyElwRd8xp8j-g_5MhKVM19kF2TgFAsFxarygr6_iBS-H_huNaXitmEFZ16689SbrMTRO2NtCbZZZz0Cp0k02Wil6OkDeYQbNOcX40wN6oC154Jchn8TDwGBXB1jwEDebdtFf7bijqLM6XEUL5f1SikvvLWnTno-tEb-cc6nFNkmhNBlNzcyIyyq7I7xdwAP5x6swTX1aJferddY02SXAWSLmv5Yfi5O8XOaZZQDNny3TpJrUYB1cMXQxywX-m7omhDti-5qdL3IeiIaJcF4ZuBB24_AJtGsQ_AFcB6YYaPwAaWK1-wD8AjwPzhjw7wJ8CSA8dtELxAo-KQgFA4GKHhZm1yBpaiFi8B4DGw1G5ICqw-wA1GSAwAMFDA9ObNsDyA71zSswA8gKAQeAYALNBg13ALfsgA613TBn7tAFtf8AhALcD3AjwGDWngbIJ4QPVNimLiRAR1_denXtgDYCzgl16IRZmfkBfvnwUQE9f7AJCDDeKTkN-sD8AegVteD4DN7MAYyJKS9JIAmdPwBK8KuV9Lm2nN0BggAjg3DcgAPN7vCq5m3d-DiE_AAmRM3_AMLec3Mt4VT8A96xYD8AxtHLdC3gmCLca3UtwiTq3YKJrcK3VwAbdtIKt9Xjc3PVBaD74MABLdG32t4rei3Vtzbd23CgICergG1ydZK8GVpzcM1CJJRD8A_MY7cVAtAAkAvATIJDfbXIAJ0Ei3bgKHfS-Ed82fiEAdyoCS3Jt0LcqmuFELBeQUdzHeO365ASb-s13PwBJ3_t1HdB36dytE53gd3ABD-vzJzfNSqt_XCB3ad1HdYyUkgCgc3SwDXd13y1w3cfuTdyncV3Ud5_ATAf8WODsbkdz3crx1AFteN3q4Aqae36Ls9Jy3-t3TBleq9_0T8AKUpvcxM295gFqh5Pb7fFeibKmauAkYNt67e0rQd6yCR3jeBeGOANjDcgdN-92n3n8JGBWYn94oA5HIAB3S8RbeDMT8Agobvdb3OgG6HKhG1fytcAEwFtd-38TFDADeEMNjB_3TxEA_gPQYYfewPJ94IBn3H99_f4PP9wN5v3591_ef3z9yg8d0aD5CFCh7IaKEc3YMMV6RQ-gsV6YVsTP_fGCZpBbcgAvTiA_U4VD9Pa8PAhPw9GhaIJA-r-WD6_cgAFocjafrL9_Ez8AVoYZj8Af91omMXRG1DdmZAtx7d0wWQGHew3Wj2vdRjx99w83AdwA8BPANqVaAiA_Kx0bW3-NwUAWgemFDAAA7PohzAfkCIBkYmmpFCrwO_AQAkIiJpamzQWANVBYA8gB1CJA1UIkDhPAkNVACQcUCADtB6t77Ai3J0V5DS3IAJalCREd1cCiRsMBk8jL1JPXfp3VCNDIAAlVDAKQkUHpit-wgAgdLAFT1U81P4Os4BJQSwHeLngeyA0BLAgiJ4z6gE97EB2AAAO11gMm83bcAVTqY9I3kgCMCzPp4HU96Ih16qhQA4_RaDteqsAlruFUAGhBqoRAHACqwgqfgDEAUAO0BiAvT3s_CCySJLBSArgBIAkB8YL_fB02mPLeZ3nyoI9R3Rjww8mPiN-Y_-kfqFY-WgSMTlB2P517OCOPLj2493AQoFjdfArAD4-6n3wO0hkowT6E_hPkT8ADRPHULE_AA8T_wBJPmTyk-O3aT3I98PmT4JHu4W13k_u3fGPwBV3Bj0I9kvf0sY8I3Zj7teWPJwIC-2PkAKC8pA4L6495wHjzC_ePvj5qf-PriCtEivMACi_AAYTxE9RPMT3E8JP-LzE5EvdUek-GP5L-FCUvYkdS8fQG15kBAInd-88M3zOeaP0vMhEvdV538TXlQAItyvtTAQHa3Dt3hr2JCQeB-N8ZAmLiNsDcAekMo9YVXDyq_p3Zg8KB-vnD9o-j3eAOPdogZwua96vIAIzexvpL7i7V568ba-O3VreeCboQw4-IGgUvWPf52ZAtIzNwZK5gCnweAKG-3eAb4S9BvmhRW8AP2j4KAlGxr_G-mv7z2rcgAyb9a-pvdrwuLZvT4oaAjAePa4CqwPwKrAn7MAAc9aQXd2cSWvUYt9ISPsTEPet38tw7el3i7-XfLvIAIO_Dukt93fR3UFAuAi34GFWZJQDkubcd0S7yLeih5AKgCqwDmtXf7vnIiLcNAySPYD3oDgFkDaCk92u8xMl747flAMiKrApkD73nfp30GBLWhGs9yAA_v_RH-_p3lKarBlwZrzB8yEcH1Hejv47yXdN3gMxu92vbCRzcofAhGh9K3TdarCJAR94R_U4xHx2-_AY74S-UfOHy3ci3UQLOCIfOplh9PE1Hz1y1oHHxe-4fjt7YCUAyYFh9nEvEU3fJP8wCLfBvR97q-1gDNxPahAzbwm_Kn7b528NxNr7Hc9tmb2UpAdObwO9DvqsKiIT4BXqrBQ2k7_4DqvoD7i5zvdwAu-_v_H-ncK3DH81AOfUd9u9MIu77ncHvab-nfHvS5me963670x8CfmcLe_3vU94--Hvjty-9vvH71oI6CvH5qHUfAHykBAfFFRF-gfUd-B8KqLO4l9Bfqd6k-j2iH2aB5f9n8F-OflAGO_Rhid9h8uf5X1HcuYeQKV-wfrnyR991ZHxR-1fuffV8bXtHyq_Of3XwV-O3LH6l9hAMD9B9dfzd0N81v_QLI8DfU38Pc13QnyJ-1UYn1W-Sfjt9J91vKH_wBBAAkEp-tvib3G9qfEQBp_pvWn1m8EpVQKrC7Z2DKrBAhblBO9AhqsIQweAMsg5rLy-FY4Myrjg8aJ7fiADNAdURADJAQ8uvVmOsQN32r7J8332D-j2GoAUAjvgmH98wAAkAD_VkwP88CHCtC3D9CurHxDx6fMICj-WfFrx28nWNn_Q8-eSX619a3qJRN-ifkwet85PUd1t8kvcb4U_DcxT1Hfng54J4j-o0kMwi23VEsKCFAjz2G80v3DwoiSwFn0d9R3ynySyWvKbxvGafKsFm9GARCoQzss4P9QA_zsP88DUAkPyPj9vYJ8wSamxPwy_WfaJBT9wPZX9N9R3Wvz3CS3839R_BK4jHsjva2Seugrf13gz8ZPgb8z-1vov8uTPPIAAHC0ABXlV4ugogDL8mvBdoLBtvbdydaK_Pn1HcZvqvwwuzwaXhH_T5rP0m9k_lv3Z8tfPXzT81fnH9T_ufQd3u-Zf_AH5-nvuKee9U_Rf9e9hf0QCB_efz76-_vvIePF_fvk38l_wAgH8B8Zfbf47fZfKQJB8BgE36X9F_CH0h_NfqH9T8Yf1X3P9Ef1P418Efvf6v_4fHX8v9Uf1P9oKsAdHxt9O_1PyN9sf438f9F_3H3N8b_jf4rLCfdP6t8-_hj9W_-_yNWb9yfIAOz_5EUHyU9Lm_qLM8jATEhh_ZBhZ_EmCR_bb73rRNhgAZiAHfWP5mvFT4J_BXhJ_ZX7afbyT3fC8zq4NAHPfV77vfaICffK74eASH7GiAQDQAhvCA_BdAkAtMyw_PCAI_XbKdAUgFo_DqiUAmVb2_IgGTgMABUA7H40A1j6_fdgFpmAn4kAmAE5_Y755_ZLhW_Pj7T_DgE7_Rj62_fgAu_E5Bu_e8Qe_Llpe_GQhrfX34v_Ra4B_WT7tvcSLR_Ft5wA-P4K_Lt5K_YO69vR17ugbYDbAGYCGfQX6JQd_4iAhXjk_Av7z_Iv7KYZD43_WQEgAeQGKA1izboT34P_b37-vDQEbfGt5v_QP71vcX5e4bYAIIKxB3vRKAZAQESc_bagx_SuxGA0n5IAkwHJ_ByAXfHT6G_XN7RA2IHm4eIGuIRIG5fYQEf_C35iAlwEr_Iv6aHKACI_Wn4X_LwEYwF0DSAur5eApD6qwdeLbAIgCqAgQjqA5_6hA1_5jkCAHB_GDBU0VWDcvAm4i_ZU4SfJn5aA8IEBvZ0bMvKZ7mPCYE4tAF42PRozoUaYEOPJx78vdx7QvLx42iPIxMwLvb9_VwBegD4LA9SQB7A2cCSvOBA4vJQAyvF4HRPPF46AqO4bA4HppfS3ZyoZt5-_RYGjAioHq3FYFfPFl7TPb4FwALYFAvXYH2PMF4HAyF6CvE4EA8M4GqAG3D5AK4FQg8fp_AtVCPA967xPRQCvAokHvAxJ5cPOX5ueWd75_Y-4N_LwHfAyH79A6nBifT4G7fG4H7PFJgzAAEGaAkAAs_ZYFMvcEFrAx4BQgmEFcveEG8vREECvY4GHXU4FjgOBDogl0CYg64FU0J4BsFP1AEgl4FhPEkFKvckGHfBAFUg6oE0g_L6LfEAD0goO4cPJkFqPIP7aPKEGqwPCBcg4YFAgkN4ggxl603AUE_PIUFsgkUE7AkF4zAvl5IgqUHY3GUG3A-UGXApUE4tfNgagfEHPAokGagjF7agjJ4Ugmd4ZAxADOAw0E2_Y0Gmgx34bpZkFDHKG4-3Bh58YFIFeA3m5Y8BwGy_XUHy_eN6s3bwCYybGQi3MW47AV25P_Bl6Agp26Ngvm67vDJ7C-cIDpAwIKX7Tb4FBbb6RAhl78edIElg2AiYPR26KPaKDoVIcHmg-9ZFg40Eh3BcAJ3MsGpA4pwy_dt7oyGsEkpesFW3ccH83ZsGkvVsHEvLh7RRO166PVcHOg7sFR_PUE8g1oL9goN6DgiIEwFYcHNQDJ7GgsUxZ3I-46gwwGbg2X7VgrAC1ghxJ7gpTIzAC0AHgyW5HguN4ngtV7Og88GO3L8FvPF8ELgj8GbvCN5RvSe6_gtIH_glm4zANm51gx24Ng7YBNg4IFDAhYHgATAJrgumBKyPcH5vCe4xvM8FKyd2JggIiFsETCGMQjJ6jg_8HtvV_ziPNMHyPOmC0ATkEVA_ojW_bHobXbP4v1ON6lvcb7FeGWov1BR6RQGADJgPSBGQcgBlg_ogVWIzDyQqO4WhSKCuAKGBgAIyD3_F-qVPHSHvddt76QvSAwwbGDIPUSEyESzAWQxbxKQqp5gAPSBmvF-pt1WMouQqR4KQdACRQDwB6QUyG6Q2SrOQ3LwKPBSCuASKAmQjwCaQmQgYVcKGCQq0LIwSKDJgKGDxQgQjOPSqyKQvyGWYdABQwTyG6QgzBJQuJiRQiqx6YZSFzgj6D2pD_6v-fYAQBfiHp3ZggIIPB7_RAACkcMEMwnUP-iz91QelEISABYVLCAkLKhKgDlQIaSyAmULe8ukLjeiFGzuL4LYeL9XEhynX4ApzAWhMTFqhAhGTAL9R8huXhigukIGOG0MtBb4NI6aEOY-ucyj-2EI3Bd4O3BQEN3Bwd2Vu60PE-BLwdBA0LTeTEKli50Kbe8EOYhPfC-hbNBQh2mEXBm70be4FDpeV0OkauEOTBpgWH-nx29OH_1uhwEJwQeHykkc4OehrYPUCXgHehGTwQh6d1Bhl0Jxhv0MQQ_0IJha9xvB6QKuCdj3YEIt2AAjgwSegD0yepuGtuIEBqBpL1FA0QhEAI4C4Q0HnlgmpGqh7AFqh6tyZh-QC1enNwqsx0JQ-wMK-h6IGohiYNqoeEIIhIEIehqMKehjPxFuO9x-hn0OG-Cn2oh0URYhR9zxhOsMBhq4Clh2sKFgoQGV4vUVlhFYMpB0ML1ksMOT2DMMRh90PTust1VhIQIohmMPgwusNohZsJlhmsI4i-sOlhin2vBfgQphTMN-Em71phgmHphSYMphn11Zhcb3Zhcxi5hC-HYAvMK5I_MMFhjMPgoIsKZ-4sKwqnwNNh6dz2-1sL_BN0MAhSMJEhrsMeh0EI_-rYI1hH0I4iIt1LhAcMRAQcMdurcKLhZ0M7hKP0thaxjLhOELvBLaXthT737uEVxJ-zsMIhNcJVhdcPbeGML_iWMJ9hWsJLhRPzbhQoT-hvcP2-ocKaC4cPgokcJphdMPihQsP3hLMJGhDL2ThnMMNwacIzhhACzhDMMphecK2uBcMGOYv0BmPcOahkv1N-zoLlhoDynhSsJnhQCDRhasMdujcMJhK8Kju-pCl-07zXuesM3hn8NkQ0CLGBJsI_hkCK_h_gH7hdGB_hNsKTBI8OyCc9xooTsMrhLsIa-tcLIhLYO5BXsOxhsCN9hCCJN-0vybh7cPgRaCMQR38K4e5MKhh8cKxEUcPt-XAFjh8sJzhloATh58LZhHMPfw3MJHAt8Kj-onwfhwsIpeYsNYet3m7ha92NBggMoAg8OuhlYP_hyMOVhQCPdh5EPVhVEPXhqT1IBy8MDhzCKgBQgOURDL1URpAMwRMCIZev8JJ-eCIdhM7CIR-EJ3B08NIRs8PIRx4MoRi8O9hxiKJepiPXhHcPg-ISPYRYcM4REcO4RNMMpS8Px4BMcOPhgiOZhAMILBsTH4Al8PERN8L5h60IUhccLkRosKuAL8KURTzxQRKiM3eegIhhcfyhh2iOrh3iL0Rc8I-e3ILARNCIgR_ACqR4CPMRxMMduegOsRpL2NBRkHsRGiMhhw8JOsMMLHhcMPcRisJ0RgCNiAwCI9hdrwCR1CIZeuMKjunSLaR3SLk2vSOohHCLvBXCOphjt2jhUQH4RoD3jhZ8PSRe9xAAWSNThPMNyRMiIKRucPkRxSMUR4oxOhXNy8Bof0z-sQKkhCYJwRAiLqRKMMaRviJghLSKMRjCIohXyPD-PyNJhqyKJh2yPTuUKJABMKOQRhYNQR_ACRR2QFABwyOwR5cMrBLiMmRjsKTBgKN0R8yP0RFCNehVCLMRpOUdumKLx6KKNCRFiJD-Gf2hR7gF-RZMKiR-yJiRhyPTuxyIBuySPORaSMp-GSOuRYiNuRkiPuRq31kRTyKKRUUFeRr4Mlh6KPAA8QBiBlQH2evEDKB9d2qR8AK0RxCK8RbXzJRTSPmBhiK6YQSPTuhQLVRJQI525QIhRYSKjuFqLiBGqI9y5QP6Rcb2NBDqOKBTqKSBrEBxR2qPSBBKKi-UyOJReqIARDSMNRIKPrh_iI0CKyNJeayO3uKqKKB6qISBzqK1RXSKYRPSPNRCaMtRXqJtRXYM5RlYIORwUiOR9QMaB_KIchJ8KERFyOFRVyJuR18LuRmcLyRAsOlRloCfhCiIlhqEIqRLcLZBUwLFBIyJqRYyIV4utyDRAKJDRsyI-eUpAWRBiMduwDzNRXwO7R9wJF-tqKZRcTmoh3ELvBSoVoeTX05u20KTBSoSahekK3mlUMnQySMDCoj09C0D3LenNyQeDMNPRKoSFC-6MihlViUeT0NdRH_wzB3aM32_wNxRQ8PxRNdgnR48PhhW4NHR9SKFht2EnRFKIohM6IhRXaMmBn6IF2jKIzRUdxXRzoLXRlYI3RIoS3RFmBvR4DwfRUj3PAYkT0gzj21AJ6PQeZ6ODCF6K2u16N3RpGLvRk4PTuijyfRaMNfR7b3fRsGM_2aqBu-vED7ROqNthuLiHRRKIERuLgPM8f3be9rzNYPELfRugCXcsqOWhsTFeYukPlRQQLvWEZ2DRHiLuh-qMZhYGPJRfiMpRyyOpRFEJtBcGNYhS6MQx_AGQxkSN3hEmMDuUmIFAyTAMx7GOMxlDxUAUmNbRVwF2hoDwXcqAAtAiUlGAb_h64CCHqR5R1fhVoLRRnaM7h3aI5B1ENbBUGLTRBmIixHCwQxCKKQx1YVhRpLycR5vz_RWmOHRf8OAxOt3_RRqJD-wbnSB6GI5CFPx3RAiL3RVrhFuFoUsgW82ceSUBuc5aLAe1Dwge56M4Ml6Lcxj92wxLWIweuGIYxlViYxZSNCxNiM3eNoI5BnGPsBzoIXh0aO4x_qMyxuSAIRE8Iyxy935Bl9RluG9wkxLGJcxzyOrR8THkxlkNJ273XYeqZ0ZY0yM8RoaNAxC2O0xcbzjRJoPixIkJMxSWLMxKWN2R-aKBm1mMXctmLSAIt0ixDkK2xi7lcx_0X6hnmO8xn-BGAfmIyAAWMWxCBROxiqLCxJcO7RdoKmx3IJixmyJpRCOMmBSOMexrEPTu5mL-ReKN4x82MWw0OLOx6mIuxmmKuxBWNQxtsJKxdDy2u5WNAelWMZE1WL0gekCSgkUBvAAAE4SMT1iyMVA92sZRiusdRjecbRi-sU-jn0e2igYUqibQXhAJsa4gosVGil4d-jNEYTjB0f-jssc4iTrMJirMevcC3CJjJMQDidsbJiYmPtjFvIpi1AWiV-oSSj07rrdVHhGjRMbQi50ZjiNQPpi7Uc9jjoAbsd4fsB9cR9ivMV9jIUS7i_seXdtsbKj3MST8QcT5jwcScQocQBjJceUiRsT9iDXrEBO7ghRU4A4i0sf8icsWpiq4aBCvSOBCXbh2DwMTpiKIYhR9MYniO7ky9scQbC27knjegJXiMnpVJE4R_8RoFND-AFM4VXv1DeYS6AYeOl9xCPi9qcU5jGoVVipwZFBnHtwk9ML68g8bS9U4ENDN_JtiP_p6Rn4blC8sLZ8REfExjcdj0w8e70IYM48ZobWBNoTEwN8cp01rnviBCDvjT8U2iL8UfjFvJzjpITIQIYBlCDsTVDdIcdj5vtPjpAhEZBccg9C4fIpmsEqjnXsnjsQL6j8cT-jbYdbiR7s7cOIKRDTsYsjg7npjZ0fq8K8bTcq8eXiXXsgSG8U7Ym8e28W8VPiQAO3jCXp3jU4D3iRfn3iLMd7idcYWio4ZgAsZEEA4APIAAAF2t4lJHCIy5GCQ2tH9PDkJygZsBu4DSGNo_JGahGW7LIpzQbeGPRCo9_ER3fqFUIm5Cv8dL4IAhl6L4sWHL4roziAp_G1ga_G5eBnETDCwBhQi_EH4sSEX4j6An41QkCEbSHm4-Jiv45_GahSb4Vo6TFM_IGZxvBQnFIpQkuELAmH4gwm1gTQlaE3fHGEy_E-E9QnxMZx534kwmP493oWE_fGW4pzGUwvNBqoaQlUiWQn_RHAAhEyt5cQorEUEpmG4YlqFtQhSA9Q7SHtQvqGREpmF-AReD848b6dY5h4CElJFosWnBM_fwm1gC0Cm43LyHQ67z9QymFFE1CgZEuACtQp-zZEgwR6YHqEQwPSCc4_IkVEymE8BfXEOEykBL43SFK3Fwlr44LzuEiwBb49XpNE5Tp6EmQi1E2JhGErQkWAFYmLeNYkCEDYkxMW_ELEw7GhEl_GwzYLHvI4uFefK2HK40ZG6o7PEkIy25gQ5mFZjQvHXYyNGvQ08GxYkW50vcgIJGP0yTNAMyWwZlo3sIFCK2Q3j-iOa5DiD2D38C3iBwMMR1wD5hsoO9grIG8wQpOBDIk_VDgIGcQQgS5SeKKrRhoaJQltZNpltcPTrAQjTVKE9okk4pRNKX_QUk-szDKOdpGqdYC6qVZQrtFkkbQH5BhFGLTFyQZbxAIijWxKVTbcJ3Tp9N7pXAUtSZ9Hjg1kXmyQqSMCRQTnHZQwDid1OUnqZG_i0aLWgikhIB1cbNSLECUmwyOrgQKfUmLUYRT4KBLK8EOriVcGlTGkt1SWk34gNcCKCSk1rg4kVjRiKJ0mTcVABDcb_60kQrg2k10h1CB0q4MRVCVyKHKN-Iii5wEgQSKOADb-fEDdYBeRnwQ_zEsX8xeKc8DKneTpMBHzC0nWkLeYbZCgEBJrexLcpxhYljEkqDSkkuklpk53oZk3uqAY4NY6kK4C5kuqoFklWyghboCUks1rSnGknkaZJQVk-45Vk3zAzEHDTUcQhYUSRsnto16RH-RFQck5U7xVPOqsYULBSqXZyJ0eaCgwETJ2sKVRGCMGAPbc1TPbYAoNkhJov2e46yZaslEKWcnzg8cnEsNkn6qKckCsK8anklCbVk1aizk3iIzk6cAxbUsad-DADu-UXKe-Quh7k6yyB0W1RfRXhxarZEJ_RBFjiEZY6rkhzbvkiBCFkqsIe4msIQUqvyCbOvwm6O-SWoGMSXDbcn1iIAT5iWkRP8NLiPsHEQsiB9hDkgvi4UzwSlZcTgacSTg6kovS-k4EQDcLrgnEWbjOk9riMU5rh2k6lThlDimdcD0nk0B0msUj0kiKV0nJcISlAkL0kjcMbi8UibjAnBDwIUw_Z4gFEl_wJ8C4MVBIYUv-CGKIMn6oExQjXbXjsFCxrgk3sSQksMwm8GElTAYMRwQUMTW8Q8QOoO9h9mT0TnwfsggoLEnCoOfgHwNEmuFDEkzPJSnYkmyk1oXpDVVOJpitZdo1VdgBhtYoq-aFCSstNcL8k8nL-WO3C31dKYRJHRpgoYMlGWUMlkUAUlVyYckfgEfTRkl4A7-OMlTQffzzARMndAIKmniacl9lWkYrkzMljsJQZ_ksai8RSCn1U2gAnhQuzYVc8ndAF2q5Faqn4yW2q0jJqm_EINa5OULDOJQOaNIMFIskdHhLReuw1FfGo_zHOQOoM4jpkzUL7sRpBPEDakLUgWZf1LdIIkVqnHkxVYEzOCkUBYlgRU2Ir9UviB0LbIAmFPRrDUzsDiUOxrh9c7Z8QMal2sHKqBZB2T1NfKqzUnIABEG6laVZ6kHkt-z0uI6nQyLqlvVOJwcMA6nIUvCioUvkn9kTCnWiAHg4UsUSrgPrjegKUA2Jbak7ATBCwbVGmaiGISMnROqr1GOrkUiDjV4aOrJ1YERY0_vBueG8rVib_hnEQipM0-kQCEFgyilPCl0iGYjMVNmnw7E-ZScOSlxOCy7KUkOBPgZymqyJpAAcb6lNINlC6UoEmjXWZrrIZWlWwIymLNbgrLNciAXNW5rLwVwqUzXEk1gb1qTtbjLrAVWbBtG8Sdk_daWAQ9YLKTNqfaE9ZhoTpYm0tCJhoc2lFtJLQeXGsDArLpagrdYBqtHbzbzA1oLtN2lbrLpbqzdYCKLPtoqLIdphoMs7jnHtqnrM2nLtOdqmLWOnrAeOljnZ45hoQc4ftKklftXdpPtBOnVnZwpUoHk4xUh0phkhKkyNBRhjiFLyybctCRgOgTweDbo2EYfBsrNfYzjL0p59eTI2pGdQprdtYzRNCYZRaPxlEDKR0MCHpcReubJAIfKhDHBgcLEhwTAKtAeMboCjiCWBCwZIApzbSDmMW5i82NKTv4bYA_AMYDg9AlbFjAIZI9PWbKOfJZL6Tcnqkvk4pbDQS2AVY7v8Ru530y47IMLM7dnBcBakwYTVxJRQpYo0AnHK-SGWKunQU7ZCdEAqleSYqkaoBMlgRI_zG0ty5EWHslv2cEYGsBVRKqVDbtUu-DWrf1APUliRDUFskhUly7brYtqlk2kmlKW2mVtLNonrK6nfjPq5znbgwnnAQhK7BNYSTKBYALPBmCnIBZrLJtZfJVhmBEY5pAbKaaMzWRycMkdZzrEIiB0YaacM-yY8MwenLrKaZIUhUqoM-VRj_DBkqqCLA4MghlFkiqkbzEhnXiWhkiddhktkZ-ayqNBlqMlrCYM_8BoTJYBueUGBiMw0pyElfq30jujBYPBn0kSM6w05RlmM1RmKqSxkaM7Bn0MiBDaMvGxH-d2nuXSCyGM3y5pQPBlBrNKQzxKCnNyYaZpXNWJiZHADRM0SYZnHBmQRRJnWMnBn01FJmOM2Gw-xQ6n9koxkBbM8lvVffbhUworttF2ksyQxlmrUxlcucxl-M5VShYd1awbG4RnjaRkLyOqpcMlqlV-FRkQfdRllMyiBmraApAUapkB0reb6tXebIM_HjDM9Bn-MsZkJLf2bYgMGC5M4dJ1Td-C5UvMnWWQ-IhMs6k9UsOmTtZtqGM9sYluPpkJNLhlBrbhoXdK5klU_pl5DV6l2SfLZg0jpk4MwraGlc0FExN5lgDaRY1kPpY6nP1DPk66ZgdB3w3VClqu-L8mOTcYAeTDpihNEOaMeJi7pjCFnEyE6j1EkDyUDelD5Te5kLbSYKYXGQg4sv7I5LVSadE4ClP2S1LzhGy7BoJzoUtClmbealn-yQWQIsHMHMMtrYjbElkZLHWJNMgSZtUvJlBM-mr0TC06_M4yrmAD5k5UiZmnU1QLnUrT7R08OlDtQxncLGJnXM6yxy1ClI9XFfpxMoiZpQQDafMoJmxHCibZMhJkCs_zbRUPzI-xKCZqTei5gpIdysXd5lHkgNa5TMVkxTGBZZbaE7JIH-Z11V5lCLSRbjUMlBvkuS7tbGFn7RaE6LbbraFVabpeszyb11foI3CaXrBoELbFQLFnRTYCh8JCC6YYBNnwHUy7N9MlAxsz8DFeYNkMs8kDAUiRaJswNlYOcClWEyBokDDVm6EG6lrM-7p_SBEgiydJbBGLZnpLXiLcLG1mWpAtnT1HWLlsnerigMABJsyFnpLXaKwszrb5VZFlRsvtkos_ogsJYRboAEdljs4mQpshFiX1dtkeGYrzBYCdmMsvhx-s6XqrsytkeOAbx7sqraJLZOTfRIdnZAE9nos7AAByKKCR1AYF24xljwzUplSs_JlNs-MaQ0whnGLO2kLtZwBRMv6CznOlxHkg1nGM8tAlM53oQcr9lBM2aZgcypmEM-OnPHYDkIjbxktM3xmjMnKnjMjs45nLkR7MuqrF1Zlgockc7lnQuk_tK1oLMiVlwc6Cm9OT-kEc-slqs0Xp_snRkOAd9rDnfOmjnSjmVnWU40c_llHUhjldnJjlF0eBhsc-Cl8wGGkCETnyTQhGmoAVgobIGZqItVtDq0kymY3Hgra0yma6085oG0p5o1gaJRDmUUCEBSwDiMZHQNAF7S88IDlEkiDRGckzlmc1OnWcikm2c4wj2ck5BHIcDA7oVdodmDZ64pJOk1gDJJrtXznagYiyUMvtBhoKOnjtXCzecpFLBc_zlRUlTmUtSooVrNpjZUqHI4xFmxZrP1AuMjvAs2XRbZczqhTybOz_TYNAxsggxLqUFjJmbNkFLMrk5c4WkAMhcbAM5dapc-KlgMyMkvkSBlFU3MmwM8yITklznGc5JRmc-rSWclWBAcwxmgsLLmAs2sgiMlOJ4MkGkmVOjlYMiblxrLiISc45k0ZZLSucwbnucxzlrtcbl5cklp6LTqgzc_vBzcpRmg0xblaGVC56zX9kys1YDFk_rlucjzlectOmjc5JB-c_bnFc7cZzIfNkCLCmaCM9eh2sSrnfcgNkpIARYnc6Bkjkm5k2pf6ZlcwOhGsrXws2KrnCLUrl_cuo5UzQHljsYHnigFHm_cmBbJxU7ksc34gKTdYw48yRZw8wjbU4TzjFNcVY7jSXrCrMSCirQjLn0o9k71O5mhNEHlL6MrmX2fxglcvHklcQLJnET1nes4qDY86rmo8mBbtdejjzskyISQeomU8_ByHk3JlLnXnmc8_nmzTPnmQpARYq85piUAMnmUgCXmwU5snscwLlDtOLkoWFdragT7mq8-Fb8881aLyL7m28sHnm4INYy8gBJCwbM7ezFlaPMjVB1VdnkjAHlY28tah28urpmIJ3kwAMrnY7WqjC8uCZu86CDIxbIBe8vWab5GmTQcGXlwsOXm7Eo0bnchbnK8_7Ka8iPkCLWaaB83Xnh87nlrc2VndASLlqwaLmvczsxxcgTmSs6Cli83HnO88rnIcv-QpY6TkumOGlycgNQTNTXhK09sQRMNTmhmDTla0mpCWQbJDUFcaHwYPAHBFF2DtwVCAWgLECriSRYKiFOB7kViToAZMAWgSRarifUBsyT_QXic8BQ6as7laIdDH8lWBn8rFqnxAcyEoGpALmafT3iLCK38tTjA9Q2kWANrSWmTpSh0ly4k6X_nOcrdDH87_QrackkGciDRHacdqKwW7R7IMNBP8_7Qz6T7Q2crdBmmJHQAC-klck6FBaabpDJcviAToSyBJQOngBKPAJ_aAHTWxe_SoAbUB9AFnZyGXaGUChSQCACaFjkWaYj4afmMC5gXaSQinKGfhT-AWQw-uXTZvAWIABkyJItcwUmhlV9S6YQfCaGNzGNnNmoRQMPH9qTwl2MIWD8CsPHxSUQiyC1cARGF5GlQuIzxifTDhQjOr9yOXAX89LQbaE_ln8weSnqUwWH8-8RX80_k9tODTy0YeTKQIrm88ngWsQH-kBk_-kKUwBmTQViBNcoqpZU1rlYM8BkdcmMlideMkH-OBkPc-1qy6TpSN8vslZk_oiNydxmDuG9QI4OSBEcm5lSMEazTSLACTyDIU2CogDnqAwWcMqRjFQMSRDyAeQi0FwWYwEQxjsE5i1Cn_FlVUJnEsF2oYCwxk1qQTmhYduRHkvBlistak3-AVkzECnS1UESiuC5oXDqMclVMvrnACiwWgCnbScya3n6ALuT286YV9A8tZ8QT3S5WQFiK4XaYFCooW1UCoU-IDqigsdYWCyMRk8QG3QFSW0K-snoVueLZnjCkYU4AAgVEC-WAkC37TP8mYip6Qtb26RnBfuInmPUzQwdMJcncGSdQAi7oDMcp5k3MzQyHLeQXd8_ogyM-QVgi-BhWeO1iTqVEUwi33lwi-QVNkmTmVk7MnHks4gvC3ZiZCjAjZCvIWkxQoUtC3_IlCsoVXASoWPhGoUzCiYX1C0wV9CodTq4QdxI8zwXUAJ1CkC5_kxKZyI4AT_QEi0jnscw7S8yaAWnabpTnaRvmXc7yDvqaIDPqFIA4iqHnWWDvntC7oAICgHSVmRUV58yrn8i7IV7OCvn3c1smmmCHToChIWWAQ0WjCgYXAiizbG8yTlHcJEUWJXvmw3eTmKczlClICSSj82a5mUgzTAOccSxmQWDxmQ5racoeBbNPWkXNEFBt-c5B7mUAIHmKa7_gY8z6cr_mQCpSw7mMNAZJeFKEWcBI5JZ7R5JciwFJMNCKWCyzKWIAWi8OjKm0iAWcWASy-teLktIYMy8kwhpB2XIjek1jAXNMKiAbBMXngd_Ld9WsALJJIhKyE8QxuXHD9iwcWfOMcUxuUGhf_GkjHpFI7RRUSQQRLvIGKPkmEUcpDQYBSlvpYyz5Us3ygyGq4LZTzbYFWLI3gyY4gXVrY32C8XO8SGngVWLL8eS8UhEO0wHWJ8V3iiSIXMEIXu4VoqC2UMbSYOx4KCRfolXM8Xl2U14tSMCVwAyvK12ci6vixK7E2DwzCOE_z01U56XBZYqCwQUBU2EGgoSxgBoSw4oYSnGRLATnHESkiWkS4iUowbCYGMJ_D09L4Lv4I3JD5OfbdRL4KwgK4jh3HRjSQbM4yrIfJHKABlJUDKpsnG8V-BYBaxBXHwTeMILq5bajnioSV9gpPbFBG3A2hJlhddOGlI-NCkpc7UKhCwyx24KWSe4UKIAKQVA7ivmBmofsVyie_I0FX5I5c0chSSPTiFc9YASZCyUhATsUjcHwVBqEWmNcs7KgMsIXtcu3Cdc2MndcmIW9cpMn4kj8yVincwgckYBgxe3lSyJYK65JgjYQOsicMjSyKENMg582jl587SXV-CKX3i9bnmWGVqpkjDkXctKUGWDUVTFYjlZSyvkbc0BKsWe0VHU99LFS_ZmsciSLVM6JScZC2nockUawcvPl2SnIVaisqUWi8rRwWTJIFikqJFisiwUWK3k3kkHJ_5MyU35e8nL5KaUEFPURuMp0WDMpXkOi0yULS50VvI-SlSclKUqqcOYD8qZpjXDTTqXCiQBi_via0kAAFxdYQpk0_DMQEhi5MZPCn4NymHiHKVGc5wCyCH8RMwBqQlUiumiC9SXiC17hLyJzBABIQA0EltCBQerl-CtyX-WDyVaGcIXeSyIWQ8qYo9cwhmvS4wjvS0UDVSspmNMGeR1S0qUSRaGm7SlCn98hTl6UxmC6AIrQa06EmX4a7AJSCzr8IKhaDODdr_aHbSJYe9BqwRLTfiCSBQwPSBDDDCp8ypSBAdUwnpsufwrVaNpQQNmSPiJKA7aE_nnaSwCSIa5TDtFmU9tDp6i8c8DfiYfCiyrxgWLMBiy7Nlj2lNRjugboZSMWAA_oIUjcCKCh7EacKWFXIDwHHoBuhMDwD7bXr10-nTiy9gBocntC9KeLCHID8Rey5JS5S8wVZaeWW9oZwCSIZrw3jcSJsQXQgaMT0i1RUrFsMZNSs7VDKRHJ0z8QEYDmAMlbeDDDEZMc0BRSdTB14m_ICdeaqog6fJaLHxgeyriyey7NoJaNKB6YEjZl7Sboa6OKwnhKWhDAL_DtAaCh-MCXxEZOSaKU-BieHVJoBoBRBcqXMYIMCwTk9MuX28D2XxtZWDGEB8Qbocgj9KBIlMPdM728BeWQ6RxTuc-OmSIZJAttZMDwwVeV8QaeVdLbNr6gOwV7IbdDywNyCSIU94SQJB6HyqYC5Fc8R6gG2kBy4_nByzsxhy-WA3jR_FuynWBDoRcxxYMdDniGcw3iUcwiRcXEmlTRgZXZa5RyuOV0PYQSWHQAwmhSTT_7E4y6FZQS-AL_BIePwgaMSLg7APMD2_aA6I9asoY4YIbmMSw5uy546ntNLTkEFWB4BYOluQAdBpQAuFuy5_SJaN_SF0wOVf6UPRgClrS3RP-VH8iwXX819oSQffLD4L7pw2DvQmgSTT9DeRjDzU2VSwBBjOZCcAGTbvapAUICLdPQBIgG7ZQUcXyT0ltkbtf-XcKywWiKqKC-vHWXHU-uXpwgUATgDgaiJBhi1zaoS4-L4KyKkcDGy67Jmy4QZwKm8AxuagBq-N3LTjeBgfYHPicpZzJuSKgBCwYliMbI2WM9UYDfIE2UTA216Ty5KCboDeWnIPwHGKhwVn8hdoVtDPIsK0PZwK-cQE9XJhr4BQ4kKjRhnYdSRnjRJVmy0hii9Pul0QXemLuKpUSsatDD4cBhSMeLzCcEfBRSKikvWbpV5jBIm4wI_ZVzYebJgCy7P4QgjWK4eYpeKGD5qNDxgUZhbNAeZWCyJB7vgSfbyMEfJECX3hjiXCAEQIuVF0OkTCCavYhKn-Ay9HezhYAkDsJIuXWKuECCDVMYTLJEBzAbxXMys3nptExWviExgVKAayP3B-V1mWsXgJfMVQJXUA1mPNqTPd0GAgb-JqEE65QABdGlwUQiREGSCuFB6qSATsCK4NFXxSYV6oQWaAUymRDcAKZwIJURjIJPZCitSqVwpRCxBc7sygqyJQ27PzwQg8x4EpGFWfwOFVighFVZQJFUpAFFUZANFXoADFWzACADYq0pBTOLFKfiNyC4pdUHvXMJ7vXaJ5hYVgCuaNloPaJ-UJtSWUcyLmTviMVVuKBMimwMmVsFMFAoSe14YSKmVBi3pDqSWzBaSBflDwZcQbSGCQAaJDTryBM750LDQhFUEmLcQ1VIIf5X7SK-DSjYBmiSLKoWNUiIbtM8CPmQ0RiNHoBziC1VhUL1VNIJwoNofsjWNCxopHOFkkwI6KfoIaob9IuQpK2uI52SYrq1IMDtDVaTmqjaTaSZ5ohq4Gzq1MNCy08hS_U6ppfU5NVERYvLAXEIgbi9sV8QGWRpAcaR2OWACvMOKxQwAxZbxf1CSsyqCRQQcVpMiVBQwQcU_vU2SbMzMnDq6aJjq8pATq02SGSVhoOlSqRlq6gB3gZGj_XR7hDVWxng7Hor4MkfTXSIarVkSAhDVaYoDOe6RV-TRJZOMYqG2YEwXqsYqaoTbA42PpxYKEhRLOXLYUTfwBvFPNofQU4q3FC4rX9VPqJufYr3FW_InFT4pnFQErpDUDVAaoErZ7fEBPFf87pQV4rLFK6zDOJ2zAmNYpAhBiE_FTUYZIF9VC8t9VHDVPqYrEDWndbfYpdH1kz1aeDSYMjWndbZxdOL4qwayjW7FAErga5YrLWZmCv4hvwg9C3Sk0l0A1bY8CMah3BVC6corbUTXsas8YjWM_DchOtC2AWVDI0RCgIlUjUyazYoaanclh4ODWndNRJRybDU-qD6YnkZYp-xYAqlGMTWuYC4kxMHOTqa4zUqY2qgRwYzW30mhzt8n2KB0a6RvqgjUZDWBa2awzVmeOWogYN9WvuRMrj1bzCxeGYh4a6N5OM4LC4ajAEMQ_FJaaz3CGa7zXkajxl1CzjVEiIGaxa6DVAaxLUfTMDVZamWaHFZLUKCX0T3FLK5f1CUUAa_zUzFfKbBa-BSw-HRJV-BrUDOIRSdUJkoMlagAPqonKD4YLB7q1cBjFT3BYKHrX2VZrUKlIao9alKlySMcCWQQUjq1TtXhqtaSRq9YC6SO1V90Lywbqi3RpUplZLqZqxa0KWnVq08UPaV4qAaWskFIKrr80EnbyoxYphqy0rukCxqq0FDU41U7UF0FpqvFCSgI-QUj85ECYyyV1ISCsMofEc7VY0AejT0ZaDV4M_DKEZ2glWMLrg6xqV-WBJzlNeFDgkubaSgWrhI66aneTdHhT1HORo6labCqCCJSpGZwOoJWzyAEwqqpK6Z8afNJAzFWJOMiwAziqWIowOnW1gc5Sy8SYrS1GQi31ddWTFLdX8VHNSy0htXL1f64vs4mqVamJjTq3bG_vXSFL8A1wk6vhFd45Zwv1aKKGzE1KIUDnVpRVVDM6j6BSBcjHtYmgINExbw66w-40BEnU5NXSGTfd5GwfaXU2WWXV_U-QBmFHFrFAJXVKyFXWB6A0LUPdXUmCJ2xgwfzyh4KmwheSIAMQ8ficQagztASpwO618BdUQhFGgFSr7EoNya6tNna62nGchK4D7Q1Qnu69ELYBaiiBNM3UHYi3XzfWqEbpHOTtqorCnSOMno6_2xNI-6qayDKKzxTqjmgwoic-Fe51-XSwjSdDSJnIGlqyCWSGoCNXFqr-Y1gNbUEAR1WYaRzrryLbV5q3bWVqwcn2q-NWonH9Xp2AuiyuDUnfkGMjT6vujXa01a_qwSgWeThoPatRpPa04kWkdKAF7X9Xi0d7Vb6lSjissTnJKnLp86xYiha8HZXANfWFdUHWlWOHUIkSHXG_GOiL0G2hv6yOrsuFAyI6v7go6q0ho6qWmY64_Uk6nHVV-PHVvVYCYfKQnXsAW3WBNPhHD6q46d67YAU63ZgI698I06mvVpshnUcRJnWJ6qCL6idnUv1LnVO2LbW86v7WLEAXVKDUozC642YREzUIS62on2EwAg264nV26tA3IMBXVwAJ3W6Q5XW6Q1nVq6l-r8eLXW1gI3VehJwl74o3VZ6-UDSPZGye6t-FxMSb6F61alV-EvXwScvX_KQ9JV6gdW16tg2HxPraK8t-zCYlvWeq_2pNIRbVmq-OAragfVngObUPLOCSnSLyy8G26kWyU6R7a26TPSCLD4ckwoXSBprWqXpyBGu6RX63w0tssw348bQ1l6yI27M0I1eG56R0qBWmD87XjtiE6VTFTgrnS6EnGIJD6CFYQpoqs0CriHwHu_QsXroN_kscD_mHiNs4eGgjmYrM451GxjlGbArT-aculti4MV76GgAH6UBon6OVCfSnAVhIf5XRKYJRuQL8R8WUY1fia9qccyY1cy-UC501WCzGslVZi7tBvSj6XgWT8xrGzZRuyl2qzG4dDNaGsWWAGuVLtFy57G3tAHGgswJaPAXZq19z9PQWCj4dgR7iqyW4zMpnzFForppbgxGZfdImZT6L_hcqRFbUbLRRUqmrMAZTpqjMgiacvJ6BZ8U5AXnKQm016V5cn4WBJtWinQkUKlW9VbSpBxwmqCWc5RE2rOJljD4FOZu5dToFRU9VjZbzjZSZUkspenqxeQnpwgTtwhAXRXTrO44oMsq58jVOK5azLW2zVWhCjVcBzsb7V8YK4CAbQDWcm7qSbYLsagaTgA2WZulqZabVt6ggDaFCUAniIgDzKtHBYgV9zBlJD69AlU1yogjpAdC0BGQIYZIfeNKvuDHgFvPEJ3q3SqkLInKam5U2OsGZAPGYglPgOgAWgK437qkzACgWkQ6uEgTd4fnD-oJSBKShUqCDK02ym7NWpEfSRYqdAjx2ELWqm9TxdOUqQNoNU2fFWLJQm5bbdQRM0sa5M3wmznLc5QqBQ0dM1LOSg60Q1tXgGDADRmhXJmeCRSppWM2wefqZ5UFpr5m85xnbD0UKlUtSUlWHJK7BHLDWdLhmecazdlaayPnEaTVmj4STuMzxgVU-YfKJjKHhc8aTmpaaRmoc0YYBs1dAfiUZUwSRrdLvL5SkyofFLpzHyec01k_42JTLKWssKvytmv-lTne3goKTnYVLKEWX6adQweMhSJJY8bvGmKr6ZbqSG-fxhJQZxUiQP2TfS1iDSjSDmpLfDkpbOkzYnHsK4nLXYGbPY6y7fiagsD818iN_jfmmBXUAAwoAEEWQ4yqKRe6LphZOb4GJlc5Q7cIyrd2W06wS_Eb28Gk3YGVQCvudk0DOKIze6UKg0m9c1iuHxg2fB405QI6qza-BR3G1wDMW83CUWgs37mqxmfqj4SXqr9W5HJi3cIhS7e6Elj2szk3Mags3Cmuk20uI2ptq7sQxcLi3_qmQiiWx43tNMAC44MADh-U5xK2O03xKgQAh4LaIZ81nyCYdXLcXWsAaWli1aWnS16W7qC6WqHggpIy0mWlGhzuVtK5muugJBNEhcWgXmUeYrypxeM2LeJy1LUXSEwa2lygwUK1GCBOjwMY4pxMCK2VuaK2ZeedgzQeK0JBIDVRWuLIcnWrLyzRS26oNAAqW7hF6NKICFW3y3cIwxoRBMybwKUlAzYNKCJWrtylW2uTlW9gQAm_ojfA4E1aqwqg2hD6AdW-JmX1JfhrFPi1vsmQgdWyQr-lS-qxeWq12WCYJ9MIGVuKfHpaoVoWddB8od7Qi3BneebwGtOzdHbAy9HL7bQm6shhnQo4H6lYloW_3wlHMI55edoBq4BVLTQIoKLWlhDFEMa0-7eUARSIIJR5KngVaYuJLVWcp-wdsbyMSUnaUCADNEYZZ0gKyTdANyQ4oUGBL6G7x9Wlvx_QvjBjW4BoTW7ajT9f1BHWpo5vHUo4a4fC0aRbOBRSAIihYTI0O8meQZkcU79nE0xOKTY3oy2QT7zc9Yx2GeQnzc0iZVSKyOqCBQyaVm1eqVAAQKHGneYb4FJRfcrwwkCoX6Apokyt2UTxB4hn6a82AGZ-K3msYoPmlE6LZI1bTmlJYL0tpa1G_DnNG0BpyKN836AWC1sAeC2PzU-RIW2kb_my1aAWk3b1-HxggWrTa2nGOAOnQ4bEnPa1rGck7_ZfW1_AL81G2n80m2uP5W2-3jYWgHWkGvC2FNUbJP0xPZEW8WLwKeOTkW-BQ8WshTUWxcC0WqO30WoNYV2Py16ZW42S8Py1x2k7B8WgJlrFeYpx6PqyRwnlkPaBq0yWwS1yWjYql26ghp2sS2LkxcAksEu2SyLO1iWkcV129gQQlUSxE5Du05QcPxA_Vu3UwyaIK1DLxFVKNmlGpQHlGrlruRMcAKm1wBKmqGA52_8BvGp5SZWtWId0YYVxMOnC9CXu3oAIZhZSAe33Giq3X1KGZ6yNADbAOrCD2vu2mBc-3-XXgQZTbK6MXcQjPW6g4DKbVXP2m4Ed-B_XO4GyxDWmc0WqCWEWAJG03cb-0Y2Fi0zEBq3Va4wSp7cqgv2wyzCOT82PNRG2f2_q0I28Cr4K7YB-nT04WeG5bbUf-RdGiIBGbPo1qoNBQLqG80rMd2axnRo0W25M5F1YB1tOQO3dkQM7UbDXFbSmB3bUeh0TWjG1fbbLpDHc5bAMsLCOqLM4c2t8ZCOh4i82ttA3AgW1kOuPT4i0W1pnUmWK09I0aaehDqcpZrmU8KlagRfkkQOuCWUoiDWUifiUIWYAHIfdVsaViSuwS0DL81fl1wX3VqYlfkrPM7D-PW6H2Oj4DgyuuDu2w20tkTylvWkSCSADx2e24qhr7CElUtA8w_ITIhnAa-CxUmLjgYTIA74HcIHKForYnQW3kOi_QLQIaB0Ae21VoG8DhACIDXVcTTlweq36KZk348GViMAGLitbQW3VQTQxWs-QVVO-QWiTF0nZO-YyoAaqAsaJp25On2L5O6qD5On2LMYYYACAE1jcmPoHrQ_qB-lMxAzAaqD1EhSA-xevbZPaqB6QBp1VoRvhZnaqCAedlxHsCiBrQcMDsuKQAxcJqCQxONi5Wb6DodQjKW4a3B-sHGI5YdEDI1L6ouEclQ4Ifq70EQoijsdE6Z0BXa6gHrisO6B1tYVthB4dAC94AHAZkXEAYAUYD6ILsDvBMmR0MdIDssBUB5wqmwgEWwF5w5520ERF3u4L8LAHKGyaHSZWWQXmT2AbQXogwAE_YaTD7AdBpg8FF2oiNF3Kk6tkGMCvaICBgQBwCQRygOlblZRhDMIOlLtYtjB7iCzqRgPDKTK-NG5YLioreeaEIMIQAjAVFV29PFUpAOHZUSoIAXPeRCM8TQZsonIL8HQV2jePzLkMcd7j5d_Bo6jtjSMcqBEAGB58YYF0nAQl2lWEl3nQfKrku_v7hQcHVyozqxGVVViQYBIAjGTCiAu8qjGu0F03UiF12BKF09iLNlwutyiF4VF3hQLArsAYN2GWC13Haq-itoA56ESVl09iEdnQmzDVa5PRCINdoAh4LMBP4cBgsgW5gn4AKQXuLMCRlDVgoMGgDX5KhZT5V8Dzct6oAGu-Rxu0t3MIWKweuwAHtJZIzIMKQgIu9-LhsBN3cES8b28CIz1WqJU2dfvCdu7sQZAZJwRGLqG9us3ZoebIwmUQd0ZoN-J1urt1ju7Ij6Cyd1Ps_fKhUft1HMFagRMft0dUfQXTsY5gTMfQVc2TKiY6HXRPC7zBQsJxBnECd1nENd37UojYAEDfSfNQrj86WwzJpEMgXuoBQ_yIyrHES83pQb4G5uUUgXmqMB9W2cAfqSUwwgFB2Qe6IDqmGD0ngeW3_u-4hRcR7jAer903kCW00KCD0pAKD1S4RD3p0OD3FWaPCf25D0h25rWWFW45bWzOhkij6AmCnkUIkCeR0i18gmi5iTV4KWTV4fJ0xcavAYOnj0oCfzhokXj1Ay6vDqXH9C4DZtau21kjZyA8biEOVh_MHgB4Q_mH6sFtCqjDdhGyVCBF67gjVQX2Zd2jt1Lu0d0mubghU-LRIbpagBbHfIRz9KqDAASN2X1S1joGHCQPqD537EVvLf1NvBme1ABbHYtBqoHT16egigOe9yRQ2Zz1OYRu6j1H2IbOxMBfQA5Ad0B_RsejADVQSgXMSDdJAkCBQJe2ggAejIDJe54grOi1jpe1D25sJjx1xIGU6epTbagZ6CyQOcCEzNNnUEM61oivqQcG8bVv2WwBle5JgVeq63t3fgomXIoIdenq3E1PmZV-M61olLL1SyaqBSyLL17sbzCEEYb3ClLuSjemb2YwYb2siogCjepb1Ze191kkNL2F4db2FcLL1ie1PxYqOADVQPb0SejdIRe2sCMAfx2gbFshFrHUibe-cjo0YLp90Q9gXvPj1okHK1s5V70gSWK1CkCojUzc73RO2J1wgXSGaGVp0PEGLh7lBdRZej6DC26z2fenBCrUWW0rMKH1rORp05O2e4HYrp17dBTQSaGYDI-s71EfOH0rJOMTI-3Z1okGJ1jjAQD4-o0bjel52qqJz2Xmr06r6wT1fe5E1M-nrhsab70xkP73LsMn2A-_Dq5eEH3AAYYDs-tEgQ-kZjI-3nCI-zADVQYX0ZAcH0w-iX2xsLJ1o-lp0fXFSp4-3SFC-5n3w-zG4k-kwa8-in1U-t1jbsDsTGO-WBneuVixsA1hqe2ZxGybQRo-DHxo-SgDPehEhFsc9j7S7iD0IE-DI0msCNyPrjT9MBSCoZ0QOiDvBg-sRT--4ml-cEX1iUomkuaFeS0i0wXc0msRSQJb38064SAKRNDiUg2RGkmSlgKLM5Z-7j3h-zwRMU1hRxemyx9cEv3-4IGVWiHkQ_m8T1ETNGmSiUkQFAIWkRFEWlfQA6XAk1WnTNDXSqTbI1Qkk1W8FMlBUATnZDweiC3QyV6QBHrjnA7AAgoTAArqZyDRis5orwef2WIA5oP8vFrW9bODzAJST9PJCDz8nzSGwWzS4AxzSUmVcTry-rQZK2iJZK4RWOCw5DNtPJXnaHp7vK0ZSfK2rH-KN_lFaT_kzzPBi3s9cYIid-kQnWUD2Uf3g6LQ7l-oOFpl0uZoV0jdqGcrbmcyIbkWchoBWctdp8WOznbc8zkjc3ebrtM80HaR7kYB3blDtNAPwB0zk7co9ZrtZY3lnEgNmc5wCectyAzmOvlxc4gMDchAPuc2gMvc3JXvckLmitU3mxcrgOhcy3luKXgP18_gMW81OndtMdo18jpRF0oLn8BkorysqLnSBmLkiBvznPITVlzCMcSWpEf1m9EcC3MeA7zwWpWHvOBWW7WxiIMCrLu4CcYi9HcajyiXb5YTADhsWAATjZ0YOlA_raB6ZC2KgnrY6JhhdyTxx9WXYX1WSZjQAYBTeBnxCCyILkfK4_lfK_xR3hPqw2pJKCMm98JBYrOjMii_2byzJVJQS_m3-nJUP-9NoZ5DMi7C1INX-8BI3-kcx3-3JW5B87SX9bEDxBwbaL9AMre4Skqb2tkpoAVWD9qP4VClLACtBhoXSKxj00zaoMJBvBjEbNdVUbPADI8yRZHc2z1BLc8KPmpW1onY1axVXW00AAvnc83WxvjS1bktelDA8svkCLFfzgXQy5PgeMb2mepXUaKmxbB4Plt8wtmnneMbkMW9ky9HRhb0-BinfBpVcRBGxFuzYA5ABxWFARekwZJ6wjgOgAMgd17MQEQCWXWwCaK4_Ymin6wEAQhjBAQwN0YUbIX5JHlq8tvlFHGj2Vcv1BjBykArBnzaJclvnjB_nkGMeBqrUSC7QePFbNsv2C08zsDThHBbmMU4NI89EN686rlw8q3KKzanR_-v1BjZYrn0h_XmSwOHmFEcm2kG6vkfmOCzKB88T8Bpm1d6XAO6oT2awAJPkqDIDT889GIArKjIS6K1DSBoDnm8kiyp0npZu89PQGXIkMx8_-BVOKz2iyfG55gT4NvgZkP_yMAAjBjEO4LdkMB2YYP-xYNAAy1OLCgREDk0AoDPuSbl_ZLTx_LDGKK2zzbK2g84YGZjSZclbmAs7k69-ilrLc8aZL6Q3Yr9f6YETLJww8hkPCLLENIjZLL74d0O_ET0MJAb0PmeZPYD9ekP1jUPn5hu_bRneJbXcg4RHcyMPZ6TYMHcm7nOBrOwDMcMPAlGq5rLadnHa7ApVh26nQsrvz1qhKaF0DsORssy17jNzwph8mhmasPDDhoXTtorbYNh6sPQs48XgBhbbT1Gr1hh2MN9hkXIDhlyZh9eKbes5E0geFMPchwvkwLfKZ7h2dk5XZcihuq7jFh34hYhicPE8wOadNXrYkOQkMBTLMMX0nSDqisLxuh7BoihWcBeh1sNDivUMBTcSU68_ZjARhZIkmJyahzXYMpu_YOs1TsDwuu8OdgCnlvhvYP6hhUDCLFCPYgW0OnhkCNgXBCNYRi0CkRi0AZq7fh4RkHm9szsO3LeBZKFDbA-TcJKKGRy6kGuAMsB0gOW8pznWmA-YxhsrYQBhQxtLajLsRp7nsB-gPKBuLmvHBEiPhtCPa8uk5URk8NlciFavVNpak0FcPwAXXRWhm0OphvEPYgbfTFmsN2r-5rivCEYMuh4fSLZLSNOhwSKBWEvQgYIyNloPpymR_yz2RzbyqwFyMmR_2Lhk9gBhQsbAbtBfSeaLXRM6PnRo4T8MehwCN5h4CPxyFSqHKdc7PNTc55UxbI1RLwYmivhDbACADfQT4OSAIdn2lcAQueaPx5kSzJjienqS9ZtjTKkhxHYY0PYMYEIjgIynnRbOxlhkrLNAI3JFzdUUv4f2LZgY8DlGUO6rVcJY7UUKM5h8KMGeAoKQuZwPgCD6BtOSXqtwPiMnbKI3psoB0NB8qPueWINcRKaMbh_iOzR3qNslar4IeG5iTKnsOg8jtZzRpaP0asSCtwa5iCwfmT5Rj0XCLNMZnRhcCCwCaJjR8qCVRmqP6oOqMthzcNiQC0Ci8hcO9hjaNl7ZoAtRq4DuRr3IjBzgasATWo5AUEHzwc7DDOukyoQSwxXzcJgNqHWI9ChGMTMMqPR-E4Cz9MHHVsHHrcMDOAUrSgXSCaenPEHRi16aPylwCcChjQTq34J5Xl6PvTHBrw5r4cBjcCUXoBeVqDFzUaNZ0dGNXqY0Vm6CzrfeyvxLhIypfiyHJnjW5jgMKimkMNpy04JEzmAVuDfGLoC9sL2DXZFwyhSPwxygV0xTAfAx0mfAyWGXmxb-vyDjGH9B7-j77kHHXR_urJzUlSXX6xiZjsmFPhqKTwz_RLPjaYO2NXqB2OcmcdQTMCd2SC3lD6C12PrANLYPaUGDpy6PBwAU2y6xrJyhxvhDR4KIym2UOOoABD0JbOsiVubCX5gJOOowVZyzGDdSokUNKkkLTVJhwTIeB1i0vNLYAnEXmEFkM1CbC4TSPlEuMk8moPHba3zKVC-inOP8NhRlIBARz6NvuL07Cx4di42oD275ap5KQDqhjAEaz1EgzCl7BDxFGelK8bGgD8VLgCCVKBj04FnYk9cqClsm4BsLQTqCmENKJAMNKaMdxUKrXeNhpDJYgYEYBz-S-JDxgzB5eMYBXAMYCCydCo3anxgwAC-NRQa-OQMCGCGYU60-MEYDamieNPx_23am7EpvxpSDzQJgbKQfmWN4VcD4GPON7xguPGaqcPyyQgznx-OP01F-OoJmsjoJ8qDUGFBPYJ-mq4J1AAUS2Wp8YGBPwYOBO0kLTWIJwgyhxhB78YagwwAWhOEJtBO0JiOP4JlhM4JxhNEJ-ihEsnTi5xshMnxyzUtdF7bUJkYAYJ0GBaGJhOYJvhA4J6RP4J-OMUSm8NVFTrLlUVnX6gI7gQAWBNhpDmq6a8wgp1KxCaJ-BOEaz6aIFEhy-pLmNoSE4heWdgCDzYeYcDdIaECHEArgmVaoYTsDN09rp-wFvSCYceYQ8NeAYgfEC8bOYC--f9h-oI4asYLQMnEEnn0lTAHyIKuNBJphhL6cLY1bCxM9cFPk1AM1APfIG2xJukwzh1LYAEYJPYgUJM2s-xPOyOfXy-DmL5J-ADhbMc06xXYX2Jk2yhUSoXcyyyg5JxBPjhqWbkapxlAQkebm4QUqxMd_h1JqXAd0ftR1J2UoOa_ogJTTxm5XAAjincDRUBjiOIBrAPcR1S4HzHJMCZLJzuncDCbABcBdycxgSQXmPQsSYU-IAIibC_h0bJrZNQAHZOAVFuNBlOiPU6a0NWR2AB3JfqMARzuMRR7uPYKcsPEsJBQwABf0eR0hB3JY5Qe-t2U2beyi1HfNTX9ViZFWBE5-hkJYSKCRWRjYf0nEGWN9WUpUnR7oAuJ9AB0CVwoQ8bm6_oWcAEffoa_WXuV2-DAE4Wk1IR67RNJamsj2JhH0u6K7kQpsX0rMI0p0mXYVIx-tRXqE5OnnNpwYp5un_i-eBr4OXqwhj-DOZQMojgF0AKIFtQUrWEOQzL8V9SwVM-IRRXH7F4O69I3Jj5UsY5AF-A_lB7Qqsjwyp6HoM3RHtVSMVlk3eEcUCQfSIMRtwOVxl4BmoM1PHpUpIxJ61MRs8uMpJ9xPpJjAEwKEuMM0EcWup3HCuprnCI7e3g2bRMrBYYpOk4OSMUe9Nnvh2vo2bS4MO1ScgH0IAORAKE66HYHU0ABE7DXJR2MwNwrL81fw6aHI1mUkDBteG8AfmZhXcyuyGxUneVSB0tMQJzCqg6UWAlpgpWFKjdrTy3eWoWXhXLC1-X3oZJCGgNCpz-YfCPxofDuyqs7niStNtp7bTltLtOGgSBhz-YhWsgF_aTgLHhHKp_hUK4dPhtVtNbaH_RpQAdO6ESMAtp-vlLCidPdpg1NjYYfD5CFJjkAF-k_Bqfq95UnrmSdEwFoVqgiSynz_BLoAYUQCEiuvp2cxZGKOZJmWShhwDNeW-6jp62ILIPUlA4q9A0CXJ4IPdYAvwMHFXADCoAtIIDZCvTDlEsYKakT6SIZ4pF6QFDNA2rkg3gQkTFIpx5hoTuURQBGD5PTSB9Aelq5PCfFwac-0WYeGABk4fDIJAdA7afFq7AFiWxANiXJAXXqwAc9P1bBwC6Tenp5AOzGtoN2VngccWJAO8DeeHl2OMGdS8CXwOVscw6O6TC3pbWVT6AR6rSZ9QDVXW84wNGgBkCXNzUENTOJAbZgnUbpXXqx3ZpQQzO8OwxKNe_HioiA3bVxUjZDDSeI9cIXbmAItMMiWjYZed_CSIZwCiweoDOZsZDtMKao8Ic0aDdKXinwPMCtwFl7rAqYq4gNKPzAcoycqnylpRyQA-Z-tOr-boFwxbxVDDIloMgQ4qTgPaS5wQkpUAg_BBOkt072J_DOx0SLYwIwSVALBYqOIYCxxlDwcAOeloaKYDOxl2giDIYZiDNjrsAe9D4U75CTgGQjWAJCg5AVfw8CIrz5DVHoWAfrPHK1IDDZwTo0E4IDjZ7pWWDPrMDZo4AIMBbPdsQkQeZo4CrZ0QY5ydgB_NOJgjZgNC-Z0_B_WUt1s8JYZuymSAeADxCSIOAAcANHCGfJYD3fd7MeAYMr--Qz6Dp6rN2-NKD3fP7Plp62OA5tMy6Ef7N-2pS3uGPYUNWEzByOQrMIMX3yK4NKABBg4V9hD-AxBztjZJyWTClU3YHcXHM-ASBiK4Okw_SYUqx7PLxKQYGODpkzD8OkzCF0RXAZkfEB3y9Nl2yWUCowllg8J8qCIykzBXWI_zlgB927qm6JfZwdM5AQWS6RJHJpmeaAGmtzH0sesI25I_zqiwXNo4NMyQMcpK6EMXPsAJIkCEeXOn2I_weAd0UfQZnP9BG6JEVDXNPsixX9EXXMCEQmW1UY3PyooCj4gSQASQSOUO5GzPmAUGAYxf-CsAAElQK3QAuZoYByYZ6OSsFnYwKWkQEeVMbau8wD3Zhxhg2LNW-AZ7PyuGVxoa1WB8IVPM_QVWDBlY3ObYPACqwdgDtQgNC7yktOFQXQgsDKfmzIfvCVp4vOFQIDqu5h7RzkvPMnUXzMNp-aBz-Rdj7PfPP-setP_ykvO2lSWDl5lOLN5nvM45iSAH_QuhD5jIOz-FnzAKPPMF5ifMDoXvNl5jyj94efMBpviB1lOqx5Wa0Ot9Uji--ZoCyuG6IQAOkxYGH6BDDeUk3RIcUgYE5qj5s_PjRI0BDDS_M6NJI635m6Ln5yBjaWh_PI5pwCsOTvN15ntLBGVgBLAZDBkgEAvjAGdTguX5DZxxaTBGFxiAFn6BAF0AszACAtOAKAuNCYIwzAUAuwFmdRAF5AvLTdSjLHJzABBjsFyOIYZFp4vN7SK4BEFgqxzgIDpkFnvMfwSgt5WYgtpmWgvrPHvMKO6xUPSCbqTgVMwAIClZuSEWkh3GgUWdNmPh5gTCpjQZWxU2_hJ5gyVR7bDQ3LF7jMEGjDSuUjhB52SpdQnI6KqmfiMgJPPEE-QuhLS5328GPOyuHQt681MyyF9HaqF2cPFO8wDFAe7MX3YAD3Zs1xLAGZxOFlIDKqVws2uZ1ycgVVJyUntKpmR7PYAPQto4e7MxwFtDBlHLjBGToDNpSpweAOvLDi0pLorF0BQAVUbkTLXyloZIveee7OgwJIsLgVUYPbPqy5F-Kn--IostuaHgdCeUkQ4XI6lFjLwjWGKEgeIovOsfVwKQGZyNFtEAuuQB1X6tosTyh1J8YACByTJ8AZqnWLsUSAAw5iJ25BK60WhTdzygBSDdwd3NIGmZwjFlozyAGRLtF3wv_K6QtmFjwCDILADBFtDVB5iJ3fZ3gsmFsKZbFiwvA9KwvGjBUr3ZwIu7FiouhFnoDhFkM1K-hpIEAWbNP8LhobZv5p7SWZCv5ZsJfFvDgvq2q5wF_piHKAINQUEFh-MU3O_FwqAjWcEvAsYEvQl5sYcOKEur2mDA48ePObFkSmogY1z6Fys0vFYtys-g92EljC19SHOQnmnWKr-SRCMgFtzSqVk2xuG-53tVtOimpukTii6CMltdOdmUGB0CYhOUll0mogakuGWFjSogd4tRgKks0lqQQRYQyo2F9eTiZyTO8CJ_QAZpkuzmF4vEmQUsPpP9NyuLYvYabADfZxTMSQSQAAAPQtCs0HlkrgGtuvAF4AhpWAAUMAKgZpYtLVpZRgNpbtL9jIdL1pdtLnICmc6EHg4WwFI4upflKb9jszp0F5NJLCcwLAwXdQZflM4OBF1shCeU87oBwkZZNs0ZZmIBub7zQ7vwSR3G5KdZHqLUDp_pzxZuLWxdcAexbkcqZmrk3_gugdhdwenhfeAAgA8LjhZtc7hZcL9ZfeAzribLPAQKgqqTdlmxelcRZY6E-hbLL-wSOLyee7L5hZSxbq2lL8xYLLPZcdNDxZ4CGpdQ0WpZ7LOpb-ic5ZaKxhbMkSZi2LfpY66uiQCLhZZnLpZeXig5YlDC5cZAiOFuFZiEFL-hfPLohLhZt_BvLeriA6e6bHTP-g2LphcFLD5ddAaOFv4wVthzjVhFyQl10Ij8Zrz6UGfLG6b4V54knTx6d8jf6ZGAsTqvL35YULxUCEuBecfjb5fE4xlqtctxdxLaOByaCAnxL-xZBN5pJfFg-BzkI5e2LQRYqLt_AMq1hbdzXRaqxyPh9F2LSd2ajoulG7VwCv2gICq2lNAuD1Ie3905AIlhAweove0r_IkFn-nkgn-ghl_ytoOAe2Ha7QCwOxe0id8eZvAooAS0CssICfSgzyuUutij6FFAOsHlgWgprAU6D9CWsCvEuT2clqGhUralZMVGlevEWldAs1sWPE2bVCUvsuza3ZLAzNYHIsooBvashtPNqGgntfgOXMt8vlAAVeUBSUEErkymoifgInM9EUYi1sSGq8kHTVYaBOi8kBOiUlcUdaRqzT3lI8iGALfgxqsH4ZBBgyGZhcVwgBxWa-EfMD8XfeYxRQ8XBZ3s7FGtAEedrigeujeg3j5JZUWCMzWHS4qmGoCC9UqrPuoV1xBMqcaiakwA1am8h8TDQklk3iFU0wCn3gvMfVaEcBiaNE8oGGrMQEWr51gzqk1fkggoVmrHyVEYPuopTxohWrGid7l61Y0gGmV8FfMGEqu1fvQcKbAuhUfJcQpGT4lVfwqwIT_gdJkSkFVfelnMhaET1a-rQlvOcpSTeNhqyUTcoGwMnxSi17G1Q1USaTdG5uXC_JoxN6lQwBwJsEjGEfurS6e-QKXghrIhzJWvkiBCg3kC2YqVpEd4AOQlkTKiI4tgZddS8ctIgGsq4A-rc1a-rL7A9Zv1efEMQto1LJF9gGPEqrqSfo4zNe-rZVN3yqbLc8lfCmsc4bUqh5KdEg3jUI1FrlAikryuXBxpNsCEmVGjH1I3yFxB8YYSir9uP8Jz3VrkLl9g0EBhziiMr4xNc-FHNY9ZcLKukThHSZ1NbaSutfmA-tffKttaT8YsQRIGtZgA-tdC2Vta2FUyfwL6lUdrrol1VaEARaGwYBGgPFYruRtvg-JHgYS_rua-bEFIVzSjFmzWX9-tOOaIKDyzNzWjretLTrSDuDFyFQ_U7Rh2B44mP99mnn5Tmg5MzjBBQ_ue9kghSxMLKvhVV1xzT1ABczIKE8IbUGYk-PRaQLdZygbdZOruju36UcDa4roE8p8iAeuWgx36A9Z3c8UGMQZ4FV6o3T3MY4BnrZKDUD0KyA655h7E13Q0Y58UEWovW0ODqGOp1ZWY2jAVk6Qm3R6K_THAQCSFIYREmWfjyl6HQpMIHG0B6tPQ9SupzP6TQxxaHGzbmrHU9G_REgYGR2CODiXrJwh0yOIRzcqO9S6GglE-Dc3W2J8TEhY7Sfb6nxDTGdicLjkYD1Tf0QOC9QCddQpBFp7-FIekDagbsTEhYTayuARn36AmgfcVEYxskXHRHW8mwazFED-a4w1y84nTw4lzxMIGTGlsMGReZoi34k62sWwpXJYbj3AD4OSGqJcJzYmZIH-6R2tjE9vEx6RcZrAyoH215_VbI87Cz4NrKY61Gt1LpSfgyjRjqKPoDpcXyRssn9baO4hwbOEkQMzc1E59FRH0bLE3yEBuA2tllAD4Wjb2eSJWRoFnLK0kAzlJTHX9TjrGcbjpsDodjbEbBpScb70sv8EKlLw7jdRgpGAiAXjYqLTWqzoFjdgb5hFsbmjb8bMOdibhw0oTWAHEIvjZ26raCT2KTe3ilCdWqH0Eyb2jdVwA7qybCk0ETraFOYLovHNGjaFIEkE7r6AG7rqqHOqkLiEQQjZ7p9jZk6xTARIFjYhmExdBGvTfkZHw0GbR0y763Neg47XUKgG7PhG21Ex6iCYD4COwDL-PEx6mC0G684m6ASNClIvDflgImYj6omYYj3_XlDor3Prl1Te6wjaKsJmjEbwZQOqNIFyTWTikbG9S2b-bJYb0J34QJzdTTwPVEbWTZsI7Zr6sAfDfJT9m5NPdKQ1Q1n-b_sk7KqOVBbjRmJ8PZQtrjjT8b0MwjtPTaRmL22nrAQmDQLTa7cYLbUAXVCuq4Dnv2yLZtmiCcNjfdb52DvVpUXgi7dGLcx6OomhbvGtObdADGaEaZzkNzYaSJ5bL0ahSZGvzWJGIRfRGIdd_L_M0B4KR2k-fzTSORIyEEQsf_aloyA6RLT3roys-AiAkek6iel20nXSgc_jhAx2fFVOhzq2kgBfgQsBvrCUgwYypOwY-GTFWQYxwYcwzzAU-xEWivTjOGhWZGEHG4Lcq2aAaNrt4Xbp3pbAorz6UJOz6JjZW2hye6tChltvuRndhAGCwreHLGqPVcGRAHcGnYz5GpDHikgbEOVIreJGgbasYwbc1I0eC-w4beGGNDYEE0_Tdb3Yg9bA-YIA3raYbvrZhswqWHQRxtFA7MuiK57QkYqbeVK84AzbMICzbyqyDV9I1uYuFdJG4refgFGosE0bfEbhhbeptI2dWdJgiAgsAM8vbe-s-Qmui6aiJrr8TtbZIxRqjreaOrgFxwgPBh9BNXxz-9nOS8GDcGakn3bg7ed2UbYSjUbqgcPbYdbfbZmYFRCXb07fu2ORaPbhCZhrDFuIjiDVKAT7fYArRafbtEFyky4k8G5gB740k3uCnI14me9liILmS8GGYwB4xQCrdMeoWjCNYVKSQdXVBmrK1PqgHbCzQ9Z4prrqNom5Lc4qCbnreiApbYg4g2BEAbHnvbs7dKoKNb-Zbtrw48YaPAIWeQYilVlBNNahzzPB3wNRykEj3Gw7x2tw7PJY_sHIffNeHDw7oPl8Yku2VSzHeB6obt-bTUUfZd8obKc7djYXLfJGOhV7N7XSRyXZXa6sLebDetqYbhqEvb3LcdbPGpxbg2sM1krgPbakzHGnHcJEQ4qr94naY7UFRY7qFVo7EHFpTC6jhGVZRzkpEShW0rcdAd6G9kdgGXbx2aYb0MnfwoLSLUVpRtK3AjewTbEsYpwESk9WzLmgnWhkOXEzgSzng8jDaEE7ic5SXGdaKRzRikQGSfwKXmr2EwMLeYssG6BC2IyS6Alg5jDzC30Ejx9zDOG8bZ0o-rpfAciC4zunVXpWwHXphb0rrdpRXw3AhS7smClAw5qfwyMMG68jAuBzxGcg3WBcMZvQu6I-TVTYfXDbivVC77Owgi0MnrYB-Ha65jBLez8CKzseasyndIoqg3Ruiksc0K6UGLbxHYjq1ZTZWZPWE6p7fdSeCqP8KXmt6gAx4WHayA6Z3fMAzrZ0w7gk0YO9mqZr3fL6cS26zT3SFmXI0B7T7ack8AH46ER2Op_CBbluzzyomcuvrZPT6iEbZI670yMTdgFQb6MEV6iLYGEUhzHAU-z3r_Ancg5fWk-OPSQ4NyyiknvVJb1Pa08ivWKG-o3OGhdjzbM93QYndD-AgwB0YnQxRmco2IiEnRSyti2gu1Cz3swuvbbf6YP64XZ2pXbZfk3dIh7YHa0M2PeOGnEzf63Pdl7BozMSLRQF7rPelGLPZ4G2va7brPuXJG5M17gvdCzLKer003QqbBhi9rD2jVw1kGRqooGzlFaEbr3sjBoXcmd7Y5Fd7pWOQbsLGt7kQB97WrmzlFhWnABQDeQQpY97vKDPA3vdzlJrjD72tRdYUfYD7hhiD7RABD7AgBxCuPkNQMfZJgcfcxgWfZz7IkDT7RADlrY9PgYR21u2DIgPbMq3zbPLmis0PcdwR8WY00PeVqerPpLILFA7qRfowGHbgAytSKTuW377ORdNsyHblrp7aJAO_trQWczXjuHWEmqteh78Ybew6Hbr70XQh5k_eVqtcfBT_fZCwMiCiAsEpX75nePb-UxNEpWKGLWdEn7AiRDbJJl7jujGP7CzVP72wW37HI137MPqRbSLD3bu_dP7sIIHQF_dfo1cAf72mqfAsIJOQF_aZYNXuh7XTTv7Hqmkoq_ZP7L235qj1XAH5mV0ILOCmAgyu96oysQYaLCmqeYC273bDQ8DDBX7zXdZ7e9fRwqRjXw30a_TOUBOQbdLQHN6Z2oNgEcW2Quak1oeSY8HiK7jcvPwMjc0cgtsqcMPsqcWJVV4RSfgw-magcPfcEwj7agA8WVLU1ZCV7qo2kHDEyLgLRBgH4hEjrYDSP70PcCqizZIc8QC-s9zEToEtQP73AhFqmcPIz0yS0H_feNExg6lqxojMHhAAv7Vg7X7AjKpmzg8Hba-amAlfAj1rGERbXWXmgwFUbKwMZ-GUIo875kB6sLDIxZQOOuyine8HvcrgAE1nBbMQ9TIiQ7UA2ndt2fVnx6oVD8Hag-2F0oCjtQFXxqsXiEZ_pZ6bvcortJ2AatAy085NbYzyyhEoAn1dEYCcwu4_wbPk9QHiDkMdtl5jAUGOiZSGzbCN6jSvYoAaWYEZ41hB3SdLtjGYaAzGbyl3Q3KVo-XmqNuGJ73A_LQNmSQ8ENo6MA6EkAEjEgYWdAvyUA9_7ybrb1yibWKEQEaH96GhOdvb-iqvfI1OADB2telNNDEKgaWmvUHvcrc7IzAE0kQCszsl1eHoIrQMnw8S2JdQrDOdHKHH4vTW_fcH7HrPIAYKXx6o_YHKo_eM72ADE-RzJ1ipRjfJV_dRHzMHEI80Hx6QJWJ84hFWg-fbBoknd7Dx4CvwlW0eY44VC4qqBbK4JXusTGZ208DbmHqqYWHwmpTm6PYQ8tmXWHOwM2H2w-wKew937Bw4HN7Wd_7vuQ6MJyFNsudeiA-dZyg8shxHMPqwQ1I80M2ZcKIOI9_7QsQ2H8uleHoA_VHOwJOQ4C1f7FndsHllBxHm6MPb_nd5Qtg-TM2ct2mOI9sHvwqL7Cfb97dD3D7OtRSAUfftHwfcdH2coV55oMgHAo5v7xo9eH4lzz75o5JgDg7MQJfdfiqo5v7fe0z7CfcjH0Tb9HFnZ_m21FtHQR3qtrw7fObQqP1kYBukso3170vAxHOLcOH0oB26mkp9i7g8w7NV1PbYKRlAUg9PbCcZhHDY6RH8kdY0lvetS0mGJ8ptjrHc5XO29DFusW0qC1ZY6STbY4LHqMiLHiI4tsHEHgHVY-0zBo-jb5iR7HMAGkHbgzymL2ybHT7d5L14caDVfj17RvbZ7vtr8LPjGMKdhXiHLo6sKtI1MS67ZSS-NQvcZ1xmBSYZRGzZTVH0XRRpz47FH0je6sRwDhyyXTk70Q6BbziXDHanaSHmneZg6Q5o9ocY2Hoo91HEo-I90o8fAoMGAq8goRHWADrIwFShFKE4olcMD5D-NV_7mE51HOUAHQCo3fHuo_wnEkFAHxE8B4d47FBZE-Op1_c1I-E-e1xgi87MQx87c3VPeAh1LZbAhyAS1xZAmNYOblvbAbZt0G6AWZFAgXYu7J2dC7I4C17g8EtNDYxkg7gAsDa8ZWq5Cmi70lFi7gBgLU8fkx7coGTbQgkBsG3cLsBA9_HWAF27yQHK7t2fjz0apYIgk-x007eubtk-hy6lBk7Jk_rKyQ8LAo-enbBjeE4oE-JkELafIqQ-wA4E5qbiq1-tSRy8nQ5Xa6tOV-1NnSiHfXYL7Y4GJHAbNJHWbi2A5_GoApiV-trJ2P1pozl7HY-PAXY5LHboHsGjDtrAv_bBgek-fgAiQ2HmE9qhoA4qnXk9AHtU4diQRwanV7fq2v9eanD7o2cYoLanhnaqn1E55eXU-Wtql3bHE49Qn8cjLHe1X7HCBRrdJFuHHJlDGnnY941g2rLH1U-5HiCcqn9WzwnUU8KIS4_WntA82njU7FHmE72na09_rR0_an3k_QmvGrOngmHwAPU55el0_6n9W0GnMwNOnO44VKuU-N77LZMMS-zjutgDYEy-l22IUbLHqjb-ilUlpLERdaocACBnodk77XLnZGkM6kEpGFK7r8VTi3CPEH6UCXHUVu4Rsg9hkI1WX6kcNgyRkwGDS_W6GsWWgy8jE4O2-HmA4-QoW6AD8I1TPKAscDyIuVtA81raf1goKeAaNy8ex1xZV944uu9ddmA2ZnkQ-gHQg4NrgQRkGRgFoUqM5cfiQ-gAtAyYFUhgxKMgakO5xXjLfsgHgkifmoUEtJdxnUXnGbqcTLHBs5yg4Ll2nAtcOhAZvMNMM7hnijmeL_09tntLlM8IM-xnYM5MnnlWFE0M5iAsM-dnzzldnB2z6LKRw_zL3F0tU72GCl1n2S9QzwSlUjFb9GwBnvs_gA7YSXH4M89naqE_mUM6uLNs59nQM5dnwol-njlntef2xys0J2sKIO1hO4Ox8CUO0f8MOy_SswerUxhycnwFpoH6AAHQ0E9oHl1VgALiERATo7yAsqE2MIxmtTUnvpOkNfCH345Fk--crnzMCGszQDk1n5OnnRoGCnOsSXHI4-hGYABu81BBXntZoQctuQHHtYBcnG-f-iHZWKn1lV_7anaXnIU5GAMOf2nO07BZfbqT2N85OnK1jlqh-X6IuY9rnvfF-GC6EdnOc79nL7kUcxs6R-1Nn-yodhGwkGpkIV844S5E42HPG2Tw3c7Tg2cv7nHRkHnBPXStZU58AtXRbnzCsFkEQC7nYnF7nAmoHn9mCOKHUDvdyQBbq2o8hYcC_wXiC9QARC6HnaC_YMyQEwX2o5wX1C7LQBC6QXOwJQXpdoaLCtVAaLfaamQprLHWmfpirJYOCA7NrAS-xE73Y5NnPJeqTD61JFhR3ymS-yvDqZyPNCpUoVDmYG6Qau3oeWHbuoNbRZuzJPgqozcU4Y_Vyi2SuGtI1B7w4rBk1k2XKeiBmGdqeaS9i-m6DavhkzSS3nxUBxnJi8Ew6C0tDtI3YHpCyoFQQB6kp4WZDmJR-GqOUxyjQmY4JEURghIGT8O3XSIM8HgAwwBYtRykRgqS8yCOUHuM68EMU4S9hcMOZ35IWAeMCuqFg6RGtA3YnlkT9hKX8OeNQ_8Fo8xUD3tgtCUb_1xqXSwFkqWfGZDgSUaI-4i5MzHFm2xqAugxqAJqI4uNQaRZ1jaAELg5gCAqiMAOFEy8MtDpoqLOEmFKHpsz75EioF-HmB6uTzh8PS5CnxqHdrcy7oMAy4_ASy6BMjptWXpk93EGy-2QPputTuy4Kg-y_mLbnn-uYMEOXaAA_g0y-FKoNHUAAxfaAgAGM_t8AplqJVXAP5pGKJgsFWOkqjLwWgjYfotoAJ8CAACNJgV2cRK-Lxk0AB53GWPsu1MsyGVNFXFRFj6K3Cq5TIUC-ww64P7yIHo6n_JbxESQZHiV1nBzePOcgF976_4PcZNgFEBDlEZSCK7c7l0LegH0E-g1YK-h30HO5v0L-gZgP-g-4yU6ymeELaNR8tzM6P43KcAyIyVNBA6H1wsVjsBiuLc7i-KyuvSNOFHdsQD9UDqlBMB-yq_JGW2Kks3o8_qgC59tKJjnSu5fffxO_UrTQim6qLVXmmB_bYppe9w2WrPZtIqhJq0NoI7FuED0rDUPrl9cDhvV6EtRNNYyQ1zqQHV9rwfHQCBLvWNYgncZSx-eo7gxboBRxFMBzHe3BO4N3A0173qLu1mv7XhXX8-9XXcbqyqeXuyqV4A3XQx2vyzDGSY-dH2Zh-RMxWWsGLNm_aqzwLwaXLC6q_kBYp3VVS0E11WRoUAOuPvIeIQU_TpEjn2Y2jVGHAtB0bekHYL2ZNLK1lK-g9kPLLFZZ_77-bFSO1yayVzeGvRDFasgmXySt10EyiWidme9ctq-9VtIpEDgy9te6t1G8_hmmVG52Ru6tvU3BMJHcNNUmUHEJ9kRHq-vqH122LW37KFm1KK3rs1WGrfVVNJ_VWo1SIpuvrDXAAf1tKM7DZpIL16trrJz4aJKMDWBqW0g4N9YvDbsDIk1Z00Bqmmr2dbQk8N2DwG1e97G9buOwUFhvfbUBvD156utaIkmz10WrNCpeutlsDgfDZzRv1RObsrG8UCJaFtraK_rYdVO6pgGfheNz6AT82jnhSq94ger_qhN4ycBNzDrfOk-z511LKZZSrA5ZQrL9QM4BTDSFOfCmiPCRxpVHO8gxkaGSPkMulPFVD4UxN4KBhN7j19N6GOiR0ZuSR7NhUpxSPAhaJv0JeJuKNwqUQXNlYq5_POTO5YaDIx2uo13bBGN0trmNzc7kN-3qnVUVYb1yFvnsMEbdqNThn9V6vt59LRvLclv4tythRoHs5QRilutaJivawCVUb1fDWFUUFswujZhBQP6sst8VY2rDZv3N_hLxN9Vv_6D_rQur51s8jSo7Ny5mHN2M6nN6Zu0p5SPLNx5vrN7C5q53-P4pz1v-EH1uXN-Zvw8BgArN0sl_1_jwfN8FssHGNvUJ4XJgNwbIiKHooXCGGv-1b04H6diHjzjQ6vtm_SO9Vrb6No0K1g-hsTt3ydLt9Z4z-Bsxrtxate5BjGmGGGh-1KPJeDNCx2gwpgcGZsswOSeu8OL6qgOGChNlurVqN-fcRJEmIXjDsDATI4GXtzwY51HDvcl06Zkq_8Z4d06Ykd8jGr1NrG7jOjvSKfCdmThDu4tmoANIzDuAA9_qyd9gAiRMFuWtzTu0k6DvzFrFT75Cixdt6jgX5AI0a5HXJizusAx1xrojtxyNtipCmWrNCmcO3CoBd-sgUtsLvR5uc2xd8ydmFGGh9uOYYwjF_IIFp-6Jd9ToVd_Wvf3bYYcFBtAYKys0AGemu1FLgpS5LQAOd5DM2d4_Jy5EU7DFMOuEkjGv1NIzArYBE7AxYPwfuC-QhnW5jmQ_oLdBe1DmQ_aZfd1ego4Obp6ycCx927QBmQ9rGQ96wovYHHv2DBeiA98yGBILda1ADjAq4u3hMZGWuvMLdDrkFKBGjAhQnfS-Qzle_wSglnv_2u5A3vaIszADnvYVXnvAIdcgbPpAEBxN7vxbh2DlTMJrICFPASjMyGtIGL23Mf4Re9zQBK99xB69yyrG92pjm92iRvMXPhhQBBDNY1PvqgDPvkuEHB0oxpAJ932AfuCvvQAi3u-nQvuhnR3BNSMvvvAKvucEOvuMC3Xua69vv893vvZ9wfuBAIvvQTAhQ6jKfusAOfvwIfXtvd9sV8wl0ZD7lcALQlDAgoWABOcRMqe95BA-98yot90KQd92fv792vvH90HBVY3AeP9wgeL9_XtN9zfvYD3funNA_v590_v_99rH395_vL91gfc96gfSD0gf_90cHKD-gev9-lGf91cV8wkfuMmuwAgDyAewD8PvID6PvoD9geSD_Qe591lAF97QfcDy3vv93bgvAMwen99rGAD-wfgD3pBQD-AeR9wQAx99fuKD2If8D8IeZDyfu6D3ge19xIfbJb_un9_aY5DxwfFD1weID3hAoD9XEYDwIf9DxfuWNBBCVfS-Q09-11ikTHvhDHvk9MKpBmQ10Zcnr4fbJR3useGYeZHsyGpD9OBhQqVi5DIHvgMNX6_u3KhLQ0TgdKPLgIAtBRTgNsA_dzf3cngpBAj5pAw91NAI9wQkUjH4fe9FNVs9eK9S8BaBZKj1Dqj9kTY0-y6uDJU88jwVGo-PIfOcaziDMP3vt6WC8fd1rmWj0DbpAv7uj5-EPwKHnDikSZAsAGoe5IPwe9Dy3unD7ERcnYgBZfUcBJD8EeJwWwelDWABpj3Ye5j7PuFjyr7EABZAvOC-QGoanAu9zABpj8YAa9hnhT2Ec6BCr5INxGB5tXVAADB4FIxgA-mxxOFZRFrsfcD4XvQAl_8XyAPvvw8gfYuFDBDIFYeNQDYeeLj0feXn0fwTz4BITyKBoT_i1ZIEPuKrIZAMTz4AsT9wfrD7wf8j33oiGzb195N0exe8fuuSLk8DIIieVD-Ef1jxgBQj8jZcT1Cf8T7wnpD1Ee6HhZhMTwieooNyeVIFMfzhLH5qRDRoWB6nv099gArgCRKdj7Me_j2iAAT52Llj0im7cDJK91ONMpTxoem91gFZT95j5T4gBXAHN3Vjz4Y7YPJB_QFX78bWGXe5RkB-9wUevBSEBI9xYJo90YfQTInvJwF4fBrEEf2wSEf_cRKTGjE-Bfav7iSEKwAUgPzIsACQBlQC6l6igQBuAOEAwAI49FAO1DkwPYBnsykB2oZU80EBYgsAPGftQCmfsoSmfuoZU9KnrmeCzy49czyGeAKnABMz9meWXvGekoCmfLILWeAAQIlEYML9az-ZDsiVDBLIEmfsz_GfzwO1CFIFmeFIDWeFIJzj4z_YBPsHgBczylIKz8WeEYMrPZz8mAuz5U9X_OiBYAFOfnHhsCnAOgAFz_5DVz_qA9ICmf7ABVZXAEZB9z8efzIbmfIoPue2z1U8oYJeejzyefcz1eeLz1DB7AFef6iTefnz1ef9QMOfnz849oofuenz3meqnpefCz7eenzweeHz-efgL5U8LQO-eXz7mevz_-eooWBeAL4-f_zyBePz1AA2z_YBkwH-fnzyhfIL3hfczzBeoL849cz7Wfuz72f-zzWeEz7WfOz8mAoLA0fIIXIf7s-fdqs0sA2L1rm7IQ_cn7syGdBVrmqT1kevDzzKBj9UBpMfwKIjywfvAMyHlT0Z0JBOEfjD-ye8gMUiET9Mfx_dkBXcOVB1JMEBuBG_E0ACUS8AFcBnHkZAfDyT47cL8eNT9mYtT1_8w0OZfp95qei91_9EALqf9T7cnuBhcehrNceqTY5KLOvTGLICIBvkKIsxbVMV7fQgcZkB647cIWhw97afijw6eLfC4YcYCJfNYwlf-TzWA-L9LOBj8MeYYAMezrU8oLTwIBaTx6eJwV6ee6U-AGVY8BDnlK7CqF49UIL_xz4AKqlZ-hAogGkA7zAs8YAHpBVYHgA8ehABQCDBdGL3Sf0KOMeiwD1wx94SvvKQ02mmzKQyV4GJb4HeRqiTpyV4LNesgCChFr_YbN4_in5r6vA2m-aq1r1K6RLCLSWm4I3oKUU29nhIoVr5pIdr62gyJMwLDLO9cbPQzVeAC9JeAM4AUYPzJZoG6xfrl8GdYgI2trzEknQFIl-N76BS8N9fAb1ZqZS8DeqvL9fBQFIkWm502M05lXSkMPX82KS3x6yTApr4OIgxFENoUKwQdgHxJDnW93tBijeJG6l2bnQP1aCDrAunkWYplLqATxA1o3FMQACAHMWTE9sQEIt2JqW_n0piBKvlwtglekq95GuZgMtDF0AXNEeHaCChh8BDlZ0TXGzBsMl5mgMxn5YJIhTHmUJiTEJR5QKWoJJU7URbxvwlb5ANZb_LfbgIrfUQAYllyFznL66K75QDreFb5rf183YAzsPuJ0AL17YcSPQNb7ANDLPzf1aBreXNG844889QNby1NUQIv5Dku0A9kBUoqbO5VI58UcnCHi27PT7exbx_Z9b0PqF-zC6koDqY8PAJAWdlTZigL4qy4EcBidVdV5EiNbL64XhRb8SYEUB49SgZZFhHHhxPCOL17b_WQi737eh7H1N6yKWhi4CHWcAMahOjISB6WCAQ67yTAbcCGxVsLQRm7xiNAeO3e5yF3fo78Xf8pI-BObJME278DwH8OmQjKkPeQ69R6pF_q3rPJPOH8KFQbpBPfUQMVuRY8iMs6CAQK8Pve37EkG6K9gVu75beSYDMNxBVwlu8kB1alJYBvxPEixJ2odl0JMrbmOZCm5HkB6gGdnar4T0IgDmYrCK_eCegyB1Drz03JI5gM2AGhLAM_fxWXYBoHzKs9A_h8rCECBqyvvgU4CwPw1dxV-IE1bT8L7endlYQyr9IAklcD5BHQJBMAoDxhfpIBi0JIArngj9zb3rfr75ZOBCICJp8JnAP7wPfC79ffe6uwlRoN_eOqIpRbAETYI-f0AbWAihCH3w_27L1DcjpARwH8uhhbzw_nby3oaLUfkVHLMLt71fepH6iJnQDcn2pQfetpew_3J8bntHzHfdHwkC27zWxlJKjl8RPq2LH6UDQtrveb7_AA9HwgVjHzaIE0AR2DCgmh8Em4_sp71ZroiNZeZYLI9IKfepWMY3SiAuBdLWT1Z2x-hr9c0n9W1sU0o4ZZsb6k1FONk7xeh4gZy64_LHwey2oWE-PNRIOTQrFJoCPWRyb3RYqbzTfzwEo_VOTABOTBilHAAZ0jcqL0ZoJdH3uiARe-u0_4mDNAM4DZIRwMzgmmGOIAH0Gb_M6VX2GEI4A5KDNaCMk_YpN0-4mKrwa7_SwiatmOlSNE_w1tOA4n4UPBYAmgwaBmh0oZGAYoIWG5ahvfIiEZu0oCE_W6pE-aykE_2nLpbRnU_hBZKc_Yn4y3Ya9c_cx88-E79sJUpnhF1n2T00oFzWWBrtM0nyCIJM6EAsn06x7i7k_SgTw5NvKc-Hn2OAJEHCqzn2M6n2Z8-86rO2i6oHRTn6K6tn4fq1n8i_mlgoOSpxBNxCLDljHzmYuAAbWhrJS_0ABgu7nxs-FAghhezbS-sABfOPoBS_4MEEw_nwnegml25WX-w8czErYxi_BgqX-vQeXxGtiX8eBpB-ky_F-73klVdNDon_Ad_RMlAmmfArYFylHBjK-z4MHGsLq_2wsMq2xZ0cAyn3IPb2_Bhzysrexwzh5zXyjm8-3VIUc0B0hX3Xt0o0a_87z_Ud-yi-n8Ca_drGa_7X82xvX641h7X6_ZlwyILX4LIhXwi-tU5cT3X_q_nX6WzvkAG-Z_L6-6DJa-CZ5fUnX-Tm7Xym_HXza_DXw4gei317w7x6_I36m_FqN1kbX-TnE32ZFrX_a_M36G_6c-G_zX5G-7ceK_kX7i_ggM52hX7Agd_Xv2tXiNPMyOs-S38530X5s-6APWzjs4OtFXWL3SGC6AYOlMA9IBBDrH4vvYCBvS8ooO_zn853Dn6_mR3xkA4nwXnCn53mLFWu_CX18_iWnrNnDnvPwKju_exHh59AKvGyn8-BZnjSA0rd1Br30iryW_e-BlKe3cQJLA1b2ql1nxXgO469tZiPCBrszae337e-wP8qUnapC-XWJ7ggGQiVQqrpD03UFIcgC0-dxm0-RDbQQun8h_jgJAJ38BNAGQHMANQJFmLupB-KyBRIRGKB-KP9kLMPwdiQCOR_V4_M-en_UBnADgg8IE4tqPyzt_UKK6f3_SmMO3x-cADXeJQiwav6ss_KN5e_JRZgJdCM_Sehivi-82vw5Hzi-sgq8-3PKc-EBiS1Db_MXz7wqicKlE-T3xGtGPxZ1P0Lx_n34k-jgJGXBFwiRYckNZ4Xxu-GX-2_zAJguuysp-ODGy_-zW55jH6bfQRzF4erJy_5EHS_Ozay-kcm--hZiy_RX3S_2X9Th_P9y-DP9OA-X9IOqX6_jjHwSIBygmhtX8q-tgGDQ1UCjAt6Mi_I3zRXB6qMAZX44NTbASIPEuu_UX52_zX92-sv0_DZrf0Rh8K5-fZqK7Lg5obHdiV-5X0hhRgJ0WRNOs_RXVS_4n2--mzdJ-GXxp-9ZstBnlyzqnb1YkNsJGWT6MbfQPKc_R7llAfZg0e2Hata8vzE_eX0Z_2mJ-hv32Z_aPUk_4MLSWlMwq_ov_Y_9S6S_UWYE-Y9i3U7P1V-GX80tVaEB1mv6p_Vin5_jvwF_qXwyJBv_kKJX_F-wv12VWX1F-OX19_Yv9t_JX8RhEv3S_dX9gbIfDZ2CO-HgCRPq_av-QBQXyNhufeB43H7C-XOJV_Eewy-h36G-0f72_ugK9-Af4rZBaB3Q1Eg9_Hn-moKf72IXv8T_Mv-j_6vxvbzDp1_jwKbYczLSWW306kxv5_1NP-t-Puso_ZvxmXToOJ-kOy4do34pKrVyLT8b2PWxZyoxRrxGwngPPX0W-5M0b5pyPYMDd_YMDdVxMu3RuqxJx_YBDNNJoV195vBFVfte-2ezfI7_XO-INJ8QWt9VtnJOQbf_JlB8Oj36h790ESNMcO6Enel6f0BU74UekDZneugNneLWLnfBDQ1_qcCPSzln0Xq6n4-EgeYlrpA4_JYJERhsCSxB-tglh-tpIP280-3GM8H54MTr82Y0Y87_2_Jy9C-0_-kePACkv6ElyZ7rnayiGqJ1IBqI_81VGBJfxolub99UYBrN-u7W0NFbNpBvXU-pfXVGAkI5gA1cs0cu7eAJ-_72JLP2vtOu262qaMIJq_8g_BvIcI6O-90_KPddOrXO4-NlNBJAPhhQ_tEJwX8J-Qp_hDJ54bHgboq4I1vN_0mvwvkaldtO6ob-4-uf_9NVfr-b6HUH_4VM0SoPVeX20NgdxBwmT4o2PX-0QimzE-62459FtA04eBpFtrkISSkDPMWjv43TLgk_taZpqUgca5-Oog6Y1ha_hPy-EDDPkfAFjogoEB0uvTiqgOgDQD-wC0Y3V6cSLo6cJKj8NSu_lLBiopkeTa6Zly-Wa7mgG-m4ELWOhv69cCSjmYgmxiF1kwwdmj7-qf6ZdZuwFwBduBKFknmN_CmFtK4xBJSATZ06kivQI9mE8JwVrMAgpZhoGBWB6YHrPDo3aaQBohIXlKq_g3WuZjf-hXKfbROVi-8_nIWAMfKk7SzyjeIhAqboLTa_tJpKpf6W8rkcpyW6gGrpvG0p8rnypfK18ptPOsAHspmAS5WZgH-yqBYJiofyqHK4cruAbKcNCrwWHQq14hPaIwqbc6l0noBkrogoLOcLhTUoLOcIKDq1Er4nlLISDkBiCDXGsQqVzwILuUYTfi0PIH4-aRl9rjg1IoBAV7KQQF-ypzIb8oWCuEBX8rEYpYqDTYMCFcEo3Y03BqwhRbxugbKuhASbEQwU3ThWGjUZQF0jCKEz2DWKsMB9srUPM8eenQA2qA2a-Aq1kcA0qYzATvYHcqCkJLAL8AzQOFYZTS-tg5iNqxwKrr0hDBV9gwI6AiOjPgIt3Yw2M2wX95faFjIUPDWKiNmeTqMDpD0puDDmivOb8RpLmK0osDkKPIwvyAz9nmApbxn4GIk8PZCptYqzbDGHi5k7-AI2O_gyGRBTKTc4dyDOFw2ATCgNIIgYiDDmry28cpjyn0AWfbBlLcAUAAZuoCIrGCHgNZIMpAIbpeAt5ZPgAeoJIEX9ldw5ID2AAzeoWyMge4AJIFg0JPEVwRPgFDAdt6--OUY-dhcqKaOQwxJEiBgk6a5SsO0wnysKKyBd6D-AAIkF6IkRK7gAoFHAEB0YoGgWPrA4uaqgZBY-sDTpiXmuhAagd2m4oHHpsoQ_wA5GE_ggQBQhohmWuYnzodGhIHEgbKBh7pbTIJgb1hPlh4B66aaAZ2mR6aCyBoB7aaHpvqAMOQRDn1Y95Y3CreWnZpBgQoBroAjWN6B46ZaAZOmQ1hhgReWF84gYEns_IFwkMqBCAifllmAgsjxgbeWsLiJAMQ6XKjJAILIpo73WFpQV2Q0djDmxYHxLO3cLABfluMAjIEM3h8AhWBOjjqEFQEA4OIQWYTiEHmBUzDV4EKBQHSdygIAWfbV4B2BCJBdgXKgPYHejptspqzFuOmBwYGKAZQAgpZWFhmBRBDxLPdmexbkVo6aP5YGxK2BJMArZFa4CcA9SE_Yq4EQiD9q11KpmGUKXKgSAVuWKgHgKIyAVhZPspZgypIGYBoWhRDVgeS2YLrodsKA-4HykksAlZbv3NWW54Gz_nWW92YAQba4TZbAQQx0bd7KqFVYsHbFELaBDYEpSLFYr4H6APng9YG4AClI4oDY0k_YYOwpgWqgJ4SKgamBwcSecA7KZYHWJgHIjoFKgRu66bL0MKBk5z7mgdCG5gDzKkuOGSxwQbgAgQCyQElK20QsQbhw5ACRgKg2-YGJ2KaOXhjsXkMMAQbiqsHI0UYoQUSB8EGYBLFYR4EusJJBTIFoQZgE6LrM0J4QCQA7AZEc5SCrgD4AznY4Qd8grLIKQQ2BbEGFWmwQnEGoQdxBvEFLAKOBuEHwKuwkQHQDEkJBVoFAdKJB3TzwdkGUhkFKQQkAskGpmMQSHkG32GA0zzrmQcZBtcimQYFBUkG4AELAPEF8Qd2BtkF2APZBOACc4voI0Q7zKs5BeVhiQW5BtFYs6uZBiFCQYBy6Yip-QUGE3kEeAL5BcQjmQUGEymhLHLuO0oEkgREkhzqO7n5kJzp2AIwBnIFCAEKQlzoZgF3g7bB94KventBBug02FUFW2h1BNAAYNhhBaHg_oNSwcFBZuHc6KiY3kDrurJh4QIpQJQJXBGIY8JT6juf4puBiUHu68oE7uvd6K0FhjvKBHwyTQZtBJ7o39ke6u7onQXzCm2xrlCi6vOgbMNk8mfhiIMdBfBgXohuMj0GqEBIYAY5mrupQqsD9QTEus9SNHhjEh7r8TDe6LuJvVHgQFAEEdiQBDQA4AHNgdMqBCttQ97oIkI-60ka96IkEW3ACYnT088Zu4P4AXzoodtN-PD6WFDfsExAUAQighMEFvr1BFxRsgbr03D5fECTBaCD4UIXgtIGygRJIkV7Gfq9adp4pGM8gjt6MwfG6A_4cdjCQ2UAd3ozBVMFdNnEIBFCCwH4QNMGgECTBNmDfYlUyPjCekBiBSzh2gaXGRmxKwR8Iu6arppXKZgEJaEsAVgFuXDYB88r2AaKAyLqF4IrBHwEH4BJAUME4AOrBJ2CVwCrBXJgG8hbB28QiwcHEIBA4oCXgksGd1NbBnIGGepxB4sF2Yu-BPhBtQIpQHsESwdYWDMG0waZOAkQEKr2I2kCLQQ_oUXChuqZ8tOii4PdBhBC5QQIYfsbx3pqQpN4EwdOAitgUuja6GcEvQdnBgyC5wUZUyfgIHPZQ3eDxILDwLADl9g8M-lCF4GHBdmIvtilK7z4NwR_2Iv5skPTo1kDfhrKgUUYIdgqi7sH06J7BFSDbPH4ACoGg1oz680D6wXugXgFaVglgvgEs-FbOL7oW6G0AWUAZdMj-CW4NXNaoY1qbwRGMKIY98oY-I8G0EDZsoSY7wTKQEQCZwBGMH1C6DDQAbc6Eeimqh8FpxqDQD8EEAHQOKHpbHFwgJDBo4Bh6ddQgEBfBEKZXwWLgSv4EAE_BHVofwV_BEabAISLulkEtAFPGn8DQAOlI8DAN0uq67ryxBmKmn2IpXJywSlDmsr1Q5HhozgdE6VzqoCQwNjbhPtW6J4F4tOAwwMEousbwYiCwuABE-IoWMAuoZX72xqMYIgH94KDAqDbEJn-UKKZ8-vrMqIqedFL6CBTUENeBCWZqiguoV8b2HAIQEiHZAFIh7w4WgGhUGFRRnH40daDyIUIhoiFI5P_GllCaIYohDujOdmhW1TY6xJBO3I7tzugA4o59pHBOGxgdGPLI-iEsIUqO2E7UIcOAeC4cLrQu9C6eBkOm0QGPtDEozXjxATvMixrMKmAwEzAevIfWkcH4IVLuCMY3HMnchayIivmAgiEGISLalkzXmne6UE5pIbqOJazsLj3OHiHILsQuvVQlMHzQfdDhbDpu5pAvXIJqaajiKIluocF9wS8mg8Gn5MtQvcEa6OPBUyTyELcwdRZnukG6OKD9wUQOwkCj2NtEsv7fQT4U9lA9IQiuecFNIesg_cEFAPUhyewRId0hfhRoAP8QC24UzItQRlQdXrUhmACLIcJCPUFH3oPeGyG9ITSoyyFpbiiaPcEEIaMhqABLIcNuJ-aQqOkyowADIbfqx4CXgLMAoDZo4DchR9LnQBJsLcH7IVshPG5XIb3mphL8IeS4bSFOPl8hzSHhwa0hU8Hi5nfmo8FgoYHB8QBtISBWpRhPIXcA7M7UEPChU8Et1Juy21DoofL2WfIwoZMhdSEhvtrOh974oRooaQAQofL2OKGixroQ9I6uKHdK_T4Ftswgs0DrAOgCwa7_0NTUh25PbP4a924ickZsmjKGskKOCAhpQIUGLgHccpUou8qAoV_qmpBTINKM4UTyQKrAXHLtklugqsBi1AFcGMGIkEv4vlY-nIyAYK5OAWkG28q7yjjaGQ5j7P_Q8M6vjm9Ur86ZbvfSsuypmigIp27E7GlItqFIwfahzL7cOi7aTqE-nC6hl17rWl6cMzZBrNFE4ExoTO00rVxe-CdQnKF9HCKcUjJj0DKho7ZSoVyQMaFbDCJkSshQFHahpqGuzuGhApxuocy-pSSqLn2cMhDUVqsUTti0lk4yv9YNTvRs106F6vDsGFxUVC8Umtq8oQIuQsYTSggaUsSBoTgywaE9-FGywnJRcF_SdUiRoamh79IJofL2eHL_0IOhY6rJofZIPsQH0GahkurvwpqEBaGhnEWhQIgcGqWhNZBdoQQqBHLXTiSkB-K1fE3clEqDsESKnqEjoYggsaqHoe_SodhGoamctgJUen9B4cAp6Cx6Rub5MiUwjO7GJkbmNW7hbNXgGaFrGB-hdaHdoQRyjJxgoInoqO5_EITuB1KY7mjuHpga4CCh93pYnNnBUnr0IezAjCHywXxovm6Qskyc5O5sHPEs624A3sUhzJxFdPEsUNjNgeUBUwHZsE9kCPQlAYRhn0jEYQDkG2AUxhahtaHWoX0cYdpOHDY210GF4FXBsAA1wTuIsPBdSO8-n6HMvkxhU_g4Ot0Ae-qdINyadhydITG6wyHfIYqoiY58UHU-ZMFFThHgUGGkwQXBvYiyxGeAOf7ssEU-QHoZ4PNQiFRRpmngoSQmIQ9ow6EDoceh3dJTobtsdCFBuvTu79LU1P2hHerhnM6hPKG_oXyhKAg4Mn1sS27SsHJ6MgCaGmAAOnrN2H56PMH1uj2IJnpOeBukEqCAwDpghJ7swTFehQTyAB56P8F7EHd6UJBJYT-gHnoeILfB_xApYQ_oh8H_EOF6ZxBC-m2h9qYPnH96jACznMV4dAhVOi8syPo98NVhoCDI-m3Y9WFKXLtsHVC1kMj6hBDVQFN6s6SdbszA6nooYWoAyPrrbtVA627I-ubBmIFdAClh42FLOMj6QgAiAOPBKWGtwWkAyPoEYSKELYFUYYKg1UCrYWUBlGE1gSRhsADI-hVk544FAJthwAAtYB1hTDDOGJGehrhAYQju2QAXYRsw4JjXYfju7piOBll6BMBwzMb6jmqjsH4QqZpJboWwFWHvdFVh8Nz4cvzC0PqIIDL60aHmYYLAjWGKOJDhaaHCiA9hiaBdYUwwyPp6bn1htvoDYdgAQ2H-btgAI2G44WE8xXjTYR8IU2FOwRNh_KLvdHNhNTBpAIthY8HhwSthksAUYduBp2HbYeRQu2HktoKgh2HjZMdhs4CnYTzAKWKRjk4S1q6nQNk8xSJ4wMV4hBBXYVU6t2FOmEjheEBPYdVAL2FY7h6Y72Fnel9hsHw_YURWpr7dQGVhBQFybB0-YKAJemCgcuEagCjhGzDI-mrgcTwLej1hWOEhPJjhq26DYcV4w2HAAKNhxXj5bt-Q4Wzw4e_Si9DhbLNhL4ALYbl6heCywRThsTAfYfLMPsRu-qUhzKj1QfOQPvoy4N0GSfrM0j6gAO7EiHhwUpJQpiTuqeGU0lTuMW4K7uhhjfp2nApgXqHB-rEIReEuYeuhRmwl4WDubSAF4WGgUSGzAEduFfqcUusAc0Fq7s9uufo87C4YBO4emGn69KhgYcBhPeHAiOgIAZIx4YzMVwRx4dnBVeFy_gAyMeHO7gjeeRAmDIE02AE8gvq2mr4kvnbgXrI0AHpgWsyDXpvhBAB6YH80OAA3gCcgwCqLGkloWnwdptpginDyQFd2UMB_NBzUZ4BqoIlWZ9aqoHpgHNQMyvsQ_NQEAHvhb-EZYOWKW-E74e7gHRT74Yfhx-Gn4aAqL6AqwJfhtNZ4cDfhy-bXdhL4KpRjgE_hZBrf4a_h7-HIEZ_hbzboEX_hZtKqoDFCgBHhQFLo-BFGQKARJ-H18hARF-HJKFfhsBHygLfh9-FIEaQswMpngHvhMUIYEUwR8kDYETQAbBG4EUbS3BFGQIQREUAZoDFCZBHgEefhUBHUETAREHBwEV62d-F4cA_hmBHMEdz4BAA8EXWcHBHygOo4KhFGQEF4GdR74elCghHEETQACBFH4eQRICriEXwqNBHSEXQR8BFyERBwChHqEWzqaBFGEVDA7BEoEV_hehEuEbwRFgD7PlDABhGNAM4RohEUEeYR0BF8YNfh1hGyEQwRBsSKEc_hBIQltp4RahFuEZoR6UI6EWGgt-F-EfQRgJZgEUERN4hUEeAKH0BhEe0AGRF2EYwRbhFOGjYRrhFYEbNq5RFeEYR2BABqzukRy-ZqzoERZhE5ERIReREIzLQRhRGNEWzi8hElEZ_hZREV5mrOFRHAyvwgxbZDEbwR7eDGPnBW4dzEEo84eHBAAVyo0MqJ2LqUuPTCpmAAaxETlK0IdaC1WCBE_LAuCISUtaiM_rY-VZQs2g6Ah4blUD4UrHapnNQQVd6XEecRg-C3EdOUutgigG2an345SElUqh5dmmfg6OQeftAm4L7LWBfm05SCyI8R2Vim2DlwHwBkII4AmAD_bBAAF6D_RFgAyNhApjKB0-AdCHMRgAHgvijY8chAMjlwqGwigIeqnRDGPhveUGH8OjsRxFYnIUA6BxF8FoVuEA54qNlY8T5WvndETxGH6kywXn5_ZLzYP-GXEOJuifIg7rfgP9Y0qDYQ0xHxwKiRT7jzERiRi6RogLiRLjBn4LquXhhZzrZm_QhikRPKkxH6thk-ipHZPn2W2BhAMlXeiJwKlMQS_XCygPEQmFaYAJC8aDSt6NgkP-HgrtqRsvjGPv5Axaj-CiQIUt4hwDv6smaEiB6m62Cgge4ABJEqkXp2ndR_NAsR7LAk_ki6zYTYJD4-3KDdYHhwnIDWpCz-H9g5fm1C3SpukTNgHpGZqvMWqpEQvo6ainDWkfq2aT4UCr7AtWDlUGvhEQgFkaacXKRhEZYy2liaQLvAcZY7AEYUopFpkR0I9ZK1kSjY6pG5cPjgwpF-kYqRIhgusGiRz8D-kWGggpGl6l2RIpHokeL0d8Zk3LMRQ5E9kYqRu3Dkvvq233z9Dmq-uZGZEEWRXpHT4Cq-VsELkfMAGr6z4FIOpX6vYD2-33ykmL2O7kAbkXniVj6KcJ84Pb6KcGCRO_rT4X4KaT5z4UpyGuipZmGsy-HGIM7AVqpagCCglK4gygiS9AG3wDrSGda6cinWdcBEAXYAUMHkAdHBVAFiAS3OT8joKvwBGzCCAebGpdaOxqIBDAGqVqHKw6CfaHZW52i5SksAVlYYUcfytlZxYDhRDlarmDlg65iriD_OgM60uPDOfZhB1tOuIdZpAWPBbwC5ARyg9lBsfh4AUyBqBroQBCzk9sdA1Gwy7P12INjNALCCsFGtGN706A73MIVSkRjWKkcIY_wcQHYAmA7qMIJ0AXhTGCocpWaJQL66G8BJ7LWmwqgsKoOmI6rf4mfGHRhiUWsYoUB_gI9wePbf4MGUYAAw5nFB6UBEADMwQHQ6Qd_goMB6QEYIQHSFga5R8MBbjkFqSez2UW_EeggeUS0AT7KOUWlCW46ijLZRwci1uLVBBrABoH6sjUGaOuaAVuBYZLehEqhDQX86ALq0qDNBfUFoYDKOiiYZURg2LrodsDshCLrlAKI8r8QFUVmwfzqC6KVRVrq5QOjUA0E_OoHgI0HddmfIE0EbQU86TcEPQVNBERCs4ethe2HUYWdBu0H9UURhg1GCoBJhH9g3gOiApCBdyDzhKQBSEEdBqhCjUezhlQEEsnw630G_QYKhNtoCQf7h4cHp8Izha2FjURzh-PhHYcn2J2GW2NZh0GFiwUHhLFFVkD5--MHyYRH2vOGzBNeKitj_PhUQsWTNLPrKDDB4HIJcf_7nUQww50TecPNRtfgRIfwg01H-xKDR5SCKUD9RC1HPeMZY4NFjgJDRs1GYwNDRlUBTkIdRO2HM4YjRYMEBwV7BhsZTDtDBvsHMICpBFiR7UXChG4SCwSKw4cGhuhDRM1F4AOjRftgPhPhR6lZA6NhRF8qgWDgAulb6VuCaThDS3pJEn6DZeJNRJARQ0YDR8NH5pKzRmFGaViRRkFgguA8gEQCpIHCAblrLQNhMi34gEKLRpCBM0YZYJEHsuAi69NFi0ZYUF1GVQO74dNHI0QzRc1Hi0VIQK1E40YekOVEPCBbRaNFW0a9RCJA20RthswS-oVVE7ABS0YRR7NHEUZzRpHiBAT7KwQGcyGcQVwA-0RYKRFH2VqR4XlY3tBEh3QLm0YbRz1ES0Q-ydJTJwQbRWtHO0SbR-0RTxry6PNEJYCK67UahOkR-KzS1rK6AUjAWGqiGY4zoAJbRRtEvUTckhSFmwQzR2tGF0FLRUdGy0e34-dGmEPNAGtGO0f4YWdHzwG5isLiJ-G-SvdFJ0a6OK0jhvtXRtdHJ0bX44FQj0Q74azAa3nXRKdGxTmo2Bj79xiShy9Gz0eUgb5IL0WoAq4DgjIMqIrB3UZckNrLwRKCk09QX0ZUkY4Da0e74V94r0YKg84TyOmUh1cBg1DshIGCGaElcN9YTTOThBxxXUUpQa0GtsvNYOW7F0Blu4OHlLESW4DG1gLFkkvTHISpce2RXLPUGksB-odJG-NH_gCfkGUEdwcZhmuHCSokG0v6PUZJI5KE4oXtsithjEkhh4-Bcspyys0Y6xHE4CFZ7ZLfwxWwJAIKWpPLJ9mpaqHaw7O96-ziKOIVuuBz72KXao37hzpwOWCHJ7GvG66rYyPraK-ApzCUEDPS0OLtsJdrFeLKmyUgsOFkc8jAl0SR-OXY4dPZI6Pa7ssHO9lpCMTY2u7KA1ocoMT4klmSRV1oKQNMWpjF6-N42yDQs-IhOKWKCluUWLrCq0bC409IlAegALDEIzo-ubJqWsKfRTu5vVMPgbTj09Lfw_8AxrCh44KhMMVAAXjHo8nG40TH4CFVylhQb9izYSQAeMSwxGJYAagGB8OR3ysfOiUgsMefOvxF5DkKhJbjMMfgICi7YFHkxCTEMhkkxUvLQcD-WhdCC1uSk7xhuMCyAvNihMcDG3TKRHG8AaDrQ0EG65VFCAIkAHFGoFH4xnFEALLfwW4425p0x9ZDX0UtY4zFG1DNOvX542v4wqTE71PkxtTGXFg0xWKFNMS5kfE62MO0x4W5njPBEPTEF3lyw_jHZwJ7mjIBj9vQhc4jdMXRcxOFdAIG6T1ET0bvRWDibgeX-0zFnMV244zEfAGcczgA03NSwyI67DpUx8ACJMfF-GdArPiv0NEarhrRq-tHF4J8xfzFk3DgQltQYtm54t9SWpILqqK6emoo4pWqw7DXQMxB0MUtiEAG9FrTWpTEgsdUx8X4est2WyfbmJCMxuORUsZYUoNBssAMh6dFwsaMxjpAIseHcSLHCgCixx1LS1uehwuFD6qpkfNHH6lPUG9ERPsZhn9FTzpDsBOH90hswac5jILKxiaBXYYqx8uEn7gAxYBDFEC5O404fEcT4Q1jasXPOe0RqAHqxy05pDoUxvrJbzsdS-U5r0RtucBq7DkuOhUC7zrmoJxRZMa5O8nYxDpNO905nzr5Oj7L-ToFO7n7YsoGBkn7gVMpc8DEtNG3Yx8H9EEJcQFSOMUGxCqKZMePOxdqHzoNYjAhI5JXwodgzzpNYZrExMEFqLDhkWsKIuM6v4k2ooDQJznbOwoiALrsMHs772BnOKM4IlFGxVbGMMe901uYxMBukd3igeNB4dDgGsESIyCHnfnq-UbH3Eda-88Z25Hz-jX4EMLE6WC5LDgkearDcVOSGgnR8VDLIi8buANIAujypwNsxYw7V7B64rcBKQO_g2MDwwH_e1rYkzvmAz8CkMPYGGQCK4Gnsao7yMIcq_ABwVnzgJdzZMDDioHj0xnOxZRhLxuoAH1hkrAPKO9LjgAT03SrpQG68ENr0pHLGVjAWSJwcnE589qVWDkoQMJIA01jbMSNmzdj5YBwcToDkMHYqZDYwMEwwwnRHBlFIxB4wGBvSLcp0zt-GS_SopvB409LbMerc8gwn7vexJdxPsfPG87HlGLaxNHYvjtaBB06tzphOfQTBBhswV2G75HJU3UBqjiNYkuF1GL5MBDAwLvIwuKYE3I78_HEuGL7k0hzZOIHkf-x2APwAhyraxlRxzgy0gIwaC7H0cWVOMC7Odjux2ua3eJt-EnFTAAhUMZBqjsVAhBBPYbwkao7KId5GB8qzWvlaml4emNWmao5AdBEwYSEPsadkTpgSMCFEnrFPzrxqQwwucXCYlOptqsyBo-bHGGZonsAuaBMY0QBTGPjq9vA8IVZBOtgd0BEwGgo7-Dya73TzQKJR5cjoKuZR9LRJEE6YT8GucZYh3kAM3m_-d8YmUZlxrRjyyAVx-XEecXWQBrp8mGxxPgAbstxxpEF8cT7G8oGsss1x5C575J1xSOQfQSfuHXG8JLSxYzGXMVOGHLH_FHcAWP7DgfEwheFxMPtO4lyzeGtOPAT4ThiQcNHJOHE4kY5xXGtOQoELcfdOpo7LcbXeA9HvYCli2TzU_m6-sOKDISyhCG4cUT3wjsG4LM7B1so70dnRj_j1McRaHyhnMQR27FFnMa949zHwwqtxLzG6OCgIhLEUwW3ezdGHca3R6FFs0VhR_tG5SkfhdPDaZOeAV4g6bsDxweFBwdTRMzHGnLTRXmFWRGyx_PplIf0xlACVUeVQR9FSCCfROPEl7GpMZVHEmAMxQzEHWKPeC96mwbawgcH48a_EmUCCweGAcMIkcjrElEBU4ePBcGH8UOWoFNHkoTdSwcEyjprhycHM8TTxoCC7hGTx4yFEMZKg9KEi8Y-A6PG9iMHhCsRnMUtwxoSVUUZUTLGc3tfqSJGznLewFYihWIggU-H0qILxd_BpCAH65wjt4RH6cfqvYL1hGe5D4Rtmyu4E4b3hHDH_8BTS-3ZBHndx5OGm8cgQWNFs4bbRvQhwiKqIuXIg0YdxfvHZwVdhbvHZwU9hveGQypdWgOE-ivkBYKCbWMvh1x78HuBRoizGIEAEJMFQUW-RWjofkTo6XAHfkQY6ysiHiBlxbkBwUTZoAgEn-gvuZ_qHiMqqL8rjmJBYYQGSICHKbQHrrsVo2qCHOnrhSHTLYKc6WoApURlRsYgZUcxQWVF1UblRIcFVUb86zFC1UbLxtgINUSMATVE1gD9BeVGPgDeh9cA88eHBfPHXUdzBjPEE0dzeRNE4AJRh8hCDPP7BQeHgoR8Y_BoXvggU2_GU0QLBIcFi8Q66ZxyT8Qfx_4BtnCvxFgCL8e_Rm_HbwABhPQaSkX5uhrENBO7hwOCJJuqxRToRIZ_xy5q5jn9wI37NmpvRqz4PaCcQsqCyoKFhdKpWod7hz6EFhhLefDEUljIQrBIxMJJudJTo4c9xb6G4YSDQMZbU4GjmCK7rbtyh2AnE7uhhCNDUCTLUsLgnEKGuEkCoCagA6AnfIBUQ3Am8CdMwqMA3RAIJecwa2ECM1zh5eKIJoWF-khtskqEhvkpA7dIUsuBQNt4SCKniwmo_ABaARVw71BaA7D5WHPEsS_GCzrOA9gBuhKxgzIpN8aOgLfE7mG3xHfHhyuLEYoImCdQ84KBu9mIqT7Jl9jHMsRTPypYJzQFByu3xn8rhyiBW98oGCWDUwXqmNDceoa5_YRwJOpAzMJIJ_Ak9cMDg2zAoaubI1TQ1XA6g5iThpFLBbkY21J40qLGE0lAaiowyEGQJ7ARnEPQJbjRg1EYJKQCOCdPYkno1ajy8VQnYgAQuMxBsHsUAsxbcGjnqVrhe7Dlw8pJusFH-e7ipwLHMOwAKgv6gBuodBKnAguFRQJ4yAywtemMAytZj0DceO9i71inMGjCSKiseU_Sc7BowyNDwdLkcS_GhCc40uQ5lBGRB9ZBZCWTULlRAzGix2OoFCf0QRQldJmAJOpBVJthKHdDrbk_qFAnMCYMmmoSGCQ4JpgkGpJ8JTgmNCTW-bR6KQFgAtWLAiZZAnuqIUAMJh9IFCFrmTxCIUOMJIwm9FjL-hEHfrv5MtfQfgLiu5mTQrBYAQHTTCQwI-gY2SO9w1UipwE-yk_R2EJaMWInzdE90oXbvcKcqhdjNsEAETXZTVDNAFA7SMCkwPcBTsHt231ikiRSJBQy8dCo27qQrVDhszaAJgDpOpoH_WDEIjKFMLCmgFkC2nhO4eCo0dG4gmio-XipxBsjZwQdRZracuocxWl6y9BCmwonciaj0Hwl1CaYJxPYV7MexCgwLonMB1Ql6unBkuok9ZowIhom_CW72QoG-XmKCFok0MSKJ4jy3QCKJ4Im77JCJLaA2iU90sIlL-P6JBQywgpJ2oonTwCOALKRb0kjqOD5H6Av-_SCIUB3s3QA6cZwMg6x6BuXGhJRjDoSmLp5ckKSJpnTf8UvxJhTDEPpUFti24dGUIAlTcZIo5Qk_CdUJ2mALovUJ5KDZyiOoVriNnP0JPolDCa2JLoAbcdoKHRhhifJ236jbUbBhkAkuEm9UXjhXETAxmQ7y0POIj1SSoSJQmxhETsah3PabGHqOFDH5oG6EPg4P6l0myVIjgfZKF97psomJBeCDCbz08jAKqNOO7qQfGO5IrkDIgAYO2WaEMSjxiFBSEN6JUXAdiXtmHqZdid_4wsh9WBnApbIOaBRgHRhDwSgxb1RasSaxf47XCcaxBU5JDutu4EnWsVF-Q44kvrh2405w_nyO9rFutvAUctQHzm5OcpAesdZUF06adhp2dAA_EXwuIOQBOOmOXnE4SUEch5SoriLWGnHGUdyO2EkINDVOK1hPsqGJRm52cdqOZEkMSaROz840ST4wcXEtAKbYlfHoKn96ZiGETn5xoSEPGBYhEjDOceJJQJgH4klxJxjhceMY5npRcS0Yl0yS3iJQ04kiHAEQMVhBHINx6DGCOj-gj-ioNo1MGnHD4KSGq-A_duwAAAC9Lc7CCI46YnB2MBaBvbBHxvEOBWClbMXMyXbLsW0CRb7AlvOJMZDwlvlkMC7MDPLQ84lTNpxeEOCX1ASavYnnPkKMEDA4lFemO9jmTJQxy1TZCS7kOgyJSOzOer4sSai-QowIlE1-fVgs8K_gpDAFqMcAqUm7AMkw3YiQcRowdMbKiZ4cnILvdN-JVxBZAHwBQmGwzCVM7rh9WBIwvQ4Q2vuxu9ZkSJLAUoAVzIWACYkrscPaHYqQqDlBH45mNDBgy4luCZQuS4lijr3mv8qahASamwAmiZaUXFRxiaFOiYmtwIQwjhgCClG-2Bo7KLBul2yUAHKYBE6tzjdEc4kwLghUTUxeZBsO-XTZSY8-6UApiR_GkMBPotWy_UQ_xhsOGXRPSaXK7UlcHMwq3Um49F-x20mjSV9J40leSTAAzEh-SUVUJ0mogB4g50npcQ9JhJSlcdyO_xB3SemybThAyRpq4OygySNJ3kkQyeY4OoBQyf8QsMl3MESYCMlnSaaIN8Y_SdOUaMmETsxImMkgYDwhPaqJAMIJ0C47AqZRPGDFePYyJMmh3KnAMMkwLtJJsJhAmLnA_Mkr1C6As0kiydCwrnFrEvJJYXFcIZFxE-DpNpqEkUz6SeCJlAC8QWzJn0nZsbxJWAC0JokA2tgXSdzJZqC8ydEAE0lEEjSofkkyycEgrnHiyZbJUskfjrbJKuByyf5coXELgIpJFxgqSarJsTDqyZfxgcH0oUZJhsl9qsOxvTHv8bKQ_QlaycZJTUyYlNWJ9omWiac4a05vTgUAeOTdwXMw64nxDjgAuAD5TB10GcnUPD4Otw6IJuaae1IacddJdEmcyYROdQozSVNJLc4riXtQU4mkSf9kmkmHRmw6-o4GiTMCDYnvFGgxAcnkoQ-JMNGaFicxcvFt3oL8qABE2GA0eFa6yfGxNZTZMdEOgoQ89Ip2goSFybgAeEkjWPPJlHYTAIRJmf76SUvxDYlu2JnJ7gjZyXjkMcAHyfJMRmYrWJ5UCckNCdnKai53ieChZ-DjyfchdGEvyDggTUm0AC1J-wnU4KU41R70ZtZx2tg2spG-YKRlUWVJwH7sGNFJYzpXAAV--9SXCYUJDvHFCZqEpQnvCfHJnclfCR3Q9YmmCX8JQb7LyE9MbYnPiSX0OCnvifsEeTR1sofeCPja8cn2OyFfaspmHBbbam0g_oRwkhIK_aiJ4fSI9_HmYLH6Loi--urutvEcKZZKDuHink7xPNIt4a7xAinJ-tCIjAk4YfnhWeFe8aX6NeFSKXacCfETHH3xE8o-ipkBzFFk8flWg4gZ8bnuWfGmdDnxpmiUAVS04zLvlmeWs4FJdFGBP-iQVkemdFHeUoYBGEgG_lrBpgFeyrrBZgqAKo4o2RH0WF3xe14m7oc6n3Fk8UTew3abSD9xD3HPMU9xoAlB5lDYBdxRAFAAeGZn4FH2AEmbWqB4muGQwcfxJNF-usL-k-zdAHUUQCCpNiFhGHjP4PxRb1i8TsJRO9jgUUiBZ4xJruDRO_GQDNbBh9ixAPSgWSl1KUwBy7rssMYqriliEWAqrtJsRA8YXzoe9JPBtojqoapc1p4CigMppLCsAP6gbiLyOj30ksCRKfEAMSkYAHEp17jRRqxhEckSCPMpxYATJMfxvPCfaNco_K5MRM4Ay2ivoHdylrC9AaiQXL7mobasLXK2wTAAOrh72NUpx_EYQSckCByveEsSSxImAeO0OsH6wEB0UGYIkG8pasAfKcKBSPH1kE1aasHOwckppAE2wc7Bt3G_0Us42-yXKc7BNymZQcDxCdHckOThCKmKuI_R_3FhKRHBN1EXFL8x_zH0EF_xSnZCwGNxh_QuEG_xIWAnKcIwpU5dJrzYRRHPwEYoGQZHIG5AQCruKaOYIurl7tgkdKmvxK0pzKluKS0R9Fgi6v0ptKk2EeCuPKksqfypbKlRRKwKXKkMqQAqvKntKQKpF6F3iZSpLhBNPitgzJEAEK10JKnUsFZRwOzdyfvxFKlk3Lv0ERBYANakBFAqqXcAaqkEAKbYvsnKqUapYlBGZscp9qn0EFapptgFNtMxFql2cGapQeGeqa6pMTLg0Z6pIWDeqVywvqkdsGCRAanOqaqpHbDUSXRW_CB30ftEf3GhKaZe8dE_YPCpZY7oqY9xqdGhuszx5KllKfAApyl1NnrxOKnDyTmprPGLQGMQojEMkOxUmIlDDILoC_74Pt0BB-ArziW-7-CZBGMAqzTKMDrGDNFxWGPMCAjTTEB0FiCFgMA0hAgH4I2MvYDyZEAQiw6XsQWQyDAnDDBgAwDsJL-xSwG5WoR0YcE6-ET2kHjrSZGJxLClgZbYziwRfq6JmkELBN1mQlyXAUJcv7F0QZaBSkDcCMYhtYCBXmG6qamoqempiamp0Wd-UpaGWJzYgqGNqdcpC05Aqd2IIKnk4fqR905ASC6AZNHYFC-p1rEN2vV6AyyLDnpBRwA4LiaBJb6XqcEAjEFljqXa36kIqdnJaUC_KVXK5gHCgUMMEGkhbEWBh3F4jsZh1BBCXI2hkkqBsfIBF5b-rMYpNGnUgW8xvbEmKeGB2W4SQOYpEFbaAVOmz7IksNmBerh3yp0WGGlrTknsfGmugC6BspzniNrBTimfKVrmuRyiaVmA1zhHhmmp906FgScWS4GaPsWpwKnogc7BQGm3KSzQT6na3Jpp_6naaYBpKBCEqTrxgqHeDlSpHqmRqZapHbARIUXBRWAnKbRgYGnVlD-OSbHHzlZpLhBbya-2Hyg03MphKPFbOnQA5TH15gFpganoTLxEeakf2C0wsM7ulCKwgammqRfJNmnIgQ6px8nlQHwg2L403BShYWm2aV6p3EnICSBglfAkqWEm-klBaVMUD1CDai6xh85eaXcAnmm0iMVpPmn-of5pUsGBaWzxwWn5aV0QWWkw5lM6DubkKXnCxWkFqR_RhNZEAM_ITqkpaS6p9mnvnPLQs2bFaQFp4KFlabwxD2jnRvL2NWk2jCJQM2m9AQSGmEbCsOtp9Wm9AcaI30Y6pLSIWijmXMtpAPwtyjcwbX5Q1stpOiGDEsRKhM55qah42QBErEhQ9KF72qGwZDZr4AHAYMr5AGbKyQCLutiePCTgxp0O73KaTg2ENHoRAOKA9KGo5nlYBwraQksABGCXaQMsBmFZsndKNIaXVFDpexDC_l-OM8n9WDkxXZqQ6T1cjWn10L3J8vF7EIrx_2yDyaUiyAmYlPdGtzCKaU2hEYlzrDDp-wpSbmFCtS506UoIyImZslBcBHHwuv-s2OlHCdpAxWmkdnOsGCzfQcLpvQGqPo3BPwhVaZ2adZQjWJXwxOkPCgIudyngqSSpilBaafRsVymB0Evs-iAEHlhpd8p_KqssHuyP7rcOvyrf4qN-DSnVCakp3yAGTC5k6jEOgHgxWhiKyBZIb7FtqnsQFWb-aRO49MZlRmw-HuzdadpCAyx66asp_zrrKVbBmynqbtEUGwjYRPspvaCvoFN-HSoe7E1h9OqE0eCp4bF4ZniBgWQVWIoAFVjqZI3REckrZNTRqi5fQYCShWI7AIHBM1z5poPwC1zF_CLcQIDEgFUA3gD5hL-A9LTE_FoCQlEi3J_GkMDt6SAALM79AJz2ItwcTrhAJuAIcBZRpbyLwC_A48x2yhY6kATlACCAzek_gvTcVYJFMAJ8zMBYQL3pIIERgKckroLlUImwWoAi3IaWMUI4AK48jWLB_GXxFPz8AEfp2MBIwIkS7_z76TXAh-l6QJDAOADhhDn8--lsATmuh-k36SOqb-nB_Dmuo8DjwIfpE6qIwGfp2jwxiqQgT-mv6a48kUB_6do8gzQ4YAAZ36BEYFgi6dyGlkg8r-kbInG81qoUZI7chpbP6Z_G9-kQQLuI4YqMBHgZBBmQwB3A6P4Hyu_p94IIUXXxT-6UmIfpRkCv6a_pRBlCFH0AIhS0lMwZL-lwGeL8s-lWOtkCIAD4GawZfBkyQrvykiyH6SOq98q0GRwZJAJFGhKAPBkQwGIZH_wm_mpik_puBofpoBl36bIZ2B511sTc1a4uZj9iaNyIAPzOeNw8vETcWUBZmPFORBnn_loZiRI96bIZE_rSfBb-FEJH6TgAiMAqGe28-ikb6eQZJ-lsGbQZs-nWgFIZLBmn6RW8KmhmwAvpuACSuo8gCnLV6YOIgtxnXitcQDyFYHwMk4h5wCrcCgAJYUAAA`} __position={0} __code={'<Map viewport={{ center: [0.026, 123.61], zoom: 5 }} />'} __scope={{props: this ? this.props : props,Map}}>\n  <Map viewport={{ center: [0.026, 123.61], zoom: 5, }} />\n</Playground>\n           </MDXTag>\n  }\n}\n  "],"sourceRoot":""}