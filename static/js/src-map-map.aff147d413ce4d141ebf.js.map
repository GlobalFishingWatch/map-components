{"version":3,"sources":["webpack:///./src/map/glmap/map.css","webpack:///./src/map/lib/Pack.js","webpack:///./src/map/lib/pelagosClient.js","webpack:///./src/map/proptypes/tracks.js","webpack:///./src/map/proptypes/layers.js","webpack:///./src/map/proptypes/shared.js","webpack:///./src/map/config.js","webpack:///./src/map/module/module.actions.js","webpack:///./src/map/module/module.selectors.js","webpack:///./src/map/tracks/tracks.selectors.js","webpack:///./src/map/constants.js","webpack:///./src/map/utils/getPBFTile.js","webpack:///./src/map/utils/heatmapTileData.js","webpack:///./src/map/utils/buildEndpoint.js","webpack:///./src/map/heatmap/heatmapTiles.actions.js","webpack:///./src/map/heatmap/heatmap.actions.js","webpack:///./src/map/glmap/viewport.actions.js","webpack:///./src/map/glmap/interaction.actions.js","webpack:///./src/map/utils/map-colors.js","webpack:///./src/map/heatmap/HeatmapSubLayer.js","webpack:///./src/map/heatmap/HeatmapLayer.js","webpack:///./src/map/tracks/TracksLayer.js","webpack:///./src/map/activity/ActivityLayers.js","webpack:///./src/map/activity/ActivityLayers.container.js","webpack:///./src/map/glmap/Map.js","webpack:///./src/map/glmap/Map.container.js","webpack:///./src/map/utils/getMainGeomType.js","webpack:///./src/map/glmap/style.actions.js","webpack:///./src/map/tracks/tracks.actions.js","webpack:///./src/map/utils/withReducerTypes.js","webpack:///./src/map/module/module.reducer.js","webpack:///./src/map/tracks/tracks.reducer.js","webpack:///./src/map/heatmap/heatmap.reducer.js","webpack:///./src/map/heatmap/heatmapTiles.reducer.js","webpack:///./src/map/glmap/viewport.reducer.js","webpack:///./src/map/glmap/style.reducer.js","webpack:///./src/map/glmap/interaction.reducer.js","webpack:///./src/map/map.js","webpack:///./src/map/map.mdx"],"names":["module","exports","map","googleLogo","byname","Uint8","size","Uint8Array","BYTES_PER_ELEMENT","array","getter","setter","Int8","Int8Array","Uint16","Uint16Array","Int16","Int16Array","Uint32","Uint32Array","Int32","Int32Array","Float32","Float32Array","Float64","Float64Array","writeStringToArrayBuffer","str","start","end","buf","bufstart","undefined","length","i","charCodeAt","arrayBufferToString","String","fromCharCode","apply","Pack","typemap","byarray","pack","typespec","value","littleendian","ArrayBuffer","DataView","stringToArrayBuffer","res","Uint8ClampedArray","buffer","name","spec","PelagosClient","_classCallCheck","this","MAGIC_COOKIE","url","token","Promise","resolve","reject","request","XMLHttpRequest","open","setRequestHeader","concat","responseType","onload","handleData","bind","onerror","send","self","error","readyState","success","status","isFileUri","response","byteLength","dataView","headerLen","cookie","slice","getInt32","offset","headerIsLoaded","header","JSON","parse","rowLen","colsByName","colidx","cols","col","idx","type","multiplier","min","max","orientation","errorLoading","toString","allLoaded","result","rowidx","row","val","colValues","eval","trackTypes","id","PropTypes","string","isRequired","data","object","color","oneOf","layerTemporalExtents","arrayOf","number","fitBoundsOnLoad","bool","shape","hue","filterValues","endpoints","isPBF","temporalExtents","temporalExtentsLess","field","values","node","VESSELS_BASE_RADIUS","MAX_SPRITES_PER_LAYER","TILES_URL_NEEDING_AUTHENTICATION","startLoader","dispatch","state","loaderId","Date","getTime","payload","onLoadStart","completeLoader","getState","loaders","Object","assign","onLoadComplete","setHighlightTemporalExtent","highlightTemporalExtent","getTemporalExtent","temporalExtent","getHighlightTemporalExtent","getGeojsonTracks","createSelector","tracks","filter","t","getGeojsonTracksReady","mergeStyles","style1","style2","sources","_objectSpread","layers","_toConsumableArray","filterGeojsonByTimerange","geojson","_ref","features","featuresFiltered","reduce","filteredFeatures","feature","properties","coordinateProperties","times","filtered","geometry","coordinates","filteredCoordinates","coordinate","index","timeCoordinate","push","filteredFeature","getFullTracksStyles","hasTemporalExtent","hasTracks","timerange","acc","track","source","style","_defineProperty","paint","line-width","line-color","circle-radius","circle-color","getHighlightedTrackStyles","getTracksStyles","trackStyles","highlightedTrackStyles","TRANSITION_TYPE","BRUSH_RENDERING_STYLE","NORMAL","BULLSEYE","BRUSH_ZOOM_RENDERING_STYLE","CUSTOM_LAYERS_SUBTYPES","getPBFTile","tileUrl","fetch","headers","Authorization","then","ok","Error","blob","reader","FileReader","addEventListener","pbf","Pbf","vectorTile","VectorTile","readAsArrayBuffer","catch","e","console","warn","getTemporalTileURLs","urlTemplate","params","urls","forEach","extent","urlParams","seriesgroup","startTimeISO","toISOString","endTimeISO","tileCoordinates","x","y","z","zoom","templateSettings","interpolate","template","urlTemplateCompiled","buildEndpoint","temporalExtentsIndices","indexOf","getTilePromises","tilesetUrl","promises","urlIndex","obtainTile","getCleanVectorArrays","rawTileData","vectorArray","groupData","cleanVectorArrays","columns","currentArray","totalVectorArraysLength","sumBy","a","longitude","filteredColumns","column","key","cumulatedOffsets","appendValues","set","getTilePlaybackData","prevPlaybackData","tilePlaybackData","zoomFactorRadius","convert","getZoomFactorRadius","zoomFactorRadiusRenderingMode","getZoomFactorRadiusRenderingMode","zoomFactorOpacity","getZoomFactorOpacity","columnsArr","keys","c","storedColumns","sigma","weight","hidden","pull","uniq","_loop","point","geom","toGeoJSON","latitude","timeIndex","getOffsetedTimeAtPrecision","datetime","_lngLatToWorld2","_slicedToArray","lngLatToWorld","worldX","worldY","radius","sigmaToRadius","opacity","weightToOpacity","series","frame","addTracksPointsRenderingData","hasFishing","_lngLatToWorld4","getTracksPlaybackData","playbackData","vesselSatisfiesFilters","every","selectVesselsAt","tileData","tileQuery","startIndex","endIndex","currentFilters","vessels","toleranceRadiusInWorldUnits","_loop2","f","_loop3","wx","wy","filters","pass","some","vesselSatisfiesAllFilters","vessel","getTilecoverLimits","viewportZoom","Math","ceil","tilesAvailable","min_zoom","max_zoom","flushToReleaseTiles","heatmapTiles","currentToLoadTileUids","currentTilesToReleaseUids","currentToReleaseTileUids","releaseTiles","markTileAsLoaded","tileUids","flushTileState","forceLoadingAllVisibleTiles","arguments","currentVisibleTiles","tilesToLoad","tilesToReleaseUids","currentLoadedTiles","visibleTile","find","uid","loadedTile","tilesToLoadUids","tile","referenceTile","ADD_REFERENCE_TILE","visibleHeatmapLayers","heatmap","heatmapLayers","visibleHeatmapLayersIds","visible","getTiles","updateLoadedTiles","debouncedFlushState","debounce","updateHeatmapTilesFromViewport","mapViewport","viewport","currentTransition","boundsViewport","PerspectiveMercatorViewport","bounds","unproject","width","height","wn","es","w","s","n","boundsPolygonsCoordinates","limits","w1","e2","viewportTilesCoords","tilecover","tiles","viewportTilesIndexes","indexes","visibleTiles","coords","prevZoom","queryHeatmapVessels","temporalExtentIndexes","uids","_queryHeatmap2","_queryHeatmap","layer","isEmpty","isCluster","isMouseCluster","foundVessels","highlightedVessels","layerId","HIGHLIGHT_VESSELS","tilesetId","subtype","clickableCluster","highlightableCluster","clearHighlightedVessels","highlightVesselFromHeatmap","heatmapTiles_actions_objectSpread","UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES","UPDATE_HEATMAP_TILE","getTemporalExtentsVisibleIndices","loadTemporalExtent","currentExtentStart","currentExtentEnd","indices","temporalExtentStart","layerIds","referenceTiles","newTemporalExtentsToLoad","loaderID","tilesByLayer","heatmap_actions_toConsumableArray","allPromises","heatmapLayerHeader","_heatmapLayerHeader","heatmap_actions_objectSpread","temporalExtentsIndicesLoaded","queriedTemporalExtentsIndices","visibleTemporalExtentsIndices","temporalExtentsIndicesToLoad","difference","tilePromise","pelagosPromises","allLayerPromises","all","loadedLayerId","loadLayerTile","_ref2","points","parseLayerTile","loadAllTilesForLayer","layersVessels","availableTiles","bestTile","layerVesselsResult","layersVesselsResults","layerVessels","hasEncounters","layerVessel","v","uniqBy","updateHeatmapLayers","newLayers","currentLoadTemporalExtent","prevLayersDict","newLayer","prevLayer","interactive","prevLayerId","l","transitionTo","increment","callback","onViewportChange","center","canZoomIn","canZoomOut","mouseLatLong","getFeatureMetaFields","staticLayerId","mapStyle","toJS","metadata","getStaticLayerIdFromGlFeature","glFeature","findFeature","glFeatures","mapClick","cluster","currentActivityLayersInteractionData","event","fields","metaFields","metaField","pow","area","toLocaleString","maximumFractionDigits","title","label","isLink","target","zoomIntoVesselCenter","onClick","interaction_actions_objectSpread","hsvToRgb","h_","s_","v_","h","parseFloat","floor","p","q","mod","r","g","b","round","hueToRgbDefaults","hueToRgbString","rgb","hexToRgb","hex","exec","parseInt","hueIncrementToHue","hueIncrement","wrapHue","HeatmapSubLayer","baseTexture","renderingStyleIndex","useNormalBlendMode","stage","PIXI","particles","ParticleContainer","scale","alpha","position","uvs","blendMode","BLEND_MODES","SCREEN","spritesPool","initialTextureFrame","Rectangle","mainVesselTexture","Texture","_setTextureFrame","clearSpriteProps","spritesProps","spritesPropsCount","destroy","children","textureFrame","clone","hueToHueIncrement","VESSELS_HUES_INCREMENTS_NUM","update","numProps","resizeSpritesPool","sprite","setTransform","numSprites","delta","toRemove","removeChildAt","toAdd","_addSprites","num","Sprite","anchor","addChild","worldToPixelsSimple","m","HeatmapLayer","React","Component","_build","_destroy","_redraw","nextProps","useRadialGradientStyle","props","setBrushZoomRenderingStyle","_this$props","rootStage","customRenderingStyle","subLayers","renderingStyle","rendering","setBrushRenderingStyle","brushRenderingStyle","toUpperCase","_setBrushRenderingStyleIndex","brushZoomRenderingStyle","_this","cappedZoomRenderingStyle","newStyleIndex","subLayer","setRenderingStyleIndex","_this2","_this$props2","defaultHue","allHuesToRender","currentlyUsedHues","allHues","_createSublayer","_destroySubLayer","_setSubLayersSpritePropsForTile","numFilters","hueToRender","render","_this$props3","viewportLeft","viewportRight","len","fi","scaledX","scaledY","mtx","pixelProjectionMatrix","_ref3","HeatmapLayer_slicedToArray","pitch","worldToPixels","pushSpriteProps","defaultOpacity","defaultSize","removeChild","TracksLayer","Graphics","nativeLines","clear","highlightTemporalExtentIndexes","overInInner","overExtent","drawFishingCircles","fishingCirclesRadius","drawOverTrack","_drawTrack","substr","lineThickness","lineOpacity","prevSeries","prevWorldX","prevWorldY","_ref$worldOffset","worldOffset","circlePoints","lineStyle","duplicateWorld","currentSeries","_worldToPixels2","TracksLayer_slicedToArray","moveTo","abs","atDatelineWorldY","isWestToEast","worldXEnd","atDatelineEndWorldX","atDatelineStartWorldX","_worldToPixels4","x1","y1","lineTo","_worldToPixels6","x2","y2","beginFill","circlesLength","drawCircle","endFill","ActivityLayers","touches","queryCoords","clientX","clientY","heatmapFadingIn","heatmapStage","_heatmapFadeinStep","BaseControl","exportNativeViewport","_context","_updateViewportSize","_this$props$viewport","pixi","transparent","antialias","renderer","canvas","view","container","appendChild","baseTextureCanvas","blurFactor","tplCanvas","document","createElement","tplCtx","getContext","diameter","yCenter","gradient","createRadialGradient","rgbString","addColorStop","rgbOuter","fillStyle","fillRect","beginPath","arc","PI","fill","lineWidth","strokeStyle","stroke","getVesselTexture","fromCanvas","ticker","add","_onTick","viewportWidth","viewportHeight","resize","dim","_viewport$unproject2","ActivityLayers_slicedToArray","wrappedLongitude","heatmapFadeinStartTimestamp","now","timeElapsed","highlightedClickedVessel","highlightLayerData","highlightFilters","ActivityLayers_objectSpread","leftWorldScaled","rightWorldScaled","shouldUseRadialGradientStyle","toggleHeatmapDimming","_startHeatmapFadein","err","gl","getError","log","_this$_getHighlightDa","_getHighlightData","react_default","ref","onMouseMove","onTouchStart","heatmap_HeatmapLayer","tracks_TracksLayer","propTypes","func","contextTypes","getHeatmapLayersAsArray","ActivityLayers_container_objectSpread","getTracksWithData","getTemporalExtentIndexes","startTimestamp","endTimestamp","getHighlightTemporalExtentIndexes","connect","ownProps","nativeViewport","topLeftPx","bottomRightPx","topLeftWorld","pixelsToWorld","pixelUnprojectionMatrix","bottomRightWorld","northWest","southEast","north","south","west","east","PopupWrapper","closeButton","onClose","esm","offsetTop","tipSize","closeOnClick","Map","Map_classCallCheck","Map_getPrototypeOf","call","Map_defineProperty","Map_assertThisInitialized","_mapContainerRef","mapContainerStyle","window","getComputedStyle","setViewport","Map_objectSpread","mapHover","glMap","clusterId","cluster_id","sourceId","glSource","getSource","getClusterExpansionZoom","err1","getClusterLeaves","err2","lngLat","onMapInteraction","getMap","isDragging","cursor","resourceType","match","mouseOver","_resize","setTimeout","removeEventListener","_this3","maxZoom","minZoom","transitionEnd","onClosePopup","clickPopup","hoverPopup","interactiveLayerIds","className","styles","onMouseLeave","setState","onMouseEnter","getRef","transformRequest","onTransitionEnd","onHover","getCursor","ActivityLayers_container","Map_PopupWrapper","content","defaultProps","getInteractiveLayerIds","staticLayers","getMapStyle","mapStyles","trackLayersIndex","lastIndexOf","finalMapStyles","mergeIn","mapStylesLayers","get","trackLayer","insert","fromJS","interaction","lat","long","popupFields","mainPopupFieldId","toLowerCase","featureTitle","objects","TYPES","geoJSON","setMapStyle","updateGLLayer","glLayerId","refLayer","currentStyleLayers","newStyle","glLayerIndex","findIndex","glLayer","visibility","setIn","toggleLayerVisibility","isBasemap","initialGLLayer","GL_STYLE","refLayerOpacity","labelsVisibility","getIn","showLabels","currentGlLayer","currentStyle","glType","defaultStyles","styleType","hasFeatures","applyStyleToAllFeatures","allPaintProperties","style_actions_objectSpread","glPaintProperty","glPaintFinalValue","selectedValue","fallbackValue","paintOrLayout","includes","layerColorRgbString","layerColorRgb","replace","applyLayerExpressions","addCustomGLLayer","tileSize","allGeoJSONTypes","numByGLType","geoJSONType","glTypeMax","getMainGeomType","layout","layerIndex","reverse","splice","instanciateCartoLayers","cartoLayersPromises","sourceCartoSQL","mapConfig","options","sql","mapConfigURL","encodeURIComponent","stringify","cartoAnonymousMapUrl","json","layergroupid","instanciatedCartoLayers","cartoLayer","tilesURL","newSourceId","commitStyleUpdates","basemapLayers","style_actions_toConsumableArray","bl","currentGLSources","workspaceGLLayers","workspaceGLLayer","finalSource","srcGlLayer","source-layer","finalLayers","addWorkspaceGLLayers","customLayers","isCustom","glLayers","glSources","cartoLayersToInstanciate","newTiles","cartoLayerInstanciated","cartoLayersInstanciated","ADD_TRACK","UPDATE_TRACK","getTrackDataParsed","time","Infinity","timelineBounds","getTrackBounds","tbbox","minLat","minLng","maxLat","maxLng","getOldTrackBoundsFormat","addOffset","geo","lng","updateTracks","newTracks","prevTracks","newTrack","trackId","prevTrack","trackHasData","trackHasUrl","geoBounds","cleanData","rawTrackData","statusText","_getTrackDataParsed","targetMapVessel","finally","withReducerPropTypes","propTypesSchema","reducer","initialState","onAttributionsChange","withReducerTypes","instanceOf","action","module_reducer_objectSpread","module_reducer_toConsumableArray","loaderIndex","exact","tracks_reducer_objectSpread","tracks_reducer_toConsumableArray","trackData","removedTrackId","DEFAULT_TRANSITION","transitionDuration","transitionInterpolator","FlyToInterpolator","transitionEasing","easeCubic","bearing","attributions","sourceKey","attribution","mapReducer","combineReducers","ModuleReducer","TracksReducer","indicesAdded","heatmap_reducer_defineProperty","heatmap_reducer_objectSpread","heatmap_reducer_toConsumableArray","newTile","layerTiles","tileIndex","tileUid","releasedTileIndex","releasedRefTileIndex","newHeatmapLayers","heatmapTiles_reducer_objectSpread","tileUidsMarkedAsLoaded","newMapStyle","glyphsPath","style_reducer_objectSpread","style_reducer_toConsumableArray","viewport_reducer_objectSpread","currentZoom","interaction_reducer_objectSpread","composeEnhancers","compose","process","MAP_REDUX_REMOTE_DEBUG","REACT_APP_MAP_REDUX_REMOTE_DEBUG","store","createStore","applyMiddleware","thunk","throttleApplyTemporalExtent","throttle","currentFilter","applyTemporalExtent","setTemporalExtent","updateViewportFromIncomingProps","incomingViewport","viewportUpdate","MapModule","initialized","errorInfo","prevProps","indicesToAddByLayer","heatmapLayer","oldVisibleTemporalExtentsIndices","newVisibleTemporalExtentsIndices","layerIdsWithIndicesToAdd","currentViewport","componentStack","react_redux_es","Map_container","vp","fitBounds","padding","MDXContent","map_map_classCallCheck","map_map_possibleConstructorReturn","map_map_getPrototypeOf","components","_objectWithoutProperties","dist","parentName","href","index_m","__codesandbox","__position","__code","__scope","map_map"],"mappings":"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","file":"static/js/src-map-map.6806de2f.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"map\":\"map_map__2QkEc\",\"googleLogo\":\"map_googleLogo__1hHOD\"};","var byname = {\n  Uint8: {\n    size: Uint8Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint8',\n    setter: 'setUint8',\n  },\n  Int8: {\n    size: Int8Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint8',\n    setter: 'setUint8',\n  },\n  Uint16: {\n    size: Uint16Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint16',\n    setter: 'setUint16',\n  },\n  Int16: {\n    size: Int16Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getInt16',\n    setter: 'setInt16',\n  },\n  Uint32: {\n    size: Uint32Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint32',\n    setter: 'setUint32',\n  },\n  Int32: {\n    size: Int32Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getInt32',\n    setter: 'setInt32',\n  },\n  Float32: {\n    size: Float32Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getFloat32',\n    setter: 'setFloat32',\n  },\n  Float64: {\n    size: Float64Array.BYTES_PER_ELEMENT,\n    array: 'Float64Array',\n    getter: 'getFloat64',\n    setter: 'setFloat64',\n  },\n}\n\nvar writeStringToArrayBuffer = function(str, start, end, buf, bufstart) {\n  if (end == undefined) {\n    end = str.length\n  }\n  if (start == undefined) {\n    start = 0\n  }\n  if (bufstart == undefined) {\n    bufstart = start\n  }\n  for (var i = start; i < end; i++) {\n    buf[i - start + bufstart] = str.charCodeAt(i) & 0xff\n  }\n}\n\nvar stringToArrayBuffer = function(str, start, end) {\n  var self = this\n\n  if (end == undefined) {\n    end = str.length\n  }\n  if (start == undefined) {\n    start = 0\n  }\n  var res = new Uint8ClampedArray(end - start)\n  writeStringToArrayBuffer(str, start, end, res, 0)\n  return res.buffer\n}\n\nvar arrayBufferToString = function(buf) {\n  return String.fromCharCode.apply(null, new Uint8Array(buf))\n}\n\nvar pack = function(typespec, value, littleendian) {\n  var array = new ArrayBuffer(typespec.size)\n  new DataView(array)[typespec.setter](0, value, littleendian)\n  return arrayBufferToString(array)\n}\n\nvar Pack = {\n  typemap: {\n    byname: byname,\n    byarray: {},\n  },\n  pack: pack,\n  arrayBufferToString: arrayBufferToString,\n  stringToArrayBuffer: stringToArrayBuffer,\n  writeStringToArrayBuffer: writeStringToArrayBuffer,\n}\nfor (var name in Pack.typemap.byname) {\n  var spec = Pack.typemap.byname[name]\n  spec.name = name\n  Pack.typemap.byarray[spec.array] = spec\n}\n\nexport default Pack\n","import Pack from './Pack'\n\nclass PelagosClient {\n  constructor() {\n    this.MAGIC_COOKIE = 'tmtx'\n  }\n\n  obtainTile(url, token) {\n    return new Promise(\n      function(resolve, reject) {\n        this.request = null\n        if (typeof XMLHttpRequest != 'undefined') {\n          this.request = new XMLHttpRequest()\n        } else {\n          throw 'XMLHttpRequest is disabled'\n        }\n        this.resolve = resolve\n        this.reject = reject\n        this.request.open('GET', url, true)\n        if (token) {\n          this.request.setRequestHeader('Authorization', `Bearer ${token}`)\n        }\n        this.request.responseType = 'arraybuffer'\n        this.request.onload = this.handleData.bind(this)\n        this.request.onerror = this.handleData.bind(this)\n        this.request.send(null)\n      }.bind(this)\n    )\n  }\n\n  handleData() {\n    var self = this\n    if (!this.request) {\n      return\n    }\n    if (this.error) {\n      return true\n    }\n\n    if (this.request.readyState == 4) {\n      /* HTTP reports success with a 200 status. The file protocol\n       reports success with zero. HTTP returns zero as a status\n       code for forbidden cross domain requests.\n       https://developer.mozilla.org/En/Using_XMLHttpRequest */\n      var success = this.request.status == 200 || (this.isFileUri && this.request.status == 0)\n      if (!success) {\n        this.resolve(null)\n        return\n      }\n    }\n\n    if (!this.request.response) {\n      return\n    }\n    var length = this.request.response.byteLength\n    var response = this.request.response\n    var dataView = new DataView(response)\n\n    if (length < 4 + 4) {\n      return\n    }\n    if (self.headerLen == null) {\n      var cookie = Pack.arrayBufferToString(response.slice(0, 4))\n      if (cookie != this.MAGIC_COOKIE) {\n        this.reject(\n          'Could not load ' +\n            this.url +\n            ' due to incorrect file format. Cookie: [' +\n            this.cookie +\n            ']'\n        )\n        return\n      }\n\n      self.headerLen = dataView.getInt32(4, true)\n\n      self.offset = 4 + 4\n    }\n    if (length < self.offset + self.headerLen) {\n      return\n    }\n    if (!self.headerIsLoaded) {\n      self.header = JSON.parse(\n        Pack.arrayBufferToString(response.slice(self.offset, self.offset + self.headerLen))\n      )\n      self.rowLen = 0\n      self.header.colsByName = {}\n      for (var colidx = 0; colidx < self.header.cols.length; colidx++) {\n        var col = self.header.cols[colidx]\n        col.idx = colidx\n        self.header.colsByName[col.name] = col\n        col.typespec = Pack.typemap.byname[col.type]\n\n        if (col.multiplier != undefined && col.min != undefined) {\n          col.min = col.min * col.multiplier\n        }\n        if (col.offset != undefined && col.min != undefined) {\n          col.min = col.min + col.offset\n        }\n        if (col.multiplier != undefined && col.max != undefined) {\n          col.max = col.max * col.multiplier\n        }\n        if (col.offset != undefined && col.max != undefined) {\n          col.max = col.max + col.offset\n        }\n\n        self.rowLen += col.typespec.size\n      }\n      self.offset += self.headerLen\n\n      // Add the padding to nearest 4-byte-boundary\n      self.offset += (4 - (self.headerLen % 4)) % 4\n\n      self.headerIsLoaded = true\n      if (self.header.orientation != 'rowwise' && self.header.orientation != 'columnwise') {\n        self.errorLoading({\n          orientation: self.header.orientation,\n          toString: function() {\n            return (\n              'Could not load ' +\n              this.url +\n              ' due to unsupported file orientation. Orientation: ' +\n              this.orientation +\n              '. Supported orientations: rowwise, columnwise.'\n            )\n          },\n        })\n        return true\n      }\n\n      // Empty tile, stop parsing.\n      if (!self.rowLen) {\n        self.allLoaded()\n        return true\n      }\n    }\n    if (self.header.orientation == 'rowwise') {\n      var result = {}\n      for (; self.offset + self.rowLen <= length; self.rowidx++) {\n        var row = {}\n        for (var colidx = 0; colidx < self.header.cols.length; colidx++) {\n          var col = self.header.cols[colidx]\n          var val = dataView[col.typespec.getter](self.offset, true)\n          row[col.name] = val\n          self.offset += col.typespec.size\n        }\n        // self.rowLoaded(row);\n\n        result[col.name] = row\n      }\n      if (self.rowidx == self.header.length) {\n        // self.allLoaded();\n        this.resolve(result)\n      } else {\n        // self.batchLoaded();\n      }\n    } else if (self.header.orientation == 'columnwise') {\n      var colValues = null\n      var result = {}\n      if (length >= self.offset + self.header.length * self.rowLen) {\n        for (var colidx = 0; colidx < self.header.cols.length; colidx++) {\n          var col = self.header.cols[colidx]\n\n          colValues = new (eval(col.typespec.array))(\n            response.slice(self.offset, self.offset + col.typespec.size * self.header.length)\n          )\n          self.offset += self.header.length * col.typespec.size\n\n          result[col.name] = colValues\n        }\n\n        // self.allLoaded();\n        this.resolve(result)\n        return true\n      }\n    }\n  }\n}\n\nexport default PelagosClient\n","import PropTypes from 'prop-types'\n\nexport const trackTypes = {\n  id: PropTypes.string.isRequired,\n  url: PropTypes.string,\n  data: PropTypes.object,\n  color: PropTypes.string,\n  type: PropTypes.oneOf(['geojson', undefined]),\n  layerTemporalExtents: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.number)),\n  fitBoundsOnLoad: PropTypes.bool,\n}\n","import PropTypes from 'prop-types'\n\nexport const heatmapLayerTypes = {\n  id: PropTypes.string.isRequired,\n  tilesetId: PropTypes.string,\n  subtype: PropTypes.string,\n  visible: PropTypes.bool,\n  hue: PropTypes.number,\n  opacity: PropTypes.number,\n  filters: PropTypes.arrayOf(\n    PropTypes.shape({\n      // hue overrides layer hue if set\n      hue: PropTypes.number,\n      // filterValues is a dictionary in which each key is a filterable field,\n      // and values is an array of all possible values (OR filter)\n      // ie: filterValues: { category: [5, 6] }\n      filterValues: PropTypes.object,\n    })\n  ),\n  header: PropTypes.shape({\n    endpoints: PropTypes.object,\n    isPBF: PropTypes.bool,\n    colsByName: PropTypes.object,\n    temporalExtents: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.number)),\n    temporalExtentsLess: PropTypes.bool,\n  }).isRequired,\n  interactive: PropTypes.bool,\n}\n\nexport const basemapLayerTypes = {\n  id: PropTypes.string,\n  visible: PropTypes.bool,\n}\n\nexport const staticLayerTypes = {\n  id: PropTypes.string.isRequired,\n  // TODO MAP MODULE Is that needed and if so why\n  visible: PropTypes.bool,\n  selected: PropTypes.bool,\n  selectedFeatures: PropTypes.shape({\n    field: PropTypes.string,\n    values: PropTypes.arrayOf(PropTypes.string),\n  }),\n  highlighted: PropTypes.bool,\n  higlightedFeatures: PropTypes.shape({\n    field: PropTypes.string,\n    values: PropTypes.arrayOf(PropTypes.string),\n  }),\n  opacity: PropTypes.number,\n  color: PropTypes.string,\n  showLabels: PropTypes.bool,\n  interactive: PropTypes.bool,\n  filters: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.string)),\n  isCustom: PropTypes.bool,\n  subtype: PropTypes.oneOf([undefined, 'geojson', 'raster']),\n  url: PropTypes.string,\n  data: PropTypes.object,\n  gl: PropTypes.object,\n}\n","import PropTypes from 'prop-types'\n\nexport const popupTypes = {\n  content: PropTypes.node,\n  latitude: PropTypes.number.isRequired,\n  longitude: PropTypes.number.isRequired,\n}\n\nexport const viewportTypes = {\n  zoom: PropTypes.number,\n  center: PropTypes.arrayOf(PropTypes.number),\n}\n","// Application settings\nexport const TIMELINE_STEP = 24 * 60 * 60 * 1000 // 1 day\nexport const MIN_FRAME_LENGTH_MS = TIMELINE_STEP // 1 day\n\n// vessels rendering\n// from this zoom level and above, render using circle style instead of heatmap\nexport const VESSELS_RADIAL_GRADIENT_STYLE_ZOOM_THRESHOLD = 6\n// the base radius, it can only be scaled down by the radius factor calculated on the dataset\nexport const VESSELS_BASE_RADIUS = 8\n// in heatmap style, defines how 'blurry' a point will look. Higher = less blur\nexport const VESSELS_HEATMAP_BLUR_FACTOR = 0.15\n\nexport const ACTIVITY_HIGHLIGHT_HUE = 312\n\nexport const VESSELS_HEATMAP_DIMMING_ALPHA = 0.5\n\nexport const TRACKS_DOTS_STYLE_ZOOM_THRESHOLD = 2\n\nexport const MAX_SPRITES_PER_LAYER = 200000\n\n// interaction\n// radius of vessels lookup in pixels,\n// ie how large the clicked region should be for including vessels\nexport const VESSEL_CLICK_TOLERANCE_PX = 10\n\nexport const CLUSTER_CLICK_ZOOM_INCREMENT = 1\n\nexport const MIN_ZOOM_LEVEL = 1\n// user can zoom up to this z level, but it doesn't guarantee availability of tiles\nexport const MAX_ZOOM_LEVEL = 14\n\n// data\n// Limit tile loading for activity layers up to this z level.\n// Beyond, layer is still displayed but with coarse data from the lower zoom level\nexport const ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING = 10\n\n// Sets what should be the discrete zoom level to load tiles, from a non-discrete\n// viewport zoom values. For instance, a values of 0.5 will load z 3 with a viewport\n// z of 2 (ceiling of 2 + 0.5)\n// this has a direct impact on the number of points displayed on the map, thus on the\n// performance of the app.\nexport const TILES_LOAD_ZOOM_OFFSET = 0.5\n\nexport const STATIC_LAYERS_CARTO_ENDPOINT =\n  'https://carto.globalfishingwatch.org/user/admin/api/v1/map?config=$MAPCONFIG'\nexport const STATIC_LAYERS_CARTO_TILES_ENDPOINT =\n  'https://carto.globalfishingwatch.org/user/admin/api/v1/map/$LAYERGROUPID/{z}/{x}/{y}.mvt'\n\nexport const TRACKS_LAYER_IN_FRONT_OF_GROUP = 'static'\n\nexport const TILES_URL_NEEDING_AUTHENTICATION = 'dot-world-fishing'\n","export const INIT_MODULE = 'INIT_MODULE'\nexport const SET_TEMPORAL_EXTENT = 'SET_TEMPORAL_EXTENT'\nexport const SET_HIGHLIGHT_TEMPORAL_EXTENT = 'SET_HIGHLIGHT_TEMPORAL_EXTENT'\nexport const START_LOADER = 'START_LOADER'\nexport const COMPLETE_LOADER = 'COMPLETE_LOADER'\n\nexport const initModule = (props) => (dispatch) => {\n  dispatch({\n    type: INIT_MODULE,\n    payload: props,\n  })\n}\n\nexport const startLoader = (dispatch, state) => {\n  const loaderId = new Date().getTime()\n  dispatch({\n    type: START_LOADER,\n    payload: loaderId,\n  })\n  if (state.map.module.onLoadStart !== undefined) {\n    state.map.module.onLoadStart()\n  }\n  return loaderId\n}\n\nexport const completeLoader = (loaderId) => (dispatch, getState) => {\n  const state = getState()\n  const loaders = Object.assign({}, state.map.module.loaders)\n  dispatch({\n    type: COMPLETE_LOADER,\n    payload: loaderId,\n  })\n  if (!loaders.length && state.map.module.onLoadComplete !== undefined) {\n    state.map.module.onLoadComplete()\n  }\n}\n\nexport const onViewportChange = () => (dispatch, getState) => {\n  const state = getState()\n  const callback = state.map.module.onViewportChange\n\n  if (callback === undefined) {\n    return\n  }\n  const viewport = state.map.viewport\n\n  if (viewport.bounds === undefined) {\n    return\n  }\n\n  callback({\n    zoom: viewport.viewport.zoom,\n    center: [viewport.viewport.latitude, viewport.viewport.longitude],\n    bounds: viewport.bounds,\n    canZoomIn: viewport.canZoomIn,\n    canZoomOut: viewport.canZoomOut,\n    mouseLatLong: viewport.mouseLatLong,\n  })\n}\n\nexport const setTemporalExtent = (temporalExtent) => ({\n  type: SET_TEMPORAL_EXTENT,\n  payload: temporalExtent,\n})\n\nexport const setHighlightTemporalExtent = (highlightTemporalExtent) => ({\n  type: SET_HIGHLIGHT_TEMPORAL_EXTENT,\n  payload: highlightTemporalExtent,\n})\n\nexport const closePopup = () => (dispatch, getState) => {\n  const state = getState()\n  if (state.map.module.onClosePopup !== undefined) {\n    state.map.module.onClosePopup()\n  }\n}\n","export const getTemporalExtent = (state) => state.map.module.temporalExtent\n\nexport const getHighlightTemporalExtent = (state) => state.map.module.highlightTemporalExtent\n","import { createSelector } from 'reselect'\nimport { getTemporalExtent, getHighlightTemporalExtent } from '../module/module.selectors'\n\nexport const getTracksData = (state) => state.map.tracks.data\nexport const getGeojsonTracks = createSelector(\n  getTracksData,\n  (tracks) => tracks.filter((t) => t.type === 'geojson')\n)\nexport const getGeojsonTracksReady = createSelector(\n  getGeojsonTracks,\n  (tracks) => tracks.filter((t) => t.data !== undefined)\n)\n\nconst mergeStyles = (style1, style2) => ({\n  sources: { ...style1.sources, ...style2.sources },\n  layers: [...style1.layers, ...style2.layers],\n})\n\nconst filterGeojsonByTimerange = (geojson, { start, end }) => {\n  if (!geojson || !geojson.features) return null\n  const featuresFiltered = geojson.features.reduce((filteredFeatures, feature) => {\n    const hasTimes =\n      feature.properties.coordinateProperties.times &&\n      feature.properties.coordinateProperties.times.length > 0\n    if (hasTimes) {\n      const filtered = feature.geometry.coordinates.reduce(\n        (filteredCoordinates, coordinate, index) => {\n          const timeCoordinate = feature.properties.coordinateProperties.times[index]\n          const isInTimeline = timeCoordinate >= start && timeCoordinate <= end\n          if (isInTimeline) {\n            filteredCoordinates.coordinates.push(coordinate)\n            filteredCoordinates.times.push(timeCoordinate)\n          }\n          return filteredCoordinates\n        },\n        { coordinates: [], times: [] }\n      )\n      if (!filtered.coordinates.length) return filteredFeatures\n\n      const filteredFeature = {\n        ...feature,\n        geometry: {\n          ...feature.geometry,\n          coordinates: filtered.coordinates,\n        },\n        properties: {\n          ...feature.properties,\n          coordinateProperties: {\n            times: filtered.times,\n          },\n        },\n      }\n      filteredFeatures.push(filteredFeature)\n    }\n    return filteredFeatures\n  }, [])\n  const geojsonFiltered = {\n    ...geojson,\n    features: featuresFiltered,\n  }\n  return geojsonFiltered\n}\n\nconst getFullTracksStyles = createSelector(\n  [getTemporalExtent, getGeojsonTracksReady],\n  (temporalExtent, tracks) => {\n    const hasTemporalExtent = temporalExtent && temporalExtent.length > 0\n    const hasTracks = tracks && tracks.length > 0\n    if (!hasTemporalExtent || !hasTracks) return null\n\n    const timerange = {\n      start: temporalExtent[0].getTime(),\n      end: temporalExtent[1].getTime(),\n    }\n    const styles = tracks.reduce(\n      (acc, track) => {\n        if (!track.data) return acc\n\n        const source = `${track.id}Track`\n        const style = {\n          sources: {\n            [source]: {\n              type: 'geojson',\n              data: filterGeojsonByTimerange(track.data, timerange),\n            },\n          },\n          layers: [\n            {\n              id: `${track.id}Lines`,\n              source,\n              type: 'line',\n              paint: {\n                'line-width': 1,\n                'line-color': track.color,\n              },\n            },\n            {\n              id: `${track.id}Points`,\n              source,\n              type: 'circle',\n              filter: ['match', ['geometry-type'], ['', 'Point'], true, false],\n              paint: {\n                'circle-radius': 4,\n                'circle-color': track.color,\n              },\n            },\n          ],\n        }\n        return mergeStyles(acc, style)\n      },\n      { sources: {}, layers: [] }\n    )\n    return styles\n  }\n)\n\nconst getHighlightedTrackStyles = createSelector(\n  [getHighlightTemporalExtent, getGeojsonTracksReady],\n  (highlightTemporalExtent, tracks) => {\n    const hasTemporalExtent = highlightTemporalExtent && highlightTemporalExtent.length > 0\n    const hasTracks = tracks && tracks.length > 0\n    if (!hasTemporalExtent || !hasTracks) return null\n\n    const timerange = {\n      start: highlightTemporalExtent[0].getTime(),\n      end: highlightTemporalExtent[1].getTime(),\n    }\n    const styles = tracks.reduce(\n      (acc, track) => {\n        if (!track.data) return acc\n\n        const source = `${track.id}HighlightedTrack`\n        const style = {\n          sources: {\n            [source]: {\n              type: 'geojson',\n              data: filterGeojsonByTimerange(track.data, timerange),\n            },\n          },\n          layers: [\n            {\n              id: `${track.id}HighlightedLines`,\n              source,\n              type: 'line',\n              paint: {\n                'line-width': 1,\n                'line-color': '#fff',\n              },\n            },\n          ],\n        }\n        return mergeStyles(acc, style)\n      },\n      { sources: {}, layers: [] }\n    )\n    return styles\n  }\n)\n\nexport const getTracksStyles = createSelector(\n  [getFullTracksStyles, getHighlightedTrackStyles],\n  (trackStyles, highlightedTrackStyles) => {\n    if (!highlightedTrackStyles) return trackStyles\n    return mergeStyles(trackStyles, highlightedTrackStyles)\n  }\n)\n","export const GL_TRANSPARENT = 'rgba(0,0,0,0)'\n\nexport const TRANSITION_TYPE = {\n  ZOOM: 'ZOOM',\n}\n\nexport const ENCOUNTERS = 'Encounters'\n\nexport const BRUSH_RENDERING_STYLE = {\n  NORMAL: 0,\n  BULLSEYE: 2,\n}\n\nexport const BRUSH_ZOOM_RENDERING_STYLE = {\n  RADIAL_GRADIENT: 0,\n  CIRCLE: 1,\n}\n\nexport const POLYGON_LAYERS_AREA = 'POLYGON_LAYERS_AREA'\n\nexport const CUSTOM_LAYERS_SUBTYPES = {\n  geojson: 'geojson',\n  raster: 'raster',\n}\n","import Pbf from 'pbf'\nimport { VectorTile } from '@mapbox/vector-tile'\n\nexport default (tileUrl, token) => {\n  const vectorTilePromise = fetch(tileUrl, {\n    headers: token\n      ? {\n          Authorization: `Bearer ${token}`,\n        }\n      : {},\n  })\n    .then((response) => {\n      if (!response.ok) {\n        throw new Error(`could not load tile ${tileUrl}`)\n      }\n      return response.blob().then((blob) => {\n        const reader = new FileReader()\n        return new Promise((resolve) => {\n          reader.addEventListener('loadend', () => {\n            // reader.result contains the contents of blob as a typed array\n            // blob.type === 'application/x-protobuf'\n            const pbf = new Pbf(reader.result)\n            const vectorTile = new VectorTile(pbf)\n            return resolve(vectorTile)\n          })\n          reader.readAsArrayBuffer(blob)\n        })\n      })\n    })\n    .catch((e) => {\n      console.warn(e)\n    })\n  return vectorTilePromise\n}\n","import pull from 'lodash/pull'\nimport uniq from 'lodash/uniq'\nimport sumBy from 'lodash/sumBy'\nimport { lngLatToWorld } from 'viewport-mercator-project'\nimport convert from '@globalfishingwatch/map-convert'\nimport buildEndpoint from './buildEndpoint'\nimport PelagosClient from '../lib/pelagosClient'\n\nimport getPBFTile from './getPBFTile'\n\n/**\n * Generates the URLs to load vessel track data for a tile\n *\n * @param {string} tilesetUrl       the tileset base URL\n * @param {array} temporalExtents   all tileset temporal extents\n * @param {object} params           - seriesgroup: a seriesgroup id, used for tracks loading\n *                                  - tileCoordinates: this tiles tile coordinates (zoom, x, y). Will default to 0,0,0\n *                                  - temporalExtentsIndices: restrict to these temporalExtents indices\n * @returns {Array}                 an array of URLs for this tile\n */\nconst getTemporalTileURLs = (urlTemplate, temporalExtents, params) => {\n  const urls = []\n\n  ;(temporalExtents || [null]).forEach((extent, index) => {\n    const urlParams = {\n      id: params.seriesgroup,\n    }\n    if (extent !== null && params.temporalExtentsLess !== true) {\n      urlParams.startTimeISO = new Date(extent[0]).toISOString()\n      urlParams.endTimeISO = new Date(extent[1]).toISOString()\n    }\n    if (params.tileCoordinates) {\n      urlParams.x = params.tileCoordinates.x\n      urlParams.y = params.tileCoordinates.y\n      urlParams.z = params.tileCoordinates.zoom\n    }\n\n    const url = buildEndpoint(urlTemplate, urlParams)\n\n    if (\n      params.temporalExtentsLess === true ||\n      !params.temporalExtentsIndices ||\n      params.temporalExtentsIndices.indexOf(index) > -1\n    ) {\n      urls.push(url)\n    }\n  })\n  return urls\n}\n\n/**\n * See getTemporalTileURLs.\n */\nexport const getTilePromises = (tilesetUrl, token, temporalExtents, params) => {\n  const promises = []\n  const urls = getTemporalTileURLs(tilesetUrl, temporalExtents, params)\n  for (let urlIndex = 0, length = urls.length; urlIndex < length; urlIndex++) {\n    if (params.isPBF === true) {\n      promises.push(getPBFTile(urls[urlIndex], token))\n    } else {\n      promises.push(new PelagosClient().obtainTile(urls[urlIndex], token))\n    }\n  }\n\n  return promises\n}\n\nexport const getCleanVectorArrays = (rawTileData) =>\n  rawTileData.filter((vectorArray) => vectorArray !== null)\n\n/**\n * As data will come in multiple arrays (1 per API query/year basically), they need to be merged here\n *\n * @param cleanVectorArrays an array of objects containing a Float32Array for each vessel param (lat, lon, weight...)\n * @param columns the keys to pick on the vectorArrays (lat, lon, weight, etc)\n * @returns an object containing a Float32Array for each API_RETURNED_KEY (lat, lon, weight, etc)\n */\nexport const groupData = (cleanVectorArrays, columns) => {\n  const data = {}\n\n  const totalVectorArraysLength = sumBy(cleanVectorArrays, (a) => a.longitude.length)\n\n  const filteredColumns = columns.filter((column) => {\n    if (cleanVectorArrays[0] && cleanVectorArrays[0][column] === undefined) {\n      console.warn(`column ${column} is present in layerHeader.colsByName but not in tile data`)\n      return false\n    }\n    return true\n  })\n\n  filteredColumns.forEach((key) => {\n    data[key] = new Float32Array(totalVectorArraysLength)\n  })\n\n  let currentArray\n  let cumulatedOffsets = 0\n\n  const appendValues = (key) => {\n    data[key].set(currentArray[key], cumulatedOffsets)\n  }\n\n  for (let index = 0, length = cleanVectorArrays.length; index < length; index++) {\n    currentArray = cleanVectorArrays[index]\n    filteredColumns.forEach(appendValues)\n    cumulatedOffsets += currentArray.longitude.length\n  }\n  return data\n}\n\n/**\n * Converts Vector Array data to Playback format and stores it locally.\n * The data structure is an array indexed by a time unit, ie a set of points every day\n * This preprocessing step allows playback to play smoothly as the necessary conversions and data structure set up\n * is done once (after tile has been loaded)\n *\n * @param data the source data before indexing by day, an object containing\n *  - a vector (Float32Array) for each header's column in the case of Pelagos tiles\n *  - an array of points int the case of PBF tiles\n * @param colsByName the columns present on the dataset, determined by tileset headers\n * @param tileCoordinates x, y, z\n * @param isPBF bool whether data is a PBF vector tile (true) or a Pelagos tile (false)\n * @param prevPlaybackData an optional previously loaded tilePlaybackData array (when adding time range)\n */\nexport const getTilePlaybackData = (data, colsByName, tileCoordinates, isPBF, prevPlaybackData) => {\n  const tilePlaybackData = prevPlaybackData === undefined ? [] : prevPlaybackData\n\n  const zoom = tileCoordinates.zoom\n  const zoomFactorRadius = convert.getZoomFactorRadius(zoom)\n  const zoomFactorRadiusRenderingMode = convert.getZoomFactorRadiusRenderingMode(zoom)\n  const zoomFactorOpacity = convert.getZoomFactorOpacity(zoom)\n\n  // store all available columns as object keys\n  const columns = {}\n  const columnsArr = Object.keys(colsByName)\n  columnsArr.forEach((c) => {\n    columns[c] = true\n  })\n\n  // columns specified by layer header columns\n  let storedColumns = [].concat(columnsArr)\n  if (columns.sigma === true) storedColumns.push('radius')\n  if (columns.weight === true) storedColumns.push('opacity')\n  if (columns.longitude === true) {\n    storedColumns.push('worldX')\n    storedColumns.push('worldY')\n  }\n  if (columns.id === true) {\n    storedColumns.push('series')\n  }\n\n  // omit values that will be transformed before being stored to playback data (ie lat -> worldY)\n  // only if hidden: true flag is set on header\n  ;['latitude', 'longitude', 'datetime'].forEach((col) => {\n    if (colsByName[col] === undefined || colsByName[col].hidden === true) {\n      pull(storedColumns, col)\n    }\n  })\n  // always pull sigma and weight\n  pull(storedColumns, 'sigma', 'weight')\n  storedColumns = uniq(storedColumns)\n\n  const numPoints = isPBF === true ? data.length : data.latitude.length\n\n  for (let index = 0, length = numPoints; index < length; index++) {\n    let point\n    if (isPBF === true) {\n      const feature = data.feature(index)\n      point = feature.properties\n      // WARNING: toGeoJSON is expensive. Avoid using raw coordinates in PBF tiles, pregenerate world coords\n      // FIXME: this should not be done when headers declare worldX/Y -  if (!columns.worldX) {\n      const geom = feature.toGeoJSON(tileCoordinates.x, tileCoordinates.y, zoom).geometry\n        .coordinates\n      point.longitude = geom[0]\n      point.latitude = geom[1]\n    } else {\n      point = {}\n      columnsArr.forEach((c) => {\n        point[c] = data[c][index]\n      })\n    }\n\n    const timeIndex = columns.timeIndex\n      ? point.timeIndex\n      : convert.getOffsetedTimeAtPrecision(point.datetime)\n\n    // FIXME: this should not be done when headers declare worldX/Y -  if (!columns.worldX) {\n    const [worldX, worldY] = lngLatToWorld([point.longitude, point.latitude], 1)\n    point.worldX = worldX\n    point.worldY = worldY\n\n    if (columns.sigma) {\n      point.radius = convert.sigmaToRadius(\n        point.sigma,\n        zoomFactorRadiusRenderingMode,\n        zoomFactorRadius\n      )\n    }\n    if (columns.weight) {\n      point.opacity = convert.weightToOpacity(point.weight, zoomFactorOpacity)\n    }\n    if (columns.id) {\n      point.series = point.id\n    }\n\n    if (!tilePlaybackData[timeIndex]) {\n      const frame = {}\n      storedColumns.forEach((column) => {\n        frame[column] = [point[column]]\n      })\n      tilePlaybackData[timeIndex] = frame\n      continue\n    }\n    const frame = tilePlaybackData[timeIndex]\n    storedColumns.forEach((column) => {\n      frame[column].push(point[column])\n    })\n  }\n  return tilePlaybackData\n}\n\nexport const addTracksPointsRenderingData = (data) => {\n  data.hasFishing = []\n  data.worldX = []\n  data.worldY = []\n\n  for (let index = 0, length = data.weight.length; index < length; index++) {\n    const [worldX, worldY] = lngLatToWorld([data.longitude[index], data.latitude[index]], 1)\n    data.worldX[index] = worldX\n    data.worldY[index] = worldY\n    data.hasFishing[index] = data.weight[index] > 0\n  }\n  return data\n}\n\n/**\n * A simplified version of getTilePlaybackData for tracks\n * Converts Vector Array data to Playback format (organized by days) and stores it locally\n * @param vectorArray the source data before indexing by day\n */\nexport const getTracksPlaybackData = (vectorArray) => {\n  const playbackData = []\n\n  for (let index = 0, length = vectorArray.series.length; index < length; index++) {\n    const datetime = vectorArray.datetime[index]\n    const timeIndex = convert.getOffsetedTimeAtPrecision(datetime)\n\n    if (!playbackData[timeIndex]) {\n      const frame = {\n        worldX: [vectorArray.worldX[index]],\n        worldY: [vectorArray.worldY[index]],\n        series: [vectorArray.series[index]],\n        hasFishing: [vectorArray.hasFishing[index]],\n      }\n      playbackData[timeIndex] = frame\n      continue\n    }\n    const frame = playbackData[timeIndex]\n    frame.worldX.push(vectorArray.worldX[index])\n    frame.worldY.push(vectorArray.worldY[index])\n    frame.series.push(vectorArray.series[index])\n    frame.hasFishing.push(vectorArray.hasFishing[index])\n  }\n  return playbackData\n}\n\nexport const vesselSatisfiesFilters = (frame, index, filterValues) => {\n  const satisfiesFilters = Object.keys(filterValues).every((field) => {\n    if (frame[field] === undefined) {\n      // this field is not available on this layer. This can happen in an edge case described\n      // here: https://github.com/GlobalFishingWatch/map-client/issues/661#issuecomment-334496469\n      return false\n    }\n    return filterValues[field].indexOf(frame[field][index]) > -1\n  })\n  return satisfiesFilters\n}\n\nconst vesselSatisfiesAllFilters = (frame, index, filters) => {\n  const satisfiesAllFilters = filters\n    .filter((f) => f.pass !== true)\n    .some((filter) => vesselSatisfiesFilters(frame, index, filter.filterValues))\n  return satisfiesAllFilters\n}\n\nexport const selectVesselsAt = (tileData, tileQuery, startIndex, endIndex, currentFilters) => {\n  const vessels = []\n\n  const { worldX, worldY, toleranceRadiusInWorldUnits } = tileQuery\n\n  for (let f = startIndex; f < endIndex; f++) {\n    const frame = tileData[f]\n    if (frame === undefined) continue\n    for (let i = 0; i < frame.worldX.length; i++) {\n      const wx = frame.worldX[i]\n      const wy = frame.worldY[i]\n\n      if (\n        (!currentFilters.length || vesselSatisfiesAllFilters(frame, i, currentFilters)) &&\n        wx >= worldX - toleranceRadiusInWorldUnits &&\n        wx <= worldX + toleranceRadiusInWorldUnits &&\n        wy >= worldY - toleranceRadiusInWorldUnits &&\n        wy <= worldY + toleranceRadiusInWorldUnits\n      ) {\n        const vessel = {}\n\n        Object.keys(frame).forEach((key) => {\n          vessel[key] = frame[key][i]\n        })\n        vessels.push(vessel)\n      }\n    }\n  }\n  return vessels\n}\n\n/*\nexport const getHistogram = (tiles, propName = 'weight') => {\n  let data = tiles\n    .filter(tile => tile.ready)\n    .map(tile => tile.data\n      .map(frame => frame[propName]));\n  data = flattenDeep(data);\n  if (data.length) {\n    const bins = d3.histogram().thresholds(d3.thresholdScott)(data);\n    const x = d3.scaleLinear().domain([0, d3.max(bins, d => d.length)]).range([0, 50]);\n    console.table(bins.filter(bin => bin.length).map((bin) => {\n      const binMin = d3.min(bin).toLocaleString({ maximumFractionDigits: 2 });\n      const binMax = d3.max(bin).toLocaleString({ maximumFractionDigits: 2 });\n      return {\n        range: [binMin, binMax].join(''),\n        bars: Array(Math.round(x(bin.length))).join(''),\n        num: bin.length\n      };\n    }));\n  }\n};\n*/\n","import template from 'lodash/template'\nimport templateSettings from 'lodash/templateSettings'\n\nexport default (urlTemplate, urlParams) => {\n  templateSettings.interpolate = /{{([\\s\\S]+?)}}/g\n  const urlTemplateCompiled = template(urlTemplate)\n  return urlTemplateCompiled(urlParams)\n}\n","import tilecover from '@mapbox/tile-cover/index'\nimport debounce from 'lodash/debounce'\nimport { PerspectiveMercatorViewport } from 'viewport-mercator-project'\nimport { ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING, TILES_LOAD_ZOOM_OFFSET } from '../config'\nimport {\n  getTile,\n  releaseTiles,\n  highlightVesselFromHeatmap,\n  updateLoadedTiles,\n} from './heatmap.actions'\n\nexport const SET_CURRENTLY_VISIBLE_TILES = 'SET_CURRENTLY_VISIBLE_TILES'\nexport const SET_CURRENTLY_LOADED_TILES = 'SET_CURRENTLY_LOADED_TILES'\nexport const SET_CURRENTLY_SWAPPED_TILE_UIDS = 'SET_CURRENTLY_SWAPPED_TILE_UIDS'\nexport const MARK_TILES_UIDS_AS_LOADED = 'MARK_TILES_UIDS_AS_LOADED'\nexport const RELEASE_MARKED_TILES_UIDS = 'RELEASE_MARKED_TILES_UIDS'\n\n// restrict tilecover to a single zoom level\n// could be customized to load less or more detailed tiles\nconst getTilecoverLimits = (viewportZoom) => {\n  let zoom = Math.ceil(viewportZoom + TILES_LOAD_ZOOM_OFFSET)\n  let tilesAvailable = true\n  if (zoom > ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING) {\n    zoom = ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING\n    tilesAvailable = false\n  }\n  return {\n    min_zoom: zoom,\n    max_zoom: zoom,\n    tilesAvailable,\n  }\n}\n\nconst flushToReleaseTiles = () => (dispatch, getState) => {\n  const state = getState()\n  const currentToLoadTileUids = state.map.heatmapTiles.currentToLoadTileUids\n  // console.log('Tiles left to load: ', currentToLoadTileUids);\n\n  // Tiles are released only when all to-load tiles have finished loading\n  // this is to ensure smooth visual transitions between zoom levels\n  if (!currentToLoadTileUids.length) {\n    const currentTilesToReleaseUids = state.map.heatmapTiles.currentToReleaseTileUids\n    // console.log('no more tiles to load, releasing ', currentTilesToReleaseUids);\n    dispatch(releaseTiles(currentTilesToReleaseUids))\n    dispatch({\n      type: RELEASE_MARKED_TILES_UIDS,\n    })\n  }\n}\n\nexport const markTileAsLoaded = (tileUids) => (dispatch) => {\n  dispatch({\n    type: MARK_TILES_UIDS_AS_LOADED,\n    payload: tileUids,\n  })\n  // console.log(tileUids, 'have finished loading');\n  dispatch(flushToReleaseTiles())\n}\n\nconst flushTileState = (forceLoadingAllVisibleTiles = false) => (dispatch, getState) => {\n  const state = getState()\n  const currentVisibleTiles = state.map.heatmapTiles.currentVisibleTiles\n  let tilesToLoad = []\n  const tilesToReleaseUids = []\n\n  if (forceLoadingAllVisibleTiles === true) {\n    tilesToLoad = currentVisibleTiles\n  } else {\n    const currentLoadedTiles = state.map.heatmapTiles.currentLoadedTiles\n\n    currentVisibleTiles.forEach((visibleTile) => {\n      if (currentLoadedTiles.find((t) => t.uid === visibleTile.uid) === undefined) {\n        tilesToLoad.push(visibleTile)\n      }\n    })\n\n    currentLoadedTiles.forEach((loadedTile) => {\n      if (currentVisibleTiles.find((t) => t.uid === loadedTile.uid) === undefined) {\n        tilesToReleaseUids.push(loadedTile.uid)\n      }\n    })\n  }\n\n  const tilesToLoadUids = tilesToLoad.map((t) => t.uid)\n  // console.log('force loading:', forceLoadingAllVisibleTiles)\n  // console.log('visible', currentVisibleTiles.map(t => t.uid))\n  // console.log('load', tilesToLoadUids)\n  // console.log('release', tilesToReleaseUids)\n  // console.log('----')\n\n  tilesToLoad.forEach((tile) => {\n    dispatch(getTile(tile))\n  })\n  dispatch({\n    type: SET_CURRENTLY_LOADED_TILES,\n    payload: currentVisibleTiles,\n  })\n\n  dispatch({\n    type: SET_CURRENTLY_SWAPPED_TILE_UIDS,\n    payload: {\n      tilesToLoadUids,\n      tilesToReleaseUids,\n    },\n  })\n\n  dispatch(updateLoadedTiles())\n  dispatch(flushToReleaseTiles())\n}\n\nconst _debouncedFlushState = (dispatch) => {\n  dispatch(flushTileState())\n}\nconst debouncedFlushState = debounce(_debouncedFlushState, 500)\n\nexport const updateHeatmapTilesFromViewport = (forceLoadingAllVisibleTiles = false) => (\n  dispatch,\n  getState\n) => {\n  // if in transition, skip loading/releasing\n  // else\n  //   collect all tiles in viewport\n  //   save them to reducer: currentVisibleTiles\n  // if not zooming: flush immediately\n  //   if forceLoadingAllVisiblelTiles\n  //     get tiles from currentVisibleTiles\n  //   else\n  //     get tiles from currentVisibleTiles\n  //     make delta with currentLoadedTiles\n  //     get tiles from delta+\n  //     release tiles from delta-\n  //   save to reducer: currentVisibleTiles -> currentLoadedTiles\n  // if zooming: debounced flush to avoid \"tile spam\"\n  const mapViewport = getState().map.viewport\n  const viewport = mapViewport.viewport\n\n  // do not allow any tile update during transitions (currently only zoom)\n  // wait for the end of the transition to look at viewport and load matching tiles\n  if (mapViewport.currentTransition !== null) {\n    return\n  }\n\n  // instanciate a viewport instance to get lat/lon from screen top left/ bottom right bounds\n  const boundsViewport = new PerspectiveMercatorViewport(viewport)\n  const bounds = [\n    boundsViewport.unproject([0, 0]),\n    boundsViewport.unproject([viewport.width, viewport.height]),\n  ]\n\n  const [wn, es] = bounds\n  const [w, s, e, n] = [wn[0], es[1], es[0], wn[1]]\n  const boundsPolygonsCoordinates = []\n\n  const limits = getTilecoverLimits(viewport.zoom)\n  if (limits.tilesAvailable === false && forceLoadingAllVisibleTiles !== true) {\n    return\n  }\n\n  if (e > 180 || w < -180) {\n    // deal with the antimeridian situation by splitting the bounds polygon into two polygons\n    const w1 = e > 180 ? w : w + 360\n    const e1 = 180 - 0.001\n    const w2 = -180\n    const e2 = e > 180 ? e - 360 : e\n    boundsPolygonsCoordinates.push([[[w1, n], [e1, n], [e1, s], [w1, s], [w1, n]]])\n    boundsPolygonsCoordinates.push([[[w2, n], [e2, n], [e2, s], [w2, s], [w2, n]]])\n  } else {\n    boundsPolygonsCoordinates.push([[[w, n], [e, n], [e, s], [w, s], [w, n]]])\n  }\n\n  const geom = {\n    type: 'MultiPolygon',\n    coordinates: boundsPolygonsCoordinates,\n  }\n\n  // using tilecover, get xyz tile coords as well as quadkey indexes (named uid through the app)\n  const viewportTilesCoords = tilecover.tiles(geom, limits)\n  const viewportTilesIndexes = tilecover.indexes(geom, limits)\n  const visibleTiles = []\n\n  viewportTilesCoords.forEach((coords, i) => {\n    const uid = viewportTilesIndexes[i]\n    const zoom = coords[2]\n    if (zoom >= 2) {\n      visibleTiles.push({\n        tileCoordinates: {\n          x: coords[0],\n          y: coords[1],\n          zoom: coords[2],\n        },\n        uid,\n      })\n    }\n  })\n\n  dispatch({\n    type: SET_CURRENTLY_VISIBLE_TILES,\n    payload: visibleTiles,\n  })\n\n  const isMouseWheelZooming = mapViewport.prevZoom !== viewport.zoom\n\n  if (isMouseWheelZooming === false) {\n    dispatch(flushTileState(forceLoadingAllVisibleTiles))\n  } else {\n    debouncedFlushState(dispatch)\n  }\n}\n\nexport const queryHeatmapVessels = (coords, temporalExtentIndexes) => (dispatch, getState) => {\n  // use tilecover to get what tile quadkey/uid \"belongs\" to the point\n  const geom = {\n    type: 'Point',\n    coordinates: [coords.longitude, coords.latitude],\n  }\n  const zoom = getState().map.viewport.viewport.zoom\n\n  // get quadkey for tile at current zoom level, but also neighbouring zoom levels,\n  // in case current zoom level tiles has not been loaded yet\n  const uids = [zoom, zoom - 1, zoom + 1]\n    .map((z) => getTilecoverLimits(z))\n    .map((limits) => tilecover.indexes(geom, limits))\n    .map((indexes) => indexes[0])\n\n  const query = {\n    ...coords,\n    uids,\n  }\n\n  // console.log(query);\n  dispatch(highlightVesselFromHeatmap(query, temporalExtentIndexes))\n}\n","import difference from 'lodash/difference'\nimport uniq from 'lodash/uniq'\nimport uniqBy from 'lodash/uniqBy'\nimport {\n  getTilePromises,\n  getCleanVectorArrays,\n  groupData,\n  getTilePlaybackData,\n  selectVesselsAt,\n} from '../utils/heatmapTileData'\nimport { ENCOUNTERS } from '../constants'\nimport { markTileAsLoaded } from './heatmapTiles.actions'\nimport { startLoader, completeLoader } from '../module/module.actions'\n\nexport const ADD_HEATMAP_LAYER = 'ADD_HEATMAP_LAYER'\nexport const UPDATE_HEATMAP_LAYER_STYLE = 'UPDATE_HEATMAP_LAYER_STYLE'\nexport const ADD_REFERENCE_TILE = 'ADD_REFERENCE_TILE'\nexport const HIGHLIGHT_VESSELS = 'HIGHLIGHT_VESSELS'\nexport const INIT_HEATMAP_LAYERS = 'INIT_HEATMAP_LAYERS'\nexport const REMOVE_HEATMAP_LAYER = 'REMOVE_HEATMAP_LAYER'\nexport const UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES =\n  'UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES'\nexport const UPDATE_HEATMAP_TILE = 'UPDATE_HEATMAP_TILE'\nexport const RELEASE_HEATMAP_TILES = 'RELEASE_HEATMAP_TILES'\nexport const UPDATE_LOADED_TILES = 'UPDATE_LOADED_TILES'\nexport const HIGHLIGHT_CLICKED_VESSEL = 'HIGHLIGHT_CLICKED_VESSEL'\nexport const CLEAR_HIGHLIGHT_CLICKED_VESSEL = 'CLEAR_HIGHLIGHT_CLICKED_VESSEL'\n\n/**\n * getTemporalExtentsVisibleIndices - Compares timebar outer extent with temporal extents present on the layer header\n * @param  {array} loadTemporalExtent Current timebar outer extent\n * @param  {array} layerTemporalExtents Temporal extent present on the layer's header (an array of extent arrays)\n * @return {array}                    Indices of the layer's temporal extents that should be visible\n */\nfunction getTemporalExtentsVisibleIndices(loadTemporalExtent, layerTemporalExtents) {\n  const currentExtentStart = loadTemporalExtent[0].getTime()\n  const currentExtentEnd = loadTemporalExtent[1].getTime()\n  const indices = []\n  layerTemporalExtents.forEach((temporalExtent, index) => {\n    const temporalExtentStart = temporalExtent[0]\n    const temporalExtentEnd = temporalExtent[1]\n    if (temporalExtentEnd >= currentExtentStart && temporalExtentStart <= currentExtentEnd) {\n      indices.push(index)\n    }\n  })\n  return indices\n}\n\n/**\n * loadLayerTile - loads an heatmap tile.\n *\n * @param  {string} layerId              layer id\n * @param  {object} tileCoordinates      tile coordinates from reference tile\n * @param  {string} token                the user's token\n * @param  {array} temporalExtentsIndices which of the temporal extents from  temporalExtents should be loaded\n * @param  {string} urls                 tile endpoints provided by header\n * @param  {array} temporalExtents       all of the layer's header temporal extents\n * @param  {bool} temporalExtentsLess    true = don't try to load different tiles based on current time extent\n * @param  {bool} isPBF                  true = read tile as MVT + PBF tile, rather than using Pelagos client\n * @return {Promise}                     a Promise that will be resolved when tile is loaded\n */\nfunction loadLayerTile(\n  layerId,\n  tileCoordinates,\n  token,\n  temporalExtentsIndices,\n  { url, temporalExtents, temporalExtentsLess, isPBF }\n) {\n  // console.log('loadLayerTile', layerId, tileCoordinates, temporalExtentsIndices)\n  if (url === undefined) {\n    throw new Error('URL/endpoints object is not available on this tilesets header')\n  }\n  const pelagosPromises = getTilePromises(url, token, temporalExtents, {\n    tileCoordinates,\n    temporalExtentsIndices,\n    temporalExtentsLess,\n    isPBF,\n  })\n  const allLayerPromises = Promise.all(pelagosPromises)\n\n  const layerTilePromise = new Promise((resolve) => {\n    allLayerPromises.then((rawTileData) => {\n      resolve({\n        loadedLayerId: layerId,\n        rawTileData,\n      })\n    })\n  })\n\n  return layerTilePromise\n}\n\n/**\n * parseLayerTile - parses an heatmap tile to a playback-ready format.\n *\n * @param  {Object} rawTileData          the raw tile data, loaded either from the pelagos client or as a MVT/PBF vector tile\n * @param  {array} colsByName            names of the columns present in the raw tiles that need to be included in the final playback data\n * @param  {object} tileCoordinates      tile coordinates from reference tile\n * @param  {array} prevPlaybackData      (optional) in case some time extent was already loaded for this tile, append to this data\n * @return {Object}                      playback-ready merged data\n */\nfunction parseLayerTile(rawTileData, colsByName, isPBF, tileCoordinates, prevPlaybackData) {\n  let data\n  if (isPBF === true) {\n    if (\n      rawTileData === undefined ||\n      !rawTileData.length ||\n      rawTileData[0] === undefined ||\n      !Object.keys(rawTileData[0].layers).length\n    ) {\n      return []\n    }\n    data = rawTileData[0].layers.points\n  } else {\n    const cleanVectorArrays = getCleanVectorArrays(rawTileData)\n    data = groupData(cleanVectorArrays, Object.keys(colsByName))\n    if (Object.keys(data).length === 0) {\n      return []\n    }\n  }\n  const playbackData = getTilePlaybackData(\n    data,\n    colsByName,\n    tileCoordinates,\n    isPBF,\n    prevPlaybackData\n  )\n  return playbackData\n}\n\n/**\n * getTiles - loads a bunch of heatmap tiles\n * @param  {array} layerIds                 list of layer Ids that need to be loaded for this/these tiles\n * @param  {array} referenceTiles           list of reference tiles (tile data regardless of layer) that need to be loaded\n * @param  {object} newTemporalExtentsToLoad (optional) a dict (layerId is the key) of temporal extents\n * indices that should be appended to existing data\n */\nfunction getTiles(layerIds, referenceTiles, newTemporalExtentsToLoad = undefined) {\n  return (dispatch, getState) => {\n    const state = getState()\n    const loaderID = startLoader(dispatch, state)\n    const token = state.map.module.token\n    const heatmapLayers = state.map.heatmap.heatmapLayers\n    const tilesByLayer = {}\n    layerIds.forEach((id) => {\n      tilesByLayer[id] = [...heatmapLayers[id].tiles]\n    })\n    const allPromises = []\n\n    layerIds.forEach((layerId) => {\n      const heatmapLayerHeader = heatmapLayers[layerId].header\n      const { temporalExtents, temporalExtentsLess, isPBF, colsByName } = { ...heatmapLayerHeader }\n      const url = heatmapLayerHeader.endpoints.tiles\n\n      referenceTiles.forEach((referenceTile) => {\n        // check if tile does not already exist first\n        let tile = tilesByLayer[layerId].find((t) => t.uid === referenceTile.uid)\n        if (!tile) {\n          // console.log('create tile ', referenceTile.uid)\n          tile = {\n            uid: referenceTile.uid,\n            temporalExtentsIndicesLoaded: [],\n          }\n          tilesByLayer[layerId].push(tile)\n        } else {\n          // console.log('found tile', referenceTile.uid)\n        }\n\n        const queriedTemporalExtentsIndices =\n          newTemporalExtentsToLoad === undefined\n            ? heatmapLayers[layerId].visibleTemporalExtentsIndices\n            : newTemporalExtentsToLoad[layerId]\n\n        const temporalExtentsIndicesToLoad = difference(\n          queriedTemporalExtentsIndices,\n          tile.temporalExtentsIndicesLoaded\n        )\n\n        const tilePromise = loadLayerTile(\n          layerId,\n          referenceTile.tileCoordinates,\n          token,\n          temporalExtentsIndicesToLoad,\n          {\n            url,\n            temporalExtents,\n            temporalExtentsLess,\n            isPBF,\n          }\n        )\n\n        allPromises.push(tilePromise)\n\n        tilePromise.then(({ loadedLayerId, rawTileData }) => {\n          tile.temporalExtentsIndicesLoaded = uniq(\n            tile.temporalExtentsIndicesLoaded.concat(temporalExtentsIndicesToLoad)\n          )\n          tile.data = parseLayerTile(\n            rawTileData,\n            colsByName,\n            isPBF,\n            referenceTile.tileCoordinates,\n            tile.data\n          )\n\n          dispatch({\n            type: UPDATE_HEATMAP_TILE,\n            payload: {\n              layerId: loadedLayerId,\n              tile,\n            },\n          })\n        })\n      })\n    })\n\n    Promise.all(allPromises).then(() => {\n      dispatch(completeLoader(loaderID))\n      dispatch(markTileAsLoaded(referenceTiles.map((tile) => tile.uid)))\n    })\n  }\n}\n\n/**\n * getTile - This action is emitted when a new tile is queried from panning or zooming the map\n * This will load a tile for all currently visible heatmap layers\n *\n * @param  {object} referenceTile a reference tile containing xyz coords and uid\n */\nexport function getTile(referenceTile) {\n  return (dispatch, getState) => {\n    dispatch({\n      type: ADD_REFERENCE_TILE,\n      payload: referenceTile,\n    })\n    const visibleHeatmapLayers = getState().map.heatmap.heatmapLayers\n    const visibleHeatmapLayersIds = Object.keys(visibleHeatmapLayers).filter(\n      (id) => visibleHeatmapLayers[id].visible === true\n    )\n\n    if (visibleHeatmapLayersIds.length) {\n      dispatch(getTiles(visibleHeatmapLayersIds, [referenceTile]))\n    }\n  }\n}\n\n/**\n * releaseTiles - This action is emitted when an existing tile is removed from panning or zooming the map\n * @param  {array} uids tile ref uids to release\n */\nexport const releaseTiles = (uids) => ({\n  type: RELEASE_HEATMAP_TILES,\n  payload: uids,\n})\n\nexport const updateLoadedTiles = () => ({\n  type: UPDATE_LOADED_TILES,\n})\n\n// triggered when a layer is added or set to visible\nfunction loadAllTilesForLayer(layerId) {\n  return (dispatch, getState) => {\n    //                current layer, all reference tiles\n    const referenceTiles = getState().map.heatmap.referenceTiles\n    dispatch(getTiles([layerId], referenceTiles))\n  }\n}\n\nexport const addHeatmapLayer = (layer, loadTemporalExtent) => (dispatch) => {\n  const layerTemporalExtents = layer.header.temporalExtents\n  dispatch({\n    type: ADD_HEATMAP_LAYER,\n    payload: {\n      ...layer,\n      // initially attach which of the temporal extents indices are visible with initial outerExtent\n      visibleTemporalExtentsIndices: getTemporalExtentsVisibleIndices(\n        loadTemporalExtent,\n        layerTemporalExtents\n      ),\n    },\n  })\n\n  if (layer.visible === true) {\n    dispatch(loadAllTilesForLayer(layer.id))\n  }\n}\n\nexport const removeHeatmapLayer = (id) => (dispatch) => {\n  dispatch({\n    type: REMOVE_HEATMAP_LAYER,\n    payload: {\n      id,\n    },\n  })\n}\n\n/**\n * updateLayerLoadTemporalExtents - when outer time extent changes, checks if more tiles needs to be loaded\n * by comparing the outer time range with the temporalExtent already loaded on each layer.\n * @param  {array} loadTemporalExtent Current app-wide extent of tiles that need to load, expressed\n * as an array of two dates\n */\nexport function updateLayerLoadTemporalExtents(loadTemporalExtent) {\n  return (dispatch, getState) => {\n    const state = getState()\n    const heatmapLayers = state.map.heatmap.heatmapLayers\n    const indicesToAddByLayer = {}\n    Object.keys(heatmapLayers).forEach((layerId) => {\n      const heatmapLayer = heatmapLayers[layerId]\n      const temporalExtents = heatmapLayer.header.temporalExtents\n      const oldVisibleTemporalExtentsIndices = heatmapLayer.visibleTemporalExtentsIndices\n      const newVisibleTemporalExtentsIndices = getTemporalExtentsVisibleIndices(\n        loadTemporalExtent,\n        temporalExtents\n      )\n      const indicesAdded = difference(\n        newVisibleTemporalExtentsIndices,\n        oldVisibleTemporalExtentsIndices\n      )\n\n      if (indicesAdded.length) {\n        // add new loaded indices to heatmap layer if applicable\n        indicesToAddByLayer[layerId] = indicesAdded\n        dispatch({\n          type: UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES,\n          payload: {\n            layerId,\n            indicesAdded,\n          },\n        })\n      }\n    })\n\n    // getTiles with indices diff\n    const layerIdsWithIndicesToAdd = Object.keys(indicesToAddByLayer)\n    if (layerIdsWithIndicesToAdd.length) {\n      dispatch(\n        getTiles(layerIdsWithIndicesToAdd, state.map.heatmap.referenceTiles, indicesToAddByLayer)\n      )\n    }\n  }\n}\n\n/**\n * Returns clusters or vessels data from a tileQuery\n * @param {object} state - the application state\n * @param {string} tileQuery - the id of a heatmap layer\n * @return {object} { isEmpty, isCluster, isMouseCluster, foundVessels, layerId, tilesetId }\n */\nconst _queryHeatmap = (state, tileQuery, temporalExtentIndexes) => {\n  const layers = state.map.heatmap.heatmapLayers\n  const startIndex = temporalExtentIndexes[0]\n  const endIndex = temporalExtentIndexes[1]\n  const layersVessels = []\n\n  Object.keys(layers).forEach((layerId) => {\n    const layer = layers[layerId]\n    const allPossibleTilesByPreference = tileQuery.uids.map((uid) =>\n      layer.tiles.find((tile) => tile.uid === uid)\n    )\n    const availableTiles = allPossibleTilesByPreference.filter(\n      (tile) => tile !== undefined && tile.data !== undefined\n    )\n\n    const currentFilters = layer.filters\n    if (availableTiles.length) {\n      const bestTile = availableTiles[0]\n      layersVessels.push({\n        layer,\n        vessels: selectVesselsAt(bestTile.data, tileQuery, startIndex, endIndex, currentFilters),\n      })\n    }\n  })\n\n  const layersVesselsResults = layersVessels.filter(\n    (layerVessels) => layerVessels.vessels.length > 0\n  )\n\n  // it's a cluster because of aggregation on the server side\n  let isCluster\n  // its a cluster because or multiple vessels under mouse\n  let isMouseCluster\n  let isEmpty\n  let layerVesselsResult\n  let foundVessels\n\n  const hasEncounters =\n    layersVesselsResults.filter((layerVessel) => layerVessel.layer.subtype === ENCOUNTERS).length >\n    0\n\n  if (layersVesselsResults.length === 0) {\n    isEmpty = true\n  } else if (layersVesselsResults.length > 1 && !hasEncounters) {\n    // if there are points over multiple layers, consider this a cluster (ie don't select, zoom instead, or don't highlight)\n    // there's an exception if vessel selection contains an encounter, in which case it will take priority\n    isCluster = true\n  } else {\n    // if we have a hit with an encounters layer, use it in priority\n    // if not the layersVesselsResults should contain a single result\n    layerVesselsResult = hasEncounters\n      ? layersVesselsResults.find((layerVessel) => layerVessel.layer.subtype === ENCOUNTERS)\n      : layersVesselsResults[0]\n\n    // we can get multiple points with similar series and seriesgroup, in which case\n    // we should treat that as a successful vessel query, not a cluster\n    const vessels = layerVesselsResult.vessels\n\n    if (vessels.length === 0) {\n      isEmpty = true\n    } else {\n      // look up for any negatives seriesgroup (clusters on the server side)\n      const clusteredVessels = vessels.filter((v) => v.seriesgroup < 0)\n      if (clusteredVessels.length) {\n        isCluster = true\n      } else {\n        foundVessels = uniqBy(vessels, (v) => v.series)\n        isMouseCluster = foundVessels.length > 1\n      }\n    }\n  }\n\n  const layer = layerVesselsResult === undefined ? {} : layerVesselsResult.layer\n\n  return { isEmpty, isCluster, isMouseCluster, foundVessels, layer }\n}\n\nexport function clearHighlightedVessels() {\n  return {\n    type: HIGHLIGHT_VESSELS,\n    payload: {\n      isEmpty: true,\n      clickableCluster: false,\n    },\n  }\n}\n\nexport function highlightVesselFromHeatmap(tileQuery, temporalExtentIndexes) {\n  return (dispatch, getState) => {\n    const state = getState()\n    const { layer, isEmpty, isCluster, isMouseCluster, foundVessels } = _queryHeatmap(\n      state,\n      tileQuery,\n      temporalExtentIndexes\n    )\n\n    if (layer.id !== undefined || state.map.heatmap.highlightedVessels.layerId !== layer.id) {\n      dispatch({\n        type: HIGHLIGHT_VESSELS,\n        payload: {\n          layer: {\n            id: layer.id,\n            tilesetId: layer.tilesetId,\n            subtype: layer.subtype,\n            header: layer.header,\n          },\n          isEmpty,\n          clickableCluster: isCluster === true || isMouseCluster === true,\n          highlightableCluster: isCluster !== true,\n          foundVessels,\n        },\n      })\n    } else {\n      dispatch(clearHighlightedVessels())\n    }\n  }\n}\n\nexport const highlightClickedVessel = (seriesgroup, layerId) => ({\n  type: HIGHLIGHT_CLICKED_VESSEL,\n  payload: {\n    seriesgroup,\n    layerId,\n  },\n})\n\nexport const clearHighlightedClickedVessel = () => ({\n  type: CLEAR_HIGHLIGHT_CLICKED_VESSEL,\n})\n\nexport const updateHeatmapLayers = (newLayers, currentLoadTemporalExtent) => (\n  dispatch,\n  getState\n) => {\n  const prevLayersDict = getState().map.heatmap.heatmapLayers\n\n  // add and update layers\n  newLayers.forEach((newLayer) => {\n    const layerId = newLayer.id\n    const prevLayer = prevLayersDict[layerId]\n    if (prevLayer === undefined) {\n      // console.log('adding', layerId)\n      dispatch(addHeatmapLayer(newLayer, currentLoadTemporalExtent))\n    } else {\n      if (prevLayer.visible !== newLayer.visible && newLayer.visible === true) {\n        dispatch(loadAllTilesForLayer(layerId))\n      }\n      if (\n        prevLayer.visible !== newLayer.visible ||\n        prevLayer.hue !== newLayer.hue ||\n        prevLayer.opacity !== newLayer.opacity ||\n        prevLayer.filters !== newLayer.filters ||\n        prevLayer.interactive !== newLayer.interactive\n      ) {\n        // console.log('updating', layerId, ' with visibilty', newLayer.visible)\n        dispatch({\n          type: UPDATE_HEATMAP_LAYER_STYLE,\n          payload: {\n            id: newLayer.id,\n            visible: newLayer.visible,\n            hue: newLayer.hue,\n            opacity: newLayer.opacity,\n            filters: newLayer.filters,\n            interactive: newLayer.interactive,\n          },\n        })\n      }\n    }\n  })\n\n  // clean up unused layers\n  Object.keys(prevLayersDict).forEach((prevLayerId) => {\n    if (!newLayers.find((l) => l.id === prevLayerId)) {\n      dispatch(removeHeatmapLayer(prevLayerId))\n    }\n  })\n}\n","import { fitBounds, pixelsToWorld } from 'viewport-mercator-project'\nimport { updateHeatmapTilesFromViewport } from '../heatmap/heatmapTiles.actions'\nimport { onViewportChange } from '../module/module.actions'\nimport { CLUSTER_CLICK_ZOOM_INCREMENT } from '../config' // TODO MAP MODULE\n\nexport const SET_VIEWPORT = 'SET_VIEWPORT'\nexport const UPDATE_VIEWPORT = 'UPDATE_VIEWPORT'\nexport const SET_ZOOM_INCREMENT = 'SET_ZOOM_INCREMENT'\nexport const SET_MOUSE_LAT_LONG = 'SET_MOUSE_LAT_LONG'\nexport const TRANSITION_END = 'TRANSITION_END'\nexport const SET_NATIVE_VIEWPORT = 'SET_NATIVE_VIEWPORT'\n\nexport const setViewport = (viewport) => (dispatch) => {\n  dispatch({\n    type: SET_VIEWPORT,\n    payload: viewport,\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  dispatch(onViewportChange())\n}\n\nexport const updateViewport = (viewportUpdate) => (dispatch) => {\n  dispatch({\n    type: UPDATE_VIEWPORT,\n    payload: viewportUpdate,\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  dispatch(onViewportChange())\n}\n\nconst transitionTo = (increment, latitude = null, longitude = null, zoom = null) => (dispatch) => {\n  dispatch({\n    type: SET_ZOOM_INCREMENT,\n    payload: {\n      increment,\n      latitude,\n      longitude,\n      zoom,\n    },\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  dispatch(onViewportChange())\n}\n\nexport const transitionToZoom = (zoom) => (dispatch) => {\n  dispatch(transitionTo(null, null, null, zoom))\n}\n\nexport const transitionEnd = () => (dispatch) => {\n  dispatch({\n    type: TRANSITION_END,\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  dispatch(onViewportChange())\n}\n\nexport const zoomIntoVesselCenter = (latitude, longitude) => (dispatch) => {\n  dispatch(transitionTo(CLUSTER_CLICK_ZOOM_INCREMENT, latitude, longitude))\n}\n\nexport const fitToBounds = (bounds) => (dispatch, getState) => {\n  const state = getState()\n  const vp = fitBounds({\n    bounds: [[bounds.minLng, bounds.minLat], [bounds.maxLng, bounds.maxLat]],\n    width: state.map.viewport.viewport.width,\n    height: state.map.viewport.viewport.height,\n    padding: 50,\n  })\n  dispatch(transitionTo(null, vp.latitude, vp.longitude, vp.zoom))\n}\n\nexport const exportNativeViewport = (nativeViewport) => (dispatch) => {\n  const topLeftPx = [0, 0]\n  const bottomRightPx = [nativeViewport.width, nativeViewport.height]\n\n  // compute left and right offsets to deal with antimeridian issue\n  const topLeftWorld = pixelsToWorld(topLeftPx, nativeViewport.pixelUnprojectionMatrix)\n  const bottomRightWorld = pixelsToWorld(bottomRightPx, nativeViewport.pixelUnprojectionMatrix)\n  const leftWorldScaled = topLeftWorld[0] / nativeViewport.scale\n  const rightWorldScaled = bottomRightWorld[0] / nativeViewport.scale\n\n  // lat/lon corners for miniglobe\n  const northWest = nativeViewport.unproject(topLeftPx)\n  const southEast = nativeViewport.unproject(bottomRightPx)\n  const bounds = {\n    north: northWest[1],\n    south: southEast[1],\n    west: northWest[0],\n    east: southEast[0],\n  }\n\n  dispatch({\n    type: SET_NATIVE_VIEWPORT,\n    payload: {\n      leftWorldScaled,\n      rightWorldScaled,\n      bounds,\n    },\n  })\n}\n","import area from '@turf/area'\nimport { POLYGON_LAYERS_AREA } from '../constants'\nimport { clearHighlightedVessels, clearHighlightedClickedVessel } from '../heatmap/heatmap.actions'\nimport { zoomIntoVesselCenter } from './viewport.actions'\n\nexport const SET_POPUP = 'SET_POPUP'\nexport const CLEAR_POPUP = 'CLEAR_POPUP'\nexport const SET_MAP_CURSOR = 'SET_MAP_CURSOR'\nexport const UPDATE_POPUP_REPORT_STATUS = 'UPDATE_POPUP_REPORT_STATUS'\n\nconst getFeatureMetaFields = (staticLayerId, state, feature) => {\n  const source = state.style.mapStyle.toJS().sources[staticLayerId]\n  if (source === undefined) {\n    console.warn('Couldnt find source when looking for fields of layer', staticLayerId)\n  }\n  if (source.type !== 'geojson') {\n    if (source.metadata === undefined || source.metadata['gfw:popups'] === undefined) {\n      return null\n    }\n    return source.metadata['gfw:popups']\n  }\n  // when layer is of type geojson (custom layer), use all feature properties available\n  return Object.keys(feature.properties).length === 0\n    ? null\n    : Object.keys(feature.properties).map((key) => ({ id: key }))\n}\n\nconst getAreaKm2 = (glFeature) => {\n  const areakm2 = 10 ** -6 * area(glFeature.geometry)\n  const formatted = areakm2.toLocaleString('en-US', { maximumFractionDigits: 0 })\n  return formatted\n}\n\nconst getStaticLayerIdFromGlFeature = (glFeature) =>\n  (glFeature.layer.metadata !== undefined && glFeature.layer.metadata['gfw:id']) ||\n  glFeature.layer.source\n\nconst findFeature = (glFeatures) => {\n  if (glFeatures === undefined || !glFeatures.length) {\n    return undefined\n  }\n  for (let i = 0; i < glFeatures.length; i++) {\n    const glFeature = glFeatures[i]\n    const staticLayerId = getStaticLayerIdFromGlFeature(glFeature)\n    if (staticLayerId !== undefined) {\n      return {\n        feature: glFeature,\n        staticLayerId,\n      }\n    }\n  }\n  return undefined\n}\n\nexport const mapHover = (latitude, longitude, features, cluster) => (dispatch, getState) => {\n  const state = getState().map\n  const currentActivityLayersInteractionData = state.heatmap.highlightedVessels\n  const { layer, isEmpty, foundVessels } = currentActivityLayersInteractionData\n\n  let cursor = null\n  const event = {\n    type: null,\n  }\n\n  if (isEmpty === true) {\n    const feature = findFeature(features, null)\n    if (feature !== undefined) {\n      const popupFields = getFeatureMetaFields(feature.staticLayerId, state, feature.feature)\n      if (popupFields !== null) {\n        const properties = feature.feature.properties\n        const mainPopupField =\n          popupFields.find((f) => f.id && f.id.toLowerCase() === 'name') ||\n          popupFields.find((f) => f.id && f.id.toLowerCase() === 'id') ||\n          popupFields.find(\n            (f) =>\n              f.id &&\n              properties[f.id] !== null &&\n              properties[f.id] !== 'null' &&\n              properties[f.id] !== undefined\n          )\n        const mainPopupFieldId = mainPopupField.id\n        const featureTitle = properties[mainPopupFieldId]\n        event.type = 'static'\n        event.cluster = cluster\n        event.layer = {\n          id: feature.staticLayerId,\n        }\n        event.target = {\n          featureTitle,\n          properties,\n        }\n        cursor = 'pointer'\n      }\n    }\n  } else if (isEmpty !== true) {\n    const isCluster = foundVessels === undefined || foundVessels.length > 1\n    cursor = isCluster ? 'zoom-in' : 'pointer'\n\n    event.type = 'activity'\n    // TODO MAP MODULE sometimes layerId is undefined, likely an issue with heatmap[Tiles]\n    event.layer = layer\n    event.target = {\n      objects: foundVessels,\n      isCluster,\n    }\n  }\n\n  if (cursor !== state.interaction.cursor) {\n    dispatch({\n      type: SET_MAP_CURSOR,\n      payload: cursor,\n    })\n  }\n\n  if (state.module.onHover) {\n    state.module.onHover({\n      ...event,\n      latitude,\n      longitude,\n    })\n  }\n}\n\nexport const mapClick = (latitude, longitude, features, cluster) => (dispatch, getState) => {\n  const state = getState().map\n\n  dispatch(clearHighlightedClickedVessel())\n\n  const currentActivityLayersInteractionData = state.heatmap.highlightedVessels\n\n  const { layer, isEmpty, clickableCluster, foundVessels } = currentActivityLayersInteractionData\n\n  const event = {\n    type: null,\n  }\n\n  if (isEmpty === true) {\n    const feature = findFeature(features, null)\n    if (feature !== undefined) {\n      const metaFields = getFeatureMetaFields(feature.staticLayerId, state, feature.feature)\n      let fields\n      const properties = feature.feature.properties\n\n      if (metaFields !== null) {\n        fields = metaFields.map((metaField) => {\n          const id = metaField.id || metaField\n          const value = id === POLYGON_LAYERS_AREA ? getAreaKm2(feature.feature) : properties[id]\n          return {\n            title: metaField.label || metaField.id,\n            isLink: metaField.isLink,\n            value,\n          }\n        })\n      }\n\n      event.type = 'static'\n      event.cluster = cluster\n      event.layer = {\n        id: feature.staticLayerId,\n      }\n      event.target = {\n        fields,\n        properties,\n      }\n    }\n  } else {\n    event.type = 'activity'\n    event.layer = layer\n    if (clickableCluster === true) {\n      dispatch(zoomIntoVesselCenter(latitude, longitude))\n      dispatch(clearHighlightedVessels())\n      event.target = {\n        isCluster: true,\n      }\n    } else {\n      event.target = foundVessels[0]\n    }\n  }\n\n  if (state.module.onClick) {\n    state.module.onClick({\n      ...event,\n      latitude,\n      longitude,\n    })\n  }\n}\n","const RGB_MAX = 255\nconst HUE_MAX = 360\nconst SV_MAX = 100\n\nexport const VESSELS_HUES_INCREMENTS_NUM = 31 // 360 / VESSELS_HUES_INCREMENTS_NUM - 1  should give a round number\nexport const VESSELS_HUES_INCREMENT = 360 / (VESSELS_HUES_INCREMENTS_NUM - 1)\n\n// Legacy: this is only here for compatibility with pre-mapbox branch workspaces\nexport const COLOR_HUES = {\n  orange: 0,\n  peach: 22,\n  yellow: 60,\n  green: 85,\n  brightGreen: 145,\n  lightBlue: 182,\n  blue: 236,\n  purple: 284,\n  pink: 312,\n}\n\n// FIXME mark explicitely as legacy. Check all usages.\nexport const getKeyByValue = (obj, value) => {\n  let result = null\n  Object.entries(obj).forEach((entry) => {\n    if (entry[1] === value) result = entry[0]\n  })\n  return result\n}\n\n/**\n * Converts an RGB color value to HSV. Conversion formula\n * adapted from http://en.wikipedia.org/wiki/HSV_color_space.\n * Assumes r, g, and b are contained in the set [0, 255] and\n * returns h, s, and v in the set [0, 1].\n *\n * @param   Number  r       The red color value\n * @param   Number  g       The green color value\n * @param   Number  b       The blue color value\n * @return  Array           The HSV representation\n */\nexport const rgbToHsv = (_r, _g, _b) => {\n  const r = _r / 255\n  const g = _g / 255\n  const b = _b / 255\n\n  const max = Math.max(r, g, b)\n  const min = Math.min(r, g, b)\n  let h\n  const v = max\n\n  const d = max - min\n  const s = max === 0 ? 0 : d / max\n\n  if (max === min) {\n    h = 0 // achromatic\n  } else {\n    switch (max) {\n      case r:\n        h = (g - b) / d + (g < b ? 6 : 0)\n        break\n      case g:\n        h = (b - r) / d + 2\n        break\n      case b:\n        h = (r - g) / d + 4\n        break\n      default:\n        h = 0\n    }\n\n    h /= 6\n  }\n\n  return [h, s, v]\n}\n\n// converts hue, saturation, luminance to an rgb object\nexport const hsvToRgb = (h_, s_, v_) => {\n  const h = ((h_ % HUE_MAX) / parseFloat(HUE_MAX)) * 6\n  const s = s_ === SV_MAX ? 1 : (s_ % SV_MAX) / parseFloat(SV_MAX)\n  const v = v_ === SV_MAX ? 1 : (v_ % SV_MAX) / parseFloat(SV_MAX)\n\n  const i = Math.floor(h)\n  const f = h - i\n  const p = v * (1 - s)\n  const q = v * (1 - f * s)\n  const t = v * (1 - (1 - f) * s)\n  const mod = i % 6\n  const r = [v, q, p, p, t, v][mod]\n  const g = [t, v, v, q, p, p][mod]\n  const b = [p, p, t, v, v, q][mod]\n\n  return { r: Math.round(r * RGB_MAX), g: Math.round(g * RGB_MAX), b: Math.round(b * RGB_MAX) }\n}\n\n// returns an rgb string with default saturation and luminance values\nconst hueToRgbDefaults = (hue) => hsvToRgb(hue, 50, 100)\n\nexport const hueToRgbString = (hue) => {\n  const rgb = hueToRgbDefaults(hue)\n  return `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`\n}\n\nexport const rgbToHexString = (rgb, css) => {\n  const str = ['r', 'g', 'b']\n    .map((channelName) => {\n      const channelValue = rgb[channelName]\n      let channelStr = channelValue.toString(16)\n      if (channelValue < 16) {\n        channelStr = `0${channelStr}`\n      }\n      return channelStr\n    })\n    .join('')\n  const prefix = css === true ? '#' : '0x'\n  return `${prefix}${str}`\n}\n\nexport const hueToRgbHexString = (hue, css) => {\n  const rgb = hueToRgbDefaults(hue)\n  return rgbToHexString(rgb, css)\n}\n\nconst closestNumber = (numberArray, goal) =>\n  numberArray.reduce((prev, curr) => (Math.abs(curr - goal) < Math.abs(prev - goal) ? curr : prev))\n\nexport const hueToClosestColor = (hue) => {\n  if (hue === undefined || hue === null) return undefined\n  const colorHueValues = Object.keys(COLOR_HUES).map((key) => COLOR_HUES[key])\n  const closestHue = closestNumber(colorHueValues, hue)\n  return getKeyByValue(COLOR_HUES, closestHue)\n}\n\nexport const hexToRgb = (hex) => {\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex)\n  return result\n    ? {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16),\n      }\n    : null\n}\n\nconst rgbToRgbaString = (rgb, opacity) => `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`\n\nexport const hueToRgbaString = (hue, opacity) => {\n  const rgb = hueToRgbDefaults(hue)\n  return rgbToRgbaString(rgb, opacity)\n}\n\nexport const hexToRgba = (hex, opacity) => {\n  const rgb = hexToRgb(hex)\n  return rgbToRgbaString(rgb, opacity)\n}\n\nexport const hueIncrementToHue = (hueIncrement) => hueIncrement * VESSELS_HUES_INCREMENT\n\nexport const hueToHueIncrement = (hue) =>\n  Math.round((hue / 360) * (VESSELS_HUES_INCREMENTS_NUM - 1))\n\nexport const wrapHue = (hue) => hue % 360\n\nexport const hueOrColorToHexColor = (color, hue) => {\n  if (hue !== undefined) {\n    return hueToRgbHexString(hue, true)\n  }\n\n  return color\n}\n","/* global PIXI */\nimport 'pixi.js'\nimport { hueToHueIncrement, VESSELS_HUES_INCREMENTS_NUM } from '../utils/map-colors'\nimport { VESSELS_BASE_RADIUS, MAX_SPRITES_PER_LAYER } from '../config'\n\nexport default class HeatmapSubLayer {\n  constructor(baseTexture, renderingStyleIndex, hue, useNormalBlendMode = false) {\n    // this.stage = new PIXI.Container();\n    // the ParticleContainer is a faster version of the PIXI sprite container\n    this.stage = new PIXI.particles.ParticleContainer(MAX_SPRITES_PER_LAYER, {\n      scale: true,\n      alpha: true,\n      position: true,\n      uvs: true,\n    })\n    if (useNormalBlendMode === false) {\n      this.stage.blendMode = PIXI.BLEND_MODES.SCREEN\n    }\n\n    this.spritesPool = []\n\n    const initialTextureFrame = new PIXI.Rectangle(\n      0,\n      0,\n      VESSELS_BASE_RADIUS * 2,\n      VESSELS_BASE_RADIUS * 2\n    )\n    this.mainVesselTexture = new PIXI.Texture(baseTexture, initialTextureFrame)\n    this._setTextureFrame(renderingStyleIndex, hue)\n\n    this.clearSpriteProps()\n  }\n\n  clearSpriteProps() {\n    this.spritesProps = {\n      x: new Float32Array(MAX_SPRITES_PER_LAYER),\n      y: new Float32Array(MAX_SPRITES_PER_LAYER),\n      a: new Float32Array(MAX_SPRITES_PER_LAYER),\n      s: new Float32Array(MAX_SPRITES_PER_LAYER),\n    }\n    this.spritesPropsCount = 0\n  }\n\n  pushSpriteProps(x, y, a, s) {\n    this.spritesProps.x[this.spritesPropsCount] = x\n    this.spritesProps.y[this.spritesPropsCount] = y\n    this.spritesProps.a[this.spritesPropsCount] = a\n    this.spritesProps.s[this.spritesPropsCount] = s\n    this.spritesPropsCount++\n  }\n\n  setRenderingStyleIndex(renderingStyleIndex) {\n    this._setTextureFrame(renderingStyleIndex)\n  }\n\n  destroy() {\n    this.spritesPool = null\n    this.stage.destroy({ children: true })\n  }\n\n  /**\n   * Updates the main texture frame offset to show different brush styles and hues\n   * Both args are optional, if one is omitted, previous value is used\n   * @heatmapStyle bool whether to use heatmap style or solid circle style\n   * @hue number hue value between 0 and 360\n   */\n  _setTextureFrame(renderingStyleIndex = null, hue = null) {\n    const textureFrame = this.mainVesselTexture.frame.clone()\n\n    if (renderingStyleIndex !== null) {\n      // one diameter + tiny offset between 2 frames\n      textureFrame.x = VESSELS_BASE_RADIUS * 2 * renderingStyleIndex + renderingStyleIndex\n    }\n\n    if (hue !== null) {\n      let hueIncrement = hueToHueIncrement(hue)\n      if (hueIncrement === VESSELS_HUES_INCREMENTS_NUM - 1) {\n        hueIncrement = 0\n      }\n      textureFrame.y = hueIncrement * VESSELS_BASE_RADIUS * 2\n      if (hueIncrement > 0) {\n        textureFrame.y += hueIncrement\n      }\n    }\n\n    this.mainVesselTexture.frame = textureFrame\n    this.mainVesselTexture.update()\n  }\n\n  render() {\n    const numProps = this.spritesPropsCount\n    this.resizeSpritesPool()\n\n    for (let i = 0; i < numProps; i++) {\n      const sprite = this.stage.children[i]\n      const s = this.spritesProps.s[i]\n      sprite.setTransform(this.spritesProps.x[i], this.spritesProps.y[i], s, s)\n      sprite.alpha = this.spritesProps.a[i]\n    }\n\n    const numSprites = this.stage.children.length\n    for (let i = numProps; i < numSprites; i++) {\n      const sprite = this.stage.children[i]\n      sprite.x = -100\n    }\n  }\n\n  resizeSpritesPool() {\n    const numProps = this.spritesPropsCount\n    const prevNumSprites = this.stage.children.length\n    const delta = numProps - prevNumSprites\n    // console.log(prevNumSprites, '->', numProps, ' delta:', delta);\n\n    if (delta < -4999) {\n      // sprite needs to be removed. Do that progressively (max 100) to avoid UI lock\n      const toRemove = Math.min(100, -delta)\n      // console.log('removing ', toRemove);\n      for (let i = 0; i < toRemove; i++) {\n        this.stage.removeChildAt(0)\n      }\n    }\n\n    if (delta > 0) {\n      const toAdd = Math.max(5000, delta)\n      // console.log('adding ', toAdd);\n      this._addSprites(toAdd)\n    }\n  }\n\n  _addSprites(num) {\n    for (let i = 0; i < num; i++) {\n      const vessel = new PIXI.Sprite(this.mainVesselTexture)\n      vessel.anchor.x = 0.5\n      vessel.anchor.y = 0.5\n      // ParticlesContainer does not support .visible, so we just move the sprite out of the viewport\n      vessel.x = -100\n      // vessel.blendMode = PIXI.BLEND_MODES.SCREEN;\n      // vessel.filters=  [new PIXI.filters.BlurFilter(10,10)]\n      this.stage.addChild(vessel)\n    }\n  }\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport uniq from 'lodash/uniq'\nimport * as PIXI from 'pixi.js'\nimport { worldToPixels } from 'viewport-mercator-project'\nimport { BRUSH_RENDERING_STYLE, BRUSH_ZOOM_RENDERING_STYLE } from '../constants'\nimport { vesselSatisfiesFilters } from '../utils/heatmapTileData'\nimport HeatmapSubLayer from './HeatmapSubLayer'\n\n// This is a faster version of worldToPixels that omits pitch,\n// and ignores values from the matrix that are consistently = 0\nconst s = 1 / 1.5\nconst worldToPixelsSimple = (x, y, m) => {\n  const fx = s * (m[0] * x + m[4] * y + m[12])\n  const fy = s * (m[5] * y + m[13])\n  return [fx, fy]\n}\n\nclass HeatmapLayer extends React.Component {\n  componentDidMount() {\n    this._build()\n  }\n\n  componentWillUnmount() {\n    this._destroy()\n  }\n\n  componentDidUpdate() {\n    this._redraw()\n  }\n\n  componentWillReceiveProps(nextProps) {\n    if (nextProps.useRadialGradientStyle !== this.props.useRadialGradientStyle) {\n      this.setBrushZoomRenderingStyle(nextProps.useRadialGradientStyle)\n    }\n  }\n\n  _build() {\n    const { layer, rootStage, useRadialGradientStyle, customRenderingStyle } = this.props\n    this.subLayers = {}\n    this.renderingStyle =\n      layer.header && layer.header.rendering ? layer.header.rendering : customRenderingStyle\n\n    this.setBrushRenderingStyle(this.renderingStyle.style)\n    this.setBrushZoomRenderingStyle(useRadialGradientStyle)\n\n    this.stage = new PIXI.Container()\n\n    rootStage.addChild(this.stage)\n  }\n\n  setBrushRenderingStyle(style = BRUSH_RENDERING_STYLE.NORMAL) {\n    if (typeof style === 'string') {\n      this.brushRenderingStyle = BRUSH_RENDERING_STYLE[style.toUpperCase()]\n    } else {\n      this.brushRenderingStyle = style\n    }\n    this._setBrushRenderingStyleIndex()\n  }\n\n  setBrushZoomRenderingStyle(useRadialGradientStyle) {\n    this.brushZoomRenderingStyle =\n      useRadialGradientStyle === true\n        ? BRUSH_ZOOM_RENDERING_STYLE.RADIAL_GRADIENT\n        : BRUSH_ZOOM_RENDERING_STYLE.CIRCLE\n    this._setBrushRenderingStyleIndex()\n  }\n\n  _setBrushRenderingStyleIndex() {\n    // only NORMAL brush styles support different zoom styles\n    const cappedZoomRenderingStyle =\n      this.brushRenderingStyle === BRUSH_RENDERING_STYLE.NORMAL ? this.brushZoomRenderingStyle : 0\n    const newStyleIndex = this.brushRenderingStyle + cappedZoomRenderingStyle\n    if (newStyleIndex === this.renderingStyleIndex) {\n      return\n    }\n    this.renderingStyleIndex = newStyleIndex\n    Object.values(this.subLayers).forEach((subLayer) => {\n      subLayer.setRenderingStyleIndex(this.renderingStyleIndex)\n    })\n  }\n\n  _redraw() {\n    const { filters, baseTexture, layer } = this.props\n\n    if (\n      layer === null ||\n      layer === undefined ||\n      layer.tiles === undefined ||\n      layer.visible === false\n    ) {\n      this.stage.visible = false\n      return\n    }\n\n    this.stage.visible = true\n    this.stage.alpha = layer.opacity\n\n    const tiles = layer.tiles\n    const defaultHue = layer.hue\n    const allHuesToRender =\n      filters !== undefined && filters.length\n        ? filters\n            // pass is set to true by filterGroupActions when none of the filters fields\n            // in the filter group is supported by the layer headers\n            .filter((f) => f.pass !== true)\n            .map((f) => (f.hue === undefined ? '0' : f.hue.toString()))\n        : [defaultHue.toString()]\n    const currentlyUsedHues = Object.keys(this.subLayers)\n\n    // get all hues, old and new\n    const allHues = uniq(allHuesToRender.concat(currentlyUsedHues))\n\n    for (let i = 0; i < allHues.length; i++) {\n      const hue = allHues[i]\n      if (allHuesToRender.indexOf(hue) === -1) {\n        // not on new hues: delete sublayer\n        this._destroySubLayer(this.subLayers[hue])\n        delete this.subLayers[hue]\n        continue\n      }\n      if (currentlyUsedHues.indexOf(hue) === -1) {\n        // not on old hues: create sublayer\n        this.subLayers[hue] = this._createSublayer(baseTexture, this.renderingStyleIndex, hue)\n      }\n      this.subLayers[hue].clearSpriteProps()\n    }\n\n    if (!allHuesToRender.length) return\n    tiles.forEach((tile) => {\n      this._setSubLayersSpritePropsForTile({\n        data: tile.data,\n        numFilters: filters.length,\n        defaultHue,\n      })\n    })\n\n    allHuesToRender.forEach((hueToRender) => {\n      this.subLayers[hueToRender].render()\n    })\n  }\n\n  _setSubLayersSpritePropsForTile({ data, numFilters, defaultHue }) {\n    if (!data) {\n      return\n    }\n\n    const { startIndex, endIndex, viewport, filters, viewportLeft, viewportRight } = this.props\n\n    for (let timeIndex = startIndex; timeIndex < endIndex; timeIndex++) {\n      const frame = data[timeIndex]\n\n      if (!frame) continue\n\n      for (let index = 0, len = frame.worldX.length; index < len; index++) {\n        let hue\n        if (filters === undefined || !filters.length) {\n          hue = defaultHue\n        }\n        for (let fi = 0; fi < numFilters; fi++) {\n          const filter = filters[fi]\n          if (vesselSatisfiesFilters(frame, index, filter.filterValues)) {\n            hue = filter.hue\n            break\n          }\n        }\n\n        // no filter passes: bail\n        if (hue === undefined) {\n          continue\n        }\n\n        // wrap worldX when point crosses the antimeridian/dateline\n        // world points go from 0 to 512. There is no way to determine if worldX is on the \"wrong\" side\n        // of the antimeridian just by looking at its value (where with lat/lon we can simply look at -/+)\n        // Therefore we compare it to the viewport's left or right boundary, depending on what is currently\n        // \"the right side\" of the antimeridian\n        let worldX = frame.worldX[index]\n        if (viewportLeft > 0 && worldX < viewportLeft) {\n          // worldX is \"behind\" viewportLeft, which means it is \"on the right\" of the antimeridian\n          worldX += 512\n        } else if (viewportLeft < 0 && worldX > viewportRight) {\n          worldX -= 512\n        }\n\n        const scaledX = worldX * viewport.scale\n        const scaledY = frame.worldY[index] * viewport.scale\n        const mtx = viewport.pixelProjectionMatrix\n\n        const [x, y] =\n          viewport.pitch === 0\n            ? worldToPixelsSimple(scaledX, scaledY, mtx)\n            : worldToPixels([scaledX, scaledY], mtx)\n\n        if (x > -10 && x < viewport.width + 10 && y > -10 && y < viewport.height + 10) {\n          this.subLayers[hue].pushSpriteProps(\n            x,\n            y,\n            frame.opacity ? frame.opacity[index] : this.renderingStyle.defaultOpacity,\n            frame.radius ? frame.radius[index] : this.renderingStyle.defaultSize\n          )\n        }\n      }\n    }\n  }\n\n  _createSublayer(baseTexture, renderingStyleIndex, hue) {\n    const subLayer = new HeatmapSubLayer(\n      baseTexture,\n      renderingStyleIndex,\n      hue,\n      this.brushRenderingStyle === BRUSH_RENDERING_STYLE.BULLSEYE\n    )\n    this.stage.addChild(subLayer.stage)\n    return subLayer\n  }\n\n  _destroy() {\n    Object.values(this.subLayers).forEach(this._destroySubLayer.bind(this))\n    this.stage.destroy({ children: true })\n    const { rootStage } = this.props\n    rootStage.removeChild(this.stage)\n  }\n\n  _destroySubLayer(subLayer) {\n    this.stage.removeChild(subLayer.stage)\n    subLayer.destroy()\n  }\n\n  render() {\n    return null\n  }\n}\n\nHeatmapLayer.propTypes = {\n  layer: PropTypes.object,\n  rootStage: PropTypes.object,\n  viewport: PropTypes.object,\n  startIndex: PropTypes.number,\n  endIndex: PropTypes.number,\n  filters: PropTypes.array,\n  baseTexture: PropTypes.object,\n  useRadialGradientStyle: PropTypes.bool,\n  customRenderingStyle: PropTypes.object,\n  viewportLeft: PropTypes.number,\n  viewportRight: PropTypes.number,\n}\n\nexport default HeatmapLayer\n","/* global PIXI */\nimport 'pixi.js'\nimport React from 'react'\nimport PropTypes from 'prop-types'\nimport { worldToPixels } from 'viewport-mercator-project'\nimport { TRACKS_DOTS_STYLE_ZOOM_THRESHOLD } from '../config'\n\nclass TracksLayer extends React.Component {\n  componentDidMount() {\n    this._build()\n  }\n\n  componentDidUpdate() {\n    this._redraw()\n  }\n\n  _build() {\n    const { rootStage } = this.props\n    this.stage = new PIXI.Graphics()\n    this.stage.nativeLines = true\n    rootStage.addChild(this.stage)\n  }\n\n  clear() {\n    this.stage.clear()\n  }\n\n  _redraw() {\n    const { tracks, zoom, startIndex, endIndex, highlightTemporalExtentIndexes } = this.props\n\n    this.clear()\n    if (!tracks.length) {\n      return\n    }\n\n    const overInInner =\n      highlightTemporalExtentIndexes === null\n        ? undefined\n        : [\n            Math.max(startIndex, highlightTemporalExtentIndexes[0]),\n            Math.min(endIndex, highlightTemporalExtentIndexes[1]),\n          ]\n    const overExtent = overInInner && overInInner[1] - overInInner[0] > 0 ? overInInner : undefined\n\n    let n = 0 // eslint-disable-line no-unused-vars\n\n    const drawFishingCircles = zoom > TRACKS_DOTS_STYLE_ZOOM_THRESHOLD\n    const fishingCirclesRadius = 1 + (zoom - TRACKS_DOTS_STYLE_ZOOM_THRESHOLD) * 0.5\n    const drawOverTrack = overExtent !== undefined && overExtent[0] > 0 && overExtent[1] > 0\n\n    tracks.forEach((track) => {\n      n += this._drawTrack({\n        data: track.data,\n        startIndex,\n        endIndex,\n        drawFishingCircles,\n        fishingCirclesRadius,\n        color: `0x${track.color.substr(1)}`,\n        lineThickness: 1,\n        lineOpacity: 1,\n      })\n\n      // Draw the highlight over the track when the user hovers over the Timebar\n      if (drawOverTrack === true) {\n        n += this._drawTrack({\n          data: track.data,\n          startIndex: highlightTemporalExtentIndexes[0],\n          endIndex: highlightTemporalExtentIndexes[1],\n          drawFishingCircles,\n          fishingCirclesRadius,\n          color: '0xFFFFFF',\n          lineThickness: 2,\n          lineOpacity: 1,\n        })\n      }\n    })\n\n    // console.log(n);\n  }\n\n  /**\n   * Draws a single track (line + points)\n   *\n   * @param data track points data in 'playback form' (ie organized by days)\n   * @param extent extent, in day indices\n   * @param offset object containing info about the current situation of the map viewport, used to compute screen coords\n   * @param drawFishingCircles whether to draw fishing circles or not\n   * @param fishingCirclesRadius radius of the fishing circles\n   * @param color\n   * @param lineThickness\n   * @param lineOpacity\n   * @param worldOffset offset to use when a track crosses the dateline (ie 512 to add a second world to the right)\n   */\n  _drawTrack({\n    data,\n    startIndex,\n    endIndex,\n    drawFishingCircles,\n    fishingCirclesRadius,\n    color,\n    lineThickness,\n    lineOpacity,\n    worldOffset = 0,\n  }) {\n    const { viewport } = this.props\n\n    let n = 0\n    let prevSeries\n    let prevWorldX\n    let prevWorldY\n\n    const circlePoints = {\n      x: [],\n      y: [],\n    }\n\n    // line thickness is ignored in native mode anyways.\n    this.stage.lineStyle(lineThickness, color, lineOpacity)\n\n    let duplicateWorld = false\n\n    for (let timeIndex = startIndex; timeIndex < endIndex; timeIndex++) {\n      const frame = data[timeIndex]\n\n      if (!frame) continue\n\n      for (let i = 0, len = frame.series.length; i < len; i++) {\n        const currentSeries = frame.series[i]\n\n        n++\n\n        const worldX = frame.worldX[i] + worldOffset\n        const worldY = frame.worldY[i]\n\n        const [x, y] = worldToPixels(\n          [worldX * viewport.scale, worldY * viewport.scale],\n          viewport.pixelProjectionMatrix\n        )\n\n        if (prevSeries !== currentSeries) {\n          this.stage.moveTo(x, y)\n        }\n\n        // more than a  world of distance between two points = crossing the dateline\n        if (prevWorldX && Math.abs(worldX - prevWorldX) > 256) {\n          // worldOffset === 0 -> this is the first time drawTrack is called\n          if (worldOffset === 0) {\n            // set a flag to call drawTrack again at the end of the loop\n            duplicateWorld = true\n          }\n\n          // get Y coordinate where track intersects with dateline\n          const atDatelineWorldY = prevWorldY + (worldY - prevWorldY) / 2\n\n          // whether tracks crosses dateline from west to east\n          const isWestToEast = worldX - prevWorldX < 0\n\n          const worldXEnd = worldOffset + (512 - 0.000001)\n          const worldXStart = worldOffset\n\n          // get X coordinate ending at dateline\n          const atDatelineEndWorldX = isWestToEast ? worldXEnd : worldXStart\n\n          // get X coordinate starting at dateline\n          const atDatelineStartWorldX = isWestToEast ? worldXStart : worldXEnd\n\n          const [x1, y1] = worldToPixels(\n            [atDatelineEndWorldX * viewport.scale, atDatelineWorldY * viewport.scale],\n            viewport.pixelProjectionMatrix\n          )\n          this.stage.lineTo(x1, y1)\n          const [x2, y2] = worldToPixels(\n            [atDatelineStartWorldX * viewport.scale, atDatelineWorldY * viewport.scale],\n            viewport.pixelProjectionMatrix\n          )\n          this.stage.moveTo(x2, y2)\n        }\n\n        this.stage.lineTo(x, y)\n\n        if (drawFishingCircles && frame.hasFishing[i] === true) {\n          circlePoints.x.push(x)\n          circlePoints.y.push(y)\n        }\n\n        prevWorldX = worldX\n        prevWorldY = worldY\n        prevSeries = currentSeries\n      }\n    }\n\n    if (drawFishingCircles) {\n      this.stage.lineStyle(0)\n      this.stage.beginFill(color, 1)\n      for (let i = 0, circlesLength = circlePoints.x.length; i < circlesLength; i++) {\n        this.stage.drawCircle(circlePoints.x[i], circlePoints.y[i], fishingCirclesRadius)\n      }\n      this.stage.endFill()\n    }\n\n    if (duplicateWorld === true) {\n      ;[-512, 512].forEach((offset) => {\n        this._drawTrack({\n          worldOffset: offset,\n          data,\n          startIndex,\n          endIndex,\n          drawFishingCircles,\n          fishingCirclesRadius,\n          color,\n          lineThickness,\n          lineOpacity,\n        })\n      })\n    }\n    return n\n  }\n\n  render() {\n    return null\n  }\n}\n\nTracksLayer.propTypes = {\n  zoom: PropTypes.number,\n  rootStage: PropTypes.object,\n  viewport: PropTypes.object,\n  startIndex: PropTypes.number,\n  endIndex: PropTypes.number,\n  highlightTemporalExtentIndexes: PropTypes.array,\n  tracks: PropTypes.array,\n}\n\nexport default TracksLayer\n","import React from 'react'\nimport * as PIXI from 'pixi.js'\nimport PropTypes from 'prop-types'\nimport { BaseControl } from 'react-map-gl'\nimport { lngLatToWorld } from 'viewport-mercator-project'\nimport {\n  hsvToRgb,\n  hueToRgbString,\n  hueIncrementToHue,\n  wrapHue,\n  VESSELS_HUES_INCREMENTS_NUM,\n} from '../utils/map-colors'\nimport {\n  VESSELS_BASE_RADIUS,\n  VESSELS_HEATMAP_BLUR_FACTOR,\n  ACTIVITY_HIGHLIGHT_HUE,\n  VESSELS_HEATMAP_DIMMING_ALPHA,\n  VESSELS_RADIAL_GRADIENT_STYLE_ZOOM_THRESHOLD,\n  VESSEL_CLICK_TOLERANCE_PX,\n} from '../config'\nimport HeatmapLayer from '../heatmap/HeatmapLayer'\nimport TracksLayer from '../tracks/TracksLayer'\n\nconst shouldUseRadialGradientStyle = (zoom) => zoom < VESSELS_RADIAL_GRADIENT_STYLE_ZOOM_THRESHOLD\n\n// builds a texture spritesheet containing\n// - the heatmap style (radial gradient)\n// - the circle style that is used at higher zoom levels\n// - the 'bullseye' style used for encounters\n// as well as a number of hues for each in a 2D grid.\n// Then, only the texture frame (mesh UVs) is modified depending on the zoom level,\n// in order not to have to recreate sprites\nconst getVesselTexture = (radius, blurFactor) => {\n  const tplCanvas = document.createElement('canvas')\n  const tplCtx = tplCanvas.getContext('2d')\n  const diameter = radius * 2\n  const NUM_STYLES = 3\n  tplCanvas.width = diameter * NUM_STYLES + (NUM_STYLES - 1) // + (NUM_STYLES - 1): tiny offset between 2 frames\n  tplCanvas.height = diameter * VESSELS_HUES_INCREMENTS_NUM + VESSELS_HUES_INCREMENTS_NUM\n\n  for (let hueIncrement = 0; hueIncrement < VESSELS_HUES_INCREMENTS_NUM; hueIncrement++) {\n    const y = diameter * hueIncrement + hueIncrement\n    const yCenter = y + radius\n\n    // heatmap style\n    let x = radius\n    const gradient = tplCtx.createRadialGradient(\n      x,\n      yCenter,\n      radius * blurFactor,\n      x,\n      yCenter,\n      radius\n    )\n    const hue = hueIncrementToHue(hueIncrement)\n    const rgbString = hueToRgbString(hue)\n    gradient.addColorStop(0, rgbString)\n\n    const rgbOuter = hsvToRgb(wrapHue(hue + 30), 80, 100)\n    gradient.addColorStop(1, `rgba(${rgbOuter.r}, ${rgbOuter.g}, ${rgbOuter.b}, 0)`)\n\n    tplCtx.fillStyle = gradient\n    tplCtx.fillRect(0, y, diameter, diameter)\n\n    // circle style\n    x += diameter + 1 // tiny offset between 2 frames\n    tplCtx.beginPath()\n    tplCtx.arc(x, yCenter, radius, 0, 2 * Math.PI, false)\n    tplCtx.fillStyle = rgbString\n    tplCtx.fill()\n\n    // bullseye style\n    x += diameter + 1\n    tplCtx.beginPath()\n    tplCtx.arc(x, yCenter, radius * 0.4, 0, 2 * Math.PI, false)\n    tplCtx.fillStyle = rgbString\n    tplCtx.fill()\n    tplCtx.beginPath()\n    tplCtx.arc(x, yCenter, radius * 0.95, 0, 2 * Math.PI, false)\n    tplCtx.lineWidth = 1\n    tplCtx.strokeStyle = rgbString\n    tplCtx.stroke()\n  }\n\n  return tplCanvas\n}\n\nclass ActivityLayers extends BaseControl {\n  componentDidMount() {\n    this._build()\n  }\n\n  componentWillReceiveProps(nextProps) {\n    this.props.exportNativeViewport(this._context.viewport)\n\n    if (\n      nextProps.viewport.width !== this.props.viewport.width ||\n      nextProps.viewport.height !== this.props.viewport.height\n    ) {\n      this._updateViewportSize(nextProps.viewport.width, nextProps.viewport.height)\n    }\n  }\n\n  _build() {\n    const { width, height } = this.props.viewport\n\n    this.pixi = new PIXI.Application({\n      width,\n      height,\n      transparent: true,\n      antialias: true,\n    })\n\n    this.renderer = this.pixi.renderer\n    this.canvas = this.pixi.view\n    this.canvas.style.position = 'absolute'\n\n    this.container.appendChild(this.canvas)\n\n    this.stage = this.pixi.stage\n\n    const baseTextureCanvas = getVesselTexture(VESSELS_BASE_RADIUS, VESSELS_HEATMAP_BLUR_FACTOR)\n    this.baseTexture = PIXI.Texture.fromCanvas(baseTextureCanvas)\n\n    this.heatmapStage = new PIXI.Container()\n    this.stage.addChild(this.heatmapStage)\n\n    this.pixi.ticker.add(this._onTick)\n  }\n\n  _updateViewportSize(viewportWidth, viewportHeight) {\n    this.renderer.resize(viewportWidth, viewportHeight)\n  }\n\n  toggleHeatmapDimming(dim) {\n    if (this.heatmapStage === undefined) {\n      return\n    }\n    if (dim === true) {\n      this.heatmapFadingIn = false\n    }\n    this.heatmapStage.alpha = dim === true ? VESSELS_HEATMAP_DIMMING_ALPHA : 1\n  }\n\n  onTouchStart = (event) => {\n    if (!event.touches.length) {\n      return\n    }\n    this.queryCoords(event.touches[0].clientX, event.touches[0].clientY)\n  }\n\n  onMouseMove = (event) => {\n    this.queryCoords(event.clientX, event.clientY)\n  }\n\n  queryCoords(x, y) {\n    // bail if all heatmap layers are set to non-interactive\n    if (this.props.heatmapLayers.every((l) => l.interactive !== true)) {\n      return\n    }\n\n    const { viewport } = this._context\n    const [longitude, latitude] = viewport.unproject([x, y])\n\n    let wrappedLongitude = longitude\n    if (wrappedLongitude > 180) {\n      wrappedLongitude -= 360\n    } else if (wrappedLongitude < -180) {\n      wrappedLongitude += 360\n    }\n\n    const [worldX, worldY] = lngLatToWorld([wrappedLongitude, latitude], 1)\n\n    const toleranceRadiusInWorldUnits = VESSEL_CLICK_TOLERANCE_PX / viewport.scale\n\n    this.props.queryHeatmapVessels(\n      {\n        longitude: wrappedLongitude,\n        latitude,\n        worldX,\n        worldY,\n        toleranceRadiusInWorldUnits,\n      },\n      this.props.temporalExtentIndexes\n    )\n  }\n\n  _onTick = () => {\n    if (this.heatmapFadingIn === true && this.heatmapStage.alpha < 1) {\n      this._heatmapFadeinStep()\n    }\n  }\n\n  _startHeatmapFadein() {\n    this.heatmapFadingIn = true\n    this.heatmapFadeinStartTimestamp = undefined\n  }\n\n  _heatmapFadeinStep() {\n    if (this.heatmapFadeinStartTimestamp === undefined) {\n      this.heatmapFadeinStartTimestamp = Date.now()\n    }\n    const timeElapsed = (Date.now() - this.heatmapFadeinStartTimestamp) / 1000\n    let alpha = this.heatmapStage.alpha + (1 - this.heatmapStage.alpha) * timeElapsed\n    if (alpha >= 1) {\n      alpha = 1\n      this.heatmapFadingIn = false\n    }\n    this.heatmapStage.alpha = alpha\n  }\n\n  // FIXME move to container?\n  _getHighlightData(highlightedVessels, highlightedClickedVessel, heatmapLayers) {\n    const hue = ACTIVITY_HIGHLIGHT_HUE\n    let highlightLayerData = {\n      id: '__HIGHLIGHT__',\n      visible: true,\n      opacity: 1,\n      hue: ACTIVITY_HIGHLIGHT_HUE,\n    }\n    let highlightFilters = []\n\n    if (\n      highlightedVessels !== undefined &&\n      highlightedVessels.layer !== undefined &&\n      highlightedVessels.foundVessels !== undefined &&\n      highlightedVessels.isEmpty !== true\n    ) {\n      const sourceLayer = heatmapLayers.find((l) => l.id === highlightedVessels.layer.id)\n      highlightLayerData = { highlightLayerData, ...sourceLayer }\n      highlightFilters = highlightedVessels.foundVessels.map((vessel) => ({\n        hue,\n        filterValues: {\n          series: [vessel.series],\n        },\n      }))\n    } else if (highlightedClickedVessel !== null) {\n      const sourceLayer = heatmapLayers.find((l) => l.id === highlightedClickedVessel.layer.id)\n      highlightLayerData = { highlightLayerData, ...sourceLayer }\n      highlightFilters = [\n        {\n          hue,\n          filterValues: {\n            series: [highlightedClickedVessel.seriesgroup],\n          },\n        },\n      ]\n    }\n    return {\n      highlightLayerData,\n      highlightFilters,\n    }\n  }\n  _render() {\n    const {\n      zoom,\n      heatmapLayers,\n      temporalExtentIndexes,\n      highlightTemporalExtentIndexes,\n      highlightedVessels,\n      highlightedClickedVessel,\n      tracks,\n      leftWorldScaled,\n      rightWorldScaled,\n    } = this.props\n    const { viewport } = this._context\n\n    const startIndex = temporalExtentIndexes[0]\n    const endIndex = temporalExtentIndexes[1]\n    const useRadialGradientStyle = shouldUseRadialGradientStyle(zoom)\n\n    if (highlightedVessels.isEmpty !== true) {\n      this.toggleHeatmapDimming(true)\n    }\n    if (highlightedVessels.isEmpty === true && tracks.length === 0) {\n      this._startHeatmapFadein()\n    }\n    if (this.renderer) {\n      const err = this.renderer.gl.getError()\n      if (err !== 0) console.log(err)\n    }\n\n    const { highlightLayerData, highlightFilters } = this._getHighlightData(\n      highlightedVessels,\n      highlightedClickedVessel,\n      heatmapLayers\n    )\n\n    return (\n      <div\n        ref={(ref) => {\n          this.container = ref\n        }}\n        style={{ position: 'absolute' }}\n        onMouseMove={this.onMouseMove}\n        onTouchStart={this.onTouchStart}\n      >\n        {heatmapLayers.map((layer) => (\n          <HeatmapLayer\n            key={layer.id}\n            layer={layer}\n            filters={layer.filters || []}\n            viewport={viewport}\n            startIndex={startIndex}\n            endIndex={endIndex}\n            baseTexture={this.baseTexture}\n            rootStage={this.heatmapStage}\n            useRadialGradientStyle={useRadialGradientStyle}\n            customRenderingStyle={{}}\n            viewportLeft={leftWorldScaled}\n            viewportRight={rightWorldScaled}\n          />\n        ))}\n        {this.stage !== undefined && (\n          <HeatmapLayer\n            key=\"highlighted\"\n            layer={highlightLayerData}\n            filters={highlightFilters}\n            viewport={viewport}\n            startIndex={startIndex}\n            endIndex={endIndex}\n            baseTexture={this.baseTexture}\n            rootStage={this.heatmapStage}\n            useRadialGradientStyle={useRadialGradientStyle}\n            customRenderingStyle={{ defaultOpacity: 1, defaultSize: 1 }}\n            viewportLeft={leftWorldScaled}\n            viewportRight={rightWorldScaled}\n          />\n        )}\n        {this.stage !== undefined && (\n          <TracksLayer\n            tracks={tracks}\n            viewport={viewport}\n            zoom={zoom}\n            startIndex={startIndex}\n            endIndex={endIndex}\n            highlightTemporalExtentIndexes={highlightTemporalExtentIndexes}\n            rootStage={this.stage}\n          />\n        )}\n      </div>\n    )\n  }\n}\n\nActivityLayers.propTypes = {\n  zoom: PropTypes.number,\n  heatmapLayers: PropTypes.array,\n  temporalExtentIndexes: PropTypes.array,\n  highlightTemporalExtentIndexes: PropTypes.array,\n  highlightedVessels: PropTypes.object,\n  highlightedClickedVessel: PropTypes.object,\n  tracks: PropTypes.array,\n  queryHeatmapVessels: PropTypes.func,\n  exportNativeViewport: PropTypes.func,\n  leftWorldScaled: PropTypes.number,\n  rightWorldScaled: PropTypes.number,\n}\n\nActivityLayers.contextTypes = {\n  viewport: PropTypes.object,\n}\n\nexport default ActivityLayers\n","import { connect } from 'react-redux'\nimport { createSelector } from 'reselect'\nimport convert from '@globalfishingwatch/map-convert'\nimport { exportNativeViewport } from '../glmap/viewport.actions'\nimport { getTemporalExtent, getHighlightTemporalExtent } from '../module/module.selectors'\nimport ActivityLayers from './ActivityLayers'\nimport { queryHeatmapVessels } from '../heatmap/heatmapTiles.actions'\nimport { MIN_FRAME_LENGTH_MS } from '../config'\n\nconst getHeatmapLayers = (state) => state.map.heatmap.heatmapLayers\n\nconst getHeatmapLayersAsArray = createSelector(\n  [getHeatmapLayers],\n  (heatmapLayers) => {\n    const a = Object.keys(heatmapLayers).map((id) => ({\n      ...heatmapLayers[id],\n    }))\n    // console.log(a)\n    return a\n  }\n)\n\nconst getTracks = (state) => state.map.tracks.data\n\nconst getTracksWithData = createSelector(\n  [getTracks],\n  (tracks) => {\n    const tracksWithData = tracks\n      .filter((t) => t.type !== 'geojson')\n      .filter((t) => t.data !== undefined)\n    return tracksWithData\n  }\n)\n\nconst getTemporalExtentIndexes = createSelector(\n  [getTemporalExtent],\n  (temporalExtent) => {\n    const startTimestamp = temporalExtent[0].getTime()\n    const endTimestamp = Math.max(\n      temporalExtent[1].getTime(),\n      temporalExtent[0].getTime() + MIN_FRAME_LENGTH_MS\n    )\n    const startIndex = convert.getOffsetedTimeAtPrecision(startTimestamp)\n    const endIndex = convert.getOffsetedTimeAtPrecision(endTimestamp)\n    return [startIndex, endIndex]\n  }\n)\n\nconst getHighlightTemporalExtentIndexes = createSelector(\n  [getHighlightTemporalExtent],\n  (highlightTemporalExtent) => {\n    if (\n      highlightTemporalExtent === undefined ||\n      highlightTemporalExtent === null ||\n      !highlightTemporalExtent.length\n    ) {\n      return null\n    }\n    const startTimestamp = highlightTemporalExtent[0].getTime()\n    const endTimestamp = highlightTemporalExtent[1].getTime()\n    const startIndex = convert.getOffsetedTimeAtPrecision(startTimestamp)\n    const endIndex = convert.getOffsetedTimeAtPrecision(endTimestamp)\n    return [startIndex, endIndex]\n  }\n)\n\nconst mapStateToProps = (state) => ({\n  highlightedVessels: state.map.heatmap.highlightedVessels,\n  highlightedClickedVessel: state.map.heatmap.highlightedClickedVessel,\n  viewport: state.map.viewport.viewport,\n  zoom: state.map.viewport.viewport.zoom,\n  heatmapLayers: getHeatmapLayersAsArray(state),\n  tracks: getTracksWithData(state),\n  leftWorldScaled: state.map.viewport.leftWorldScaled,\n  rightWorldScaled: state.map.viewport.rightWorldScaled,\n  temporalExtentIndexes: getTemporalExtentIndexes(state),\n  highlightTemporalExtentIndexes: getHighlightTemporalExtentIndexes(state),\n})\n\nconst mapDispatchToProps = (dispatch, ownProps) => ({\n  queryHeatmapVessels: (coords, temporalExtentIndexes) => {\n    dispatch(queryHeatmapVessels(coords, temporalExtentIndexes))\n  },\n  exportNativeViewport: (viewport) => {\n    dispatch(exportNativeViewport(viewport))\n  },\n})\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(ActivityLayers)\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport MapGL, { Popup } from 'react-map-gl'\nimport 'mapbox-gl/dist/mapbox-gl.css'\nimport { TILES_URL_NEEDING_AUTHENTICATION } from '../config'\nimport ActivityLayers from '../activity/ActivityLayers.container.js'\nimport styles from './map.css'\n\nconst PopupWrapper = (props) => {\n  const { latitude, longitude, children, closeButton, onClose } = props\n  return (\n    <Popup\n      latitude={latitude}\n      longitude={longitude}\n      closeButton={closeButton}\n      onClose={onClose}\n      anchor=\"bottom\"\n      offsetTop={-10}\n      tipSize={4}\n      closeOnClick={false}\n    >\n      {children}\n    </Popup>\n  )\n}\n\nPopupWrapper.propTypes = {\n  latitude: PropTypes.string.isRequired,\n  longitude: PropTypes.string.isRequired,\n  children: PropTypes.node.isRequired,\n  closeButton: PropTypes.bool.isRequired,\n  onClose: PropTypes.func.isRequired,\n}\n\nclass Map extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      mouseOver: true,\n    }\n    this._mapContainerRef = null\n  }\n  componentDidMount() {\n    window.addEventListener('resize', this._resize)\n    this._resize()\n\n    // useful with FOUC\n    window.setTimeout(() => this._resize(), 1)\n\n    // there is a problem with the container width computation (only with \"fat scrollbar\" browser/os configs),\n    // seems like the panels with scrollbars are taken into account or smth\n    window.setTimeout(() => this._resize(), 10000)\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('resize', this._resize)\n  }\n\n  _resize = () => {\n    if (this._mapContainerRef === null) {\n      console.warn('Cant set viewport on a map that hasnt finished intanciating yet')\n      return\n    }\n    const mapContainerStyle = window.getComputedStyle(this._mapContainerRef)\n    const width = parseInt(mapContainerStyle.width, 10)\n    const height = parseInt(mapContainerStyle.height, 10) + 1\n\n    if (width !== this.props.viewport.width || height !== this.props.viewport.height) {\n      this.props.setViewport({\n        ...this.props.viewport,\n        width,\n        height,\n      })\n    }\n  }\n\n  onViewportChange = (viewport) => {\n    this.props.setViewport(viewport)\n  }\n\n  onMapInteraction = (event, type) => {\n    // console.log(type, event, event.features)\n    const callback = type === 'hover' ? this.props.mapHover : this.props.mapClick\n    if (this.glMap !== undefined && event.features !== undefined && event.features.length) {\n      const feature = event.features[0]\n      if (feature.properties.cluster === true) {\n        const clusterId = feature.properties.cluster_id\n        const sourceId = feature.source\n        const glSource = this.glMap.getSource(sourceId)\n        glSource.getClusterExpansionZoom(clusterId, (err1, zoom) => {\n          glSource.getClusterLeaves(clusterId, 99, 0, (err2, children) => {\n            if (err1 || err2) {\n              return\n            }\n            callback(event.lngLat[1], event.lngLat[0], event.features, {\n              zoom,\n              children,\n            })\n          })\n        })\n        return\n      }\n    }\n    callback(event.lngLat[1], event.lngLat[0], event.features)\n  }\n\n  onHover = (event) => {\n    this.onMapInteraction(event, 'hover')\n  }\n\n  onClick = (event) => {\n    this.onMapInteraction(event, 'click')\n  }\n\n  getRef = (ref) => {\n    if (ref !== null) {\n      this.glMap = ref.getMap()\n    }\n  }\n\n  getCursor = ({ isDragging }) => {\n    const { cursor } = this.props\n    if (cursor === null) {\n      return isDragging ? 'grabbing' : 'grab'\n    }\n    return cursor\n  }\n\n  transformRequest = (url, resourceType) => {\n    const { token } = this.props\n    if (token !== null && resourceType === 'Tile' && url.match(TILES_URL_NEEDING_AUTHENTICATION)) {\n      return {\n        url: url,\n        headers: { Authorization: 'Bearer ' + token },\n      }\n    }\n  }\n\n  render() {\n    const {\n      viewport,\n      maxZoom,\n      minZoom,\n      transitionEnd,\n      mapStyle,\n      onClosePopup,\n      clickPopup,\n      hoverPopup,\n      interactiveLayerIds,\n    } = this.props\n    return (\n      <div\n        id=\"map\"\n        className={styles.map}\n        ref={(ref) => {\n          this._mapContainerRef = ref\n        }}\n        onMouseLeave={() => {\n          this.setState({ mouseOver: false })\n        }}\n        onMouseEnter={() => {\n          this.setState({ mouseOver: true })\n        }}\n      >\n        <MapGL\n          ref={this.getRef}\n          transformRequest={this.transformRequest}\n          onTransitionEnd={transitionEnd}\n          onHover={this.onHover}\n          onClick={this.onClick}\n          getCursor={this.getCursor}\n          mapStyle={mapStyle}\n          {...viewport}\n          maxZoom={maxZoom}\n          minZoom={minZoom}\n          onViewportChange={this.onViewportChange}\n          interactiveLayerIds={interactiveLayerIds}\n        >\n          <ActivityLayers />\n          {clickPopup !== undefined && clickPopup !== null && (\n            <PopupWrapper\n              latitude={clickPopup.latitude}\n              longitude={clickPopup.longitude}\n              closeButton\n              onClose={onClosePopup}\n            >\n              {clickPopup.content}\n            </PopupWrapper>\n          )}\n          {this.state.mouseOver === true && hoverPopup !== undefined && hoverPopup !== null && (\n            <PopupWrapper\n              latitude={hoverPopup.latitude}\n              longitude={hoverPopup.longitude}\n              closeButton={false}\n            >\n              {hoverPopup.content}\n            </PopupWrapper>\n          )}\n        </MapGL>\n        <div className={styles.googleLogo} />\n      </div>\n    )\n  }\n}\n\nMap.propTypes = {\n  token: PropTypes.string,\n  viewport: PropTypes.object.isRequired,\n  mapStyle: PropTypes.object.isRequired,\n  clickPopup: PropTypes.object,\n  hoverPopup: PropTypes.object,\n  maxZoom: PropTypes.number.isRequired,\n  minZoom: PropTypes.number.isRequired,\n  setViewport: PropTypes.func.isRequired,\n  mapHover: PropTypes.func,\n  mapClick: PropTypes.func,\n  onClosePopup: PropTypes.func,\n  transitionEnd: PropTypes.func,\n  cursor: PropTypes.string,\n  interactiveLayerIds: PropTypes.arrayOf(PropTypes.string),\n}\n\nMap.defaultProps = {\n  token: null,\n  clickPopup: null,\n  hoverPopup: null,\n  mapHover: () => {},\n  mapClick: () => {},\n  onClosePopup: () => {},\n  transitionEnd: () => {},\n  cursor: null,\n  interactiveLayerIds: null,\n}\n\nexport default Map\n","import { connect } from 'react-redux'\nimport { createSelector } from 'reselect'\nimport { fromJS } from 'immutable'\nimport { TRACKS_LAYER_IN_FRONT_OF_GROUP } from '../config'\nimport { closePopup } from '../module/module.actions.js'\nimport { getTracksStyles } from '../tracks/tracks.selectors.js'\nimport { mapHover, mapClick } from './interaction.actions.js'\nimport { setViewport, transitionEnd } from './viewport.actions.js'\nimport Map from './Map'\n\nconst getStaticLayers = (state) => state.map.style.staticLayers\n\nconst getInteractiveLayerIds = createSelector(\n  [getStaticLayers],\n  // Note: here we assume that layer IDs provided with module match the GL layers that should\n  // be interactive or not, ie typically the fill layer if a label layer is present\n  (staticLayers) =>\n    staticLayers.filter((l) => l.interactive === true && l.visible === true).map((l) => l.id)\n)\n\nconst getMapStyles = (state) => state.map.style.mapStyle\nconst getMapStyle = createSelector(\n  [getMapStyles, getTracksStyles],\n  (mapStyles, trackStyles) => {\n    if (!trackStyles) return mapStyles\n\n    const currentLayerGroups = mapStyles\n      .toJS()\n      .layers.filter((l) => l.metadata !== undefined)\n      .map((l) => l.metadata['mapbox:group'])\n    const trackLayersIndex = currentLayerGroups.lastIndexOf(TRACKS_LAYER_IN_FRONT_OF_GROUP) + 1\n\n    let finalMapStyles = mapStyles.mergeIn(['sources'], trackStyles.sources)\n    let mapStylesLayers = mapStyles.get('layers')\n    trackStyles.layers.forEach((trackLayer, i) => {\n      mapStylesLayers = mapStylesLayers.insert(trackLayersIndex + i, fromJS(trackLayer))\n    })\n    finalMapStyles = finalMapStyles.set('layers', mapStylesLayers)\n\n    return finalMapStyles\n  }\n)\n\nconst mapStateToProps = (state, ownProps) => ({\n  viewport: state.map.viewport.viewport,\n  maxZoom: state.map.viewport.maxZoom,\n  minZoom: state.map.viewport.minZoom,\n  cursor: state.map.interaction.cursor,\n  token: state.map.module.token,\n  mapStyle: getMapStyle(state),\n  interactiveLayerIds: getInteractiveLayerIds(state),\n})\n\nconst mapDispatchToProps = (dispatch) => ({\n  setViewport: (viewport) => {\n    dispatch(setViewport(viewport))\n  },\n  mapHover: (lat, long, features, cluster) => {\n    dispatch(mapHover(lat, long, features, cluster))\n  },\n  mapClick: (lat, long, features, cluster) => {\n    dispatch(mapClick(lat, long, features, cluster))\n  },\n  transitionEnd: () => {\n    dispatch(transitionEnd())\n  },\n  onClosePopup: () => {\n    dispatch(closePopup())\n  },\n})\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(Map)\n","// This utility looks at GeoJSON features and returns the predominant geometry type\n\nconst TYPES = [\n  { gl: 'line', geoJSON: ['LineString', 'MultiLineString'] },\n  { gl: 'fill', geoJSON: ['Polygon', 'MultiPolygon'] },\n  { gl: 'circle', geoJSON: ['Point', 'MultiPoint'] },\n]\n\nexport default (geoJSON) => {\n  // collect all geoJSON geom types\n  const allGeoJSONTypes = geoJSON.features.map((feature) => {\n    const geom = feature.geometry\n    if (geom === undefined) {\n      return null\n    }\n    return geom.type\n  })\n\n  // collect number of geometries by GL geom types\n  const numByGLType = TYPES.map((type) => {\n    let num = 0\n    allGeoJSONTypes.forEach((geoJSONType) => {\n      if (type.geoJSON.indexOf(geoJSONType) > -1) {\n        num++\n      }\n    })\n    return { gl: type.gl, num }\n  })\n\n  // get feature types with the higher count\n  let glType = 'fill'\n  let glTypeMax = 0\n  numByGLType.forEach((t) => {\n    if (t.num > glTypeMax) {\n      glType = t.gl\n      glTypeMax = t.num\n    }\n  })\n\n  return glType\n}\n","import { fromJS } from 'immutable'\nimport { hexToRgb } from '../utils/map-colors'\nimport uniq from 'lodash/uniq'\nimport { STATIC_LAYERS_CARTO_ENDPOINT, STATIC_LAYERS_CARTO_TILES_ENDPOINT } from '../config'\nimport { CUSTOM_LAYERS_SUBTYPES, GL_TRANSPARENT } from '../constants'\nimport GL_STYLE from './gl-styles/style.json'\nimport getMainGeomType from '../utils/getMainGeomType'\n\nexport const INIT_MAP_STYLE = 'INIT_MAP_STYLE'\nexport const SET_MAP_STYLE = 'SET_MAP_STYLE'\nexport const MARK_CARTO_LAYERS_AS_INSTANCIATED = 'MARK_CARTO_LAYERS_AS_INSTANCIATED'\nexport const SET_STATIC_LAYERS = 'SET_STATIC_LAYERS'\nexport const SET_BASEMAP_LAYERS = 'SET_BASEMAP_LAYERS'\n\nexport const initStyle = ({ glyphsPath }) => ({\n  type: INIT_MAP_STYLE,\n  payload: {\n    glyphsPath,\n  },\n})\n\nconst setMapStyle = (style) => ({\n  type: SET_MAP_STYLE,\n  payload: style,\n})\n\nexport const applyTemporalExtent = (temporalExtent) => (dispatch, getState) => {\n  const state = getState().map.style\n  let style = state.mapStyle\n  const currentStyle = style.toJS()\n  const glLayers = currentStyle.layers\n\n  const start = Math.round(temporalExtent[0].getTime() / 1000)\n  const end = Math.round(temporalExtent[1].getTime() / 1000)\n\n  for (let i = 0; i < glLayers.length; i++) {\n    const glLayer = glLayers[i]\n    if (glLayer.metadata === undefined || glLayer.metadata['gfw:temporal'] !== true) {\n      continue\n    }\n\n    // if layer is temporal, a filter must always be preset on the style.json object\n    // because each layer can have a different time field to be filtered\n    const currentFilter = style.getIn(['layers', i, 'filter']).toJS()\n    if (currentFilter === null) {\n      throw new Error('filter must be preset on style.json for temporal layer: ', glLayer.id)\n    }\n    currentFilter[1][2] = start\n    currentFilter[2][2] = end\n    style = style.setIn(['layers', i, 'filter'], fromJS(currentFilter))\n  }\n  dispatch(setMapStyle(style))\n}\n\nconst applyLayerExpressions = (style, refLayer, currentGlLayer, glLayerIndex) => {\n  let newStyle = style\n  const currentStyle = style.toJS()\n  const glType = currentGlLayer.type\n  const defaultStyles = currentStyle.metadata['gfw:styles']\n  const metadata = currentGlLayer.metadata\n  ;['selected', 'highlighted'].forEach((styleType) => {\n    // get selectedFeatures or highlightedFeatures\n    const features = refLayer[`${styleType}Features`]\n    const hasFeatures = features !== null && features !== undefined && features.values.length > 0\n    const applyStyleToAllFeatures = refLayer[styleType]\n\n    const defaultStyle = defaultStyles[styleType][glType] || {}\n    const layerStyle =\n      (metadata && metadata['gfw:styles'] && metadata['gfw:styles'][styleType]) || {}\n    const allPaintProperties = { ...defaultStyle, ...layerStyle }\n    if (Object.keys(allPaintProperties).length) {\n      // go through each applicable gl paint property\n      Object.keys(allPaintProperties).forEach((glPaintProperty) => {\n        const selectedValue = allPaintProperties[glPaintProperty][0]\n        const fallbackValue = allPaintProperties[glPaintProperty][1]\n        const paintOrLayout = ['icon-size', 'icon-image'].includes(glPaintProperty)\n          ? 'layout'\n          : 'paint'\n        let glPaintFinalValue\n        if (\n          hasFeatures === false &&\n          applyStyleToAllFeatures !== true &&\n          applyStyleToAllFeatures !== false\n        ) {\n          // style reset when no features filter is declared and neither is applyAll\n          const originalLayerStyle = GL_STYLE.layers.find((l) => l.id === currentGlLayer.id)\n          glPaintFinalValue = originalLayerStyle[paintOrLayout][glPaintProperty]\n        } else if (applyStyleToAllFeatures === true || applyStyleToAllFeatures === false) {\n          glPaintFinalValue = applyStyleToAllFeatures === true ? selectedValue : fallbackValue\n        } else {\n          let layerColorRgbString = ''\n          if (refLayer.color !== null && refLayer.color !== undefined) {\n            const layerColorRgb = hexToRgb(refLayer.color)\n            layerColorRgbString = `${layerColorRgb.r},${layerColorRgb.g},${layerColorRgb.b}`\n          }\n          glPaintFinalValue = [\n            'match',\n            ['get', features.field],\n            features.values,\n            typeof selectedValue !== 'string'\n              ? selectedValue\n              : selectedValue.replace('$REFLAYER_COLOR_RGB', layerColorRgbString),\n            typeof fallbackValue !== 'string'\n              ? fallbackValue\n              : fallbackValue.replace('$REFLAYER_COLOR_RGB', layerColorRgbString),\n          ]\n        }\n\n        if (glPaintFinalValue !== undefined) {\n          newStyle = newStyle.setIn(\n            ['layers', glLayerIndex, paintOrLayout, glPaintProperty],\n            glPaintFinalValue\n          )\n        }\n      })\n    }\n  })\n  return newStyle\n}\n\nconst toggleLayerVisibility = (style, refLayer, glLayerIndex) => {\n  const visibility = refLayer.visible === true ? 'visible' : 'none'\n  return style.setIn(['layers', glLayerIndex, 'layout', 'visibility'], visibility)\n}\n\nconst updateGLLayer = (style, glLayerId, refLayer) => {\n  const currentStyle = style.toJS()\n  const currentStyleLayers = currentStyle.layers\n  let newStyle = style\n\n  const glLayerIndex = currentStyleLayers.findIndex((l) => l.id === glLayerId)\n  const glLayer = currentStyleLayers.find((l) => l.id === glLayerId)\n\n  // visibility\n  newStyle = toggleLayerVisibility(newStyle, refLayer, glLayerIndex)\n\n  if (refLayer.isBasemap === true) {\n    return newStyle\n  }\n\n  const initialGLLayer = GL_STYLE.layers.find((l) => l.id === glLayerId)\n  const refLayerOpacity = refLayer.opacity === undefined ? 1 : refLayer.opacity\n\n  // color/opacity\n  switch (glLayer.type) {\n    case 'fill': {\n      newStyle = newStyle\n        .setIn(['layers', glLayerIndex, 'paint', 'fill-opacity'], refLayerOpacity)\n        .setIn(['layers', glLayerIndex, 'paint', 'fill-outline-color'], refLayer.color)\n        .setIn(['layers', glLayerIndex, 'paint', 'fill-color'], GL_TRANSPARENT)\n      break\n    }\n    case 'line': {\n      newStyle = newStyle\n        .setIn(['layers', glLayerIndex, 'paint', 'line-opacity'], refLayerOpacity)\n        .setIn(['layers', glLayerIndex, 'paint', 'line-color'], refLayer.color)\n      break\n    }\n    case 'symbol': {\n      if (glLayer.metadata && glLayer.metadata['gfw:isLabel'] === true) {\n        const parentLayerIsVisible =\n          newStyle.getIn(['layers', glLayerIndex, 'layout', 'visibility']) === 'visible'\n        const labelsVisibility =\n          parentLayerIsVisible && refLayer.showLabels === true ? 'visible' : 'none'\n        newStyle = newStyle.setIn(\n          ['layers', glLayerIndex, 'layout', 'visibility'],\n          labelsVisibility\n        )\n        if (refLayer.showLabels !== true) {\n          break\n        }\n      }\n      newStyle = newStyle.setIn(['layers', glLayerIndex, 'paint', 'text-opacity'], refLayerOpacity)\n\n      if (refLayer.color !== undefined) {\n        newStyle = newStyle.setIn(['layers', glLayerIndex, 'paint', 'text-color'], refLayer.color)\n      }\n      break\n    }\n    // Event layers and custom layers with point geom types\n    case 'circle': {\n      newStyle = newStyle\n        .setIn(['layers', glLayerIndex, 'paint', 'circle-opacity'], refLayerOpacity)\n        .setIn(\n          ['layers', glLayerIndex, 'paint', 'circle-radius'],\n          initialGLLayer.paint['circle-radius']\n        )\n        .setIn(\n          ['layers', glLayerIndex, 'paint', 'circle-stroke-color'],\n          initialGLLayer.paint['circle-stroke-color'] || '#000'\n        )\n        .setIn(\n          ['layers', glLayerIndex, 'paint', 'circle-stroke-width'],\n          initialGLLayer.paint['circle-stroke-width'] || 1\n        )\n\n      if (refLayer.color !== undefined) {\n        newStyle = newStyle.setIn(['layers', glLayerIndex, 'paint', 'circle-color'], refLayer.color)\n      }\n      break\n    }\n    case 'raster': {\n      newStyle = newStyle.setIn(\n        ['layers', glLayerIndex, 'paint', 'raster-opacity'],\n        refLayerOpacity\n      )\n      break\n    }\n    default: {\n      break\n    }\n  }\n\n  newStyle = applyLayerExpressions(newStyle, refLayer, glLayer, glLayerIndex)\n\n  return newStyle\n}\n\nconst addCustomGLLayer = (subtype, layerId, url, data) => (dispatch, getState) => {\n  const state = getState()\n  let style = state.map.style.mapStyle\n  const currentStyle = style.toJS()\n\n  // add source if it doesn't exist yet\n  if (currentStyle.sources[layerId] === undefined) {\n    const source = { type: subtype }\n    if (subtype === CUSTOM_LAYERS_SUBTYPES.geojson) {\n      source.data = data\n    } else if (subtype === CUSTOM_LAYERS_SUBTYPES.raster) {\n      source.tiles = [url]\n      source.tileSize = 256\n    }\n    style = style.setIn(['sources', layerId], fromJS(source))\n  }\n\n  if (currentStyle.layers.find((glLayer) => glLayer.id === layerId) === undefined) {\n    const glType = subtype === CUSTOM_LAYERS_SUBTYPES.geojson ? getMainGeomType(data) : subtype\n    const glLayer = fromJS({\n      id: layerId,\n      source: layerId,\n      type: glType,\n      layout: {},\n      paint: {},\n    })\n    const layerIndex =\n      subtype === CUSTOM_LAYERS_SUBTYPES.raster\n        ? // if raster, put at index of last raster layer except labels\n          currentStyle.layers.length -\n          1 -\n          currentStyle.layers\n            .filter((l) => l.id !== 'labels')\n            .reverse()\n            .findIndex((l) => l.type === 'raster')\n        : currentStyle.layers.length - 1\n    style = style.set('layers', style.get('layers').splice(layerIndex, 0, glLayer))\n  }\n\n  dispatch(setMapStyle(style))\n}\n\nconst addWorkspaceGLLayers = (workspaceGLLayers) => (dispatch, getState) => {\n  const state = getState()\n  let style = state.map.style.mapStyle\n\n  workspaceGLLayers.forEach((workspaceGLLayer) => {\n    const id = workspaceGLLayer.id\n    const gl = workspaceGLLayer.gl\n    const finalSource = fromJS(gl.source)\n    style = style.setIn(['sources', id], finalSource)\n\n    const layers = []\n    gl.layers.forEach((srcGlLayer) => {\n      const glLayer = {\n        ...srcGlLayer,\n        source: id,\n        'source-layer': id,\n      }\n      layers.push(glLayer)\n    })\n\n    const finalLayers = fromJS(layers)\n    style = style.set('layers', style.get('layers').concat(finalLayers))\n  })\n\n  dispatch(setMapStyle(style))\n\n  // TODO MAP MODULE\n  // dispatch(updateMapStyle());\n}\n\nconst getCartoLayerInstanciatePromise = ({ sourceId, sourceCartoSQL }) => {\n  const mapConfig = { layers: [{ id: sourceId, options: { sql: sourceCartoSQL } }] }\n  const mapConfigURL = encodeURIComponent(JSON.stringify(mapConfig))\n  const cartoAnonymousMapUrl = STATIC_LAYERS_CARTO_ENDPOINT.replace('$MAPCONFIG', mapConfigURL)\n\n  return new Promise((resolve) => {\n    fetch(cartoAnonymousMapUrl)\n      .then((res) => {\n        if (res.status >= 400) {\n          console.warn(`loading of layer failed ${sourceId}`)\n          Promise.reject()\n          return null\n        }\n        return res.json()\n      })\n      .then((data) => {\n        resolve({\n          layergroupid: data.layergroupid,\n          sourceId,\n        })\n      })\n      .catch((err) => {\n        console.warn(err)\n      })\n  })\n}\n\nconst instanciateCartoLayers = (layers) => (dispatch, getState) => {\n  dispatch({\n    type: MARK_CARTO_LAYERS_AS_INSTANCIATED,\n    payload: layers.map((layer) => layer.sourceId),\n  })\n  const cartoLayersPromises = layers.map((layer) => getCartoLayerInstanciatePromise(layer))\n  const cartoLayersPromisesPromise = Promise.all(cartoLayersPromises.map((p) => p.catch((e) => e)))\n  cartoLayersPromisesPromise\n    .then((instanciatedCartoLayers) => {\n      let style = getState().map.style.mapStyle\n      const currentStyle = style.toJS()\n      instanciatedCartoLayers.forEach((cartoLayer) => {\n        const tilesURL = STATIC_LAYERS_CARTO_TILES_ENDPOINT.replace(\n          '$LAYERGROUPID',\n          cartoLayer.layergroupid\n        )\n\n        // replace gl source with a new source that use tiles provided by Carto anonymous maps API\n        const newSourceId = `${cartoLayer.sourceId}-instanciated`\n        style = style.setIn(\n          ['sources', newSourceId],\n          fromJS({\n            type: 'vector',\n            tiles: [tilesURL],\n          })\n        )\n\n        // change source in all layers that are using it (genrally polygon + labels)\n        currentStyle.layers.forEach((glLayer, glLayerIndex) => {\n          if (glLayer.source === cartoLayer.sourceId) {\n            style = style.setIn(['layers', glLayerIndex, 'source'], newSourceId)\n            style = style.setIn(['layers', glLayerIndex, 'metadata', 'gfw:id'], cartoLayer.sourceId)\n            const refLayer = layers.find((l) => l.refLayer.id === cartoLayer.sourceId).refLayer\n            style = updateGLLayer(style, glLayer.id, refLayer)\n          }\n        })\n      })\n\n      dispatch(setMapStyle(style))\n    })\n    .catch((err) => {\n      console.warn(err)\n    })\n}\n\nexport const commitStyleUpdates = (staticLayers, basemapLayers) => (dispatch, getState) => {\n  // Store a copy of static and basemap layers. This is not used directly by\n  // the Map component which only needs a prepared style object\n  dispatch({\n    type: SET_STATIC_LAYERS,\n    payload: staticLayers,\n  })\n  dispatch({\n    type: SET_BASEMAP_LAYERS,\n    payload: basemapLayers,\n  })\n\n  const layers = [...staticLayers, ...basemapLayers.map((bl) => ({ ...bl, isBasemap: true }))]\n\n  const currentGLSources = getState().map.style.mapStyle.toJS().sources\n\n  // collect layers declared in workspace but not in original gl style\n  const workspaceGLLayers = layers.filter(\n    (layer) => layer.gl !== undefined && currentGLSources[layer.id] === undefined\n  )\n  if (workspaceGLLayers.length) {\n    dispatch(addWorkspaceGLLayers(workspaceGLLayers))\n  }\n\n  // instanciate custom layers if needed\n  const customLayers = layers.filter(\n    (layer) => layer.isCustom === true && currentGLSources[layer.id] === undefined\n  )\n  if (customLayers.length) {\n    customLayers.forEach((layer) => {\n      dispatch(addCustomGLLayer(layer.subtype, layer.id, layer.url, layer.data))\n    })\n  }\n\n  const state = getState().map.style\n  let style = state.mapStyle\n  const currentStyle = style.toJS()\n  const glLayers = currentStyle.layers\n  const glSources = currentStyle.sources\n\n  const cartoLayersToInstanciate = []\n\n  // update source when needed\n  staticLayers.forEach((refLayer) => {\n    const sourceId = refLayer.id\n    if (currentGLSources[sourceId] !== undefined) {\n      if (refLayer.data !== undefined) {\n        style = style.setIn(['sources', sourceId, 'data'], fromJS(refLayer.data))\n      }\n      if (refLayer.url !== undefined) {\n        const { tiles } = currentGLSources[sourceId]\n        // Using default tiles url as a fallback\n        const newTiles =\n          tiles !== undefined && tiles.length > 0 ? uniq([refLayer.url, ...tiles]) : [refLayer.url]\n        style = style.setIn(['sources', sourceId, 'tiles'], fromJS(newTiles))\n      }\n    }\n  })\n\n  for (let i = 0; i < glLayers.length; i++) {\n    const glLayer = glLayers[i]\n    const sourceId = glLayer.source\n    const glSource = glSources[sourceId]\n    const layerId = (glLayer.metadata !== undefined && glLayer.metadata['gfw:id']) || sourceId\n\n    const refLayer = layers.find((l) => l.id === layerId)\n\n    if (refLayer === undefined) {\n      if (glLayer.type !== 'background') {\n        // console.warn('gl layer does not exists in workspace', glLayer);\n      }\n      continue\n    }\n\n    // check if layer is served from Carto, which means we need to instanciate it first\n    // TODO BUG: check if layer is not instanciatING too\n    const sourceCartoSQL = glSource.metadata !== undefined && glSource.metadata['gfw:carto-sql']\n    if (sourceCartoSQL !== false && sourceCartoSQL !== undefined) {\n      // only if layer is visible and has not been instanciated yet\n      const cartoLayerInstanciated = state.cartoLayersInstanciated.indexOf(sourceId) > -1\n      if (\n        refLayer.visible === true &&\n        !cartoLayerInstanciated &&\n        !cartoLayersToInstanciate.find((l) => l.sourceId === sourceId)\n      ) {\n        cartoLayersToInstanciate.push({ sourceId, sourceCartoSQL, refLayer })\n      }\n      continue\n    }\n\n    style = updateGLLayer(style, glLayer.id, refLayer)\n  }\n\n  if (cartoLayersToInstanciate.length) {\n    dispatch(instanciateCartoLayers(cartoLayersToInstanciate))\n  }\n\n  dispatch(setMapStyle(style))\n}\n","import tbbox from '@turf/bbox'\nimport { targetMapVessel } from '../map'\n\nimport {\n  getTilePromises,\n  getCleanVectorArrays,\n  groupData,\n  addTracksPointsRenderingData,\n  getTracksPlaybackData,\n} from '../utils/heatmapTileData'\nimport { startLoader, completeLoader } from '../module/module.actions'\n\nexport const ADD_TRACK = 'ADD_TRACK'\nexport const UPDATE_TRACK = 'UPDATE_TRACK'\nexport const REMOVE_TRACK = 'REMOVE_TRACK'\n\nconst getTrackDataParsed = (geojson) => {\n  const time = { start: Infinity, end: 0 }\n  if (geojson && geojson.features) {\n    geojson.features.forEach((feature) => {\n      const hasTimes =\n        feature.properties.coordinateProperties.times &&\n        feature.properties.coordinateProperties.times.length > 0\n      if (hasTimes) {\n        feature.properties.coordinateProperties.times.forEach((datetime) => {\n          if (datetime < time.start) {\n            time.start = datetime\n          } else if (datetime > time.end) {\n            time.end = datetime\n          }\n        })\n      }\n    })\n  }\n  return {\n    geojson,\n    timelineBounds: [time.start, time.end],\n  }\n}\n\nconst getTrackBounds = (geojson) => {\n  const bounds = tbbox(geojson)\n  return {\n    minLat: bounds[3],\n    minLng: bounds[0],\n    maxLat: bounds[1],\n    maxLng: bounds[2],\n  }\n}\n\n// Deprecated tracks format parsing\nconst getOldTrackBoundsFormat = (data, addOffset = false) => {\n  const time = {\n    start: Infinity,\n    end: 0,\n  }\n  const geo = {\n    minLat: Infinity,\n    maxLat: -Infinity,\n    minLng: Infinity,\n    maxLng: -Infinity,\n  }\n  for (let i = 0, length = data.datetime.length; i < length; i++) {\n    const datetime = data.datetime[i]\n    if (datetime < time.start) {\n      time.start = datetime\n    } else if (datetime > time.end) {\n      time.end = datetime\n    }\n\n    const lat = data.latitude[i]\n    if (lat < geo.minLat) {\n      geo.minLat = lat\n    } else if (lat > geo.maxLat) {\n      geo.maxLat = lat\n    }\n\n    let lng = data.longitude[i]\n    if (addOffset === true) {\n      if (lng < 0) {\n        lng += 360\n      }\n    }\n    if (lng < geo.minLng) {\n      geo.minLng = lng\n    } else if (lng > geo.maxLng) {\n      geo.maxLng = lng\n    }\n  }\n\n  // track crosses the antimeridian\n  if (geo.maxLng - geo.minLng > 350 && addOffset === false) {\n    return getOldTrackBoundsFormat(data, true)\n  }\n\n  return {\n    time: [time.start, time.end],\n    geo,\n  }\n}\n\nfunction loadTrack(track) {\n  return (dispatch, getState) => {\n    const { id, url, type, fitBoundsOnLoad, layerTemporalExtents, color, data } = track\n    const state = getState()\n    if (state.map.tracks.data.find((t) => t.id === id)) {\n      return\n    }\n\n    const payload = {\n      id,\n      url,\n      type,\n      color,\n      fitBoundsOnLoad,\n    }\n    const trackHasData = track.data !== undefined && track.data !== null\n    const trackHasUrl = url !== undefined && url !== null && url !== ''\n    if (trackHasData) {\n      payload.data = data\n      payload.geoBounds = getTrackBounds(data)\n    }\n    dispatch({ type: ADD_TRACK, payload })\n\n    if (trackHasData || !trackHasUrl) {\n      return\n    }\n\n    const loaderID = startLoader(dispatch, state)\n    if (type !== 'geojson') {\n      // Deprecated tracks format logic to be deleted some day\n      const token = state.map.module.token\n      const promises = getTilePromises(url, token, layerTemporalExtents, { seriesgroup: id })\n\n      Promise.all(promises.map((p) => p.catch((e) => e))).then((rawTileData) => {\n        const cleanData = getCleanVectorArrays(rawTileData)\n\n        if (!cleanData.length) {\n          return\n        }\n        const rawTrackData = groupData(cleanData, [\n          'latitude',\n          'longitude',\n          'datetime',\n          'series',\n          'weight',\n          'sigma',\n        ])\n\n        const vectorArray = addTracksPointsRenderingData(rawTrackData)\n        const bounds = getOldTrackBoundsFormat(rawTrackData)\n\n        dispatch({\n          type: UPDATE_TRACK,\n          payload: {\n            id,\n            data: getTracksPlaybackData(vectorArray),\n            geoBounds: bounds.geo,\n            timelineBounds: bounds.time,\n          },\n        })\n        dispatch(completeLoader(loaderID))\n      })\n    } else {\n      fetch(url)\n        .then((res) => {\n          if (res.status >= 400) throw new Error(res.statusText)\n          return res.json()\n        })\n        .then((data) => {\n          const { geojson, timelineBounds } = getTrackDataParsed(data)\n          const geoBounds = getTrackBounds(data)\n          dispatch({\n            type: UPDATE_TRACK,\n            payload: {\n              id,\n              data: geojson,\n              geoBounds,\n              timelineBounds,\n            },\n          })\n          if (fitBoundsOnLoad) {\n            targetMapVessel(id)\n          }\n        })\n        .catch((err) => console.warn(err))\n        .finally(() => dispatch(completeLoader(loaderID)))\n    }\n  }\n}\n\nconst removeTrack = (trackId) => ({\n  type: REMOVE_TRACK,\n  payload: {\n    trackId,\n  },\n})\n\nexport const updateTracks = (newTracks = []) => (dispatch, getState) => {\n  const prevTracks = getState().map.tracks.data\n  // add and update layers\n  if (newTracks) {\n    newTracks.forEach((newTrack) => {\n      const trackId = newTrack.id\n      const prevTrack = prevTracks.find((t) => t.id === trackId)\n      if (prevTrack === undefined) {\n        dispatch(loadTrack(newTrack))\n      } else if (prevTrack.color !== newTrack.color) {\n        dispatch({\n          type: UPDATE_TRACK,\n          payload: {\n            id: newTrack.id,\n            color: newTrack.color,\n          },\n        })\n      }\n    })\n  }\n\n  // clean up unused tracks\n  prevTracks.forEach((prevTrack) => {\n    if (!newTracks || !newTracks.find((t) => t.id === prevTrack.id)) {\n      dispatch(removeTrack(prevTrack.id))\n    }\n  })\n}\n","import PropTypes from 'prop-types'\n\nconst withReducerPropTypes = (name, propTypesSchema) => (reducer) => {\n  if (process.env.NODE_ENV === 'development') {\n    return (state, action) => {\n      const result = reducer(state, action)\n      PropTypes.checkPropTypes(propTypesSchema, result, 'reducer', name)\n\n      return result\n    }\n  }\n  return reducer\n}\n\nexport default withReducerPropTypes\n","import PropTypes from 'prop-types'\nimport withReducerTypes from '../utils/withReducerTypes'\nimport {\n  INIT_MODULE,\n  SET_TEMPORAL_EXTENT,\n  SET_HIGHLIGHT_TEMPORAL_EXTENT,\n  START_LOADER,\n  COMPLETE_LOADER,\n} from './module.actions'\n\nconst initialState = {\n  loaders: null,\n  token: undefined,\n  temporalExtent: [new Date(1970), new Date()],\n  highlightTemporalExtent: null,\n  onViewportChange: undefined,\n  onHover: undefined,\n  onClick: undefined,\n  onLoadStart: undefined,\n  onLoadComplete: undefined,\n  onClosePopup: undefined,\n  onAttributionsChange: undefined,\n}\n\nconst moduleReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case INIT_MODULE: {\n      return {\n        ...state,\n        ...action.payload,\n      }\n    }\n\n    case SET_TEMPORAL_EXTENT: {\n      return {\n        ...state,\n        temporalExtent: action.payload,\n      }\n    }\n\n    case SET_HIGHLIGHT_TEMPORAL_EXTENT: {\n      return {\n        ...state,\n        highlightTemporalExtent: action.payload,\n      }\n    }\n\n    case START_LOADER: {\n      const loaders = state.loaders !== null ? [...state.loaders] : []\n      loaders.push(action.payload)\n      return { ...state, loaders }\n    }\n\n    case COMPLETE_LOADER: {\n      const loaders = [...state.loaders]\n      const loaderIndex = loaders.findIndex((l) => l === action.payload)\n      loaders.splice(loaderIndex, 1)\n      return { ...state, loaders }\n    }\n\n    default:\n      return state\n  }\n}\n\nconst moduleTypes = {\n  loaders: PropTypes.arrayOf(PropTypes.number),\n  token: PropTypes.string,\n  temporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  onViewportChange: PropTypes.func,\n  onHover: PropTypes.func,\n  onClick: PropTypes.func,\n  onLoadStart: PropTypes.func,\n  onLoadComplete: PropTypes.func,\n  onClosePopup: PropTypes.func,\n  onAttributionsChange: PropTypes.func,\n}\n\nexport default withReducerTypes('module', moduleTypes)(moduleReducer)\n","import PropTypes from 'prop-types'\nimport { trackTypes } from '../proptypes/tracks'\nimport withReducerTypes from '../utils/withReducerTypes'\n\nimport { ADD_TRACK, UPDATE_TRACK, REMOVE_TRACK } from './tracks.actions'\n\nconst initialState = {\n  data: [],\n}\n\nconst tracksReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case ADD_TRACK: {\n      const data = [...state.data, action.payload]\n      return { ...state, data }\n    }\n\n    case UPDATE_TRACK: {\n      const trackData = action.payload\n      const data = state.data.map((track) => {\n        if (track.id !== trackData.id) return track\n        return {\n          ...track,\n          ...trackData,\n        }\n      })\n      return { ...state, data }\n    }\n\n    case REMOVE_TRACK: {\n      const removedTrackId = action.payload.trackId\n      const data = state.data.filter((track) => track.id !== removedTrackId)\n      return { ...state, data }\n    }\n\n    default:\n      return state\n  }\n}\n\nconst tracksTypes = {\n  data: PropTypes.arrayOf(\n    PropTypes.exact({\n      ...trackTypes,\n      data: PropTypes.object,\n      timelineBounds: PropTypes.array,\n      geoBounds: PropTypes.exact({\n        minLat: PropTypes.number,\n        minLng: PropTypes.number,\n        maxLat: PropTypes.number,\n        maxLng: PropTypes.number,\n      }),\n    })\n  ),\n}\n\nexport default withReducerTypes('tracks', tracksTypes)(tracksReducer)\n","import uniq from 'lodash/uniq'\nimport {\n  INIT_HEATMAP_LAYERS,\n  UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES,\n  ADD_HEATMAP_LAYER,\n  UPDATE_HEATMAP_LAYER_STYLE,\n  REMOVE_HEATMAP_LAYER,\n  ADD_REFERENCE_TILE,\n  UPDATE_HEATMAP_TILE,\n  RELEASE_HEATMAP_TILES,\n  HIGHLIGHT_VESSELS,\n  UPDATE_LOADED_TILES,\n  HIGHLIGHT_CLICKED_VESSEL,\n  CLEAR_HIGHLIGHT_CLICKED_VESSEL,\n} from './heatmap.actions'\n\nconst initialState = {\n  // a dict of heatmap layers (key is layer id)\n  // each containing data, url, tiles, visibleTemporalExtentsIndices\n  heatmapLayers: {},\n  // store a list of tiles currently visible in the map\n  // those are necessary when adding a new layer to know which tiles need to be loaded\n  referenceTiles: [],\n  highlightedVessels: { isEmpty: true },\n  highlightedClickedVessel: null,\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case INIT_HEATMAP_LAYERS: {\n      return Object.assign({}, state, { heatmapLayers: action.payload })\n    }\n\n    case UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES: {\n      const heatmapLayers = state.heatmapLayers\n      let indices = heatmapLayers[action.payload.layerId].visibleTemporalExtentsIndices\n      indices = uniq(indices.concat(action.payload.indicesAdded))\n      heatmapLayers[action.payload.layerId].visibleTemporalExtentsIndices = indices\n      return Object.assign({}, state, heatmapLayers)\n    }\n\n    case ADD_HEATMAP_LAYER: {\n      const heatmapLayers = Object.assign({}, state.heatmapLayers, {\n        [action.payload.id]: {\n          tiles: [],\n          ...action.payload,\n        },\n      })\n      return Object.assign({}, state, { heatmapLayers })\n    }\n\n    case UPDATE_HEATMAP_LAYER_STYLE: {\n      const newLayer = action.payload\n      const layer = { ...state.heatmapLayers[newLayer.id], ...newLayer }\n      const heatmapLayers = { ...state.heatmapLayers, [newLayer.id]: layer }\n      return { ...state, heatmapLayers }\n    }\n\n    case REMOVE_HEATMAP_LAYER: {\n      const heatmapLayers = Object.assign({}, state.heatmapLayers)\n      delete heatmapLayers[action.payload.layerId]\n      return Object.assign({}, state, { heatmapLayers })\n    }\n\n    case ADD_REFERENCE_TILE: {\n      return Object.assign({}, state, { referenceTiles: [...state.referenceTiles, action.payload] })\n    }\n\n    case UPDATE_HEATMAP_TILE: {\n      const layerId = action.payload.layerId\n      const newTile = action.payload.tile\n      const layer = { ...state.heatmapLayers[layerId] }\n      let layerTiles = [...layer.tiles]\n      const tileIndex = layerTiles.findIndex((t) => t.uid === newTile.uid)\n      if (tileIndex === -1) {\n        layerTiles.push(newTile)\n      } else {\n        layerTiles = [layerTiles.slice(0, tileIndex), newTile, layerTiles.slice(tileIndex + 1)]\n      }\n      layer.tiles = layerTiles\n      const heatmapLayers = { ...state.heatmapLayers, [layerId]: layer }\n      return { ...state, heatmapLayers }\n    }\n\n    case RELEASE_HEATMAP_TILES: {\n      const uids = action.payload\n\n      // remove tiles\n      const layerIds = Object.keys(state.heatmapLayers)\n      const heatmapLayers = { ...state.heatmapLayers }\n      layerIds.forEach((layerId) => {\n        const prevLayer = { ...heatmapLayers[layerId] }\n        uids.forEach((tileUid) => {\n          const releasedTileIndex = prevLayer.tiles.findIndex((tile) => tile.uid === tileUid)\n          if (releasedTileIndex > -1) {\n            // console.log('releasing', layerId, tileUid);\n            prevLayer.tiles.splice(releasedTileIndex, 1)\n          }\n        })\n      })\n\n      // remove reference tiles\n      let referenceTiles = [...state.referenceTiles]\n      uids.forEach((tileUid) => {\n        const releasedRefTileIndex = referenceTiles.findIndex((tile) => tile.uid === tileUid)\n        if (releasedRefTileIndex > -1) {\n          referenceTiles = [\n            ...referenceTiles.slice(0, releasedRefTileIndex),\n            ...referenceTiles.slice(releasedRefTileIndex + 1),\n          ]\n        }\n      })\n\n      return { ...state, heatmapLayers, referenceTiles }\n    }\n\n    case UPDATE_LOADED_TILES: {\n      const newHeatmapLayers = { ...state.heatmapLayers }\n      return { ...state, heatmapLayers: newHeatmapLayers }\n    }\n\n    case HIGHLIGHT_VESSELS: {\n      return Object.assign({}, state, { highlightedVessels: action.payload })\n    }\n\n    case HIGHLIGHT_CLICKED_VESSEL: {\n      return { ...state, highlightedClickedVessel: action.payload }\n    }\n\n    case CLEAR_HIGHLIGHT_CLICKED_VESSEL: {\n      return { ...state, highlightedClickedVessel: null }\n    }\n\n    default:\n      return state\n  }\n}\n","import uniq from 'lodash/uniq'\nimport {\n  SET_CURRENTLY_VISIBLE_TILES,\n  SET_CURRENTLY_LOADED_TILES,\n  SET_CURRENTLY_SWAPPED_TILE_UIDS,\n  MARK_TILES_UIDS_AS_LOADED,\n  RELEASE_MARKED_TILES_UIDS,\n} from './heatmapTiles.actions'\n\nconst initialState = {\n  currentVisibleTiles: [],\n  currentLoadedTiles: [],\n  currentToLoadTileUids: [],\n  currentToReleaseTileUids: [],\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case SET_CURRENTLY_VISIBLE_TILES: {\n      const currentVisibleTiles = [].concat(action.payload)\n      return { ...state, currentVisibleTiles }\n    }\n\n    case SET_CURRENTLY_LOADED_TILES: {\n      const currentLoadedTiles = [].concat(action.payload)\n      return { ...state, currentLoadedTiles }\n    }\n\n    case SET_CURRENTLY_SWAPPED_TILE_UIDS: {\n      const currentToLoadTileUids = uniq(\n        state.currentToLoadTileUids.concat(action.payload.tilesToLoadUids)\n      )\n      const currentToReleaseTileUids = uniq(\n        state.currentToReleaseTileUids.concat(action.payload.tilesToReleaseUids)\n      )\n      // clean to load tiles of tiles that needs to be released\n      const newToLoadTilesUids = currentToLoadTileUids.filter(\n        (tileUid) => currentToReleaseTileUids.indexOf(tileUid) === -1\n      )\n      return { ...state, currentToLoadTileUids: newToLoadTilesUids, currentToReleaseTileUids }\n    }\n\n    case MARK_TILES_UIDS_AS_LOADED: {\n      const currentToLoadTileUids = state.currentToLoadTileUids\n      const tileUidsMarkedAsLoaded = action.payload\n      const newCurrentToLoadTileUids = currentToLoadTileUids.filter(\n        (tileUid) => tileUidsMarkedAsLoaded.indexOf(tileUid) === -1\n      )\n      return { ...state, currentToLoadTileUids: newCurrentToLoadTileUids }\n    }\n\n    case RELEASE_MARKED_TILES_UIDS: {\n      return { ...state, currentToReleaseTileUids: [] }\n    }\n\n    default:\n      return state\n  }\n}\n","import { FlyToInterpolator } from 'react-map-gl'\nimport { easeCubic } from 'd3-ease'\nimport { MIN_ZOOM_LEVEL, MAX_ZOOM_LEVEL } from '../config'\nimport { TRANSITION_TYPE } from '../constants'\nimport {\n  SET_VIEWPORT,\n  UPDATE_VIEWPORT,\n  SET_ZOOM_INCREMENT,\n  SET_MOUSE_LAT_LONG,\n  TRANSITION_END,\n  SET_NATIVE_VIEWPORT,\n} from './viewport.actions'\n\nconst DEFAULT_TRANSITION = {\n  transitionDuration: 500,\n  transitionInterpolator: new FlyToInterpolator(),\n  transitionEasing: easeCubic,\n}\n\nconst initialState = {\n  viewport: {\n    latitude: 0,\n    longitude: 0,\n    zoom: 3,\n    bearing: 0,\n    pitch: 0,\n    width: 1000,\n    height: 800,\n  },\n  maxZoom: MAX_ZOOM_LEVEL,\n  minZoom: MIN_ZOOM_LEVEL,\n  prevZoom: 3,\n  currentTransition: null,\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case SET_VIEWPORT: {\n      return {\n        ...state,\n        viewport: action.payload,\n        canZoomIn: action.payload.zoom < state.maxZoom,\n        canZoomOut: action.payload.zoom > state.minZoom,\n        prevZoom: state.viewport.zoom,\n      }\n    }\n\n    case UPDATE_VIEWPORT: {\n      const viewport = { ...state.viewport, ...action.payload }\n      return {\n        ...state,\n        viewport,\n        prevZoom: viewport.zoom,\n      }\n    }\n\n    case SET_ZOOM_INCREMENT: {\n      const currentZoom = state.viewport.zoom\n      const zoom = Math.min(\n        state.maxZoom,\n        action.payload.zoom || currentZoom + action.payload.increment\n      )\n      const viewport = {\n        ...state.viewport,\n        ...DEFAULT_TRANSITION,\n        zoom,\n        latitude:\n          action.payload.latitude === null ? state.viewport.latitude : action.payload.latitude,\n        longitude:\n          action.payload.longitude === null ? state.viewport.longitude : action.payload.longitude,\n      }\n      return {\n        ...state,\n        viewport,\n        canZoomIn: zoom < state.maxZoom,\n        canZoomOut: zoom > state.minZoom,\n        prevZoom: state.viewport.zoom,\n        currentTransition: TRANSITION_TYPE.ZOOM,\n      }\n    }\n\n    case SET_MOUSE_LAT_LONG: {\n      return { ...state, mouseLatLong: action.payload }\n    }\n\n    case TRANSITION_END: {\n      return { ...state, currentTransition: null }\n    }\n\n    case SET_NATIVE_VIEWPORT: {\n      return { ...state, ...action.payload }\n    }\n\n    default:\n      return state\n  }\n}\n","import { fromJS } from 'immutable'\nimport uniq from 'lodash/uniq'\nimport GL_STYLE from './gl-styles/style.json'\nimport {\n  SET_MAP_STYLE,\n  MARK_CARTO_LAYERS_AS_INSTANCIATED,\n  INIT_MAP_STYLE,\n  SET_STATIC_LAYERS,\n  SET_BASEMAP_LAYERS,\n} from './style.actions'\n\nconst attributions = uniq(\n  Object.keys(GL_STYLE.sources)\n    .map((sourceKey) => GL_STYLE.sources[sourceKey].attribution)\n    .filter((source) => source !== undefined)\n)\n\nconst setStyleDefaults = (style) => {\n  style.layers.forEach((layer) => {\n    if (layer.layout === undefined) {\n      layer.layout = {}\n    }\n    if (layer.paint === undefined) {\n      layer.paint = {}\n    }\n    // initialize time filter for time-filterable layers\n    if (layer.metadata && layer.metadata['gfw:temporal'] === true) {\n      // is this field always called 'timestamp'\n      layer.filter = ['all', ['>', 'timestamp', 0], ['<', 'timestamp', 999999999999]]\n    }\n    // set all layers to not visible except layers explicitely marked as visible (default basemap)\n    if (layer.layout.visibility !== 'visible') {\n      layer.layout.visibility = 'none'\n    }\n  })\n  return style\n}\n\nconst initialState = {\n  mapStyle: fromJS(setStyleDefaults(GL_STYLE)),\n  cartoLayersInstanciated: [],\n  staticLayers: [],\n  basemapLayers: [],\n  attributions,\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case INIT_MAP_STYLE: {\n      const newMapStyle = state.mapStyle.setIn(['glyphs'], action.payload.glyphsPath)\n      return { ...state, mapStyle: newMapStyle }\n    }\n    case SET_MAP_STYLE: {\n      return { ...state, mapStyle: action.payload }\n    }\n    case SET_STATIC_LAYERS: {\n      return { ...state, staticLayers: action.payload }\n    }\n    case SET_BASEMAP_LAYERS: {\n      return { ...state, basemapLayers: action.payload }\n    }\n    case MARK_CARTO_LAYERS_AS_INSTANCIATED: {\n      const cartoLayersInstanciated = [...state.cartoLayersInstanciated, ...action.payload]\n      return { ...state, cartoLayersInstanciated }\n    }\n    default:\n      return state\n  }\n}\n","// TODO MAP MODULE remove whole reducer\nimport { SET_MAP_CURSOR } from './interaction.actions'\n\nconst initialState = {\n  cursor: 'progress',\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case SET_MAP_CURSOR: {\n      return { ...state, cursor: action.payload }\n    }\n    default:\n      return state\n  }\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { compose, createStore, combineReducers, applyMiddleware } from 'redux'\nimport { Provider } from 'react-redux'\nimport thunk from 'redux-thunk'\nimport throttle from 'lodash/throttle'\nimport { trackTypes } from './proptypes/tracks'\nimport { heatmapLayerTypes, basemapLayerTypes, staticLayerTypes } from './proptypes/layers'\nimport { viewportTypes, popupTypes } from './proptypes/shared'\n\nimport Map from './glmap/Map.container'\nimport { initModule, setTemporalExtent, setHighlightTemporalExtent } from './module/module.actions'\nimport { fitToBounds, updateViewport, transitionToZoom } from './glmap/viewport.actions'\nimport { initStyle, commitStyleUpdates, applyTemporalExtent } from './glmap/style.actions'\nimport { updateTracks } from './tracks/tracks.actions'\nimport { updateHeatmapLayers, updateLayerLoadTemporalExtents } from './heatmap/heatmap.actions'\nimport GL_STYLE from './glmap/gl-styles/style.json'\n\nimport ModuleReducer from './module/module.reducer'\nimport TracksReducer from './tracks/tracks.reducer'\nimport HeatmapReducer from './heatmap/heatmap.reducer'\nimport HeatmapTilesReducer from './heatmap/heatmapTiles.reducer'\nimport ViewportReducer from './glmap/viewport.reducer'\nimport StyleReducer from './glmap/style.reducer'\nimport InteractionReducer from './glmap/interaction.reducer'\n\nconst mapReducer = combineReducers({\n  module: ModuleReducer,\n  tracks: TracksReducer,\n  heatmap: HeatmapReducer,\n  heatmapTiles: HeatmapTilesReducer,\n  style: StyleReducer,\n  viewport: ViewportReducer,\n  interaction: InteractionReducer,\n})\n\nlet composeEnhancers = compose\n\nif (\n  (process.env.MAP_REDUX_REMOTE_DEBUG || process.env.REACT_APP_MAP_REDUX_REMOTE_DEBUG) &&\n  process.env.NODE_ENV === 'development'\n) {\n  const composeWithDevTools = require('remote-redux-devtools').composeWithDevTools\n  composeEnhancers = composeWithDevTools({\n    name: 'Map module',\n    realtime: true,\n    hostname: 'localhost',\n    port: 8000,\n    maxAge: 30,\n    stateSanitizer: (state) => ({ ...state, map: { ...state.map, heatmap: 'NOT_SERIALIZED' } }),\n  })\n}\n\nconst store = createStore(\n  combineReducers({\n    map: mapReducer,\n  }),\n  {},\n  composeEnhancers(applyMiddleware(thunk))\n)\n\nconst throttleApplyTemporalExtent = throttle((temporalExtent) => {\n  store.dispatch(applyTemporalExtent(temporalExtent))\n  store.dispatch(setTemporalExtent(temporalExtent))\n}, 16)\n\nconst updateViewportFromIncomingProps = (incomingViewport) => {\n  store.dispatch(\n    updateViewport({\n      latitude: incomingViewport.center[0],\n      longitude: incomingViewport.center[1],\n      zoom: incomingViewport.zoom,\n    })\n  )\n}\n\nclass MapModule extends React.Component {\n  state = {\n    initialized: false,\n    error: null,\n    errorInfo: null,\n  }\n\n  componentDidCatch(error, errorInfo) {\n    console.log(error, errorInfo)\n    this.setState({\n      error: error,\n      errorInfo: errorInfo,\n    })\n  }\n\n  componentDidMount() {\n    // First trigger synchronous actions that should happen before any map render\n    // At the end of this, set a flag to allow map rendering\n\n    if (this.props.viewport !== undefined) {\n      updateViewportFromIncomingProps(this.props.viewport)\n    }\n\n    // TODO\n    if (this.props.glyphsPath !== null) {\n      store.dispatch(\n        initStyle({\n          glyphsPath: this.props.glyphsPath,\n          // TODO apply URL updates here\n        })\n      )\n    }\n\n    if (this.props.onAttributionsChange !== undefined) {\n      this.props.onAttributionsChange(store.getState().map.style.attributions)\n    }\n\n    if (store && store.getState().map.module.token === undefined) {\n      store.dispatch(\n        initModule({\n          token: this.props.token,\n          onViewportChange: this.props.onViewportChange,\n          onHover: this.props.onHover,\n          onClick: this.props.onClick,\n          onLoadStart: this.props.onLoadStart,\n          onLoadComplete: this.props.onLoadComplete,\n          onClosePopup: this.props.onClosePopup,\n          onAttributionsChange: this.props.onAttributionsChange,\n        })\n      )\n    }\n\n    if (this.props.highlightTemporalExtent !== null && this.props.highlightTemporalExtent.length) {\n      store.dispatch(setHighlightTemporalExtent(this.props.highlightTemporalExtent))\n    }\n\n    if (\n      (this.props.basemapLayers !== null && this.props.basemapLayers.length) ||\n      (this.props.staticLayers !== null && this.props.staticLayers.length)\n    ) {\n      store.dispatch(\n        commitStyleUpdates(this.props.staticLayers || [], this.props.basemapLayers || [])\n      )\n    }\n\n    if (this.props.tracks !== null) {\n      store.dispatch(updateTracks(this.props.tracks))\n    }\n\n    // Now trigger async actions\n\n    if (this.props.temporalExtent !== null && this.props.temporalExtent.length) {\n      throttleApplyTemporalExtent(this.props.temporalExtent)\n    }\n\n    // eslint-disable-next-line react/no-did-mount-set-state\n    this.setState({\n      initialized: true,\n    })\n  }\n\n  componentDidUpdate(prevProps) {\n    // tracks\n    if (this.props.tracks !== prevProps.tracks) {\n      store.dispatch(updateTracks(this.props.tracks))\n    }\n\n    // heatmap layers\n    if (this.props.heatmapLayers !== prevProps.heatmapLayers) {\n      store.dispatch(updateHeatmapLayers(this.props.heatmapLayers, this.props.loadTemporalExtent))\n    }\n\n    // basemap / static layers\n    if (\n      (this.props.basemapLayers !== null && this.props.basemapLayers.length) ||\n      (this.props.staticLayers !== null && this.props.staticLayers.length)\n    ) {\n      store.dispatch(\n        commitStyleUpdates(this.props.staticLayers || [], this.props.basemapLayers || [])\n      )\n    }\n\n    // loadTemporalExtent\n    if (this.props.loadTemporalExtent !== null && this.props.loadTemporalExtent.length) {\n      if (\n        prevProps.loadTemporalExtent === null ||\n        !prevProps.loadTemporalExtent.length ||\n        this.props.loadTemporalExtent[0].getTime() !== prevProps.loadTemporalExtent[0].getTime() ||\n        this.props.loadTemporalExtent[1].getTime() !== prevProps.loadTemporalExtent[1].getTime()\n      ) {\n        store.dispatch(updateLayerLoadTemporalExtents(this.props.loadTemporalExtent))\n      }\n    }\n    // temporalExtent\n    if (this.props.temporalExtent !== null && this.props.temporalExtent.length) {\n      if (\n        prevProps.temporalExtent === null ||\n        !prevProps.temporalExtent.length ||\n        this.props.temporalExtent[0].getTime() !== prevProps.temporalExtent[0].getTime() ||\n        this.props.temporalExtent[1].getTime() !== prevProps.temporalExtent[1].getTime()\n      ) {\n        throttleApplyTemporalExtent(this.props.temporalExtent)\n      }\n    }\n\n    // highlightTemporalExtent\n    if (this.props.highlightTemporalExtent !== null && this.props.highlightTemporalExtent.length) {\n      if (\n        prevProps.highlightTemporalExtent === null ||\n        !prevProps.highlightTemporalExtent.length ||\n        this.props.highlightTemporalExtent[0].getTime() !==\n          prevProps.highlightTemporalExtent[0].getTime() ||\n        this.props.highlightTemporalExtent[1].getTime() !==\n          prevProps.highlightTemporalExtent[1].getTime()\n      ) {\n        store.dispatch(setHighlightTemporalExtent(this.props.highlightTemporalExtent))\n      }\n    } else {\n      if (this.props.highlightTemporalExtent !== prevProps.highlightTemporalExtent) {\n        store.dispatch(setHighlightTemporalExtent(this.props.highlightTemporalExtent))\n      }\n    }\n\n    // viewport - since viewport will be updated internally to the module,\n    // we have to compare incoming props to existing viewport in store, ie:\n    // update viewport from incoming props ONLY if zoom or center is different\n    // from the internally stored one\n    // TODO FFS incoming lat lon should be an object, not an array\n    const currentViewport = store.getState().map.viewport.viewport\n    //                                        stop propagating updates from outside when zooming in\n    if (\n      this.props.viewport !== undefined &&\n      store.getState().map.viewport.currentTransition === null\n    ) {\n      if (\n        currentViewport.latitude !== this.props.viewport.center[0] ||\n        currentViewport.longitude !== this.props.viewport.center[1] ||\n        currentViewport.zoom !== this.props.viewport.zoom\n      ) {\n        // if zoom delta is precisely === 1, zoom with a transition\n        if (Math.abs(currentViewport.zoom - this.props.viewport.zoom) === 1) {\n          store.dispatch(transitionToZoom(this.props.viewport.zoom))\n        } else {\n          updateViewportFromIncomingProps(this.props.viewport)\n        }\n      }\n    }\n  }\n  render() {\n    if (this.state.error !== null) {\n      console.log(this.state.error)\n      return (\n        <div>\n          <h2>Map component crashed!</h2>\n          <p className=\"red\">{this.state.error && this.state.error.toString()}</p>\n          <div>Component Stack Error Details:</div>\n          <p className=\"red\">{this.state.errorInfo.componentStack}</p>\n        </div>\n      )\n    }\n    // won't render anything before actions in componentDidMount have been triggered\n    return this.state.initialized !== true ? null : (\n      <Provider store={store}>\n        <Map {...this.props} />\n      </Provider>\n    )\n  }\n}\n\nMapModule.propTypes = {\n  token: PropTypes.string,\n  viewport: PropTypes.shape(viewportTypes).isRequired,\n  tracks: PropTypes.arrayOf(PropTypes.exact(trackTypes)),\n  heatmapLayers: PropTypes.arrayOf(PropTypes.shape(heatmapLayerTypes)),\n  temporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  highlightTemporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  loadTemporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  basemapLayers: PropTypes.arrayOf(PropTypes.shape(basemapLayerTypes)),\n  staticLayers: PropTypes.arrayOf(PropTypes.shape(staticLayerTypes)),\n  // customLayers\n  hoverPopup: PropTypes.shape(popupTypes),\n  clickPopup: PropTypes.shape(popupTypes),\n  glyphsPath: PropTypes.string,\n  onViewportChange: PropTypes.func,\n  onLoadStart: PropTypes.func,\n  onLoadComplete: PropTypes.func,\n  onClick: PropTypes.func,\n  onHover: PropTypes.func,\n  onAttributionsChange: PropTypes.func,\n  onClosePopup: PropTypes.func,\n}\n\nMapModule.defaultProps = {\n  token: null,\n  glyphsPath: null,\n  highlightTemporalExtent: null,\n  tracks: null,\n  hoverPopup: null,\n  clickPopup: null,\n  heatmapLayers: null,\n  temporalExtent: null,\n  loadTemporalExtent: null,\n  basemapLayers: null,\n  staticLayers: null,\n  onViewportChange: () => {},\n  onLoadStart: () => {},\n  onLoadComplete: () => {},\n  onClick: () => {},\n  onHover: () => {},\n  onAttributionsChange: () => {},\n  onClosePopup: () => {},\n}\n\nexport default MapModule\n\nexport const targetMapVessel = (id) => {\n  const track = store.getState().map.tracks.data.find((t) => t.id === id.toString())\n  store.dispatch(fitToBounds(track.geoBounds))\n\n  return track.timelineBounds\n}\n\n// TODO MAP MODULE make it a function\nexport const AVAILABLE_BASEMAPS = GL_STYLE.metadata['gfw:basemap-layers']\n","\n  import React from 'react'\n  import { MDXTag } from '@mdx-js/tag'\n  import { Playground, PropsTable } from 'docz'\nimport Map from './index.js'\n\nconst layoutProps = {\n  \n};\nexport default class MDXContent extends React.Component {\n  constructor(props) {\n    super(props)\n    this.layout = null\n  }\n  render() {\n    const { components, ...props } = this.props\n\n    return <MDXTag\n             name=\"wrapper\"\n             \n             components={components}>\n<MDXTag name=\"h1\" components={components} props={{\"id\":\"map\"}}>{`Map`}</MDXTag>\n<MDXTag name=\"h2\" components={components} props={{\"id\":\"description\"}}>{`Description`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`This component displays and load fishing activity and fishing-related layers on a map, used in various GFW projects:`}</MDXTag>\n<MDXTag name=\"ul\" components={components}>\n<MDXTag name=\"li\" components={components} parentName=\"ul\"><MDXTag name=\"a\" components={components} parentName=\"li\" props={{\"href\":\"https://github.com/GlobalFishingWatch/map-client/blob/9c5179358d4870c0fd4c2c0742917e72e6025c59/app/src/map/components/MapWrapper.jsx#L5\"}}>{`Map client`}</MDXTag></MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\"><MDXTag name=\"a\" components={components} parentName=\"li\" props={{\"href\":\"https://github.com/GlobalFishingWatch/vessel-profiles/blob/aa0e17395f6a4947bb3fdf3106cb9d0a744ba64f/src/profile/components/MapWrapper.js#L3\"}}>{`Vessel profiles`}</MDXTag></MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\"><MDXTag name=\"a\" components={components} parentName=\"li\" props={{\"href\":\"https://github.com/GlobalFishingWatch/data-portal/blob/96b1e24efcff58ade672a67229da0610d9d241ab/src/map/MapWrapper.jsx#L2\"}}>{`Data portal`}</MDXTag></MDXTag>\n</MDXTag>\n<MDXTag name=\"h2\" components={components} props={{\"id\":\"available-properties\"}}>{`Available properties`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`TODO: fix crash on PropsTable docz component`}</MDXTag>\n<MDXTag name=\"h2\" components={components} props={{\"id\":\"basic-usage\"}}>{`Basic usage`}</MDXTag>\n<Playground __codesandbox={`N4IgZglgNgpgziAXKCA7AJjAHgOgBYAuAtlEqAMYD2qBMNSIAPOhAG4AEE6AvADogAnSpQL8AfIwD0LVmJABfADQg0mXACsEyEFRp0CDSQCojvVO3YAVPBDjsAwpUwBlAIYYARpSzs8rux4wdOyuAK4ElESuBBDkrlBQAJ7sAOZ0MALRMOjsoXBoKWYWAAZUmHDu6F5YGcU47ACSYOyJlKEA5AIw7OShAhBtdniUAO7sBH4Evq4ADjPp6IotbT3uRT14MOQA1uxtU20C7OiU5EMZMIi-BAQzcIiSkikQE6EeOFREkqiUrGiJkjK8Eq1QyZnWTWWoXY2Hm_To5G67mScAIAlCKRSsDsIxeeHGNjsFU83iWM1g_m6mVsSPMtjgoRg62oqTxb3qiAAlGYjJIzBAiDNKAIpgAlGCuchTMBCIjsToSqXtADc_MFwrFioIABEAPIAWXYMsi8q6koIAFoTkQVWqhSKHJEhah9EbZfKcJJsK5BbBbagzOLzXr9TguhgMgAKdbMNhidYWRh4ADMYkc6pdNE46pF2XYuImPScwJJNQEiCkKfj5gs7EYMzEkYaUyiyRdedc6BYMWo8XYMyEd3GlFSMCmL3Y4cw_VQKXzMASnKkDYTdfTztdkmriekccUZhOvSI-hwaQIAFFYMeaAAhRINdCRzrCAjtbmoTnKhTKb2-mA4TQyB0ahaHoRAVBzKZ9VmN0TXaT04AEchJCiGZJFUbAALgf0BXtTVzVguUFXNdo7Q1dhgHYTQfHkQj5QAARgIgRAGVBAWFGBSIDVBdFRY5TgAL2cAhEmxdhuAo9YogEZ5UCudoAAZ2GTGYsHafcaxmTsWFneSABZVPYAA2VT1PWMAQIAMR9aBEnk_hnEORFHUwdgAAUhH4JZmJ-OAtMRMyawsmhnAgATLnYABGPSNPkcEeOoPiAEE5nE9hI0o8gbCgdBw3YeROXEsR0pjGR2FRUSYG4YBDyEkTsXkbda2ALLoFy4IADIOvGRJ5koZpWpyvLuBG-UwFCHie1Qdp2AAfg2Nrw0jQqrkG9rUDimspBkat3zMWFyMwMAwigKZlqKkqtpSlca0TIMpRwSzMhSa8CCa2s62gmZ2D-GARjw6rMv0DIrgAbQUnAFIAJiMpZIqh5McCMyKAF0lgE4QiCuABWfLaK3VcpHughHue16mqka7drMb8QEQ5DUPQiMNC0CgQP0BgDodSijpOgglgIVwZLHL6ADV4DgBcliS0WkoaAAZJKb3l88AH0byS5xz31JK3OcfK6PglDZi42n6eNtDUKwoDdFAgxwNw8jicNs0lTIh0PMoGZLF6-BDYHL2LRE-ZsPdqZMqdShJaWcgzVoYSOJjyIPDQGBxXQUJEQEOAllmclEn1Lh0FgEYhe6WjjSIroM7UsOKPcoQ_mnA3K9NLULWr0Ja9QR2HVeVBdlbhUa6DvAJu2Lje6mCYhBuWBDagJx_DwSQZ5EAg_Tryi0UlbYfZDlv3SNgOZmD-BV8yHZQ57yD682aJUPl1xEgyff4CWDxKUf5_X99nPysFjEcgT8X4CDfnYCuR9PQnzPnASQUAf7Z0nrfSiv1_oanAWSL2oRvZ_0PnBaBg5YGSDgH4auXE65fUNp6LEjMvofBAq4VOAhkF4XrmgF4-onChFgEsSWBBLBMXtPEc8WA7Z8LHAACQgCkPAUAZGEEETmERYjXSQIIShbhsBNEZ1gDgc0rFr5T3rpAARlAbxtAwP_HB6AsiiwgH9PCAtMioHyFNSwlAABamN8FERoVARmaC8L6KlIY1h5FKIcIIMJSqSciBEBeDE2AABVGYtjaD_zzkkJRwioCiLtr4j0TwAmzBIfVf8BjErhO5rkNJWRLCX22BA6hF9d5wJ3lfEJU0jEoNqekmAkiJTEFmCAjI1i6m0FGQIeWlBOw5OFCou2zSh6envsMtCayraVNcdUqYABxeWqtnCWAAJoqxabQ0pWILQVWxGUyqWFqAUJvmwrhui07ZEzhkFpzF3k6J4f-TuWddlWEaXAdOXyjgrNaVfGFTSwyfOBXXQZD9ZgQqzi0zZpSsUzARRnJFLzyIovWZYaA8B0XfOhTiyQOLSXYjxZCkF9jHEagpVCqBxTAkOPQSKBlBLjFJI-fiylHLLloVuYCxFGQQUND0JfKabKLklLQmgWg8rWJ8ulfFXiLY0VSqOBJT4KcXRsrgBlKSWiIpvIBWyjSFgOlNKuA0tptr1g4quMS1Crqay0rJfcdgnrZh0vJfqu1ADKpXEFd6iwQSNRXGZTygg0bOByu2VcWVartneoKvFWAUxPhCklueVAfgeJjLSgWqOTJuIQGaNGGskYA6IjgHAHAdBWA4B1m5VWopzzamSQADR7drXUlg1banPDeZJez2AAB9Z39iEM21t7acC9qSvYSwqtdbdq7cO_tQ7e36lHeOyd07CpdXWE2iWbbUAdoAHK6gnarc897RbiVGu0TArAFxe1elxQqwB1g6qLOqSWAB1PE2oYCsA8ZQKAdgJJdAAI6hAgF0J8XRmK0A7p8rAVoYMRHg9hTkDCwMwEgxMaDsHhAIeA5HItJb3BZ0Q6BwtFGoMwbgwh81t12CoB9BFdoVDfkAsCh9M0p0BQRTRIyMNFhhiogE8eeSi84hQEU6-eT_Y43sAABwKUM9pqIWAkppCuMmBS2nURZDcD3GI4VyzpRs7QQq3BioZXYDgbzLmYDeVmFcSi3mcC-ZwKhJY7r5SPq3VrUUDQkrywaJ4vtM1aIFTDTmja2rEpTFRBxCtccYAJww_RogxqhWQrNUBvjqErhetDesdL6xgBKFK-x4tpaWORiyQXIuJcy6Rn7tsTk749oJVcdPPAs8N4wGutkoRCy8mqKzBJNec8YCRkGwtzIS27ZueKtViweWug4BYH5aIWVutzHm8o3b-gtu3fyfoEb6xjv_jO1pAgl3-HzJ209mgD3cn_YIC9jacMjJjZAzYux3K8JPUiLKz4BRPZDgkpGNASPZwJrwvtySNY3undsJ9y7q5oe0GxxqXjH0LAIJiAQUImArgY8iAUCnvLERyvBmjVcNPqDPHp4zlNmOUhs5JhztVoNUbaYsBjSITOEoJKx7DjUOBZdEG05liw75NpmHIAglt7AvrWvntgUC6A7DExwOuagrpDsAKyGlO3FgokQHiGFbIVxjoIb841-KFhK2Zh1FwewF28CRgyEIAQSwI_CllRZQDq5eLwf_IvFI4eBCR-jxn2PqB4-rgmLYELY5hJZCp9TmPTmK_S5hNngQcfKBXAr_XjX74LA65rAH_Q2ouBcImgQc6Tv2CPHYJZdDfE0QyLSEcOAiQeJTeoIMEIoTEoEmiOVYYPCch-DmMEQIFkughFQMkVCk46DTlXMPpKk3uhn72M0Av_9-EhCNAgucEQQgJFGOwE_U4MgFD97WLWulA_jgCfK2rGg6AAISjQTRHSpzoAJ58YWBk4wCi7w5ECI4s6zgo5mogFgE4AQEg6rjt4fTD6WBPq6irhAGDaEigGDitpYi9R4BwBuTRD4jQESSwEwCQAugIF47U4AIcSE7nZfZh486AH2aCpl4CEWCMEzDMGsETBXB4H0GnhJDyEsFsHV6kGSBWAUEhDXbJDJKijyx9JZDnBdDiFt6t7U42Ft4AHO51oqFeytrUBX4T4eDhCGL2ClppDsAcG5ARg8HZCIECHOF3A4BuE3D9CeHdI-HuBpCRgE5ngl60DLRhazAhblL6LREQCxGGJ2H5QOGcB1pvbsBdSCEnYpGAIbakZWyiZ6IRDbDBAjScFBHwGhHU4E4fah71oyEpqcKWrSEyFNF0DKG0H4GjGoDaG1jUCi7xGzgyYTGqFzHK4igLFpAzEWDUCSK_AgwEiF74E7F7FR5WGzGoD2DyI7DjGHErEXFXHbBbF7CoAzKdgl4ig3GtpHEvGzLoDvH8xnHbE_Gdjrh5pLG3EuGRHAnoCgljg-5IHU7UCXFVpuTYIzCfF0GQlImLySyokzA4JPFREeFeGJQbHglfF3HuExEkmuJkkzGa62HEHFHUHhGto2CyLyKyICLbaLKugBGoA8JQDlHdSsn4AKKcmKI8l3Y0A4CwCzgTCdEfTdFE69H8LSIckKLcmPbLb96inslyKam_a8k0Cg4fQkGAF1riE0EQkRGfySzfygJ2ABFcHBE5AVGil2lMQjKIKtpykpAKlzqzpWmikuaxBTJOkwHtG8HCkHEUmQmhnAI-myl0D-l4CFGKm1jKkiEk4In-6RAJLRLlKpL9K4HLHxmAJhk-mBnsCgxoyxmYm2lfzemOnVm1mFFa5MncQfQsllkREOoRkSQCmLj8FdERAnY9GiGRgoHOpXzWlxl9lgqmm1jmkWDD73pf4T6YjfL-Cz7kBL7dLMlOG9mtq0DakFLOlRl5junHk4CnlA46nJnylpkjkfRrYzZzaJBGnSm6k3l3mLbA6FErlD66HwDyI0BWi2CuAeCwAWguhiIWhgVUhajfCUAQXoAWjMR943Jjg3I1H560H8KpEbaD7O72au7yLhToDKHojwlmk2Hmmd40Dd7oDFml4DgwY4EZnD79lUFHk2knlgr-GjTsWsA4G3mLkvmZljnvYqmTnTlgpzkNkCVtJLn2Fdm1jD44rsAIKOm8XAE3k4rhlCUSQiViWGU-kZlHbSXCHE5h4oGBozDhmKX4HmWOkCw3mLxzJSkAWAXFHD6ekn66EJnaU-l6V9HU7OWqEBXNnloXlwHRnXn8U4DRWOVJl-kBnzrBk3kJlGVxXcHwExkhkVmJmOmPmpnpmSVWVCETk5n9GfAFmCqsUZKRXlnRCVktnzo1l1kelNmpUdULptniG-XqWrm6GeXoBfnA5hWinjWTU6nGWBHxVXkikeW_FzV2xlUBkkUlGXT9GmWqGzXeXzWtGLX5XRmZW5n-H7WQmHVnknjpX4gXX9EzVrVHV2xc6nhjikrHjnQBHXURG3X3nvUKQoyfUCLSbnRPUjGrVeV3U0CS6g1njfW1ELX_W-mvVw0EAI1g3I3LRDWVVSXVWyWXYoFTKvETVvX6CllJWA3_k6mqXLmdk6HjCU00DTW_ms1TB5WumFUc2Y2bXPnbXUFnFo23mc0fptFLU5BQ0CGQGi1_l_YPkPWBlnGikK3GlY0g040Q2FR_VdCiWqHq3fkfVI060q2XVq2c3Y2m0_W63CX61iVG3A7W1fU6343bX2rz7rYfnrX3aW2Y3tlFF8ZAWaXimGmc3s1JX6kSlalA18mjRDlCmJXzlslh1cm-0ykPWWU7XhUCGi3R3h2Y0S38aCnm39Fy0O2qEF3p2c0C1l3Q1R1p2SmY0m2u223GWAmLocVV1N2x103A2I1t0o0y3U56m90Z1Y2oza3t0cGd353j1W1T0221Hu1nFZm2VJFSIL2Y0tURHV3N1x0mmB2bRmkwje4E09mN0ak11F163d2Qn7192K17YE1VXjnE1h5qnb2H0_lX0Gk30_0M1qVml-W6GEHsAWjlQY7dDgO4gJDsCBBmG0A5CqoZACYJDJDv4TDdANG0UaW6EjDdB-A_rDhsZlxC5YFzhgGkPYC2AxCzg_RrHjjmBvZLAOKIAX66EoGMMsoOitzM6K5UP0HsC6j3rywnI7Vq57BHDi7fK2DHC1pgAXBs18bD6tzYMppqroNJCVF5g26cN6F6gj6WT6wCMFAhVTCLwsMb45QIO0h7AeDqBbD8z8YiCH4hAZ7PyJ45Y9B9DhgECi5pTJHF41HpFWyEEEFMMGP9ExOxNxOCHfQnyuApBtUMMoF2Ctz7D5CuQjCbDmBq7mNoBhXiGingPc0FWXoInBOFml51GZERO9AZ76DOquIvCsTF2J2rjZ3C2XWNP-Oi6yltUC7dABGlNMMfDAwCBc710CF9P6ADNWP84M4jOjRjO8Ni6TMI0zPU5zM0ADNSOjM3kRNq6r2XXD5AFSOYCnSuCcB2DsXkA0g6MnWRTow-IFj4g3M7ytNTRnHUHQQTD6IeBmq7MBPjNSOQNrOJqq6YxuajSRTZ1KnWU1Vh5fNuKsQeLeKRC73gFgswuB1t5n2Syv21goFoGyiYGCM4HYuRPrP4tB0CEn2M01iMu_4CAD6R2tqhYV4LUukdEE1J56Kp6KVcu16B1dD04CDmC53U6xiyCd1JhQxiBUKMX5qZCkLZCQGViKvyvfR67-BwD3qCZ8CCDZDiDAAgEiuR682F6WvCi3mUDCQzhp6cjyDLjvQyGytpiRyB7sAl47DsDni17sDQaCzQD3DbRxg6s9D64GtGv8DVxmsWs1Ftq1715kYbghSCw7CuuSA3T9ERtysInDXM0jBPJTCsuH6JAF4MN775bbJ2BoBsY25MU96WJTDEPdCBDBCblT6mt8bit9DmBJtZA4Au5u6UULWybdDzSJ3sBXDSuJiexNzfJvbVRvaNRnGMBULADBasn4zus7hLtcAZDuv0VmDt5G6WoNngKO7rBTFXAo7gJZFOthqEEPuDhPukKzAbaEHgKchhr9nvtexPtCyZCJC6hgCRiPt_xtpYDmiDaNJ_v_tupDIOljJAe4Ihz6KePgeQfQdYdfvzCRiuW_whwjYAec0Ycgc4cQdQcfswdoA2Zlq0fahZDkdurf3936BUcwegfPy0f4fwCjsTbMYwAsdsfIc1i03P3ccNzAe8c0d4f0dYeMeCzMeQeseuaScWApXhk8dYd8e4d0fycEfb4ba6eIJIdho5U-n6dCeGcCfKdCeEcbY2egJWfrDD69B5ZEDhluonF4k4J2ectmeNpol_thp66xDbCBfolyeYfOehdCj4kJdwDaepDqEKFsHBfPsFBhqrHrNkk5fjQ8T5fQn_HFcTTkBlfk2wm0CVelfMj3HRcNfVdNe7E_pOaCetoldtc1hEnUlxG-ERTdc4C9dlfIm4lomtexTxSXvvKnbcF8w4G3s-qccyc0BXCJ0AdgpbeCmzfcRcxTC8w8JQSzDG7Vr7RYBsIgaCzCwEBiwSwLhpTo58HuYjm3eNJBPWXVG1MZG4r9mnbRCuBjeqCbYg4XQkxcDF1cD2uOsFDLQ2Hr29GmIeIWKwG4GNKfXmKWLm6g7rADuSvjBY8xDHiIXo9WLnvxRkH6FdqG5PrJLnJRDNGcBTA3O9c_NwU3c-MyxyyKzKxqwaxaxdr6wSQHJHKnIqxhZjidjA-gztApBgAjCIApUIU-ntAow0xKB0xIQWy5tEJ_xwqtqATaC2wcwOy3zdf-yDhBx_zPJHdFgTbE-7w3sSR25cA5eohOujvgowCobobZBhp9BQCe8T6zhhrpKuA5eUCOPOORfwbCih8vt3u-zR8ui0fy9pCUCaBPJLC8u8Eozpc6Wvyc3-qjcOdKcmf2eKfGepc4ACllYZDsdBQvAU_m66jQk5deDwYHdmy6-MwwKG_F_ZzWym_sxgQQRsJW9Dwny28hz2_XfkQgYkdgJ4Ju_rAe_xefth8pA-_ij-_VwAd-pjgPhJ95evZvBnxn_h_rB_D5DQUjdOetrd9QBhpjyP9V-toN-BCnH9f-QvB2Qt-MHb_hkDDSQBTo6HIAQZxr6rhRuLnYYqNV8CMg9gnXfoOUBCqgIkB3QIAvwnELv8cuIA3_gITUbQA1UoseIIyAbZ2AbmLAZfAJgEDJBG2uTWIPiEVD4hmijA6gUaFIEZAoK88SAAuEWDiFh8lQH6BQL9jyN3AHjMDnfg_xClC09_eeKwHEF2BIwuoUUNwIgECBA65zCKOALIEqDAsqwWgCkGFCADQY2MJYEZBRj0tqc-gjIOQKgCUDo-sfKUC3nWDpd7404T3qF0Hxn4hQqqMvk_0iKuCASfGWwG5BvCWQu-tGbTFQAQx3hDWKmKAUJxj5OM3B-eUvjlwr619qOYHRzp_3r6hBG-2g9LvalL7ywJYMQnvo1lIy2B9-aGQ_hv1TShIf01Q1_lT0O6L8HQIGCzu5zX4jlN-cAnfq-1sB5FYA7Qg7ld255O83OpHP2OvxrBDDghXvAoHvz96NDA-nnXQuQSMZ09j0_ac5A0DsATA187YTADkFEE4CRwuTRILfzGEP9Jhr2BcM4w9wpDn-sQ54bAClDZBLIQyPoPAB8HfthiAgnKNfxSDaZlBTgwEe8Ow75DK-dfVYbOHS5NY1u19QgG8NG4v83-MiGOr8P-FdAghhQ-AYPlBFUVYRSIiEauChHODYROQ4YU6xRHpcvYkoAAQQOKE_94-i8LrisJGGvZhgIwJ-IEAQxPClhLQmIG0NhHYjzIPA7ONkJr7l8FRvIxkel1sD2A8gEQLGFKM-H45L-qfWETbgz759A-8oLPjn2mhLBOg_gNVBr3S7B9wREfYHi4PSFhDZCIfA0aEN77a9zYA_A3iHBIRkJsgo_NmHoAn7GJp-R8WfrAgX4zC-IyXHBK7w-7j8CABA4sGGlpwvBlm7IkoesIP5bCpOfOTMYLlG6EDcxmwoQVli6Gxipgv7AYXbjVzZjORwGSZvKPhG5DgBHIpvl6OUA-irkyqSQPQlthMIXQAgYMcBFDH2xJ-ESR3i6ClCFJiIUoXDDXBBSZRCszgF4VKGFDzjCRG418FvEIgAApfWOoiIgCgiA4QPgZxH3GWBRQG6AANLOBVYisE5OeFFCqwGg96VWJZFFCiMt0uoSyKrD2Q_jkkbkecd5nYi54ZEK46NiiTRJgTPQuDf5HonrZYRoJSNMFIKmWRQJPQ_ZI3kXm-FjljePSNhJRFQgddQB3-WYJcWi5gSmYmaOgV0kMSoT9x_CUXM4ncBotqAxaHICeKKQRMUJmgEFFQmhRfRnkIGX7kAiMpo5fMuOULFbAlRZE2qJVMZNlid5ngM0vA1oTACmQPhWMscIZEVl3HChwqoMCSe1TGTc4awa5EQBFE2AH5CGIQFtMUO6CnDLGiCRoNqDuaNxj2OQd5t_ktSUTRCBIboAcgwHlpXJ6-NoDlG2F2NNGmkiUd0C3E_AXGDiHqDMFiDxAdGGjcAUKWH47UbmCCYUWFKODyN2KksFRhYCSLFVwy-2VcHMJH72C2WkYKALjigDCd6JCU4ulOxjJtS7-4w7oCdSnZ1MZgm2FqRdDalcBRsqkviGeC-iYSXuMki6HJMyIKTUIgqXXD41mmzBBUBWAyeuIInGT1gpkkWNtPKT_x0JbSTCZZMqlrSzp7EnYJhNxyD5qCkBB1I9NPwStzAt0yqHAGKIgYQWUyPZEIBwSsZvp2IcQvayPF40ESgzUqo1NGmtTpegsSPjy0vIIEIZqEBGeNKRmy9BY8vVCNUEQApBgZMwW0d4yd4OpwysqNQBWj8b6BAZJM30taOpnYBaON4-8Y-OfGvj3xn478b-NVj_jAJwEtyIVAADUUUYonmm4HoM5pZ0tKGDKE7HhhYsqSMPLzgBOR4AGve6dsEwkhYNZaXVcFLIVlwApJlEmYLrLPBPhh-JGfPI0l1nWyxuwoc8JKDDwIdd4UyNhk9PELGzTZPspMoxwyC6lGkVM5mOwHFkQAlglcKGZTMQQM0GSFgHgvEFlk_S0oicqAMnPpT8IrZ6vfzObLOk1TiihPcwGnIznwBfcH4aabqjzn1JKAK3aSTUSWCjBUAnFC6GXjfb25aA_3GllC0IJhoTMmLLUctNxQRN-5mMPuWgAHlXAh53c4JIrgHmRc-g6spzNPNQbqpqAHwRecKD7mnSI0o4B7jvNgBVS2OYaVeQYh_Q6TzcVwdSeKLYDaTEEuko-a5liiQ4fGqEbvNmTwAeI656UZFrjjLysSmG87Qgl7L4zItN6oLdZpGGAX0Vt5MwciU5manRAlgizSOQSPfjRsNRTfC6IPjAVkSTiiClxigqNBoL_4euTBaUMaywLqJ1xdKLTmQV85UF0QAEaQqcGogsF73HBR_UjCoRqF2wAhfQvD7EKmFhImOKwrVRLlWsNYVFm0y4kYB52ICj6GAukVTRuJiPShU10m4wBYu8i7BauDAV65YJKXNRcy2fnxQHeJ3U6DOOcbhVbpNcnArAvfm2Uv59BMwJyEjBfR3wffBmKUkQm4NGJiUMcWbwn4O8QMH4hoFugOGM9zwaUdoGEoiUM8VYXEEJT4y1hbox0-oNyOoISwvoB0Y6e9JYBiWpLVY6SzJbeMOTnhclr6SwEku6H5oUl54LdJIgaB7JJEiWFpWku1ilLslFSvJQUokjtAilTSlpW0skQdKMlWS8pZUvyU1LqxvrSwElFFBbp5YuoJKBOg0H9LjkCypZSsrWUzKl-PjewAaDcgqwx0T4nZa-JiWHKMlJytWMstWWviYx-yp3lEgu4vcwCf83-boprBgLB8V_RoPenCWqxIlKsbTFpFEi_ErgYBDLNrjMW1LHefEGzCKHJrfI0cyLPhDUQUXwrLGvxDIA-DSgugxgmnWotPRXrfKuFvy_UZssWVnL7looUFc_HGpXBxquKisdYQ36lFk29RK9tQHJr_FUZUtDMtPL8U8rfi_xaGcAw-mDttKOKuvOgE6HTCnlfEAtGCWRUGpaFMqh8B8o_pLAJJMATFSBl8xpRdV4qrFdKs7DloJIuoUIfohbQyJUAGUJQB3P_BcqFuzK7ODYR-X559RVy45Q0tuXnK6Vq4MFYyrNXTgHw0K9lelEgJurfSKZQsBUSFXcroSdXFZpLTOohFJKiahbiKpBJOgwSJqzaO3mSVO8CuiaMki9y1UfydVITNjl8rzKzCaiRqmtWkRsL_TMpn8f1hJCzUAooS8xYbgAWoLqYoAHa3YCdWNF8FB8Rc8ufWr4jgMu1nK-plE3UrUEImXgDHsXXHUZkp1zLAAkOpHXDEGxPDHubi0iBxCWxNZCJhEwzHDMlgl68ZosyLEwBrptYNdVYiuCrrceOcRPO4AHmyp314zOIKgF_XTFv1QGzGLqHCD_r1mHwH9eBvCDGZBgd8ggDMl0hHrZ5iGp-MhoYW1D5VXPRVbli-ri00cTtemq3Ltx_KilJSiZTkt6Vhpg1EKlmpjVMVVj8N5ULeuiKfoa0Xuj9Cen_PI2UqGlqsIZa0uaWjLilnS6jT0qqV0aGVDGnjZzWY0KqehPjAxVNxS4VrW5aKveURX1U-NDVEkY1TYWoLdq9E2JQxTgn5XpqJ1dUhdbimFX3FzNI0s9pWK8V68xUkgfiXQKIk2xkxDAYxJRFMRt9_46UmoAhg8TgZhQtjXie0EIIYUMgcQMchaADgujoJ9lVDkGj9ToFAm0W8CdSl9T0p620E0tXhHLU5aEJlqJCRUi83QT7A8sZJMcm5m1aGg9gO8arE8S6gDQPM-wEeiqXwSIJkAFIDNBp57DdY9PQ4eeFhWzKilosBoOeHAylK-l8oabbNvm3qDqlSmupU7xAnagkopymbXNoW0xLttu2tWPttW2LK9lymp3kUva2daPx3W7WL1o2WCbbt-oLrT1umUbbTVRS49PVtuW7azl96GdM9viV_anxAO5ZUDsu2ba-I7M-9M4HCUNBRGL6e9NqBiVw6EdlgJHZ-NfTahod32wTfel20NBRYp2lbYdpB2qwidWO0narDO0LbHlV2hFWOECZo5gFmmj-pis9V8YKNgm-nWtvpXgrOwUGxNBGrJUfypyEyAZOlu9iZbZQouYxRYDAXFaNQZJYxUWrhVQ4pdrO9KIQSap6qOdH8rneSq9XzArgx2vbeToF1BrZNwutDRqH11i6ldXCtLaill3YgstTDRXQowl0q71iw3dXZXOd7fN0WI4NHBjiwz6BkFQzZZviv27SrZwj6uPQkFeYmhBygpStbZWN0S6KVZu31i9o61vb7tH2ywILpDVC0eIkemgNXmvXLMa9hYm9eITVwa4ndPujeq7pJRy7IgCupcsrtQB9qEitRGFSxqZ3TwXEnE1ABix8Ro41cme0PNno3rKLQ9kYbbiXRT1r7X-7AWfcPq-2fcOJMi1ANxI03vdIwnyjhesG52vl9RGOxHcjtx2t6wFHe1CMGjgCe7IFverhX7oIBq7QcGu2ZWrgzSUBxYLaBcPYEmYvda9mAARUs0wBz7RCC-3okvuoAeJIwtW-rWOjfFNaWtbWwve9se35Lo9dOOvQnpgN6qd9eG0fdwLMRBaXur6vHobtsrVqamrmOtaav03abQmranxqwG-gSRAtn64YnQf9SgxQYQhsLGgHliCKxDiuTDXWVEOfqMiWASQxCIQYKGTMsh59RYFxDoAlCTqruXeug3aGJg2mTYJqSnm2aZ5KuCJqYa5L0quwBQHGFZhw3i7F94-g_SgdX08HBmRBqAz9FxQPqb1fh6FpEF_2TbWNR3Q1glJ10r62qP6UXHAayi6aKZXsSoWAAIBuQfAEkcGEsBBr0YneXgG4JEFFCakMjaUUGAJiiPjMjDeAJYBUdvkDMbDhATXupS85Ohwg3QWAGkcPw5B-gXJO_GAH4QnCRwmAPsH5PcCk8_8LAKQfSEZB5Hx8KR7ggQAi0CBbGJlCAKFrgDhbItj4CII5UWMZHajsR1AuMxC0LhkkqAZLc41Yj_N-gWALg_kfXhFHNSyx1Y_2HWMLhNjlAF44-AKOajijXJA4_xiOMDNTjUAc45cboE3H1j9xviJ0aWPbHnA6mPMKtgWNpHvj0zXQnUbiPjM4ASJuY-W2eMImkTOQCSL8aeNcl0TINIfECcqPQbcT8QS7lZLGrRB4ELIKgJK3LT75v8HCLEDH2rQzqpgPwEUHgHAzwApgg5YE-MwmgQndSqJ9I3cfxPlR9geAZ2XxAlO0moW0poQC6MjBkmiA_xwgBkZhNTAhDq3D6EKd0MWmRTYphGtZmVNTzlTqpyepofnCogtuGoa06iC5zaYJQbppU-EBVPWjvT5ci_Sbp50Cat01OknWToO3W6-M9Gu3dtThPfHETDJ1ldTl6OEAUzxJ6vEIZb3OHNormxmO5oUkCTWY44u2H5t6RRzjxhsM8ReIf7QTNgWADxKKBSAeA-tXhBDBbAtDxDhQxE6cZsqx32BwdL40UI-PsBbLdQKO7UJko_Gl65lxOkc1zPHOqxJziy6c1jpViPjcdc5_JX1t0ADaat6BzrSucfHOBkkN4U5G5HPDOAlg4vDHW5AWW9aytEEpjgQAHMOhxexyM5NEuhTXIJUcCBSeaJBRbS0AeyGAJEDfjUJPQXZuBGBdQAQWoLvsRnTDqmBxKgVusCXr-ZiUYW90P5xJbvvqURKsLBF6JZTvwuS9zw-OkDDrFFCtb1z5BUc6-MfGaweZmy-9PYHixjo0d_SuiwxanPMXVzbFj8Rxa4sna8dRF67YJqHPNahLovJbTJfmXDn5LNF4i-rE1jawsLZ5wpYJqF5aXu0Z51C6aqiQ7S0clEOQll0LAFQyNKfPPXhdItUWZNQu8kYPksuaFjD6ijaC_NmEnS85lUBaeUj412WIoP2xy7-ecshqJUimig2hYML5wJ6L3EjS_RP1abdVSRhFY2oM3NriV8k8pOsClkSpvuI7BWYqZBZmXw0jRSgFDONMZdTZ5V7ItbN3V6a7u4pw3GwTDC49AcXHeGlrWXrnRdCkUQzApFqu34JI_zPAJ1dgLdWNuzpklQNaijDWxsCcrcc1LHCcA0oCkZUBtcYB1W0qcavANtYgCizRZGZcSVACmRGqLrPpUGBAGaPdk60WIKZDjJRljq0Z1ZJ64ghety8FeSvRAEbQ16TsaK2dW2GgFmPB1QGO1PKfIyNq5xNBaqb_BqI_ylxEgAQboGVPWssgNGwF9WeYDSHOMDGgQOIHkBvwuzipqwcwB22fwsAwASjfxuMGkzcDBBpDRBo1L7YfR_pdMmgKPi0HfcHk181We0GtnqROAloxqbaMhnOATVjhdKCCx5sI2TqidbOmvDGAEqA2teJ8I1MRt8REGGNg4Cw2yLmijQW4o2sVPkg6rrroCUdujIht8Y5bsohGqDChg2D51QsUQHba5sEB5bGQJ2yjF9tpQz8NmgK_OoeT8IVZ8vYW2wzFuyitZh4qW_ba0ESLQzEu_hKXKqmVRQj3EEDD1imSiIyp-QFfPXNiSn4wAHs3xk0xoB7JLbFEz66AhZl3HWDUsglRVYlRlXPbLd7IhEBquKmsQ0Fw1J7arvPWz4ipixYWRTn92K7Y9vRMeGRk_XFeyvQCxr0VMz3cZNzCe_40HtfWV7kfdYMqDVm7jsgIt9oI_UPug198zsy7OndgBvxMViAs8GxoIn4jhFfsLcSffQB_Dn7v0u2z4yUaf20oXQUu4glBjFAAAJMAAlRvx5AH9iVvAGKD3Xawy_fwNA-YWpySFC1WdhUV_swOByp1Hmpg5IUEEVBddYqApHJl8QesgqDxElASDIPCR_97glMlBgQPfYzRsh8dyW6ncKro9zCUw_KRvw_bvdlh9WRaxsPipZlq0tveB4xlJHeM36wvbOmA2KiMj1wJnz-uL2_bzD-YIX2EeMsBTcg1gqqhRyByHErGILN5m4flIlgwWYfjtN0c50rVLonABwLNSZSDHNAIxyKBMekYs6BNYfKYIJDAzZEMIMm1kgykP8Mu_YYcVMBPiBy7hCJBx84yccwBUb3WBIG4_SODhjH8AUjOfZdmbYsQ6TjxyJFvs7M9NB99AI4OQESRXHUTopyY9MlQBCnmTkUIkD9u5HemP99tbvEqcDT9HtT5pzEHgANOmnXsWJ37dRhnEQMWkVVLqGmTPx9gZR9oLEGoA3J3cR95Z6gAtAChkmnEUGhjicHlBIwBT_p6M5ad0sLA80IW_M_CBcRYm8kaZzQFucyEpZxz1VKPnQY9PfmlpS6gpiQdoOTqXuIlpU1iYUO-HlAah1AFod-xRmNFYUp3VBeVQqHNDtBwEUBf8mZCCLfBpVaQpP5cmwQH4EIuwfw25GdgTAHq2rjdH-MMAPECS_itJAIXndEDMKBkRoB4gUyCq9-aouwyxkoPDAFjPe4TSSTo0EFpvatuTTO6rz7m6y6gA9O0ozL2SGy8QSCpQYDzggLM5AT7ABHjTk53CBEjwOGWhLbAXWgRfX3wXyLv-4NNhedUTXMAJF5C_-ejQ0XmLt0ek_efxBZX1TwwpQ7Nf2uLXqzWF_NEliP2Kn4gudkaC6c7BPnl1WiB8e6Ae1awUs4fo4G5FtmPA8PBhv0qef9FqCAD5632aOD8lS6FRXN19fzeWbXSzrhBz4yTcJ8BAqbtKM2dbPtnIwJbq2_m_OcJvEEyb4UKm_TdzgJIoD4ADW5TftmwwSgMB8O57ejuUg47od129repvkq8gYoJ3TscCFJXXt6Vx65rKd0LA7QKIKIXExxNM-Y4EW1g-YWg9BBLp_oue8JGEPoRX6n57WDPj9QH7rwkN9CIWrtBKRWbuJoG_KdRv4mFgKeQB_EEIpyQkoDbO0BAe9pLIK5tc7qGWVvjRQeyG8CLcnd1v2zfbsoTExffNAvcw67p6G4CLfud-v72JvNAI8jrAPQHz3BG-2A9PwPCCREE-Bg_ng4PSUMcwh6Q89pUP6H-dyO7Tc78cPAhfV9TiAoPX0oG7t1zK-I-RkBVxLCwM3fKT4q_ogqIvAQBVm7uayVzx0iLdru4rmYZIKJ-q-ucuMN3RT1p08RddROZPNH_onSzXf5Ri2zngnmOClXKfKouG27pQExCwApk9ie_tAAAGBXi7rbmu9XbrzMwMrNYh4cF5Ej0PAHVtvqeE8tfIDLnKXv0GG_aA_AXQTzoudi40_h3dPYyfT5F_ruWidK-wI-yl_i-JBY7tX-RMU-88-MUCByS60Xd4R7W67iwEu1Mhi_l3_GHdh5F3alu1WGrlUeq-3cauhUpO61zz_PBDuwBmrak8r6HPXv6BBU4ZXl-gHrv8viogr4ugZ9lW1XjvtMye1t6TI8FHwzUxGdDxOrHfNVABYfI14AHrAFvvTiIH57vmgJAveROryvrU-WO-viCC2zpOi8Dq604X0cbYBvC9UupwNySgV4-8hmO8PjMdlAHa_uSxehyMi9y4alg9bv2M-76NEe8229H0P3UP_wS9IYGHX1lkQ8xp_yerNc0KKGG-h-RFqfcTmKfm8kAM-3v-OAsFlCk-RfbyvsM65SDGjQAoA7QQLOIQ--qeRg60y6kV_tUR2c53Xwz2oEtGquj7OUi0Pz5Eix3KfXPulqr8FuR3NfUX7X_KF1_R2EgBv8IIhV7O1vjfdPtt7W7N9h21fJXpBGD_vlGfbfUTvX9L5d_cjY7D528fDqfO9p8lgdDwGaG2BM0EHkvoW6nFl8E0Ffg5IH155V_e-LfGvx74H_aB2_5Qzvw3_V7rIm_WRzXvPyfx9-W-i_Nvkv8H8q-pww_woN30l4yAMJuR8fxP8n_9yp-Z8ZWeDBn6FqPXRfyjmMsd--uyP57iAWwEKIXCA20vBu-N1M7Lg0AdJcAP76l87ofewaxXxv2t-b9Vebnlo170b-0cnUYtDwzeB06d6FSPje_ur-JDnpb_kN983f_f-6DFv3fPfqQijAy_ghgI-6XvKCZenENl65eV4pdRZ-VLkr7ZE-fp3Tq-env7512xfuf5aYEAXF5Nelfk8TP-CGK_54BZxHSw5uAAaOJABgolBQfGQNoyCVuCfhKBJ-0buIROe8AYf75-qAaV7oBWvtgA6-rfvKC0A8FBX5d-UyFT41-iQMtbU45Ad36jiZbuUy8EmLuwE5-eiJwG--2EDwHW-fAUH6qoR9kIGWg-bqIGlunvqwHiEjAa4DMBIDKoy6E54D-hZg1spS7ecmosVI4geIDpiqoo4CaCwI36kSztADzEhB-gcvgiTKBiAbn79E5vlwF--VvhV46BjzpaL-BeuDAAG-XPkYGgI4gYz6SBZxOb4oB6gWV7g-zfqX5-B6GIkEdwnYBAB5AWsp3QY-WPlbaqu8vAkEwUmQCwAVBYnh9Be-9fguzU4kQRoHRBxfoUENBSQV7yUAzRB34sI17tIFkU8QDUE9-dQUUEBBgwWiDDBSQYYE2CnVO0AAAxMNbketYO0Gae9qjkEn--QdoEt-ugfEHFBMFEMEjB1RpUFPu1QfLDPWswQMG4UQgFcFcAEwIDadUkUKQHFEMti24UBvfluIKBGavG4hB6nmoGHBAfgUECBcwSUErBSwBz7tupgQiTmBlgUywc2qfmqw2iQQQISghSAR0FnE3QXkGQhxwYUGYhGQMkESBNwf0TV-GQUNRmBA_rbaKKHDqdDYh1OCiHJ-5pPAE52iCHnaEiBdq4iA-oQV17Q-mgZoH12Ugcj4qB1aO3jZ2XYOqI-c0wWqpJEeovMDR6PXnnwrGSwJHwJGNRhwa1q5-mj4NqDuNlbMGpKjTjrWRVq7adyeVg8ilWhoUqrTewdoV6je0MjFLaQ_pkhBGurPPxDwA00FMC0MfEC_Du2vwRN6qB-sqDDD8D4C7bM-FbpJQGqGso7hpSEUAyAeAZ8LYK_BKYWmEnU9gCeZvaZ5kciXm15rebY85otnTqyfQIiBA8gsGlA72wdIa450mYb7DF0OYccinmnHixYFhV5icg3mzgGGDWiWCttTlhnobeR-oZRsHytBHoZWExAsAKFDhQaUFDDYwRkIP7YufNqoEdBasvrL8ePXnWQ1mSRBrJJ2y6nWihhKeFd6E-x3rjiz-JPhJCRhb3DGF8sg-OdZ925UCqEDSo0C2HkEeYe2GrmF5l2E9hJYbjas-CFkhZEAb8KfrA8K0M-GphvsKI5nefBrKBQyQtOSI3h1eEOGIgTKvfLpmV-nnqCOqoeIRYBgWJIp50UTgRHuC39k_7EhmRuISNh8wM2G5h8lp2FFhvYWSECAZxPNDnMzQMxFkg4QCEDMMNMq-7645bP2FHAeUtgCIgp8CFTCiX9rEzHh-PrGpPkEDJ3SRQCkU-4yRTVk-4WAoPFoL7e2lNbZfuhATbLqRXmPrRjIZoXEw7ee3kT4CuYvjRG3-zEW-BnEq0I6GCs-1vJGQMXwXxiWhhXlnK5B6KvzZjg2cnp6kYfkFcQbYkYYH5WYVvgeHJ2G9KnYHyrnEFbkGsoegDLGTSP5AwAioaxiRgpbAICpRkHhlE6hTBjpqsGBqllZ6hLagVYWhKnlaHOqK0tkR2h6wNlG5RiIBlGOyAgBfauyjUedjNR9wbHKsGejvd75gwoE1HpRPUWK5yqZETNJCkEkJ1FpRioWoSiOaco5AVhvTruFYgesstGFEnkQpJqBqEZrJsM6ADuHSuS0Z6FSBejg4FZGYnmtEOyuTpfb0woruwoHY4hOdYdexLMFh3RkXjMS7RTOJhHU437hrJq8oCBn5cA1eE54Oy-JKQhHOkXoBSnRpqmnKmyu4dbKbRVUV5H-RPkYV6WyuQaRi6ACWpGBwxFlPRRSBYCrFH-Wh8hKj48TJoYy6ghuKNrAqE2hTGP6UumnYjYqoJWIbSakmOAh4IoJQDg-THA8xZAnsAkhEs5lpOEwA4aiLGcxEQM4AAAiqYQ2WBoXo48K1AANqJh1smDCRI5IrtFixXsN0hGCcAMhjuiu0RLEOsMsQbDyANgoywgYisZBIpAxhKYQSQCIMWDGEzWt6z3YR4qIy5ciemACJA3ClRJKxMiEuRtqXMUlC5eiQJhRwAX0MkgrGaULJbLmX4ROaCWu5rqDzmTHpB6seXaIcr3olkM0oi2VsQNq2xEoe55E8atgLE0gm2ISLwYP6CU5KMk5HEBBxIcWHERxKxoHS3keTGXHZOfUdIFQ-znIAh5A7AGIASQekIZiVuArP-ClwkrJGDFA41OYz8R7ksdBkoOQGA6ax6AMu4duJcZLAIoOph27I-gpGcROeFgAV53u5otLbLkzcdgz2qYEYLAlOEmPAAVxxFJ3TD8xMm0DpS5IpHz4-j8TgjAxndEvH0kx9M3EJal9hHhXxVbq4jJ4OAGPH2qgCawEExLXs8oicPEK7i0ARsabKIKjpAVFlRBuvLFt6vRLnpWoCygJYbm9ESJbw68ypxbcWfaGXoMaDspjIoJD0cVLrRnoZqqt6gcREDhka8QsIuB_3KNK9R73GeBIJAfrzEIJWirKClxw_AHEqabttzE-kbCSwTCJQsXJyCxFSAkCRgtcSwlSJsiYrKzAm2DMC44uKP_GuyGCcVBkGrahImsJ6iTIks4ksKuAtxdAJtiqczGIIkwkJiRZQdx5obljIxhml3KrScUU9EqaTkb04KSLoYHR2J8CVkCOJXMdt43RrsiomSJoCEAl6O04fAC2x0ccpZyW-YYxabmCsLeYzme5pYApxLHp3TQeK5kBK6gIEg0B46TxNEnPWD8STJcA3wSNTU4w-F0AQezkFiAix-YG4E3MatrtGr4UwCTYM2YkAHDLsOQB4DJARsYfjUAocYvioQdgLrANAkzj4zN2GsnioDuYDpUlfWS8fIBbOcCXzHIMK7pdRbReIXsGdBH0BuHLRPQYsnLRUYU8S7h8blhFCYP6JuIsI1nv0kwioMAklwAtseMF0UdSWcRecw3G0mNsmUi4E9JHjN0B5AhTGdBpAqADtg6MQoEkCmC5gOLL6RdLKpFXeTsnk6QxZdk37YAcSRaQi-z1t0knUayVbZLxlblZROh20euFox2KVgCWiu0bHYXJDCeT5xMByaHZUpEIRgHN-yjkfYL-XALHbEpgAUsnMp0kT4zQ-aUNdGE-Y0lZEc-V4asDhJ6yUKmkY0Ptp6eRbXqNFRg0Vlb7W28IRQEdue8a54IkmWOIRExfllIRkx0MVYl6Jm2IAkuJ8KqAngJ6eNoLEE5BsWpKq-ZIkhFkUuplH1S_8H0JjIaCelasGw-MVhIgRYDMDJAr7sFSiCKVBwlWAhILcyuMvSZLA5ALAF0BSgOjCMkxSGjMqwuxWYMwLC-1ADoznCXAuxRaQFLkVb42UoNFHYJpuqFZKWS5vJYUJduj6kP6YZncmRoelppZ7oZ5k2nkifqdnBi6ipudE1kb0dVI-kVjt5j9praNQnQUfGl5iTpm-rD69U1FMgIFQnIKw72h-aAPbywx0c2hNqpoWEy1RtoXFGS26RLtFf2PPvBgESwKWS4IIFLkwJDRXUZ2zcRyUimjSMLLugwROrdpumDROUU-kZR4qaeFaRq4DQnaC40l9atJQIW6TdQIrjunhhw_NbbRhaaq6QeCkallGPps0eqkj8PjpwoS62kClH_pWGWagzReUURlRRFMcEk7J3QE4EmgDgUATnC7Nqao0ZvnFWTXhQGWqjSsoGa1JfWaohqJp6_rsgIVEsGbulDOCGVwBIZuDvASoZSwkeF8ZLGaVQ4ZieHJkRJ6KZfaiJtqWAraQ8oZqKKhoGSFgvhaoT37AxdCcHyGZo4tqEWpO6upQlRxoegmHpuKN-muJK4dVH_cyvno7Hhq4f-CBJPdpF56SfibJE-ZImX5kXeSAfrIreSqk4mOkHiLKgCJtmbWTPeXDFLptJeLuYAMZ40VZRKSKmW1EYp0PiU7xhlySSYg-Y0WFQc-KMlBkxkwmeGFLxNglBllhyMZSlHJpyZ6E9B38fKCR8sdruGlZ4ES55GpQUKtZSyEAJtZHWdYFb5yRqZEdYnWZ1ptKReV1uGS3WYnvllMps2QqnLRMEVAAiZV1kFlMOQqQtnVuGES9yz-0_uVkVEh2TLyR8qjsrx8p2jp1RLxf0qKkUBgGXDKSpd3kK5sZPXjDEyBHXneGKBF9JP5D2TYSR4jq78RgBvgxLK0YgJeiA6kK8uUu5InAfsK-kBhH5m-kkZAUJoGfgSIbMwgQYNui5qUBjFlBbAuwEATQ2RIBkA_oOQK3BGxSwPmn4gx4BxLzgVLnmDv4lGYInehkANnDBhWLrsJUxU6HsirQmwP6xE57kvIyvpzOdEAfiM6ERiiOhsRInSxdsRlwiZc_jczHZ3UFiAK5yjhdmIA0STcj6xS9uEKlEGskbGy5C1Gi4xk0uVzFG5tWb466EhaYwLNAxOYwyKCtIFvj-AiaXYzBAoucgwtAY4D4lO8AqVF6xZnuS5l-5cADFlqcVGegDCcagLRykpfcRAzuRAhD0zUh_wZAFgBf_h1BnEkBH7mh59iaElwul1JnmRZYyNFnbJgiTt7aRbUkvHF0pKacx1UhednDF5Aef-DgxYeJRCtZZuZLEyxOqbIEGpDLD7n0M4NlYFB2i3kgwjRUyFfZ-YWqcZm5ZqPiGF15nxtnkhJncopmgKXCh7kwAfCY6TKJc-Q3lh5gieRnO6KdqanlI4-ZnZFmpSLhKA8ZZj5oTiVZmwgEAHgNUCGw9EBKxgAkgA_neA0EndxbSMwMAZBufWqhDPI_musCm0sANIlhovCRSD96zjMKBJQOHI-6yEJMppyuAYaNpAzkTSKiSBC4oBGBOsSBeAVfUYKG5A6UI6rgXnsMFpIBwWNKDLrBoSBdBKIqWGuapR4bGCqoyq_-RVp-KhWmEaUGqytqDFKt4i1oxK3BbwX3ialltpuQO2qcrsy_Bf0oW6asJIV3iIhXxBHouoLTpyFMSkoUqFfBfIVB6F0jsBIFrBNnDImUnpBalhxUT4wTGiYXQXpokEvZiJA0eHIrsASkIyzUEZogBEnZxhbjZjcJChmQuF68re5CckSZth-FQCYg6bG0mIhhnEfhQ2RZOraFQDCgOkPzEDOJjiOHHgdgMC4yEkRTE6eOQnLEUCA8RbQB1OQnBMZjZhYCQ7iE1BH4ChFKRZi4ZFiRdkXCAuRay75FtRSeRhFrUe1GbY_SBMa4pvwZ0WM2u1hMaKSIoGSkM2x4IMVtWvRceCru9YdQQTF3QMVADFZ-MMULFGADWFZAExqu67xx9M6nTqkqkTxuW7hdQDaYExuTyfqYMAMV0FAsNJi3oB0RlgwJM0vgW7wNBmjg-FH4KYUPG66qtjv5WAEc4HFFcjWAFeg-DIbRAVwEIagwyYC6YyGqGqCUg0xmK4BKGwJaoYY8tpquDqGUJZ-q-2txazFsQuhNBj3Muef2TG2AgAe6RO2cP_jjY9xWq45QaBUFqWQwoMSWoqwPLnBdgEHAMbrWfBvECSwA3uYWLCiLG7ZWFPBAAI-m9hU4ZWZejlnxmmtYECUpijQNYWClKJXCWYaVwBaBx4USLYUolEhqhoqlNhbCVKGqGsqWylIkJiUrWRwGtbjgm1sgoHWqxYLBVhY4FcUPUw2btb2lnAJNlxhPjLMVWlIPLMXzZYVO6X9FVxXQXK2_pa1ZWltpZMV1hsbjnTul8xVcWLFBNMsWFZsxZ2SiOtOB6XeGj6t6V65tCmvi7WWfOIYvE0QNnS5lUpYBkc5BLBGXUEKZcVBFlCpQWUE01ZfCVtWtOEmV8Yibhm7HAwPLKQN6yzBmWSe3WMyW02T-Gv7dMdaFAAMMu1iNbEso5XOCiyEkMmBGQpDoanLhFZWOWeBeZcoaFlkFmuVtlU5cQTTFI5QwxVlm5aiUpAG5ZQCKGyhuKmzgHIQlnO8_rLHBRwksCcKbAh-BMZoCruIeFGFZ5ceUQMq5ZCVzgxUMmDYwSkBUTaQLJYOWOuHJev6rgBXmeC6gVJY0g0ldJdEAXxyBcTz0BM-bsXmAvytJhnFQZW7aXFoxWfgumWfJiXt4HPO0yzUjSG7I7AnRAV6n62qugl5ZPjOrEahm-mfCRyrfJ-od85NGZkT0pCrW5ahUjrRCrYjSFLmlRhmmFTTygPK_HXe4PLjhQ8r2ZwAIE2dNuqD5E0dE626hWYhHV4pmSUy-w1ePm7V4_BhjzcVvxBriiODqJIj-ASBWlAOoVYUrnfZy1LeXbA9leg47x6lc5VWVHyVHGcEUccrm5AflQnRFu3UMHxfuv7iySNIXlUgXZ0CZhHmvW7ZYLDiEsVdjxPFe8tSUCG2ocuE_KSYVcCCFchcZ4uWBqdNSRV1lVI6dUr0iVXeVY0ttSqVTLMmUaqvFvbhIqMqvRVVqTqoUQskAOZ-gvFoOdtTD4uJWmn4lglPvjElqeLEAs23QFcxwkOQOrLHg7ZXE6Y5yRs0TmALmS6o9qUxD7lxiZifunBo0iVOSahw4MtW8VpfEsCt5f-PADvxcXNDy9ZAhGwn6ISiQHAKJ06ZomNoOiTBqTk4eLjhGJ1iefGZAIwNQXgRtqe5mQFNlSaGXEEoFAWPJsBWBxmof1QDWXxPwXimRgmeSDUdly-bEy1VveY_58QcNY0ig1qQIgXA8yiajWCwSwKDAFJkBpxBPEQtl2WYAR7v0RfoaxdJj01MhN-7nVGgQUmEMmpCzUCE37jIhRAPNbWCF8iNXo4PJY5NDXPwaUKgUEFlAJgVn4f-LOBIFLbq4D_VeNeBHzJ7xVYj7pcFRNQIVn6rSVElyFbjW7w0VSLVYJk5Lck5V7ADIVCFLWk8SxVrIbEyfxhkZHxXyDxVfCEFz8MQVE1YtTAU4cInjIRZ8QWiCUKGJFdp7HFqcMHWIlViMkV4M_RIREyE8ctTj6KeanCSqqzUg1VAMPecuT1h21NXEk0TcVkFnxbcWlxA1SNXe4uYvcf3HsAg8ROUq2CAeraR4fwZyw9xmxqbhbxhceYCHxuNsfHfJKvsXUoV3RaaoWWvxQRULgkdZ-oGwJoWgV6FQsMmmD1jLptKQWqVToXbAQWgvVPul-nEx_KNtflXaeDtYp7SBP0bEyu1ngeaLPJshMvWfqF9SMXj1LoEFrPJCdfHUdu1BMZVWIplZ2BLFQsN_m_5C4K9x6pmxVkFWpjqbjgjxYCULAQJGeFnUaRackkCbYuOCnV_gkyC1VuqZSSNg9ZdxeWxMQexGgVJWjSJqq2WUivqLqFshZoWRWDGr8r4N6ZpIq9Zrqb0lS6aBZlEEqjDWUY3-HmGlY5WA3iJQsNJoURT2Z4lG0j2VboV2CUu3DGpG_BzDRJSD4kjYI0BFgoWgXBFZhVQ2K-aBdbabV0TvrS4NJlJo1goZeYNjyVukZa67wT3giTUE3DV9xvWCnvG5gKlFbvDyNjSFnUxu59GY06Nu8ACEFuCdH9CqN7bsSxb1z1PqK71ZDR_4uWjtTEyb8MjTsDap2nvm5bcXjVjyGVq7j_EY5J8RhVeckBbUiBEJNjkA8UmkK42dIcjeY27wJTi9IRNTSNWSQEpTT1yE-EPO9wKVxdIU2RNk0tnRgKWGDg1UVDTS5VNNHIcPpn5GyDLqUFbuv4quIgSr5oW8bCDTZ02CIN0BDwi8LYikIu4LTbKMAUHXATQEAMhgLwS8PM2rNyGCCjbNd4Bs1zNK8Hs31eW8MAWu0oBWYl4F3-pAXiwUNXAXgFhNaTVnN4NKAVEFJtYyVfCzjL_UIYV-LFBkFFBflowANBfuKvohyskj5KLFgeY5Y4xp-bhwlEjlHBoSUCbI4qPEpihUFfqEM2wt9cHQWqqcSOSBp1LBa-a-KV7BwUj6cVoIWSI54LtrdpX4QIXagPBZS3Ut2ll-EKFUwDbWMtlgDS1ceZFkdpiFJ2kJpUtnLcy3ctVFqy3sAghbB6vioLbIWZJdLTwWStsfvYAythFrFamqwmiMpbopOs4BawO6TErqtompq23mOrc4BitGFhy1ctkLf0pmtgrRa3jmYrSQ0CtTLYZa0t_Sg63mtwrQ8pSWfEOy02tHrW-JUaZSjRpVKnMuco8FH4tqDNat5u_41g7QD61OtQluJrjKgbVJr5KIbfcphtqOpG0mtXrWy18tpyu63doW5uRbygcbUK2FtmSfa3ngKsJpaOtZbcUqZJClu0C9o1bVrC1te6EW3ZtqrSBg21dyhOg8FHbby3iF_qum31t25mK36t7SmuaJYLWn2h06RrVW16tomhq1TtzWneKztWrTq1ittWlS1viE7WJpYGa7TwUbtC7f0rbtCykJpLtBrSu0ztR7fO3ywzyMYCmA5gEYBpVpfHv6wA1MrEB-wkDOuBlwJwtJifwRwPsDfIpuK6B-SptqB00AXkvACugWNs-V5SXgmCDPt7APRBlpPoBYDAAhnLRDScXGuqKT2t9YB17A7RkcCQdwYS-2odQsOh0UQWHcVJ8VVgFKQwg81BjZZgcHR0aII37r4ASgzcN1jmAhnLIKkd0gs_AGyyHfRAAlNHUB4CEn7XumvuGjMPwcdEHTqRPla-EAGb4sUpAFFAvIGYDkVLIEjRvtv_lJ3wAGdbDQ_0x1ZjSl1duJzaT2wOHyrXhGND_St04NLbRt2VnTqRH6tncZ09Wc1v1a1WqgF-2sY8WVJyWcpfG0UYpyVlHopoagExUUynNDZ2Ma9ne04c2ZhZzRudcXZ50I001Ml0rF1dSCzWdwZe6QxdwZYwAbeNAMDjcS3TBgB-doBHkBh4GEAqaMh2dQV6-dzaLhqPtGnaGpTIwaD-XjU1ApTYy6LyTgAadbXRR2ZAcoBRCUi2HftlAe0NulnkdaHaN3AAlaQQC0QCSY4BxFjRX7Cj0ZKEWBrdFRn7CtwADks0uSZKEN1zdGHeN2HVwQBJ3BSuQJLAsIQxstUndlHfN00dYXVB0GdOIDYAFp9-M-UKdSyHRCpds1kSA2MwyR0Yotj3SN1ndO_LRDB8dgFd0vJMIBgABCUHYui_APkggzJAiHSxEidp3dR04cy3aXwyEQKTJ3wd7HecAMFAPX2CkdUkbN1PdGHS_z49ZnZUIG4z7rC4SQJwH6HE8mDCODjUCjIs3027yQgyUgOQGyae2t9Yx12w4PVR3AA9PbcyRClkHD32orPafidg8PS7n6gosAUriycvS8nwhbBN8inC5gOCkMMbkAuDJMUcNGwOIFUuR0AlbCbRAK9tYDcxsJIKXAxCkiDOXFQAZOfmB5M8PfIzMqM3XyC54VXFNDtdlnGSjhUyEXexkoq3Q0W7d8BRd0gaUiqXzvdYaJRCmZFPd-T_wr3R-ZM9_8BEJRCQdJ0Tg56soKy-eVsr8QddZKFuEsqlxbADR9eRegpZ9IeRV3NoRmnWihVljVZoZk9dWraBsTdbG0mEXoIj2y1yPYt0Jpr6a4DKC0AJeLPEsZC8mDGnHQwX2RopaarzAr-FHDSJO1WSh7VafVMQCwJ1ZJQrd9RfX1x95QmZ3J9mQoz0Sw2mHn2WQTCT4yZSUyBv0SQd1ZlKNopvaYLmJT1VIEgYw_LtXqJivvImlxzdbfElOD_YgjSJP1WXEq18Na4BAJ7vT-gICCbii0Xy6EeqFnEcNWSgkFhqZZlsq6lAV6_9W_eoktdJgG11lpksBX3zwkDGQN-wUglpQJJpDDcwQeiQCOq4YnYMkAjV0QAN3PtkvfN0JOUoLRAYDsADZW4ez5X9Xw9kfPQrmqOQNS7YM7KF4HPlq_Wb12AUXLB1HALuTczq9lgJIDa9vtUcAJJPAxh00d8QnACJCgmPEzKYL9t93UZ8GMUKuIXdOVLMM13WIMC9EUucITVQuAc55gjbNlLSu_YG83-stYewA09EPRRCLdy3VH1H963bD2vkW3TkXH9dEAd3hgzkPoPY9tPbj1gctEKZT-D2wMIMfQkYNrGsQ8QIVCNscQESyzVR3XNUCdpcNQJQAZoOgDJAfvYSWz9CSbnA74KxVgzxpgQ9b2d1FEHwNLd9vR9BMDLA3UPH4GQGkAppwPBp0B92neYDUDFAxtiCDQLYyVFgCQokBJCE-Tf0196-ZEOx9ZIA7TZD0VSORSygQznQ39qeRmSJ5GZtAOYDUjh3080I9BYCQEiw0gV10Dw5ODXDQg3LxUmdwwVRvDkBH0NJOKTs8NfDoNIjEC0XTATQFeAXVYGKKtw-8P_VNw3jJa0YMcP0fmjWLnWiOiQe4C3N4tXAX7p4NdiPQFAgBLVAjHw0sMI1oCnCOXVStViOQ1uIzDVLAAI847KJxGKYPHgDNNQRMjyTmajahddCdQTlNVT0PQjaIbYJTOBw1SPnNWiuKOCw0rBIPeMqw-sNHFEQzt3mE1_SwRRCoKvsNe17zYlU1gNhAV5DDOo64DEDT7UENpVo4ZAzddz-J4Rz4sgnQN-oBg-kPPwE3T17RDEnfIh8QM8ZgK6SIKW4Pv4iDI0NcmD-KvCbARLO8mOjmHXj0l2h3S_pxMHowcAcR3BId1z9wBFt0oyXQCky5F2IHYBejWCq4NBA2TSOABjYPakMhDC3aEK0QzDaXweI5NOlAFDvYGNI0CsQGdA3hCaRowcChUDJ0MdVPW11NdfsBFIqdtjIgx5w8tYWOMddDOYxdD0w0H3tMIBYZ03h_8IkNTNL-rUZeN1Y9zG_EaUJuojkdFRw2mhUXZla2ZElR5WoNjVTi0tVWmjJIWVSwStV6Ga1VVYPdHlSvysY08jij4AMun5weV7yXeAvRIji2UYRPXKpmuyk0ranfjiQIw7iZZRsFjPjt1gdEjh2IGJ5J12dmk7bVF0ZLIATIXWpkYRijU7wr8KKM3ASQMEzeGg0mPeo31wjfXv2X9LaGwzqjt_SsMmDaw2YPCV9cNBMfjiCPhPfITnlDg-VC_eshTIHE6OL-CqIy0Xgy9SfvFJjSQ7a4YtcjUuNlowaLil_JBOTtT0DcOXYDj9tQ1x3JAiOdwLs5ZxFLL0Dq2H6g_jQDsRN6NNTfMU4AaGIpWyTiIMGiWT4rpdQvSCSZW5F9oCUKx-BhWPD0i2Nk1JN6IVkx24GTh9cgSb8Pk3ZNWTzyY33vdyKuSK1kTxPqn2oRk-BMmTGEaDTN5g2GSiOeGI0-6uTJfWnjtAFkLAQvJ3kxJPLjZKPZPCp4nmbUgYqGOdUU0Z_c30LCB_muNmdNY5uM_DvBNp7zQREylORMjuXxXvd2nrE3_V64-TQRhKU1VNJd9U7QLwArUyr1s9ijId3HJtYDVPwgdUz_RN900yf0jEZU5FMNTyLVIM_J2NdPCEDFib07jU8w0tM04GEU8ShTO08qMx9qo53S79T00n17Ts08fXU4ltcgSah4dSdW_TVE1tPZutE3FOHT_RK45mJVXRDEJJbCTDExDFzadOQDnmH70XyuvQiOfD1YXLGPRT7gkli0U0353RTW4z3DIYl08-47Tr05tPRTDCDxDIVu05tPvTHbgFNlT8VXMOh9h8tp7AjTzYZHGDbI3HVhNwM-zMlTck3dO19Ow49OGROMycMOeZtQfkb0X01bWlt7bZknPJB9XLNXTPXkyrID109p4JTvCNp5P1idY56_x2xfUkv9SieDOnTaXIjNAJiDfi3INDBUZ1hq2oFnW4KQsHvBkoSLdFN_BkzULP0o1Cc5OQ8ZU_5Nxyzmu3itdyHXOM_l1gJIJ0CCaUxAvAnuSlnP4atvQPyMK0w4jk57oFpCoAPcAwxbiBTAwwaMqEG11RzrgfAw89nzFt1cmQKSCw6MKeVpTiNpo8ENS9YQ9GOSTnXTcw-T8PUOIcIDDFgCJAAkNt25FPXTkBWTUw19ozD5o4fK3TsALRU9DrVYwaMVHcX43Pu-ohK3seUrZxbKt54NXgH1087zNIT3Br_4OUpsh4lWwb48-OiOkAcfM-kPo5arWqzI1fNsTqCZpEcZVpCBPvcj827pzZ4mb1P9SqeV0yHkuukfNPzYyLpIC0zTVwpzjZqJ_N8TN8-bhk1e84XwYNWJWHNmjXQBSCSwsY5Awlz-5O0zyMcczcB5gic1IKI55jCnN2ArTZ72twWcznNzgec5jBkLz5UXOljUvTR1WT_7fPAAOuQFwBDGp-Bgv8mmnV233Z_C7GNo47C8FZENees21UtrbQW2jtt5uQ1267CzFZ0NI-dFOiL6UBIv2oATXm3DtfbfIt3m57GNjcUvRr2y-S3vQVJC51Al2B6M0-Otbv46nYH2TQFFb8QQuL-gbVj5N4bPOfSP8gxWBpmCYgJXdILMVK5w8DJ3PhjHlXvOsYp85kRvjUS3oqQLko2ahjT24V3kxjfqAeF_6rGtpDXzmAmjjD8kg2tOedOoQN6_9BPW9k9-mPbjPrT1aRbW1puVfS1ttfrb2mhNGkd5gFLwgroQY-OjNEBZs-INTmyCGjL91U0EXX52gpDuX_N-SGPkR1qoU1AiSQB_U3tNu1nGhn3vtosXtNLTOHd-QzEZS2Z1DU-ZsyxSBFZV9Yp5Q5ZJQ2NriwkDuLwoJ4s8ZyleXJZLlBpQvS6X89j7pQ78-w2c6rBsvN_Kbrb63OtY5i0sX0P0QnWZYocyQPIdpNIgjk0dHZAyJzwHXoOM2AnVlCD6pCvzllNQBMxAH4AvcWnuDfvW10jJZDE6zXdCK2L0uIfhOB0_d4tPEAjDoanozmAbAnQkRjNHVsvA4DgKL15wFoNoY3481DJ2jh-Y4znc9ZlYx3527Ni-3qDvHThyDLpbAlVlyz7QH0O8E81CugIMK6XwOzvGjuNzze40VEBLbBuJU5Wx8cvwgL2cMVbWhsSzLrvjry7pQeVfY58ZJQXYMZN5LFEHY5cjKTs-M5OQE1wnvZtqUatWrKKrxNoc2cCkssqE4bdzlLAazFSjiVS431kT8GBU6_-iy5tMNuxq7_MP8ia351kTBKmsvpre6dPV6djue92bLdnZ50zEMa0WxkTtq_asXCNYQtOSTS01msJr5M350zEca9mtNrzXeWtiTpw3tNVrQYujUyEIgiI1q2jQ7aukM9c0LnNAoTnEAP8vzG9PguDq0lOgIwa7Kou2oy82i9r6WTITLzYRDotDtTSwCvcyAbd0pTKlgGm36L4bVm321mla0vPOWs4ZGVrNix9NmkSTYuXB0MMX45JL7SYWCjrEzcmUATlGHgDvdVDiI13zjjsyO2rwG-gCOrTfGFQLjAG0BvzrEef2uKKXCmcRQLoGbpLwbc61WvoqJVuauDNUS2wzYbC6_150h9XYWrU8EK2aPign0soNiK5aFuI_oIBqAEoyrcBXOwAUsYyAMCBg-WMuitEIaoQsz5VOttULIL5g8b53QkmcbGQMkCCb2AsL2TrEa99DD8Q3QCUtzkSHADnggoIaW3MlxOQo0TveJLC6bbCowUFTGAN83_wyEXP0n8PEmPPklUwKrArTiQA5SBWWQFsNSbDApRM_09du3GYJP_axl3j-G-siWrsC9at6OdBfXa2VnNN5twAXOIqZn4EW6thRbzMEM4TOP6dbLmbrDQASurZqGCNyNXix3F-bTq9bLLrUYaI6uOD5f1Iv6d4B5CCzzkIZMcbXG4kDlTz1SNJTkHy3hFfW7yWZMZTAc35Oyp_kwAseVE_UwiFS19qOHVOaThVtpriUzVvezlYfDLBkPW7U1bd_lRLNSOUGYNuYjntt7YmrFS6OKNSUkUjXDbU_dNv0oyG8Ak62Ypp13VOk_aNu-TQzgl3U46W09wIYkMy3l6ToPmcRMbQbv6hBuXzS9twAV-LqZXbTM8sOSbjW7hsigMQfFuB-CdmqhpcIMT1nf9e2Y6Tmb4oAyCnQrGM9vMbVTcBl8YoGeZvcZv3gDsEEJO8rSlFeozeUvAHHTcxkKxm3YzE2RLK-7JMxMjAApMwfax1saAgJ1xQMmABVHjgcAEZtqoMUi8BcCdOwjZE2YQEztHA54lJj4tP0ADunUMu4hr87tzAZvr59G1j1OZtgJpunwC1dpTrWw_GjvwAp3KrumbFTgDvhZ7bP4DFoVAH3gWqhsj6TG7GOx-YvzUYATsvbROw4Ivb-PvplQRNkaNCgtJSRC3jm3jpaXusC5WhnY7P2-juncxRfiD8jFwxptabyQCJUD5BsOWUjlTuwDux7mO8Q5s-FRJAQVFtu22z-pklOxHBSB-OQxI9SOScSI2cu_PDWyScK0zNwD-M_ji73yOjiTVZbG-5uCW-j4iqcXHY3JHA7Pe0DtsvdIUTcUdkpxA9djHWJHB9QBN9vPcf2zHPdzdgyQsJQ9u4wVMCn3fiClD2AlMAu94wBYHo2_QMy4iQVBILua7tlTRTojEZYPgV7DklTY3MNgIfsdJDK5vtyodgAUs3dB-2-kDgAwP0AX71gTtSvpsndns47ue0jmDjOQGvvP4-QLOCcLJu6dCO7xO5AfIHbVsXuf78O-ITzQ0ex8ZQHVTXy4e7zG17sCA3zb7vURr4RJBB74LRgbOAgdKgNjIzu3Huxb9ScPgOSgGnvL17MQPLs17rgYWD5ACSHelc7JjpS63dJjpdVEbXvSwKrAliSAcOSMB8TxDIIKeoPPh5AMujjQQpEvtCkjm7UZuMtO5ruXziu3tssHp0KTs47gC1Apk7lpYnsX0ye3rs376e2WXn0fVWNTCAuwBZpVzR-FS7s7t8iTnwgcAJdWy2muzmNDsz5bd0872THqpkTHe9XAZbEkDoe47HGVAq44HaBIcXVJMiNkjWZRUeGa72QOZvgLxLGqLX7aezjk519-xEW48CR4ERrNd4NYc47SwKkcXQ6R-zVkB4cYhpC7_q-buFH5OxLKvrMI0HRDpby0bs57GBxurvW80C1hhuox-gcu7-PgAQAltzLrvabJR3ptq7nR5ruRy1RwDtmZQdI8vSgM42yYUgAgOqT_0GIhbs477LP8U9DOCR6iXtk7ce07pQK0LQOHIkCum8z_uA8SXiXR05houBy2pQHHRoEceU2vdN83oEDlOlMNb0m55ued0W94tSq886HiFRGKgVstWR4wauFEIGJRA_7Ouyns0Tvx_pubH6xz0eK7zEw5uNbkJ1RENyJTGSjubapQiRZ90W5tuZlemdDzlZN2RYbnzvdAUdk7-2QERiZ1mgiTbrK83np7thrdq1Vthi5dQqz98Ygg3rCeUhF3LEU8fyaeSp1bbvJ1m88lUHTB5QEGZ2npj26nlq9OBxTTxHid67FSd8cP8vx0zhX75CqnnVktgOru_HqeU8SP0Px5ru2nLpzC5yYndKSeNHu8Yju7llR8KdcKWI6cc8nlxz9ve6EqhRtktpqo_S8KvJ8xsLS7NVIfFSBDSfr8aYpw8f7t07Ye1ztkp_LCKLrlnVJpnJMtpgR9JikYucFcVuGdnHeIjCQPEyZ3_lo4Wi1bVntu7bmdboB7eu13tKi5rqteUurksWq6UASrhkMcJ7aqrAdK3K1LWUFc1EUrim8VbVMGOGTd4c4rw2cGXcufPGrF6RTHuhogmI2zeSnn9BZZ7RYKH9eaJ-RE9eivs9a1JHlSJQvRj5z6TrnWNMRNhUz53kuOVQp8QK6EYDe5PaQBQFX0nexqVwo5Lxqxeeg-g3vTLFrs1nHJZTCeXWifnPfinn8kp5ycu_-MZOOcYXjuecO-NXCuNRuLmWjcuIIGG_csDHncbtQyEyF6OKoXnjdQHJemF28MWANF_gDICaFwxeVLyAsxdd0rAM9YV-6DuhdW2AlzxesXB24JecX-27KJ2Aol_rR3nN8iQwcX8lx1K3yNeQOt_niUG5Ol97QGThAXZmWLEzQfko15G-q45JeprM82cQin7adbW6L-6wm1kWV6yE1BTSlUNN3nT69TiQBrlzhf9SzyfgIIBz1u_zPJFfl5fCXXPs8kHbIVz34HbzyafJaSkVzD4KXnx-J4vrWNYMc3VwFNGwQ1GTRNBZNLgesDZbjaHJcvnzYx6vZZl9jReZnWM72UVNQlzy6yVlkQd6GN9tKufYTECxLrPLI52ywVX5F2lc9N3ov3x9ixZlAC4UP0vch6I5otfmVm4EHbj8AnXPyH8AVwHphho_AO5YLX7APwCEAtwPcCPAf1aeBsgnhLd1BKYuJECSAVdjHzxAo-KQgFA4GKHg9m1yO5bGwxm5ICqw-wPiQEAkgMADBQH5lmzbA8gB9fkrMAPICgEHgGACzQf1dwBTsXkOsD8AfkEAdMgSAOtcgAm13cAPAkgLtf84Y8AdfxayYmRinXi8J_CQutgDYCzgN16IR3Xw17DcvA58FEBPX-wCQgAHGSFDc1g_AMo5rXg-CzezAhMpdW_SCN9tT8AqvEDnAyGAGzf8AFg2tf83vVBaCC3uPPwD6zFgDDfFUItyABi3CNwrdKSst9Xj8ARtErcq3VwFrdSkGt-IRa3YKDreCY4tyAA8U34EbcgAqvPvhs7Qt3Kq83ot2beq3Nt5Ld23wOY7d2O-sytd_WqvE1YI35NQiSUQ_ALUmu3FQLQAJAVN15CI3hAebduAkd017w3-UNXgh3KgI7d63ytx6a4UQsDHf8Acd67frkwpr6x3c_ACnfiEad2HeZ3-kXncqAcAFT4_MCN91Jy39cKHcZ3iN8TJKSAKDzdLAod_XenwrEGtfN3qd4jdV3iN5_ATAocWODcbIAL3d13Dd4PdN3sLnY4umvt_I4_SItwiQw35Tpvf9E_ADlK73MTPveh--bmtdB38TPGztmrgJGBseHHlx6HKPHih43gORjgDYw3ILPfael95_CRgVmL_eKAORyACd0E4W3gzE_AAMGH3e9zoDnBCwS8FJB1RmffaeUMM8kQw2MEA9PEYD9A_PBSwaMEIPhkV_fX3f97_fv3zyfg8_3_9-Q8APaD53QYP8waUHNBPN2DDaekUJYLaeC5bEzAP6YcuSa3SN5GcQP1ODQ-JBfDwIQCPFwYsEjBp94Hef3IAOsG02YAEzcX30j8Nb8AQD7vHJNsZ8td0wYWU7d8YMN1kBR3tAEI-I34Y5I9I3NwCjePA_pH6hWgIgFyvbGFoJABXXs4BaB6YUMAADs-iHMB-QIgLjesAkUKvCqnJCCyYJJs0FgDVQWAPIAdQiQNVCJAETwJDVQAkHFAgA4wVrfQRrt8xHyP_Dxbdkos4fDdXAC4bDDW3vS4NyL3md1QgoyAAJVQwCkJFB6Y7AHsjCAWIBPmVP1T7U9E6zgElBLAH4ueB7IDQEsCCInjPqDT3sQHYAAA7XWAv7ADtwDH2Zj9teSAIwPM-ngDT3oifAdElACD9FoKh6qw9WpQVQAaEGqhEAcAKrDTJ-AMQAy-YgP08HPsgskiSwUgK4ASACfvGCAPwdNpii32d4iqGPWtw6MmPyN7M-WP2INY-Wg2UTlD2PRNwUDOPbjx493AQoMddfAvj_4_YgY4N8DtIZKCE9hPET1E_AAMTx1BxPwAAk_8AyTxbepPmd-k8f3W91k8zh7uGtf5PxBC88gANd9o_CP5L2XLfPMz6jd_P8AAC-2PKxuhQOPxNykDgv7j3nBePMLx5p-Pmp-9euI-kfC8wAqL8ADhPkT9E-xP8T4k8Evw9mk9CRGTx9CfPFL-FBUvi4TS-rgK15kBAI3dx88gArNwy8yEa95rkSJ2uVADm3K-1MAvtrcJ3cmvYkHi4H49JrAAuI2wNwB6Qyj4ancPar5ne6DAb8-uGvbt5Pcz2M9zess3Z2ZMOWvjLwv5a5esfa-u3OreeCboZo3zKGgE93gBT3aIBGm5F3yISuYAp8HgBhvyV9bfBviN6G9PP4bzo_mvWc6ICJvtYHG-z2iVa29avIAMm-2vqbw6-7i2bz-KGgIwOgBaQqsD8CqwgsM0RHPWkD3dnE1r_GJ3AuD7EyV37d87eTFIAOXdPua7-bejv0zo7dz3Bd5nfgYs5klAeShtzu-j367yoCZwqAKrAJatd8e-I3DQMkj2A96A4BZApgjPfbvq79e_m35QDIiqwKZE-80Bab5nfQY-QCkB1G1AGXct3H0Lu9pPMADMCqwZcMaNbv8H81D_vrt5O_Tvyd5h8Yd2H5neV1PN7-8xMiH8R-t1qsIkAsRGH08QUfHd78BTvqT2R_9EDHxzezgqHwGZwf9H0R-1vf-HI90fndOx913lAMmBwfZxBOEt3KT_MDm3dbwa-NvgoELChAZrxa8KnHd39Ypv-sfHdVtmbwUovtOb_mBjvrgKrCEiE-D8LoAqsCTazv_gJq-ZPC_ku8MPO7le9t35tyresfMhCJ_7vTCIe-x3YH-benvT5he9W3Ln-nfm35QeQD3vj77Pd-fwoubevv775-8mCZgjx_CffH_wCAfKQMB9XlMX_nf-frt5B92qImwGBCfoX2PfxsyH6h9mgqX2V83vuHyfs1ff765_h3rdY1_kf6X3TBUfNH219sfHX6YKsAzH7J-lfTX2F-u3UQJx9hAEwD1-efHX51y1o03wIQiftgGJ8Sfl1FJ9BvRL_x-PJlbyA8RvQQAJCqf8b52_qf1r1p_gfiNxm9Zv0SVUCqwxmdgyqwWfOrjBSD35BZEAqsIQweASsglpbyngRYOOSQJseCWi-34gAzQnVEQAyQ0PC7kZjrELd-9eWfH99Q_yHxqAFAE74JhA_MAAJAg_1ZOD_PAlwhQtI_njpx_Q8hn_t92f3bw59okTn-fftfzX5nfuf-qet_Vvm37NdEjZP4jdFPeRDSTm354OeCeI_qNJDMIbO0xLCghQPW9cPEb_qSSwtn12-I3an8Synffb9p_pvun1m9GA9CoQxss0P9QAgTiP88DUAsPyPjDvvgAohS_875dSLvlPyu80_o38S9C_2v47cefi3x1-ZK4jHsjI6-Yc-ZJQq3_0SM_ZLzW8s_232L-7fjbwHC0AFnxB4ugLb7G_mvR3-h8nfPb5p-K_53w5Aq_-n3RCh_77hH_e5pL5A8U_KXFT9pftP4jf0_vH0X_8A3n2HdHv-Xye9nvwXwR-t3Nv6Pd3vD79ECgfcX67cJfH7yHjJfP7_X8ifmX9l-i_Vf-38Qf8AEV-N3jv59MdfTSVV8SgC31P9l_Wd1O8Nfw39b_lfnX0wqkfffx18kf1H7R-T_CH319Mfarwf9Yfi_-N9Zfk3xW-r_vX4v9zfgn6f-Efi_8t_ifGH5J-sBG30N8hvrPzn-ZPHP_kSwfV24ZKJFpXAeZ4jATEhh_ZBhZ_EmCR_Hb4efeNhgAZiCHfDt5x_eX4J_ZXhnfHT4qwLN73fR77uUGAAvfSIDvfGACffeLTRAH77XfDwCw_S0QCARAEN4UH4LoWgEdmRH54QFH7GZToB0ArH6dUJgH_fLX73vKfJgAZgH4_VgGcfCwbwhQQGG_A0CTgOgFs_eW7oAxACOfK363_Rv4IAjwDz_Q_6L_F34nIN36fiD37rob34yEX36Mvf34gAeT7PPCN5LhGX7tvVeyGPOQG9vLmJ2vAd7XpZ17ugbYDbAFD58As365_P6yKAyR61fNz4-gdD6P_Bv7r_LQE6AwhL6At_5rfD_5M_L_5bfMchwAn27gAeIDbABBBWIB96JQUnLFfZAE2AmX52AxP4OA_t7K_bAFp_Qz5e4VIGVAQ568QLIGN3UB7yA3wGMPfwGu3LQ5QAVH6bvYIEifDGAugdQFn_FQEgAND6qwPWLbAIgAGA0TwxAv37M_UwE__BT7dvGDBU0VWC8vf_BWAwl5xAgP4JA3_7dvYx6MPUx5bXVG5zAqDqcvIF48vUF5OPFx6CvTx7QvXG6R8QYxMwdnpj_VwBegOwIfmSQCLA2cDSvOBC4vJQByvL4ExPfF4zAtt4gAfYEfmbL527OVBmvEwF1vIN5fPbYE_PPYFPAuACHAux6vA_l5nAyF7CvK4HA8G4GqAG3D5AB4FAguBAOxLfbvAj64JPRQDfAskG_ApJ7cPOX7xuC375_JQEzfRf5Ag2H6jA6nBSff4FyA_EEPfWYDggyYGQg6t7Qgndw7A8x6PAqmiIg7l4gvRx4ogiF5CvS4ErPa4FjgOBDYgl0C4g0UFQdJ4Dn5P1Akgr4HhPCkEqvakGx_WwEafZXgNA5z4jfdf7MgsO6cPD6Dsg8wGNvLkF4QXkGrAqYGB_KEHgyFl67Ax4D4g8UHAvZEECvNEFygk64Kg54HKg-4Fqg54F4QYkGfAskG6gzF76g6240ghd71Ay35-A80E3vS0EO_Bn5qPeAGAg-EEgg0vYCAVWA6HJ0G5PDu6_FNn5gPIw5L3X05kvOI7QQLAADyNa5DWbh472PIFGPSYFQuZNwESRe51AvwpU_W0ENvWYF5glJgofYsHLAkwEvFCsE6AKsEfHbh51guEqNghG7Ng626tg-P4mAzsFXpK4yAA3sEkKM-4Dg8X72gvMF4QIsEvbEsHm3ScEbAgEFxHIe40UOcGa7esGLgq4DLgsl6rgtAHrgtBRdgrcElfHcGf2PcHZgxlgJ1PL66UVMHNQa27r_aW6wEKcGJg837mvTm7eAImQkyc24C3XeCe3OAHB_YwGTAiCHC3S8FyArAJGg2a64BN7yu3dTpB_A8GMvVVz4Qt247AT244PV26bBap56QOcpoQzh76zPm59AiO4LgJO5QQw0Ftgjm4zALm6IQ127IQ6iEO3ZiHSfFYGlg-NgavHCGI3XaIOvPR5cQmSFAQ_YCUQq_x3CYiG_-MSEcggmiL_K0w53Wj4GglAGUQgmTwQy6pIQyW5YQx27jAjCHOgkl7cPOSE4fN56l3UiGsQsCE3vPN4FvGe6GQ3IHx_EyFYABCFPxcyH2kWYBS3FCGiQ0iHoQzJ4mAg-5KQzR6rZISFsETyHqQ-yH_RZTYJQqN7T3ZKHW3CiFtguQH6-CR6NAiToK3ZD6yAmQjU_OHorXbP431bt5lvKb4RQmJhfJK17SPSKAwAZMB6QIyDkAUqECEIaxGYbWaI3dYKRQVwBQwMABGQV_431Kp69QwyJyAgaF6QGGDYwVB4yQ_oiWYSaFFQ5qHVPMAB6QdD431WuoilVaGbBdACRQDwCMQrqHU4ICorQoDz8ATYKuASKCjQtQGLQmQjzlc6EKPTYLIwSKDJgKGAnQj6CuPYaw31S6EKQSzDoAKGBbQvqEGYJ6FxMP6FDWPTAtQ5iE2g9B7gAUPz7AZ3wFQxG7MEBBBkPBwoAAUjhghmCxhDhWIe1D3hhDvgr8DINiYodzlQcKSyAn0NrA5UKu6-d1Tgud3qhPvxvqNMNWhJzEZhhgJvqyYBvqu0KA8MUD6h8eQah_4O0wbEPX-SnzZosUOghkDz8hAUJwQDr0Vu9UPEh0UOl8U4IchmdzFhLbxShy0QBiYIDG-zb0SBwsLch5t3VhavEki3EKMhvEPkBS_mr-aFSSucgOlhZkJa-6twVhn_0khdMFDiXgDTemsM9CRsL1hsUN2i2sNo-asN9h3DzwhFsP0CIL0EE5t2AAFg0SedQPDhX1xJhmT1FAMfBEAI4C4QBLnlgmpBhh7AEah-t3go-QF1eS4LYelUztBCH0NhusOU-ZsJ8haAPthgkMo-TsOshUUMmBMUK9hiIB9hlcL9hqUMQQ7cPRA-sNXAIsJveSn3RAJsI-MVcNfBtIMthJsmthU7DqBtcMChjsKAQYkJdhDr3dh8GBVhGsh7hKn07hWsLShQcI7hIcLM8lEPjhDiGikrt2jhgmFjhSYPjhIEETh3b2ThBRjThC-HYAmcK5I2cNzhFt1NwqzkLhT4OLhgx0ihGHXLhmd1J-EsJ4hvkLgh_kIdh9cMXhzsNiBrsJbh1t1VhiN2ARrcKSCu8KQRGPz7hfGAHh5t32-I8LowICPNh8f15SU8JH-NsNnh4CJlhMwDlhDcMDesCJXho_k9hCCI3hrt2QRTCJ3h3cJYRGCNihocLXBn8LJEUcJjhpULzhloAThIEMge98NThhuCfhL8MIAb8Ljhn8ILhpYKGsQsP7hgCJRhJv19MY8ITeYCP4hpkLrhskPlhjcM2BzcOVh28O9hrt0l-miLMRiIADh5t0sR0v20h2CIsRGiP8AeCK8BmT0lhTUOIRIARvBNYKlhFCMgRBiJoRDLGXh4d1XhjCLJeiCI2uLiPcR3b39haCOiRsiFN-U4J4Rb4L4RJ8JvewAD4BXAEvhMEOvh4sMKhR9xAAEiPfw6cJHAMiJbekn3kR-cMpeRcJURWCLURCAKQBBCOrhE8LnhssIXhsQCXhdCOaBpiJQR5t1oBzSJQRtiLSeMgJchBsLJe6_0GRqFHpe3kPHhSYO8R08NvBSYPaRVCM6RnUJgREwOdBI_g9h68PihxLzGRwyISRggEOR1t1SRE8OPhkcLPhTSWR-ogIvhQiI_h8FFERhSPERKcNKR0iKzh7MPfh4cMURTYN_hIo3_hOkL6BlgLmR2iJrhASP0Rat2gRRiIBBSsISAeyPMRmdxBRbCM9CIyKRRmCLLhkyJveRkDcRWiOO-aAMWRpCJnhKyIhR88KgRXSM2RNkNdhOyLXh1iNdhyKMiRXcNAQ5twZRjL3ORV8PSRVyMzu58KiAuSMge-SKj-ZoKKRJSMfhGcM-RVSI5RNSO_hi1nqRmKMZe6_wz-4fzSBVUITBoCPBRuiIgRkKI3-0KNoRWyLgRfSJRRbcNduiqKgByqI1hhqNQRHCMzuJqOyA0AIxRoEKxR5txtRY7zNRuKJaR8yJghhKIXAviNthsv1JRHSPJRGyJhRcgJMBNKIiRjLyiRIAGdRdqLpRaKMRu0aLNRKSMPhYcM5Rp8O5RgiPuhwiPseN8LERTUJFRUiLFRr8K-R1SMtAvyLqRFF0BRTiMzu5QLSB5uAyBriBqBPYNVRhCPVRAkLJRQSJ1RISJ6R1aINRjKP2RiNxrRlQPrRkR2yBsaOORg6PSB1QO52o6McRjSOSBUAAqBk6MyB06KmgbqNBR-KInhXqPO-xKJghqyOoRnaKreeqPoRuyLpR5twnRdaKnRyglqBFqLjR-9xSBtaKqBy6KvRTaLJe7KLyRqaMyRLQLaBgNweRAqNvhAIPzRZSOfh4qLW-JaK_hSiP-REqkrRc6K5ByILxRqAM3Rf1m1u1YN9RfELbRAaKMeBt0pRTcOdB4D1PRLCLzBcGLHRVqMRuo9inBOUPj-TwSaC5QSc-XMKTBTwWRhl0Msg54Chhk6AeRTwUuCcDzeC1_yuAKDzqBHGLEeywVrc5t3ohw1lIcCsNnRjqIIx8wMJBYIPdRYKMQxyvGQxs4JJRGqMoR5t2QxwaPbBuGOgeCKKNRQCLzBsmOF2xGOZRrtzIxsUIoxaAKoxZQTyAa1zoxMEIYxwmLoh54EXCekFce2oHYxmD04xXK24xa1z4x9GK8xgmNohmd1ExSjwkxpcIdR8qPTBw4J5BsUJMBeGP6R0mKg63ILWRRyJIxGX2ZC5qLJeniKTeSGKwxKmN3R_qLWRmd00xuqPIhUTkoh1mPoedmP4xmD0Yx0j0sgzGNceSUHExtWNoe3mPgeCN38xDmMCxsD2Cx_ULExhmC0hEWIARUmIMx8wMdBcWMmBCWItROCKPBGoD0xlqNMxmd3Mx66IQxCyLyxt2B9R5CLUxgSP1uW2Owx3b0sxE8KqxNGJqxAWNoe9WPWCekD0gSUEigN4AAAnJ5j2sUFjOsbxjX7m1iSgt5irsYNjxMbKjIsZk8LQYZjsDhkATwcxtFsXNiZMSDjCwWODQkcR9wkfBjjIUViNMVhi6gQv5ALEaC5AW_ZMcQCCNnFs4ogGkB_0Yy8jMaDjH6FTDOQdDjs4TaCNiiwEysZk830ZA88cds5CcSwjKcZmiVALoALQJlJRgAb5OuAghisTbD_saNiosZDjksSTiYcS9sJ3p2IDIbNikscCDxcWDig3FODQ0Qjj5MRujVMehiBcftjckN0iyXo1IEHkjdpfnPca9hkC-8Pi8D4a0BwgEfCP0VHCTcaCCCAKh8H8vrQHEnyimoX-jc0Yy9AMdkBygiMDi0ZKjS0bUinwUg9_cVzi58MKAkIY8YiAAhRFjL-jP4f1BWSoKjwYDgAlrhAwIYM7YtMfwBjsSHi_AIvB-sRtc4AFAB0YQpBcYT1CMYfjD30fBQc8ahQ3sewAPoRWiPPlWikETFjRwaeD8MeNjksSODFcd6ipsdsjVcWtikcbtitUchi0cWo4zpDjjEkecdkGDji5AUziCcaWCWYUUjO8WTj7oUm9Ysdp4OHlBiS4V2jX0cmj4_rPidnOeDYsXUC8cdziRgLziMgPzifUULigUUDj5gZ3idDlLiShBDi5cYc978a3i4cbJC-8c2jWkRri9Ee2jtcYthdcYy99cd88jcfGjURqbjxYQS8GcW7ibcWfC7cW2xHcYwE_gKElXccYC-ETmiXkXmi3kWnDvccUI5ESHiy0UHiwMcxhhgIHDx7pHjo8WkZY8cIEBytn8wYBDAU8RaA08UYDMnlniK8ZaAq8XnikbgXii8SXicYeXj-UZ_CuCTXi68alcyIQDju3rfjksceDYcbLj28cCDZCe_ju0Z_iGEYjiLYXujXbsPiNsevd3Qep8scbw9cobjjOcczj58X1DM8RqBVYMvjfoVGiFsezDqcU-59Uk55xITAT5USYS58U6i7CcfjOcafjz8SsZYsR8dr8Y3j-AA6DLCQ_jCBM_iFCYc8lCeDie8dSiv8dli1UW0jkcVoSsMRnjCYcZiYQWASLCaqhICS29oCbvi0kU8iMkbbiICfbikCc7jUCTQSREZgShUa8iH4Ybg8Cb7iJURwTwMU2Dg8a0TSCeHihIZQS4TNUSDfHQTE8YwSlgMwScAOni6cUdiKsSmjK8fEBUKPVjUYXwTsYcXjBCbASZibnjRCUES50a69YgN3cEKKnBYkQCCcsR4iUiZndbbhxBUIYdjYUZMDEKJESO7sa8die6C0scti7iV3dHidbcQCVgTGXiNATofwAQHGq84YZnCXQH25mIQS92CaTC6Xu34rsZFBXHoPE9MP68V8bHd2_MTCjCd29PSE2CbCXlhl3h7igPAvi4ejzCBhg4UcAK48-obDCSSdTCySQIQlrhSTqcBDBiSVNC2QdVDySfST-iA9jGSQIQ08dSSN8WyDEmgTDnfDXiUHsk0E6sESe3vcTegP89Zkd_iPUf4jB8f_i3bsFCZgNmiMxuFD0iSri1CW3iXiW69mXk8SdYZndtiWKStSe8TZRETjEbt8SESb8T_iQTDASUVgd-CCSLcSpCjCVmj-EWfDMAKzt4APIAAAF0_Ex5E1EgpF1E8GHFInAmNE5oJygZsBu4INFPuRqFyAsNFJaZjxMQfQDm3G4lmkt2EMIm5D_8HL76EzJ5okpcEYk3YwF_ZklMkgkkWAezGFk9gBnQzklskv0n29Kkn5k7qFKPGsk5wvqFck-v5ZoognOXOQFZkp8E5klwjGk_oi4kq7rFkwsl0k-3qRkmJh9kiTquPCskfQeGCckxsk8kp9xZovNBqoVMmsidMmEksQmHo8rGqocfHek7gkLEiKLF4pYll4r0nhwkQm-YrrEfYgmHhw1Fi04Mwn0ki0AvMfmFUPeck7krgnzEgvEEPHIy4woyB6YXGEQwPSAPYlYlCE4QJc-afEAgjslRQLslYkz4k4k6kkfQfEkDDAWFw9Ecm9k2Cm1gasklkxClXdZCllQ1CkWAVkm4Uhwozk-klNkzYljY2L6jwtXHrYwrEykjDES3eUmKk-24y3S4khoyYF2Q-QnkU_BHJ-ZoyFmfq7eKS2BsFK9hAoHvwm8EMRTXKcQewJ_jW8QODRiOuDvMNlA3sFZCwWacJwIOSn6ocBAriCEAAqeJTjaMNCUaCTTJtE9a6UwTTinRNpdKSZS0adYBUqbZS0qMNA-qG5Q0qNZR_NaFDsFarRB6DHxEUCUoxqPbgp6O9g3jK4DjqCjiY0MGBq2IlSRgSKAPY76H_sBuqhU9dI4iDjQT0bykdCfrj96JhhFcSTK8EMrjwKfyloyCbgPEbKlS0GriiqVqz5UqzSFU3NRINCKABUjRQ4kLRTTcdKn5iIEhUkTn5DcQfQlU10hTCOzb-Sd5CKoeuS2ZdykNyXBbUATFRwAIXz4gbrAMSM-AS-Ilh4WBJTngG9YAlLII-YGk4q-bzDbIUAiaVEGLNldEJEsPSlJtY9a9Keam3HRamKSWgClrSjiDU1ADrUlyybU22w-BboCDKbs6mUyTQnrQ6k-LeNyjpVzZnEeTRBUi6lXU8ag3UtSrbU-6nzKalS9tV8Q3rH_oyqF8bJsGNRuVeBjzQUGAfUpfJQ0mwRgwCcIxqN7bjUqaB_U34hisW47zpE6kT5WGne3P6SS-Oyl-qByng0_ljVuKGlQTJakjsGNShrGmkMFBLZ0rAnwYACyJSpA7zF0NamxVQOgY04KJftB2a8BWlJRQPGlvUgmm-YQpbloEmn1JUewcMBEgFeMTZWZGUKvyS1CJiO3BeUukRKiQoSECdLj3sCkR8iRPo_UxURtiUbiUZMTgacCThlcAfSLEGbjtcE4j205Km8KJ2lAkXlTFU2ETjcJri1cVOr1cT2lVcXKmOaV2nPEJqkAA2kjDcJ2lAnUexfrPADyUv-BPgXBg5xdWl_wNxS4MNlCeKXil68C_K6NISmjiESkVmc3jiUqYARiOCBRiO3j7iB1A3sV8yD8f0T9kEFCqU4VCr8A-CKU8grKUuZ54gOOnz8eKD-acVqNLfKo2XPdb90h1qqFHLR4SUlpsxPiD9U2zJ24U-qxTTBrOVX3iN0lza0ANKBT006kXU4amjU9KBrUyalxhSXx5VTQoQ0t0pwjRGn00zuQSDX6mxVCcJLHJGkT5FGSy0u6kD0_lpyFI-kUyNWrVhapwMSWKpkTeKqhYV-J-zBxpl1CKpuNdk7-uI0bW2QqAFeB1DoDI6lPuXdiNIJ4jwMo0b0kKBLiEG-ln0u-lCVLakp-IljD0w-nU0p3jPLXWrGNQrK80zSoCNHYAPgH-lwjP-kdleGTUVYbCQ8LHigM2nzMQMnJoFExoCEdBmE0wSoYzbBlK6TLEK0rhk9DZWmAnIPT9kDWkX6J0Ta0tsSwCYITegKUCIDJBk7ATBDGpaRmjcRbrV4COr31U4oyM5-DV4IOq6M0bgKM_vDxuKUqNiUARnEP8oWMogQyEdQwIlEsTS4mYjHlGxmI7UiJa4DqnmKTLEx0zumGdMfZgoEWwSMlOkMMxemQoDOk9iAa59NN3QDNILa50kZo35MZrkQbZoHNZeDkFImYaUmsDWteNo9pdYAKzP1pPUgym9KM9aztC9ZKtaU4WAClr_LISxhoPJkHrN8QOXdYB_LbJlfhMNBrzZjGKtLeY1M2y5yLItphoaRY1tHpkNtMNAmUp47lMp-mnKMGn9tIZnrAEym9nW9pFnWynVtLs7DKK9pzMws46tJykcoN8bj0zqlr03px24EQQKMOcSvucdYtkSMAcCBNLTdGwjD4RlZr7ScbLDHfp-oW9SNrPGYdrBTC7nEiIxSMogFSOhiDLUcI1zZIAp5bwZMLHkEUxCYBVocZaziCWBCwZIDELewwMMTpJ_Qcmzv4bYA_AMYADLHFYFjPFYljcSZzbe7bCGZ9Rv2czZGCc07vHG2FkfN-xJnKM4LgRKmeMuFTR0mYaPyXpx7M3OB0CTogjUl4DC-LGkaoXekPhSXxZMutpnmV6lSqAEb6sO1QOqXDbr0yiDPjK4BkMwqpJ1ICj77cZlqwORbweI9bmU4NqU0jNoRtMpmv0viDPjU1b_gC-YIkAbJ7TZNZ-rINZys8aj4-KMLmXW1ztrOVYJ5M1ltENZro4PaZUzHGJWs34iR5PzobrLOowTL1mdgG1lwTBZYOs1jC2rNBk9DUVm2qaD4Ssp1QRYXc7DUR-mVM5pljmPVntsXc5pQaNlQfe1QtYSVlGs3c6nVAkKBsiPLiZDMnvJNGmIM1alf0jamBnVBmK0qNnWqMVmxsvNnxsu-CZshVmk0oli1M-y5UWdNn-XN5YlssiZ5SN3iS05NgwTbC5jROsjBYSdmcTMiYGs0dm304LaBrf-DlGWq4w-A6K6na0GYVFiYYMhNkWsiBD8MuQ7dAJpmCsr8L9shdkiMJtkxs3NmOqULDurY1IvCFekBsmtkuWYNnX0xtmOOZtm3s_NmnVRTZGUTtn1JJVltMjeZKteRbCsonjZs8VmtsqWn1wKJZgwJdmEbS-maVc2JJsu2yS-HtlFtftmtjT-nY05Ko3hTNZeNLbq4cjVDJVFIaLVWExvLMxyE05dmRrGLbETbdmJuVmbsJU-m-7d5JM0imRkoVmkEDelDXeCyLmTcYDlTDphEcvrYVTX4IJJBLajQe8mYuHjlCcNKbMNDKasBBC63rdzjjbGsiyczlghRdGESc6LymXYNC8VDFoF4oWk6cmmTiyeFj7gj6AIZAXp7bF_TzszNmLsjBm0cvqhjIMmrETLdlOebhmwcg1kP09Dm4M3T4DMqpkdtftnsLKWqvs8aiI1RpLYNEhgRLCjluSV0ZZs--bcjJllOcguQIkX1YhbUc7Uc-9kdsjraujTCauyfLa6rRLpO8Gi6JhViYHskrYHRbdnBTc3D5c8HhkoZJAfLQ-ogYdBa-mbIDBoVmmsXLrZ8c5mD1cmea9bf8BWTLqQNchyZO1LuL8LCahcc0OTFQaTnOXHKYp4bS6tc_wB6XDM69eBJKNchAgsxeJhdcwznkgIWlLc5NIdcwPzwsGnHP1etmdLU_BsMpCh4sufp4RdaxRLOmk0cqJYThdhZ1cqE4wADbm4pFrkvCIXrigMABHcmmS0-PFkv6cyK9c97nyVQOaypdbmjcmQjkBCbl_cgHnYAWPKzcy2oPcrIzaeYLBRLELBaciKIHc7IAI8qbmRdZ5KY82rb4s7Hn7cn7nJpAnkftUORmcgOoOE-OrnchtkS02-n7sjLkDpVualTMSA-coGnKsrVkGLftkEqTq6mOMdkjsbzmRslnl7s_9m2cBALC8liFds7oAjMu9rOACDnmAKDktsu9kDU6VmRnYlnIc-Vloc3nmzM_M59nIs6q83dk8M434cabIBUs75qyssLmbjHnk4M7oCdnC9orMydprMp45m8rLkDUylnNnalnuiWdiO8gRnHQU7hCMjMwiMvCgq0rXgRMvikxMxmCAtVtBxM_OlHXW_JJMomYpMrZrpM05o1gIpQ5hUUCx-SwDiMOnQNABHQC8AxZGUns7GEAvlF8yZnl8yymCaPPnV8k5BHIcDA7oWdpFtLZ5lJMZn8WAxad87UCsWYpnagPpn-c1tr8WdvkNtPvnSnUekJ8zFpiSdHyTBdbKlRCzqe2bNZ-oStnAYKc4otF_Tr8jvCe2d6bBoDbkEsheST2VsyU8-7aH8nflR07xmMs9gwssjekjkDllBSblnryXlmP03PlV8qpRF8mbSl8lWAC8ghkOhSeyr8sSAXRD1nIVEtni0qVTe81zbQXPZgJrUcJB849n56Svn58z_nN82vlBc__lbpSezqLNTm1kUAX94cAUS8yAWi89ekAyLfnwCo9lKs9_koC_JRF85wCt8tyA3mKZm_85JBd8_tkgsffkjc83CEzV1lr0ZNgcCjcZzILgUxFagCes-3lBs95LvTQ_mB0QOiWdfxin8kRbCCngXEzPgUjsAQXigRQUpIHhb4C5_mXUsjl-oBQVtc6QVkbX86ZXKQTv4HnoC9PlZiQAVbcC_0ZIUCbmEc_6qCCybnYgQ_nneeQUuCg_naChbaXUd7mfci6DqCs_neC2rm1dWjjQ828ISQe8kmC8PmS8i3kCCmFbCCoaacCtwU8LSc4n8ygAaCtrkhCw9m3U3zndAHvkdtSfnboQfnsCvfleCpQVB5coWJCrQXm4MiYRC8OKuzbIAezFFqhcvDmaVJwV4dTwU1Cj7k8LDwXNMCoW1C5I5RgM4j-CprkNC6CA5RZoX7TC4SR5VmSQcCIWwsKIWYUjsjM84gWs8mAVmIHoUX8hAJdCgYXbCvoUICpVn9M0fl4JcfnbmSfle8kgUT5IIWaC3oWXyLqjy8uWmCMogVE8URn7HaPk68WPnuaCJhJ88swp8xJk1ISyDZISgAaSAQAUwscjbiduCoQC0BYgaCRtc9UQpwPcjRadADJgC0Btc6CT6gD8Q4GU8zngUnTFnamJDoV7RPiPEULtV8yHmKCTXiKPyY6bHTFKbsLRKckXQtKDoZMiwDLaWMyLKLpl7rfnQci-vlboYkXF6fAyl6XkVAqEpKttRWDbKIHRhoG_RY6O_So6CvlU6YnS06bkVCijaAtITzTdIOflO8CdCWQJKCM8NJTUi2_QfvHkrB6CfTagPoDFfRww8wpAyoAMEUQixPgN1YEWfkUEXkw-DDkAtlj60twwqKZbmoaBEVvAWIAdUkDB7MiUrtyQfCU1XjGVnWmoRQeCmHqAck6cCUBOscMVBqTll4ARMV8Yaow_wsGGNGaUqgwjLDbyBsGYwK4A6wIkW4GFWD4i8eRgaOXCG4bEXEi0sVVtOjT60SeTKQY_nyCz0WsQWlm4aLxkh8yxQ380qJ387ZDssrem6C6yJQVfIVIC4vnsiywBe846lS0r7aAKPXn_UyZywaBHByQecXesqRi7WZaT5i09SLiisVEACDTSlEtnBGOUDFQOSQTyMeQi0BsUFivQzHMc8X14xVkYc2y7Ki_tlzqc3mhYXuQE0ktnbshakrUnhmzi9ZgzEESiNim8Xbiu8UK8scX8iziwl6MoWT2AeSGsywy8oE5hpcnxhSMcawdWRXBLTTcXzyM4iHiqRidUEFiwS8WSHiiPRxkiqSMkJCVO8F8XvUxzm9yY6nai3UXywfUVJQeHSGimYjN6D7Y-GS4DwucQVIbGPSuQRWyl0QNzJsK9S8S7oB289oVvsymo7LSMVh8sGbcSzsqJ6YZgdMASXXi-9SRisNyHigIx16bMHiTN6nTi5an9EGiW9MJcUYEFcXrigLZbi9XA7igeT7iq4BSME8WcqM8UgSvaiXiysVvik9SWS3ph781sXUAJ1AGimUWfiIsI4AV7QA0uqqjin7Sii_7QSi3nKQjfGkbCsOJIaFDQpAMSWkczSpPCx-nSi2kW46K4UbCjgXeSlcWB8ygWS-IpRRmJUVW6RZTZSqXnBYT8UIC-WmvCg2yUwqPmoAXpqcoUpAKSP4WTXQuk90mszziesyCwRswrNdPkzNTZpHNLPmEoL8y4-KixKoEa53IHGxPIbPmsiwTSUWCKzrAHvnpJQhKPiUSwkJcSw8WMNAOWbtANMnPn1pFSw5Mw6VbofSy2tKfktIUsyuUrOz39XIhh01jDbNcKgFXTly_mehIt9KxLUJXaJ3iZJy44V6VS8c9LbZZaI_S1pw5EYkhTQQohu7JqS7RWSQJhWrKuKIPSEUcpDQYLsVI5TrwGJB_kzeOGSerLjIdxY5ZW2LAITHKxq5cnvyEyt3iy03soIZVVxEyzvoE0KmVROR3AUyrFwY-d3Bi9LWxBjaTAgvLQTT9cRpI1BDLT-Coj8y2P4a5AGwSZIaRW5NsbxpMkTI2ITqrABIB5gMfZhFQWCCgbYIIZLWxZGdoCZSEWzy8MQB6BJWU-gUmQ5GOQztARgB6ylIrKyw2XsAB7HWym2W2y62UowRCYGMJ_BApBwLv4V9Ip5USLIfOLnloWEBXEKm46MaSDNEPH4TLcJyn6bxkpUDqpZ7AmVmeVNZv-EjyQBXqoky0cRYBWOV4BGJQwBX9wAQ_UYR83Pyq02BJtMeIAeU40UKyT3DwRKWxIyyqAoyvmBmof6XngZvhD-eVKOkBfLh5HfkZZSSQy8uek1gKdKtyniLgywxB0s8ZrX8kE5Ms1ekL8oiissiGUP8wcU708Xx706alaUzCz7SvtmYChAKlyOCUKyCILQ5JgjYQOsiHi9yyKENMh1S18UDUkuWryuKJPC3nlhWJeW_mCqUW80-XVS5cJUCo6WpJOOK3y2Dk-pZKXryWKoXyp3lji86V-tFXkxSuIWwc7uWrilXpMyofxEsVaWCWD34bS4hJMS7aV9odgVz5ZuUOJR7mhYYPKoK0JITpIZo40zsAfs4BUDUzBUl5XPIQK44AvCtYVvCyPliMpqWZ0oa6MwWK7Y09qVj8BJkgAYbRUxfYSzUy7l7EL3rJ4U_CN0_cRXytczGEZwDqCWiSMKjVA7MwMVjypfkb87OD2ikvxCAVnYtoQKBX81GXAnZxbUAEeUSQPsVssqeXJi7ekTU2eV8snamLSrCx580RWigN-VEKzeROYB-X1dYPl8wGSW1gJWnUKj4W0KmPl68CkW78ZPmjNNhW6EObAZSYPr8IehgpAL-yqLLHT6gKtpdPCXjngUCQSQKGB6QM0bzlZJVKQF9o9QpSDD4JSK2IOJyqLLEW8yW8RRKkkVA6SwCSIIFQKWSJXRK-9BqwBrSgSLJXzVanhgMRXassMkpqMd0Bt7KRiwAH9BCkUQRQUPYg6pbAo3dcxgDBFcKD7FXonMmXQ5tdgCjMntCrKeLCHIICRzKqpTYWX_nEi0pW9oZwCSIRDyNVJcLYla7qekd4b0PNhj5oKQQ25WKRevPMAnAEYDmAQlYaMajG9xY6CPJOWVik3PKc7YMFTKmZX6WWZURterRpQPTBmAc5i9dN3TYuLULpqIYBf4doDQUPxj1eZ_A17dpJlzDw71AM47-rbMYIMJwRY9VRYzKuRbKwYwhfiDdDkEdZSEk5h61nU1T4qknThKZvkmUyRDJIYtrJgacnxnEDBYqqpkRtfUD5KvZDboeWBuQSRDnvCSACkhlU-MOQqPiPUCnrFZVqwNZWSIDZVbK-WCNVOvFTKosVHINyBxYMdCPiG8xviFczzhQbGNKuKRrybiCNJGzE5jZoBJHaVTDBCzSNsUEyPuXQS-AL_B3pPwgaMKLg7APMB8AyKSqdVmxbifZwM4cxhJHD5V3ta9qtacggqwKPxgctyADoNKDKI_lVO8NAwNaTAz5nHEVF6SCWCi0NUkq2izViksWkiuXLuRYfAk2GRhSCKRgWaDobyMAeZdKqWAIMbiITgVSYc9FIChASjp6AJEC3bKChv-awVyrPJVJQYsW4i_EWhq_166q3Qi1hYfCZwgsjw9KeIMMKuatCELwOBPNUjgDpUG7bpVcDYfA3gZJzUAXrz25VEDS-NvTF8YZLcRPyRUAOeqTVKRzqMeDqjAb5CdKuYH2vIRZO8MlUzaU5D0ReVU1itNXyLByni5UNWR7PZXriJHK5MZTrA9WKQaMM7D6SFelHq7pWkMSwVPMuiCdJFZzfq8VjVoF7xMMfvYmgGkRCcEfBuq7ZIT5G5iwag1WEk3GBH7HnoDzZMAx05_CEEAFW6EAeavuKGCy2alxgUOhbNAYjXiyFB7vgKfbyMCorU2APhziXCAEQTnaECWQT8HVdU_wYXrhHHBizAdyi9xVjr4a_sAZADgZloQZZCbOYBcDCJUT83tqxqgWSNY1JSbWV-5JqlJQpJWOJjmeOIEJROLzmaNp7uWEGPAaJJqEc65QAZEGlwUQiREGSDkFW7qSATsCK4GzXpSUV4WwWaDeK7gAgOdOKiMLOJ7IMVoxxeiJrSooXaa_cx8AGNr6awEASJIzUE3UzWh4CzUpAKzUZAGzXoAOzWzACACOaxmAgOIpLCyMpLagj67hPD64xPMLCsAPcThq2HSaFTmRfhHmRfiH8T5KeTVCyEpLxK-UAJkU2B0K8_JgoPCSOvfszxMsSk90_SS2YIyRHAaLQ7iAiRoSQjRMaPeQNnQug_0Vgp_IPxRtapBAqa9mICIMFD41JlmySCwzSVSYanqikpIWc0Q8NHoBriXrXhUVepwALAaVSfsjyVXRr0MgTkkwLMLdVX4pL9d8CqLM8Bba3GyMNIMD1DXaQ9ag6RssZ5pPa5AxgoMNAhMs7WyNWURyVSHiuVeGV_FCektgMYbWk8ezOYcpAvMbFxQwds7npIwSjpSqCRQd6XoKNHWwAKGCY6iBDpiDuXY6mAAY6pvZjsyqC4662SWSXrIgYRqQ_a1AB3gZGgA3A7Kj1bFqtWOwo8STFQvSF4rlNF4qeFT-yQMnoadMH9J9gnbaGFXnV9gzVCBFWURP2bByMKGBwHja3aVFRqYIkGoqnOQZwiClUZNFNXVJFIop55AQiq63VxJFOIbrdAootFFIr57f5HlFfwDI0czpkTNmyFZSIqPfTKEMITXVCcISlLTXGLS6mEiizDJBJwV3VEbSLpl1eJLSYOvrrdVBzP2KIpZFDXUPTLXWG6wophFW6zMwLkmBipvrI0RCi2VEPU-6uYqu2B0DukTPWu6usD2xYW63BOtC2AWVBp61ODDFe3Wh62Pou6mPVyc6rosjV3UduBORe6mvXmEWOpfERvUTGdvWuYU7kxMArzV6rPWHbbfG9fY3Wx9Stm31AlnbsoJJ1oSAj26uvXH9Io6D6r3VQuPc6xc4lzVwKFwSlAQjBYPwozEJ3WFvDMl76tBTY8aN4MnEVKu6_1AL68fVizeOoAS5orH67zAG66IoVJLPWm6jMkJTFIqe4L3Wd60051s-vGt6rQQy6i9xpTe3VQuFzw6SqVTgG3cEmKLqineX4qi6rSpWJbzAvFbTB9gz3AkKJA1GlHdkvFJA3z0s8CWQQUiMNeaSGoPbWfakyS6dEbWPa34ovazSbPqGawa0bWSl1XVYhFRKyJbIuj5dfmh9Hf5FsGwSgiVNpCFUXRo8GsKhF7a3Xi0cqoVFRhoC6nxZC6iyrSYJnXGi3kofEdPrO0PqxD0ZaDV4M_DKEReiD0Rzq1EcyoeVQCw37QRru6q0iSgarjOVXFJOTLHjahHdkWGiaazCBMIrJc1jMM5eJoFPZJ1UFqxOhS2oo65y5Ayz0IowT_WinITA9VG-qn1WnW_FBnUKGwfQMM-ypj1AG708jckxMev6qxSsmefPqGb8Qdx2VHJFWkuADFAG-q7RG-p_KNPx5eG-qquYI0fQUo1cYnQx4ADPwPk_MnVG0YIZ-OyoJNekn1_QFFsfTI3kibI1uG-QAYFKDoFGvqFFGvqElGgYKC1G9yyiMGD7uUPDayhXivfTKFz8XZxk1doBH2AY2vgbqi3g8Nze4bCksXYiJtk2sAwhRoL6qjPx8wxo2OY8PzUUNxptGiTodG4IGNQ_VIFeJWRpATCTjUyw1kxLTGt5fWQkRFwJo0zh6FEVxUb3KzI-WCkpjarkjtcu2RyyMg17SfbVHSM8Bgmg-glrPeR06ug1sDBg3fUkzoL0hXXTANupF0QibrcLjQVEDE2edC3WiOKQ38GhelCGwRoiG1k5iG3E0TayQ3W6iSjbxeFFAcswoxGxYg76qSh8lS3mT4iegOdXGgB1bQ28mmOj8mpegaGnDx2OEqKw6wHhmGhEhvG7WTWGufV2VOw0FeBw1drMLbOG9gC9GkBnLxBE3IMDw0a1TKw-Gr-LfG_w27RII0HGko1hGvqERG2UR066I1KyWI0qmsHYcmtIBJGwcEpGggIdy7TyqzFy7amsBw5GvU2RnPI1DG-kkjG-kklGxCgTG6i77Gv017uPkncY-o2Mkpo2GBeSAyPWmwxm0fVxMev4PGmBk-LZ40w67EAKm7FzH0Ee5-G1tlpG2sj_G6Co5y0SZqUMbAPa92pNIUg27amE0UGuE1jgIg1XLDCR3SUbWRnNApXSf7VvSPs1v2Qc1nSYppz6sc2Qmn6QyGqVQjmoE3XxAs3Q6140Lm7EARYAc0zm7EDOacJlfCtzT9iCRXryK_IsKzrW3wND5P5F_I2as0DQSMIHu_OOLboddBQtOBIfmaCT1nHXm7HMwURnK3lNnaLgtnZ7ivmPLQWrUlo90gAw0AIAwvbMAxyoWiTqisJBzaviBFKTJRuQECS6WLdCIWkCRbtJZmqwNC11a9oAu87C3easxXdoCxViKiizmKkRXqCMVo21bC3DoBbQS8XbS_K6Qq2Xai29oWi1DmerSaiikpQuQZ6CwUfCCCb1JjpdUJtsoIrLnXLBam0LBeJEmJeZaqxjePHW8OTLLjTGTLOYZw3fnKbIQ5UeIQNJ8COATfBZga7zJZb3qLwYYLmMLkxkiVDVydSVnmSEC7L9YzQayYcVfuHqoXDfXLLRRXI0y-4YLoXaKK5DXKOfVfwqWoBUeedyp_wndnuW9XJyOBQGU_XXISqDg76WqxaDLJsLc65RJyZYqRRUvpJApPwoo9OPXUCOtUzrG44-LAq4v6qPVh7eSL8jVcAzsfy21gK4C5W0_WZFdXXDSTbAdjMjT-mi5lrpAg1jgWAoSgO8REAYjXPFX1zy6kS2gpCwIdWx9VBDF9oWgIyBmjND6QxKFxn6zKG1WDgaELUhmJ-Dq32sGZBImPtxPgOgAWgdi1_skzACgYoRPQbZDd4fnD-oRwrZynxazWqfFYlcSTNqCy0PgdAhV2bfVdWiA1FQdYATW0_VCylAHluCpgq5bq0AiX3bBW3lLoAW0T10LECTWhDJyQ26VO8a7z3WkXxr6znWT-NfUuW34YLoSAjA2ghznbArzjqHYpcmU0obWXlUOlDLhr6gWgTZU6yulVbxQ2lG2f2HsoXbNxLyWm86bnGm0sqW63fWjDDk2-XWSVAS0sqD60_ZQUa6Sy6h-FK-RM231H1ScNT_gnYro2tGQdiwc5O8PBQ87fJYiS6AyPqOXXMKURTkKANKcNXq3sGGJZUIn9IgsJKAjqkSAhyFS7UAfGrZcwZpEsy3Y_pHE5QXUlm2FY2ywEDLbMTHW162xdagLG-RG29bWq7RphLyZPQnqvRxAgrk1_KbbgYVagjW2vC4PhH-xoKVOSqAKFy4xEhS1GDPRhUVK2W5bahTONEi8WnKDRLLs1oKbi2uANO3m4GO0R6oW29eWDmRFIIq5HdKBLvXO04OJWzEsKZzNFcPUwOPnUN2qq0mOI026oNACxcXO26amJgV2jJFEHG7xgAXHBgAXSKYOa2xLWg9UCAEPCSwc6C3-Cwag5Hi4sXVO292vRoD2i6BD26Hgj22HgsJce2T2lGi3-PlKFQee06YFLiV2svLaeXGK1Seklr26DJ9Q5u1DOK-01ZIKrwMNIrbc5oqgwe-1fuROgzQZ-1xMW-0xbd-0bbJ9wopV-TDiDu0ZI5ZKUSdu2L2wQRqNI6aEuAESkoGbBpQX-2gwKICQO4-1gOg6JnEIEG2W_pQNarB1PAj4ClHDBTGbfB33UKjlVBckSRFQu0oMy6jYOr_JslQ-p-FBB26zJ9y_2mh11UWxUxKGvZaoUCXMsPcrvLN47JAH04ji4rmT0u0707Pgw7HHHYI286gLof04_bfPaYUz21biHRXiOhGyXONXBbJGaD3OVEY8O1cB0OpsL9KM-QACX9zsK6mKgSWmJKmGexhFVbkJpAKnaUCADNEHpZ0gJyTdAPyQ4oUGAv6MTzYOkdnFSfR0EO-h1tWbaiLda_VSOn7bV4NY7GbQw245RS3xW-RUeNFzKHmy6nKOsDK4ZWWZ6VPPRCK4i2BqBEgH1FJ3uMoY6xOuSRJqeBSCqTlQlO_BTbUYLBAgmvRy2vCKRigp1xnKZU8KB4gQGOW0kGBW1wOkRTEO8RQMGZE6LzXzbonFel02ltT_cAAj6KE476m63l-875rGKZzr-MXW0SiAAQG2-KSsQY23jsi1Zm2yw7WZZiohLZY74nC3o7AD04knMJ20BB22e2RZ1sAZZ03zV22oAJApW7GEBPA_236iQO1WZNDIh2s5Zh2iG0R2vgxR2tBT522XUb6SOXpQRO0-W5O2vyGXiV2_dJcWyF292gF0_W6h1CW0_Wl2k1nrWEy1kTX-312n615W9XWI1aggr2KF2FuYcjxuEy3yyWF18WzhLcKcl05QIeqBiwrIEujJG6RMH7UuzdZeGiiWhuHRWKVW826A-82e_QCItWs0DtWqGDwuk7DCWyFSv28TKd0b8XxMOnATCb_AsuwZhFSZl08Wxl3O1eJhL-NADbAOrAKujV0DwZ5KwakGbRuLYpdrAx02RerXFUbYLYOuI4VoIw4IkHx3kOxyaUO0_XUO7SWPOk8CBOrk0fQEy0P67XXvwEW18OkM4fQU129OTWVO239z2uorbdw1k72q7YDHOiR0CZER3J1LhSgWiIDfNSC0cZSSUdO4ZjOzMM6TO981XHLOp0O7-oMO-NyROtVAFY8QkuHIljbUIt33cVOSnOhDBsHNK6Q-OHUlWJNS8KMp1tu7NTNcHYBKM7zA1OjrYcS-vQKSrSVvrB5afC3sRoQdzT0IXxWsK4xDOwIeCuwQrXhiSSkz8G3gyUsaVncGYAHIP9mxcKEXmgDCghQuEV1wGY0ao2EVrPM7DvXPyHnuj4AqKuuCXOv4D62qsgt04x0iQSQAPu652lUNfbCUrFrGG5ymZEM4DXwSHXuQNEjgYTIA74JULvKXq2W2od1Zu4gxrQcMCiKKtA3gcIARAaYjPETRRT1NK2HbOiqEwWLiDux9TVQSmqgxSMVEeyMVcTGqkoewoyoAaqCqaGABUetD1OeMzSSwaqDMen9EIkLokCAY1h6mZiHx4n7BewaqD3khSBOeXg45PaqB6QCj1VoDvi8KaqBouOxwHsCiAIeugB2OKQCxcJqCJRGNjtWb6CQdbgWW4a3A-sCzo5YdECPJQq4uEQVQ4IKMDvKfCg2sWRUIkeKW6gTrgVugFH1kI56-xGgDDiDIB_c7207FFVjMUXvAA4DMi4gDACjAfRBdgWwL0yOhjpANlgKgRRGBM2gimfMf7hQQoggEBL2KI10IgHEmxaHHDWWQEpL2AVcBBeq5UaeZGj7AeBqQ8eL2Eid3CaGsWmQ2WQbYCEtJCAB_hygSlbWDdz3MIdpK1GtjAXiYPr5DVAA6MPyR3o3LD3lBICAdMu4J-UYDWa83reKhHZOyoICXPeRAs8DRhZzWgJ-SXExCAYb1z1cZZ4fOkBgWpfD246RjlQIgBTfNMXYg8AE_YaTAle6e3zFcr2Jegw2LWJawYVFViQYBIDnGTCgBeySgFekL3PLcL3b-SL0jiTDA3euL2F4VL3u4ZzTrAYH1zhNs54yviitoVz0zARwCtekcRee_iXEuzar2pDS24W8YxsaWLzrMGfo3ME_ARSCoo6WjhDqsFBjuexfLmMIMJL9YRmfSR-XAOuH2MIZhAVWD73gA3hJtGZBhSEFL1WxUNiI-7ghYnHxjVGJB3bqjNA-xen0I-jIDqeaozYwvn24Talx9GEyhC-gHBc-jz0CAdTxZiqX1hyfo5hUAX2HMJKgRMAX2dULMWTsI5jjMLMXK2bKgs6L3RUSluK6-phgzESX1fU2X2EAIM7kbAAhf6ctRs6JhglOEMgW-yBTAKDCrUAL6Bgi7ZAvcGp1JhEpzzczspp4dipuu6vQx-kmB9g6X0RZdb2dqJMLF0Y-wnEGaDzQUUjS275AYkfAgtO6LgcsNQhUIfyrYOvsGc2pypl-1G0HWEGzh25-wB2Ah19gpt2UXEV1N5ZoqEO-06fO1u09Ojm18GSq3t-uI4sg2B2V5Pv0F2jeGwO1XJamkAhYgehApEDWR7hArJ0sSf1OWiArkKPOz76agADyYmrkKMWKOpBHWz6IPXy5Gy2r-4zaVCCfqGdOI5ixa2U5GJo4R4JB4LQIaB0AIeq_BCPBKRTqh3-4YpQGyVh6zaJr0ecPAEOqcqYaW0xx-2UizgIAMwlEAN9gotn0ktiX0kpT0J9eJhJ1BliGzfM2Dsf13ohZP18KHx1gB6IDAB7AMpAcAN1kKv386_32oAeBQh-p4Fe-2ggB-2YBB-ugT_-8Lrp-zrhU-wp1AkXhQUB57AdxEAg0BmYB0BqaAMB2P1-BB4gsB80issa46iO8ODiEQyUCEUeROS6nBzyW8VhEPKXcSavAKyavBse2LgGVB4iaBvAQBcNEgGVWxUROxK4XyLabMTVki1mnxadBWVi_MHgB8Q7OF6sFtDrDNdhnSf7iPG7gjVQL2ZD1Tn1ue7n2ee7giJeXeL6pAP0YaCUA_oDwNeBgigGrUiSIaBz37EE3JIB5chBB1ADq7YtBqocIOH-i1hRB_yQk2WINOYZu6OeJzwKexMBfQA5BSu9wPAATwOH-34JcLIl3VVUY20EGf0wQIHlg0L6C91ROqrueKbPEFpgT6biTVQa0XcSToPHETrh9B6gNkBk4iDBnt2-vc1ijB3hSdB3hK2KjwPqbbUDPQWSBzgTGbOXQdScO5H11B-kmNdI7UrB8xiXOTu4P5IC7ZeY4PbBSt0D6noYpOjoOd0BWTVQBWSdBndjeYQgidB2QNEAB4MLgzGBvBxyUfB4AAKByIATB22lpAEYOF4N33DcToMSK8-QATaqBQhn7wsqOAD6pIoO1gRgAfup90tkVlY6kUEMp0TsoedWaz7sYT4xuvd3-VIkNwSWoMxkEmaLsUD3geuEB9Qymq0e7QNokNMrDMToOWc0j0tQRkMpceSWkGVkMIOSj2oe2D70ktj2sehzRqaHBC8h5EOLfUkNcho668h1T3UhkcYCASUPsAF1jCfYdjWhGIMy2hN0xkYYCdcYkPfnHUN6B9TTkhioiUhusCxcMD2KhukMiS6qC6hjICxcZkPLMXkO84Ed2YAW0NGhnBDchx9TOhmCSSwBj3UAWT2QVCUN9Q4AB2hgQAOh2UPaeeUMpcS0MQe5UOqhy6hSAEoPywZEOysaNj6sJwPgOFwOmCXzz-eXzyUAAkMIkAtinscd3cQehAnwSRk1gduQaMz0RSQOKLOiOPjAYTkNBcD0QuiN_gehuLg1htsN1hiyWuMqSC_BvsP44H32JoYOk5-nkSFCL2k1gAv00KUbiThtgM1U7RT-0xrhSKZQP2FWcMB0uRVLyB0TNCFS7Qh10atifjgIibfiMiAeWHQbxlfQCd2RMuPnYodFoFaLzQdazqW3wBJJUAHnZDweiB-Q6V4u-Tri3A7AAgoTACvqZyBDSw5rSAEgGWIZZqbu-uAm9bODzALSSDPJCBui7LSGwWLRffN0VJabUzOMaCTnqilVXqltVya2sWHIDvm9tcXJ9PGTU7KOTX_iExgNKJ81HmeaWTzPBh48lcYccDjTgnWUAOUIPhS6HAXrm0gpUoIC03SqZXUCpvnF8n_lbzRtoCR1AVCRhoBl8jtoEW5AWCR9AUNtFC3CKmgWF8tAWhtAxYyRpSOCR-gVt85gVqwVgX98xSON88SPaRxgXnCvSNd8sVqFCifn6RgflasmJRWRi4U2RkoVasytottNWBj83SOPiGyNqFEfnuRs4WeRyfkPtXQhmffoBziZ8N17d_A3MBA6NPaDVygItUnq1owuq6jJyZd3BjjHnqoqrcRYrSaoy8eeK3czqlzjF8MZAPtWi7F7iEEAeSYqKWQoS9qwAsREDQAKBRMMAiVWAUiOrKciMKahpQ2EfSZ-oJKCZW4fKQ3WJ12S8VqboclWXq_MLXq1NX4iu9VERoHQZkKqNYRkaP3msaNtqqtqTRnZTi5fPBdRnqMrRSCqi22BkfQRXCqwQ9SwBvaNwlA6NXio6OkzbEDdRkbaXiUipB6MACsKT-SZC4IVqcy72-LNqr-LKq56rDE4HpcbzVCtaiVCgLa4oGfkJC_6NDCy9JqWyP1PgWMZwmADUMaEWwgxoQVDC9HItGHYSjhchh487jV9eixbwMCIAIUTcYC9KmwClEn2hqMkqICNvYw2EcB0ABkCevZiAiAfEB38KtVCka0Vo2AgCEMYIB_q0eGxOzPJ_RxGP3C-PaqWgAXyCgwVPR_hbuC1aqBbZ_QYtW4XZC4QV45TS65TJ8AEuLKMpjCwXCrA7nmMeGN784WNZCykDSCrbm1gFprPR4s0cC7WNn86QWFEEU6_LXyOYWeixmRryNd8xp0S22ZSByxFozCwwpjC-gypWL5aYJH5b6iByNZJJyNsWSZlArBoWt6CP1CsUOPygQmPE-zYA5AQdWDaZGMyzFHgPRwwWUgF_SB6cG18Qe6PVdYNBFykF3CgREDk0AoAQuIAXsJJ1x9O0QgonfUKfRmzLDOuzK_RwAVwC4AWAxpzkg8kFilxw7adR7EDvTTLY_pSQUixowV9CtCYflXGIFx7SS_EYuMJADuOh29aPdxlwX9C2AV9TB0YBu1w5bbbAXkC5uOvjW8PZFTflSDWzlAclflNx_wo4yhZZLbT6O9lMgV7x6SbVNAxpDck6inx0TlLC-qk_nbaZzx8miY0h-MxHO8UwxS-MXCEHl5bDeMYyifyy2Q-NLx3jk3x0HV3x0aB-9MKbvzMF2q0U2Oix7QVpTGBOQ8sTksQ0H19x4WPk0MWNz9d6aUuy7XlTa5kaXCGPuTffDOQeOMg_bY6ehIuOzgEuNHx4TqICf87aXBOXpC_pgMJzhLimCyZBzcGPF9Bbl5TcaiBM7BO_EYwUUxZhN5TPHlCJueM6xyWCiJphPyx_hNPgC0DKJi0BL9SPpvx71lyNf2a6rMBRzjcHnQJFww1pcMyZOhvkf82gWqRkdodtIFbtxhhODpQxN1LYxN1pWSPGRhgVMCu9U2Rl460nDROdgQ_laMxBODx-Bb_A9K4MxfpCcRwzof6CXTZx0hCpxzBZ-oDOPAe1WD_hsCO_CB6N5xpE7wGb5ZcKKJOfybJ6cGYfQgYJJNVcFJPVdPOOFJstCRgRJOgRopPv2VJMDUs6GNmyW18QJ_QZaD3Ty6KDVo4chPjxsoJ0JqeMMJ1OSQVP-RznGozPNRc6vFTBIV7bwZ5SvhDbACABKbCeNvA9WNXlCmKxuGKR5keWVziIFIC9Rth4aimJHYc_3BSOUDv4XOmORRuNgJx1kZXejJuMfOZJSl_DVdbMDHgKYyR3fXbD4GWydJ2hMpAehOO5KAD7xwJa1ge-wC9VuA2Js5OHbF5OGuVZN_J-xajhQFOgJyrbLx35MWAZnjZR65g4a3-PtcuFMZXD6D_JqFPugK5iCwUWTgp8Sb8LFMatwXFOuAC0DgpioDRckcDHJzYXTxi0DFQVFOuC85MV7a5NXAMpOIgcnIPRhgasAWWo5AbV7dAc7DNEn9KoQHXSa2-CUc5EDAvikVPjMHZMxSE4Cu5U_GVseHrcMDODErZmMgJyew6MM5Wz6GKSlwCcBBjZ8q34YnouSPKWwx4YI8Re3QOgUQQ89A9ytQAubop_F2zAAZi5S_fTB9WoNbqTuqpNLpYkKlenIaqDUW00hj32WnCsmYuTugVb1BAIdhewA3ZpGXQh6mScCakaOp1Cn9JCGHXTFxMZAwRhKRwR777kHL3R--5NOT1dHl8YFNNSmC4zoRxRnZGBwqF8bTDFp6DRambPjWKUGB6-7jHPM6DRZiqtPrADdJ6OUGDXK6PBwAVdZCGRUzdpvhDR4WoyrrbtOoAb0wwgGLZS4KdOTp65UI0eBy9CT9SokeFKkkYfW9xodICgEqPT1MlCFR6ZBbpj8z1R6DQ6p2J3yIAsgiTeABXRk7aLeCCrn0TBxjx95OfJ2FNiQYR0epmn1vO2J1zFKKAGYashjAXaz3kgzBcUbtUSgIUjNel8oKGrgDvlKBj04Yr7o9cqB7cm4CMLTtiT1OFKJABFKaMCdUyrVDMIpEfWmqEYBKRe2Kx5Gp5KQeaBjAUAEa-ucq8GnxjE60NU_pyBgQwQzBKO_n2dWuPIGYURwwAFjNfp4jOs-boCQMSjNhuco5CGFdNoZtdNX6zGkiGbtMI61AByGYnWjpsmqyZ8qByGfDN8IJTNSZh2XC1ItPLp-DAiZ2kjD68TMiGEYD3-6TPyZozMyZ-_19psmqGZlTOWZ0zMOy-ijKcnThaZ1dO6ZsTNpTCTMjAOTM1kCfLGZrzPWZmsgeZxTOWZ0dN2Zh71L1NPQH9fUTCYU7gQAYTMIpFmq36jJAh1DHixZ0TP16uPrmkTNXRRl5J7ppgzsAPuYDzegZxDagQ4gTiH_fVDCdgC5m1dP2AxGB5PcLbJrz4DED4gDRh5wWqy_sP1B19VjDhRzrjwTQzp4Ahx3np1rNMMF_TRbDPXfCE4hzCmoBmoPrNnp0XaDZ4FMbpqsNDZ9rNH9QCZlXKJIrZz2RXnJpMDRNrPYgaLaU2vRxVRorO-2MKh2ShJXZ0T-Nd6iGLxuQ_pX6jMn-Qwebm4YMxPuQATHZqXCd0Q9THZ52z0kGYjhTetm9XcZ1tpEI0dpZxPmJiSNSR6Znxma9YhysbZcRw5YPOp06IacDCbABcADycxgSQaVPQaQCU-IAIjASkYEjxxHMk2ZHNBAKABo5jNy3pzkrnLLJMpx3JOl4N5PzJj5O9J4FMSKBzPkKgCPFJ0hB8NX-SlhqZWObByg1HJvVDzWE6zWeE4Vx-c4DOz6OZZo7pjZnnbv4e-xvq46bzwcrPoADgTkFaHj83X9CzgUj4dDdGyojHuyvfZ5156doDrG-LPD6sGBFZr0OBGC3OU1Z9QWxZCXT6euP6GGVPuSm8r32ZXMXMjmXzwNfDBLDmOb6WIgf4dWRUuBRBrqYla-5uPqAqxAU-5nxDxRlMb0a19JdscwCNDIMKKmELlZGZvSxRn8r7-nxBmcsTyUugSAXhSUZ7p4qOHp_POQy6hIzZj8wQ8mXNGZZLZTZ177IKA9NpcMvMvVKrMsG4qCt5rnDI7J3iObLk3BYIrPaYZRZepu1IKxxzaJx82qXYR-gsRyICQnPQ6qGnUjwnPq6eKxmAUFGEX5ubzQnmwukgYJ-6YWENUJK-aHAe6lV-R3fPKQecrAe5wCiwHfOPqp9WYq5XlCaGlVwKh7RRK1NpU6ZJCGgWcpKRYfD8Z3QhYq-_N4GJ_Miq-9Cv5zPNHYD9XPAEhgdzXHgl0J_EbaqYA_5rJICi__NpQL_PpQOAsP5kvSPiQAuGgNyLGLXQiVCFJjkAQATkxsI46MafZNDAtBtUFOBpyvyTsUQ90aohBguIYXwo5JtWNJqYAP3dQR35qNrGihZB20hwp0aNgR5PDokWAF-Cf4ZXjGQHmGuklcV6YFh5dyzMwEAIGQRpp8F6QaQs04TUg3gaERPglx5hoKFURQBGAFPTSB9AfFp5POEl0aTV0WYeGAdU4fBZxAdBRK-Fq7AX2WxAf2XJAF3KwAfAtNbBwDorOQQ3dHZytoKZVngEGV3gbdz5DRxi3qcQQVR-7njHdPSsmiwAAjfQCBHIIvqAUq7nnWIuSBKH3pQZItbMe-OhF0_Au7AOw0ABgTN-hkgHxDA4mjNrrw-zrhI5KQRP3FYaMbUNzv4SRDn5-oBlFsZDtMEao8IY0bIdWXinwPMCtwZG57Ay6m4gGZPzAKYzRa9ukzJyQD1Fi_P5uQYFpRLgZmjJFoMgFIqTgHVS5wFYrMAg_Dfu0n3XdJ_AVphcLYwGwSVANrpFyIYDDpylwcAYFkCp9awVpqeiDdFhajddgD3oaXH7xGQjWAJCiwHWtxiCaESOje4uPF1IDPF58oSF6otHAWDVfFh4slCHTh_FztifuMtzAlkToFecVpSrWJgvFgNDn50_DMdCsiChoIYKrFguTgdsweISRBwADgBo4Uz5LAB74kljwADeNVSmfaky7FnuxpQB77Ul_fPJpuksdmXQg0lnZ1S2uEppQCayKGFtzLFhBi1WRXBcltCVoAXkupAD-AdR9awVvH9KElyiRYAB530uzkuQMRXCKmUGScl_kas-JSBsp6kwmYFt0-xTIyjQRXAZkBPYOFDK4uyWUDq3FePVuuqSDikzAg2SXzlgL6kHZH8rkl6kw5AcWRHOEbIdmeaCjW3jF0sdkJpcyXxJSx0to4DsyQMMDLdqjX3rkgQj-l2ZiS-DwDOKj6DGlltw_lE8quljX2dq_ogxl5OoUK_ojGl_5FAUfECSACSC7KmJ1f-8wCgwXUL_wVgDcUrVW6AcotDAOTDlQYRTFfZBTFCVlxiayKNd1dswOMF0RTK5gg0Yetxo4PACqwPhAjln6CqwAbxJl4jiqwdgAYwgNA0qnfOFQXQjUDYEWzIfvCH5xcuFQF9olltgxBMGcsnUc_OX5-aBKRediHPWcu-sC_NFipcsklSWCrl5CqHlq8uKmGUsDfYugPlltWs-E8u66Gctzlt8sDoa8srlzyj94X8td5yelClgFj3R-orEcGa0NuH8oQARUy8GH6BmjMKk_lRhOmqdZqJHJCtKRSBjNAF9qoV27hpQDgAvtZCuQMYitGgLcvlQAUtOAVennlncstcsoysAJYDIYMkDMV8YC3qP2y_IRdObSMowuMBis_QRissVmYDsVpwCcV_IxlGGYAsVniu3qRitCVzB14DfGlOYbksO3ZMsvtbfNXlnVSFijqxKVucAqVzZ5qVhBgaVgFhKVjsw6Vm8CLl9xVCao4vuMGSAdmSkQ4a6OkR3c0XB9a1NtlgTBialDXAe9_hNuDwBVyuPbcaegIXQfsteV4jiNloCpLEhpOzKTyuZCrDw78PytAJxUzWVhtyMgLys-VzHbBVr-Nll7U3WVm-5ZI0dwCAR1RgOayungfKs5V94AeAAqB7JIE4tc3EuUAQZBYAPtwvcaysxwFtADeL3iLOJ5KmiI-weAcK21gSl0orbOYLgdYY4TJVSloF0CyeT9xIYdsygwPqujV9Ybo09azTVhcCOsCtAjVhcCMeSWI78MKkQ4Mu3KJFatjV5AS7WG6GYuBauL8tVTFABSCrJXauOsZdyuugrzHVx1jGzD6AAQYfpPgFgO12_KiZGHoAG4Nfys-DYLaO-UAKQbuAZVwdzsUSADhPReJoga6tYlVRaRV1Ny1V-qtDlxsuAeikvdlwiZJVqKveVzLFmod_gnWqVTWVvEvYAVa2NVz6vCdPOVKqGqmogUEs_8F7iECEkY6qWZBc097zS4kkaS6wq4wYNhN_ybktQUYFh-MFMv01wqC7WTmtAsVmscASBimCIoas-PphhuESjkxaGto1zRSogbtxKhbGusGcopVOA0MG-tWuRFsaRi2qWhlWWtySIRkA9OVjAFXNgu7te_M1W85m_Si6Cm1jgvOAUGAcCDTPA1KtCogA2u9OOj0U16XEsjbkSu1o2sRYdCrZWqVR-F5JwBF8QSoGRDzsFw_N3mX0NimV2supbEuNudGvcaHFK9WwkSncNKCSAAAB66wVmgqsjJTcj14AB0WAAUMAKgudfsevAALrKMCLrJddBgedfLrhdeLrnIBAc6EFg4WwGI4OKTc8Pi1TrKBz4wUx3QGkKgV9_eC7rzpnBwSRpuT1A2F9Q9YxKUUAhwMxHjLN5fWWg9YwOYJTrIh1ZClwHg3089Lxr6NdcA8NfSgRNYr8uOGKA1levuBVdyrxVcKrM7iWAp9dKrxVYr85Vbgt7bDRrqbh3rMVYRrE-QPrKdZRrWAmSrmNbSrONaJ4W9efrhNfbMjclN8TsdY0CdefrSddFpH9cGdhDK_rkDebczZn_rXZY8AXlZfrTrBbcIDb2AYDahr8dcZAiOCr0ZiFdrsVcIbJEoE57_DIbr0DNGqBb_zVSgfr39ZqrBDcr05DdirF9osAila6saVepMlGfIrkYFobCBc1ZmBczzMtexLIwHA9JDbfruOHf455cozDDff4szkVr-NawAitZe4hlSwEsNvSgMjaTtFgalUMNfbMcNY2rgVxthmCYyrp9xc0TWrQgOqBhaD4eCU2Jcj8TEucAMfie0poCvuZD0IenIGMsIGAylyOiLCEpVe08kFe0qioYbtBxD2jbRL2W-yA9MBfYAN4FFA9WjKVsfjWU4uVFVEpUfQooB1g8sFTFFgCnQ9wS1gL4jyep4coMsTfibcmsSbr4mSbPLWNFt4gja2SkWVEbSqUWTYcADQFFA27U7J4DcoM3LoiBVLRiUnTb0BVLS8bByjoi-YR_CjEQlKLxXkgNpv-KQkXkgdkW7Ee5uXzbdKAir3zfgtjcnEZBHjSXZlHVHh2oE-yEgsbsQ_e5ftEEllcW91cCwImPsP1DAiTCQelGbhacI-WIFUw6fmrU0ltEY0xqtJfbiPs-oGizbzbI85sRT6GXHkgOUn08ezdEV96GmNKWYtE8oE-bUmHBbgNiFJ_zflA4xqeb-zbBbqIw-b0WZNzvzbMAG6U7FfME_K-zcxUrRnWTbPHgYWfH2bngUOTf8EVMmUiQs-zcTEpLZBbjdovc1CWEtrBrCzcoFH9Ddoub-u1-Cj3xkdwISPlQuoCtMFVe-w4ucMl6SJbUBaprr7gubYh0JWoUl5b3gR_SDfDvAByCfCjEQITs8t1WTdmKEm1lXA1LeBbv4hg4cjXpbhrfmAQCU6q8wGx4-zYmztHBNb-SlnlM3PhYxLAb4J1n_BAJvxp9zaTCahDjtcoCzlrubRdEdtgQOGo0Y-pG-Q9uNV2OERDdgLYjb3yd9g9YN1bNYGVbiQFVbvsDe5AnOekThCKEx4oy4b8HrBhZVjbZrpJgWIHEIkbfjbq2Czb3TUWOPQ0jbnQmalALW3jLw1ndp5rYQ-JHgYQEdSZrbZl8A0rWaGfJGlazRBQCxf2a7bfmag7ZOaEEZxOOAbMQ3xnnEyEbIBiWhlMIKDrLgcifyvJgi1JwJSAZmqygPZiXbIoBBQnhDag3EjhV0KH3bOUEPbqLbrgJvTX6V-0t60oGwk8CDyIubHf6UcGok-gEAKt8DPAcvU66_5jHAn7cr6lG0bmdTyi95hGu6tsV4WPPR0OzlQSq7PC3E7GwEW4myh6VmwIAkcSFIYRB-6qp0F63bJMIPGxe6BPQsAmyfQ7wyyg6PGxbmc3TdGMhEgYGRyCOJMllZoh0yOT8SUqefGTSTQwJK8cba6JZLiYELHumx_U-IKsdiG66cjA6edFpkgXqAT3qFI0dPfwhDzY77HZiYELDDZVwBCjzY1IY2DDDGBPQjZsJc7qdgGAAJIzt6V3SkEfHVfcoHeY78aXI5gi0utKywP5JhEyiwfByQN5OFzGtGC0T3TbzSYid4MPQWzFgGVAjBoz6rZETohfDe5pHQD1yddZbLnZWM-hR9ApjjKK5IlI7ReECOUhyXKdaAE6Joe6gUXcb6OfToCibo-gwfFC7BzzGKyNBL5VMWz8hKlLwpHU7z9rDy7q1sDomXcc71xVy7oioAGoVOK7qMFIwEQDK7G1cgNOdGS7XHaiG2dEq7I3VbQH1Y67IszEzcpYRIPXbC7OAFT2JJTG7t2bSz43fEIo3ey7A83l9vXZ6zveqE4iEsBpVNoCqU0RLVB7aH6qqH2q3yaEQtna27WXeE6xTFydVXZS7EsAdOfw2S7YbO2YexuW7tM0q6YQsg4tXUKgjrYhG21Bh6mNOD4SOw7rUqhh6JReQ664m6AVBtyQFnflgPhflWvhclGT_VTGCLyQ7B1V36c-aWQxnl67XDVQmXVBTzKxgzt5nYa5lnfe5_CGQ7dnYz66PbC7NhCxtUsmD4rNIiiytF8qr2ydKNPdDkjpQOs21mZ7agBdKGbfLtVXbOGXftydEMzSmH7aiEwaAO7MWw572AG6oN43gugbupwj1RpAV2bDwaaavbL7YC9IQm59ovZh6oMAl7WACl7y1TjkGFQNGZiXabcVggKENRxGftRhqDVbJGhw3cwBPBt7dDOB11hzuaYHDSORIxJGcNJak_7ba6SLSg78KqFInwGwEX0miz8u0M4qgiUicIHFabkAaA7AEc2kgBfgQsAw7GUgwYUVOwYbYCxZ9gvldwsC3wFwBuLZo2G66HVpGFveJGeIz07Uq1fcITsd43PvMYNzDvLBAHehHva5MjKwg7p3X4UCeipyjvpJg3mFbwTczlA8QlsGT5W6AzjlIY6Un9YnO10GJI1UEdCnb784E1I0eC-wPfZQ6lldOVoQir7w4hr7I-EArDfalWTfbJssyWHQlgGMI1Sp4Ka7QkYbfasYHfbn7MIAX7tmwe1jzTXsIR3N77vfuaKwwH7A3niqf40VMEQEFgMrmf7MNUqEhVufCRAHqORfb_7QnSaOsAwugIPE0lmAHAWDzqH1TgiIAdg0NQNgyQHwwqak_faQHk5sf7hIxd7QnWmYQmRuaYA9RsXOCmrqA-kzfLZfjojrR948VKA5A_YAqyXIHtEFKkO4izAjbGH4Ak178DE3WGJasFMbjG8GaY2B4xQAgFRPDRcy4SgZt-3hz6lAQHA_be5dVp0TcvAdrAAzr72_bA4g2BEA7rmIHJshr9Yrbm8WAoWdOHA9txQjaLyDDAqioITbVLbaGH7koEL3HkH58ag79teScoNCzkOtpw4jg6s8vjFl2oSTMHleYwqVPfWstXXNKBu0AHoA7wHqNkJtEXSR5rPafIR1mZgXPaUyk9g97hqCIHYQ5i2tXTE8Mg7QHdXJHGZmxUEWJ2MHN5PQAPg7sAM5U2FzNZgHKeAOsO0Z8WtYXBWAHaaLIoDsAxffhLMghRk7-E9qzA13ghJWJKogjewDbGxUQ6ia2xc2fKKMi94mcBgcCaTL7MgiqzwyScLYvVWaKUlDST-FfcHGrmBlzZyVww5YHyHyXQEsHMYbCm-gp-LuY2QxH7OlAO9L4DkQThcH7VLmXQMLMd4c10MQlLlGHsmClAAIix9tSF7GpLhtwzxGcg3WDSM-vS269GoTzdK3J8AHYL7coDaHERwTCKMlrYB-Fq65jFLe-jPcYo_TuZSybNGP5WQ1RI3SgKg6hgJI0Kgu_eF8mPQ46mA-2913SVZr7kvbSgzyjaI8gYUw8lqKw-EmmjFJHkvnJH-fRi5vffomPM1JH5A-g6Dgxn6X6sxBY4FBV-zwKotyvQ7mPWp6KHVO603fiGQnfRgBgzOGL_C96Y4DskfvckE7kHz6ug3h6CHH8rMHfcgT7Y4W3QFxiAyYMGWQ21GuhSkcpyoHuDY14uAwDyAOjEaG0M2lGNzD46WUQsW8LLfwjNkSNt_exLc4w6H3tQ_pP8mWG3M0YmgPxeSq3dz6wM14ufo6NGXJS36To6QdWo06H5o4_pBoYRpqNKjHTo4edVUelHUQyPFipjVw1kEeSooH1VFaGoA5RbBoA8kLHY5GLH9DwE7MLHzHmMCrHPbn1VWBWnABQDeQbtbLHgcgrHjY_NAzY_oerY4VqKQA7HdY5CMDY8iATY4EA6QRC8KA7vQ3Y7PAlY77HU4658o46IAUgWHw3zPgYx2zu2r_bQH_31H6zjj1riA-QHzqyPHA_ehqCXLA2SXODHg1fowx48B2GeDe55ACYq946mrq6z6juA3FbA_fgzWwFrQ6czgzCHS46Ybe5Hquzew3uvvHrDR0FxI4fHTqVid0E5Cw_NTXsCbsKgYE-Tcsg7SmVonoeLAcHU3I7ASnfbwuqE9wnGE5ECrfVlsuE4qHM8Y8i0lHAn6E8b17QCOBA6BYDb9Gt5RE7onRwJOQIgbQy8E6h5iPkHwhE_vHmNLZqgR04nKMb2A_apQ1zvRXViDFRYI1TzAMI87Y1LgYYYE5OHZo92AKMi72FjAgYxUHYnxCeeIOjCAINgBsWK4u6k90eSYCaWWHQKvPwNYD3sVzg4lR9gqHR9lmKGvCfH8GGwHXte4HgmDIHUAAky46mrIN488n8QhImRcBaIyE4JonbaqkHEBonaA6TgXvfI2uk_iAKNjuYpdCg-UQEpcXNVfh-haUS_E4H7dKUQnR9nSnhABYD2U73HLrOJmxU9cQIFcFMxQnWN4bNomDp3mgr8WVobKbRqIkvBG0g_6yAQ_W8vBeCHqZDj0RABqnsQ5pk0Q_GykQ6wA8Q5bK61hr2YVD57oU_Bd3zvr9bPToZ_zve7SVVRGWLpOwv9ou5rfNFAAKiB0yhEoANLZBbsc2u4VMdvk9QG6jvKaGVDDDEGCWYkE5gG167yT2GbOyA7K9KOBj2dwziAisLUSp47Sh3jz3exdASo8sn5aFvS5DAYnkgAkYkDBzomeVwnDE9r97MXCzkRQiAh09EY73PDHOAFFpOY9r1Nttn0U1sLeQDWH1q09VQludj02VkiAzfsGGqI0dDfEvJb6XXDKq8dyda0_JlPiXvH0NSfHuKRr2b449Kb48T1agCk-BvM27ExlZp8E8FnzMFwO7gRlIIs7UA4hFWgXY95QsFUGJaKePAV-Bq2DzH5CYXCJnsxXfWuhC-nc1Nn6v07cYiDDuBgM4X604FJcWwDvSbju2MA6HBnP5Shn8E9hnJNr4g3aatnVOW2MJyFXWgAeiAWxm5eqshr2xM98Mfs5tzcMEKIfs4YnaUAYnQakpn7E_Dnbs6sO8E5SnkA-2ofs_uVekllnJMATnrZn1VS0z9nCc9YlvY6LHLY_lqTrA7Hec4nHS45rHZ2M7WAVpwnAk4KnEPCTnlM4Eus4_LHdc48Q045Eg6s5lIdc9T0RAEnH7c8yCDipzo3E6oHtYBzn7NSQdlM_vOG3d-Cr0jjHqk6QKbyWkw9dm0cc06zjI3X2ZTnnKnq2fPOxI9xSMoACn5A7HTHM-JHDsv-zm3Vea887l4ks8l7qcnXnfeWxytPoht689GzUo0vneMmvnuvZs0kU7QnWQ7kau89tS-8-PAXk9sGqU0b1x88PnOA1sEUDLnnSY5yG62sqr9_S7AjDRqng45wKcI0Hq3yw7KFRUuufL17jSug7KYc-Hj-C-tK0c-Hj5kA6nvESR5vKotKgA9fidc4iHgQ-GnEwEGn2AHGnEgf8zLs9_SOUHdnl5QIDXs6-M2xlVkjU8jFPM8l7vDOgHIktEXuvZXrFsYIXVs6kXq6wjnlIxIXbs4UXMc-5eJyD0UWC6Qc67bUXi05IXnfbUXFOwlUBXlqH3veQ657yEOe3IEEOQHuHLIGlbcPfjHQYxNuyHQaHSOWaHHvbaHI4GjH_rFmtdYxkg7gFSjcGZyVpdV6H0lH6H0qkGHBgwn7Uq2xsUI6kc8k9Gn8I-SAGw5h70TcO1Pi7gXAY-d79I2fgXDXjHZC76yJpVNZgPO6n9PYV2YQ-i7SRSdKjC56nzC9GnbC8277pUSOxA5tKExgUX8huPAQs7TnYNB8His9mwGTl_Has81nVhzloTo8XnXS6T1cM7XnZgyUN1OAYnYMBiXYHDAS8i_SHjUPYniy9aX7E4UXjUMo7my8qXlHZ2XMxGwX67f2XuS6a2Jy6lBRy9ddho2THKjg_nq60AX5R3rU_eXKOUpp_sz85Mo4y4eXq4CeXKy-5eA6A_jWy9WXUy9-X68_-X3C6BXlS-2X6Q8KIfy8o7UK_OXVS6GcsK7BXgmHwAOi6lBiK8t7z8AxXr-l0XqK-X6Bo0zHeDdmUOhwTutgAEE-K60EmUSeXAXdFpjUiNrLVbaocACpXO22NriXJScjK7yHbaE643sU91ggjcnTy7ftGSJ8naMmzotGoyYGSLH6Bh02jfI_jSCGTjS8jC4O2-HmAJI5IW6AD8ISrPKAscDyIjGWZo0-yuAIWoxu7IBWeZ1wJuOC-uut11Xz8iH0A6EFcdcCCMgyMHWCMxi2A-ZH0AFoGTAbUP_JRkHahT2MoVxcm2jg85X1WgiNrIq6vcNrcg4wq7JEftlhXyPIFhhRZEZLK7ZX0l3np5K-TXJjghc7K5e4dK9GnHFRpXzK5iArK8zXNDmkukdppXViXoZK9ve4Q9rneODiGkViXKGUusTsLRxe2FK-LX8AHZXuMXXn9K_zXaqChlTK5QbTZaLXVK6zXqa9JXrGkde5myvwSVkRGqFXB2MJyaqewRt8MOxt8cOzL2cDdnUJh2x77Jb4glEAYnrs40XAsGTwDBbTg-qtlQ3xnOMJUbMDdJ0a2ABH8H0oGKsUO2Zg21maAu1lXX2AFfXjS70cTy5fnC87AAYnlfqny58toNgFI5RwfXONocKeNr-XDE4YX36827IwA-rMG9WXHHL4gIwAm7yG40XGZW2rowu5jk9nZXrwwXQ6a5HXJa8JuNK-7XaP1FsmwvZXI2D11MhEQ3fcWmiVs5_KEQG9eonArneQAvX2xivXSOW_tH0AY3RXS4X6ABDV4slY3vAjLQHG6b6l6_swqRXTyl1HQ3jG6E3EM-HAbG4k3569QA0m5KjfG9rACm8E30c9E3J6_Y36m803aIyLYNdu4ML20ZlZtVyt688SLGKTsHh9R0O7g8eX68-c3B2fE8dLCSOQK9IO6AagXPQy9VKCyfaTZoIA0iDywnd3ZbCPfQUJ8B4H_SjrnoOUwSxwzhGMXJ6r8MgMm0ZT0QIw2bzI0jS3_XUlmPVcxkv65rXrm-i3gmCQW-sfiqpk8IWdzqCAI0m1C-sZmKaNRr9js5NMjHBrCiMEJAX3hG66RBng8AGGA6dtP0iMB63QARygiJnXgbijq3ojg-rqIpCwSJitJQsHSI1oGHEqsgii025MwupkY4WoQugSGxr9vnYBuy26WAQFUL4-sZnUoCT6lh8mNQ6A_W3K1WKgxqHAWlLuNQQ1Za3yQcbYbPURg6Eoe3Y9pWtG1dIkcJR2tvc51VB1tF2eT2c8x2827xqDLbxwDe3cJSu3TXY3GX28wbP26wAf272tdAkB3H5mB3BUFB3GVfjcANzBg4O7QAH8DQA9YNBo6gGer7QEAAxn9vgWetz1XKo4cdxSaVrqzfFW7dZ0EbBPVkUvtAQAARpFTuziA3wQSmgA2pwyxQd2ul9Y4WoWYoIs6223SG6ZCgn2E23Hw1PxV3ZGJ13eXTM42_sJgGygreGjgxAWlbwEIiZNgFEA_5LnTNG6Z7l0LegH0E-g1YK-h30Lf5v0L-gZgP-g304idYOf2KfVvdkci7T5G6UyyJ5axBA6KNx8cjsBuuKZ7UuLruvSDqkXdjQD9UCLYLBrDMd2UPXrygHWAG_qgTe-Qr1FVLus4N1xLw7HziWgtwZtevnRKYXTgt-wbW3SwZ3uCZovMhHQitVMB4TQSbvyMvSMZaXuxSPFTy981LX3QCA0Q87aR-N-686f8K_FV1rqALOIpgP1r24J3Bu4F1ryDZiPB9469F22nOV2_jd4gJFqybqvm05_CLalJEZ6jFBrXzD8LxmMBbekOD2kTVXvG90XQiWgJTs971qsWm3ujKNChz9-rx9xHzmZdPbayCoBa3dCDzt9yRIqxQUqkoEUqVYCUqylfqBazC3TvFRxbK91Ih7OUXu691ydNnbudtCsAeD2Ui0kh22aPtUSNKDdAf2eRZnnre6sts2zxLx4k5mRu6tKXU1y-3SlybrOJkW8JPsSE3wnIY7ANdG0Tx2iw2aoDwtrBDb1Ti9_ZK8NgDxdGrWFgPYdqANvjVutfHBYTTWBjpPQer4AwbTtRgeF6Vwekty4vd9RdqDGmmESPPZaIZNIfQdWVkVLVQeh2GChxD7qNaDyrvX2pjQRs9CaEDyZ7OzSstgcMIfOaNia6CjbqLZZFsW6Oob9DYatqMxgBLDwbKwK5NY1tyUxdDfNYA6ln0BTWbRxZPkqKtR_vblK-g9kKUrylYNt2F-Fsupzu2i22OA-l5NylZ4MvVZ6xAj5CKAnD4KBE_f6EOaVEeel_LOE8f0vlZ2mkxhFoqz8GkftEqoeayJEeV11kfeZ-XIQTUAeQt9XvgcHof4D7weOzfwf993ybOaOibGj6RpdVpcNEyz0eCkO1M8wG8NiTbNYlJfAw_hmMeNaALudgr5ai4qVbN8TZlUj_rLBQA25Bj_oAfD050PKiUfVjwhXpj8bRxTXYeMj0uvul3OO5Z7EeFZ_EeBlyrOij_aoLD3seTjx-uPq9Efel1cfkaAUehl8kfdj-bKDZe62fFnJbn11UfdvEnraj0HpbFLQBnFC4Ra9-2ctnT9tzDCwenOQ3vJ8X-aEMHFSUTz-aHVf7yET2asgY5s7IzjbyXtqMJ1mDieaosPJnc_-L1gIepp5AYYoWOdGZWaNrdzrAe6dzJIduG0hllow0ND9fdWTxVE0TESY0zKSenc9BpkzPyfYAOmZZC9mYBTy3HfhYSZuXqmYxT4FSvNrXmOT0ls1AIZ0eT2iJOj7oflT_2aD90qe1T2agNT9Tq6fY4pQ8FCfUcG9GF5k3IW5Fmd1gLfu3dLrzBc_AtUe_oBRczomuFPaf1kOZsnT5n1VT9gBsnDAp1gBEZJTCSegFrSwl5lwpgzxqY8IEenE0BIoBzoPL1FboB-9zYpTpHYp6CA4oP6Oaev7G4or96gkM9_ubGYFbBAPR1KJ-P9wRyHqZeMfrGsxRmKMYfrG4TFWer0FHAD9LKygWDYNaAPrHZC42epFF7Buz1oZuMbWf9YwJAtkmoAcYCzF28ETJZ90KR_uNUBrkFKAVjHjH_HDPSicDpR3TC6Bxz5RsQPeppBFmYBJz8ZqvMH5DrkEu8XfBOIKz2FDceGueRmFPBxjPrGtIO6PeMf4RrzzQANz9xA9zwTcDz-Aijz2iRQ8VlBhQFLdI8R-eNUV-eUuEHBZkxpA3z32AZz94BgLzggfz2QT_z4UYo8bIXAL7OfhrsefeDuBfV25BfDz2hfvz5x6EL5qIqCVMAoL1gAYLwqTeDhWe4iuSFdjKMErgOsEoYEdCwAA9jsNZAQnzwQAXz7uesL9OecL0lo8L2HiBAEHAo0yReyL6BfxK5xepzyhfoL7heQL_heaL8hfhL9JfYLxhfxL_ueFL7xeZL_xfBLwqSYY2pf0L7MnKL8W8BL3qZaL-wB6L4xfmL4-fIIDefcNBBfuL5-fFLwqT8LzpeeL3pfvoHbgvAIZeO4JqQTL2Ze9IExeWL2xeOL3JAuL5JfSLw5e4L3-f5Ly5fvzxRf3L1ReBL3CYfLwxe_LxZfWL1ZfnzzZeQr7pfvz3R6pbgKGsKlSeRz9gAnwZ2ezDKxnVIPrHdjHk8Kr-sBLIT5fZHvrGPL9OA6HjRjHDHWfNw_aLuHQIBytyufn4PLhnfNBRTgNsBqz5328ngpAar5pBmz1NBWz8X12jJVfx9CNUrjZK9S8BaAgKrjDVr8sT9Y-mLa8eNesAPrGYmqZeoYA9ibsQZhbz4BcnHpWfa8RNeVCy6ALQDWeoN-QvwKIoinwSZA9r5leJL9leQL7lfYiGh7EAGGGzzyJDcePVfabEFfbL6FeRL99f8r4gALIN5wRyIjDU4Jeegr8YAUBBHhj2Fp7H8qFIjxCuFIo1ABEp5FIxgOQW5xEVZBFmDe1L_Ofhrv_8RyHeedIPy8qr1defAGle8INZfNIOdf-XpdeoYIZBGbxqBmbwinv6mgAHz0NZDIILefAMLfLL0zeMr5NeJ9PJ3TeglIzr-6OvL1yQ8ngZAGb4Ffar-efYCMDfmgFzeRQDzfVDJ5eU5xZghbxzeRb8bflINdeQ5XV4jV8FPUAEOeirw9mbZaDesrzxfyb1zj7pX9e69nbg1If-pHco7ePr87e0QBTe3b4gBXAH8OjgIZ6JxPJB_QP7hbFZCpdHd1emz1LeQgG2enBB2far5Hi-z_GnFbw9eu5ereMAPjidnP5SVjE-BXaqYSSEKwAUgKLIsACQBlQCisDCgQBuAOEAwAM49FABjDkwPYACSykAMYVU80EBYgsAK3ftQF3fvoV3ecYVU8qnsPex7249h71XfRynAB-74Pfkbq3ekoF3fLIMvewAWAlEYCL9l7xNDi8VDBLIB3fB763fzwBjCFIAPeFIEveFIA9jW7_YBPsHgBh7zlI575PeEYF6vn78mAD71U99fOiBYAA_fXHvsCnAOgA37wpB_78mAB72499QHpAu7_YAhrK4AjIBA-YHxNDh75FAIHzvfqnlDAkH9A_YH8PfkH4g-oYPYBkH_eTUHzg_kH_qBL7zg_XHtdCIH9g-R79U8kH-Pe0H9g_IH5g-EHzQ-qnhaACH7g_h78Q-KHwpByHzg_KH1g-KH7Q_CH1AAd7_YBkwDw-GH_A-qnvQ_KH6w_mH649h78vfD78ffT70ve278vf978mBqLGPm6rwdfj65GBdi0sADH7Xj5oS_c37lteBz7XjlbyNeyr4krzb9UAv4Q4Y9b81fqgPrGvbzDmYAI1f4ry1e8gEHiJr-3h3w97ioo_pJggKIJuFGgAfMbUargK49vyapBOiKTf_bwuf__mGh4n_ZfezAHfXbx4REAMHfQ71Tngon1fXGOueh8C-1krfdKaSOJrpmi-BvkIIsaFWYBFnrmHx40ueE7y2ek77NfU73N40jDjA7H-nfSyebftr06vzb_deYYObeUnbHfV5I1fc7-hRTCYXfC8dM9PQRbAGCAmRcbqhBwBOfAktZ6v0IHPj4LEs8YAHpArCWO8IAKARZwG-Bxn4DeNb89eiwJ1wXzxLuw2G_k0MKe29uzKRZd2GInw0d2HcMO2V4HeQbySChPnz1rEM1rne26vBXn7we_n2ErjLNHSDuzZ3oBfN2nO-RogX4ZIQX62hV5BCLenB9cKg-TVeAL9JeAM4AUYKLJZoC6w_roUAf0tZ24X-uBcoxwaIPGkRiX76A2OAD2ieFS-KX9sNBQPPEDu6d3F8_M3SkPIgPAI-2Ve7avHn93u53Zbwuh9ChWCDsAxJJp6KRx_1Ve5IHN0sZ6xyOIHn3LQQdYD08RzIcpdQHeJZtDEpiAAQBAa6wGHGBr2w-jv1pe0j5BdUiy2Ep0FGWfAMJ8l0AXRJi4QCChhKBG1ZBW7DynCL7BX3NYX5YJIgzHg0IxTEJR5QOOpE5djNaCPa-fXwV32AO6_PX7cBvX6iA2g1W643E9N58GMB2gOG-vXxsIfX_IwzsJeIAbao8LaEG-b4h71enJa_VaLm-XRPQ5eyzm_C8MG_UQJz4bEu0A9kA0oRbDv1gbF85gCEa_Lana_U31W_-EFG-Qt0BPovUlAAzMy4BIMV8RbMUA51WXAjgIGabxivFs389Rc3zVMq34SJnQJgtDHfKBDOJ4Q-ehcH6yJW-SYIWk2pvWRS0MXByRiDxjUDsZCQHSx23_O-d3yOIrWKthaCAe_0Zse-weA_hz33O-HX0Xg-XErZWAslQn32e_wj7q_730e_5XzGhE-0G5mgLe_bAKIaL3w6-VKp6nB55fQV0KKx5j2ofnDrq_xOa--xTAig2BkXKB4hKuX2qMpLAKBIbkY0P1DsugcNTcwJoR3I8gPUAkSys-UehEB4hFYQiP9AdM4KR-_JI5gzygGhLAAR_MKnYB2P_98oo619cyECAmhvvgU4EZPdtQ-V-IKg6u6h2_XdlYQQtTbvF4HCAwsJQABINL4QeCL9JAMWhJANc8Ufsm_I37J_MS1IGQPyx_ru-B_E-bJ-Tqb3FRoBR_OqIpRbADzYPuf0BrWBZ_L31Z_EMLyrZ9VGoGQBocJYLa_c38X0EBp-_LqJjVnPUBQnJuh-F3_AAl3-l2XFbB-ArcoJhIrYct35Z_F35kDkqFWxtJFUO-MIl_sizF_bKpF-SYGl-G0dSJE-5HwE0HV3geAmhm6jF-PsiOVLSrtYkleLI9IDB_309XPSiAuAh7Zj0ABx-ggXQTRcv7EUZk704RXy5VDOCh6-eh4hCa9F_0v0ZyWPBFEWv15-m9UN_fXyAQlX3JZVX-q-65cSx23zqYCklpbbGK-keejNB8U-LNaCKFUTv_EwZoBnAXJCOBmcE0w5xLR_ZrY0WPDuwwdPGHJw6rQRBv6lILv3EwNeJu-6WKF_Sy10ROv8acioy0QoOwmgj_DQB3oZGAYoCY3EaqB_IiIMS0oE1-a6nF3aFA1-H7EPa-PetZxZIj_uv0_6kP-j_kavj_e38cJopmWEQf5j00oNa3qBktMRv3CJn4ON-6bJN-Nq8V_14rN_XOCD-cfy4xEfzz-NfaT-GCgAOs6oHREf0IBBROD_IMVj_Qf3IFWRiGON5-IQsbQN_4MFwAPq1tYVhqr-RsoL_pwFwOIh_EJVf_BuPoMr_tu9r-e_MYMvJ6r-OHvEJrbC8eVf-gBhu_0RTf7L-FRgfO2pBYNV1gx-OnG1JYEDBG0oAz-z4FbARkhYMvJ8OLO086-yJ21JZdrwdbVx41n4xVl4MHmVfX9uNLatb_BSygPI_42wX2qn-Q-zH-Z3-H-va0j-E8Un_3rEJkE_4KXoCM_Hh4mX-XtysNE_-LJrfzz-8_4hcI_2Fgc_w4hY_75PS_5H_OSxX_k_4vVu_7b-B_2aNs_w3t2_03-W_Q3_kf73-S_zBky_z3_kMveF-_4oZSx0P_6_wn_G_7Ti16CD_xfz1_Sh9b-ff1sAEJ7q9ADdL_-f6UOnfwAOIuQEqRGot7Wb6QwXQH-0pgHpApbpl__z7AQYWVRFuf8j_Sh7D-fypvQTNTL-PX5zlgt-55adqp_-AAGY9OT-rQplHNtWTv4Waje2sGYV_s-A8zw0gF_a3UBwAcy4-gCIAf0oxI64gJLAAb6O_iD-FeDvJogMH0CYAe56017S_lUs5AHolggGuHgOsDvwnuDDysMUuHr0krhaUUg5AId-m4zHfvUGheDnfn1CV37ICO_gE0AMgHMAGoDdFlt0NAHFfPUAszgIAZQBPAGRmtQG8IAUAe0wP36XfvUAzgA4IHhAtixyAYYg8najAHgBNwrkDoYBOACbvm0Ec5JnciF-PQwfjiXCF3IrHJgwZKDoqFGmZAxrCNtWkBBi_sAEhP7xuIj-D_QotDG-O7I2AQFadjjGaFT-vb7wAVgBwfSfoOL-hgEEAR5cifZD1lZuKuqrWNtYfP7f_tL-O_7BAIJuTpQeAdoYY07E2vG4uX7i_okBN7irWMb-mv642hr-9v5a_qEBDBS6_k6U-v72_ob-cQEyMPBgQTA1ATr-5v4NAZ_OT7i5flCIHpQJoCH-B_7kAGDQaqAowP_-2P6DEs4g_tYY1KMAIf7u_gRW8QBfxF_-Rf57_gn-QwFH_s8uznrM0DkBnszi_sjGMDIu7HMBpW7_2KMArrohAQAB4v7lAV2o7QGkyk1u8bgbjiD-vgFSDMtAWO4KvhW-eb4IDEPWx9Cs5tsBIP4T3FlAnsxj5kEB_DrjATL-4QEqASyAn6C4AagBF2aJ9vEIRtbeevMs8QERFqeOpjT1fvJE1dSpASsBVAFhAcrQuFbb_p4BrxQkuqUBcIF2_mr-21hdAdUBEAFhAcYMev5kgU0BRv6kgSb-NwHO_jFsXQFh_l4ae1bsJGrY__rxAAX-6wGGcCNgZobs_v-AnP6ggTz-EiAAAWf-tf7rAYoiZoxwAVnQndAduFiBT-Dn_iyBddBZ_msBf8AwRhsB0szZFqdwRwHHgB7-8GBG1tm-vyRBUI8BCQCAga8BntDvAYF-CwwYHAD-1gGSDpcGAEJJ7tHSEr7Ptry-7tjXPt2YwvaWQHZMTz6TiOGIINz-wCDc0EjF9p100WjvhuAiHmhEjKBeD_hfaOC-63LI9ka-m641iESMf_SnTKg4k5ApgZvog-DijvtOj4wCEL3WT7j9vuCy_QBDvpQBo77xit8gk77LVMu47DrU4J8yUg6PVgPUIoHmtnPqIoGREIwyN2YJvg3UvfTGSHQOqnRcASr09AyBmg1yKxjTvif-RRZePA2iyVD43N1urcS6mPjcX3L3ZOT0ob6Ofq9qUYBOgbIapr7qJCXUIAyH-nUMPfjaQN96yGi_elGANNTmqCDkTRzP-hlcJ4GjiAkBa-xXDkdcqGqDXkICz-BnwJcIhg6GRP5Q-Nw4Op-gwmxTQJIA-GCh_DHwoQBgAGYBm3b8QmB-DdRuQCDcfwS1AV8B0TQWbo8k12wN1JGBYfSwQS3qMe4fAT-wmYGKco4SHdTIQVx0zJ5gcMz-UYAfgSgG2AwPVj1WwDRxVuRK5B4OpOlWKTTx7uYAugxZgQoktbaWNjZqTtrvuk7a23hBganyDoALukfAS7ogoOKsdgDR9gOgMfYz8OsYBz6CSBe2Cu6l0kruXdLjtjE2lIDw-osEQpCD7ge6MIrHuhpBns5TttsYM7ZMMHFo8EbztmWmy7ooIG6gBJZeVm_wT9bRVsnwPqDMNvpIr0B4ln4i-YASNl5BAjbxqv_mGBav5psyBCBKUjc-i-7ciFi0duCfKjW01TavvGMyTKrxtDiqb4g6ipug6gitMkNGF6qUqo9Sh-ZhoAlBdbQsqmyqHKpcqh086wAzKrFBtTaxQcsqZFhyausqt5hSqkPypUE-qge0xSiIeK-ICCpqwMGqwUF-IJ6AAB7IoMasD-79NJ1cIKCMNJdYLdK4SCNB7HSIysD01zxnrlMYmPjUYpt4yMSrjrjgZkplQXMqFUFLKlVq1UHiqpKq2ypaqie23AqfMKbgrw6U3BkgKOabaNX2SybD4LJsimwrhMrUc0EE1GUEz2BCajdBIypFWBFI8jC5XGvgobZHAGHmL0HXdJCqgpCSwC_AM0BFWLlcTfbQ4l_YIgglZluOXAhsaicyNg74jviAgKS14mjoxMiw8EJqLxboemcqQyzHQQfgv65UuqQg1tSiwKXU8jC_IH-OlyrIfGfg08Q8ahnm8UYaQBHm8V6u5O_gVNhHJlsAnkynQXKsZnbfNIIgYiCvDmjgKc4fwOiqk45clOSAIeB3oC7kbPSnAM5IMpA8HjAAl4DkNk-AgGjKCAZE8SRiwdq-tlRiwe4AKsFg0NpBpuBPgFDAANq1WFMYM9j-rCnOZozrkiBgmBaiqgpY4nxSKFrBEsGtoAL680yCYAjYL7TWwWRY-sDulh7BVFj6wNgWGVzewa_mNsEiNsoQ_wD9GE_ggQCsxhGmteJugIJgh2y3AFAA4sE6wYb6LsGmwUcAL7R-QY_mQjZAFuLImcHoFi_m-oD3rhQuWAhUNq6AFQGUNiw21Da7WHnBgoqBQfqA21gVwe5B-gDwbiBgE3YmwXCQ6cElwZXBroDiyI3BRDaiOIkA6br-rMkA4sgpzpDYWlCOZAm461gfVmPBHlSd3CwAZcHjAOrBuABywRXOUwQLQQDg4hC0pOIQg8GTMNXg5sEvtFCqAgCTjtXg28EIkLvBcqD7wfqqf756ODI2qNbrLE3BNACeQRtgfcHkNice1la71vo2QniYNtjWq4DzwTe2oXrgTsKACcAjSLjyzkEFAD_GoqTtmPuK_qyBVujWWUQ-QS_ByAjiyJZgUVIGYGFWf8EbwSTAWmS1uCAhYVJLAEfWbjbX1jAhT4Hn1tAhxHRFVlfWJVYkIUu4ORicgMIOxRAJwfYA2r6aRIvyToT_wfGSPOjLwawh4oCKMhFENtrtwWqgWoSu4GnBWs49ANA82LirgD4ApQ6CId8gZnIZXPQwEaTI_pHBbMbmAMRqTy64ZkwhLCGBALJAB8rHxFohuABCwOQAkYBCdkPBjBSCwd1OxGovtNyW0faRyMaOXCGJwSwhOUgVWB_BNpIOIcwhuAA5SOl6zNCeEAkAwMECpvlYfGDSIanBHcEa-phSBiHJUEL8zchsEPoh3CFGISYhSwAXwUIhhyo0YmaMf5I3-jHB1iEdWLYh2xqclPng3CHOIcjEriFOsPkhjiGeIdL4sSFlIZEhuiExIcl6cSFIQAkhLQBmIbr09DxpITgAD2KWCJYhZow2Ib08uSGsQfag3CGIUJBgHXoSQOEh3CGcYi4h4CGojs-44yGCYgWoVbY-LEwh2sG2fBdamnp5nj7Ky2DcCnD4hmwgQGt6SYgZgF3grbB94EB-LnoHQfMhOzoHITQAona8IdS4P6BUsHBQGThmegf0N5BRnmvukCgpembwYiDipnV-VFzmmKbgYlBNph16Ovo4hoChhYBvDA8hAKEm-vhOwKFKUOKm74xZwnxgZvpA-qSwTDA5PID4YiCQoYYYzaZUuBihqhDWGJ32yCxg-mchAsZwtJL6nHQJpmYGxvrrMIwhExAKQQAMMkENADgAgSoJaMke21D2-giQavolMOPoZaSycDuiAhDjGORQruD-oHyhbEHWehZ-2BT-rHgQCkEIoBKhWuxvATEUyyGdZrShSO7dyGKhMGiOwVkQDyCFoAfoMShc1u2esARqoZ3ukLxn4D4QbUCKUMrB_gAwxMOwfhDmfqAQ0qE2YITibJr5GGnGeMHr5Iqh-6Q8wa6h_Da35l8qsUH1aEsAeUF7oElBeKqpQaKAyXq0EJ6QvMETDs_0DQCyQTgAUaHYurKAScH-ALqYLqF8wV0AyaFndjzod74y6CXgNqHwQbGhjKHaQcr6-iEEUILAaQCAIaahOUCKUDigeaFfxmqhIWgHPkAgzRCjiNpAilAvXJPo0XCmNuwAVnza6KihlXqEEMMhxhiWpj2-mpBd9Lm-sqEIoGl6g6HYoYQQgyBjoRhUX3iNPA5Q3eDxIAjwLABrjpJQ8H5OcnWhlA6tfmgGcH51oBuhlE6odoXgOKDWQDTesqD9Jt7gy4QgELWh5aGKJPIQD_bHod9W80CBoVhYBUHJNglgxUFhuAmurvqT6G0AWUCxdAIG6baiGnQ6gGGhjEUc3NoHoQFaIBCObB1mIGH2sJnAoYwfUCoMNAADoNHgAToQYQ9soNBoYQQAJyDdocEGJNhcICQwaOBAglQGheDwYStmiGF4YRhhIAZ4YQRhGFRUYXEUZqBCdkBmgvTQAPlI8DCnMuWg5DBP4G7KKzhwhkX6LlC7nLyu0mzl5O1IqzqKXMhO-6Hf-nkK7C6oIOvuBX5A-p8hpZSmqBGEDToWMI-oq6wRMHWmOpigwEJ2GmaGyOtY4jYjjOgAiUpJ6LZ0roblHNQQpmE74OZhakrFQMRm2dB2YUMWFmGKShaAs5Sn5nTORLC2YTSG2QDuYbHo_6bOYQTQrmEBYWpKpQ5yNvJhm3bOzgCuh67cLh7Ok7beztWh3ab-YQ5h1mGEGNphwc53ZMkYqm6IgJJuXG7cvDxurGBPHL6qLUEBqu1BWFohqmAwOJh4mPUkopCeniKmAOydBPG4FQ6gAmlhgWFQGOxKCtpnEAeuvWFuzqWshm5qbvQ8hWE5QMVhIMRaMnzQ-p7-nrhm3aEdoaSgKfqvRtz2NaEy6BehBQBXod9WydA7oQ-h91RPoSNkTrbbUCl656HmqGgAwkDIfMfEboHqUIMCrVgOUBehik4nIXehq2HdJikAG2GC4tmhZ6FPYZgAp2GtWKUehMy61h-mFgBWEp9hik5nYU5oW6HQ-k5yd2HfYW7Yv2HDHiPOtoFskMDh0OErHr8eax4SQESo9fCjABdhnS7ywfziTHZo4BjhaLLnQIJsH2Fu6FDhqAD_EKUe15YZKsZhxLZ7Ybah96E7OLthfgAa-qRWj2Fu6HWhzOGQDi-0ExiXgLMAyaRhUPEAe2HV1Adh4hBC4SzhoyElMDmhZOHPYa9hYg6Dzuzh6yCc4eLhD_Yq4UPmOs7-SFSma_bMILNAYPodHjHQStRwnh8YG5rfmoSezGxs8iuyJKFYCGlAc0ZZQW7yYmiH5rThIpqakFMg-NSIRPJAqsCu8iJok7SqwILUnlxkIuIQwVwQUngIjIC5VBlB2EZUqjSq0TpTwePsHGjZroUuvZR4CPm6P2wV-tfaHKHJ4R8Y-Pip4XRuAx7fmoUc8jq0BMrkSeF54STsIdrCOl92ZEy7RC9Ez4x6NFzSOkSypEbhjPZ3LIHQj9Cu4XCM2vIcaG3hpNSS0hrIl1hOeI_Q8eHO4eCa_vKATHbaJOzUJDoc7ZwCEIFcERSyiEbWGZJ7LheoPuyUdg8aiOyAUCCBvvK_mv7ynvbTLqJay0TV4aJh9Vx14Yd4J1Cb4VieFByCnC3hvdBd4Q_2HeGT4jfhOCpV4e5I_eG90IPhfZKW1DPhT7jcrg-4wRqL4RWWBJ4zOsvh5ZxPxCOSmHwt3I7K_bC7RtTgreGIIMdq0BGv4dJc0eGMsAl62BQnIdicTeiKBtARhbLuHtqeBp7V4AceTR615vgRGeFonsXhGJ5m4UG4WjJ_andyfJ5ynjmYaDKyniNu9BF1hLahYBCiOIphOPqUoSph7MBiIDlhh4xAnlQuLp40APtmj2y-2tUeghFMnLXmtM7sLiTYa8HzQU9BmbAUpNNBksByEUDIChFT2BtgJ6ZhUI3hiL6COml2SKEnkL54y6Ey6KuhgjDajv0hnDzlFCQRuhH2AQ6c7pDCGrYco0ACjFLhQPp0FLdhJ2H2qG1226GssAOEZEwR4Mph4qHTgD34a0RngIOB7orbVv4RARATlOImIDSUCrs6MBGgILgUQ-GEANmuXBEw-vrhmpBK1GQRjZzmbMQRpuGAEebheAiQHoihhchzzOIQ1gZWAWAAHgYAOBEGheCd7gEG0bj6pBKggMA6YInemsrJ3u0YqWBJBursJGFVQNMGYIbJBohovRFJBh4gyGH_ENiGUJCjEUBhrViFBmcQoYaiYeXm3CQeYPKwnVzaeBwIRHp3LLyGw_AbEaAgvIYHbDsRUVxlrp1QtZC8hoQQ1UCvBiqkrVj12M4Gbtj12LyGzx7VQM8evIaRoa6hExEvEemh7HrxMEIAIgB1oRMRjOFpALyGshFlBOvB6hGCoNVAQJFzQWoRC8GKEbAAvIbMZKguBQBgkcAALWCnEUwwqRj13kO4ixiSnmKeqJHrMAaYGJESnqKe2QCdBgTAl1AjYPqk_REt1Ds42eGmhisRxqxrEck4xrDY4vYSnbigILaG1-GwEcDwexHSXOyRceHSXLiRiaDnEUwwvIaVHtgANxECEeE82ngPEcAATxHaeO8RMDhvEWmhMDi8ht8RNTAghpSR22E7OICRKhHAkfIR0JEaEeCROpGQkVghgqBwkXJkCJGzgEiRPMCZYv3OnZLJ7nzAOTxPgnjA2niEEOiRRHpYkUSRy8QukUww-JHVQISRdBFpmCSRyIYJhmx81qGpqHH-tJFPuIwAE0HMouLMYKB9BmCgApEAwMAAFxGGRGrg8TzfBpcRtxHMwOKRy67YAPcR4hGhPDKRhZG8hgQR8-a15ryRWp7TYZNmKpEvgL8RGpEOoZ8RMTCkkQ54TnjFhn--TTqoAOshI_AVhnWIVJ5Xio4yJQhv8B8yejIX6kIReZGTZgeGY5FlkXbA0WxTkeieOREA7A2GGQiano2cFBE0sq2GjYYrhuyeo5FhoI1hTqZLkUuGfXAWAK8h2JihnuuGy4bmhLQRTBFSnoORTYj_FIwRfxDEmIOG7eDdkSIKegBiIJWGMaBzil2GW5FqKri2b5EFnozAnL7aDG40wkHgQLl-Qf6zLiOQjXI0AHpgoTTnPrBRBAB6YMzWN4AnIMqqWFrcyLp8_-baYIZw8kDYjiSMLNRngOW6pohjgEhRemAs1CEq-xBs1Eh2qqAUUbmKEIBwUQhR7uBWFMhRqFHoUVkkqqovoCrAOFF6tjhw-FFb9jiOOHBEUWOAJFHzGrRRcFGUUaJR1FHE9nRRR7gJ1EhRN0LMUeFA5uiqoDdC7FEYUVxR2FHSaHxRYHACUWuWqg7PwCJRhCxOYOJRilFGQFJRJlHyQLJRNAA3QvJRu0q2UUZAylERQBmg6lE4cDgAaFGaUVhRPFE6UXxgeFHygARRwlHaYMRR1FHXyAQAdlHWYNJRplHe-OFRFlEMUTWASFHvQs5RqlHQ_kJRyy6eUZxR3lGCirhR_FEBUYJRhFHBUVFREzZkUaqg70KWUWJRNlH19lDA9lGMUVVRyVEylFVRGlGZUW-I2lEEGLpR-T7tAIFRYHDGUWJRYVFlUZFRVlH1avX4VVE1UTWA2I71UV1RuK4ZUSqqWVG8UX5RuVGdUflRQVF_wUVRpFFe2IJR5VEyUV2aG1HxURYAdfa-rhNRgFa-rk1RM1EtUT5RbVHzUXpReVFrlsdRy1F8YCFRplGEGkdRekCbUdFR21E3US9R8VHt4Ll-4jZU3H24VDg4cJRBaqg9iowUFxQI9L14674fwJBBAZSDCPF2KxTwJnxgY1gAIMnK2X4SqMZowZQI0coabVjFwk4UdaDrvnQUvX59_kWm0NEY0UuumNokgSVIT67sXjtY4NFE2hmQ6763WChWwZTiyPjRrVirrF7wHwBkII4AmABA7BAAF6AOFFgAtNg85hLB0-A78ADRFEGQQXTYqcjDyl7wkOwuMLGUnt4gfp1-ARG6lmNYC_5c2vo68NHI0bMeuNGtug6AmNHcmvrRhFLL9IUB3IFIsuRRlxAGys0KdO634BR2rVg2EL9R8cBi0eC4gNGS0RqkaIBy0ezqoe50IbS-Mn7P8G7RWPTfUYn2Y34B0az-xKx8GMPK674InETwfbhjcEmhXNHFgJC8cDSr6GrY5FEkjLqYkEGZ2GYAuX7-QKOoGir0BkMBIRbQiA3m62DUwe4AnRC5fnx0ob4kjEDRg2DagYf-iiI2ECFSVX7coN1g_tRvJPXRwwFUUQIAYwERRAa6Djql0RV05dG-0YJ0iQBA0WHRCPCCgbhouX4jfhKUAf4BYJJQUFHJCEvRvMwjJP5RebJeWHsaNCi50SgUrtETfgwBCYqj0ePRB9Hn8PjgztE10QHR5hhOsOLRTP4B0WGgjtHWktfRLtES0Xz07WF_UefRe9F02AdwSv6J9n98jbD-_r7Agf6z4IJgFdEgfr7-z_RuNPPRuKAr0eUYpW6vYDqBf3wSmGGUFgAAMfMAQDGGcEw4OoGGcOzRMEbugd4yI35AUTeG0TKdXKs2IkH4QA9-4kFagCCgJdJEQGXS6kHGIMky7z5pMv22dcBSQe5AhaH-wNKhSkEaQUcCX8jvGKAE0WiztpZBf54LtvuIxTabKsOgqOjlNkDooqpLAOIxZSrEimU2cWAyMTy0jIrPmpFBCuzMbO2uKa40rp2YbdKAtMC0EEYOUJoBHgCjQRygxjFvAFMgQUZKrlQIz-DHQPTsdi542M0AvDG1yPwxSnQHAOembxiVxkJqVwjQfBxAdgASTnuqvGoT4D4AEUjkMLxAv3obwBN2C5QGqKGq1JgY6qg8nVIuMW5AbjGhQH-AL3Cyjt_gA3hgAB9WdgBEVkQA0zAvtNIh3-CgwHpANggvtCPBJTHwwI7WsMQTdnkx6UAFMXsWZoyVMQUxb0I1MVCMOTGRyK043niaep1c4vRn4BbgWoBW4Lmk0r55kJchQeDoAP56_eDjoUD6xKGhZuMxonYvem2wD2HxeuUAiwTexN2hvnpcAProKzFA-tXAf1TnIW1gzbBLGNL4NyG3yPch_yH0EA5aY5yXMZCQEJHkUFCRN7Y7SDCh-BD3MSCR-pGCoAYRGng3gOiApCADyBaRKQBSEBChqhBvMXqRTzFBWHHuRKF3Po-AVuGW2qAg8IR1kQ-hjHazQQ8xJpHA-PCRRc6IkSp4aRFKUGqhKYSmyH-Mr5AToW2OlpFVREnKMv49SF9YVSwtKgwweBxUsWEBNLFzgI5EPnAAscr4eLFjgD8x1XSsscfk7b7YFFixodgQse9hnLAcsb8xeAD_MZixpLGVQFOQRpGosaCRgrF4sQ-h9KGFocMxYvrhEfUkqpHK4XKE2UCnvjZ6OzjdofwgnLGkINyxUrGeRPIxkjFJNioxXLhpNhk21zF10X1AzQCWhJ-gP7hfMQn4XLESsYCxyMRmsUoxFTZUWLw4I3iUAKkgcIA72stAiEw_AfWQrrFGse6xw3jLeArh8XoGsaKxxrE08moAhzFDhgQAhrFisZjAibEbYKCxjzGLQRnYzyGF4BGxGbFFGFGxZLEjdjKx7zHgscHYCbqsRDE2cTYSMYoxuOjSMeyqePjlQQsqlUH5KA5EdbElNo2xUjHKMS2xXLhcWC02KsBqoYMCIrFusXyxkrFJsdgAKbGA4fGxE7EksR6xlUB7eOxhZyrWsQlg9BZ3JsYaogHjNLWsroBSMBjiHlRxAPZh4rGTsUuxi3guEc_wCbGlsdWxEkBesU2x_bGiqjgA67GmEFn6EaGisaexi7E7SLxiojgfeKzSIBBFsVmxGvrHsUMWn7FDjm5kSNR_set4qzDEseBx5SDihET-sbHvAWexgqCs0lBxUs58YACMKGrCsJYxFlBvcvixSxEE0ARxJKRjgFmxe3i8sV-x8HEQ-GO6AOE9ofsxKtRoEbs60VwYdvayHxF7HDixbBH1JP0erJEoqI_aQpBvDCOy6tZBkCaynWzjbEJx5LGnLBTm5RxfMY2RdrLXofIc1PowYaFKRLG6sRWhpyxvYSpxVJEVoSrhj2Q9-MTCTqHj4GpyVnLopno4o9iSNnQk7_BlbAkArtafGKguXdpeumWu_lQHbLMeJYGb6h9O6lyROAbg8jD8YROqsLiErLTqJMiXOivgicwwBOU-bnFM2Ona2ngR5j4MvNjBHN5xWgHiAbMO13SATgwU7nFSHk721a7FQLWu-rD6ERjyzLZ_yF1-mtZx_pc4CkB_VoVxUlrldtA0YbigwGZxjIBw8K12u2S-5J7YSQAzQegANnFYHg9AzIwWsLhx-Z7sHLoQ99hApO_w_8BxrJS4BKhWcVAA7XGlTqk4E3GUCKfy2BRQTs1xiQCtcTZx5MReusXBg2QVAYNku1iZSDZxcG75AfOyVThyCDZx7m6_BDtxs3FPRvNxr3Z_1sXQKPLmga7kLIBq2ENxbKZPsgKmbwDKbOW-MPprMUIAiQAmMWPk3XGmMTdY7_A1MQIQU1Qr0v9xc2RA8RrUry5nAbJkmqZLccmku3FXccrWJ1C3cWcwmJhuMPYutjBPcS0er3HQUFG6s742sD1xYyAVloyA747xenLBJjHD8KmhmCyuoe5QyHGUccuxgfi_wSf-4PGA8aTxhDrxis4ADNxCJC4Q2OFccXPqZ3EzTBdxOv4-OKF-3XI4ytom9g4I4TgAY7HRIETx2cBc8XDcOBAG1KL21jTSMmtsnMz9EA3w7K4_6jSuAtAzELVxSVwKsjDEgvG2cUXOb3Iw1kXOQCSs8Y6QJPG2uMLxGQCg0GIGkC7mkLLxv3E-kIrxVNzK8cKAqvFQdj627K6gqqjKJDY2WMthkBB2GtBhcmHTzsPUpx6B-M8eLaai6G5x8fF4QOiRSfGsoBShARG4sfUkEG4fzlTR9djbWDnx766FkfnxS85xDvtxTEG3ttBR52Q_Ll2sL0hPLoVAoG7g2Ir-63FdTnT24P6YbjlAgK41Liz2wQ4sLnkBMnKSlih-vZTiXHDh5TTOceds0-GHcYbx4_5rccUuaLobcVBu3AgjZNrx0lyvrsdYZfEipBDasojlrvDsIq5ckiuoba4Zrp2u0lwUbqGOtXR9rocRoa55DsMUd8Gb6mxcmwHRlgyEsTBOEmbUw-AEuFrYda4wiJ_A0ADNvtw2cOFV_jQAD86b_mjx3kEwQGHOicxwqveUIBhXDgKhSsiQZu4A0gB6PKnAd3FvThxq_jitwEpA7-DYwPDA1H6kFsLkNwiS1O_gmADCjgDOQBBhzvIwnOzl_EIAOXy87PfxGVzGpuBmsAlTGOYA6gBI2ISsBlozJgiy44BI5LBq6UAevG46bgTBplYw9ORcHFYu9o4eHBamFoCSAKdYd3EvFgA4-WCcHE6A5DATgDrmI6EcdDDGW4jIXnQYMLKgqmquNN4z9ArmCaQAsndxWtyiDAmm0Rxl3PQJMAmTGO-UekwmYcxucETorgxOHS6OTHWgrpGLGLHkwFTdQGHOu1huCWkYLkwEMMxu8jAa5sTcDvy-CS4wAyy05HYME4BBCSAAnOyyFhYJVgwMCdYJawBPuGHOpQ5YCVGW4ngggWEJ2RwxkGHOxUCEEPiRlbhhzp5hpZL0qozyGppsGMSYx-Zhzi-0ETAXKt36FyroABIwDgmjFDCuSepmjPUJdWFsunxAh3ofVhEwoJiewC6I1xjRALcYjhpOzoZh9nEyEAMJBipFWoZEpGbbGHwxGxhpMfi0SRDVCXwgxJgnIN5A2r64QaACiwmuMRsYqshNCXRhTQnuztsJdXQ_8T4AjraeCXlmI2SgofiAZnI3CckA1wkxkMkAPglQoQmmjwmVuDbxxPFA8W9snvGx6mag2nhnwfEwY5GxMH8uAlyUeOCuFfhqLhiQjLHqeKPY_c7hXOCu5sFQieiuKc6wiSl-KHHZENw4lLyAOtPxP8qu8RTxb3GkXPKRAIgDKgzx07Gi0srWXzoIqPLxAAwWMQDxoCCdBGSJXQD7wTexVIn4EV5BmnHJUNex2Im3sd2xEjHesZaxb0o5Njuk54AviDfB9ZCycVpk2rHKhEyJgAQPof8eUqjEcUh0QP6VJkMEGzGSUFhxKgg4cQqJ7qh1cil6X3GUAD9x8vHfvny4z77hoapx72BimN9xnmDwBh8c2dR6OJRAGrGKsRxxLij9sIixTOHPLFWhOrFacaxBrvHGiaaJ-onyiZecvyhlod6JUXLr5HKJqomUBEqJdUhmiUGJs7Gn4KgRDu4LHlEW5lZkBimsvZEHwMaKw_DLka6Ik4BeieZgm5Erkd-R55HBCJoyr2BXEczAg4YnkYWRdYlucfORat408R8RBYlB8BWxYLF5sXK6WIg6iNHeLLEciR_wdfBViYtm6zDokY2JhQllXneRljITrg6A0dKrER4q7L57PC1qMZE_uqWeazYvtCFeDKFGfhBGJfhcMVi0YkFwQBJBykGf8FJS5F7K7j3SyTFuMWZB6zAWQdmmaEb1pm7AGkGCqqrAwqrnmFRYNUESqnVB2yrURpSKWdiaequJJHSbIYMx5oDDMeMx-yEZsBMxUzG7MTD6czG0cVsxLFBS6DBJMvH0cSMAyYmqwMShzW5wcsWJ5cAZ8ZxxPImNkUqxcaFqEfIQwzylodaJ9fBHGHkaThzlHK6JTOGyiWahYZGbMSccyEmyceGc6EmoSYxxTvDbwH9qsUZy0dDshZEm4VWRcJy15lh65gb1YZ9-LEnAusjUgPDj8ZhUcRElqJ1wsqCyoCOIUwkKYBsewhGiSdsGtbEY2pdQ0FICENyWa26ikdSJGkkTkThhHpq1gIZJIpZx8ckRxh7lkQaeCNAWSY1xnoydcGysEkAnEMpJ_VZHABUQHkk2il5JWzCQML5JKkk-2FSYJDis-EFJXklhuLpJTuG3jJkqIFBGcuBQGb4P8HsSAM4_ABaAOVzJpBaAiX7r6k0uf1SWrrOA9gDQPKxgA0YviW-JoqqfibtB0qoLROu2hUnzBOCgJY6jIazh4LBWACVqr4mjoO-Jv5gVSd-J0qrkVnyq7C65QCrUuQZaNCjebUTzUP5UJxBqGjYIYUk-Sa5JOpBbMBTstsiyNBLxgDJFcvxgYci2oYkmxtS9umrxgsBXGpE0coz7JDWJ2vhYOoJJllx5STVJRUkzEMiCtUmJBPVJRyrzJNyIVwBnVlgAgZrxNLW4fuxe8GFSLrBhmv0QiFBRzDsAKoL-oA0av0mpwLaRweG0QV2s_VTODM-Uj9AjSdd0DqDGzhowWapWqnNccMkaMMjQI3pogT_If1RDSRY0s0487utJLnoDSarUdjSW1KfULpqa8TEwxklW3nqeIkkOSTCUndDPHjTJwkki5lIR72ab1OdJUoI3SXDm4IkXSXVJkm5v6o9J_1ZYAI1iosmWQFmaDjougP9JqLJVCLXiBASgyVz4bTZGum62kNgxER-AIu7PeFRsFgAvtMsGKtRcCNFG88AIyc1IqcAa-vwcdhCmjNrJko609G0OX3AcaijIjbAl-McOI1QzQBpOIvyBLhOwCI6o2ObJVskQ9AJ0_nZvpDkqa6znJvn2p3T8_siODPq0LCmgFkBJ3gs4dqqi9G4gVaoc7IkJJ-Dvirlc7-AFoO0Y5UDBPuYARWYJgOyOxMn5SSkA3Ml-wHi4sgykMMTJ3AhSguIhdUn7eslIeck-yeh010lFSZJuKSECaokJyILVybdJ9clgjoCW3cmndH9Jn3QyyS2gfcm09IhQ_c4jyRD0RwI-DuHB9iwjgH0kxCyQdpAJj5TXdP0g6eoaThkJDAwiNFFGbq4rFG9OKgmyFubJAfSA4cTJaBTDEAdJWNEVeJrRIJ7HSaAonMl8vMXJW0xNyfzJ-qpxCAJUhsipwNLJgMmVnArJEgTaYFPJyP7ULrUIWEkcEYmgYknHkJLI83gJtpZyk0760OuIgRxO4SJQ3xgDoAgp-tDfGJouBnH5oNA8NU6eunlmPcofQOYILpgh0GNQJskF4ADJ13byMHaokU5vpFiYODDFgJWwiU6zFvKhikgVoYhQUhADydFwX8mAlg3m6fC4Nk7hGcB7cgloFGCmQeyUN6FZ8cXBOfE56hORxfGTLkNO4NF58bfU9dhNATTqny4ODtXxbgF18VX2gAlN8bPxZpTULsEOt87orgiuNS4jZHKQdNHmbk1xF3jjzq0JooHs1NhucASutpUJIGCELrHBbQkobhr6_8kJ4t36pC4uKaPEqi53WOMJUwAGYYkhii77CSkxhwkoBLUJI6EzbgyY8WHNCZ0JtWEMmCOSMwmhaEMJX4JQmA7-GLhm1C40MGBwKWIcARDlWG0ch9RhkSp-P6AoGGxhZoHACcrGBvTP4AAAvUJusgiXuqJwdjBRwd2wWGYMjmQaFWwFzCMOiAndAi4J5dqoKcxuFRCC1sRkzG5UDAMpAK4fdsY-EOCH1Bwc2xjTyeqW9Kaz9DDYz5Rs5IZxc1QnyV9wyq6ZSPqu-f4eKeBUnn5zchaBmB6mTm_gI4BDqMcAW0m7AMkww4gWphowRqaJCQZaWtrxMPwpVxBZANO2MAGOEnqBH6xTABIwt05Kjtismylf7M4wAhz4gKvJSAkqRHdKRKhDIW7OCY4wYGgprOHRzmMpcKluzteWsqrZTAQwmwBlyQSUS8l-wGCpAM6twIQw8xjBOKiAi9TPKHAAopiogB4gTpjqLh3xP5SIKcxu45R6gU4pVs4pdHspuP7pQBvJ9GaQwGJiJ3IQqU7wDE6xdGyp7tid0N8pYb6PZmHq1MGcCbKsNxJ8qeQ4OoA9KfLBGABIKavS5KlXbJQA1KkLCQCuR-h7CQCu_xBfKf1x61ghqn8pdBQ19sdwCqmkqXKpUKmpwP8QyqmqOhSpZiAaqUJuA6B8qDqpHfHcSEypPjAGYQjqiQCowDSpE1AHCR8YZoY11vKpkdypwNxIyql1CQkpXXjRAFapLoDwqZGpdJhImNhSySkLgKkpkJijCesYSoHxvhRJf0mUACYh3qm8qRvxEwn3-okAzth-qUsJganaeMGpsanWkm7YEalRKRcqucAhqXfUQikaLvEpiamJKfq6Jxj8MWmpU0DpKVmpgb4USVdyZSklqUjqFSkE8f6JspAfyXmp5SmVCTMUd8kFAA_JMZB_LpcufLzzZCehMTADBDVO6M6Y0nV00kRYKcJM43aY0gPOFQkXisipAK5-qcgpMpzjKdwufqnoKc5KOSlWKZsKuSnByWF-VhwFyXzJt0kycTthrCnH5DkcjJwRiRWhOiFoADzYheLqNoWpdgjrcUEOAwTaDiEOB6mBCDupxim7WDBpAA4jTmvx_n4UScTJxcnKJPBpUHTozvNkMcC4aa7siQAEaZXJ98nNyfqqxrqnoZOpZ-CgaXzxPpQ4IK8ptADvKfjJCJB72Kte5hZlCc7Yb3I8_rikRomXKaQBOm5zKYMSVwASgZ3Q58lUyUdJfASMyadJHMkq1IXJD8nXJJ-p2IACyf3-W8j3xB_Jg8lfyRppPCm_yYA0EMlCtoLqhvZFzichLJo-2pmJgEnXsH2RNYCHqNOJtjJ0SSWJv5FliSOh7YnVidmRo56wiIQIYaBMyZ5pTjJMRizJGtBzkbuRd7C7cMFps4nsOOoqgEmEMVEy6yDjFrmhZongUWwqm4kSXtuJgizGIHuJKqHcMT3SkVau1qXBsfo1wQFBBcF6MWFBIUJr5hGBPqExQXMq_qGEigqqSqrNUUJYv4mDaCSq0dIOBnYAjImXWOHeYw4meqyJVr6DiTEExjYk2EXcUQBQAGoWZ-AdjvJxsX6SrswpvTjFxMqxxaHMIC8BBjAaMPoUQCAizKqxkw7huA4xzRb2LokJ24mcwdrhI4gKsdSRob4MoetSnji3STgAK2mxAGtpvgZssPKqTjZ1aadR1TJEcUiYTnofQCrhb2mjzlNebYoB4SN2rADCocsiNHG9lINpSFQjaXKQkzF0KQC4AyZxlIBp_4AP8BgA42kxoXGhAvCo6CKKE6C9hM4AD2ivoEeyFrDc8SwQtGBudpt2GPgJoV0Ae1pzVCdpyrG8IWpwjTydBPBSFgB06dMqFWmttH6h-sAvtIIW1ODRQczpVWms6bXiUokgENJ-nqEfEURJjKEk6eZwSpHkiQMQMQDxAKLpZOkWESl6P2CuobLpfwT8iZyJGjY0oXURJxwAiTzxdwDJieGcWulUsDMxnLB46d_I21APZmrYk1HexPdpiqrhKPVpK5gB1IAI5ulLUWoOVumPaZhRaqpfhAHUUfAOik7pz8DuKLhGD2k26U9pdukoRENMm_YGUWlRvuku6YHpbulCWJKaeLHG6fQQWlorYMbRQP7N5Prp9BCNITbaqFS26kKxIWAJ6ZCQWABvJARQ-el3AEnpBACrrBkp0vGcweYkERAkabjpcNw16YLsbbCrrNy20okl6a2g9y7F6Q3pOBBl6ausNB5MKdXpYlAxbPXpVNyN6b3pQTDx6d3pieltsA4pQP5dvn1pvXLwiVRxgerhia4RhGgfEUrpS-mM8ZF0GFRJiYbpeend6QTpWtZHaRWhSYmZQNqx4YCOiQyQGWZayWaM-uhXDtJ-LNBC6b-u_P7v4FQEvPTezCaYorHYuMPMWAgj6i-0FiCFgN_U1AgH4PWM6DBsMM0AXw7kCQWQyDBPTn8Ai-A8CZ9BAuG3QOR096EBWIqOpckqjsIBRLATwSp4W4jF9NDwb0GBIbWAqBnICGxqMjY8CSoh0cFKQKIIUWEkGUfJPaEK6Rvp687K6ZSJ6yylLqvoN_HV2rSJ08CK6Sop_OnDiILpDdp_LgYoLoDeIeXUC-k0yO6mEspfDrIhRwCibmHB_P5UGcEA6iHrzu5x-gQAiLLp6M5pQJzpasAs6RbBaCySGUjyo8FGGZXpqH450No2fHHZ0FLIr8HUNvfBz8F5af3gzPHN_mlWjhnF0AVp2cFYFmLSxLC2GYvBUv4ienwZ6K4Tdr4ZWYAZwUzpehnc6RbB21YhGVMAJDi2voEZoxQjwffBjhn-umqhAukvbKLpcdHQURoZpOl3zrnp6RnMbJkZKBDJic7xWEkN8N_II-kZID3pbbBqoRV64UBa6fjp8GDiGcaUGP66KQvxW3FQFjgQZimrzrlg3PEZ8WxJF-l0ACdxu5a2oYPpqhBpDhOEnMFFegtedJTCsO3p-Gl3WHTxRulT6ZCQJGmLGeVAfCCi_tzxXOH9GfMZKjj-KdFhejgN8A0Z_Rk7YfAGLnFNDNja8_HlGfQQeNrHGXjp3RmV4X0ZoxlnGYMZE6YHGQIQUxkfVkJ6-ZbGaYoiDRmokE0ZVuE3GdCeoxnt6WXpojgiUKCWJxkvGUzh5xkPUKI4pKZ9TitwSKmsANCZeOlyxqQmpfRQmcUIDRmWiPSmke7VThme8oDkKtcwVCakmZfELMQ-lAuA1YT_pv-S1soSrkFQfRm4rJn2RDL1ANqAE6qTACj0yir5AN0qyQB6lnd6hUCRRjym0PCsCpEuqITsLhEA4oBXci4eeZRhUkZgEDCkpjoIZB5aXBImUXIaxseu0pl7EECBtYAQbvPx6v4dGVKZUYmPGR9x02kIoFdyvolA7P-proHvqTSZNzBxGSvKEQBVrLKZa25nQitudpnKmcPmiiaayu6O8oDHrlWsOpnS8ah8XYANGeoOAZmQsTWAwZl_EHjpK-jFCBmQeplDZDTRDfAmmRvqEHYU6XGhWumKUAUZQbii6YHQOhz6IPxe2hm8qspq8yw-7Jx643ZKaokxpgpXabdJ82mqSapMruQ7seRAdrJ8IDcI3QAsCb0JPCrY2H0ZCzj0CTsmAhD5md8ZPUIXcvmZ8OkQ6dTOp2ko6TwUBwjFhJjpvaCvoK8BL3g-7PsRFgBrsmMAp2nOcWoWfQA7bPKZigBDWOukl7FmmQxJ1aGT4XHuPFLKALnRTOETXBvmE_AzXMrcLtyZ3ECAxIBVAN4A5IS_gPi0GTws_KSUgAKZ3AxmkMCfmSAAOq79AFaOJXyZ3JYuuEAm4HBw6TFlvIvAL8AjzFlmS7ou-OUAIICvmTLizNywQkUwrty1dFhAAFllvPLU8CTMvKE0FXzmgObcGdY3QkSS_5mXgpniakGEWYjcZFnYwEjAYxJ2fBV8NcCkWXpAkMA4AF8EVFkmsAe6w-6kWQxZGOpcWbS8w-6jwOPApFm46ojArWIRvLM0y8BsWZxZ7jyRQEJZEbytNDhgIlnfoERg-CKZ3BnWKDycWayiAIIDagTYrtwZ1uxZDGbMWRBA54hnbq7CxlkcWQpAHcDDAdOS3FlCMfeJMpikWUZAnFmcWWZZz-R9AK_kXxSuWRxZSlmNvIhZBkHJ_CAA1lmCWWZZqIroipSApFkY6gKS3FleWbQCV5pz_EZZblkQwAFZ3bwxgRqin4Z7pqRZkllMWfFZXF7z7lu2i-7nHoKiK1z7XIgA5q4XXOu2pNzFWaVpac5mWbBBuVljEpRZtLyZWdUAcYGPJAmBVlkY6ojA6VkAgo2hOFlGWexZCllmWYhZ1oAxWW5Z7jx_YirSZsAoWSvBfsQ-KrjY64kMAEBgH8LUvgY8SABgPIVgrAyLiHnAstwKAPIA8gBAAA`} __position={0} __code={'<Map viewport={{ center: [0.026, 123.61], zoom: 5 }} />'} __scope={{props: this ? this.props : props,Map}}>\n  <Map viewport={{ center: [0.026, 123.61], zoom: 5, }} />\n</Playground>\n           </MDXTag>\n  }\n}\n  "],"sourceRoot":""}