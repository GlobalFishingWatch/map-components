{"version":3,"sources":["/Users/joseangel/Workspace/map-components/src/map/glmap/map.css","/Users/joseangel/Workspace/map-components/src/map/lib/Pack.js","/Users/joseangel/Workspace/map-components/src/map/lib/pelagosClient.js","/Users/joseangel/Workspace/map-components/src/map/proptypes/tracks.js","/Users/joseangel/Workspace/map-components/src/map/proptypes/layers.js","/Users/joseangel/Workspace/map-components/src/map/proptypes/shared.js","/Users/joseangel/Workspace/map-components/src/map/config.js","/Users/joseangel/Workspace/map-components/src/map/module/module.actions.js","/Users/joseangel/Workspace/map-components/src/map/module/module.selectors.js","/Users/joseangel/Workspace/map-components/src/map/tracks/tracks.selectors.js","/Users/joseangel/Workspace/map-components/src/map/constants.js","/Users/joseangel/Workspace/map-components/src/map/utils/buildEndpoint.js","/Users/joseangel/Workspace/map-components/src/map/utils/heatmapTileData.js","/Users/joseangel/Workspace/map-components/src/map/heatmap/heatmapTiles.actions.js","/Users/joseangel/Workspace/map-components/src/map/heatmap/heatmap.actions.js","/Users/joseangel/Workspace/map-components/src/map/glmap/viewport.actions.js","/Users/joseangel/Workspace/map-components/src/map/glmap/interaction.actions.js","/Users/joseangel/Workspace/map-components/src/map/utils/map-colors.js","/Users/joseangel/Workspace/map-components/src/map/heatmap/HeatmapSubLayer.js","/Users/joseangel/Workspace/map-components/src/map/heatmap/HeatmapLayer.js","/Users/joseangel/Workspace/map-components/src/map/activity/ActivityLayers.js","/Users/joseangel/Workspace/map-components/src/map/activity/ActivityLayers.container.js","/Users/joseangel/Workspace/map-components/src/map/glmap/Map.js","/Users/joseangel/Workspace/map-components/src/map/glmap/Map.container.js","/Users/joseangel/Workspace/map-components/src/map/glmap/style.reducer.js","/Users/joseangel/Workspace/map-components/src/map/utils/getMainGeomType.js","/Users/joseangel/Workspace/map-components/src/map/glmap/style.actions.js","/Users/joseangel/Workspace/map-components/src/map/glmap/viewport.reducer.js","/Users/joseangel/Workspace/map-components/src/map/store/index.js","/Users/joseangel/Workspace/map-components/src/map/utils/getTrackBounds.js","/Users/joseangel/Workspace/map-components/src/map/tracks/tracks.actions.js","/Users/joseangel/Workspace/map-components/src/map/utils/withReducerTypes.js","/Users/joseangel/Workspace/map-components/src/map/module/module.reducer.js","/Users/joseangel/Workspace/map-components/src/map/tracks/tracks.reducer.js","/Users/joseangel/Workspace/map-components/src/map/heatmap/heatmap.reducer.js","/Users/joseangel/Workspace/map-components/src/map/heatmap/heatmapTiles.reducer.js","/Users/joseangel/Workspace/map-components/src/map/glmap/interaction.reducer.js","/Users/joseangel/Workspace/map-components/src/map/store/reducers.js","/Users/joseangel/Workspace/map-components/src/map/map.js","/Users/joseangel/Workspace/map-components/src/map/basemaps/index.js","/Users/joseangel/Workspace/map-components/src/map/map.mdx"],"names":["module","exports","byname","Uint8","size","Uint8Array","BYTES_PER_ELEMENT","array","getter","setter","Int8","Int8Array","Uint16","Uint16Array","Int16","Int16Array","Uint32","Uint32Array","Int32","Int32Array","Float32","Float32Array","Float64","Float64Array","writeStringToArrayBuffer","str","start","end","buf","bufstart","undefined","length","i","charCodeAt","arrayBufferToString","String","fromCharCode","apply","Pack","typemap","byarray","pack","typespec","value","littleendian","ArrayBuffer","DataView","stringToArrayBuffer","res","Uint8ClampedArray","buffer","name","spec","PelagosClient","this","MAGIC_COOKIE","url","token","Promise","resolve","reject","request","XMLHttpRequest","open","setRequestHeader","responseType","onload","handleData","bind","onerror","send","self","error","readyState","success","status","isFileUri","response","byteLength","dataView","headerLen","cookie","slice","getInt32","offset","headerIsLoaded","header","JSON","parse","rowLen","colsByName","colidx","cols","col","idx","type","multiplier","min","max","orientation","errorLoading","toString","allLoaded","result","rowidx","row","val","colValues","eval","trackTypes","id","PropTypes","string","isRequired","data","object","color","oneOf","layerTemporalExtents","arrayOf","number","fitBoundsOnLoad","bool","heatmapLayerTypes","tilesetId","subtype","visible","hue","opacity","filters","shape","filterValues","endpoints","temporalExtents","temporalExtentsLess","interactive","basemapLayerTypes","staticLayerTypes","selected","selectedFeatures","field","values","highlighted","higlightedFeatures","showLabels","isCustom","gl","popupTypes","content","node","latitude","longitude","viewportTypes","zoom","center","STATIC_LAYERS_CARTO_ENDPOINT","STATIC_LAYERS_CARTO_TILES_ENDPOINT","initModule","props","dispatch","payload","startLoader","state","loaderId","timestamp","Date","getTime","map","onLoadStart","completeLoader","getState","loaders","onLoadComplete","onViewportChange","interactionState","callback","viewport","bounds","canZoomIn","canZoomOut","mouseLatLong","setTemporalExtent","temporalExtent","setHighlightTemporalExtent","highlightTemporalExtent","closePopup","onClosePopup","setCursor","cursor","getTemporalExtent","getHighlightTemporalExtent","getTracksData","tracks","getGeojsonTracksReady","createSelector","filter","t","mergeStyles","style1","style2","sources","layers","filterGeojsonByTimerange","geojson","features","featuresFiltered","reduce","filteredFeatures","feature","properties","coordinateProperties","times","filtered","geometry","coordinates","filteredCoordinates","coordinate","index","timeCoordinate","push","filteredFeature","getFullTracksStyles","hasTemporalExtent","hasTracks","timerange","acc","track","source","style","paint","getHighlightedTrackStyles","getTracksStyles","trackStyles","highlightedTrackStyles","TRANSITION_TYPE","ZOOM","BRUSH_RENDERING_STYLE","NORMAL","BULLSEYE","BRUSH_ZOOM_RENDERING_STYLE","RADIAL_GRADIENT","CIRCLE","CUSTOM_LAYERS_SUBTYPES","raster","urlTemplate","urlParams","templateSettings","interpolate","template","urlTemplateCompiled","getTemporalTileURLs","params","urls","forEach","extent","startTimeISO","toISOString","endTimeISO","tileCoordinates","x","y","z","buildEndpoint","temporalExtentsIndices","indexOf","getTilePromises","tilesetUrl","promises","urlIndex","obtainTile","getCleanVectorArrays","rawTileData","vectorArray","groupData","cleanVectorArrays","columns","currentArray","totalVectorArraysLength","sumBy","a","filteredColumns","column","console","warn","key","cumulatedOffsets","appendValues","set","getTilePlaybackData","prevPlaybackData","tilePlaybackData","zoomFactorRadius","convert","getZoomFactorRadius","zoomFactorRadiusRenderingMode","getZoomFactorRadiusRenderingMode","zoomFactorOpacity","getZoomFactorOpacity","columnsArr","Object","keys","c","storedColumns","concat","sigma","weight","hidden","pull","uniq","numPoints","newFrames","timeIndexes","point","timeIndex","getOffsetedTimeAtPrecision","datetime","lngLatToWorld","worldX","worldY","radius","sigmaToRadius","weightToOpacity","series","frame","vesselSatisfiesFilters","every","selectVesselsAt","tileData","tileQuery","startIndex","endIndex","currentFilters","vessels","toleranceRadiusInWorldUnits","f","wx","wy","pass","some","vesselSatisfiesAllFilters","vessel","getTilecoverLimits","viewportZoom","Math","ceil","tilesAvailable","min_zoom","max_zoom","flushToReleaseTiles","heatmapTiles","currentToLoadTileUids","currentTilesToReleaseUids","currentToReleaseTileUids","releaseTiles","markTileAsLoaded","tileUids","flushTileState","forceLoadingAllVisibleTiles","currentVisibleTiles","tilesToLoad","tilesToReleaseUids","currentLoadedTiles","visibleTile","find","uid","loadedTile","tilesToLoadUids","tile","getTile","updateLoadedTiles","debouncedFlushState","debounce","updateHeatmapTilesFromViewport","mapViewport","width","height","currentTransition","boundsViewport","PerspectiveMercatorViewport","unproject","wn","es","w","s","e","n","boundsPolygonsCoordinates","limits","w1","e2","geom","viewportTilesCoords","tilecover","tiles","viewportTilesIndexes","indexes","visibleTiles","coords","prevZoom","queryHeatmapVessels","temporalExtentIndexes","uids","highlightVesselFromHeatmap","getTemporalExtentsVisibleIndices","loadTemporalExtent","currentExtentStart","currentExtentEnd","indices","temporalExtentStart","loadLayerTile","layerId","Error","pelagosPromises","allLayerPromises","all","then","loadedLayerId","parseLayerTile","getTiles","layerIds","referenceTiles","newTemporalExtentsToLoad","loaderID","join","heatmapLayers","heatmap","tilesByLayer","allPromises","heatmapLayerHeader","referenceTile","temporalExtentsIndicesLoaded","queriedTemporalExtentsIndices","visibleTemporalExtentsIndices","temporalExtentsIndicesToLoad","difference","tilePromise","visibleHeatmapLayers","visibleHeatmapLayersIds","loadAllTilesForLayer","addHeatmapLayer","layer","removeHeatmapLayer","updateLayerLoadTemporalExtents","indicesToAddByLayer","heatmapLayer","oldVisibleTemporalExtentsIndices","newVisibleTemporalExtentsIndices","indicesAdded","indicesRemoved","layerIdsWithIndicesToAdd","clearHighlightedVessels","isEmpty","clickableCluster","layersVessels","availableTiles","bestTile","isCluster","isMouseCluster","layerVesselsResult","foundVessels","layersVesselsResults","layerVessels","v","uniqBy","_queryHeatmap","highlightedVessels","highlightableCluster","highlightClickedVessel","clearHighlightedClickedVessel","updateHeatmapLayers","newLayers","currentLoadTemporalExtent","prevLayersDict","newLayer","prevLayer","prevLayerId","l","setBounds","setViewport","updateViewport","viewportUpdate","transitionTo","increment","transitionToZoom","transitionEnd","zoomIntoVesselCenter","fitToBounds","vp","fitBounds","minLng","minLat","maxLng","maxLat","padding","exportNativeViewport","nativeViewport","topLeftPx","bottomRightPx","topLeftWorld","pixelsToWorld","pixelUnprojectionMatrix","bottomRightWorld","leftWorldScaled","scale","rightWorldScaled","northWest","southEast","north","south","west","east","getAreaKm2","glFeature","area","toLocaleString","maximumFractionDigits","getFeature","fields","fieldsDefinition","metadata","fieldsKeys","k","fd","fieldKey","def","label","title","isLink","isMain","mainField","getFields","mapInteraction","interactionType","glFeatures","glGetSource","legacyHeatmapFeature","currentStyle","mapStyle","toJS","event","currentLegacyHeatmapData","count","group","clusterPromises","getStaticLayerIdFromGlFeature","cluster","clusterPromise","clusterId","cluster_id","glSource","getClusterExpansionZoom","err1","getClusterLeaves","err2","children","childrenFeatures","child","getCluster","autoClusterZoom","clusterBehavior","clusterZoom","onClick","onHover","COLOR_HUES","orange","peach","yellow","green","brightGreen","lightBlue","blue","purple","pink","getKeyByValue","obj","entries","entry","rgbToHsv","_r","_g","_b","h","r","g","b","d","hsvToRgb","h_","s_","v_","parseFloat","floor","p","q","mod","round","hueToRgbDefaults","hueToRgbString","rgb","rgbToHexString","css","channelName","channelValue","channelStr","hueToRgbHexString","hueToClosestColor","goal","colorHueValues","closestHue","prev","curr","abs","hexToRgb","hex","exec","parseInt","rgbToRgbaString","hueToRgbaString","hexToRgba","hueIncrementToHue","hueIncrement","hueToHueIncrement","wrapHue","hueOrColorToHexColor","HeatmapSubLayer","baseTexture","renderingStyleIndex","useNormalBlendMode","stage","PIXI","particles","ParticleContainer","alpha","position","uvs","blendMode","BLEND_MODES","SCREEN","spritesPool","initialTextureFrame","Rectangle","VESSELS_BASE_RADIUS","mainVesselTexture","Texture","_setTextureFrame","clearSpriteProps","spritesProps","spritesPropsCount","destroy","textureFrame","clone","VESSELS_HUES_INCREMENTS_NUM","update","numProps","resizeSpritesPool","sprite","setTransform","numSprites","delta","toRemove","removeChildAt","toAdd","_addSprites","num","Sprite","anchor","addChild","worldToPixelsSimple","m","HeatmapLayer","_build","_destroy","_redraw","nextProps","useRadialGradientStyle","setBrushZoomRenderingStyle","rootStage","customRenderingStyle","subLayers","renderingStyle","rendering","setBrushRenderingStyle","brushRenderingStyle","toUpperCase","_setBrushRenderingStyleIndex","brushZoomRenderingStyle","cappedZoomRenderingStyle","newStyleIndex","subLayer","setRenderingStyleIndex","defaultHue","allHuesToRender","currentlyUsedHues","allHues","_createSublayer","_destroySubLayer","_setSubLayersSpritePropsForTile","numFilters","hueToRender","render","viewportLeft","viewportRight","len","fi","scaledX","scaledY","mtx","pixelProjectionMatrix","pitch","worldToPixels","pushSpriteProps","defaultOpacity","defaultSize","removeChild","React","Component","ActivityLayers","pixiReady","onTouchStart","touches","queryCoords","clientX","clientY","onMouseMove","_onTick","heatmapFadingIn","heatmapStage","_heatmapFadeinStep","setState","_context","_updateViewportSize","pixi","transparent","antialias","renderer","canvas","view","container","appendChild","baseTextureCanvas","blurFactor","tplCanvas","document","createElement","tplCtx","getContext","diameter","yCenter","gradient","createRadialGradient","rgbString","addColorStop","rgbOuter","fillStyle","fillRect","beginPath","arc","PI","fill","lineWidth","strokeStyle","stroke","getVesselTexture","fromCanvas","ticker","add","viewportWidth","viewportHeight","resize","dim","wrappedLongitude","heatmapFadeinStartTimestamp","now","timeElapsed","highlightedClickedVessel","highlightLayerData","highlightFilters","sourceLayer","shouldUseRadialGradientStyle","toggleHeatmapDimming","_startHeatmapFadein","getError","err","log","_getHighlightData","ref","BaseControl","propTypes","func","contextTypes","getHeatmapLayersAsArray","getTemporalExtentIndexes","startTimestamp","endTimestamp","connect","ownProps","PopupWrapper","closeButton","onClose","offsetTop","tipSize","closeOnClick","defaultProps","Map","onLoad","getBounds","glMap","_ne","_sw","lat","lng","loadObserver","async","window","ResizeObserver","default","_containerResizeObserver","handleResizeObserver","observe","_mapContainerRef","contentRect","propsViewport","bearing","onMapInteraction","lngLat","getRef","getMap","getSource","getCursor","isDragging","transformRequest","resourceType","match","headers","Authorization","mouseOver","disconnect","maxZoom","minZoom","clickPopup","hoverPopup","hasHeatmapLayers","markers","interactiveLayerIds","className","styles","onMouseLeave","onMouseEnter","onTransitionEnd","clickRadius","marker","googleLogo","getInteractiveLayerIds","staticLayers","glLayer","glLayerId","getMapStyle","mapStyles","trackLayersIndex","lastIndexOf","finalMapStyles","mergeIn","mapStylesLayers","get","trackLayer","insert","fromJS","interaction","internalCursor","moduleCursor","long","attributions","GL_STYLE","sourceKey","attribution","setLayerStyleDefaults","layout","temporalField","visibility","initialState","cartoLayersInstanciated","basemapLayers","TYPES","geoJSON","INIT_MAP_STYLE","SET_MAP_STYLE","MARK_CARTO_LAYERS_AS_INSTANCIATED","SET_STATIC_LAYERS","SET_BASEMAP_LAYERS","setDefaultVectorTiles","currentSource","refLayerUrl","refLayerUrls","newTiles","initStyle","glyphsPath","setMapStyle","setStyleTemporalExtent","applyToThrottled","glLayers","currentFilter","getIn","isLegacy","setIn","applyTemporalExtentThrottled","throttle","applyTemporalExtent","updateGLLayer","refLayer","currentStyleLayers","newStyle","glLayerIndex","findIndex","toggleLayerVisibility","isBasemap","refLayerOpacity","labelsVisibility","colorPaintProperty","currentGlLayer","glType","defaultStyles","styleType","refLayerStyle","hasFeatures","applyStyleToAllFeatures","defaultStyle","layerStyle","allPaintProperties","glPaintProperty","glPaintFinalValue","selectedValue","fallbackValue","paintOrLayout","includes","originalLayerStyle","layerColorRgbString","layerColorRgb","replace","applyLayerExpressions","addCustomGLLayer","tileSize","allGeoJSONTypes","numByGLType","geoJSONType","glTypeMax","getMainGeomType","layerIndex","reverse","splice","instanciateCartoLayers","sourceId","cartoLayersPromises","sourceCartoSQL","mapConfig","options","sql","mapConfigURL","encodeURIComponent","stringify","cartoAnonymousMapUrl","fetch","json","layergroupid","catch","instanciatedCartoLayers","cartoLayer","tilesURL","newSourceId","deleteIn","commitStyleUpdates","bl","currentGLSources","workspaceGLLayers","workspaceGLLayer","finalSource","existingLayerIds","layerToAdd","layerToAddId","defaultGlLayer","existingLayers","newLayerGroup","newLayerIndex","findLastIndex","updateWorkspaceGLLayers","customLayers","glSources","cartoLayersToInstanciate","newSource","cartoLayerInstanciated","DEFAULT_TRANSITION","transitionDuration","transitionInterpolator","FlyToInterpolator","transitionEasing","easeCubic","composeEnhancers","compose","process","MAP_REDUX_REMOTE_DEBUG","REACT_APP_MAP_REDUX_REMOTE_DEBUG","store","createStore","applyMiddleware","thunk","targetMapVessel","fitToBoundsAction","geoBounds","timelineBounds","setTimeout","TRANSITION_DURATION","getTrackTimeBounds","time","Infinity","getTrackBounds","tbbox","loadTrack","trackHasData","trackHasUrl","cleanData","vectorArrays","currentLng","createFeature","segId","geomType","currentSeries","currentFeature","fishingPoints","lngOffset","ll","cloneDeep","convertLegacyTrackToGeoJSON","statusText","finally","removeTrack","trackId","updateTracks","newTracks","prevTracks","newTrack","prevTrack","withReducerPropTypes","propTypesSchema","reducer","onAttributionsChange","withReducerTypes","instanceOf","action","loaderIndex","exact","trackData","removedTrackId","mapReducer","combineReducers","ModuleReducer","TracksReducer","assign","newTile","layerTiles","tileIndex","tileUid","releasedTileIndex","releasedRefTileIndex","newHeatmapLayers","newToLoadTilesUids","tileUidsMarkedAsLoaded","newCurrentToLoadTileUids","newMapStyle","currentZoom","mapReducers","replaceReducer","throttleApplyTemporalExtent","updateViewportFromIncomingProps","incomingViewport","MapModule","initialized","errorInfo","prevProps","currentViewport","componentStack","AVAILABLE_BASEMAPS","layoutProps","MDXContent","components","mdxType","parentName","__position","__code","__scope","Playground","PropsTable","__codesandbox","isMDXComponent"],"mappings":"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","file":"static/js/src-map-map.141a9ce0.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"map\":\"map_map__1TLha\",\"googleLogo\":\"map_googleLogo__3lQ1y\"};","/* eslint-disable */\nvar byname = {\n  Uint8: {\n    size: Uint8Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint8',\n    setter: 'setUint8',\n  },\n  Int8: {\n    size: Int8Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint8',\n    setter: 'setUint8',\n  },\n  Uint16: {\n    size: Uint16Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint16',\n    setter: 'setUint16',\n  },\n  Int16: {\n    size: Int16Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getInt16',\n    setter: 'setInt16',\n  },\n  Uint32: {\n    size: Uint32Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint32',\n    setter: 'setUint32',\n  },\n  Int32: {\n    size: Int32Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getInt32',\n    setter: 'setInt32',\n  },\n  Float32: {\n    size: Float32Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getFloat32',\n    setter: 'setFloat32',\n  },\n  Float64: {\n    size: Float64Array.BYTES_PER_ELEMENT,\n    array: 'Float64Array',\n    getter: 'getFloat64',\n    setter: 'setFloat64',\n  },\n}\n\nvar writeStringToArrayBuffer = function(str, start, end, buf, bufstart) {\n  if (end == undefined) {\n    end = str.length\n  }\n  if (start == undefined) {\n    start = 0\n  }\n  if (bufstart == undefined) {\n    bufstart = start\n  }\n  for (var i = start; i < end; i++) {\n    buf[i - start + bufstart] = str.charCodeAt(i) & 0xff\n  }\n}\n\nvar stringToArrayBuffer = function(str, start, end) {\n  var self = this\n\n  if (end == undefined) {\n    end = str.length\n  }\n  if (start == undefined) {\n    start = 0\n  }\n  var res = new Uint8ClampedArray(end - start)\n  writeStringToArrayBuffer(str, start, end, res, 0)\n  return res.buffer\n}\n\nvar arrayBufferToString = function(buf) {\n  return String.fromCharCode.apply(null, new Uint8Array(buf))\n}\n\nvar pack = function(typespec, value, littleendian) {\n  var array = new ArrayBuffer(typespec.size)\n  new DataView(array)[typespec.setter](0, value, littleendian)\n  return arrayBufferToString(array)\n}\n\nvar Pack = {\n  typemap: {\n    byname: byname,\n    byarray: {},\n  },\n  pack: pack,\n  arrayBufferToString: arrayBufferToString,\n  stringToArrayBuffer: stringToArrayBuffer,\n  writeStringToArrayBuffer: writeStringToArrayBuffer,\n}\nfor (var name in Pack.typemap.byname) {\n  var spec = Pack.typemap.byname[name]\n  spec.name = name\n  Pack.typemap.byarray[spec.array] = spec\n}\n\nexport default Pack\n","/* eslint-disable */\n\nimport Pack from './Pack'\n\nclass PelagosClient {\n  constructor() {\n    this.MAGIC_COOKIE = 'tmtx'\n  }\n\n  obtainTile(url, token) {\n    return new Promise(\n      function(resolve, reject) {\n        this.request = null\n        if (typeof XMLHttpRequest != 'undefined') {\n          this.request = new XMLHttpRequest()\n        } else {\n          throw 'XMLHttpRequest is disabled'\n        }\n        this.resolve = resolve\n        this.reject = reject\n        this.request.open('GET', url, true)\n        if (token) {\n          this.request.setRequestHeader('Authorization', `Bearer ${token}`)\n        }\n        this.request.responseType = 'arraybuffer'\n        this.request.onload = this.handleData.bind(this)\n        this.request.onerror = this.handleData.bind(this)\n        this.request.send(null)\n      }.bind(this)\n    )\n  }\n\n  handleData() {\n    var self = this\n    if (!this.request) {\n      return\n    }\n    if (this.error) {\n      return true\n    }\n\n    if (this.request.readyState == 4) {\n      /* HTTP reports success with a 200 status. The file protocol\n       reports success with zero. HTTP returns zero as a status\n       code for forbidden cross domain requests.\n       https://developer.mozilla.org/En/Using_XMLHttpRequest */\n      var success = this.request.status == 200 || (this.isFileUri && this.request.status == 0)\n      if (!success) {\n        this.resolve(null)\n        return\n      }\n    }\n\n    if (!this.request.response) {\n      return\n    }\n    var length = this.request.response.byteLength\n    var response = this.request.response\n    var dataView = new DataView(response)\n\n    if (length < 4 + 4) {\n      return\n    }\n    if (self.headerLen == null) {\n      var cookie = Pack.arrayBufferToString(response.slice(0, 4))\n      if (cookie != this.MAGIC_COOKIE) {\n        this.reject(\n          'Could not load ' +\n            this.url +\n            ' due to incorrect file format. Cookie: [' +\n            this.cookie +\n            ']'\n        )\n        return\n      }\n\n      self.headerLen = dataView.getInt32(4, true)\n\n      self.offset = 4 + 4\n    }\n    if (length < self.offset + self.headerLen) {\n      return\n    }\n    if (!self.headerIsLoaded) {\n      self.header = JSON.parse(\n        Pack.arrayBufferToString(response.slice(self.offset, self.offset + self.headerLen))\n      )\n      self.rowLen = 0\n      self.header.colsByName = {}\n      for (var colidx = 0; colidx < self.header.cols.length; colidx++) {\n        var col = self.header.cols[colidx]\n        col.idx = colidx\n        self.header.colsByName[col.name] = col\n        col.typespec = Pack.typemap.byname[col.type]\n\n        if (col.multiplier != undefined && col.min != undefined) {\n          col.min = col.min * col.multiplier\n        }\n        if (col.offset != undefined && col.min != undefined) {\n          col.min = col.min + col.offset\n        }\n        if (col.multiplier != undefined && col.max != undefined) {\n          col.max = col.max * col.multiplier\n        }\n        if (col.offset != undefined && col.max != undefined) {\n          col.max = col.max + col.offset\n        }\n\n        self.rowLen += col.typespec.size\n      }\n      self.offset += self.headerLen\n\n      // Add the padding to nearest 4-byte-boundary\n      self.offset += (4 - (self.headerLen % 4)) % 4\n\n      self.headerIsLoaded = true\n      if (self.header.orientation != 'rowwise' && self.header.orientation != 'columnwise') {\n        self.errorLoading({\n          orientation: self.header.orientation,\n          toString: function() {\n            return (\n              'Could not load ' +\n              this.url +\n              ' due to unsupported file orientation. Orientation: ' +\n              this.orientation +\n              '. Supported orientations: rowwise, columnwise.'\n            )\n          },\n        })\n        return true\n      }\n\n      // Empty tile, stop parsing.\n      if (!self.rowLen) {\n        self.allLoaded()\n        return true\n      }\n    }\n    if (self.header.orientation == 'rowwise') {\n      var result = {}\n      for (; self.offset + self.rowLen <= length; self.rowidx++) {\n        var row = {}\n        for (var colidx = 0; colidx < self.header.cols.length; colidx++) {\n          var col = self.header.cols[colidx]\n          var val = dataView[col.typespec.getter](self.offset, true)\n          row[col.name] = val\n          self.offset += col.typespec.size\n        }\n        // self.rowLoaded(row);\n\n        result[col.name] = row\n      }\n      if (self.rowidx == self.header.length) {\n        // self.allLoaded();\n        this.resolve(result)\n      } else {\n        // self.batchLoaded();\n      }\n    } else if (self.header.orientation == 'columnwise') {\n      var colValues = null\n      var result = {}\n      if (length >= self.offset + self.header.length * self.rowLen) {\n        for (var colidx = 0; colidx < self.header.cols.length; colidx++) {\n          var col = self.header.cols[colidx]\n\n          colValues = new (eval(col.typespec.array))(\n            response.slice(self.offset, self.offset + col.typespec.size * self.header.length)\n          )\n          self.offset += self.header.length * col.typespec.size\n\n          result[col.name] = colValues\n        }\n\n        // self.allLoaded();\n        this.resolve(result)\n        return true\n      }\n    }\n  }\n}\n\nexport default PelagosClient\n","import PropTypes from 'prop-types'\n\nexport const trackTypes = {\n  id: PropTypes.string.isRequired,\n  url: PropTypes.string,\n  data: PropTypes.object,\n  color: PropTypes.string,\n  type: PropTypes.oneOf(['geojson', 'pelagos', undefined]),\n  layerTemporalExtents: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.number)),\n  fitBoundsOnLoad: PropTypes.bool,\n}\n","import PropTypes from 'prop-types'\n\nexport const heatmapLayerTypes = {\n  id: PropTypes.string.isRequired,\n  tilesetId: PropTypes.string,\n  subtype: PropTypes.string,\n  visible: PropTypes.bool,\n  hue: PropTypes.number,\n  opacity: PropTypes.number,\n  filters: PropTypes.arrayOf(\n    PropTypes.shape({\n      // hue overrides layer hue if set\n      hue: PropTypes.number,\n      // filterValues is a dictionary in which each key is a filterable field,\n      // and values is an array of all possible values (OR filter)\n      // ie: filterValues: { category: [5, 6] }\n      filterValues: PropTypes.object,\n    })\n  ),\n  header: PropTypes.shape({\n    endpoints: PropTypes.object,\n    colsByName: PropTypes.object,\n    temporalExtents: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.number)),\n    temporalExtentsLess: PropTypes.bool,\n  }).isRequired,\n  interactive: PropTypes.bool,\n}\n\nexport const basemapLayerTypes = {\n  id: PropTypes.string,\n  visible: PropTypes.bool,\n}\n\nexport const staticLayerTypes = {\n  id: PropTypes.string.isRequired,\n  // TODO MAP MODULE Is that needed and if so why\n  visible: PropTypes.bool,\n  selected: PropTypes.bool,\n  selectedFeatures: PropTypes.shape({\n    field: PropTypes.string,\n    values: PropTypes.arrayOf(PropTypes.string),\n  }),\n  highlighted: PropTypes.bool,\n  higlightedFeatures: PropTypes.shape({\n    field: PropTypes.string,\n    values: PropTypes.arrayOf(PropTypes.string),\n  }),\n  opacity: PropTypes.number,\n  color: PropTypes.string,\n  showLabels: PropTypes.bool,\n  interactive: PropTypes.bool,\n  filters: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.string)),\n  isCustom: PropTypes.bool,\n  subtype: PropTypes.oneOf([undefined, 'geojson', 'raster']),\n  url: PropTypes.string,\n  data: PropTypes.object,\n  gl: PropTypes.object,\n}\n","import PropTypes from 'prop-types'\n\nexport const popupTypes = {\n  content: PropTypes.node,\n  latitude: PropTypes.number.isRequired,\n  longitude: PropTypes.number.isRequired,\n}\n\nexport const viewportTypes = {\n  zoom: PropTypes.number,\n  center: PropTypes.arrayOf(PropTypes.number),\n}\n","// Application settings\nexport const TIMELINE_STEP = 24 * 60 * 60 * 1000 // 1 day\nexport const MIN_FRAME_LENGTH_MS = TIMELINE_STEP // 1 day\n\n// vessels rendering\n// from this zoom level and above, render using circle style instead of heatmap\nexport const VESSELS_RADIAL_GRADIENT_STYLE_ZOOM_THRESHOLD = 6\n// the base radius, it can only be scaled down by the radius factor calculated on the dataset\nexport const VESSELS_BASE_RADIUS = 8\n// in heatmap style, defines how 'blurry' a point will look. Higher = less blur\nexport const VESSELS_HEATMAP_BLUR_FACTOR = 0.15\n\nexport const ACTIVITY_HIGHLIGHT_HUE = 312\n\nexport const VESSELS_HEATMAP_DIMMING_ALPHA = 0.5\n\nexport const MAX_SPRITES_PER_LAYER = 200000\n\n// interaction\n// radius of vessels lookup in pixels,\n// ie how large the clicked region should be for including vessels\nexport const VESSEL_CLICK_TOLERANCE_PX = 10\n\nexport const CLUSTER_CLICK_ZOOM_INCREMENT = 1\n\nexport const MIN_ZOOM_LEVEL = 1\n// user can zoom up to this z level, but it doesn't guarantee availability of tiles\nexport const MAX_ZOOM_LEVEL = 14\n\n// data\n// Limit tile loading for activity layers up to this z level.\n// Beyond, layer is still displayed but with coarse data from the lower zoom level\nexport const ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING = 10\n\n// Sets what should be the discrete zoom level to load tiles, from a non-discrete\n// viewport zoom values. For instance, a values of 0.5 will load z 3 with a viewport\n// z of 2 (ceiling of 2 + 0.5)\n// this has a direct impact on the number of points displayed on the map, thus on the\n// performance of the app.\nexport const TILES_LOAD_ZOOM_OFFSET = 0.5\n\nexport const STATIC_LAYERS_CARTO_ENDPOINT =\n  'https://carto.globalfishingwatch.org/user/admin/api/v1/map?config=$MAPCONFIG'\nexport const STATIC_LAYERS_CARTO_TILES_ENDPOINT =\n  'https://carto.globalfishingwatch.org/user/admin/api/v1/map/$LAYERGROUPID/{z}/{x}/{y}.mvt'\n\nexport const TRACKS_LAYER_IN_FRONT_OF_GROUP = 'temporal'\n\nexport const TILES_URL_NEEDING_AUTHENTICATION = 'dot-world-fishing'\n","export const INIT_MODULE = 'INIT_MODULE'\nexport const SET_TEMPORAL_EXTENT = 'SET_TEMPORAL_EXTENT'\nexport const SET_HIGHLIGHT_TEMPORAL_EXTENT = 'SET_HIGHLIGHT_TEMPORAL_EXTENT'\nexport const START_LOADER = 'START_LOADER'\nexport const COMPLETE_LOADER = 'COMPLETE_LOADER'\nexport const SET_MODULE_CURSOR = 'SET_MODULE_CURSOR'\n\nexport const initModule = (props) => (dispatch) => {\n  dispatch({\n    type: INIT_MODULE,\n    payload: props,\n  })\n}\n\nexport const startLoader = (dispatch, state, loaderId) => {\n  const timestamp = new Date().getTime()\n  const generatedLoaderId = loaderId !== undefined ? `${loaderId}_${timestamp}` : timestamp\n  dispatch({\n    type: START_LOADER,\n    payload: generatedLoaderId,\n  })\n  if (state.map.module.onLoadStart !== undefined) {\n    state.map.module.onLoadStart()\n  }\n  return loaderId\n}\n\nexport const completeLoader = (loaderId) => (dispatch, getState) => {\n  dispatch({\n    type: COMPLETE_LOADER,\n    payload: loaderId,\n  })\n  const state = getState()\n  const loaders = state.map.module.loaders\n  if (!loaders.length && state.map.module.onLoadComplete !== undefined) {\n    state.map.module.onLoadComplete()\n  }\n}\n\nexport const onViewportChange = (interactionState) => (dispatch, getState) => {\n  const state = getState()\n  const callback = state.map.module.onViewportChange\n\n  if (callback === undefined) {\n    return\n  }\n  const viewport = state.map.viewport\n\n  callback({\n    interactionState,\n    zoom: viewport.viewport.zoom,\n    center: [viewport.viewport.latitude, viewport.viewport.longitude],\n    bounds: viewport.bounds,\n    canZoomIn: viewport.canZoomIn,\n    canZoomOut: viewport.canZoomOut,\n    mouseLatLong: viewport.mouseLatLong,\n  })\n}\n\nexport const setTemporalExtent = (temporalExtent) => ({\n  type: SET_TEMPORAL_EXTENT,\n  payload: temporalExtent,\n})\n\nexport const setHighlightTemporalExtent = (highlightTemporalExtent) => ({\n  type: SET_HIGHLIGHT_TEMPORAL_EXTENT,\n  payload: highlightTemporalExtent,\n})\n\nexport const closePopup = () => (dispatch, getState) => {\n  const state = getState()\n  if (state.map.module.onClosePopup !== undefined) {\n    state.map.module.onClosePopup()\n  }\n}\n\nexport const setCursor = (cursor) => ({\n  type: SET_MODULE_CURSOR,\n  payload: cursor,\n})\n","export const getTemporalExtent = (state) => state.map.module.temporalExtent\n\nexport const getHighlightTemporalExtent = (state) => state.map.module.highlightTemporalExtent\n","import { createSelector } from 'reselect'\nimport { getTemporalExtent, getHighlightTemporalExtent } from '../module/module.selectors'\n\nexport const getTracksData = (state) => state.map.tracks.data\n\nexport const getGeojsonTracksReady = createSelector(\n  getTracksData,\n  (tracks) => tracks.filter((t) => t.data !== undefined)\n)\n\nconst mergeStyles = (style1, style2) => ({\n  sources: { ...style1.sources, ...style2.sources },\n  layers: [...style1.layers, ...style2.layers],\n})\n\nconst filterGeojsonByTimerange = (geojson, { start, end }) => {\n  if (!geojson || !geojson.features) return null\n  const featuresFiltered = geojson.features.reduce((filteredFeatures, feature) => {\n    const hasTimes =\n      feature.properties &&\n      feature.properties.coordinateProperties &&\n      feature.properties.coordinateProperties.times &&\n      feature.properties.coordinateProperties.times.length > 0\n    if (hasTimes) {\n      const filtered = feature.geometry.coordinates.reduce(\n        (filteredCoordinates, coordinate, index) => {\n          const timeCoordinate = feature.properties.coordinateProperties.times[index]\n          const isInTimeline = timeCoordinate >= start && timeCoordinate <= end\n          if (isInTimeline) {\n            filteredCoordinates.coordinates.push(coordinate)\n            filteredCoordinates.times.push(timeCoordinate)\n          }\n          return filteredCoordinates\n        },\n        { coordinates: [], times: [] }\n      )\n      if (!filtered.coordinates.length) return filteredFeatures\n\n      const filteredFeature = {\n        ...feature,\n        geometry: {\n          ...feature.geometry,\n          coordinates: filtered.coordinates,\n        },\n        properties: {\n          ...feature.properties,\n          coordinateProperties: {\n            times: filtered.times,\n          },\n        },\n      }\n      filteredFeatures.push(filteredFeature)\n    }\n    return filteredFeatures\n  }, [])\n  const geojsonFiltered = {\n    ...geojson,\n    features: featuresFiltered,\n  }\n  return geojsonFiltered\n}\n\nconst getFullTracksStyles = createSelector(\n  [getTemporalExtent, getGeojsonTracksReady],\n  (temporalExtent, tracks) => {\n    const hasTemporalExtent = temporalExtent && temporalExtent.length > 0\n    const hasTracks = tracks && tracks.length > 0\n    if (!hasTemporalExtent || !hasTracks) return null\n\n    const timerange = {\n      start: temporalExtent[0].getTime(),\n      end: temporalExtent[1].getTime(),\n    }\n    const styles = tracks.reduce(\n      (acc, track) => {\n        if (!track.data) return acc\n\n        const source = `${track.id}Track`\n        const style = {\n          sources: {\n            [source]: {\n              type: 'geojson',\n              data: filterGeojsonByTimerange(track.data, timerange),\n            },\n          },\n          layers: [\n            {\n              id: `${track.id}Lines`,\n              source,\n              type: 'line',\n              paint: {\n                'line-width': 1,\n                'line-color': track.color,\n              },\n            },\n            {\n              id: `${track.id}Points`,\n              source,\n              type: 'circle',\n              filter: ['match', ['geometry-type'], ['', 'Point'], true, false],\n              paint: {\n                'circle-radius': 4,\n                'circle-color': track.color,\n              },\n            },\n          ],\n        }\n        return mergeStyles(acc, style)\n      },\n      { sources: {}, layers: [] }\n    )\n    return styles\n  }\n)\n\nconst getHighlightedTrackStyles = createSelector(\n  [getHighlightTemporalExtent, getGeojsonTracksReady],\n  (highlightTemporalExtent, tracks) => {\n    const hasTemporalExtent = highlightTemporalExtent && highlightTemporalExtent.length > 0\n    const hasTracks = tracks && tracks.length > 0\n    if (!hasTemporalExtent || !hasTracks) return null\n\n    const timerange = {\n      start: highlightTemporalExtent[0].getTime(),\n      end: highlightTemporalExtent[1].getTime(),\n    }\n    const styles = tracks.reduce(\n      (acc, track) => {\n        if (!track.data) return acc\n\n        const source = `${track.id}HighlightedTrack`\n        const style = {\n          sources: {\n            [source]: {\n              type: 'geojson',\n              data: filterGeojsonByTimerange(track.data, timerange),\n            },\n          },\n          layers: [\n            {\n              id: `${track.id}HighlightedLines`,\n              source,\n              type: 'line',\n              paint: {\n                'line-width': 1,\n                'line-color': '#fff',\n              },\n            },\n          ],\n        }\n        return mergeStyles(acc, style)\n      },\n      { sources: {}, layers: [] }\n    )\n    return styles\n  }\n)\n\nexport const getTracksStyles = createSelector(\n  [getFullTracksStyles, getHighlightedTrackStyles],\n  (trackStyles, highlightedTrackStyles) => {\n    if (!highlightedTrackStyles) return trackStyles\n    return mergeStyles(trackStyles, highlightedTrackStyles)\n  }\n)\n","export const GL_TRANSPARENT = 'rgba(0,0,0,0)'\n\nexport const TRANSITION_TYPE = {\n  ZOOM: 'ZOOM',\n}\n\nexport const ENCOUNTERS = 'Encounters'\n\nexport const BRUSH_RENDERING_STYLE = {\n  NORMAL: 0,\n  BULLSEYE: 2,\n}\n\nexport const BRUSH_ZOOM_RENDERING_STYLE = {\n  RADIAL_GRADIENT: 0,\n  CIRCLE: 1,\n}\n\nexport const POLYGON_LAYERS_AREA = 'POLYGON_LAYERS_AREA'\n\nexport const CUSTOM_LAYERS_SUBTYPES = {\n  geojson: 'geojson',\n  raster: 'raster',\n}\n","import template from 'lodash/template'\nimport templateSettings from 'lodash/templateSettings'\n\nexport default (urlTemplate, urlParams) => {\n  templateSettings.interpolate = /{{([\\s\\S]+?)}}/g\n  const urlTemplateCompiled = template(urlTemplate)\n  return urlTemplateCompiled(urlParams)\n}\n","import pull from 'lodash/pull'\nimport uniq from 'lodash/uniq'\nimport sumBy from 'lodash/sumBy'\nimport { lngLatToWorld } from 'viewport-mercator-project'\nimport convert from '@globalfishingwatch/map-convert'\nimport buildEndpoint from './buildEndpoint'\nimport PelagosClient from '../lib/pelagosClient'\n\n/**\n * Generates the URLs to load vessel track data for a tile\n *\n * @param {string} tilesetUrl       the tileset base URL\n * @param {array} temporalExtents   all tileset temporal extents\n * @param {object} params           - tileCoordinates: this tiles tile coordinates (zoom, x, y). Will default to 0,0,0\n *                                  - temporalExtentsIndices: restrict to these temporalExtents indices\n * @returns {Array}                 an array of URLs for this tile\n */\nconst getTemporalTileURLs = (urlTemplate, temporalExtents, params = {}) => {\n  const urls = []\n\n  ;(temporalExtents || [null]).forEach((extent, index) => {\n    const urlParams = {}\n    if (extent !== null && params.temporalExtentsLess !== true) {\n      urlParams.startTimeISO = new Date(extent[0]).toISOString()\n      urlParams.endTimeISO = new Date(extent[1]).toISOString()\n    }\n    if (params.tileCoordinates) {\n      urlParams.x = params.tileCoordinates.x\n      urlParams.y = params.tileCoordinates.y\n      urlParams.z = params.tileCoordinates.zoom\n    }\n\n    const url = buildEndpoint(urlTemplate, urlParams)\n\n    if (\n      params.temporalExtentsLess === true ||\n      !params.temporalExtentsIndices ||\n      params.temporalExtentsIndices.indexOf(index) > -1\n    ) {\n      urls.push(url)\n    }\n  })\n  return urls\n}\n\n/**\n * See getTemporalTileURLs.\n */\nexport const getTilePromises = (tilesetUrl, token, temporalExtents, params = {}) => {\n  const promises = []\n  const urls = getTemporalTileURLs(tilesetUrl, temporalExtents, params)\n  for (let urlIndex = 0, length = urls.length; urlIndex < length; urlIndex++) {\n    promises.push(new PelagosClient().obtainTile(urls[urlIndex], token))\n  }\n\n  return promises\n}\n\nexport const getCleanVectorArrays = (rawTileData) =>\n  rawTileData.filter((vectorArray) => vectorArray !== null)\n\n/**\n * As data will come in multiple arrays (1 per API query/year basically), they need to be merged here\n *\n * @param cleanVectorArrays an array of objects containing a Float32Array for each vessel param (lat, lon, weight...)\n * @param columns the keys to pick on the vectorArrays (lat, lon, weight, etc)\n * @returns an object containing a Float32Array for each API_RETURNED_KEY (lat, lon, weight, etc)\n */\nexport const groupData = (cleanVectorArrays, columns) => {\n  const data = {}\n\n  const totalVectorArraysLength = sumBy(cleanVectorArrays, (a) => a.longitude.length)\n\n  const filteredColumns = columns.filter((column) => {\n    if (cleanVectorArrays[0] && cleanVectorArrays[0][column] === undefined) {\n      console.warn(`column ${column} is present in layerHeader.colsByName but not in tile data`)\n      return false\n    }\n    return true\n  })\n\n  filteredColumns.forEach((key) => {\n    data[key] = new Float32Array(totalVectorArraysLength)\n  })\n\n  let currentArray\n  let cumulatedOffsets = 0\n\n  const appendValues = (key) => {\n    data[key].set(currentArray[key], cumulatedOffsets)\n  }\n\n  for (let index = 0, length = cleanVectorArrays.length; index < length; index++) {\n    currentArray = cleanVectorArrays[index]\n    filteredColumns.forEach(appendValues)\n    cumulatedOffsets += currentArray.longitude.length\n  }\n  return data\n}\n\n/**\n * Converts Vector Array data to Playback format and stores it locally.\n * The data structure is an array indexed by a time unit, ie a set of points every day\n * This preprocessing step allows playback to play smoothly as the necessary conversions and data structure set up\n * is done once (after tile has been loaded)\n *\n * @param data the source data before indexing by day, an object containing\n *  - a vector (Float32Array) for each header's column in the case of Pelagos tiles\n *  - an array of points int the case of PBF tiles\n * @param colsByName the columns present on the dataset, determined by tileset headers\n * @param tileCoordinates x, y, z\n * @param prevPlaybackData an optional previously loaded tilePlaybackData array (when adding time range)\n */\nexport const getTilePlaybackData = (data, colsByName, tileCoordinates, prevPlaybackData) => {\n  const tilePlaybackData = prevPlaybackData === undefined ? [] : prevPlaybackData\n\n  const zoom = tileCoordinates.zoom\n  const zoomFactorRadius = convert.getZoomFactorRadius(zoom)\n  const zoomFactorRadiusRenderingMode = convert.getZoomFactorRadiusRenderingMode(zoom)\n  const zoomFactorOpacity = convert.getZoomFactorOpacity(zoom)\n\n  // store all available columns as object keys\n  const columns = {}\n  const columnsArr = Object.keys(colsByName)\n  columnsArr.forEach((c) => {\n    columns[c] = true\n  })\n\n  // columns specified by layer header columns\n  let storedColumns = [].concat(columnsArr)\n  if (columns.sigma === true) storedColumns.push('radius')\n  if (columns.weight === true) storedColumns.push('opacity')\n  if (columns.longitude === true) {\n    storedColumns.push('worldX')\n    storedColumns.push('worldY')\n  }\n  if (columns.id === true) {\n    storedColumns.push('series')\n  }\n\n  // omit values that will be transformed before being stored to playback data (ie lat -> worldY)\n  // only if hidden: true flag is set on header\n  ;['latitude', 'longitude', 'datetime'].forEach((col) => {\n    if (colsByName[col] === undefined || colsByName[col].hidden === true) {\n      pull(storedColumns, col)\n    }\n  })\n  // always pull sigma and weight\n  pull(storedColumns, 'sigma', 'weight')\n  storedColumns = uniq(storedColumns)\n\n  const numPoints = data.latitude.length\n\n  const newFrames = {}\n  const timeIndexes = []\n  for (let index = 0, length = numPoints; index < length; index++) {\n    let point = {}\n    columnsArr.forEach((c) => {\n      point[c] = data[c][index]\n    })\n\n    const timeIndex = columns.timeIndex\n      ? point.timeIndex\n      : convert.getOffsetedTimeAtPrecision(point.datetime)\n\n    // FIXME: this should not be done when headers declare worldX/Y -  if (!columns.worldX) {\n    const [worldX, worldY] = lngLatToWorld([point.longitude, point.latitude], 1)\n    point.worldX = worldX\n    point.worldY = worldY\n\n    if (columns.sigma) {\n      point.radius = convert.sigmaToRadius(\n        point.sigma,\n        zoomFactorRadiusRenderingMode,\n        zoomFactorRadius\n      )\n    }\n    if (columns.weight) {\n      point.opacity = convert.weightToOpacity(point.weight, zoomFactorOpacity)\n    }\n    if (columns.id) {\n      point.series = point.id\n    }\n\n    if (!newFrames[timeIndex]) {\n      timeIndexes.push(timeIndex)\n      const frame = {}\n      storedColumns.forEach((column) => {\n        frame[column] = [point[column]]\n      })\n      newFrames[timeIndex] = frame\n      continue\n    }\n    const frame = newFrames[timeIndex]\n    storedColumns.forEach((column) => {\n      frame[column].push(point[column])\n    })\n  }\n\n  // finally, copy new frames to the overall tilePlaybackData object\n  // frames previously existing here will be overwritten\n  timeIndexes.forEach((timeIndex) => {\n    tilePlaybackData[timeIndex] = newFrames[timeIndex]\n  })\n  return tilePlaybackData\n}\n\nexport const vesselSatisfiesFilters = (frame, index, filterValues) => {\n  const satisfiesFilters = Object.keys(filterValues).every((field) => {\n    if (frame[field] === undefined) {\n      // this field is not available on this layer. This can happen in an edge case described\n      // here: https://github.com/GlobalFishingWatch/map-client/issues/661#issuecomment-334496469\n      return false\n    }\n    return filterValues[field].indexOf(frame[field][index]) > -1\n  })\n  return satisfiesFilters\n}\n\nconst vesselSatisfiesAllFilters = (frame, index, filters) => {\n  const satisfiesAllFilters = filters\n    .filter((f) => f.pass !== true)\n    .some((filter) => vesselSatisfiesFilters(frame, index, filter.filterValues))\n  return satisfiesAllFilters\n}\n\nexport const selectVesselsAt = (tileData, tileQuery, startIndex, endIndex, currentFilters) => {\n  const vessels = []\n\n  const { worldX, worldY, toleranceRadiusInWorldUnits } = tileQuery\n\n  for (let f = startIndex; f < endIndex; f++) {\n    const frame = tileData[f]\n    if (frame === undefined) continue\n    for (let i = 0; i < frame.worldX.length; i++) {\n      const wx = frame.worldX[i]\n      const wy = frame.worldY[i]\n\n      if (\n        (!currentFilters.length || vesselSatisfiesAllFilters(frame, i, currentFilters)) &&\n        wx >= worldX - toleranceRadiusInWorldUnits &&\n        wx <= worldX + toleranceRadiusInWorldUnits &&\n        wy >= worldY - toleranceRadiusInWorldUnits &&\n        wy <= worldY + toleranceRadiusInWorldUnits\n      ) {\n        const vessel = {}\n\n        Object.keys(frame).forEach((key) => {\n          vessel[key] = frame[key][i]\n        })\n        vessel.timeIndex = f\n        vessels.push(vessel)\n      }\n    }\n  }\n  return vessels\n}\n\n/*\nexport const getHistogram = (tiles, propName = 'weight') => {\n  let data = tiles\n    .filter(tile => tile.ready)\n    .map(tile => tile.data\n      .map(frame => frame[propName]));\n  data = flattenDeep(data);\n  if (data.length) {\n    const bins = d3.histogram().thresholds(d3.thresholdScott)(data);\n    const x = d3.scaleLinear().domain([0, d3.max(bins, d => d.length)]).range([0, 50]);\n    console.table(bins.filter(bin => bin.length).map((bin) => {\n      const binMin = d3.min(bin).toLocaleString({ maximumFractionDigits: 2 });\n      const binMax = d3.max(bin).toLocaleString({ maximumFractionDigits: 2 });\n      return {\n        range: [binMin, binMax].join('﹣'),\n        bars: Array(Math.round(x(bin.length))).join('█'),\n        num: bin.length\n      };\n    }));\n  }\n};\n*/\n","import tilecover from '@mapbox/tile-cover/index'\nimport debounce from 'lodash/debounce'\nimport { PerspectiveMercatorViewport } from 'viewport-mercator-project'\nimport { ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING, TILES_LOAD_ZOOM_OFFSET } from '../config'\nimport {\n  getTile,\n  releaseTiles,\n  highlightVesselFromHeatmap,\n  updateLoadedTiles,\n} from './heatmap.actions'\n\nexport const SET_CURRENTLY_VISIBLE_TILES = 'SET_CURRENTLY_VISIBLE_TILES'\nexport const SET_CURRENTLY_LOADED_TILES = 'SET_CURRENTLY_LOADED_TILES'\nexport const SET_CURRENTLY_SWAPPED_TILE_UIDS = 'SET_CURRENTLY_SWAPPED_TILE_UIDS'\nexport const MARK_TILES_UIDS_AS_LOADED = 'MARK_TILES_UIDS_AS_LOADED'\nexport const RELEASE_MARKED_TILES_UIDS = 'RELEASE_MARKED_TILES_UIDS'\n\n// restrict tilecover to a single zoom level\n// could be customized to load less or more detailed tiles\nconst getTilecoverLimits = (viewportZoom) => {\n  let zoom = Math.ceil(viewportZoom + TILES_LOAD_ZOOM_OFFSET)\n  let tilesAvailable = true\n  if (zoom > ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING) {\n    zoom = ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING\n    tilesAvailable = false\n  }\n  return {\n    min_zoom: zoom,\n    max_zoom: zoom,\n    tilesAvailable,\n  }\n}\n\nconst flushToReleaseTiles = () => (dispatch, getState) => {\n  const state = getState()\n  const currentToLoadTileUids = state.map.heatmapTiles.currentToLoadTileUids\n  // console.log('Tiles left to load: ', currentToLoadTileUids);\n\n  // Tiles are released only when all to-load tiles have finished loading\n  // this is to ensure smooth visual transitions between zoom levels\n  if (!currentToLoadTileUids.length) {\n    const currentTilesToReleaseUids = state.map.heatmapTiles.currentToReleaseTileUids\n    // console.log('no more tiles to load, releasing ', currentTilesToReleaseUids);\n    dispatch(releaseTiles(currentTilesToReleaseUids))\n    dispatch({\n      type: RELEASE_MARKED_TILES_UIDS,\n    })\n  }\n}\n\nexport const markTileAsLoaded = (tileUids) => (dispatch) => {\n  dispatch({\n    type: MARK_TILES_UIDS_AS_LOADED,\n    payload: tileUids,\n  })\n  // console.log(tileUids, 'have finished loading');\n  dispatch(flushToReleaseTiles())\n}\n\nconst flushTileState = (forceLoadingAllVisibleTiles = false) => (dispatch, getState) => {\n  const state = getState()\n  const currentVisibleTiles = state.map.heatmapTiles.currentVisibleTiles\n  let tilesToLoad = []\n  const tilesToReleaseUids = []\n\n  if (forceLoadingAllVisibleTiles === true) {\n    tilesToLoad = currentVisibleTiles\n  } else {\n    const currentLoadedTiles = state.map.heatmapTiles.currentLoadedTiles\n\n    currentVisibleTiles.forEach((visibleTile) => {\n      if (currentLoadedTiles.find((t) => t.uid === visibleTile.uid) === undefined) {\n        tilesToLoad.push(visibleTile)\n      }\n    })\n\n    currentLoadedTiles.forEach((loadedTile) => {\n      if (currentVisibleTiles.find((t) => t.uid === loadedTile.uid) === undefined) {\n        tilesToReleaseUids.push(loadedTile.uid)\n      }\n    })\n  }\n\n  const tilesToLoadUids = tilesToLoad.map((t) => t.uid)\n  // console.log('force loading:', forceLoadingAllVisibleTiles)\n  // console.log('visible', currentVisibleTiles.map(t => t.uid))\n  // console.log('load', tilesToLoadUids)\n  // console.log('release', tilesToReleaseUids)\n  // console.log('----')\n\n  tilesToLoad.forEach((tile) => {\n    dispatch(getTile(tile))\n  })\n  dispatch({\n    type: SET_CURRENTLY_LOADED_TILES,\n    payload: currentVisibleTiles,\n  })\n\n  dispatch({\n    type: SET_CURRENTLY_SWAPPED_TILE_UIDS,\n    payload: {\n      tilesToLoadUids,\n      tilesToReleaseUids,\n    },\n  })\n\n  dispatch(updateLoadedTiles())\n  dispatch(flushToReleaseTiles())\n}\n\nconst _debouncedFlushState = (dispatch) => {\n  dispatch(flushTileState())\n}\nconst debouncedFlushState = debounce(_debouncedFlushState, 500)\n\nexport const updateHeatmapTilesFromViewport = (forceLoadingAllVisibleTiles = false) => (\n  dispatch,\n  getState\n) => {\n  // if in transition, skip loading/releasing\n  // else\n  //   collect all tiles in viewport\n  //   save them to reducer: currentVisibleTiles\n  // if not zooming: flush immediately\n  //   if forceLoadingAllVisiblelTiles\n  //     get tiles from currentVisibleTiles\n  //   else\n  //     get tiles from currentVisibleTiles\n  //     make delta with currentLoadedTiles\n  //     get tiles from delta+\n  //     release tiles from delta-\n  //   save to reducer: currentVisibleTiles -> currentLoadedTiles\n  // if zooming: debounced flush to avoid \"tile spam\"\n  const mapViewport = getState().map.viewport\n  const viewport = mapViewport.viewport\n\n  // do not allow any tile update during transitions (currently only zoom)\n  // wait for the end of the transition to look at viewport and load matching tiles\n  if (!viewport.width || !viewport.height || mapViewport.currentTransition !== null) {\n    return\n  }\n\n  // instanciate a viewport instance to get lat/lon from screen top left/ bottom right bounds\n  const boundsViewport = new PerspectiveMercatorViewport(viewport)\n  const bounds = [\n    boundsViewport.unproject([0, 0]),\n    boundsViewport.unproject([viewport.width, viewport.height]),\n  ]\n\n  const [wn, es] = bounds\n  const [w, s, e, n] = [wn[0], es[1], es[0], wn[1]]\n  const boundsPolygonsCoordinates = []\n\n  const limits = getTilecoverLimits(viewport.zoom)\n  if (limits.tilesAvailable === false && forceLoadingAllVisibleTiles !== true) {\n    return\n  }\n\n  if (e > 180 || w < -180) {\n    // deal with the antimeridian situation by splitting the bounds polygon into two polygons\n    const w1 = e > 180 ? w : w + 360\n    const e1 = 180 - 0.001\n    const w2 = -180\n    const e2 = e > 180 ? e - 360 : e\n    boundsPolygonsCoordinates.push([[[w1, n], [e1, n], [e1, s], [w1, s], [w1, n]]])\n    boundsPolygonsCoordinates.push([[[w2, n], [e2, n], [e2, s], [w2, s], [w2, n]]])\n  } else {\n    boundsPolygonsCoordinates.push([[[w, n], [e, n], [e, s], [w, s], [w, n]]])\n  }\n\n  const geom = {\n    type: 'MultiPolygon',\n    coordinates: boundsPolygonsCoordinates,\n  }\n\n  // using tilecover, get xyz tile coords as well as quadkey indexes (named uid through the app)\n  const viewportTilesCoords = tilecover.tiles(geom, limits)\n  const viewportTilesIndexes = tilecover.indexes(geom, limits)\n  const visibleTiles = []\n\n  viewportTilesCoords.forEach((coords, i) => {\n    const uid = viewportTilesIndexes[i]\n    const zoom = coords[2]\n    if (zoom >= 2) {\n      visibleTiles.push({\n        tileCoordinates: {\n          x: coords[0],\n          y: coords[1],\n          zoom: coords[2],\n        },\n        uid,\n      })\n    }\n  })\n\n  dispatch({\n    type: SET_CURRENTLY_VISIBLE_TILES,\n    payload: visibleTiles,\n  })\n\n  const isMouseWheelZooming = mapViewport.prevZoom !== viewport.zoom\n\n  if (isMouseWheelZooming === false) {\n    dispatch(flushTileState(forceLoadingAllVisibleTiles))\n  } else {\n    debouncedFlushState(dispatch)\n  }\n}\n\nexport const queryHeatmapVessels = (coords, temporalExtentIndexes) => (dispatch, getState) => {\n  // use tilecover to get what tile quadkey/uid \"belongs\" to the point\n  const geom = {\n    type: 'Point',\n    coordinates: [coords.longitude, coords.latitude],\n  }\n  const zoom = getState().map.viewport.viewport.zoom\n\n  // get quadkey for tile at current zoom level, but also neighbouring zoom levels,\n  // in case current zoom level tiles has not been loaded yet\n  const uids = [zoom, zoom - 1, zoom + 1]\n    .map((z) => getTilecoverLimits(z))\n    .map((limits) => tilecover.indexes(geom, limits))\n    .map((indexes) => indexes[0])\n\n  const query = {\n    ...coords,\n    uids,\n  }\n\n  // console.log(query);\n  dispatch(highlightVesselFromHeatmap(query, temporalExtentIndexes))\n}\n","import difference from 'lodash/difference'\nimport uniq from 'lodash/uniq'\nimport uniqBy from 'lodash/uniqBy'\nimport {\n  getTilePromises,\n  getCleanVectorArrays,\n  groupData,\n  getTilePlaybackData,\n  selectVesselsAt,\n} from '../utils/heatmapTileData'\nimport { markTileAsLoaded } from './heatmapTiles.actions'\nimport { startLoader, completeLoader } from '../module/module.actions'\n\nexport const ADD_HEATMAP_LAYER = 'ADD_HEATMAP_LAYER'\nexport const UPDATE_HEATMAP_LAYER_STYLE = 'UPDATE_HEATMAP_LAYER_STYLE'\nexport const ADD_REFERENCE_TILE = 'ADD_REFERENCE_TILE'\nexport const HIGHLIGHT_VESSELS = 'HIGHLIGHT_VESSELS'\nexport const INIT_HEATMAP_LAYERS = 'INIT_HEATMAP_LAYERS'\nexport const REMOVE_HEATMAP_LAYER = 'REMOVE_HEATMAP_LAYER'\nexport const UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES =\n  'UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES'\nexport const UPDATE_HEATMAP_TILE = 'UPDATE_HEATMAP_TILE'\nexport const RELEASE_HEATMAP_TILES = 'RELEASE_HEATMAP_TILES'\nexport const UPDATE_LOADED_TILES = 'UPDATE_LOADED_TILES'\nexport const HIGHLIGHT_CLICKED_VESSEL = 'HIGHLIGHT_CLICKED_VESSEL'\nexport const CLEAR_HIGHLIGHT_CLICKED_VESSEL = 'CLEAR_HIGHLIGHT_CLICKED_VESSEL'\n\n/**\n * getTemporalExtentsVisibleIndices - Compares timebar outer extent with temporal extents present on the layer header\n * @param  {array} loadTemporalExtent Current timebar outer extent\n * @param  {array} layerTemporalExtents Temporal extent present on the layer's header (an array of extent arrays)\n * @return {array}                    Indices of the layer's temporal extents that should be visible\n */\nfunction getTemporalExtentsVisibleIndices(loadTemporalExtent, layerTemporalExtents) {\n  const currentExtentStart = loadTemporalExtent[0].getTime()\n  const currentExtentEnd = loadTemporalExtent[1].getTime()\n  const indices = []\n  layerTemporalExtents.forEach((temporalExtent, index) => {\n    const temporalExtentStart = temporalExtent[0]\n    const temporalExtentEnd = temporalExtent[1]\n    if (temporalExtentEnd >= currentExtentStart && temporalExtentStart <= currentExtentEnd) {\n      indices.push(index)\n    }\n  })\n  return indices\n}\n\n/**\n * loadLayerTile - loads an heatmap tile.\n *\n * @param  {string} layerId              layer id\n * @param  {object} tileCoordinates      tile coordinates from reference tile\n * @param  {string} token                the user's token\n * @param  {array} temporalExtentsIndices which of the temporal extents from  temporalExtents should be loaded\n * @param  {string} urls                 tile endpoints provided by header\n * @param  {array} temporalExtents       all of the layer's header temporal extents\n * @param  {bool} temporalExtentsLess    true = don't try to load different tiles based on current time extent\n * @return {Promise}                     a Promise that will be resolved when tile is loaded\n */\nfunction loadLayerTile(\n  layerId,\n  tileCoordinates,\n  token,\n  temporalExtentsIndices,\n  { url, temporalExtents, temporalExtentsLess }\n) {\n  // console.log('loadLayerTile', layerId, tileCoordinates, temporalExtentsIndices)\n  if (url === undefined) {\n    throw new Error('URL/endpoints object is not available on this tilesets header')\n  }\n  const pelagosPromises = getTilePromises(url, token, temporalExtents, {\n    tileCoordinates,\n    temporalExtentsIndices,\n    temporalExtentsLess,\n  })\n  const allLayerPromises = Promise.all(pelagosPromises)\n\n  const layerTilePromise = new Promise((resolve) => {\n    allLayerPromises.then((rawTileData) => {\n      resolve({\n        loadedLayerId: layerId,\n        rawTileData,\n      })\n    })\n  })\n\n  return layerTilePromise\n}\n\n/**\n * parseLayerTile - parses an heatmap tile to a playback-ready format.\n *\n * @param  {Object} rawTileData          the raw tile data, loaded either from the pelagos client or as a MVT/PBF vector tile\n * @param  {array} colsByName            names of the columns present in the raw tiles that need to be included in the final playback data\n * @param  {object} tileCoordinates      tile coordinates from reference tile\n * @param  {array} prevPlaybackData      (optional) in case some time extent was already loaded for this tile, append to this data\n * @return {Object}                      playback-ready merged data\n */\nfunction parseLayerTile(rawTileData, colsByName, tileCoordinates, prevPlaybackData) {\n  let data\n\n  const cleanVectorArrays = getCleanVectorArrays(rawTileData)\n  data = groupData(cleanVectorArrays, Object.keys(colsByName))\n  if (Object.keys(data).length === 0) {\n    return []\n  }\n\n  const playbackData = getTilePlaybackData(data, colsByName, tileCoordinates, prevPlaybackData)\n  return playbackData\n}\n\n/**\n * getTiles - loads a bunch of heatmap tiles\n * @param  {array} layerIds                 list of layer Ids that need to be loaded for this/these tiles\n * @param  {array} referenceTiles           list of reference tiles (tile data regardless of layer) that need to be loaded\n * @param  {object} newTemporalExtentsToLoad (optional) a dict (layerId is the key) of temporal extents\n * indices that should be appended to existing data\n */\nfunction getTiles(layerIds, referenceTiles, newTemporalExtentsToLoad = undefined) {\n  return (dispatch, getState) => {\n    const state = getState()\n    const loaderID = startLoader(dispatch, state, layerIds.join('-'))\n    const token = state.map.module.token\n    const heatmapLayers = state.map.heatmap.heatmapLayers\n    const tilesByLayer = {}\n    layerIds.forEach((id) => {\n      tilesByLayer[id] = [...heatmapLayers[id].tiles]\n    })\n    const allPromises = []\n\n    layerIds.forEach((layerId) => {\n      const heatmapLayerHeader = heatmapLayers[layerId].header\n      const { temporalExtents, temporalExtentsLess, colsByName } = { ...heatmapLayerHeader }\n      const url = heatmapLayerHeader.endpoints.tiles\n\n      referenceTiles.forEach((referenceTile) => {\n        // check if tile does not already exist first\n        let tile = tilesByLayer[layerId].find((t) => t.uid === referenceTile.uid)\n        if (!tile) {\n          // console.log('create tile ', referenceTile.uid)\n          tile = {\n            uid: referenceTile.uid,\n            temporalExtentsIndicesLoaded: [],\n          }\n          tilesByLayer[layerId].push(tile)\n        } else {\n          // console.log('found tile', referenceTile.uid)\n        }\n\n        const queriedTemporalExtentsIndices =\n          newTemporalExtentsToLoad === undefined\n            ? heatmapLayers[layerId].visibleTemporalExtentsIndices\n            : newTemporalExtentsToLoad[layerId]\n\n        const temporalExtentsIndicesToLoad = difference(\n          queriedTemporalExtentsIndices,\n          tile.temporalExtentsIndicesLoaded\n        )\n\n        const tilePromise = loadLayerTile(\n          layerId,\n          referenceTile.tileCoordinates,\n          token,\n          temporalExtentsIndicesToLoad,\n          {\n            url,\n            temporalExtents,\n            temporalExtentsLess,\n          }\n        )\n\n        allPromises.push(tilePromise)\n\n        tilePromise.then(({ loadedLayerId, rawTileData }) => {\n          tile.temporalExtentsIndicesLoaded = uniq(\n            tile.temporalExtentsIndicesLoaded.concat(temporalExtentsIndicesToLoad)\n          )\n          tile.data = parseLayerTile(\n            rawTileData,\n            colsByName,\n            referenceTile.tileCoordinates,\n            tile.data\n          )\n\n          dispatch({\n            type: UPDATE_HEATMAP_TILE,\n            payload: {\n              layerId: loadedLayerId,\n              tile,\n            },\n          })\n        })\n      })\n    })\n\n    Promise.all(allPromises).then(() => {\n      dispatch(completeLoader(loaderID))\n      dispatch(markTileAsLoaded(referenceTiles.map((tile) => tile.uid)))\n    })\n  }\n}\n\n/**\n * getTile - This action is emitted when a new tile is queried from panning or zooming the map\n * This will load a tile for all currently visible heatmap layers\n *\n * @param  {object} referenceTile a reference tile containing xyz coords and uid\n */\nexport function getTile(referenceTile) {\n  return (dispatch, getState) => {\n    dispatch({\n      type: ADD_REFERENCE_TILE,\n      payload: referenceTile,\n    })\n    const visibleHeatmapLayers = getState().map.heatmap.heatmapLayers\n    const visibleHeatmapLayersIds = Object.keys(visibleHeatmapLayers).filter(\n      (id) => visibleHeatmapLayers[id].visible === true\n    )\n\n    if (visibleHeatmapLayersIds.length) {\n      dispatch(getTiles(visibleHeatmapLayersIds, [referenceTile]))\n    }\n  }\n}\n\n/**\n * releaseTiles - This action is emitted when an existing tile is removed from panning or zooming the map\n * @param  {array} uids tile ref uids to release\n */\nexport const releaseTiles = (uids) => ({\n  type: RELEASE_HEATMAP_TILES,\n  payload: uids,\n})\n\nexport const updateLoadedTiles = () => ({\n  type: UPDATE_LOADED_TILES,\n})\n\n// triggered when a layer is added or set to visible\nfunction loadAllTilesForLayer(layerId) {\n  return (dispatch, getState) => {\n    //                current layer, all reference tiles\n    const referenceTiles = getState().map.heatmap.referenceTiles\n    dispatch(getTiles([layerId], referenceTiles))\n  }\n}\n\nexport const addHeatmapLayer = (layer, loadTemporalExtent) => (dispatch) => {\n  const layerTemporalExtents = layer.header.temporalExtents\n  dispatch({\n    type: ADD_HEATMAP_LAYER,\n    payload: {\n      ...layer,\n      // initially attach which of the temporal extents indices are visible with initial outerExtent\n      visibleTemporalExtentsIndices: getTemporalExtentsVisibleIndices(\n        loadTemporalExtent,\n        layerTemporalExtents\n      ),\n    },\n  })\n\n  if (layer.visible === true) {\n    dispatch(loadAllTilesForLayer(layer.id))\n  }\n}\n\nexport const removeHeatmapLayer = (id) => (dispatch) => {\n  dispatch({\n    type: REMOVE_HEATMAP_LAYER,\n    payload: {\n      id,\n    },\n  })\n}\n\n/**\n * updateLayerLoadTemporalExtents - when outer time extent changes, checks if more tiles needs to be loaded\n * by comparing the outer time range with the temporalExtent already loaded on each layer.\n * @param  {array} loadTemporalExtent Current app-wide extent of tiles that need to load, expressed\n * as an array of two dates\n */\nexport function updateLayerLoadTemporalExtents(loadTemporalExtent) {\n  return (dispatch, getState) => {\n    const state = getState()\n    const heatmapLayers = state.map.heatmap.heatmapLayers\n    const indicesToAddByLayer = {}\n\n    Object.keys(heatmapLayers).forEach((layerId) => {\n      const heatmapLayer = heatmapLayers[layerId]\n      const temporalExtents = heatmapLayer.header.temporalExtents\n      const oldVisibleTemporalExtentsIndices = heatmapLayer.visibleTemporalExtentsIndices\n      const newVisibleTemporalExtentsIndices = getTemporalExtentsVisibleIndices(\n        loadTemporalExtent,\n        temporalExtents\n      )\n\n      const indicesAdded = difference(\n        newVisibleTemporalExtentsIndices,\n        oldVisibleTemporalExtentsIndices\n      )\n\n      const indicesRemoved = difference(\n        oldVisibleTemporalExtentsIndices,\n        newVisibleTemporalExtentsIndices\n      )\n\n      if (indicesAdded.length || indicesRemoved.length) {\n        // add new loaded indices to heatmap layer if applicable\n        dispatch({\n          type: UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES,\n          payload: {\n            layerId,\n            newVisibleTemporalExtentsIndices,\n            indicesRemoved,\n          },\n        })\n      }\n      if (indicesAdded.length) {\n        indicesToAddByLayer[layerId] = indicesAdded\n      }\n    })\n\n    // getTiles with indices diff\n    const layerIdsWithIndicesToAdd = Object.keys(indicesToAddByLayer)\n    if (layerIdsWithIndicesToAdd.length) {\n      dispatch(\n        getTiles(layerIdsWithIndicesToAdd, state.map.heatmap.referenceTiles, indicesToAddByLayer)\n      )\n    }\n  }\n}\n\n/**\n * Returns clusters or vessels data from a tileQuery\n * @param {object} state - the application state\n * @param {string} tileQuery - the id of a heatmap layer\n * @return {object} { isEmpty, isCluster, isMouseCluster, foundVessels, layerId, tilesetId }\n */\nconst _queryHeatmap = (state, tileQuery, temporalExtentIndexes) => {\n  const layers = state.map.heatmap.heatmapLayers\n  const startIndex = temporalExtentIndexes[0]\n  const endIndex = temporalExtentIndexes[1]\n  const layersVessels = []\n\n  Object.keys(layers).forEach((layerId) => {\n    const layer = layers[layerId]\n    if (layer.visible !== true) {\n      return\n    }\n    const allPossibleTilesByPreference = tileQuery.uids.map((uid) =>\n      layer.tiles.find((tile) => tile.uid === uid)\n    )\n    const availableTiles = allPossibleTilesByPreference.filter(\n      (tile) => tile !== undefined && tile.data !== undefined\n    )\n\n    const currentFilters = layer.filters\n    if (availableTiles.length) {\n      const bestTile = availableTiles[0]\n      layersVessels.push({\n        layer,\n        vessels: selectVesselsAt(bestTile.data, tileQuery, startIndex, endIndex, currentFilters),\n      })\n    }\n  })\n\n  const layersVesselsResults = layersVessels.filter(\n    (layerVessels) => layerVessels.vessels.length > 0\n  )\n\n  // it's a cluster because of aggregation on the server side\n  let isCluster\n  // its a cluster because or multiple vessels under mouse\n  let isMouseCluster\n  let isEmpty\n  let layerVesselsResult\n  let foundVessels\n\n  if (layersVesselsResults.length === 0) {\n    isEmpty = true\n  } else if (layersVesselsResults.length > 1) {\n    // if there are points over multiple layers, consider this a cluster (ie don't select, zoom instead, or don't highlight)\n    // there's an exception if vessel selection contains an encounter, in which case it will take priority\n    isCluster = true\n  } else {\n    // layersVesselsResults should contain a single result\n    layerVesselsResult = layersVesselsResults[0]\n\n    // we can get multiple points with similar series and id, in which case\n    // we should treat that as a successful vessel query, not a cluster\n    const vessels = layerVesselsResult.vessels\n\n    if (vessels.length === 0) {\n      isEmpty = true\n    } else {\n      // look up for any negatives ids (clusters on the server side)\n      const clusteredVessels = vessels.filter((v) => v.id < 0)\n      if (clusteredVessels.length) {\n        isCluster = true\n      } else {\n        foundVessels = uniqBy(vessels, (v) => v.series)\n        isMouseCluster = foundVessels.length > 1\n      }\n    }\n  }\n\n  const layer = layerVesselsResult === undefined ? {} : layerVesselsResult.layer\n\n  return { isEmpty, isCluster, isMouseCluster, foundVessels, layer }\n}\n\nexport function clearHighlightedVessels() {\n  return {\n    type: HIGHLIGHT_VESSELS,\n    payload: {\n      isEmpty: true,\n      clickableCluster: false,\n    },\n  }\n}\n\nexport function highlightVesselFromHeatmap(tileQuery, temporalExtentIndexes) {\n  return (dispatch, getState) => {\n    const state = getState()\n    const { layer, isEmpty, isCluster, isMouseCluster, foundVessels } = _queryHeatmap(\n      state,\n      tileQuery,\n      temporalExtentIndexes\n    )\n\n    if (\n      isCluster === true ||\n      layer.id !== undefined ||\n      state.map.heatmap.highlightedVessels.layerId !== layer.id\n    ) {\n      const layerPayload =\n        layer === undefined\n          ? null\n          : {\n              id: layer.id,\n              tilesetId: layer.tilesetId,\n              subtype: layer.subtype,\n              header: layer.header,\n            }\n      dispatch({\n        type: HIGHLIGHT_VESSELS,\n        payload: {\n          layer: layerPayload,\n          isEmpty,\n          clickableCluster: isCluster === true || isMouseCluster === true,\n          highlightableCluster: isCluster !== true,\n          foundVessels,\n        },\n      })\n    } else {\n      dispatch(clearHighlightedVessels())\n    }\n  }\n}\n\nexport const highlightClickedVessel = (id, layerId) => ({\n  type: HIGHLIGHT_CLICKED_VESSEL,\n  payload: {\n    id,\n    layerId,\n  },\n})\n\nexport const clearHighlightedClickedVessel = () => ({\n  type: CLEAR_HIGHLIGHT_CLICKED_VESSEL,\n})\n\nexport const updateHeatmapLayers = (newLayers, currentLoadTemporalExtent) => (\n  dispatch,\n  getState\n) => {\n  if (newLayers === null) {\n    console.warn(\"New layers in updateHeatmapLayers can't be null\")\n    return\n  }\n  const prevLayersDict = getState().map.heatmap.heatmapLayers\n\n  // add and update layers\n  newLayers.forEach((newLayer) => {\n    const layerId = newLayer.id\n    const prevLayer = prevLayersDict[layerId]\n    if (prevLayer === undefined) {\n      // console.log('adding', layerId)\n      dispatch(addHeatmapLayer(newLayer, currentLoadTemporalExtent))\n    } else {\n      if (prevLayer.visible !== newLayer.visible && newLayer.visible === true) {\n        dispatch(loadAllTilesForLayer(layerId))\n      }\n      if (\n        prevLayer.visible !== newLayer.visible ||\n        prevLayer.hue !== newLayer.hue ||\n        prevLayer.opacity !== newLayer.opacity ||\n        prevLayer.filters !== newLayer.filters ||\n        prevLayer.interactive !== newLayer.interactive\n      ) {\n        // console.log('updating', layerId, ' with visibilty', newLayer.visible)\n        dispatch({\n          type: UPDATE_HEATMAP_LAYER_STYLE,\n          payload: {\n            id: newLayer.id,\n            visible: newLayer.visible,\n            hue: newLayer.hue,\n            opacity: newLayer.opacity,\n            filters: newLayer.filters,\n            interactive: newLayer.interactive,\n          },\n        })\n      }\n    }\n  })\n\n  // clean up unused layers\n  Object.keys(prevLayersDict).forEach((prevLayerId) => {\n    if (!newLayers.find((l) => l.id === prevLayerId)) {\n      dispatch(removeHeatmapLayer(prevLayerId))\n    }\n  })\n}\n","import { fitBounds, pixelsToWorld } from 'viewport-mercator-project'\nimport { updateHeatmapTilesFromViewport } from '../heatmap/heatmapTiles.actions'\nimport { onViewportChange } from '../module/module.actions'\nimport { CLUSTER_CLICK_ZOOM_INCREMENT } from '../config' // TODO MAP MODULE\n\nexport const SET_BOUNDS = 'SET_BOUNDS'\nexport const SET_VIEWPORT = 'SET_VIEWPORT'\nexport const UPDATE_VIEWPORT = 'UPDATE_VIEWPORT'\nexport const SET_ZOOM_INCREMENT = 'SET_ZOOM_INCREMENT'\nexport const SET_MOUSE_LAT_LONG = 'SET_MOUSE_LAT_LONG'\nexport const TRANSITION_END = 'TRANSITION_END'\nexport const SET_NATIVE_VIEWPORT = 'SET_NATIVE_VIEWPORT'\n\nexport const setBounds = (bounds) => ({\n  type: SET_BOUNDS,\n  payload: bounds,\n})\n\nexport const setViewport = (viewport, interactionState) => (dispatch) => {\n  dispatch({\n    type: SET_VIEWPORT,\n    payload: viewport,\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  dispatch(onViewportChange(interactionState))\n}\n\nexport const updateViewport = (viewportUpdate) => (dispatch) => {\n  dispatch({\n    type: UPDATE_VIEWPORT,\n    payload: viewportUpdate,\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  // Not needed as call the callback with the same values\n  // dispatch(onViewportChange())\n}\n\nconst transitionTo = (increment, latitude = null, longitude = null, zoom = null) => (dispatch) => {\n  dispatch({\n    type: SET_ZOOM_INCREMENT,\n    payload: {\n      increment,\n      latitude,\n      longitude,\n      zoom,\n    },\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  dispatch(onViewportChange())\n}\n\nexport const transitionToZoom = (viewport) => (dispatch) => {\n  dispatch(transitionTo(null, viewport.center[0], viewport.center[1], viewport.zoom))\n}\n\nexport const transitionEnd = () => (dispatch) => {\n  dispatch({\n    type: TRANSITION_END,\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  dispatch(onViewportChange())\n}\n\nexport const zoomIntoVesselCenter = (latitude, longitude, zoom = null) => (dispatch) => {\n  dispatch(transitionTo(CLUSTER_CLICK_ZOOM_INCREMENT, latitude, longitude, zoom))\n}\n\nexport const fitToBounds = (bounds) => (dispatch, getState) => {\n  const state = getState()\n  const vp = fitBounds({\n    bounds: [[bounds.minLng, bounds.minLat], [bounds.maxLng, bounds.maxLat]],\n    width: state.map.viewport.viewport.width,\n    height: state.map.viewport.viewport.height,\n    padding: 50,\n  })\n  dispatch(transitionTo(null, vp.latitude, vp.longitude, vp.zoom))\n}\n\nexport const exportNativeViewport = (nativeViewport) => (dispatch) => {\n  const topLeftPx = [0, 0]\n  const bottomRightPx = [nativeViewport.width, nativeViewport.height]\n\n  // compute left and right offsets to deal with antimeridian issue\n  const topLeftWorld = pixelsToWorld(topLeftPx, nativeViewport.pixelUnprojectionMatrix)\n  const bottomRightWorld = pixelsToWorld(bottomRightPx, nativeViewport.pixelUnprojectionMatrix)\n  const leftWorldScaled = topLeftWorld[0] / nativeViewport.scale\n  const rightWorldScaled = bottomRightWorld[0] / nativeViewport.scale\n\n  // lat/lon corners for miniglobe\n  const northWest = nativeViewport.unproject(topLeftPx)\n  const southEast = nativeViewport.unproject(bottomRightPx)\n  const bounds = {\n    north: northWest[1],\n    south: southEast[1],\n    west: northWest[0],\n    east: southEast[0],\n  }\n\n  dispatch({\n    type: SET_NATIVE_VIEWPORT,\n    payload: {\n      leftWorldScaled,\n      rightWorldScaled,\n      bounds,\n    },\n  })\n}\n","import area from '@turf/area'\nimport { POLYGON_LAYERS_AREA } from '../constants'\nimport { clearHighlightedVessels, clearHighlightedClickedVessel } from '../heatmap/heatmap.actions'\nimport { zoomIntoVesselCenter } from './viewport.actions'\n\nexport const SET_POPUP = 'SET_POPUP'\nexport const CLEAR_POPUP = 'CLEAR_POPUP'\nexport const SET_MAP_CURSOR = 'SET_MAP_CURSOR'\n\nconst getAreaKm2 = (glFeature) => {\n  const areakm2 = 10 ** -6 * area(glFeature.geometry)\n  const formatted = areakm2.toLocaleString('en-US', { maximumFractionDigits: 0 })\n  return formatted\n}\n\nconst getFields = (glFeature, source = null) => {\n  if (source === null || source === undefined) {\n    // console.warn('Couldnt find source when looking for fields of layer', sourceId)\n  }\n\n  const fieldsDefinition =\n    !source || source.metadata === undefined || source.metadata['gfw:popups'] === undefined\n      ? []\n      : source.metadata['gfw:popups']\n\n  const properties = glFeature.properties\n\n  // whitelist if 'gfw:popups' exist, if not return all\n  const fieldsKeys = Object.keys(glFeature.properties).filter(\n    (k) => fieldsDefinition.length === 0 || fieldsDefinition.find((fd) => fd.id === k) !== undefined\n  )\n\n  const fields = fieldsKeys.map((fieldKey) => {\n    const value = fieldKey === POLYGON_LAYERS_AREA ? getAreaKm2(glFeature) : properties[fieldKey]\n    const def = fieldsDefinition.find((fd) => fd.id === fieldKey) || {}\n    const label = def.label || fieldKey\n    return {\n      id: fieldKey,\n      label,\n      value,\n      title: `${label}: ${value}`,\n      isLink: def.isLink,\n      isMain: def.isMain,\n    }\n  })\n\n  const mainField =\n    fields.find((f) => f.isMain === true) ||\n    fields.find((f) => f.id === 'name') ||\n    fields.find((f) => f.id === 'id') ||\n    fields[0]\n\n  if (mainField !== undefined) {\n    mainField.isMain = true\n  }\n  return fields\n}\n\nconst getCluster = (glFeature, glGetSource) => {\n  const clusterId = glFeature.properties.cluster_id\n  const sourceId = glFeature.source\n  const glSource = glGetSource(sourceId)\n  const promise = new Promise((resolve, reject) => {\n    glSource.getClusterExpansionZoom(clusterId, (err1, zoom) => {\n      glSource.getClusterLeaves(clusterId, 99, 0, (err2, children) => {\n        if (err1 || err2) {\n          reject()\n        }\n        const childrenFeatures = children.map((child) =>\n          getFeature(child, glFeature.layer.id, glSource)\n        )\n        resolve({\n          zoom,\n          childrenFeatures,\n        })\n      })\n    })\n  })\n  return promise\n}\n\nconst getFeature = (glFeature, layerId, source) => {\n  const feature = {\n    properties: glFeature.properties,\n  }\n  const fields = getFields(glFeature, source)\n  feature.fields = fields\n\n  // Get most likely feature title\n  const mainField = fields.find((f) => f.isMain === true)\n  feature.title = mainField === undefined ? layerId : mainField.value\n\n  return feature\n}\n\nexport const mapInteraction = (interactionType, latitude, longitude, glFeatures, glGetSource) => (\n  dispatch,\n  getState\n) => {\n  if (interactionType === 'click') {\n    dispatch(clearHighlightedClickedVessel())\n  }\n\n  const currentStyle = getState().map.style.mapStyle.toJS()\n\n  const event = {\n    latitude,\n    longitude,\n    features: [],\n  }\n\n  // Collect and normalize features on legacy heatmap\n  const currentLegacyHeatmapData = getState().map.heatmap.highlightedVessels\n  let legacyHeatmapFeature\n\n  if (currentLegacyHeatmapData.isEmpty !== true) {\n    const foundVessels =\n      currentLegacyHeatmapData.foundVessels === undefined\n        ? []\n        : currentLegacyHeatmapData.foundVessels\n    const properties = foundVessels.length === 0 ? [] : foundVessels[0]\n    const isCluster = currentLegacyHeatmapData.clickableCluster === true\n    const count =\n      isCluster === true && currentLegacyHeatmapData.highlightableCluster === false\n        ? -1\n        : foundVessels.length\n    legacyHeatmapFeature = {\n      isCluster,\n      count,\n      layer: {\n        id: currentLegacyHeatmapData.layer.id,\n        group: 'legacyHeatmap',\n      },\n      properties,\n    }\n    event.features.push(legacyHeatmapFeature)\n  }\n\n  // Try to retrieve 'gfw:id' (generated when instanciating CARTO layer to preserve original style.json id)\n  // In most cases it won't exist, so fall back to source id\n  const getStaticLayerIdFromGlFeature = (glFeature) =>\n    (glFeature.layer.metadata !== undefined && glFeature.layer.metadata['gfw:id']) ||\n    glFeature.layer.source\n\n  // Collect gl features\n  const clusterPromises = []\n  const allGlFeatures = glFeatures || []\n  allGlFeatures.forEach((glFeature) => {\n    const layerId = getStaticLayerIdFromGlFeature(glFeature)\n    const source = currentStyle.sources[layerId]\n    const feature = {\n      layer: {\n        id: layerId,\n        group: glFeature.layer.metadata && glFeature.layer.metadata['mapbox:group'],\n      },\n      ...getFeature(glFeature, layerId, source),\n    }\n\n    if (glFeature.properties.cluster === true) {\n      // lookup for cluster\n      const clusterPromise = getCluster(glFeature, glGetSource).then((cluster) => {\n        feature.cluster = cluster\n        feature.count = cluster.childrenFeatures.length\n      })\n      clusterPromises.push(clusterPromise)\n      feature.isCluster = true\n    } else {\n      feature.isCluster = false\n    }\n    event.features.push(feature)\n  })\n\n  Promise.all(clusterPromises).then(() => {\n    // The whole set of features is considered a cluster\n    // if any feature is a cluster, or there is more than one feature\n    event.isCluster =\n      event.features.length > 1 || event.features.some((feature) => feature.isCluster === true)\n\n    // legacy heatmap layers can yield clusters with an unknown number of features, handle this here:\n    if (legacyHeatmapFeature !== undefined && legacyHeatmapFeature.count === -1) {\n      event.count = -1\n    } else {\n      event.count = event.features.reduce((count, feature) => {\n        let featureCount = feature.count || 1\n        return count + featureCount\n      }, 0)\n    }\n\n    if (event.count === 1) {\n      event.feature = event.features[0]\n    }\n\n    // When autoClusterZoom is set to true, we handle zoom here\n    const autoClusterZoom = getState().map.module.autoClusterZoom === true\n\n    // Check if cluster using customizable isCluster() callback\n    // If not set resolves simply to (event) => event.isCluster === true\n    const clusterBehavior = getState().map.module.isCluster(event)\n    event.isCluster = clusterBehavior\n\n    if (autoClusterZoom) {\n      if (interactionType === 'click' && event.isCluster === true) {\n        dispatch(clearHighlightedVessels())\n        const clusterZoom = event.features[0].cluster && event.features[0].cluster.zoom\n        dispatch(zoomIntoVesselCenter(latitude, longitude, clusterZoom))\n      }\n    }\n\n    let cursor = event.features.length ? 'pointer' : null\n    if (event.isCluster === true) {\n      cursor = 'zoom-in'\n    }\n\n    dispatch({\n      type: SET_MAP_CURSOR,\n      payload: cursor,\n    })\n\n    const callback =\n      interactionType === 'click' ? getState().map.module.onClick : getState().map.module.onHover\n\n    if (callback !== undefined) {\n      callback(event)\n    }\n  })\n}\n","const RGB_MAX = 255\nconst HUE_MAX = 360\nconst SV_MAX = 100\n\nexport const VESSELS_HUES_INCREMENTS_NUM = 31 // 360 / VESSELS_HUES_INCREMENTS_NUM - 1  should give a round number\nexport const VESSELS_HUES_INCREMENT = 360 / (VESSELS_HUES_INCREMENTS_NUM - 1)\n\n// Legacy: this is only here for compatibility with pre-mapbox branch workspaces\nexport const COLOR_HUES = {\n  orange: 0,\n  peach: 22,\n  yellow: 60,\n  green: 85,\n  brightGreen: 145,\n  lightBlue: 182,\n  blue: 236,\n  purple: 284,\n  pink: 312,\n}\n\n// FIXME mark explicitely as legacy. Check all usages.\nexport const getKeyByValue = (obj, value) => {\n  let result = null\n  Object.entries(obj).forEach((entry) => {\n    if (entry[1] === value) result = entry[0]\n  })\n  return result\n}\n\n/**\n * Converts an RGB color value to HSV. Conversion formula\n * adapted from http://en.wikipedia.org/wiki/HSV_color_space.\n * Assumes r, g, and b are contained in the set [0, 255] and\n * returns h, s, and v in the set [0, 1].\n *\n * @param   Number  r       The red color value\n * @param   Number  g       The green color value\n * @param   Number  b       The blue color value\n * @return  Array           The HSV representation\n */\nexport const rgbToHsv = (_r, _g, _b) => {\n  const r = _r / 255\n  const g = _g / 255\n  const b = _b / 255\n\n  const max = Math.max(r, g, b)\n  const min = Math.min(r, g, b)\n  let h\n  const v = max\n\n  const d = max - min\n  const s = max === 0 ? 0 : d / max\n\n  if (max === min) {\n    h = 0 // achromatic\n  } else {\n    switch (max) {\n      case r:\n        h = (g - b) / d + (g < b ? 6 : 0)\n        break\n      case g:\n        h = (b - r) / d + 2\n        break\n      case b:\n        h = (r - g) / d + 4\n        break\n      default:\n        h = 0\n    }\n\n    h /= 6\n  }\n\n  return [h, s, v]\n}\n\n// converts hue, saturation, luminance to an rgb object\nexport const hsvToRgb = (h_, s_, v_) => {\n  const h = ((h_ % HUE_MAX) / parseFloat(HUE_MAX)) * 6\n  const s = s_ === SV_MAX ? 1 : (s_ % SV_MAX) / parseFloat(SV_MAX)\n  const v = v_ === SV_MAX ? 1 : (v_ % SV_MAX) / parseFloat(SV_MAX)\n\n  const i = Math.floor(h)\n  const f = h - i\n  const p = v * (1 - s)\n  const q = v * (1 - f * s)\n  const t = v * (1 - (1 - f) * s)\n  const mod = i % 6\n  const r = [v, q, p, p, t, v][mod]\n  const g = [t, v, v, q, p, p][mod]\n  const b = [p, p, t, v, v, q][mod]\n\n  return { r: Math.round(r * RGB_MAX), g: Math.round(g * RGB_MAX), b: Math.round(b * RGB_MAX) }\n}\n\n// returns an rgb string with default saturation and luminance values\nconst hueToRgbDefaults = (hue) => hsvToRgb(hue, 50, 100)\n\nexport const hueToRgbString = (hue) => {\n  const rgb = hueToRgbDefaults(hue)\n  return `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`\n}\n\nexport const rgbToHexString = (rgb, css) => {\n  const str = ['r', 'g', 'b']\n    .map((channelName) => {\n      const channelValue = rgb[channelName]\n      let channelStr = channelValue.toString(16)\n      if (channelValue < 16) {\n        channelStr = `0${channelStr}`\n      }\n      return channelStr\n    })\n    .join('')\n  const prefix = css === true ? '#' : '0x'\n  return `${prefix}${str}`\n}\n\nexport const hueToRgbHexString = (hue, css) => {\n  const rgb = hueToRgbDefaults(hue)\n  return rgbToHexString(rgb, css)\n}\n\nconst closestNumber = (numberArray, goal) =>\n  numberArray.reduce((prev, curr) => (Math.abs(curr - goal) < Math.abs(prev - goal) ? curr : prev))\n\nexport const hueToClosestColor = (hue) => {\n  if (hue === undefined || hue === null) return undefined\n  const colorHueValues = Object.keys(COLOR_HUES).map((key) => COLOR_HUES[key])\n  const closestHue = closestNumber(colorHueValues, hue)\n  return getKeyByValue(COLOR_HUES, closestHue)\n}\n\nexport const hexToRgb = (hex) => {\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex)\n  return result\n    ? {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16),\n      }\n    : null\n}\n\nconst rgbToRgbaString = (rgb, opacity) => `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`\n\nexport const hueToRgbaString = (hue, opacity) => {\n  const rgb = hueToRgbDefaults(hue)\n  return rgbToRgbaString(rgb, opacity)\n}\n\nexport const hexToRgba = (hex, opacity) => {\n  const rgb = hexToRgb(hex)\n  return rgbToRgbaString(rgb, opacity)\n}\n\nexport const hueIncrementToHue = (hueIncrement) => hueIncrement * VESSELS_HUES_INCREMENT\n\nexport const hueToHueIncrement = (hue) =>\n  Math.round((hue / 360) * (VESSELS_HUES_INCREMENTS_NUM - 1))\n\nexport const wrapHue = (hue) => hue % 360\n\nexport const hueOrColorToHexColor = (color, hue) => {\n  if (hue !== undefined) {\n    return hueToRgbHexString(hue, true)\n  }\n\n  return color\n}\n","/* global PIXI */\nimport 'pixi.js'\nimport { hueToHueIncrement, VESSELS_HUES_INCREMENTS_NUM } from '../utils/map-colors'\nimport { VESSELS_BASE_RADIUS, MAX_SPRITES_PER_LAYER } from '../config'\n\nexport default class HeatmapSubLayer {\n  constructor(baseTexture, renderingStyleIndex, hue, useNormalBlendMode = false) {\n    // this.stage = new PIXI.Container();\n    // the ParticleContainer is a faster version of the PIXI sprite container\n    this.stage = new PIXI.particles.ParticleContainer(MAX_SPRITES_PER_LAYER, {\n      scale: true,\n      alpha: true,\n      position: true,\n      uvs: true,\n    })\n    if (useNormalBlendMode === false) {\n      this.stage.blendMode = PIXI.BLEND_MODES.SCREEN\n    }\n\n    this.spritesPool = []\n\n    const initialTextureFrame = new PIXI.Rectangle(\n      0,\n      0,\n      VESSELS_BASE_RADIUS * 2,\n      VESSELS_BASE_RADIUS * 2\n    )\n    this.mainVesselTexture = new PIXI.Texture(baseTexture, initialTextureFrame)\n    this._setTextureFrame(renderingStyleIndex, hue)\n\n    this.clearSpriteProps()\n  }\n\n  clearSpriteProps() {\n    this.spritesProps = {\n      x: new Float32Array(MAX_SPRITES_PER_LAYER),\n      y: new Float32Array(MAX_SPRITES_PER_LAYER),\n      a: new Float32Array(MAX_SPRITES_PER_LAYER),\n      s: new Float32Array(MAX_SPRITES_PER_LAYER),\n    }\n    this.spritesPropsCount = 0\n  }\n\n  pushSpriteProps(x, y, a, s) {\n    this.spritesProps.x[this.spritesPropsCount] = x\n    this.spritesProps.y[this.spritesPropsCount] = y\n    this.spritesProps.a[this.spritesPropsCount] = a\n    this.spritesProps.s[this.spritesPropsCount] = s\n    this.spritesPropsCount++\n  }\n\n  setRenderingStyleIndex(renderingStyleIndex) {\n    this._setTextureFrame(renderingStyleIndex)\n  }\n\n  destroy() {\n    this.spritesPool = null\n    this.stage.destroy({ children: true })\n  }\n\n  /**\n   * Updates the main texture frame offset to show different brush styles and hues\n   * Both args are optional, if one is omitted, previous value is used\n   * @heatmapStyle bool whether to use heatmap style or solid circle style\n   * @hue number hue value between 0 and 360\n   */\n  _setTextureFrame(renderingStyleIndex = null, hue = null) {\n    const textureFrame = this.mainVesselTexture.frame.clone()\n\n    if (renderingStyleIndex !== null) {\n      // one diameter + tiny offset between 2 frames\n      textureFrame.x = VESSELS_BASE_RADIUS * 2 * renderingStyleIndex + renderingStyleIndex\n    }\n\n    if (hue !== null) {\n      let hueIncrement = hueToHueIncrement(hue)\n      if (hueIncrement === VESSELS_HUES_INCREMENTS_NUM - 1) {\n        hueIncrement = 0\n      }\n      textureFrame.y = hueIncrement * VESSELS_BASE_RADIUS * 2\n      if (hueIncrement > 0) {\n        textureFrame.y += hueIncrement\n      }\n    }\n\n    this.mainVesselTexture.frame = textureFrame\n    this.mainVesselTexture.update()\n  }\n\n  render() {\n    const numProps = this.spritesPropsCount\n    this.resizeSpritesPool()\n\n    for (let i = 0; i < numProps; i++) {\n      const sprite = this.stage.children[i]\n      const s = this.spritesProps.s[i]\n      sprite.setTransform(this.spritesProps.x[i], this.spritesProps.y[i], s, s)\n      sprite.alpha = this.spritesProps.a[i]\n    }\n\n    const numSprites = this.stage.children.length\n    for (let i = numProps; i < numSprites; i++) {\n      const sprite = this.stage.children[i]\n      sprite.x = -100\n    }\n  }\n\n  resizeSpritesPool() {\n    const numProps = this.spritesPropsCount\n    const prevNumSprites = this.stage.children.length\n    const delta = numProps - prevNumSprites\n    // console.log(prevNumSprites, '->', numProps, ' delta:', delta);\n\n    if (delta < -4999) {\n      // sprite needs to be removed. Do that progressively (max 100) to avoid UI lock\n      const toRemove = Math.min(100, -delta)\n      // console.log('removing ', toRemove);\n      for (let i = 0; i < toRemove; i++) {\n        this.stage.removeChildAt(0)\n      }\n    }\n\n    if (delta > 0) {\n      const toAdd = Math.max(5000, delta)\n      // console.log('adding ', toAdd);\n      this._addSprites(toAdd)\n    }\n  }\n\n  _addSprites(num) {\n    for (let i = 0; i < num; i++) {\n      const vessel = new PIXI.Sprite(this.mainVesselTexture)\n      vessel.anchor.x = 0.5\n      vessel.anchor.y = 0.5\n      // ParticlesContainer does not support .visible, so we just move the sprite out of the viewport\n      vessel.x = -100\n      // vessel.blendMode = PIXI.BLEND_MODES.SCREEN;\n      // vessel.filters=  [new PIXI.filters.BlurFilter(10,10)]\n      this.stage.addChild(vessel)\n    }\n  }\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport uniq from 'lodash/uniq'\nimport * as PIXI from 'pixi.js'\nimport { worldToPixels } from 'viewport-mercator-project'\nimport { BRUSH_RENDERING_STYLE, BRUSH_ZOOM_RENDERING_STYLE } from '../constants'\nimport { vesselSatisfiesFilters } from '../utils/heatmapTileData'\nimport HeatmapSubLayer from './HeatmapSubLayer'\n\n// This is a faster version of worldToPixels that omits pitch,\n// and ignores values from the matrix that are consistently = 0\nconst s = 1 / 1.5\nconst worldToPixelsSimple = (x, y, m) => {\n  const fx = s * (m[0] * x + m[4] * y + m[12])\n  const fy = s * (m[5] * y + m[13])\n  return [fx, fy]\n}\n\nclass HeatmapLayer extends React.Component {\n  componentDidMount() {\n    this._build()\n  }\n\n  componentWillUnmount() {\n    this._destroy()\n  }\n\n  componentDidUpdate() {\n    this._redraw()\n  }\n\n  componentWillReceiveProps(nextProps) {\n    if (nextProps.useRadialGradientStyle !== this.props.useRadialGradientStyle) {\n      this.setBrushZoomRenderingStyle(nextProps.useRadialGradientStyle)\n    }\n  }\n\n  _build() {\n    const { layer, rootStage, useRadialGradientStyle, customRenderingStyle } = this.props\n    this.subLayers = {}\n    this.renderingStyle =\n      layer.header && layer.header.rendering ? layer.header.rendering : customRenderingStyle\n\n    this.setBrushRenderingStyle(this.renderingStyle.style)\n    this.setBrushZoomRenderingStyle(useRadialGradientStyle)\n\n    this.stage = new PIXI.Container()\n\n    rootStage.addChild(this.stage)\n  }\n\n  setBrushRenderingStyle(style = BRUSH_RENDERING_STYLE.NORMAL) {\n    if (typeof style === 'string') {\n      this.brushRenderingStyle = BRUSH_RENDERING_STYLE[style.toUpperCase()]\n    } else {\n      this.brushRenderingStyle = style\n    }\n    this._setBrushRenderingStyleIndex()\n  }\n\n  setBrushZoomRenderingStyle(useRadialGradientStyle) {\n    this.brushZoomRenderingStyle =\n      useRadialGradientStyle === true\n        ? BRUSH_ZOOM_RENDERING_STYLE.RADIAL_GRADIENT\n        : BRUSH_ZOOM_RENDERING_STYLE.CIRCLE\n    this._setBrushRenderingStyleIndex()\n  }\n\n  _setBrushRenderingStyleIndex() {\n    // only NORMAL brush styles support different zoom styles\n    const cappedZoomRenderingStyle =\n      this.brushRenderingStyle === BRUSH_RENDERING_STYLE.NORMAL ? this.brushZoomRenderingStyle : 0\n    const newStyleIndex = this.brushRenderingStyle + cappedZoomRenderingStyle\n    if (newStyleIndex === this.renderingStyleIndex) {\n      return\n    }\n    this.renderingStyleIndex = newStyleIndex\n    Object.values(this.subLayers).forEach((subLayer) => {\n      subLayer.setRenderingStyleIndex(this.renderingStyleIndex)\n    })\n  }\n\n  _redraw() {\n    const { filters, baseTexture, layer } = this.props\n\n    if (\n      layer === null ||\n      layer === undefined ||\n      layer.tiles === undefined ||\n      layer.visible === false\n    ) {\n      this.stage.visible = false\n      return\n    }\n\n    this.stage.visible = true\n    this.stage.alpha = layer.opacity\n\n    const tiles = layer.tiles\n    const defaultHue = layer.hue\n    const allHuesToRender =\n      filters !== undefined && filters.length\n        ? filters\n            // pass is set to true by filterGroupActions when none of the filters fields\n            // in the filter group is supported by the layer headers\n            .filter((f) => f.pass !== true)\n            .map((f) => (f.hue === undefined ? '0' : f.hue.toString()))\n        : [defaultHue.toString()]\n    const currentlyUsedHues = Object.keys(this.subLayers)\n\n    // get all hues, old and new\n    const allHues = uniq(allHuesToRender.concat(currentlyUsedHues))\n\n    for (let i = 0; i < allHues.length; i++) {\n      const hue = allHues[i]\n      if (allHuesToRender.indexOf(hue) === -1) {\n        // not on new hues: delete sublayer\n        this._destroySubLayer(this.subLayers[hue])\n        delete this.subLayers[hue]\n        continue\n      }\n      if (currentlyUsedHues.indexOf(hue) === -1) {\n        // not on old hues: create sublayer\n        this.subLayers[hue] = this._createSublayer(baseTexture, this.renderingStyleIndex, hue)\n      }\n      this.subLayers[hue].clearSpriteProps()\n    }\n\n    if (!allHuesToRender.length) return\n    tiles.forEach((tile) => {\n      this._setSubLayersSpritePropsForTile({\n        data: tile.data,\n        numFilters: filters.length,\n        defaultHue,\n      })\n    })\n\n    allHuesToRender.forEach((hueToRender) => {\n      this.subLayers[hueToRender].render()\n    })\n  }\n\n  _setSubLayersSpritePropsForTile({ data, numFilters, defaultHue }) {\n    if (!data) {\n      return\n    }\n\n    const { startIndex, endIndex, viewport, filters, viewportLeft, viewportRight } = this.props\n\n    for (let timeIndex = startIndex; timeIndex < endIndex; timeIndex++) {\n      const frame = data[timeIndex]\n\n      if (!frame) continue\n\n      for (let index = 0, len = frame.worldX.length; index < len; index++) {\n        let hue\n        if (filters === undefined || !filters.length) {\n          hue = defaultHue\n        }\n        for (let fi = 0; fi < numFilters; fi++) {\n          const filter = filters[fi]\n          if (vesselSatisfiesFilters(frame, index, filter.filterValues)) {\n            hue = filter.hue\n            break\n          }\n        }\n\n        // no filter passes: bail\n        if (hue === undefined) {\n          continue\n        }\n\n        // wrap worldX when point crosses the antimeridian/dateline\n        // world points go from 0 to 512. There is no way to determine if worldX is on the \"wrong\" side\n        // of the antimeridian just by looking at its value (where with lat/lon we can simply look at -/+)\n        // Therefore we compare it to the viewport's left or right boundary, depending on what is currently\n        // \"the right side\" of the antimeridian\n        let worldX = frame.worldX[index]\n        if (viewportLeft > 0 && worldX < viewportLeft) {\n          // worldX is \"behind\" viewportLeft, which means it is \"on the right\" of the antimeridian\n          worldX += 512\n        } else if (viewportLeft < 0 && worldX > viewportRight) {\n          worldX -= 512\n        }\n\n        const scaledX = worldX * viewport.scale\n        const scaledY = frame.worldY[index] * viewport.scale\n        const mtx = viewport.pixelProjectionMatrix\n\n        const [x, y] =\n          viewport.pitch === 0\n            ? worldToPixelsSimple(scaledX, scaledY, mtx)\n            : worldToPixels([scaledX, scaledY], mtx)\n\n        if (x > -10 && x < viewport.width + 10 && y > -10 && y < viewport.height + 10) {\n          this.subLayers[hue].pushSpriteProps(\n            x,\n            y,\n            frame.opacity ? frame.opacity[index] : this.renderingStyle.defaultOpacity,\n            frame.radius ? frame.radius[index] : this.renderingStyle.defaultSize\n          )\n        }\n      }\n    }\n  }\n\n  _createSublayer(baseTexture, renderingStyleIndex, hue) {\n    const subLayer = new HeatmapSubLayer(\n      baseTexture,\n      renderingStyleIndex,\n      hue,\n      this.brushRenderingStyle === BRUSH_RENDERING_STYLE.BULLSEYE\n    )\n    this.stage.addChild(subLayer.stage)\n    return subLayer\n  }\n\n  _destroy() {\n    Object.values(this.subLayers).forEach(this._destroySubLayer.bind(this))\n    this.stage.destroy({ children: true })\n    const { rootStage } = this.props\n    rootStage.removeChild(this.stage)\n  }\n\n  _destroySubLayer(subLayer) {\n    this.stage.removeChild(subLayer.stage)\n    subLayer.destroy()\n  }\n\n  render() {\n    return null\n  }\n}\n\nHeatmapLayer.propTypes = {\n  layer: PropTypes.object,\n  rootStage: PropTypes.object,\n  viewport: PropTypes.object,\n  startIndex: PropTypes.number,\n  endIndex: PropTypes.number,\n  filters: PropTypes.array,\n  baseTexture: PropTypes.object,\n  useRadialGradientStyle: PropTypes.bool,\n  customRenderingStyle: PropTypes.object,\n  viewportLeft: PropTypes.number,\n  viewportRight: PropTypes.number,\n}\n\nexport default HeatmapLayer\n","import React, { Fragment } from 'react'\nimport * as PIXI from 'pixi.js'\nimport PropTypes from 'prop-types'\nimport { BaseControl } from 'react-map-gl'\nimport { lngLatToWorld } from 'viewport-mercator-project'\nimport {\n  hsvToRgb,\n  hueToRgbString,\n  hueIncrementToHue,\n  wrapHue,\n  VESSELS_HUES_INCREMENTS_NUM,\n} from '../utils/map-colors'\nimport {\n  VESSELS_BASE_RADIUS,\n  VESSELS_HEATMAP_BLUR_FACTOR,\n  ACTIVITY_HIGHLIGHT_HUE,\n  VESSELS_HEATMAP_DIMMING_ALPHA,\n  VESSELS_RADIAL_GRADIENT_STYLE_ZOOM_THRESHOLD,\n  VESSEL_CLICK_TOLERANCE_PX,\n} from '../config'\nimport HeatmapLayer from '../heatmap/HeatmapLayer'\n\nconst shouldUseRadialGradientStyle = (zoom) => zoom < VESSELS_RADIAL_GRADIENT_STYLE_ZOOM_THRESHOLD\n\n// builds a texture spritesheet containing\n// - the heatmap style (radial gradient)\n// - the circle style that is used at higher zoom levels\n// - the 'bullseye' style used for encounters\n// as well as a number of hues for each in a 2D grid.\n// Then, only the texture frame (mesh UVs) is modified depending on the zoom level,\n// in order not to have to recreate sprites\nconst getVesselTexture = (radius, blurFactor) => {\n  const tplCanvas = document.createElement('canvas')\n  const tplCtx = tplCanvas.getContext('2d')\n  const diameter = radius * 2\n  const NUM_STYLES = 3\n  tplCanvas.width = diameter * NUM_STYLES + (NUM_STYLES - 1) // + (NUM_STYLES - 1): tiny offset between 2 frames\n  tplCanvas.height = diameter * VESSELS_HUES_INCREMENTS_NUM + VESSELS_HUES_INCREMENTS_NUM\n\n  for (let hueIncrement = 0; hueIncrement < VESSELS_HUES_INCREMENTS_NUM; hueIncrement++) {\n    const y = diameter * hueIncrement + hueIncrement\n    const yCenter = y + radius\n\n    // heatmap style\n    let x = radius\n    const gradient = tplCtx.createRadialGradient(\n      x,\n      yCenter,\n      radius * blurFactor,\n      x,\n      yCenter,\n      radius\n    )\n    const hue = hueIncrementToHue(hueIncrement)\n    const rgbString = hueToRgbString(hue)\n    gradient.addColorStop(0, rgbString)\n\n    const rgbOuter = hsvToRgb(wrapHue(hue + 30), 80, 100)\n    gradient.addColorStop(1, `rgba(${rgbOuter.r}, ${rgbOuter.g}, ${rgbOuter.b}, 0)`)\n\n    tplCtx.fillStyle = gradient\n    tplCtx.fillRect(0, y, diameter, diameter)\n\n    // circle style\n    x += diameter + 1 // tiny offset between 2 frames\n    tplCtx.beginPath()\n    tplCtx.arc(x, yCenter, radius, 0, 2 * Math.PI, false)\n    tplCtx.fillStyle = rgbString\n    tplCtx.fill()\n\n    // bullseye style\n    x += diameter + 1\n    tplCtx.beginPath()\n    tplCtx.arc(x, yCenter, radius * 0.4, 0, 2 * Math.PI, false)\n    tplCtx.fillStyle = rgbString\n    tplCtx.fill()\n    tplCtx.beginPath()\n    tplCtx.arc(x, yCenter, radius * 0.95, 0, 2 * Math.PI, false)\n    tplCtx.lineWidth = 1\n    tplCtx.strokeStyle = rgbString\n    tplCtx.stroke()\n  }\n\n  return tplCanvas\n}\n\nclass ActivityLayers extends BaseControl {\n  state = {\n    pixiReady: false,\n  }\n\n  componentDidMount() {\n    this._build()\n    this.setState({\n      pixiReady: true,\n    })\n  }\n\n  componentWillUnmount() {\n    this._destroy()\n  }\n\n  componentWillReceiveProps(nextProps) {\n    this.props.exportNativeViewport(this._context.viewport)\n\n    if (\n      nextProps.viewport.width !== this.props.viewport.width ||\n      nextProps.viewport.height !== this.props.viewport.height\n    ) {\n      this._updateViewportSize(nextProps.viewport.width, nextProps.viewport.height)\n    }\n  }\n\n  _build() {\n    const { width, height } = this.props.viewport\n\n    this.pixi = new PIXI.Application({\n      width,\n      height,\n      transparent: true,\n      antialias: true,\n    })\n\n    this.renderer = this.pixi.renderer\n    this.canvas = this.pixi.view\n    this.canvas.style.position = 'absolute'\n\n    this.container.appendChild(this.canvas)\n\n    this.stage = this.pixi.stage\n\n    const baseTextureCanvas = getVesselTexture(VESSELS_BASE_RADIUS, VESSELS_HEATMAP_BLUR_FACTOR)\n    this.baseTexture = PIXI.Texture.fromCanvas(baseTextureCanvas)\n\n    this.heatmapStage = new PIXI.Container()\n    this.stage.addChild(this.heatmapStage)\n\n    this.pixi.ticker.add(this._onTick)\n  }\n\n  _destroy() {\n    this.pixi.destroy()\n  }\n\n  _updateViewportSize(viewportWidth, viewportHeight) {\n    this.renderer.resize(viewportWidth, viewportHeight)\n  }\n\n  toggleHeatmapDimming(dim) {\n    if (this.heatmapStage === undefined) {\n      return\n    }\n    if (dim === true) {\n      this.heatmapFadingIn = false\n    }\n    this.heatmapStage.alpha = dim === true ? VESSELS_HEATMAP_DIMMING_ALPHA : 1\n  }\n\n  onTouchStart = (event) => {\n    if (!event.touches.length) {\n      return\n    }\n    this.queryCoords(event.touches[0].clientX, event.touches[0].clientY)\n  }\n\n  onMouseMove = (event) => {\n    this.queryCoords(event.clientX, event.clientY)\n  }\n\n  queryCoords(x, y) {\n    // bail if all heatmap layers are set to non-interactive\n    if (this.props.heatmapLayers.every((l) => l.interactive !== true)) {\n      return\n    }\n\n    const { viewport } = this._context\n    const [longitude, latitude] = viewport.unproject([x, y])\n\n    let wrappedLongitude = longitude\n    if (wrappedLongitude > 180) {\n      wrappedLongitude -= 360\n    } else if (wrappedLongitude < -180) {\n      wrappedLongitude += 360\n    }\n\n    const [worldX, worldY] = lngLatToWorld([wrappedLongitude, latitude], 1)\n\n    const toleranceRadiusInWorldUnits = VESSEL_CLICK_TOLERANCE_PX / viewport.scale\n\n    this.props.queryHeatmapVessels(\n      {\n        longitude: wrappedLongitude,\n        latitude,\n        worldX,\n        worldY,\n        toleranceRadiusInWorldUnits,\n      },\n      this.props.temporalExtentIndexes\n    )\n  }\n\n  _onTick = () => {\n    if (this.heatmapFadingIn === true && this.heatmapStage.alpha < 1) {\n      this._heatmapFadeinStep()\n    }\n  }\n\n  _startHeatmapFadein() {\n    this.heatmapFadingIn = true\n    this.heatmapFadeinStartTimestamp = undefined\n  }\n\n  _heatmapFadeinStep() {\n    if (this.heatmapFadeinStartTimestamp === undefined) {\n      this.heatmapFadeinStartTimestamp = Date.now()\n    }\n    const timeElapsed = (Date.now() - this.heatmapFadeinStartTimestamp) / 1000\n    let alpha = this.heatmapStage.alpha + (1 - this.heatmapStage.alpha) * timeElapsed\n    if (alpha >= 1) {\n      alpha = 1\n      this.heatmapFadingIn = false\n    }\n    this.heatmapStage.alpha = alpha\n  }\n\n  // FIXME move to container?\n  _getHighlightData(highlightedVessels, highlightedClickedVessel, heatmapLayers) {\n    const hue = ACTIVITY_HIGHLIGHT_HUE\n    let highlightLayerData = {\n      id: '__HIGHLIGHT__',\n      visible: true,\n      opacity: 1,\n      hue: ACTIVITY_HIGHLIGHT_HUE,\n    }\n    let highlightFilters = []\n\n    if (\n      highlightedVessels !== undefined &&\n      highlightedVessels.layer !== undefined &&\n      highlightedVessels.foundVessels !== undefined &&\n      highlightedVessels.isEmpty !== true\n    ) {\n      const sourceLayer = heatmapLayers.find((l) => l.id === highlightedVessels.layer.id)\n      highlightLayerData = { highlightLayerData, ...sourceLayer }\n      highlightFilters = highlightedVessels.foundVessels.map((vessel) => ({\n        hue,\n        filterValues: {\n          series: [vessel.series],\n        },\n      }))\n    } else if (highlightedClickedVessel !== null) {\n      const sourceLayer = heatmapLayers.find((l) => l.id === highlightedClickedVessel.layer.id)\n      highlightLayerData = { highlightLayerData, ...sourceLayer }\n      highlightFilters = [\n        {\n          hue,\n          filterValues: {\n            series: [highlightedClickedVessel.id],\n          },\n        },\n      ]\n    }\n    return {\n      highlightLayerData,\n      highlightFilters,\n    }\n  }\n  _render() {\n    const {\n      zoom,\n      heatmapLayers,\n      temporalExtentIndexes,\n      highlightedVessels,\n      highlightedClickedVessel,\n      leftWorldScaled,\n      rightWorldScaled,\n    } = this.props\n    const { viewport } = this._context\n    const { pixiReady } = this.state\n\n    const startIndex = temporalExtentIndexes[0]\n    const endIndex = temporalExtentIndexes[1]\n    const useRadialGradientStyle = shouldUseRadialGradientStyle(zoom)\n\n    if (highlightedVessels.isEmpty !== true) {\n      this.toggleHeatmapDimming(true)\n    }\n    if (highlightedVessels.isEmpty === true) {\n      this._startHeatmapFadein()\n    }\n    if (this.renderer && this.renderer.gl && this.renderer.gl.getError !== undefined) {\n      const err = this.renderer.gl.getError()\n      if (err !== 0) console.log(err)\n    }\n\n    const { highlightLayerData, highlightFilters } = this._getHighlightData(\n      highlightedVessels,\n      highlightedClickedVessel,\n      heatmapLayers\n    )\n\n    return (\n      <div\n        ref={(ref) => {\n          this.container = ref\n        }}\n        style={{ position: 'absolute' }}\n        onMouseMove={this.onMouseMove}\n        onTouchStart={this.onTouchStart}\n      >\n        {pixiReady === true && (\n          <Fragment>\n            {heatmapLayers.map((layer) => (\n              <HeatmapLayer\n                key={layer.id}\n                layer={layer}\n                filters={layer.filters || []}\n                viewport={viewport}\n                startIndex={startIndex}\n                endIndex={endIndex}\n                baseTexture={this.baseTexture}\n                rootStage={this.heatmapStage}\n                useRadialGradientStyle={useRadialGradientStyle}\n                customRenderingStyle={{}}\n                viewportLeft={leftWorldScaled}\n                viewportRight={rightWorldScaled}\n              />\n            ))}\n            {this.stage !== undefined && (\n              <HeatmapLayer\n                key=\"highlighted\"\n                layer={highlightLayerData}\n                filters={highlightFilters}\n                viewport={viewport}\n                startIndex={startIndex}\n                endIndex={endIndex}\n                baseTexture={this.baseTexture}\n                rootStage={this.heatmapStage}\n                useRadialGradientStyle={useRadialGradientStyle}\n                customRenderingStyle={{ defaultOpacity: 1, defaultSize: 1 }}\n                viewportLeft={leftWorldScaled}\n                viewportRight={rightWorldScaled}\n              />\n            )}\n          </Fragment>\n        )}\n      </div>\n    )\n  }\n}\n\nActivityLayers.propTypes = {\n  zoom: PropTypes.number,\n  heatmapLayers: PropTypes.array,\n  temporalExtentIndexes: PropTypes.array,\n  highlightedVessels: PropTypes.object,\n  highlightedClickedVessel: PropTypes.object,\n  queryHeatmapVessels: PropTypes.func,\n  exportNativeViewport: PropTypes.func,\n  leftWorldScaled: PropTypes.number,\n  rightWorldScaled: PropTypes.number,\n}\n\nActivityLayers.contextTypes = {\n  viewport: PropTypes.object,\n}\n\nexport default ActivityLayers\n","import { connect } from 'react-redux'\nimport { createSelector } from 'reselect'\nimport convert from '@globalfishingwatch/map-convert'\nimport { exportNativeViewport } from '../glmap/viewport.actions'\nimport { getTemporalExtent } from '../module/module.selectors'\nimport ActivityLayers from './ActivityLayers'\nimport { queryHeatmapVessels } from '../heatmap/heatmapTiles.actions'\nimport { MIN_FRAME_LENGTH_MS } from '../config'\n\nconst getHeatmapLayers = (state) => state.map.heatmap.heatmapLayers\n\nconst getHeatmapLayersAsArray = createSelector(\n  [getHeatmapLayers],\n  (heatmapLayers) => {\n    const a = Object.keys(heatmapLayers).map((id) => ({\n      ...heatmapLayers[id],\n    }))\n    // console.log(a)\n    return a\n  }\n)\n\nconst getTemporalExtentIndexes = createSelector(\n  [getTemporalExtent],\n  (temporalExtent) => {\n    const startTimestamp = temporalExtent[0].getTime()\n    const endTimestamp = Math.max(\n      temporalExtent[1].getTime(),\n      temporalExtent[0].getTime() + MIN_FRAME_LENGTH_MS\n    )\n    const startIndex = convert.getOffsetedTimeAtPrecision(startTimestamp)\n    const endIndex = convert.getOffsetedTimeAtPrecision(endTimestamp)\n    return [startIndex, endIndex]\n  }\n)\n\nconst mapStateToProps = (state) => ({\n  highlightedVessels: state.map.heatmap.highlightedVessels,\n  highlightedClickedVessel: state.map.heatmap.highlightedClickedVessel,\n  viewport: state.map.viewport.viewport,\n  zoom: state.map.viewport.viewport.zoom,\n  heatmapLayers: getHeatmapLayersAsArray(state),\n  leftWorldScaled: state.map.viewport.leftWorldScaled,\n  rightWorldScaled: state.map.viewport.rightWorldScaled,\n  temporalExtentIndexes: getTemporalExtentIndexes(state),\n})\n\nconst mapDispatchToProps = (dispatch, ownProps) => ({\n  queryHeatmapVessels: (coords, temporalExtentIndexes) => {\n    dispatch(queryHeatmapVessels(coords, temporalExtentIndexes))\n  },\n  exportNativeViewport: (viewport) => {\n    dispatch(exportNativeViewport(viewport))\n  },\n})\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(ActivityLayers)\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport MapGL, { Popup, Marker } from 'react-map-gl'\nimport 'mapbox-gl/dist/mapbox-gl.css'\nimport { TILES_URL_NEEDING_AUTHENTICATION } from '../config'\nimport ActivityLayers from '../activity/ActivityLayers.container.js'\nimport styles from './map.css'\n\nconst PopupWrapper = (props) => {\n  const { latitude, longitude, children, closeButton, onClose } = props\n  return (\n    <Popup\n      latitude={latitude}\n      longitude={longitude}\n      closeButton={closeButton}\n      onClose={onClose}\n      anchor=\"bottom\"\n      offsetTop={-10}\n      tipSize={4}\n      closeOnClick={false}\n    >\n      {children}\n    </Popup>\n  )\n}\n\nPopupWrapper.propTypes = {\n  latitude: PropTypes.number.isRequired,\n  longitude: PropTypes.number.isRequired,\n  children: PropTypes.node.isRequired,\n  closeButton: PropTypes.bool.isRequired,\n  onClose: PropTypes.func,\n}\n\nPopupWrapper.defaultProps = {\n  onClose: () => {},\n}\n\nclass Map extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      mouseOver: true,\n    }\n    this._mapContainerRef = null\n  }\n\n  componentDidMount() {\n    if (this._mapContainerRef !== null) {\n      this.loadObserver()\n    }\n    this.setBounds()\n  }\n\n  componentDidUpdate() {\n    this.setBounds()\n  }\n\n  onLoad = () => {\n    if (this.props.onLoad !== undefined) {\n      this.props.onLoad(this.getBounds())\n    }\n  }\n\n  setBounds = () => {\n    const bounds = this.getBounds()\n    if (bounds !== null && this.props.setBounds !== undefined) {\n      this.props.setBounds(bounds)\n    }\n  }\n\n  getBounds = () => {\n    if (!this.glMap) return null\n\n    const { _ne, _sw } = this.glMap.getBounds()\n    return {\n      north: _ne.lat,\n      south: _sw.lat,\n      west: _sw.lng,\n      east: _ne.lng,\n    }\n  }\n\n  componentWillUnmount() {\n    if (this._containerResizeObserver) {\n      this._containerResizeObserver.disconnect()\n    }\n  }\n\n  loadObserver = async () => {\n    if ('ResizeObserver' in window === false) {\n      const module = await import('resize-observer-polyfill')\n      window.ResizeObserver = module.ResizeObserver || module.default\n    }\n    this._containerResizeObserver = new ResizeObserver(this.handleResizeObserver)\n    this._containerResizeObserver.observe(this._mapContainerRef)\n  }\n\n  handleResizeObserver = (entries) => {\n    const { width, height } = entries[0].contentRect\n    const { viewport, setViewport } = this.props\n\n    if (width !== viewport.width || height !== viewport.height) {\n      setViewport({\n        ...viewport,\n        width,\n        height,\n      })\n    }\n  }\n\n  onViewportChange = (viewport, interactionState) => {\n    const propsViewport = this.props.viewport\n    if (\n      propsViewport.latitude !== viewport.latitude ||\n      propsViewport.longitude !== viewport.longitude ||\n      propsViewport.zoom !== viewport.zoom ||\n      propsViewport.bearing !== viewport.bearing ||\n      propsViewport.pitch !== viewport.pitch\n    ) {\n      this.props.setViewport(viewport, interactionState)\n    }\n  }\n\n  onMapInteraction = (event, type) => {\n    this.props.mapInteraction(\n      type,\n      event.lngLat[1],\n      event.lngLat[0],\n      event.features,\n      this.glGetSource\n    )\n  }\n\n  onHover = (event) => {\n    this.onMapInteraction(event, 'hover')\n  }\n\n  onClick = (event) => {\n    this.onMapInteraction(event, 'click')\n  }\n\n  getRef = (ref) => {\n    if (ref !== null) {\n      this.glMap = ref.getMap()\n      this.glGetSource = this.glMap.getSource.bind(this.glMap)\n    }\n  }\n\n  getCursor = ({ isDragging }) => {\n    const { cursor } = this.props\n    if (cursor === null) {\n      return isDragging ? 'grabbing' : 'grab'\n    }\n    return cursor\n  }\n\n  transformRequest = (url, resourceType) => {\n    const { token } = this.props\n    if (token !== null && resourceType === 'Tile' && url.match(TILES_URL_NEEDING_AUTHENTICATION)) {\n      return {\n        url: url,\n        headers: { Authorization: 'Bearer ' + token },\n      }\n    }\n  }\n\n  render() {\n    const {\n      viewport,\n      maxZoom,\n      minZoom,\n      transitionEnd,\n      mapStyle,\n      onClosePopup,\n      clickPopup,\n      hoverPopup,\n      hasHeatmapLayers,\n      markers,\n      interactiveLayerIds,\n    } = this.props\n\n    return (\n      <div\n        id=\"map\"\n        className={styles.map}\n        ref={(ref) => {\n          this._mapContainerRef = ref\n        }}\n        onMouseLeave={() => {\n          this.setState({ mouseOver: false })\n        }}\n        onMouseEnter={() => {\n          this.setState({ mouseOver: true })\n        }}\n      >\n        <MapGL\n          {...viewport}\n          ref={this.getRef}\n          transformRequest={this.transformRequest}\n          onTransitionEnd={transitionEnd}\n          onLoad={this.onLoad}\n          onHover={this.onHover}\n          onClick={this.onClick}\n          getCursor={this.getCursor}\n          mapStyle={mapStyle}\n          maxZoom={maxZoom}\n          minZoom={minZoom}\n          onViewportChange={this.onViewportChange}\n          interactiveLayerIds={interactiveLayerIds}\n          clickRadius={4}\n        >\n          {hasHeatmapLayers !== false && <ActivityLayers />}\n          {clickPopup !== undefined && clickPopup !== null && (\n            <PopupWrapper\n              latitude={clickPopup.latitude}\n              longitude={clickPopup.longitude}\n              closeButton\n              onClose={onClosePopup}\n            >\n              {clickPopup.content}\n            </PopupWrapper>\n          )}\n          {this.state.mouseOver === true && hoverPopup !== undefined && hoverPopup !== null && (\n            <PopupWrapper\n              latitude={hoverPopup.latitude}\n              longitude={hoverPopup.longitude}\n              closeButton={false}\n            >\n              {hoverPopup.content}\n            </PopupWrapper>\n          )}\n          {markers !== null &&\n            markers.length > 0 &&\n            markers.map((marker, i) => (\n              <Marker key={i} latitude={marker.latitude} longitude={marker.longitude}>\n                {marker.content}\n              </Marker>\n            ))}\n        </MapGL>\n        <div className={styles.googleLogo} />\n      </div>\n    )\n  }\n}\n\nMap.propTypes = {\n  token: PropTypes.string,\n  viewport: PropTypes.object.isRequired,\n  mapStyle: PropTypes.object.isRequired,\n  clickPopup: PropTypes.object,\n  hoverPopup: PropTypes.object,\n  maxZoom: PropTypes.number.isRequired,\n  minZoom: PropTypes.number.isRequired,\n  setViewport: PropTypes.func.isRequired,\n  setBounds: PropTypes.func,\n  mapInteraction: PropTypes.func,\n  onLoad: PropTypes.func,\n  onClosePopup: PropTypes.func,\n  transitionEnd: PropTypes.func,\n  cursor: PropTypes.string,\n  hasHeatmapLayers: PropTypes.bool.isRequired,\n  markers: PropTypes.arrayOf(\n    PropTypes.shape({\n      latitude: PropTypes.number.isRequired,\n      longitude: PropTypes.number.isRequired,\n      content: PropTypes.node,\n    })\n  ),\n  interactiveLayerIds: PropTypes.arrayOf(PropTypes.string),\n}\n\nMap.defaultProps = {\n  token: null,\n  clickPopup: null,\n  hoverPopup: null,\n  mapInteraction: () => {},\n  onLoad: () => {},\n  onClosePopup: () => {},\n  transitionEnd: () => {},\n  cursor: null,\n  markers: null,\n  interactiveLayerIds: null,\n  setBounds: undefined,\n}\n\nexport default Map\n","import { connect } from 'react-redux'\nimport { createSelector } from 'reselect'\nimport { fromJS } from 'immutable'\nimport { TRACKS_LAYER_IN_FRONT_OF_GROUP } from '../config'\nimport { closePopup } from '../module/module.actions.js'\nimport { getTracksStyles } from '../tracks/tracks.selectors.js'\nimport { mapInteraction } from './interaction.actions.js'\nimport { setBounds, setViewport, transitionEnd } from './viewport.actions.js'\nimport Map from './Map'\n\nconst getStaticLayers = (state) => state.map.style.staticLayers\nconst getHeatmapLayers = (state) => state.map.heatmap.heatmapLayers\nconst getInternalCursor = (state) => state.map.interaction.cursor\nconst getModuleCursor = (state) => state.map.module.cursor\n\nconst hasHeatmapLayers = createSelector(\n  [getHeatmapLayers],\n  (heatmapLayers) => {\n    return Object.keys(heatmapLayers).length > 0\n  }\n)\nconst getInteractiveLayerIds = createSelector(\n  [getStaticLayers],\n  // Note: here we assume that layer IDs provided with module match the GL layers that should\n  // be interactive or not, ie typically the fill layer if a label layer is present\n  (staticLayers) => {\n    return staticLayers.reduce((acc, layer) => {\n      if (!layer.interactive || !layer.visible) return acc\n      // We also need to check nested layers interactivity when custom gl layers are provided\n      if (layer.gl !== undefined) {\n        layer.gl.layers.forEach((glLayer, index) => {\n          // layers.length === 1 is used to ensure when parent layer is marked as interactive we have to\n          // have at least one interactive sublayer, then checked eah one individually\n          if (\n            layer.gl.layers.length === 1 ||\n            (glLayer.metadata !== undefined && glLayer.metadata['gfw:interactive'] === true)\n          ) {\n            const glLayerId = glLayer.id || index > 0 ? `${layer.id}-${index}` : layer.id\n            acc.push(glLayerId)\n          }\n        })\n      } else {\n        acc.push(layer.id)\n      }\n      return acc\n    }, [])\n  }\n)\n\nconst getMapStyles = (state) => state.map.style.mapStyle\nconst getMapStyle = createSelector(\n  [getMapStyles, getTracksStyles],\n  (mapStyles, trackStyles) => {\n    if (!trackStyles) return mapStyles\n\n    const currentLayerGroups = mapStyles\n      .toJS()\n      .layers.filter((l) => l.metadata !== undefined)\n      .map((l) => l.metadata['mapbox:group'])\n    const trackLayersIndex = currentLayerGroups.lastIndexOf(TRACKS_LAYER_IN_FRONT_OF_GROUP) + 1\n\n    let finalMapStyles = mapStyles.mergeIn(['sources'], trackStyles.sources)\n    let mapStylesLayers = mapStyles.get('layers')\n    trackStyles.layers.forEach((trackLayer, i) => {\n      mapStylesLayers = mapStylesLayers.insert(trackLayersIndex + i, fromJS(trackLayer))\n    })\n    finalMapStyles = finalMapStyles.set('layers', mapStylesLayers)\n    return finalMapStyles\n  }\n)\n\nconst getCursor = createSelector(\n  [getInternalCursor, getModuleCursor],\n  (internalCursor, moduleCursor) => {\n    if (moduleCursor !== null) {\n      return moduleCursor\n    }\n    return internalCursor\n  }\n)\nconst mapStateToProps = (state) => ({\n  viewport: state.map.viewport.viewport,\n  maxZoom: state.map.viewport.maxZoom,\n  minZoom: state.map.viewport.minZoom,\n  onLoad: state.map.module.onLoad,\n  cursor: getCursor(state),\n  token: state.map.module.token,\n  mapStyle: getMapStyle(state),\n  hasHeatmapLayers: hasHeatmapLayers(state),\n  interactiveLayerIds: getInteractiveLayerIds(state),\n})\n\nconst mapDispatchToProps = (dispatch) => ({\n  setViewport: (viewport, interactionState) => {\n    dispatch(setViewport(viewport, interactionState))\n  },\n  setBounds: (bounds) => {\n    dispatch(setBounds(bounds))\n  },\n  mapInteraction: (type, lat, long, features, cluster, glGetSource) => {\n    dispatch(mapInteraction(type, lat, long, features, cluster, glGetSource))\n  },\n  transitionEnd: () => {\n    dispatch(transitionEnd())\n  },\n  onClosePopup: () => {\n    dispatch(closePopup())\n  },\n})\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(Map)\n","import { fromJS } from 'immutable'\nimport uniq from 'lodash/uniq'\nimport GL_STYLE from './gl-styles/style.json'\nimport {\n  SET_MAP_STYLE,\n  MARK_CARTO_LAYERS_AS_INSTANCIATED,\n  INIT_MAP_STYLE,\n  SET_STATIC_LAYERS,\n  SET_BASEMAP_LAYERS,\n} from './style.actions'\n\nconst attributions = uniq(\n  Object.keys(GL_STYLE.sources)\n    .map((sourceKey) => GL_STYLE.sources[sourceKey].attribution)\n    .filter((source) => source !== undefined)\n)\n\nexport const setLayerStyleDefaults = (layer) => {\n  if (layer.layout === undefined) {\n    layer.layout = {}\n  }\n  if (layer.paint === undefined) {\n    layer.paint = {}\n  }\n  if (layer.metadata === undefined) {\n    layer.metadata = {}\n  }\n  // initialize time filter for time-filterable layers\n  if (layer.metadata['gfw:temporal'] === true) {\n    const temporalField =\n      layer.metadata['gfw:temporalField'] === undefined\n        ? 'timestamp'\n        : layer.metadata['gfw:temporalField']\n    layer.filter = ['all', ['>', temporalField, 0], ['<', temporalField, 999999999999]]\n  }\n\n  if (layer.metadata['mapbox:group'] === undefined) {\n    layer.metadata['mapbox:group'] = 'temporal'\n  }\n\n  // set all layers to not visible except layers explicitely marked as visible (default basemap)\n  if (layer.layout.visibility !== 'visible') {\n    layer.layout.visibility = 'none'\n  }\n  return layer\n}\n\nconst setStyleDefaults = (style) => {\n  style.layers.forEach((layer) => {\n    setLayerStyleDefaults(layer)\n  })\n  return style\n}\n\nconst initialState = {\n  mapStyle: fromJS(setStyleDefaults(GL_STYLE)),\n  cartoLayersInstanciated: [],\n  staticLayers: [],\n  basemapLayers: [],\n  attributions,\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case INIT_MAP_STYLE: {\n      const newMapStyle = state.mapStyle.setIn(['glyphs'], action.payload.glyphsPath)\n      return { ...state, mapStyle: newMapStyle }\n    }\n    case SET_MAP_STYLE: {\n      return { ...state, mapStyle: action.payload }\n    }\n    case SET_STATIC_LAYERS: {\n      return { ...state, staticLayers: action.payload }\n    }\n    case SET_BASEMAP_LAYERS: {\n      return { ...state, basemapLayers: action.payload }\n    }\n    case MARK_CARTO_LAYERS_AS_INSTANCIATED: {\n      const cartoLayersInstanciated = [...state.cartoLayersInstanciated, ...action.payload]\n      return { ...state, cartoLayersInstanciated }\n    }\n    default:\n      return state\n  }\n}\n","// This utility looks at GeoJSON features and returns the predominant geometry type\n\nconst TYPES = [\n  { gl: 'line', geoJSON: ['LineString', 'MultiLineString'] },\n  { gl: 'fill', geoJSON: ['Polygon', 'MultiPolygon'] },\n  { gl: 'circle', geoJSON: ['Point', 'MultiPoint'] },\n]\n\nexport default (geoJSON) => {\n  // collect all geoJSON geom types\n  const allGeoJSONTypes = geoJSON.features.map((feature) => {\n    const geom = feature.geometry\n    if (geom === undefined) {\n      return null\n    }\n    return geom.type\n  })\n\n  // collect number of geometries by GL geom types\n  const numByGLType = TYPES.map((type) => {\n    let num = 0\n    allGeoJSONTypes.forEach((geoJSONType) => {\n      if (type.geoJSON.indexOf(geoJSONType) > -1) {\n        num++\n      }\n    })\n    return { gl: type.gl, num }\n  })\n\n  // get feature types with the higher count\n  let glType = 'fill'\n  let glTypeMax = 0\n  numByGLType.forEach((t) => {\n    if (t.num > glTypeMax) {\n      glType = t.gl\n      glTypeMax = t.num\n    }\n  })\n\n  return glType\n}\n","import { fromJS } from 'immutable'\nimport convert from '@globalfishingwatch/map-convert'\nimport uniq from 'lodash/uniq'\nimport throttle from 'lodash/throttle'\nimport { hexToRgb } from '../utils/map-colors'\nimport { STATIC_LAYERS_CARTO_ENDPOINT, STATIC_LAYERS_CARTO_TILES_ENDPOINT } from '../config'\nimport { CUSTOM_LAYERS_SUBTYPES, GL_TRANSPARENT } from '../constants'\nimport GL_STYLE from './gl-styles/style.json'\nimport { setLayerStyleDefaults } from './style.reducer.js'\nimport getMainGeomType from '../utils/getMainGeomType'\n\nexport const INIT_MAP_STYLE = 'INIT_MAP_STYLE'\nexport const SET_MAP_STYLE = 'SET_MAP_STYLE'\nexport const MARK_CARTO_LAYERS_AS_INSTANCIATED = 'MARK_CARTO_LAYERS_AS_INSTANCIATED'\nexport const SET_STATIC_LAYERS = 'SET_STATIC_LAYERS'\nexport const SET_BASEMAP_LAYERS = 'SET_BASEMAP_LAYERS'\n\nconst setDefaultVectorTiles = (currentSource, refLayerUrl) => {\n  if (currentSource.type !== 'vector') {\n    return currentSource\n  }\n  const tiles = currentSource.tiles\n  const refLayerUrls = refLayerUrl === undefined ? [] : [refLayerUrl]\n\n  const newTiles =\n    tiles !== undefined && tiles.length > 0 ? uniq([...refLayerUrls, ...tiles]) : refLayerUrls\n  return {\n    ...currentSource,\n    tiles: newTiles,\n  }\n}\n\nexport const initStyle = ({ glyphsPath }) => ({\n  type: INIT_MAP_STYLE,\n  payload: {\n    glyphsPath,\n  },\n})\n\nconst setMapStyle = (style) => ({\n  type: SET_MAP_STYLE,\n  payload: style,\n})\n\nconst setStyleTemporalExtent = (dispatch, getState, temporalExtent, applyToThrottled = false) => {\n  const state = getState().map.style\n  let style = state.mapStyle\n  const currentStyle = style.toJS()\n  const glLayers = currentStyle.layers\n\n  let start = Math.round(temporalExtent[0].getTime() / 1000)\n  let end = Math.round(temporalExtent[1].getTime() / 1000)\n\n  // TEMPORARY, remove later - temporal layers points should have a timestamp, this is legacy\n  // logic for legacy encounters layer that only have a 'timeIndex'\n  const startIndex = convert.getOffsetedTimeAtPrecision(temporalExtent[0].getTime())\n  const endIndex = convert.getOffsetedTimeAtPrecision(temporalExtent[1].getTime())\n\n  for (let i = 0; i < glLayers.length; i++) {\n    const glLayer = glLayers[i]\n    if (glLayer.metadata === undefined || glLayer.metadata['gfw:temporal'] !== true) {\n      continue\n    }\n\n    if (\n      (applyToThrottled === true && glLayer.metadata['gfw:temporal:throttled'] !== true) ||\n      (applyToThrottled === false && glLayer.metadata['gfw:temporal:throttled'] === true)\n    ) {\n      continue\n    }\n\n    // if layer is temporal, a filter must always be preset on the style.json object\n    // because each layer can have a different time field to be filtered\n    const currentFilter = style.getIn(['layers', i, 'filter']).toJS()\n    if (currentFilter === null) {\n      throw new Error('filter must be preset on style.json for temporal layer: ', glLayer.id)\n    }\n\n    // TEMPORARY, remove later - temporal layers points should have a timestamp, this is legacy\n    // logic for legacy encounters layer that only have a 'timeIndex'\n    const isLegacy = glLayer.metadata && glLayer.metadata['gfw:temporalField'] === 'timeIndex'\n    currentFilter[1][2] = isLegacy ? startIndex : start\n    currentFilter[2][2] = isLegacy ? endIndex : end\n    style = style.setIn(['layers', i, 'filter'], fromJS(currentFilter))\n  }\n  dispatch(setMapStyle(style))\n}\n\nconst applyTemporalExtentThrottled = throttle((dispatch, getState, temporalExtent) => {\n  setStyleTemporalExtent(dispatch, getState, temporalExtent, true)\n}, 400)\n\nexport const applyTemporalExtent = (temporalExtent) => (dispatch, getState) => {\n  setStyleTemporalExtent(dispatch, getState, temporalExtent)\n  applyTemporalExtentThrottled(dispatch, getState, temporalExtent)\n}\n\nconst applyLayerExpressions = (style, refLayer, currentGlLayer, glLayerIndex) => {\n  let newStyle = style\n  const currentStyle = style.toJS()\n  const glType = currentGlLayer.type\n  const defaultStyles = currentStyle.metadata['gfw:styles']\n  const metadata = currentGlLayer.metadata\n  ;['selected', 'highlighted'].forEach((styleType) => {\n    // get selectedFeatures or highlightedFeatures\n    const features = refLayer[`${styleType}Features`]\n    const refLayerStyle = features && features.style ? features.style[glType] : {}\n    const hasFeatures = features !== null && features !== undefined && features.values.length > 0\n    const applyStyleToAllFeatures = refLayer[styleType]\n\n    const defaultStyle = defaultStyles[styleType][glType] || {}\n    const layerStyle =\n      (metadata && metadata['gfw:styles'] && metadata['gfw:styles'][styleType]) || {}\n    const allPaintProperties = { ...defaultStyle, ...layerStyle, ...refLayerStyle }\n\n    if (Object.keys(allPaintProperties).length) {\n      // go through each applicable gl paint property\n      Object.keys(allPaintProperties).forEach((glPaintProperty) => {\n        const selectedValue = allPaintProperties[glPaintProperty][0]\n        const fallbackValue = allPaintProperties[glPaintProperty][1]\n        const paintOrLayout = ['icon-size', 'icon-image'].includes(glPaintProperty)\n          ? 'layout'\n          : 'paint'\n        let glPaintFinalValue\n        if (\n          hasFeatures === false &&\n          applyStyleToAllFeatures !== true &&\n          applyStyleToAllFeatures !== false\n        ) {\n          // style reset when no features filter is declared and neither is applyAll\n          const originalLayerStyle = GL_STYLE.layers.find((l) => l.id === currentGlLayer.id)\n\n          if (originalLayerStyle !== undefined) {\n            // for reset: do not repaint with default style when layer as a custom main color property\n            if (\n              currentGlLayer.metadata &&\n              currentGlLayer.metadata['gfw:mainColorPaintProperty'] === glPaintProperty\n            ) {\n              glPaintFinalValue = null\n            } else {\n              glPaintFinalValue = originalLayerStyle[paintOrLayout][glPaintProperty]\n            }\n          } else {\n            // this will happen when no style exist in the original definition (ie custom layers)\n            // in this case set glPaintFinalValue to null and we'll just skip applying\n            // any selected/highlighted style for this layer\n            glPaintFinalValue = null\n          }\n        } else if (applyStyleToAllFeatures === true || applyStyleToAllFeatures === false) {\n          glPaintFinalValue = applyStyleToAllFeatures === true ? selectedValue : fallbackValue\n        } else {\n          let layerColorRgbString = ''\n          if (refLayer.color !== null && refLayer.color !== undefined) {\n            const layerColorRgb = hexToRgb(refLayer.color)\n            layerColorRgbString = `${layerColorRgb.r},${layerColorRgb.g},${layerColorRgb.b}`\n          }\n          glPaintFinalValue = [\n            'match',\n            ['get', features.field],\n            features.values,\n            typeof selectedValue !== 'string'\n              ? selectedValue\n              : selectedValue.replace('$REFLAYER_COLOR_RGB', layerColorRgbString),\n            typeof fallbackValue !== 'string'\n              ? fallbackValue\n              : fallbackValue.replace('$REFLAYER_COLOR_RGB', layerColorRgbString),\n          ]\n        }\n\n        if (glPaintFinalValue !== undefined && glPaintFinalValue !== null) {\n          newStyle = newStyle.setIn(\n            ['layers', glLayerIndex, paintOrLayout, glPaintProperty],\n            glPaintFinalValue\n          )\n        }\n      })\n    }\n  })\n  return newStyle\n}\n\nconst toggleLayerVisibility = (style, refLayer, glLayerIndex) => {\n  const visibility = refLayer.visible === true ? 'visible' : 'none'\n  return style.setIn(['layers', glLayerIndex, 'layout', 'visibility'], visibility)\n}\n\nconst updateGLLayer = (style, glLayerId, refLayer) => {\n  const currentStyle = style.toJS()\n  const currentStyleLayers = currentStyle.layers\n  let newStyle = style\n\n  const glLayerIndex = currentStyleLayers.findIndex((l) => l.id === glLayerId)\n  const glLayer = currentStyleLayers.find((l) => l.id === glLayerId)\n\n  // visibility\n  newStyle = toggleLayerVisibility(newStyle, refLayer, glLayerIndex)\n\n  if (refLayer.isBasemap === true) {\n    return newStyle\n  }\n\n  const refLayerOpacity = refLayer.opacity === undefined ? 1 : refLayer.opacity\n\n  // color/opacity\n  switch (glLayer.type) {\n    case 'fill': {\n      newStyle = newStyle\n        .setIn(['layers', glLayerIndex, 'paint', 'fill-opacity'], refLayerOpacity)\n        .setIn(['layers', glLayerIndex, 'paint', 'fill-outline-color'], refLayer.color)\n        .setIn(['layers', glLayerIndex, 'paint', 'fill-color'], GL_TRANSPARENT)\n      break\n    }\n    case 'line': {\n      const color = refLayer.color || (glLayer.paint && glLayer.paint['line-color'])\n      newStyle = newStyle\n        .setIn(['layers', glLayerIndex, 'paint', 'line-opacity'], refLayerOpacity)\n        .setIn(['layers', glLayerIndex, 'paint', 'line-color'], color)\n      break\n    }\n    case 'symbol': {\n      if (glLayer.metadata && glLayer.metadata['gfw:isLabel'] === true) {\n        const parentLayerIsVisible =\n          newStyle.getIn(['layers', glLayerIndex, 'layout', 'visibility']) === 'visible'\n        const labelsVisibility =\n          parentLayerIsVisible && refLayer.showLabels === true ? 'visible' : 'none'\n        newStyle = newStyle.setIn(\n          ['layers', glLayerIndex, 'layout', 'visibility'],\n          labelsVisibility\n        )\n        if (refLayer.showLabels !== true) {\n          break\n        }\n      }\n      newStyle = newStyle.setIn(['layers', glLayerIndex, 'paint', 'text-opacity'], refLayerOpacity)\n\n      if (refLayer.color !== undefined) {\n        newStyle = newStyle.setIn(['layers', glLayerIndex, 'paint', 'text-color'], refLayer.color)\n      }\n      break\n    }\n    // Event layers and custom layers with point geom types\n    case 'circle': {\n      newStyle = newStyle\n        .setIn(['layers', glLayerIndex, 'paint', 'circle-opacity'], refLayerOpacity)\n        .setIn(['layers', glLayerIndex, 'paint', 'circle-stroke-opacity'], refLayerOpacity)\n\n      if (refLayer.color !== undefined) {\n        const colorPaintProperty =\n          glLayer && glLayer.metadata && glLayer.metadata['gfw:mainColorPaintProperty']\n            ? glLayer.metadata['gfw:mainColorPaintProperty']\n            : 'circle-color'\n        newStyle = newStyle.setIn(\n          ['layers', glLayerIndex, 'paint', colorPaintProperty],\n          refLayer.color\n        )\n      }\n      break\n    }\n    case 'raster': {\n      newStyle = newStyle.setIn(\n        ['layers', glLayerIndex, 'paint', 'raster-opacity'],\n        refLayerOpacity\n      )\n      break\n    }\n    default: {\n      break\n    }\n  }\n\n  newStyle = applyLayerExpressions(newStyle, refLayer, glLayer, glLayerIndex)\n\n  return newStyle\n}\n\nconst addCustomGLLayer = (subtype, layerId, url, data) => (dispatch, getState) => {\n  const state = getState()\n  let style = state.map.style.mapStyle\n  const currentStyle = style.toJS()\n\n  // add source if it doesn't exist yet\n  if (currentStyle.sources[layerId] === undefined) {\n    const source = { type: subtype }\n    if (subtype === CUSTOM_LAYERS_SUBTYPES.geojson) {\n      source.data = data\n    } else if (subtype === CUSTOM_LAYERS_SUBTYPES.raster) {\n      source.tiles = [url]\n      source.tileSize = 256\n    }\n    style = style.setIn(['sources', layerId], fromJS(source))\n  }\n\n  if (currentStyle.layers.find((glLayer) => glLayer.id === layerId) === undefined) {\n    const glType = subtype === CUSTOM_LAYERS_SUBTYPES.geojson ? getMainGeomType(data) : subtype\n    const glLayer = fromJS({\n      id: layerId,\n      source: layerId,\n      type: glType,\n      layout: {},\n      paint: {},\n    })\n    const layerIndex =\n      subtype === CUSTOM_LAYERS_SUBTYPES.raster\n        ? // if raster, put at index of last raster layer except labels\n          currentStyle.layers.length -\n          1 -\n          currentStyle.layers\n            .filter((l) => l.id !== 'labels')\n            .reverse()\n            .findIndex((l) => l.type === 'raster')\n        : currentStyle.layers.length - 1\n    style = style.set('layers', style.get('layers').splice(layerIndex, 0, glLayer))\n  }\n\n  dispatch(setMapStyle(style))\n}\n\nconst updateWorkspaceGLLayers = (workspaceGLLayers) => (dispatch, getState) => {\n  const state = getState()\n  let style = state.map.style.mapStyle\n\n  workspaceGLLayers.forEach((workspaceGLLayer) => {\n    const { id, gl } = workspaceGLLayer\n    const finalSource = setDefaultVectorTiles(gl.source, workspaceGLLayer.url)\n    style = style.setIn(['sources', id], fromJS(finalSource))\n\n    const existingLayerIds = style\n      .get('layers')\n      .toJS()\n      .map((l) => l.id)\n    const layersToAdd = gl.layers.filter((layer, index) => {\n      const layerId = layer.id || index > 0 ? `${id}-${index}` : id\n      return !existingLayerIds.includes(layerId)\n    })\n    layersToAdd.forEach((layerToAdd, index) => {\n      // doesn't add a sufix in the first elements but it will for the following ones\n      let layerToAddId = layerToAdd.id || index > 0 ? `${id}-${index}` : id\n      const defaultGlLayer = setLayerStyleDefaults(layerToAdd)\n\n      const glLayer = {\n        ...defaultGlLayer,\n        id: layerToAddId,\n        source: id,\n      }\n\n      // set source-layer - defaults to source id\n      if (gl.source.type === 'vector') {\n        const sourceLayer =\n          layerToAdd['source-layer'] === undefined ? id : layerToAdd['source-layer']\n        glLayer['source-layer'] = sourceLayer\n      }\n\n      // find correct z-index\n      const existingLayers = style.get('layers')\n      const newLayerGroup = glLayer.metadata['mapbox:group']\n      const newLayerIndex = existingLayers.findLastIndex((l) => {\n        return newLayerGroup === l.toJS().metadata['mapbox:group']\n      })\n      style = style.set('layers', existingLayers.splice(newLayerIndex, 0, fromJS(glLayer)))\n    })\n  })\n\n  dispatch(setMapStyle(style))\n  dispatch(applyTemporalExtent(state.map.module.temporalExtent))\n}\n\nconst getCartoLayerInstanciatePromise = ({ sourceId, sourceCartoSQL }) => {\n  const mapConfig = { layers: [{ id: sourceId, options: { sql: sourceCartoSQL } }] }\n  const mapConfigURL = encodeURIComponent(JSON.stringify(mapConfig))\n  const cartoAnonymousMapUrl = STATIC_LAYERS_CARTO_ENDPOINT.replace('$MAPCONFIG', mapConfigURL)\n\n  return new Promise((resolve) => {\n    fetch(cartoAnonymousMapUrl)\n      .then((res) => {\n        if (res.status >= 400) {\n          console.warn(`loading of layer failed ${sourceId}`)\n          Promise.reject()\n          return null\n        }\n        return res.json()\n      })\n      .then((data) => {\n        resolve({\n          layergroupid: data.layergroupid,\n          sourceId,\n        })\n      })\n      .catch((err) => {\n        console.warn(err)\n      })\n  })\n}\n\nconst instanciateCartoLayers = (layers) => (dispatch, getState) => {\n  dispatch({\n    type: MARK_CARTO_LAYERS_AS_INSTANCIATED,\n    payload: layers.map((layer) => layer.sourceId),\n  })\n  const cartoLayersPromises = layers.map((layer) => getCartoLayerInstanciatePromise(layer))\n  const cartoLayersPromisesPromise = Promise.all(cartoLayersPromises.map((p) => p.catch((e) => e)))\n  cartoLayersPromisesPromise\n    .then((instanciatedCartoLayers) => {\n      let style = getState().map.style.mapStyle\n      const currentStyle = style.toJS()\n      instanciatedCartoLayers.forEach((cartoLayer) => {\n        const tilesURL = STATIC_LAYERS_CARTO_TILES_ENDPOINT.replace(\n          '$LAYERGROUPID',\n          cartoLayer.layergroupid\n        )\n\n        // replace gl source with a new source that use tiles provided by Carto anonymous maps API\n        const newSourceId = `${cartoLayer.sourceId}-instanciated`\n        style = style.setIn(\n          ['sources', newSourceId],\n          fromJS({\n            type: 'vector',\n            tiles: [tilesURL],\n          })\n        )\n\n        style = style.deleteIn(['sources', cartoLayer.sourceId])\n\n        // change source in all layers that are using it (generally polygon + labels)\n        currentStyle.layers.forEach((glLayer, glLayerIndex) => {\n          if (glLayer.source === cartoLayer.sourceId) {\n            style = style.setIn(['layers', glLayerIndex, 'source'], newSourceId)\n            style = style.setIn(['layers', glLayerIndex, 'metadata', 'gfw:id'], cartoLayer.sourceId)\n            const refLayer = layers.find((l) => l.refLayer.id === cartoLayer.sourceId).refLayer\n            style = updateGLLayer(style, glLayer.id, refLayer)\n          }\n        })\n      })\n\n      dispatch(setMapStyle(style))\n    })\n    .catch((err) => {\n      console.warn(err)\n    })\n}\n\nexport const commitStyleUpdates = (staticLayers, basemapLayers) => (dispatch, getState) => {\n  // Store a copy of static and basemap layers. This is not used directly by\n  // the Map component which only needs a prepared style object\n  dispatch({\n    type: SET_STATIC_LAYERS,\n    payload: staticLayers,\n  })\n  dispatch({\n    type: SET_BASEMAP_LAYERS,\n    payload: basemapLayers,\n  })\n\n  const layers = [...staticLayers, ...basemapLayers.map((bl) => ({ ...bl, isBasemap: true }))]\n\n  const currentGLSources = getState().map.style.mapStyle.toJS().sources\n\n  // collect layers declared in workspace but not in original gl style\n  const workspaceGLLayers = layers.filter((layer) => layer.gl !== undefined)\n\n  if (workspaceGLLayers.length) {\n    // Adds the gl layers again in case the source is a dynamic geojson source\n    dispatch(updateWorkspaceGLLayers(workspaceGLLayers))\n  }\n\n  // instanciate custom layers if needed\n  const customLayers = layers.filter(\n    (layer) => layer.isCustom === true && currentGLSources[layer.id] === undefined\n  )\n  if (customLayers.length) {\n    customLayers.forEach((layer) => {\n      dispatch(addCustomGLLayer(layer.subtype, layer.id, layer.url, layer.data))\n    })\n  }\n\n  const state = getState().map.style\n  let style = state.mapStyle\n  const currentStyle = style.toJS()\n  const glLayers = currentStyle.layers\n  const glSources = currentStyle.sources\n\n  const cartoLayersToInstanciate = []\n\n  // update source when needed\n  staticLayers.forEach((refLayer) => {\n    const sourceId = refLayer.id\n    if (currentGLSources[sourceId] !== undefined && refLayer.visible === true) {\n      if (refLayer.data !== undefined) {\n        style = style.setIn(['sources', sourceId, 'data'], fromJS(refLayer.data))\n      }\n      if (refLayer.url !== undefined) {\n        const newSource = setDefaultVectorTiles(currentGLSources[sourceId], refLayer.url)\n        style = style.setIn(['sources', sourceId], fromJS(newSource))\n      }\n    }\n  })\n\n  for (let i = 0; i < glLayers.length; i++) {\n    const glLayer = glLayers[i]\n    const sourceId = glLayer.source\n    const glSource = glSources[sourceId]\n    const layerId = (glLayer.metadata !== undefined && glLayer.metadata['gfw:id']) || sourceId\n\n    const refLayer = layers.find((l) => l.id === layerId)\n\n    if (refLayer === undefined) {\n      if (glLayer.type !== 'background') {\n        // console.warn('gl layer does not exists in workspace', glLayer);\n      }\n      continue\n    }\n\n    // check if layer is served from Carto, which means we need to instanciate it first\n    // TODO BUG: check if layer is not instanciatING too\n    const sourceCartoSQL = glSource.metadata !== undefined && glSource.metadata['gfw:carto-sql']\n    if (sourceCartoSQL !== false && sourceCartoSQL !== undefined) {\n      // only if layer is visible and has not been instanciated yet\n      const cartoLayerInstanciated = state.cartoLayersInstanciated.indexOf(sourceId) > -1\n      if (\n        refLayer.visible === true &&\n        !cartoLayerInstanciated &&\n        !cartoLayersToInstanciate.find((l) => l.sourceId === sourceId)\n      ) {\n        cartoLayersToInstanciate.push({ sourceId, sourceCartoSQL, refLayer })\n      }\n      continue\n    }\n\n    style = updateGLLayer(style, glLayer.id, refLayer)\n  }\n\n  if (cartoLayersToInstanciate.length) {\n    dispatch(instanciateCartoLayers(cartoLayersToInstanciate))\n  }\n\n  dispatch(setMapStyle(style))\n}\n","import FlyToInterpolator from 'react-map-gl/dist/esm/utils/transition/viewport-fly-to-interpolator'\nimport { easeCubic } from 'd3-ease'\nimport { MIN_ZOOM_LEVEL, MAX_ZOOM_LEVEL } from '../config'\nimport { TRANSITION_TYPE } from '../constants'\nimport {\n  SET_BOUNDS,\n  SET_VIEWPORT,\n  UPDATE_VIEWPORT,\n  SET_ZOOM_INCREMENT,\n  SET_MOUSE_LAT_LONG,\n  TRANSITION_END,\n  SET_NATIVE_VIEWPORT,\n} from './viewport.actions'\n\nexport const TRANSITION_DURATION = 500\n\nconst DEFAULT_TRANSITION = {\n  transitionDuration: TRANSITION_DURATION,\n  transitionInterpolator: new FlyToInterpolator(),\n  transitionEasing: easeCubic,\n}\n\nconst initialState = {\n  viewport: {\n    latitude: 0,\n    longitude: 0,\n    zoom: 3,\n    bearing: 0,\n    pitch: 0,\n    width: 1000,\n    height: 800,\n    bounds: {},\n  },\n  maxZoom: MAX_ZOOM_LEVEL,\n  minZoom: MIN_ZOOM_LEVEL,\n  prevZoom: 3,\n  currentTransition: null,\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case SET_VIEWPORT: {\n      return {\n        ...state,\n        viewport: action.payload,\n        canZoomIn: action.payload.zoom < state.maxZoom,\n        canZoomOut: action.payload.zoom > state.minZoom,\n        prevZoom: state.viewport.zoom,\n      }\n    }\n\n    case SET_BOUNDS: {\n      return {\n        ...state,\n        bounds: action.payload,\n      }\n    }\n\n    case UPDATE_VIEWPORT: {\n      const viewport = { ...state.viewport, ...action.payload }\n      return {\n        ...state,\n        viewport,\n        prevZoom: viewport.zoom,\n      }\n    }\n\n    case SET_ZOOM_INCREMENT: {\n      const currentZoom = state.viewport.zoom\n      const zoom = Math.min(\n        state.maxZoom,\n        action.payload.zoom || currentZoom + action.payload.increment\n      )\n      const viewport = {\n        ...state.viewport,\n        ...DEFAULT_TRANSITION,\n        zoom,\n        latitude:\n          action.payload.latitude === null ? state.viewport.latitude : action.payload.latitude,\n        longitude:\n          action.payload.longitude === null ? state.viewport.longitude : action.payload.longitude,\n      }\n      return {\n        ...state,\n        viewport,\n        canZoomIn: zoom < state.maxZoom,\n        canZoomOut: zoom > state.minZoom,\n        prevZoom: state.viewport.zoom,\n        currentTransition: TRANSITION_TYPE.ZOOM,\n      }\n    }\n\n    case SET_MOUSE_LAT_LONG: {\n      return { ...state, mouseLatLong: action.payload }\n    }\n\n    case TRANSITION_END: {\n      return { ...state, currentTransition: null }\n    }\n\n    case SET_NATIVE_VIEWPORT: {\n      return { ...state, ...action.payload }\n    }\n\n    default:\n      return state\n  }\n}\n","import { compose, createStore, applyMiddleware } from 'redux'\nimport thunk from 'redux-thunk'\n\nimport { TRANSITION_DURATION } from '../glmap/viewport.reducer'\nimport { fitToBounds as fitToBoundsAction, transitionEnd } from '../glmap/viewport.actions'\n\nlet composeEnhancers = compose\nif (\n  (process.env.MAP_REDUX_REMOTE_DEBUG || process.env.REACT_APP_MAP_REDUX_REMOTE_DEBUG) &&\n  process.env.NODE_ENV === 'development'\n) {\n  const composeWithDevTools = require('remote-redux-devtools').composeWithDevTools\n  composeEnhancers = composeWithDevTools({\n    name: 'Map module',\n    realtime: true,\n    hostname: 'localhost',\n    port: 8000,\n    maxAge: 30,\n    stateSanitizer: (state) => ({ ...state, map: { ...state.map, heatmap: 'NOT_SERIALIZED' } }),\n  })\n}\n\nconst store = createStore(() => {}, {}, composeEnhancers(applyMiddleware(thunk)))\n\nexport const targetMapVessel = (id) => {\n  const track = store.getState().map.tracks.data.find((t) => t.id === id.toString())\n  store.dispatch(fitToBoundsAction(track.geoBounds))\n\n  return track.timelineBounds\n}\nexport const fitToBounds = (bounds) => {\n  store.dispatch(fitToBoundsAction(bounds))\n  setTimeout(() => {\n    // needed as the transition end is not being called on first fitToBounds trigger\n    if (store.getState().map.viewport.currentTransition !== null) {\n      store.dispatch(transitionEnd())\n    }\n  }, TRANSITION_DURATION + 1)\n}\n\nexport default store\n","import tbbox from '@turf/bbox'\n\nexport const getTrackTimeBounds = (geojson) => {\n  const time = { start: Infinity, end: 0 }\n  if (geojson && geojson.features) {\n    geojson.features.forEach((feature) => {\n      const hasTimes =\n        feature.properties &&\n        feature.properties.coordinateProperties &&\n        feature.properties.coordinateProperties.times &&\n        feature.properties.coordinateProperties.times.length > 0\n      if (hasTimes) {\n        feature.properties.coordinateProperties.times.forEach((datetime) => {\n          if (datetime < time.start) {\n            time.start = datetime\n          } else if (datetime > time.end) {\n            time.end = datetime\n          }\n        })\n      }\n    })\n  }\n  return [time.start, time.end]\n}\n\nexport const getTrackBounds = (geojson) => {\n  const bounds = tbbox(geojson)\n  return {\n    minLat: bounds[3],\n    minLng: bounds[0],\n    maxLat: bounds[1],\n    maxLng: bounds[2],\n  }\n}\n","import cloneDeep from 'lodash/cloneDeep'\nimport { targetMapVessel } from '../store'\n\nimport { getTilePromises, getCleanVectorArrays, groupData } from '../utils/heatmapTileData'\nimport { startLoader, completeLoader } from '../module/module.actions'\nimport { getTrackBounds, getTrackTimeBounds } from '../utils/getTrackBounds'\n\nexport const ADD_TRACK = 'ADD_TRACK'\nexport const UPDATE_TRACK = 'UPDATE_TRACK'\nexport const REMOVE_TRACK = 'REMOVE_TRACK'\n\nconst convertLegacyTrackToGeoJSON = (vectorArrays) => {\n  const createFeature = (segId, type = 'track', geomType = 'LineString') => ({\n    type: 'Feature',\n    geometry: {\n      type: geomType,\n      coordinates: [],\n    },\n    properties: {\n      type,\n      segId,\n      coordinateProperties: {\n        times: [],\n      },\n    },\n  })\n\n  let currentLng\n  let currentSeries = vectorArrays.series[0]\n  let currentFeature = createFeature(currentSeries)\n  const fishingPoints = createFeature('fishing', 'fishing', 'MultiPoint')\n  const features = []\n  let lngOffset = 0\n\n  for (let index = 0, length = vectorArrays.latitude.length; index < length; index++) {\n    const series = vectorArrays.series[index]\n    const longitude = vectorArrays.longitude[index]\n    const latitude = vectorArrays.latitude[index]\n    const weight = vectorArrays.weight[index]\n\n    if (currentLng) {\n      if (longitude - currentLng < -180) {\n        lngOffset += 360\n      } else if (longitude - currentLng > 180) {\n        lngOffset -= 360\n      }\n    }\n\n    const ll = [longitude + lngOffset, latitude]\n    if (series !== currentSeries && index !== 0) {\n      features.push(cloneDeep(currentFeature))\n      currentFeature = createFeature(series)\n    }\n\n    currentFeature.geometry.coordinates.push(ll)\n    if (weight > 0) {\n      fishingPoints.geometry.coordinates.push(ll)\n      fishingPoints.properties.coordinateProperties.times.push(vectorArrays.datetime[index])\n    }\n    currentFeature.properties.coordinateProperties.times.push(vectorArrays.datetime[index])\n\n    currentSeries = series\n    currentLng = longitude\n  }\n  features.push(fishingPoints)\n\n  return {\n    type: 'FeatureCollection',\n    features,\n  }\n}\n\nfunction loadTrack(track) {\n  return (dispatch, getState) => {\n    const { id, url, type, fitBoundsOnLoad, layerTemporalExtents, color, data } = track\n    const state = getState()\n    if (state.map.tracks.data.find((t) => t.id === id)) {\n      return\n    }\n\n    const payload = {\n      id,\n      url,\n      type,\n      color,\n      fitBoundsOnLoad,\n    }\n    const trackHasData = track.data !== undefined && track.data !== null\n    const trackHasUrl = url !== undefined && url !== null && url !== ''\n    if (trackHasData) {\n      payload.data = data\n      payload.geoBounds = getTrackBounds(data)\n    }\n    dispatch({ type: ADD_TRACK, payload })\n\n    if (trackHasData || !trackHasUrl) {\n      return\n    }\n\n    const loaderID = startLoader(dispatch, state)\n    if (type !== 'geojson') {\n      // Deprecated tracks format logic to be deleted some day\n      const token = state.map.module.token\n\n      const promises = getTilePromises(url, token, layerTemporalExtents)\n\n      Promise.all(promises.map((p) => p.catch((e) => e))).then((rawTileData) => {\n        const cleanData = getCleanVectorArrays(rawTileData)\n\n        if (!cleanData.length) {\n          return\n        }\n        const rawTrackData = groupData(cleanData, [\n          'latitude',\n          'longitude',\n          'datetime',\n          'series',\n          'weight',\n          'sigma',\n        ])\n\n        const data = convertLegacyTrackToGeoJSON(rawTrackData)\n        const timelineBounds = getTrackTimeBounds(data)\n        const geoBounds = getTrackBounds(data)\n\n        dispatch({\n          type: UPDATE_TRACK,\n          payload: {\n            id,\n            data,\n            geoBounds,\n            timelineBounds,\n          },\n        })\n        dispatch(completeLoader(loaderID))\n      })\n    } else {\n      fetch(url)\n        .then((res) => {\n          if (res.status >= 400) throw new Error(res.statusText)\n          return res.json()\n        })\n        .then((data) => {\n          const timelineBounds = getTrackTimeBounds(data)\n          const geoBounds = getTrackBounds(data)\n          dispatch({\n            type: UPDATE_TRACK,\n            payload: {\n              id,\n              data,\n              geoBounds,\n              timelineBounds,\n            },\n          })\n          if (fitBoundsOnLoad) {\n            targetMapVessel(id)\n          }\n        })\n        .catch((err) => console.warn(err))\n        .finally(() => dispatch(completeLoader(loaderID)))\n    }\n  }\n}\n\nconst removeTrack = (trackId) => ({\n  type: REMOVE_TRACK,\n  payload: {\n    trackId,\n  },\n})\n\nexport const updateTracks = (newTracks = []) => (dispatch, getState) => {\n  const prevTracks = getState().map.tracks.data\n  // add and update layers\n  if (newTracks) {\n    newTracks.forEach((newTrack) => {\n      const trackId = newTrack.id\n      const prevTrack = prevTracks.find((t) => t.id === trackId)\n      if (prevTrack === undefined) {\n        dispatch(loadTrack(newTrack))\n      } else if (prevTrack.color !== newTrack.color) {\n        dispatch({\n          type: UPDATE_TRACK,\n          payload: {\n            id: newTrack.id,\n            color: newTrack.color,\n          },\n        })\n      }\n    })\n  }\n\n  // clean up unused tracks\n  prevTracks.forEach((prevTrack) => {\n    if (!newTracks || !newTracks.find((t) => t.id === prevTrack.id)) {\n      dispatch(removeTrack(prevTrack.id))\n    }\n  })\n}\n","import PropTypes from 'prop-types'\n\nconst withReducerPropTypes = (name, propTypesSchema) => (reducer) => {\n  if (process.env.NODE_ENV === 'development') {\n    return (state, action) => {\n      const result = reducer(state, action)\n      PropTypes.checkPropTypes(propTypesSchema, result, 'reducer', name)\n\n      return result\n    }\n  }\n  return reducer\n}\n\nexport default withReducerPropTypes\n","import PropTypes from 'prop-types'\nimport withReducerTypes from '../utils/withReducerTypes'\nimport {\n  INIT_MODULE,\n  SET_TEMPORAL_EXTENT,\n  SET_HIGHLIGHT_TEMPORAL_EXTENT,\n  START_LOADER,\n  COMPLETE_LOADER,\n  SET_MODULE_CURSOR,\n} from './module.actions'\n\nconst initialState = {\n  loaders: null,\n  token: undefined,\n  temporalExtent: [new Date(1970), new Date()],\n  highlightTemporalExtent: null,\n  cursor: null,\n  onViewportChange: undefined,\n  onHover: undefined,\n  onClick: undefined,\n  onLoad: undefined,\n  onLoadStart: undefined,\n  onLoadComplete: undefined,\n  onClosePopup: undefined,\n  onAttributionsChange: undefined,\n}\n\nconst moduleReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case INIT_MODULE: {\n      return {\n        ...state,\n        ...action.payload,\n      }\n    }\n\n    case SET_TEMPORAL_EXTENT: {\n      return {\n        ...state,\n        temporalExtent: action.payload,\n      }\n    }\n\n    case SET_HIGHLIGHT_TEMPORAL_EXTENT: {\n      return {\n        ...state,\n        highlightTemporalExtent: action.payload,\n      }\n    }\n\n    case START_LOADER: {\n      const loaders = state.loaders !== null ? [...state.loaders] : []\n      loaders.push(action.payload)\n      return { ...state, loaders }\n    }\n\n    case COMPLETE_LOADER: {\n      const loaders = [...state.loaders]\n      const loaderIndex = loaders.findIndex((l) => l === action.payload)\n      loaders.splice(loaderIndex, 1)\n      return { ...state, loaders }\n    }\n\n    case SET_MODULE_CURSOR: {\n      return { ...state, cursor: action.payload }\n    }\n\n    default:\n      return state\n  }\n}\n\nconst moduleTypes = {\n  loaders: PropTypes.arrayOf(PropTypes.number),\n  token: PropTypes.string,\n  temporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  onViewportChange: PropTypes.func,\n  onHover: PropTypes.func,\n  onClick: PropTypes.func,\n  onLoad: PropTypes.func,\n  onLoadStart: PropTypes.func,\n  onLoadComplete: PropTypes.func,\n  onClosePopup: PropTypes.func,\n  onAttributionsChange: PropTypes.func,\n}\n\nexport default withReducerTypes('module', moduleTypes)(moduleReducer)\n","import PropTypes from 'prop-types'\nimport { trackTypes } from '../proptypes/tracks'\nimport withReducerTypes from '../utils/withReducerTypes'\n\nimport { ADD_TRACK, UPDATE_TRACK, REMOVE_TRACK } from './tracks.actions'\n\nconst initialState = {\n  data: [],\n}\n\nconst tracksReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case ADD_TRACK: {\n      const data = [...state.data, action.payload]\n      return { ...state, data }\n    }\n\n    case UPDATE_TRACK: {\n      const trackData = action.payload\n      const data = state.data.map((track) => {\n        if (track.id !== trackData.id) return track\n        return {\n          ...track,\n          ...trackData,\n        }\n      })\n      return { ...state, data }\n    }\n\n    case REMOVE_TRACK: {\n      const removedTrackId = action.payload.trackId\n      const data = state.data.filter((track) => track.id !== removedTrackId)\n      return { ...state, data }\n    }\n\n    default:\n      return state\n  }\n}\n\nconst tracksTypes = {\n  data: PropTypes.arrayOf(\n    PropTypes.exact({\n      ...trackTypes,\n      data: PropTypes.object,\n      timelineBounds: PropTypes.array,\n      geoBounds: PropTypes.exact({\n        minLat: PropTypes.number,\n        minLng: PropTypes.number,\n        maxLat: PropTypes.number,\n        maxLng: PropTypes.number,\n      }),\n    })\n  ),\n}\n\nexport default withReducerTypes('tracks', tracksTypes)(tracksReducer)\n","import difference from 'lodash/difference'\nimport {\n  INIT_HEATMAP_LAYERS,\n  UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES,\n  ADD_HEATMAP_LAYER,\n  UPDATE_HEATMAP_LAYER_STYLE,\n  REMOVE_HEATMAP_LAYER,\n  ADD_REFERENCE_TILE,\n  UPDATE_HEATMAP_TILE,\n  RELEASE_HEATMAP_TILES,\n  HIGHLIGHT_VESSELS,\n  UPDATE_LOADED_TILES,\n  HIGHLIGHT_CLICKED_VESSEL,\n  CLEAR_HIGHLIGHT_CLICKED_VESSEL,\n} from './heatmap.actions'\n\nconst initialState = {\n  // a dict of heatmap layers (key is layer id)\n  // each containing data, url, tiles, visibleTemporalExtentsIndices\n  heatmapLayers: {},\n  // store a list of tiles currently visible in the map\n  // those are necessary when adding a new layer to know which tiles need to be loaded\n  referenceTiles: [],\n  highlightedVessels: { isEmpty: true },\n  highlightedClickedVessel: null,\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case INIT_HEATMAP_LAYERS: {\n      return Object.assign({}, state, { heatmapLayers: action.payload })\n    }\n\n    case UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES: {\n      const heatmapLayers = state.heatmapLayers\n      heatmapLayers[action.payload.layerId].visibleTemporalExtentsIndices =\n        action.payload.newVisibleTemporalExtentsIndices\n\n      // also removing indices within each tile\n      // adding is done after tile has actually loaded\n      heatmapLayers[action.payload.layerId].tiles.forEach((tile) => {\n        tile.temporalExtentsIndicesLoaded = difference(\n          tile.temporalExtentsIndicesLoaded,\n          action.payload.indicesRemoved\n        )\n      })\n      return { ...state, heatmapLayers }\n    }\n\n    case ADD_HEATMAP_LAYER: {\n      const heatmapLayers = Object.assign({}, state.heatmapLayers, {\n        [action.payload.id]: {\n          tiles: [],\n          ...action.payload,\n        },\n      })\n      return Object.assign({}, state, { heatmapLayers })\n    }\n\n    case UPDATE_HEATMAP_LAYER_STYLE: {\n      const newLayer = action.payload\n      const layer = { ...state.heatmapLayers[newLayer.id], ...newLayer }\n      const heatmapLayers = { ...state.heatmapLayers, [newLayer.id]: layer }\n      return { ...state, heatmapLayers }\n    }\n\n    case REMOVE_HEATMAP_LAYER: {\n      const heatmapLayers = Object.assign({}, state.heatmapLayers)\n      delete heatmapLayers[action.payload.id]\n      return Object.assign({}, state, { heatmapLayers })\n    }\n\n    case ADD_REFERENCE_TILE: {\n      return Object.assign({}, state, { referenceTiles: [...state.referenceTiles, action.payload] })\n    }\n\n    case UPDATE_HEATMAP_TILE: {\n      const layerId = action.payload.layerId\n      const newTile = action.payload.tile\n      const layer = { ...state.heatmapLayers[layerId] }\n      let layerTiles = [...layer.tiles]\n      const tileIndex = layerTiles.findIndex((t) => t.uid === newTile.uid)\n      if (tileIndex === -1) {\n        layerTiles.push(newTile)\n      } else {\n        layerTiles = [\n          ...layerTiles.slice(0, tileIndex),\n          newTile,\n          ...layerTiles.slice(tileIndex + 1),\n        ]\n      }\n      layer.tiles = layerTiles\n      const heatmapLayers = { ...state.heatmapLayers, [layerId]: layer }\n      return { ...state, heatmapLayers }\n    }\n\n    case RELEASE_HEATMAP_TILES: {\n      const uids = action.payload\n\n      // remove tiles\n      const layerIds = Object.keys(state.heatmapLayers)\n      const heatmapLayers = { ...state.heatmapLayers }\n      layerIds.forEach((layerId) => {\n        const prevLayer = { ...heatmapLayers[layerId] }\n        uids.forEach((tileUid) => {\n          const releasedTileIndex = prevLayer.tiles.findIndex((tile) => tile.uid === tileUid)\n          if (releasedTileIndex > -1) {\n            // console.log('releasing', layerId, tileUid);\n            prevLayer.tiles.splice(releasedTileIndex, 1)\n          }\n        })\n      })\n\n      // remove reference tiles\n      let referenceTiles = [...state.referenceTiles]\n      uids.forEach((tileUid) => {\n        const releasedRefTileIndex = referenceTiles.findIndex((tile) => tile.uid === tileUid)\n        if (releasedRefTileIndex > -1) {\n          referenceTiles = [\n            ...referenceTiles.slice(0, releasedRefTileIndex),\n            ...referenceTiles.slice(releasedRefTileIndex + 1),\n          ]\n        }\n      })\n\n      return { ...state, heatmapLayers, referenceTiles }\n    }\n\n    case UPDATE_LOADED_TILES: {\n      const newHeatmapLayers = { ...state.heatmapLayers }\n      return { ...state, heatmapLayers: newHeatmapLayers }\n    }\n\n    case HIGHLIGHT_VESSELS: {\n      return Object.assign({}, state, { highlightedVessels: action.payload })\n    }\n\n    case HIGHLIGHT_CLICKED_VESSEL: {\n      return { ...state, highlightedClickedVessel: action.payload }\n    }\n\n    case CLEAR_HIGHLIGHT_CLICKED_VESSEL: {\n      return { ...state, highlightedClickedVessel: null }\n    }\n\n    default:\n      return state\n  }\n}\n","import uniq from 'lodash/uniq'\nimport {\n  SET_CURRENTLY_VISIBLE_TILES,\n  SET_CURRENTLY_LOADED_TILES,\n  SET_CURRENTLY_SWAPPED_TILE_UIDS,\n  MARK_TILES_UIDS_AS_LOADED,\n  RELEASE_MARKED_TILES_UIDS,\n} from './heatmapTiles.actions'\n\nconst initialState = {\n  currentVisibleTiles: [],\n  currentLoadedTiles: [],\n  currentToLoadTileUids: [],\n  currentToReleaseTileUids: [],\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case SET_CURRENTLY_VISIBLE_TILES: {\n      const currentVisibleTiles = [].concat(action.payload)\n      return { ...state, currentVisibleTiles }\n    }\n\n    case SET_CURRENTLY_LOADED_TILES: {\n      const currentLoadedTiles = [].concat(action.payload)\n      return { ...state, currentLoadedTiles }\n    }\n\n    case SET_CURRENTLY_SWAPPED_TILE_UIDS: {\n      const currentToLoadTileUids = uniq(\n        state.currentToLoadTileUids.concat(action.payload.tilesToLoadUids)\n      )\n      const currentToReleaseTileUids = uniq(\n        state.currentToReleaseTileUids.concat(action.payload.tilesToReleaseUids)\n      )\n      // clean to load tiles of tiles that needs to be released\n      const newToLoadTilesUids = currentToLoadTileUids.filter(\n        (tileUid) => currentToReleaseTileUids.indexOf(tileUid) === -1\n      )\n      return { ...state, currentToLoadTileUids: newToLoadTilesUids, currentToReleaseTileUids }\n    }\n\n    case MARK_TILES_UIDS_AS_LOADED: {\n      const currentToLoadTileUids = state.currentToLoadTileUids\n      const tileUidsMarkedAsLoaded = action.payload\n      const newCurrentToLoadTileUids = currentToLoadTileUids.filter(\n        (tileUid) => tileUidsMarkedAsLoaded.indexOf(tileUid) === -1\n      )\n      return { ...state, currentToLoadTileUids: newCurrentToLoadTileUids }\n    }\n\n    case RELEASE_MARKED_TILES_UIDS: {\n      return { ...state, currentToReleaseTileUids: [] }\n    }\n\n    default:\n      return state\n  }\n}\n","// TODO MAP MODULE remove whole reducer\nimport { SET_MAP_CURSOR } from './interaction.actions'\n\nconst initialState = {\n  cursor: 'progress',\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case SET_MAP_CURSOR: {\n      return { ...state, cursor: action.payload }\n    }\n    default:\n      return state\n  }\n}\n","import { combineReducers } from 'redux'\n\nimport ModuleReducer from '../module/module.reducer'\nimport TracksReducer from '../tracks/tracks.reducer'\nimport HeatmapReducer from '../heatmap/heatmap.reducer'\nimport HeatmapTilesReducer from '../heatmap/heatmapTiles.reducer'\nimport ViewportReducer from '../glmap/viewport.reducer'\nimport StyleReducer from '../glmap/style.reducer'\nimport InteractionReducer from '../glmap/interaction.reducer'\n\nconst mapReducer = combineReducers({\n  module: ModuleReducer,\n  tracks: TracksReducer,\n  heatmap: HeatmapReducer,\n  heatmapTiles: HeatmapTilesReducer,\n  style: StyleReducer,\n  viewport: ViewportReducer,\n  interaction: InteractionReducer,\n})\n\nexport default mapReducer\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { combineReducers } from 'redux'\nimport { Provider } from 'react-redux'\nimport throttle from 'lodash/throttle'\nimport { trackTypes } from './proptypes/tracks'\nimport { heatmapLayerTypes, basemapLayerTypes, staticLayerTypes } from './proptypes/layers'\nimport { viewportTypes, popupTypes } from './proptypes/shared'\n\nimport Map from './glmap/Map.container'\nimport {\n  initModule,\n  setTemporalExtent,\n  setHighlightTemporalExtent,\n  setCursor,\n} from './module/module.actions'\nimport { updateViewport, transitionToZoom } from './glmap/viewport.actions'\nimport { initStyle, commitStyleUpdates, applyTemporalExtent } from './glmap/style.actions'\nimport { updateTracks } from './tracks/tracks.actions'\nimport { updateHeatmapLayers, updateLayerLoadTemporalExtents } from './heatmap/heatmap.actions'\n\nimport store from './store'\nimport mapReducers from './store/reducers'\n\nconst mapReducer = combineReducers({\n  map: mapReducers,\n})\n\nstore.replaceReducer(mapReducer)\n\nconst throttleApplyTemporalExtent = throttle((temporalExtent) => {\n  store.dispatch(applyTemporalExtent(temporalExtent))\n  store.dispatch(setTemporalExtent(temporalExtent))\n}, 16)\n\nconst updateViewportFromIncomingProps = (incomingViewport) => {\n  store.dispatch(\n    updateViewport({\n      latitude: incomingViewport.center[0],\n      longitude: incomingViewport.center[1],\n      zoom: incomingViewport.zoom,\n    })\n  )\n}\n\nclass MapModule extends React.Component {\n  state = {\n    initialized: false,\n    error: null,\n    errorInfo: null,\n  }\n\n  componentDidCatch(error, errorInfo) {\n    console.log(error, errorInfo)\n    this.setState({\n      error: error,\n      errorInfo: errorInfo,\n    })\n  }\n\n  componentDidMount() {\n    // First trigger synchronous actions that should happen before any map render\n    // At the end of this, set a flag to allow map rendering\n\n    if (this.props.viewport !== undefined) {\n      updateViewportFromIncomingProps(this.props.viewport)\n    }\n\n    // TODO\n    if (this.props.glyphsPath !== null) {\n      store.dispatch(\n        initStyle({\n          glyphsPath: this.props.glyphsPath,\n          // TODO apply URL updates here\n        })\n      )\n    }\n\n    if (this.props.onAttributionsChange !== undefined) {\n      this.props.onAttributionsChange(store.getState().map.style.attributions)\n    }\n\n    if (store && store.getState().map.module.token === undefined) {\n      store.dispatch(\n        initModule({\n          token: this.props.token,\n          autoClusterZoom: this.props.autoClusterZoom,\n          isCluster: this.props.isCluster,\n          onViewportChange: this.props.onViewportChange,\n          onHover: this.props.onHover,\n          onClick: this.props.onClick,\n          onLoad: this.props.onLoad,\n          onLoadStart: this.props.onLoadStart,\n          onLoadComplete: this.props.onLoadComplete,\n          onClosePopup: this.props.onClosePopup,\n          onAttributionsChange: this.props.onAttributionsChange,\n        })\n      )\n    }\n\n    if (this.props.highlightTemporalExtent !== null && this.props.highlightTemporalExtent.length) {\n      store.dispatch(setHighlightTemporalExtent(this.props.highlightTemporalExtent))\n    }\n\n    if (\n      (this.props.basemapLayers !== null && this.props.basemapLayers.length) ||\n      (this.props.staticLayers !== null && this.props.staticLayers.length)\n    ) {\n      store.dispatch(\n        commitStyleUpdates(this.props.staticLayers || [], this.props.basemapLayers || [])\n      )\n    }\n\n    if (this.props.tracks !== null) {\n      store.dispatch(updateTracks(this.props.tracks))\n    }\n\n    // Now trigger async actions\n\n    if (this.props.temporalExtent !== null && this.props.temporalExtent.length) {\n      throttleApplyTemporalExtent(this.props.temporalExtent)\n    }\n\n    // eslint-disable-next-line react/no-did-mount-set-state\n    this.setState({\n      initialized: true,\n    })\n\n    // heatmap layers\n    if (this.props.heatmapLayers !== null) {\n      store.dispatch(updateHeatmapLayers(this.props.heatmapLayers, this.props.loadTemporalExtent))\n    }\n  }\n\n  componentDidUpdate(prevProps) {\n    // tracks\n    if (this.props.tracks !== prevProps.tracks) {\n      store.dispatch(updateTracks(this.props.tracks))\n    }\n\n    // heatmap layers\n    if (this.props.heatmapLayers !== prevProps.heatmapLayers) {\n      store.dispatch(updateHeatmapLayers(this.props.heatmapLayers, this.props.loadTemporalExtent))\n    }\n\n    // basemap / static layers\n    if (\n      (this.props.basemapLayers !== null && this.props.basemapLayers.length) ||\n      (this.props.staticLayers !== null && this.props.staticLayers.length)\n    ) {\n      if (\n        this.props.basemapLayers !== prevProps.basemapLayers ||\n        this.props.staticLayers !== prevProps.staticLayers\n      ) {\n        store.dispatch(\n          commitStyleUpdates(this.props.staticLayers || [], this.props.basemapLayers || [])\n        )\n      }\n    }\n\n    // loadTemporalExtent\n    if (this.props.loadTemporalExtent !== null && this.props.loadTemporalExtent.length) {\n      if (\n        prevProps.loadTemporalExtent === null ||\n        !prevProps.loadTemporalExtent.length ||\n        this.props.loadTemporalExtent[0].getTime() !== prevProps.loadTemporalExtent[0].getTime() ||\n        this.props.loadTemporalExtent[1].getTime() !== prevProps.loadTemporalExtent[1].getTime()\n      ) {\n        store.dispatch(updateLayerLoadTemporalExtents(this.props.loadTemporalExtent))\n      }\n    }\n    // temporalExtent\n    if (this.props.temporalExtent !== null && this.props.temporalExtent.length) {\n      if (\n        prevProps.temporalExtent === null ||\n        !prevProps.temporalExtent.length ||\n        this.props.temporalExtent[0].getTime() !== prevProps.temporalExtent[0].getTime() ||\n        this.props.temporalExtent[1].getTime() !== prevProps.temporalExtent[1].getTime()\n      ) {\n        throttleApplyTemporalExtent(this.props.temporalExtent)\n      }\n    }\n\n    // highlightTemporalExtent\n    if (this.props.highlightTemporalExtent !== null && this.props.highlightTemporalExtent.length) {\n      if (\n        prevProps.highlightTemporalExtent === null ||\n        !prevProps.highlightTemporalExtent.length ||\n        this.props.highlightTemporalExtent[0].getTime() !==\n          prevProps.highlightTemporalExtent[0].getTime() ||\n        this.props.highlightTemporalExtent[1].getTime() !==\n          prevProps.highlightTemporalExtent[1].getTime()\n      ) {\n        store.dispatch(setHighlightTemporalExtent(this.props.highlightTemporalExtent))\n      }\n    } else {\n      if (this.props.highlightTemporalExtent !== prevProps.highlightTemporalExtent) {\n        store.dispatch(setHighlightTemporalExtent(this.props.highlightTemporalExtent))\n      }\n    }\n\n    // viewport - since viewport will be updated internally to the module,\n    // we have to compare incoming props to existing viewport in store, ie:\n    // update viewport from incoming props ONLY if zoom or center is different\n    // from the internally stored one\n    // TODO FFS incoming lat lon should be an object, not an array\n    const currentViewport = store.getState().map.viewport.viewport\n    // stop propagating updates from outside when zooming in\n    if (\n      this.props.viewport !== undefined &&\n      store.getState().map.viewport.currentTransition === null\n    ) {\n      if (\n        currentViewport.latitude !== this.props.viewport.center[0] ||\n        currentViewport.longitude !== this.props.viewport.center[1] ||\n        currentViewport.zoom !== this.props.viewport.zoom\n      ) {\n        // if zoom delta is precisely === 1, zoom with a transition\n        if (Math.abs(currentViewport.zoom - this.props.viewport.zoom) === 1) {\n          store.dispatch(transitionToZoom(this.props.viewport))\n        } else {\n          updateViewportFromIncomingProps(this.props.viewport)\n        }\n      }\n    }\n\n    if (this.props.cursor !== prevProps.cursor) {\n      store.dispatch(setCursor(this.props.cursor))\n    }\n  }\n  render() {\n    if (this.state.error !== null) {\n      console.log(this.state.error)\n      return (\n        <div>\n          <h2>Map component crashed!</h2>\n          <p className=\"red\">{this.state.error && this.state.error.toString()}</p>\n          <div>Component Stack Error Details:</div>\n          <p className=\"red\">{this.state.errorInfo.componentStack}</p>\n        </div>\n      )\n    }\n    // won't render anything before actions in componentDidMount have been triggered\n    return this.state.initialized !== true ? null : (\n      <Provider store={store}>\n        <Map {...this.props} />\n      </Provider>\n    )\n  }\n}\n\nMapModule.propTypes = {\n  token: PropTypes.string,\n  viewport: PropTypes.shape(viewportTypes).isRequired,\n  autoClusterZoom: PropTypes.bool,\n  isCluster: PropTypes.func,\n  tracks: PropTypes.arrayOf(PropTypes.exact(trackTypes)),\n  heatmapLayers: PropTypes.arrayOf(PropTypes.shape(heatmapLayerTypes)),\n  temporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  highlightTemporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  loadTemporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  basemapLayers: PropTypes.arrayOf(PropTypes.shape(basemapLayerTypes)),\n  staticLayers: PropTypes.arrayOf(PropTypes.shape(staticLayerTypes)),\n  cursor: PropTypes.string,\n  // customLayers\n  hoverPopup: PropTypes.shape(popupTypes),\n  clickPopup: PropTypes.shape(popupTypes),\n  glyphsPath: PropTypes.string,\n  onViewportChange: PropTypes.func,\n  onLoad: PropTypes.func,\n  onLoadStart: PropTypes.func,\n  onLoadComplete: PropTypes.func,\n  onClick: PropTypes.func,\n  onHover: PropTypes.func,\n  onAttributionsChange: PropTypes.func,\n  onClosePopup: PropTypes.func,\n}\n\nMapModule.defaultProps = {\n  token: null,\n  glyphsPath: null,\n  autoClusterZoom: true,\n  isCluster: (event) => event.isCluster === true,\n  highlightTemporalExtent: null,\n  tracks: null,\n  hoverPopup: null,\n  clickPopup: null,\n  heatmapLayers: null,\n  temporalExtent: null,\n  loadTemporalExtent: null,\n  basemapLayers: null,\n  staticLayers: null,\n  cursor: null,\n  onViewportChange: () => {},\n  onLoad: () => {},\n  onLoadStart: () => {},\n  onLoadComplete: () => {},\n  onClick: () => {},\n  onHover: () => {},\n  onAttributionsChange: () => {},\n  onClosePopup: () => {},\n}\n\nexport default MapModule\n","import GL_STYLE from '../glmap/gl-styles/style.json'\n\nconst AVAILABLE_BASEMAPS = GL_STYLE.metadata['gfw:basemap-layers']\n\nexport default AVAILABLE_BASEMAPS\n","\nimport React from 'react'\nimport { mdx } from '@mdx-js/react'\n\n/* @jsx mdx */\nimport { Playground, PropsTable } from 'docz'\nimport Map from './index.js'\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n    <h1 {...{\n      \"id\": \"map\"\n    }}>{`Map`}</h1>\n    <h2 {...{\n      \"id\": \"description\"\n    }}>{`Description`}</h2>\n    <p>{`This component displays and load fishing activity and fishing-related layers on a map, used in various GFW projects:`}</p>\n    <ul>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://github.com/GlobalFishingWatch/map-client/blob/9c5179358d4870c0fd4c2c0742917e72e6025c59/app/src/map/components/MapWrapper.jsx#L5\"\n        }}>{`Map client`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://github.com/GlobalFishingWatch/vessel-profiles/blob/aa0e17395f6a4947bb3fdf3106cb9d0a744ba64f/src/profile/components/MapWrapper.js#L3\"\n        }}>{`Vessel profiles`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://github.com/GlobalFishingWatch/data-portal/blob/96b1e24efcff58ade672a67229da0610d9d241ab/src/map/MapWrapper.jsx#L2\"\n        }}>{`Data portal`}</a></li>\n    </ul>\n    <h2 {...{\n      \"id\": \"available-properties\"\n    }}>{`Available properties`}</h2>\n    <p>{`TODO: fix crash on PropsTable docz component`}</p>\n    <h2 {...{\n      \"id\": \"basic-usage\"\n    }}>{`Basic usage`}</h2>\n    <Playground __position={0} __code={'<Map viewport={{ center: [0.026, 123.61], zoom: 5 }} />'} __scope={{\n      props: this ? this.props : props,\n      Playground,\n      PropsTable,\n      Map\n    }} __codesandbox={`N4IgZglgNgpgziAXKCA7AJjAHgOgBYAuAtlEqAMYD2qBMNSIAPOhAG4AEE6AvADogAnSpQL8AfIwD0LVmJABfADQg0mXACsEyEFRp0CDSQCojvVO3YAVPBDjsAwpUwBlAIYYARpSzs8rux4wdOyuAK4ElESuBBDkrlBQAJ7sAOZ0MALRMOjsoXBoKWYWAAZUmHDu6F5YGcU47ACSYOyJlKEA5AIw7OShAhBtdniUAO7sBH4Evq4ADjPp6IotbT3uRT14MOQA1uxtU20C7OiU5EMZMIi-BAQzcIiSkikQE6EeOFREkmXwldXfTl-nm8GTM6yay1C7Gw836dHI3XcyTgBAEoRSKVgdhGLzw4xsdgqwKwSxmsH83UytkR5lscFCMHW1FSuLe9UQAEozEZJGYIEQZpQBFMAEowVzkKZgIREdidcWS9oAbj5AqFooVBAAIgB5ACy7GlkTlXQlBAAtCciMrVYLhQ5IoLUPpDTK5ThJNhXALYDbUGYxWbdXqcF0MBkABTrZhsMTrCyMPAAZjEjjVzponDVwuy7BxEx6gKJVRBAkQUmTcfMFnYjBmYgjDSmUWSztzrnQLBi1Hi7BmQju40oqRgUxe7DDmH6qBSeZgCQ5Unr8draadLskVYT0ljijMJ16RH0ODSBAAorAjzQAEKJBroCOdYQEdpc1AcpUKZRen0wHCaMgdGoWh6EQFRsymYB2AABSgVxEhSIRQgwJZoIHOBLFcDxYHYeRXWNdoDwALz9fk7SmPVZnw2V2g9OABHISQohmSRVGwf84FIiD2EDSVqJNTV2jBVBdBRY5TiI5wCESLF2G4dhgHWKIBGeVArnaAAGdgkxmLB2j3asZg7FgZ3UgAWXT2AANl0_T1jAYCADFvWgRJ1P4ZxDgRB1MBgoR-CWIhqEoOAjIROzqwcmhnAgIjLnYABGMyDPkYTRKmABBOY5PYCMoPIGwoHQMNcI5OSxFy6MZHYFEZJgbhgGIqS6rgeQtxrYACugYrggAMl68ZEnmShmi6oqSu4Sa5TAZDJQGVB2nYAB-DZurDCMyquMaetQVLqykGQqzfMwYXVY4YDAMIoCmDbysq_asuXasE14ggcEczIUivAh2prWtKJmdhWAgGARnIhr8v0DIrgAbQ0nANIAJispYEsRpMcCshKAF0liI4QiCuABWXC8M3FcpFe97Pu-9qpEeo6zC_EB6MY5jWPDDQtAoYD9AYU77SgzBLtCa7cP42imNmITnSwciFMNF5LEoa82gwOAlgIVwVNHAGADV4DgedxaNGi6IiLoZYFyCRwISxMh2VXkPQDXbftiVtksfkYCd9WTbdSXwmgOAnlHd3HbVl2rbls6hYuq6pn8dgMr1jKGgAGQy6907PAB9a8MucM89Qy6DnH9giPQ8ClmM4pmlBZhipZY5iOMA3QQIMMCyLO16JdNRVbTOtDKBmSwhvgCX-1H81pPmOvUB7wXCyIDw0BgMV0FCBEBDsPDTYEre9KH5eR-BqcK5ogeLS6I-ZaXqYJiEG4cIP9ooCcfw8EkJ-RAIX0T421RB7ce89L7ukkNPGYc94A_wdtsBeD8FabGiMxdO8EMigPgEsauRs0EYIEFg12KJoixHQYkTBE894Sw9FAmBIc4IUN3vfbiUFgag3IkQ0ko9QhjyoeAyWdCqGSDgH4W-MtAHsABjQp4UB2YAw-MBVw68BAsPlopasaAXh6icKLGABkLBGztjAbM8QzxYE7gYmqo4AASEAUh4CgPYwglgTF2jMRY_QVijH2D6HAIUKUZFBS3rAJiujYA4DNPNRBrDcgzHQFkPWIMwbqk1pkVA-RuyoGVgALQJgIj0mJ2bsJScKSJc1qAxPUZwReBBmqwCWJ8IgLx6kwAAKrxKyK7WYZJEiuNMVAcxncCmyPZrVCJUTKlqNjnEhJtBw4IJGcAnYIdlkIPKVkqpMzeFzJgDY8UxBZjkIyK7HZWRjkCHTpQDs_T3GDM8TQahb8PQoMOSxV5rdJkZIkYvbiKIhTdGeSIi2MBpn2mYpvbeJyZH_K6JIW-ULmFpUqc2WYkKd45U-GvZ06KTl5SUrMK4ELsiIo1mYeQx0MkgtDDAMkEoN4kp3hGYlW8d6UvSviZ-_8YCPSSLcoUHjhnyV_i_GAEYIy0AGUM_QZVuAVQ0YY6lLBQrRAKhGHpfK3ECvuZ3CVWrMg6plW-RVAKcDKqMgQNVRj-UGulTQPVUqHkEA5G-JQiUrLspRbMxJyTyIfUiA0ESkQCgj0HPJCMaBPgFCSRw9Usr5XrFhX-c1qq8BRmet62gMbSkEHxRmiwcEYgEFCJgK4kbg0zmzeRD4UMBBw1xiuAt1BnjFtLTUqNlbfXqhrXoOtOMrF_XxpEMtQbmmdtjWUodRAB2lXWK6tKcE4B2ABjokJ3RsAgRdjxTUOA1zUBdAqmqWtaA5UPRYLRMR4ixWyFcS6UAjYzoyEIMs7BUCiygI-gQz7A0OSuG-hIVi9rrE-OuGgWouD2FTRGJ9AToRfqFD-ygZUz2FgyZQCJH8UjQfgwIJYMGBCIeNTWCYtgcBGKklkPNf0LD4auPhmdNGcOIbo0x1ADkZ0UvWEB6sIH91ga4Do5CubkMrkeOwRyEBd6P36BiDINVEgiTwEIVAgwQgVIyfiaINVhiixyH4OYwRAgOS6CEVAyRmITjoFOUTkhk6P02NCDAexmgkeIaOEIho4KzgiCEBIox2AWcnBkAowk_oQGaBKgkOAoFwBwCU-WABCKazsLrr3QCJ_NmaYBVvVP6oggaO0pFDXASLpGYtxa7cKIjFhuN_TE5YHUuoVzhdyq56L6ETxJBmHgOA0Foh4iS_Jf9UAMvUaPaalNlq02NprBe1pVGxs1kxENHrfWJhXDa-V5b3Xev9YY9R-rjWdQhDmEkdgbSRTpyy-cLoM2avVZrA92rs2IubY69QDKNx-geCDpU-wfgZzdEG7kcMkBnTpYUjNt7o9Ysfa-xAH7mz_vuDSBGJNJ5RwUdoBtHArdxl_miKiBHv2MlPdCy93KSb2D9XG10DHdTj1io5Lj2YuPwl_giNsYIk15IpbB9kUb1H0eTbVXdmp2j2cLcW0OLnal8RlY65zug-2_phAiPYKAeRaACDycO-XsXytq8oBrrXGRdfTrF-euAJuUTQ31-1mHOBbA2-1yrms1AcvCmR4DjbUXyse8qwQb3aQ3cWGoDYygrA7fQ7uDgcPkeMih72KgDXsRti-4V476gqedhJ-oFcjsGeDfvdQAXxYlvk9l4o8KIvDvY_5-uegavBA8-l8b2uWAtBa_-7bx2Dvo59EV-zx_I20EeEzG7yXjXIUYBj5mLw1vn2ieI-icH-KMfYeoCX99kn1uAch7F5xzLZP_QZpa6V4vjubAOKcQ44xjrhnA-G9TgaG_8DONvy4_VgrjywBnBMQXP6YXWwC1K1WxD_Zxe_O5O1XNN_a_RxSAm1H_GgF1FcZ7c9CLGbC_OvWLXBExI5AhOwJ_d9F_e3crPA_BJhWLP_FIAA9gAAH3oKwLfxIRiHIAuSIKmmfxpxYOPTIUIJwBoIAJXEAJrGAJVSm3TWlyaRaWklgA6V2RK14NIXYMIIYPoPYBhlxjII6woIIKoPUM0OxgewsBP2a1ez90V3gU4KG3fVEJNTpxFzTTOXmWsOwPKzWTgFQIzXQPYDEwADl_MidZMjh_AFNyA1NNlycMDWtLDHdJVoCnV2BiCEhSC38EjtUYDBC6BaC8B7DOU_5YBeU-lv9DV7V0jSiYCzCM0xN4AnEaBLRbAsJYBzRZYLR6jKRNRJAVNGj0BzQgohNzQjEhjGcVw2tyNGcpdZtakIAr04p0ANs0RB8fDKU6tbMPkqJGETlzDYjM9Y8NiZgODkiuC7DIdMtxDQDnDOlaB9lUF9C8U4CDlKCTlNY4jY8P4blKinVvC_o9oatydeMMxtQuAFDKN-wYBWBitRCxNPCdj3CrCPYbC-wuhISESVl8iLioMXCYAFklC3jYtPCfiaxfCxMDj2Atjd44THi7jDi1DgdwTUSr8nj7jd4MSlUQCsTri9lmTaSqD4SmSaSODXi9jqDG8kCyjnVqi1j2A9DAZbNWDYhyTCC4TmD8ScBZSjiUioA0i1SNSBChC8j1DVSRSyM-DVCDCtSdSTSFTzSTlsj_88iRCzixtz8xc389SLSpoGTit1Sa4WS7BGC3S1SbTNSvSUSfSQzlTj9nTFtMTJCK8ZCGc6pQTaA8TrSzSjjGCjDhTL9Y8PToUsytCTDHsZs_jiToi_DbMPj0BxSYCqS1TqzaykjLSeCGyxSvjO57Tcj8jXTMsLBvSOtGyOyXQedX0SDAy-zkiBzHchyH9f8ciCwJzpc39ZzEjO5616cvYjxbp6TwzBz2y5yaANzTwtymcjTJyVyDy1z9AYYcZNzvYdywyISfTVzMinVbzsZ7ztziz8iHDk0OTJDsSLky8mzO40zczRTPjDzJTSy0CbNxhhyaB6yTSMjbVmyTjUjWyULEK3oDSezMDJzpzY9ULkCphRzn8lzFsEsiKCScKuzFymCLy1SSKJTjyw4HyypdznzFccK2K7YOLzzlzmLeK7yTyBKuLGTiKRLPyxLvyZtfyCjRVijQL9B-SpLoLiyyz_jT9pT4DP8oC3zO5kKIL38b9ECcLjjbDMLX81S9LzLoL6LDSUMYipDFsaLTKEC78VLMxyLxzGLpdqK9yr8ICvK6KDTBLFs4CQqv9oK-LTzHy-BJz-ygr9joqDK0L1yNIZL2LvyIqxsoqzLQrYrRKcqzzBsK93K7KirryjySr-K5LoznKxD2SJCwCCA7FCqYqarYDbK0rvKYLMstLxZ5wjYYywsLCTSqqurDKXQJKfSpr0rSKFK4y2qOrPLpqMrVKCr1rFqJSiTfi4KdKawxN4szpzQapI1uhTr7QcRUjAgsscg0BtdUB4gzsfMJhuhgk9EZ0xMRhug_Ao8hwV4jITNy0x1ZwYsgbsBbAYgZwgZA8alad9FOBLh4LsT4aJ0pQ3QwaChkSYd2AdR_D04ABNTgZoKdPYI4BEXtTgOwFgMAMAC4JCmo2zA-D6mpZ6165EEFHIfdeChrXUcTRycuHGuGwtck5kURNoIqGUmkPYDwdQLYFvV9EQUzEIL9eCFcDlXoL9fQT3MipG-nLHJnFnGYCrTG82nNeC_5QGKBVwFIUhOG7EuwA-fYfIXyEYTYcwKdXGtAFUzLN_a6qYYHPnNLF_GbdHU8Y2nHVuIOj4PoMMO2dJTJeaOSDCqAJ0pq3s6QhOvWwPQQ0hVtIHKaQO_O6m7XetPK6jHWxO_WwQ5tF4EtYu4VNUuO8ujID8quv6GuvOi2im4HUuvugmeSsag7WzFrCmzAa6VwWm5ErYakM7UchKPGfJfMPEGe4BDJF4eaMXc_SiCYSJDwErHumgOuim86wenNHAKdWVKaBKBSv8s1ACtVTelO6gXJAmNS2LIO_a6jPCEa7oJqv6bE_WvLArCtIrdCL-y28iYs7SsbIa3w8_N_HW_xI4OajrVBoUNkibZ-tNHxPxIUaBrBgQX-ssssoLAQW6FDZBqLVgv8fDSyschcUeiwUSdDP8TDbA-hnAfDYsroYtAQcwVysbGMWQCvRMRGMQaRQEl0cgTIURbIBLCsKRiRwGcgRdOAfw70eqfgW-cQYAcYxnXhnDK02LHh_DHACIKSacLDDkeQJcX6RbMR1MR0PjKYCjHYdgM8UxrUUcZRe9csHccRpK2sdRzR7Ro8PgQQbIAxoxrIEx79NjSgRRdMfQTx7YBxyBJxv6A6WMeSw66UkYagdoKYSh0zRIEjOGozAFSI6JRG2R_jdAQTTMAG7oQIYIYItIfRjNARvocweJ2gJ3GYuY3MAepY5aZh7Uq4ERmsRgM-LgOTJNBqJNNqMXRgaRYAHAbZjfMmHJ2sSQBZqcJxojPabjFddnOvIhU9dYJXOXUNIhU02xqxIOq4B5qhMjfTMVIOohZnWwMUAAR1CEk2yCsSNxdzNwJjeYHEea8HQysWd011txfXefnhwBmhEisU8OhdHkee1kyESB1DAAjFRfgF4awDNAlXgV-Y5CsQOI4Jxb4TRfxfgiJZJZhY-dEVmDFXpYIRpaxZwsZbxY1sJeJdJdizQBIREhgDZa1CyBdTpb6sFb8lxY-ZZdFfZdVbRcla1mldlfldpfWFfM2poCFbVZFbZfFeGalYRH1doAVfWHzN3jNeZYtbFY5bRa5fmAjCdf5cTQzMIJdbJfVctY9bJa9bFUjKYT9Z40IZRbDfMaJxnCsTE16H-SIA4PWGGCjwEDn14SDfMa-YjEFHnyZfgENZ4ycR2DzYnxVbLcLe5eLfH1-asW21W36wLaeYKCsQD0xrX07YxfIB7d7wWLrcecHeHary1hrzHY-YnaZBHf7y71nbRfnerGHzTwHdmmHYjxza3cxYXe32JyR333iitbXbDxTxH1n3H33aHfJWEgubXTNXjlFgIGKxuerDub_XfVba63bfWymbBfCGNyRe13N0WIZARetzA7t2gyjxQLughOPERdNyOFHNRCg6zaVegp_YA1uesLw4_SzYT1zdvaA-Ayre2BraI7pZ5IZYo6_eVeGysWNdIto8db9N5JOQ4-rCjZ48Y7Ybjd48vf1v7dynjQUiUAXbLxmck-AGk_XZHebzk7ugU8nfb0dE73ilujlSk-HZz3Twk7U8U8vd3bg_k9M-TyPZXz-1PdU70_U4Xen1H3I90_lUU-42tnOhFjFifb0XrmUFZmbmBQBQ5jUDbm0A7j5m7liV4wfR6FNFoCkgBSWA1USD1C4HQFgBGG1m6H3gDgRWPl-XlleFQF2DfiK9njwGQm2B-SQSgksBFAyn8OcAaEsAaEJtzi1Auwyg68JoKUKTkVmEkDjoRR3jBRtkgDthVkjjsCTmm-Vl9hdgynUzSXcDftQDPCcwK8riG-KXzq-QXjME72Bpn224Bx3jsHkni8ZEXgIosGLaEARCXV4dQFYBwBLmglzhFDPB64AA0fvi4dRLA84tQzxrw2kABxQw6eF72LOgD737jKewSwXOUub7r7oHgHoHvUEHsHiH6HsqfqdYOHw2N7j7_wxrPOM8fwvWNO-SQiZDj-GYb6GWQXbWtxo2AAdVxD8dYGVnQ2u8syBZBcfC6CCloHNCq8wFYAiCF9fFScFB5754hMF_vWAy55gAu_cCu8xS1954mH5_V5KxQxeqPHUmkS-t9BnVNGum9kg-WL-mGBRHN_inflOHiBd5fBnXIiuAAA4NIg-Z0ogsAMo0grgkwNIZ16G3AZi4oX00dGdJO8p2BtnTSshApCUFZ0-eHmIlgDj1Iqe0ei4RQGgMp04Ggck_vFo8IKVAN51T8OUqcbukuYAUuuhxVLOlh1OzujYdfpXd51VTsMusucu8vItauXVKVvOOVp3Tx9ZDZjZw0uB5PNeqVxh4EcpI7MdJjmdW5PCzVohXB0XVBxVnU7o3ouAGfOB0ArHKAbGCgNoiMVq01FvZvnY4BVuskqWPYMcP_1Y3hdYH0yEab8_-MQI8B0WW5wAH2sseWBynf7QCcoPrObmvz44tVLiEYRAXN2_7zQUBn_Iktam9j7Au-aneCm2EwA5Ak47NV-tvWZBWZZ6KmKYIEFxpxAEguYZkJACkyKwZuSArpqCDPwRYd-DOSjPv1Zxt1c6NAd2FvSyRMNhsODRwng1_4yD5o23B8GQy4xLAmuLXNrv138Lddeueg9gAAGpEojfE6DHHtDCwE4SNQLo3DZgjcg496UOEnQ9jQDIuPMPQKBHAilcPA1QCWAAAFBGYASQH4O8A_JZ-XqE8tS29hIDw0aQSgJoGoBoC2GXqCAd0HkhQQSEM7H9BekSB4YMAVwLSGWXPwJCkh5gGnGUP8SoB0WByPoOW1HpVDqAtQ6IPUNizGYzwEoNNFgLqFdAUh1dL1H4AwjexruYuRmq0LpxQIMgMQSeCT0nLjDBGf4KYcKBBixYqAQoEyFkFDTTDVh4deYb0KWEDgdhZLdYQIE2G0BthKwslukLsBzDpcCw-oXXmOFrDhAZwtAFsKOFXCCSIwxyuwAqgaQZs5-IYaeS8KsMawDwyYZ8JmEvCNh7wi4VCNWFWMfhHQroeKl2TpD-h0uc_OiO9i1hxg3sDPlVjBH5UCR2Qg2jiKPAV5_696boNiKyDpC_h-Io8G9whxANqM6QlkTlApF3dpc8DRbEfgQZoFTmwA0cP000IciyRmsAkVZmxiwCLB8AqIWHHgRxDcoTQ98GQJ4xeovAn_HKAQDCFYAIwaoojCAPMAoYx06CAgFcG1HqwYYSYBtBmnNGmQZSc3etCH1cBYALRVol0f2hXCh904To60S7BhiIx7R2lPaMzGC7sxZSIcNiFzHbi8xvBSCKHunFzjOBLAxNHODQn24jdMQIxFqMCjqgcQSmyKDfinDTiZxs4ecAuEXC-7lx5IyY1MemJzi45_GcyVwDDHaApAwAIwRALKXNAUlOIso0_N52sFvtk4qcDOFnBzj5xC4xcUuM4DsGRiRuQieeHAkRIeCgIXgruD4OHgJsp4A4WeFQgiGWCpgc_alvwkyHrAuAnbFELYydxwBAWwLW-FYj6BQAbxSbFIFYjbGdtKACtJWlYioAfx42WrcNh-KxYTwfxzoNlh2LVH6Q5Q8wLzCFDgmh1wcxhVjnyxwr3AV2wbN1pq3raRJcJVrN9KvAyAOtIoLwaATqBHads4WxHXaIuKbjswVxsCAcRuOi6JjuI4rfcTPHoTHiFRG_XltGwvExlrx2ExNneP-YwBRez425tAHgCjh7w7455omjeAwIlJ3bdYMDHyDYQz2CbdUsIDokWAauukkCbFmImBBcMTIMKC8DchiScA5kxPPZGgDa4sJVrENsSxXBWsI2UxCwKSQZB7Ac2_QcoEqSYS-B_JLWIxDNmMmdsHJlkzLGJkgDXQMgeseIAyDsC2APMLAdTNrGSBoA8wNgAqNCC6HsAucuU-borCSmZAdJisecOXnim2ZKgQMVKZPAynuB1aBLZzL5m1LK9tJOEVgM1LsARgdQIoCqdrmLJiYQYt6ZyclIGlXB8oWQFIEKFskwwiYSwKyNjFwgzZEp2uFKZrngA_i_xkoDjERgrZGTxQU4G8UWxQxWZBQT1VyXpN_GK0jpWtIXreEiYmT8Jj0_8WMUwmdt3JeE4VgS1DamT7JoQEiaQ1OnEZMJ6cQ2DRIMkN97xj4kFnVPPS9ookUeOGfCzlFwCzoHKX1sJMPSiSvJYEzSbYARywBMZdErzieNQxiR-OhCAmVeNHbEyJJD4qSU-NBbrBDsgtL7lIkaxtJMxDQOwBMC0wUD2wTmCKcOE9qJBSZvUj6bC3hmJp5wStG9HZNoneJlZkobII5AOH3SQZ3klDJAFqnqTk2K4fqXtL1n4T_pLMgoJDPr7YdOqtAZmXpPVkOz9K2s3WZdMbaGyQYRUE2Z-LNmzS7J1svSbeNtkN8e21k6SDFLBkWSAJ6GIUP7O8TDARg6CQIIEzVmKzNEaMuaBjMzlYzyJlUy2YDNZbusQZIc_WR-LIlW5fE6bSmd4lUkQS7J-6aCShNBZyhYJSwToP4G1ztA0J6wV8UnPWDfjm5h0lvOsExAHSnp48-iagAjGMTlxA4ehCIjETZA2JCY7cUgi4lvwoEh4-eHxNxleoS2vCa5peM1FbiYpgIdCUWiboxzwZiM9mcjNY4N0i6d8iyQ_OkmczZ58ow-Rvx-aMzqwU6N-Y5J4y1o_phEvSbFIrbhiG4S4liEUhG4KIO4yiZ0AIHXlbiGADXVDM6D4i7cr4moaXiSmK5YL5GBydvprItgCIugRsWAIPBK4zJTYAAKXLh4K5Q_IIgOEGaKgpJEjXZrvYAADSzgXOJnGJpngRQucBoPoMcgihCaaPHUI5FzhQ8ZFbSaCINwBBsZ7Ek3BWBoxnw1s1F1vGAGEmfZHcOIWiqCNEMRKtInkAcbZmuJWR2L1kNCpWkKFiyaAzFAWWYIGm1xfIRkT1DIF8g2TRJTFPC6xAQGgFLAjE-tdbioOoBqCRkcdExW4skTSIgUAMH5ByijoBsDC4aehpJzz6s58cGfNgpmyDQb9TwtxN5EcRyXJ87o-Ss2gcXwD0coyGShSb2hepQBfEu8IUMgNyW1LjGrcPxQ7CyTx0ulAgMwC0oICro9EnStBj0pqV6c6lbOZ9iQxLFiQhhFS54rvExRt9nAFCohusBhjlKmlVBUMblEEknJMRlmQRuYB1BjycApUkrOctZK_D_hXGMwG-AmVeL_FucmABcnvDC9SFWQXZbQotiuVDlu_FQhwVOUBERA8UTYCZj-ohAl0YM7oCLKmAUlGgWoOwNPHPi5g16AWdnB4qmz4hugyYkKdCjRXaZpa6ALmbZnuqDL0Z3QbpUwKWAgxBoMwWIFzRJUVTtSGKlrDPTgjpzyVRwDKeCSNjM1Hu9M0EY5xXAmij0kKgQuNzFTqpyAQ7YVZcpcoJYKSwzbxT8sMJaqCEFWOWWVDlUShyAM2MTNz0RD3phwFAoGgVC2C7BnQtuHIAOI5rfKYgwMaSPlOCBpsIgsoTEMKvm4mYcVizGlZlnPzarA1IdUHGlgUpRqoABdKguiyFCdC1UhoqABclZWcwNVY9INb8KXqz08guYHzHQHpAIqvafYPLpmD5V2BlIXOKgelJzmerugiKtpkOAryklXAgNLTOSDEj7p3VQytgN0HpDYQCErxX1ZsB2C5hxQeIAdaoDYBcBQgXNCvNnV5EFpDVmIJNXaXCqFrKK66jNRchbFaw2xTDNuTkEqGZrDVR4E9cfxgndjEADKn5X3Jv6YcYAcDR7MSIGFlKr1TCe8DlExBHrr-WZWMYyK0grRigAAEmADaquA8gc0NBtjHyBig7AK4LBvDXrqLAZq6LHkDTSAaCE94D9XyIQaaVoQNIr9dhvnyiIIw6GzSjNlNWqq0CSwIsm8vfCrKpgC_WYFYrmXys-lCTPHHIT_DMRWk4yxUZMq42CbtlZC4Fc4qoYHLONMwKxUsAsUrIrFpy5lBJpajrcdgViy5efgSxrJdNVysUcJsE0wCjqqQjfifQIAXIoeSEMNB4sU1maZs9_ZhRtBc2sTtpkYGjZJ0TU3qOwx_M9bGvBzFlTa4qEbHdD82ti717QZiNUEQCIQ2gMwPuQ9jPEewOCgaNQJikkE2aCEdmpLdQR7mZbsAbLbQQIqEUiKxFEiqRTIv8JyKFFSinUCorKimCEoFZU7mDniAAxuN8kUzS1BbE6xA0EYDsf4j6Avc-52m7YFYrIxeRy2K4U7n1qxBVLHN0208I-AHGvgxi8CabZ5tTWojf-OwLNZwFzWLb4Ay207XAA4LWtphB27YBls5gmDOASwJhc4Fu0XIyGD2TrVAG61macoX2n7f1qMTrbCCcEi7RwQexyr_tmmrEKxs9RlLRwMy7pa32k17K5N1YcFQQC-VCN4giO3DLbCmWwBcd6mwZe0tx2BR2cuOvTRFgMW465BpxJqnKpp1xtCmNYOVSTpx3M7qwe0D5V6lM1ZBlYH7apbxr04LZXm8qoZrHXzpB0rEofCDuLqE3iD86sugmDLrQBy7FlcdMdObg06F55dptJZXojjwjsAJwnW2LjqT7yssWlAWXFcEWUGL7-suGXdDvigKb5suSulv4A2X-krg6y45Xind1Xjm1w6v5S7CuCngsdjKkPSVgD27Q4dYkZiOBlap4ABd6EZAU4RT6HpIlgeGZtLsHVfJjalypwmjlHD60Iwuep9VkgL2nMNZYSubjM0DHSqE0GaIvUYmgH4DAB1eglDMAj3qYZmMCJYIWgH3NpntusxpLBzx2YgoemOWbYXqUHMQe9P_fvUqWVofxk2hoUfT0HH3KaoAU-upDPs71ftk6dArboUOM4yrm9Sg2gVkjUHP9NBzna9jRzP1N6_oRenRa51La36udKUGfjTNHFixdAOC3NF3uNop6YcTumYInsuKgG7g7yiMADDfDzyHBLcdnEYsN2JLuYm4zuPzBpkcpJF7XXOHjx66ZjGeeBtHoQYFlnho4_EsSEXDR6g89Q0EYaRX1zhnh_uoPOrTlHaC0Hc49Bxg81xTGsH2DlgKg7_JoNng0eNiBoFDxsSV9pDdB4uHweYOCHaelgTg9wckPSHZDNieQwwaYMCG2DKhkQ_aA5RpiMoIoNHunB1AZRweI0xnqYfMPCKrDNhow6eK9T2B9Q0EHOKD0cPWGxFnB9wwwa8N5xLDvhkUC4dpkeNxDBB_mdOPsAXZnAw0tQ1EfIOxH4jw0g-cYa9QXoCdGQ3KDFhT7p6NRFgIvShjUmNB_C-BlI2eF97wRqyVwGLA32xmRCN-ZIsvHJnDROEIljOIfR2AyCEaijERpkfAC1gCgcozoMYHK2xzM5ZKTOdfmJDSCoKsg6ANowRhyDyRqyfRnIDGuFhh0IN0GjY6sfkC5xoNNwkYzMGQ2oahjJCAUMPKUGlGm59hiw04bEU1GZIjeMPekEyBOyVj94Ro5oiEH9LWc9uhvB2GbxBadjIW0enbsuYgmm807YTKxosByqDj94Jozga9QgZtOKx5ASiYhwi7OjtsAvQMZKNjEm5ARzw-IeCPPGRQrxuoxLV6OrG_jlmumYzgA0Qqpjcx9FY3mhTyRoTz7A4-Zs1UCnfhNOPk4bthNLtm6IOCEwLihOAmzawJxdlpwHzuaudaJ6gwcFQBidT2yAivfNCJP4m8Gym9k--oGPN9WT8kTJaIM5OrAEg1cLxryflMG6IkvbHNGvnJzn42BUAe07sFHLnrRCJoxE4MaDrb8nTQdAEq9R9NTE9T1AY2jOiAUY0r6cdKdDOnbovoYYcdOOoWkbqYAlgmZ_OqvpbRN1TlFgBvVcDjoN7Uz7gc3IGnLNl1qzBMQNFWdQDm4dQ4QOsxbTiAtmCYbZmeX9AGJGwLRVyJ0ZrsGC_Logw5gOVzvME4zMjLRsOBZXDQsUqid0BbGUe4O8G9DLBgw3VqsRGQ3juu5c06m_3CRmjdM8Ao7P6rICFq_VDPbcweNRGNDMhqQ9oZ4MKGtzyh3c6T1qPvHfAOHbqieeHHomrND-8fMgIKNGnCT8y5_YMfoZsmRBHJ_45TidOKmXON7UtuCdSyQmUMYpl01e10Xj5VTYY088BfPNB442yAkhnea_YPmyDMRvOHEZFAJGaT35g86OxIaAXEDIXBBSxASXqZXFGB9iZvNiTTdwlfYCADUHvTKxueQoGWqwvaBB1-iGQOIBbHNDTxp57i7El7rHhyS4AeWfWmooOKSADiXsLEIEqmQhLXT5ENfPopQP26ju7i-wOnDaRpiqtTlhoAItzg5IdQ-oarfYF-56gVDai3QJABSCLRuZx2XmVUZIsan2A3B68E1v8Jag6xcoeK4leSvhGTDURvWA0DPDc8-Dqhuw9ldyv5Xhpwhn-XObEgqKtQfXPODlbysFXOD1V2q7nHqulXzDmVr1Nwe8u-XJF_l4uEFaKto8ereoPywFcMMVXXDG_bg3jxcvBG-ujh_wjDyGvRG5rwiha5YaWudWN-2g1ru10676DaeWoTg7td0EHWWDSV7a2IbR7-E-uDQPWHVZKuNWVrt1jrg9datPWyrGRqa2RZVHt6XY1FiwOuaiMJW2kSV5wHuZ_O67Kz5KH_bFaz2Y1kB5eoPbGegu5RCj5-4o3cdJPzArg3BtqwVdpO_npdXGIjEXq0s8lTL8AfS4Hk_1Y2k9EYKy-qDXwRoUbqAKveqdENTAQGCNcNEHRTKmnDTSe_oSSYzRlHmr3hgm2VaJu67-bXJJk8cCUEU2aSVNvSzKFL1EkYVUwMWY2ttPal2aXpn03mFxDcqKgR4JqRbNpWK2GbTNr3Ke0_3cY0tMS7JMOBX4iQJeXiZfTmdyMscJaM4b22Md_bsAKaVlCLULcuIi3sbYt2i15Z8ujW-r41r8xmn3N0ms67tkxF4hmzZmi6-2Qs97f2wpmmNpN24wzeVtvJVbNNzGnTetuYDbbQee294WpmxWr980D-saD5uB4ILwt4k5fqP1ZJlYEYX223VrSujEz1aNMx-TzP50b6M5s89Jg27H64l4aLuxHZ7sM37juNqwM1z2t6CLrWoBW-Ta5LaWK76t2m0SSL112WbjdmK1zeDuNmaAlAA2EunnD2Ba0OJwuk3SH3-2c7d99u1MxXuppI7DNlu-_UoARgnLLl0HuIvcueWRrY1ga7ua9s_287P9me5zcqtSglYAArdOGgb0AOpsxphC4LZgvmmsg8F6OkRg5SsBAY8kUS3NymJlnNCMMBvbjjQD-jPxzoz_qw9LzRBtCzDubizg9Fr6WHfo3hyWeNvoBAOGuqXfnRxCSO8AM6TYJAVt1hmZHFtJR3fhqOdgCgxMaPsXerBF6QHLtwe0HeocF0b5uZoGGbRQef2rH19AmNfaAuxXrY2jFtQZfDQvU3Hnd1cxjZIdpDR4MMsAO-x8DyQ4YSwLKjaa8A3BIgIoSAtBBCeaFPHw6uunI4mBLAknUeOuho8IBDirbIGcIN0FgBBPTMOQGTIQGcxgAjEws4cJgF7D4r3A6QoKbMVpDIqeRgxiIIcQugEAZLAgGWvJA5WSWMIlAHp0VAlQBOun8T9J6Qkyf50Bn84NpKgHUtK15o-9foFgEodai_4MTyAiM7WPiXBn0l2Sw-Cif-rYnd-SZ6-mmfZZZnEl-Z4s6EDTyVn0QNZxs435FPunRz5wGwNzDCpxnQT3Z5XVswZPrnFtOAN85tNlOPnvTpvN872cnPtnd-AF1lT8KXOvHoL8F0dTEyFpJAq-wsEI2hTGYAsWiTEL-LaccoVMwoPAFarEhDYrnddZCEs8lBjPOnQT-J687pn7A8AnQml6i-Sf50GXDzpWigOidEAznhANl5E7m6fs_oFLwDrK6pfDHJ7K4UbVI85fcuCASrjNH9RRB_p1QCrlEK6JXDigdXNUNVz3MNdqmjqotv6MDZut3X3rUt8wzLdHZNV3nuzr5_EC_ljZIX7r2F_thhs-E_jMCoLgvPgXDcWIhS9A_GIwWxdqkL2gROws4U6StFugHNljQIgBCSX1cKAJAFEQFBcuU2ZuOaFTfTCtFyECAACwlgfwEkoiSQOW4BZaKRU3KKt5_FrdNuAE9C5eJsCwDKwRQKQDwGoqcEhxmIxbhOUik7c2xTDHXewOtdEVMXc49gMww1j3uMHJFlgJYFO48uzuxFQixd-YZ1A8GM4Z4IRUddXccH5LtikK5opCVxG0xvlyrfO-cBtJrw6Y6CMe6WANjTr0EMw0FYvceh0oDTrZPaAbFpiMxZ4GRLmPxwhxCl5Q9xUYguStI_GvnAgNYsrgFiIkSqtBUkonf46UFU-yIFgizF1uYgzgzjWgHw9EAsE31wY6QYIOlxGxYHzg7R6x6gec4V1yI2Qfo-sfwPK1lj02MoOTXBjJcEUPwoXdLuD3D7oRYXGq2mH_C9gcvqD2OuM9hPonvd8u8k_o8hFki2T_J9qtah2PcVqI5u5neSekjJfSwHdZM8ZQ53zgAz_FdnFY9TPK16sXOO-6Sf0lXqIxEh4TgGxJQQoVW5RZy2eQxtyNLoGAAuRtJen_Qz00F9m1WMJ4TDBS7JtfCj05V1m4LwxDadlk5-ul7LbrWihxeSP8ACFxdAi-9PheYXsr9qT9PBbcwK0LQpcZhiVeCEkXqALk_PliRxjAXxKja9y_bGsLuYHgrpZeXsBwNIOCt8NvT7NemErX12OnyK9wBjClx6bxkFm8ijrlo9dPul9m0zoFvf6UGKrcAzoOfrY4WpK0mQHmL_2u2AsBSlXOHoyjzHrj_x8htsW5pK4Nttd4Ud37Y97G0JQDpwjVK6ogN9lfFBmtPewPL3uk_jkAuib5zSZWAFeY6OQWrTtATWDhTS4j9lY1gLlLAD2d3ojY_Q0hyektMmmY6BSwTUa3cz45Qz_G53TafS-SbHThYiIG5vZccbf1PJnoEF8E3brKSR1U7mSJyj708AoYSOA6m6pxUBKtmBKEHw0hEZTuDA-SML9F_OxxfM1WqtlXqpnlpfsv1YpWSsDvnmuIoYmksAl4J5l9cmC-qUSDV9hKAd0qlbpmmA9qrjZxnMrPVgAO1yAMs6sFi8oDPAIihLj3xKGSDwg1YLk4VZpk1NnZ21M9Upt7GK3FdmTUwMkQn_17vdph9OIlpU4Hw1lvYn2NCPPXyDUA1fJrDV1lS_JM42fjmdAKn5u7UA03mfhmkYmyCnl8_XQcgGTOL9Hn1ydVeKkAMijdKaN7mCADlA0hKhOAeI_DcmoNLj-IAxg4waIQyUc_0OqQZf3ABhgQAhx41VUcv-PUBatYN_c9YYSn8ZA9_bY-9T2JYovrxmDIfIh3DQAMhDq_tMbMP16RY-lMhRH5yXQmaXqj1_m8_52IPqLFIgDtu2QNf7f-t_l3S5Q6XO_44-X_rQ7xAo1L_7Xq0WlrAX-IAaUQgBH_qKjoAL6hhxLED2Hf7AQD_m07aU8FC1i1qCFAMhpco0nJgcKYkPEC5ciQAEDdAYqu5jMg7NDB7VC8tNPLwUgQHEDFqRUoVIYqXZk76IgitgzRM0j8LiJGyMtD5j3UXmj0zd0GJjloSYlUqGaFi4eqgDDa78CDqsqXcooEparmq9oPYMXvl4EAagdrg388gmCK_wYwOMbeMOGI-CKBAWFriy0c9EYjJ4R6IWLlChoN0osUwqupDb6QGulhP-LNAb66GRvib6WYQUIDSFolvlQF3INvrdKPIDvjLQx-Lvt6AzAbvhlJB-XvvBSYYipIH4wAnviH5BoQmNCgYqlKtQDR-3auIFx-R4An4ywygRvy2AMMqUEAau_v_6BayAUwhn-MWl2KX-pRBJi1SeAVNANBMAE0Fa0qgdNJ9o2MMGIbS8kG0ElBwfpMwp-D2io7awogBmjWalgR3QhiCwTlDLBHQStBWYqfnRgYAyroz7eBESEYhDaHYhtr6B00LMETa1EG5q7BswUSRlkLerrDO6SfED4zmHKDAE4U2Pp_57OoAWiLI-Jpmj4aUAxhMR1Q_VBGAEmKPsjTd-ntm-quoSwGZBB8cNrfbAh0FMgJohiHOHapohDgaYwW8IQj44USIVCFEOMId1REY-Id1SghOATSFJ6ZId0aJB6vs6jYyQISPwXI5iGKpF-GmID4NIlmOF7jqXPuYFQ8y_sEEEaOagManc4xud5M-sAPT7c-dUBoERILPiYE2mmIIR43cOWjKFHqMCDaZ_68PpPCGh5ga0j9BaAYAE9iUHn3I2m3QQf5WhidMaEoBt6lrDrASoCNoUKYAV3ILUYAZ-Qoi6avjhYIlymJing1iCCoeyEwpPDdKQYegA6y8YYKY1gCArrI5QK3nWhQawAOGETw8gCmGLCcAMUBb-6YV6jZhKoevqphpBBCKgSmoStB1hibHVCHKUAFggbSc0kNQcoQwkWFtCf2pmEtkA0E2GYW_OBepDhusnFgDSI3gCI7BXqOlytIysBlAJAvYdQpZhpXgQgww-YfMDteLQWJDmhVYfuFmam4YJrthrYe2GGECnC9JvOBCCqFYELoTPQ0494egGOhG0o-GoB7YvaGIAL4ceEIhE8Et5Zkl4bOEb8r1H1hPUlwtCKnoafNsyHhdUEsDp8FJK0hwR2zJWGSaSDBFi3K08vcowAzAeqgJAoETQDgRqwszh4UYIlGHDgv8OiB4gCoOvSnYnKtVKBqRkE9R40sINJAzYGEUrRYROESBEoK77AiLlsKagIBpq3QpiD4RvEaPDTCiQLmpJ-MYSrLoAu0v5LyQ3EWBF8R6_iJE8R4EYkDzBETpOQICkZh7DyRuRkpEERKka2GiRGkfME4wYuByiMRNADqCXI8EPsA5QHYrEDUAQxNehwS7QC5GoA5oPyD20oKJ-SRomuOUAZqZkVCKSRFeCtC6BrQOEDNBvIupA2RL4GLincakU9QSY7SgZG70D3LyI9hmYaOT4-3QHcK8i84SeGUAS4VAArhk8Df4FRvUBXjFRCIaVHLhA4VND5RYuA_T6-1PtQruYntMEAqY1YcWG0BIqnTRbAcELfAlOr6DAC4gcmK1Ij8ZUQmReoQoPYjvCy_lWEge_Hrz7tCZ_D5qRaTuGsZTQ1mh6F9Bq_BWQukEWAtGqQ8QAh6Sa_XqOFtRvkqzTdKnUZaLiQKtGUy0oPEcbYFg5oTcGtqlahipJwM9H6rGgUQHlKAS3SssKsRoTC5QV43dEaFdB74XsKYa6YbDF_-74egHAxKeGO6hR4kcKCJAYwZaZQAWMSxHe-iMbdFLYBMTxFpR8QAZGB2CQNDHDU5GmyJjYKUTQCUxUANTHyQZ0UtGXRLYQlF2R5CPsDzBzMWJFExZYeupDUCDGRqjUjMcdS2YrmMbapE-mPMDmA3UeYC9R1PtDRiQeUuzScx7Sj5wXoqdBGjdAgMbKADiRGjLGI0csXECjUngULGsx1MT5jP4jUn9Tvw2pOoBuBcANsAQAgMOlwhYkMfr5IgMkVrLoAxlmlS5g1PoS5yxFJHTG2xS0ezFTMVIofiSxtIhFh1RCPg1HlRuURAHdAWZKnE4k6cRVHXczUYgGmm0sTHHpRzUjlC5xi4Y1E1h-Af5IrQTikHHUxt6HpE7AGUZOTUiUsRXincFJI4BASfbh4CP8cNIzyxRWIhFjZhiiEBJ061lOKFHqoMegzJYtXqyJ0xHKL3FjuA8TlDduvbv24RgE8fPFmxG6kwh9xQoAPFDxs4PJC5ha8f3H9uoYEoD7GBCMfECAA8SeB3xMGg_HrxN8R4DIaCcaExlxVMRXGhOdMbFqpoEUIjEwSo4HBJNhp_LVLiO9whOHmyaUknhA2E8CNCBxTstTHA47QGHIzgo8ZhoNx_oXJHNSdMRYC26BCQZE0odKAiCPgkGr9yOQD7gu46glhuIoigUPNeBwSV8SfH9uZ8ZDLrqMCKgl3o3pvpEVxmCdglhWxCZMwCJPpu3GIxJCYaCtx2wOQldAlCWKjtANCWeB0J1nm5aMJw0j9ysJ7Ce_HXxg8VXJJ4osX_THRFOCFEUxsccImLxMpmOGr-okXbE2Jodm1HKh1wW4mFidwdoF0xDwXoGr-fypzCkgPEXzEOR4QNvqExEkbAmLYf8WzFEJoTB-rixs6D4T6OSJqKKgCHiWqHfypSmJARAGILAAXISSNpLQANknMqwRs8ZKEn-BGAqGY2wZmTJrwTiN6ryQE8VpLkyGQlnGTMClnUm-glxu0AqYzoLFFyqhSl4k6Bjwf4nyhagF3KMI-wB5EtJ9STZKvBsycUnSQgIV6jYkyYhcilJYoZUm_G5SUwiE-KgdaHXBhSjqFEWgxgz51Qy2uckYYUZAWjuYGSbkb44AJFELL-tflKGJ0rSFdpg4NfpzDhavmjtE382yaEEde7Phsluh6TIJqfJm0WHYVQiatfyjkgKXr4nUdSUsnEx40SMBVhuSZiDjmTCIUkI4KKYPagwiEbsmJ4YyX-o5qHpuPHrhh0XADXgXHK-oEBqXmkmqxhKRT6WuJXhKFMIOoFHLJATSVSmn-o8BKAlJNXnYmTMCUMt58paCgKkd-EMXk5jukgFKk2SiaPmCFSh6oaowIi_hSDPBCQO0BvemWPcljGLKXVBi4ZGK0ojJfidsmBJ8EjxEeRiUlADmgCqdJCvB2YVymCpyycanDJviVQRwSFqRMlWpT1DanQAdqfsAdEo7kBJOpEqZPHYM7qaamepJyN6kvJlqe0AJRAaQkChpQoK8Gfu29s4Dfuv3HVrFkHgKaDbALOmwyap78OvA6pYIpzxTxvKRymn-88YYSqpfQQlGkElSdFg8RDwevBppqiMYQzY-qUNiGpmSdLgmpmOtoGxpzCHKFkpvqUmnWpkyZ2kOpuMdoTOp3KR-rDp9wVFFxpE6X0aJpyabOnOgXaa8H7xM2AWnigRackk7BpaXACJAq8OhgVpWdBFitp94S2lwxXoR-GDBj6pdpYQ84HjGb8kAWyLWR1arlp_qcALinVSPXryL3J9OGumjJPqdgCTJoST7xygiyQ0kLpt9IzyzJHbtIReogqiNQgZKKXJAVUAGX8rAZXSdVHEpaClLSpyn6fej0p9cYhkkZi0OpB9J3CpOR9paKTaHDJFeGOmcQm6VUlTpUyTFFdySGfMlRJf0Nhn3ouGchmtRmUblATxFGWnIjUTDBiFfqpZoWmH4sFHqkDpPtppmrpo6eunjppKVulTpO6XKC0AFiPancp4abWkCALqdKnhRFmhYl7xY7iOFxqX6qxkQZHqXpncZBmbxmwZfqTQAeRpmRaDzxlmXPFjudGpljHprgKekHU4QWeAIc6KmoSNSxsTb74qKQRxowAxoPQha0paR34MQvoLqljYbmZpnRpI6WalepPGQn5dyxme0C5ZGjDADmZrqQumm-EqTZk2SK6R5nQZCaUZkzpcoLVktEt4tbr1Z86SFkEIrWW6n2ZLlI5lTx10S5l_pGJpjHqRYUfhm_xy_k-koxL6Wtmeh-_q-kPq6MY_ERJOMU6F-xK0A-moxn4XtkLZykdjGOppidLjqQfWfVnBZYuEVnopPPhxmhMXGfGkBJ3Wf6mNIl2cZHXZmkUnhTZQoFJmDUR6aplnp3dKWkKMvcgVnUYL2exmmpYuJ9kVZ26T1ndyyLA1m2ZE2mLhLpjWQUwRZkOTFkv6r7NdDw5f0JFnRZ5ZGynVgrGelwChcsNQrChJWPcnNZVmTxlo5agHr5yq9ybyFzhnYLXL-q6yQQg9KjcvMAD6BGosC5AvTksBti-DgVAchwun44tGFplBbWm1YAL5HJTpoUqna6oYcmahqoRziUArPuThiYxkKa4heZNJwBTAJwPAALQUwBrFTAFCNsEuUVyX-CjamXuv4Uk94IsG2JA3svFARHLlbmZCIPrbri5-XHCSjqMCDfy3uDWKNYaeT7i-7E0b7s4D_85QhiRxep6vJBtiaBEnHW5aOBHmx5kDve6aJj7s-6vux7qGA9ypEmCKe5CIEiKyQoTq-K3ZluZl6N57fNeg5QiMETBWQxad9FahHuTGlYJs2l5k-56ANoQvaaOPvqsaV4hFju560afwYA4qJUmScraXClTQ4-ahnSmAeYv7PJBoTVBF5o5HHml5NnqmIV5KeVXlqikzGR6oAFHlghIhx_JtCH5HgKaFB5IKaLm0OMoG5pZ0o7OPn7Y9efFD_5UOE3L6hE8LnbwZnYftgJRUBUKJXhYkD7kPaYGUARH5U0CfkJ5ZeUIpJ5leWnmw5AgtLgrQE0s0B4FeOvPiJwp3llqoJi6GUw15RwBirYACINAhKk6cmmE50BudcnT-C5HiDmgFeGKk8FoTAvkDidMafyVSvydtHX8mCWJmcQB8WnwokJyLMZ-xS-d8lqAYhXpyJqMeaOSY5vch-pbQGoRwU7qXBewDnUbWhmjU-RucOnA65Wd9H04lhXGnM4oUFWxioiBb6nR83mV8Hk4PweJpOadUP8GwAjjrD5iQ2JD04IIYUDAAi52SrlDFMAgCEX0o4RRco-OtIeSExkRPrkYohpyVrmG5eugJqFieuUdRRFMRQiBxFu8AJFCR4qPkUqohRenDvaAxtJFQQXANvriw8kOUWhFRRfAWYO7Shl7eQvJqODeeb7L54WwqthmozaIXksDNFsRVUWGqr4g9hmF1hR5mAFXmVwCT53-a9pfanRe-p6-0kU7kFAUeoPkuaa2p5mbamWMYGnJf0GFpbRahTtGpaWGYQSLhnYJ0GL5igeFqShsYrmqrxUuTlDoahhKBr_CkzLmFwaCGsABIaKGmWgYa1GHKoJYWxTOBR6wzBoxN0JWFvlwFGaAOK3Fd_KGHdCFJCiXZq3OTUXmxduXAAO5IQHcUz09IJAA-AWsQ5hcCYkMrLfQAQOEA258sdqQRxFJehgfwOIHDT7orBTWA9xfLKVGdg_6usY8lGUJ2D_JIGg9o_FexoCXoA8GohqcwFxiCUzYHKOaEHR7RqErcxsAL0XXQ8JYKWdgGxeWE_qoKV-rp8SpbKG70f-dqU1-KMrGSzaIJfti-Ed0aEpt5CIP2Ki551OaHVOjpbSKgl2_kMWAF8XvMA38SXn56qIClM3yzaoKd3HmlI2rNrOlTCN-lH-K0NfxoakZSPkheMZRkBHZ0uJUlRlqZRSR4BHpRcjqZFqqzSqAeLu35TARED5GcwCpV6iQlKQMtqFK-xRtrFk5LqDC2a9mp0HrZ22R2Jxa3gAlr2aGZd-qderZeMnYAOULWWQpGAOggogCfqoUwW3rkylopbZUlo386hSbkmBtoR-E9lWAH2VJaA5b8TFkMxUMmjgthfpnjlAhA4WxAYqOMbfZvma4VT5q-R9r6OJdpgJGI_3pGyCa59koJMh3IRboS6QJpcxEhA1I7ZiakGMKCUAASTayzE8IsGijU4aFkKzaOyYAWgV1jAACKV2Ld41JHKMxCOAGiufEKwA4rDB1Fo7IAU7Jo8JshzSNUACxviHpchUP8aFeLDyAG0tl686swDhWhWF2FdjyQofpgAXYHlm4xAkEYMwqE0XbP7ZgAiQBpozAbFfYhEk2tFsGlRfSVemDAAMK145Qxntu7zuange6nuOoGu4UJcEFQmqJX3O4b-EjkFIag6rFdQDsVl2DzkLlDgSPDNIRsOKjUK6GFHiXKjNJIRxAYFRlAKVA5spVReLmh9TaBu8Q0I1JJ0TJmgSrQnYBiA8kNiFy-ymbTIcMOALlxCMEYMUDVkuNFQWi5l0HJI5A0GiRVSlxQGbH2V1IDSjTyJxYti8576GpmTkcqtQpFi2gZpShagVWiJP5OJX9DOVUAFHg-S1GBSSJavCKJJtivPn1UcqlpdLj5VbuAKJ_0oWipbpqT6FJEJVESMlXaBc1aWSnMKya0FUouvFBUwAtFcto0ahBArkKO6ufaxr2mAhvbxQKnmJ77u6lVJ5aerXBZ5yeCnn9zOuSZcmrMQTxXsmRahqvlV2yVfp5URAHBMVVGwwvKxLvV-1Z9V6cp4LtXyhkFR8IwVThQQgyVGJnJWA1MoNSC9YaNbBUqsDlQTgJAEYP9XgVhBEDVksYNTMCScZtDNXdCxDtCDT8wGCjVE1mNfADE1K4FYxe04qDqxbVSxtDVUEuahkUA-x1SbTZFESLkVjY2tHoUPJPPicnFkHNSJDbV6ANzV2kaJeKgE11RaFWDl0gViAcVqlRZ7TuN1VdXLuHXDnAnuSVme6WAelfSizMY2KokPujWiooNA-nkngq1hqr1X2aXAGDli4YmEon6V3QIGqAFH0evRopHpZH65Ao1At540uKjkAeAyQLRWmY1AIpV5AjmnYClwDQFZFeoyoQhV7OuYU7V9B-VfBoy1HfksbFAYuIeVvZyOR9kplXuXBLp1IXr7lJ4U-dLHIJm9oGUWwoCZhp7e4orpYcVImcSQfqupUATa5hYlPQD4a6fMVwS2daf75VPaRNnmxBUCjgjqs2ojSvUNvpSp5cIdb7Q3QCxv4oJAyQIKBJAi0uYCmCUhR-qCFAhErWNpJKTBnrObVdRilCu_n7Wjk49eRkZ1pMSXWeJw-Z1k3lJIHKCAFrwdXWZehGnTGv1twe_XmpXWb5mxa74R5FvpXAAen01Odc_UrxFYRKkfFp9VCl_JE8Rvk3ccDRPXP1NKFZmAN1wWskTFTCL4XI06-dLnZhZsYkn3Yq1eYmeFb5aQ2PlGaB8BQY2GKQzX17DItXawy1V-hPYs9qRauGRAM0gWhAtsLy_l_BFQQ4IXHODoJF7IQLX9CYmB3ziBVADMDJAqCTaRjRspPmpWABIIwKq0xajkAsAZZWdhR1VtuzQyM_FS6Ce0sQHOqoAZ2BQLlS4JCDRhxkml9KSgz5VBjnVeNkZ461W7pJ4vV4uhI0vEKSTXaeNONqD4g2DnvR7-NK4Cna_mTrGSjTmTydeERFMMLnxZKLxFBG-keCP6RnF2EBnpZN2EKyo0pXHI7ylQHIDuFnJRoenBrFwvGkViCZtLrnO6xxfYWj5ZubZiASIKjb6YAGjHlyPUysUKAFF7THSVMCiNDrG9gvtaynSRYxZUXLanmrMEfVteWoWbq2pDNkhaFKZEWDNFRWEXENBhQ6TQktmEKVbo7NIGpuq9tCgoNMmqZwEL1rUscAKYLkBETX5gBSuCH2uyMEXbNRRSVgzNOzeDrCimLuPSbVstWQ7JZbqi1g626oemxzNqDaIUrg4NUs0wphqs7ha47du0k04-0TU2j5MMOhp-5vOEvFzoc-blDGxV2iREoYRLafV7a6ahSS5qResZBC5kQEUVwt5GRHmS5h0dLnaqr4iy2n-8uXw2z5wKfLrkOe_PrqPJmuVT7a5tPt4WDpVTewUS1zPmuWnJS_pcni160XqFQAtTXl7vJb2W01HUslWBUcEysIGiw1xPkYTtNWWEHUqx40dkCxM6AgqrJqZ9ZQ04loZTXV7OGDV6UF56LbU2bhGdRtJrNg3gNDNJJGTRklxgIpSlWZR_Af4-tgeWNUD1wDaVnZlldREoZ1Xcm2KvBU-RPHct6mWFXBVoba-LOZ2FqnUb8f9V0WhKGpQQD9F_nrpb411TR62T17OUepTFxddG1D5sbRXXjaCbU61LFkQG5qFt6xRm005NDUdSEuQ_mOCj-s_pP5r-jlLP7z-e-fqWf53mev6b-bRR6X8l3mcMWZei7ZiBrFnQdW1eti7ePnICp2RtkRtm2X0FPhn4TA3_hGhPlUVkHKNmEoNtrWg3iFu0QKV_qQKXCS3twqbvlgit9SaEJemCT6Z9VGACl5siqbJUiJVS1Y-CnNouXiUvR0IFgAw0TanmBbNoRV9mI1KoODmZY9_m-ikBm0vZmpsU6rsAUBouRlJGwAgFHg5AB8LRWjFBUniBHgG3HOAWtOQD5j5121fSWUlruebEC0x2JDxQ8W0Ph3W5lAaM3Md0QJIow88vIu1IVclc4D0V-MWsUblubb62r-snae1vpBNUMRUVe5QXkSdYFVJ1XYwOPlGkEWnahW6d_uTdGkRtmDUG5SzQJQHoZNIHphJwozR0y0ggLQXVOyLQKODVlVmtg1VJhrT8566j9XAAGturC51rysYmyw_VjIuaAmFmbXjkRpNnYG0IxVFI_WBdnNa52FRY2Alj-d-rc53bVShbOXkkq7QiD8lU0D9Uj0f6V51DOyXUC1DMVGmmjwVTrW22ZetFTp21touZNUk536rDSP-Z6VcGZFRDRcikNPGTtEtdeyby1u55XVl0-djlKIRF6QnbQAK1Q_Jl2UAlXcF3uFVrkoKvlfwfjiOOXFuzCeEDirFhRuUXBvKYK3EDorOgfjLSgtuNbt_BndMABd3JaISvPy_BMwE_Y0Kaikmj1csSGJSwAxNa7BQ15IFqayaGUCKx_d9mpMYz0f7sR7BwxlpTZyS4PXB7wmKxn9m_gtANiaQ9BiqgYTI_Fu4oqa2wGJa49p5EgKQ9Q7i4ILI0AtR4co1hlqA8GfCvwqcGVPTT0o8_CgZ4S2ecGVp09jPKz2M9AigZ4BWOoO9bs9nBnz0C9tPR55Wa9ftMLtBwfgsjKw-HkJX-ESNkD0g9-yVZpt8FUT0olBOyRoUmZ8CN6kZZlHgl6M86cOvBnxKXiLpeNcoBVGt1FgAkI3qAgLZJNUZRrb1YI-2KcLnC-0tmRF2ydipEU5xGOAUR0mvaNXlhsIp46z4PvV-o3CsMFElWcNWH8aU-p4jlrsO8fW8npMwWJaFAwSvQSzmMafev7aRtyQn3mB6vcjpZAFUZW3WhOfVX65uNgDOBj49vsX20Apfe0BV9BQAGl5uOCV3J6gb7BAC19_mZX25RxrSK3oqM4Fn6eB8kDOH2Qg_qdygaY_QPqGF8kFHhBlwPVn3mO3thO01IWWowDkkXBbP6cwU7aPTN8OfTlAL9FsEv3wQ2fXCDztnMKYmrxL8k3RH9mfWf31039k3Qb-V_bu0f2vkPP0P9zASv1F0r_WoDX9XqH9SQE9_Yv0g9SVRNF34__dgCVNbuYn0zg-FLlA2OvkOdTWa7DniKRdgfPGrD9Tfu5jGC8kEmBWQM4RLEAMBecgPdAqA_AOzgFUAlBYDX6lAA4D2flMDmgBA0QO9tZAe_nkk1XpoTkDj2gwMpAI_aOCS5FjjACmJ5-CR27CwOOl6H9NOKBrA4cVU1RQJNXfjWr6d3UEAzAZfYnQVRv9EJyF9BwlJol9BwsXoX9UpEjF6D8Yf_x29iQIogh9XSDhrUaC4HCTADd-GBr5EzfTX12-jyJYOjg9vTYNvCofQbi4aNGiNhbStgNX1FYngyh5PCXwn4Pu9hEdcI_Cyg8f1Cgp_T_3ci0A1gBT17XboNaDBwtEPQisQ3CJh912YiI3C9g2mjJDAgKkOxY6Q7GJT10weX0X92_Dn0NDidOgPrGt_ZgBBmSg0EPuDEQ3dI2VG3hb3tAFUX3Egq80Nb19RbQkd5ZJg7LIKNk8CLdqC4cqmyGXESuSdVq1HKERVLAHLSD7PaFEnNxUSZeJy2EImEn9lAScuYFp4QwqPAjidaufU1R5TpofyDVXyefyScV_E-238LqGCKBm3XZwNxNHYNK431QfRYActIBRLnVlFw6EO16n_EcON4HGIu1rINiP4Dg9uovAhhtM9Ee08E6I6epakiI_AjIjcACpW84vTvJ32JObYOEy5qzeMG4JyDASMojrVU1QAjd_NnnHAx_DNjMj__CqK49bevLn95JRmHnJwWoNT3s9QSWxZJJVJPSNwAqI1mQGaUo6175EvwzFm7t3JgRhKe8qsKArGqw6SHy6pga9i_t4wbBL5EYmH4zgkKliWrWEfgQIBRAXJv75A091EPWud_iObYJIqKbuGPwg2eYCOm4rc6bG5suOYnWRjNXU3sUP3UGMRguw3cwnD_VF4TmJxNZEh4108DjWxYpNeTUsNkhNBiSc6xczjNVu8a4AjAVNuD3zV2tAD2ojJPkHgA9ZbVUMg9uY_mNw9T-eYmaqdWe4Dg9U3fFVKj_Ivm1iQmQPmPwIpY6kBg9x_CoPigqAOD3MaFeLoEiDkw1bXkDU49RiEQ9It7Czjf0Fgk59S4zWDtAzg4QBrjFgFgn2IUQGuP1DOkV6isjJbpqMrBXvjL2UAcvQkb-ENYwsiFjnY9IGQC68NyNKiICLEL0OfI0ePw62DsGOuCEcJ_yP5WsH3U1g1rryLi20EDVbeGoowRmve8Veeggji2G2JIJI4L-MoT6QlAJzcSeDH1TVYuK_rKmqPaqM0aqo_bU6DSSb8T55ig6OBqo9bZOSs1dAE5UhVc5Ytjn4dVawQJ10VewCxVZUHYGB1PjM-jBVibJFWuIFiGbG1VZLOULlV-5cak5j8udfXujQxphM6iZYzL0fjgE1-PrqLSr-PwWZPZ-P1joTGBO8JTclz0wTfscyO-966vUXiJyE-IkJC4SuIkYTL41hN0xOEyRqrqEWHQ6wjI7KTFPdXha93zgEaEClixh-CumU14qHNV3QnDX-Dgdc1SulfaSQKQJ6c-Eyj2_KREyiZagtNVDk4dwFRvxm-UeAsiEh8CP0bm995pvbC9bPbT2Q-v5qUZFTlpZ5y4hGDlli4kyAl16WjoTkt4khBDvI1mmR8iiTNTZYxQ766zw-yM--DUkSVOY6NEIVIWBKT2OIkohK1PriZ9QtM7ArxWkK1TBqbNM7AO0R51iQDJAVP9OfU9YS5dEqO8P_J-AR7AANEahFh7TW_B-2mdbIkXoLDHsDNMLIZE53HJxeRodN_89aU_gHe6I_vFfqhk5FTGTkEy1amT66uZPwTt_Pt6bT2wEN2INQEjDMLIkaXFJixE1eFnSTtOfaVNj5gLwgg4BjWAIrIpPF9MrIJRfto3THsFTq5QCWMtOLIso7TMbRy-SdOX8Z00-QC86I6vz5ERenlM4kiwxTNbTnMyzpH4wbvYIhcRlg0qHdnglgaxuZ0PTSM0YYN5Bvw1bl_A7gkgQrPMZSCPW5XdKs_W5lui8ACy3g2s7W71ut4GYoTyIY8UNJjrbAjoVj3_Yk029A41rDWz_FD92MIPpqONKyIKv5P3on2IEjPIHoCT0mWdY1rDuK9alTYZQl2tyY5AF7jD0q2w3g5YhKrRqqPI9ZIAPho9RHhj32W2PTfaNTDPTYhngfXI55l59PcKO5w-c4XPRNZeSz2gz3huXOWARc3O4MexBnKBc9dcw3NVa3HgZ4M9tCWIq089gGz1HuJc9T09zuaf3OHubHoJ4coT5loZo8D1s4BFwNTZwbTzL5rPPHuC87Z6TzXqLR5tzlczZ5MeFRhIYFz9c7vM7uvPcDzvWO8257FzjPOVNlzR8-3NhGm8xvytz98yfPiKm5vwbbmQhhVrPG1PZIpagHlse7LZO4y_MVzV843MfzShjuaWAP874Z_zSVoAsbzs5id7nYNc3nCXz48zx4tzaC3fNgLmC2fM5ws4rgvHz33IbVALN82eCELRcMQtY8ZC0gtz2qC1BNUmcC5gspW7QFz0hG4PCKNHu9CwI3sAy83IYLulfAIp_crVmvOULS8y-YzzQix5b8Koi3PMLzBnk5YFz4igIuvmMDnIvU9CixIuM8yi2YZlzUiyvMyLIi1oviL6cD8jGApgOYBGAbsJhIgZsAJlqXldgOdRrgeXMLLew1cEcD7AcmBuhWNJtgEG-LqQWwGZgHAQ5gYqKCNZjWL7AAEIg03oBYDAA6rHhBscEpA4A5aQxp4t7ABTkcCBLruTYsxL2sHEsKQiS8KrRjVgNb45LHgS6ChLhTgQhYJvgOdJyY6qOYDqsnUhUvqsMY1EsBCcqgksiseEDIljYjiy9ydS7NLmXCy5S06jCykwGkGR1V1CRlFAPIGYBzDqdCeR2LJGYMvwAxE1BQAWJS5hIc8ByYnQwEYJh0NbL3IZL4NU0kdZowES9vSY1k0lBX7ytWRhgBOLTkWWEYlmEmTPpqgFViXYAlynPw4URy1yGl-9aIiM4U1y4BUfkVJKCtOYnE5ctOoYJjwT_L8JrWBgpNAFcsYAPZE8svc5Q6zbc5Qs8aILlC6i9zYyli_Ms3LFyFTZGFNy_NzmAZJEV44A8y6Sv5LmQLKAKQoiUkvvFMiXyoYaeS7EssrwAG40EAeEEV6OAtg6mQkiOEG71FDLtG6BheTNN5BFejK7yvxLbKzLjBA_S9yrFqqiNU7-jnS0qtFLvS4CukUAXZiuTw1jYVKoJNAuMtgU_EIasSkhIDpgy091Bsbcr0S3qt5hH4nhCvidgOqv4iOEDdKRD2KkIAR1MpMkARL-BTysFLfK8UuAV3q9RhL1Fq2Eu1L5wAya2rsHWBSKrka_Eu0SQq9DKGwNrhMw55JTNJjJAPmNWQSB8sy6Bh1eBLzTmA1mkMZpr-gIyvdLxNX0s-rNYDPTE1wdbdTak91B1VkdPqgMxyS7vlHPzLvIGxizQ8w43jkrckq5TAFX7HJIir_g10hW6jurcyYS6y_bMKwEY2cO2rMBJdp5r3OjGQgdaGBhh--62lOt8sckvokvtUooTqvC7va7AxrG60Rjn4ObXdOzZYxB_72BoMI4ECT7C5diegGAGll2AAq3o2Jw_UtABcKXgXLELeo4MmtTghxXyLWR84PbQhQv3TpNySv3eGOy5qq6gD0h3Ia7ClGC6_etSru3uusmrm60Da5rS6ArZAhCQBcjob8kHGOvUxbChuLSGNfDUdLNphiWYbjNRtPY11IIxP-InVdTUoYr1AxtBj9E0FXdjBY61Vq1qScJtdVbIs6sh6r1ZsZu4Mm8HOuAtpTy1JNR1MiaXroY_DXErJgKSsg0g5oZsUDVarvCTwbUrStDrPmDPR0oiQD6aEKHYMkDGYNo_SvWLGa8yvxL7EZKB4Qmm-qWBa4Ew5jdjvq90DITNyzOqTRRwGzQOYCEqht2AGjCDAhLoROVJ6gesJYCHM14I5AZ9QZZFu-bhSz0sEseEIBI0piQO9KIxbvCBsuYDmIBJgyGmMEune3KhFth1lKnaryBtIiJBBRuYOSWAoS0X2BuzHsGyPehuq5msKQAq0KvEboq5PDsiQ65KsBD_ELKvqzRWxNt-b-q2Vtz0kJCNs7AqI9RiM20CPNDxAZUCDGapzo6iq4iFS7lzzcUAKaDoAyQM6tWj-uJFsY-SsYx3kRujbnmdL3SwFuCrba9RjObrmw9vmYGQGkCGNI0-wALL46yJCyC5m9imYIM68Ft3dx_OcOVb70res7VJGwEOkg4ZHtvbAhYzGSncP2_T62zYA1n3wWGuMOOVj1Q3eNabZNoFqWmjs64BDj7gLTsg9SwP9ucRx9K9JVbOjESTn43Ow8pATrgMRFz9U0AoOyqC5VoSjdgxsDsewfY992z4BO-D2i76O29I6MWO4usPreO8-Sq7-k6kkbeCu_tsjT3GCStRLyu84tUrHmD9iKYnUvZsw6G2yVvFL4-bGv9LTiP2pWdouf8rB1XW8OBOrUcy9uuYP8JsCh1ulsVtRrBq6tvwgOJLl7rqnuwcDEFF0HKtXbskBKhDrp6l0AO0ZwliB1b6qn7tBAn2-4HOrke_EvTbaKdGPKwZeLlBkVJ2xFoz0WUjdB7tGUuzSlSZUBatWr-gIKY2LhK5PCUqUtI773UPSFZglqw4LWVjbrgKOuLLE68ssWzWpS-2uwMe9KyHele5hLV7jeDlD-mMZCsPIhJpr8uee9w6T5XFbziRPqjScwybajXU_QwnD_yv-CeDj4OaCvgJ-zkmejNPn-UKmAFZ6OLtTysLyLKDSr_uIjulreAGlgEaJlS57QhS3dCq_NfULeIBxuGLFTkeny_7G_hPkd5i3oiUKTIEUGMvL7WhAcfL6JVLmrTAkn7oCAtxBfDyQKB-PmfkYa2MoYdXqFBAxr-G6X77rNG4WD3omu-bbXDOfNsxPK5B3JiJJHKG-v1LgpAQj8HaCv6t3S6B-YnL7CIKrYEHjExWsr7ckvNV4djqtblFe4kJPCjN8QKDuwdMNIrBSYSUe5iaHwqMAeJAFyFi1S5IYZtEX8enG9DAsnw7Idx7ESI4cfq-mkV5tRx68JucMZ6zVlt8kW3KDs5qe1TY4AbhxXimHUM44dXAzh6EeOH6E-RtZSZ2lHNR92ExEfmHlh9QfYrnh4nGkD0sd4eJVXDE32RwkW3BKxHckmEdHRHcQ2ODGQLGn23L0FMatJHowqExde6--BWb776-Dh0xK0FQfWHRqq0nRjG63TFIz7R2XhWHL7bAPq1u6xMsbrG-4CM554WEodUJFeHUdwgDR91RNHTi0nh0rT6xRttGrrX9AgT0kUV6drxy8saWbltT1VS5wOSnvqzoR8Ks47y6xEeejOx4kdOL8x4hN_QDdVSMJHjR38ebHMMjRs_x0uMcddSv3dke8b8NWCenHjNVJvioUECps3HE4HmOybB_hhXMT4qxzjvHL3Acdb7-s1cdYnVjDifJHvRnfy6AKliX5Grcxx0cdgZsWbF0rrIwjvTrsAISdglqJ1psoTFW5wdO8mGuUfahs20uupk6ExUc_b66mCf02Z1XTEQTTCzQv0eZCyhOQzPx4fGbGaGlHMh6KE0DZySKE65O4THcY1WIlnknCcsb2B5xvZjbNe5xgiyU6nOETl--lNkTRemHNySEcwcdZtIR8N5g1nh5fwVHbh0w3EWp-BbvQ7bsEOvnU1gK1LqYs9CYgvArnea0z0DgZocZSaxyDDkdboEZCoAi8OyVHAPtHDTs0zEKSthn2IIGk3LHmJoeEuS9dZpnYcXWSRTT0O2XtTbY8kFt3HsexSsz0zh4EfIKWiHDRYAiQERCFgGwtSs5Ajh9PvILhoLPvMgyu26f3HKhzvsLlV-4rndTatUDON18UN3PqJvc3J4DzOcNAVQ2o7Pye8n_bQpM2d2lstr1N-ugAekHnJVQ4kZx54QS-78kMLvYRJWEecXnzOI8VYEMB3pzPnoh1QSoHn5HF11x2HbqXn4X55Uq3nLsK2NNURelbtl615xef_KzGnufGEJ-P6dmAgZzYtdAfai4eTwoZ7o0-KGUlGc3AeKpWptSE-wmd2APMymfGgaZxmezg3StmfeYDmHmfO7Ue9tuOH7izhBheuQFwDulGF8a48iMOwwu8XFIN165QbF8D5lGv3FQvoLr86Qs8LVU7rpsXMPiOdCHXJAcciXlp2uYgzsp5wuiLdC0pcwkMmN0xEXwQAKpEd83J2AcCRwJ4E-YNnTPtw7qdNWRlRFdkKD9dW-TOcbec50dUohkYbZjqrdaxSRpcqRG2cLei7Xud_jg063ANKYVy81KC0FxMebGi6U2fKHWIKt1N2eIZ2A3noUuGgBXNy7eayNq9phXXF0bJhJ3tp_rQfEnjRx42SEFvXnMyX6lQE1NU8EeOpFl4uJejb1IQDcDFSZq3Or1bqKl3upBfe8GqzLcsv7WtXsxNqTeLgkU6gzYNnUMcUbHxrtR7r9i5MEUbbJ8kswEbuG8uVXx-Bxhx9009qr_nWcdN1KCjlwkDOX9kSQ20afzWleNTPM5lcqlgU4dVAOUp9HZlT589Jd4LD7g1eAiQfVZzCzwkGhdZYwFFeQEblK-a2TX9axUuz1gOK7AOqKyNblBQJmGHUON9o4U4jrUS1HXA02sLjTaxWS_WvpIaQKNeWrBIbofnST20Hv0CxUtqp1npW_BBJLIN6X6pL5gSdgzA5oHI7roSRBau5enW0XtA01ZHhhM5S_C6v_RzSyKzDLxTGNvFe1i2OvecSy8yBAUBCCBSYSmyxsfchyw7Od77RDgfuq5ZDgNN78P-xefv7CuvUo8kjSt-fbEnA4Ncol8B1ldScFZA-c4Rv-6-dQHizasbEHayqQebxF5_FerGreX8uNHXt-bdoK5VzGs7TBwEVDLXc180eB3oF30GzXJJ5yXSR4xpHcJ3Ok6styyG62tcM3pFG7ih3x-AGOPLzR0c2-dcs6ntsnydyRlR32x2LjoYckZXcJ3hOWHfr9Ti2KCxBJd0sdl3NdxHf13jRxutu4Fd3LJV3RK_nfT15-INfF3d_OFSilzR63cJ4k91wUKU5uXcUOBz24NdA01Z0R3NAGqHRGStY2EufsiWly1YYL9CZAv6G38z4ZcL1WgAv9zENrBOp2dMXOs1boMCne93FGyhODXs92R3YT6M-wMWJ49xZfz3-zV-pW3vJegA23HdNQdHBFGxPe_3R-PBRW7o12vdyz7_YvuG8eADSdHNOUA7clYID0c3gPpDHCRu7aDxg_ClJLTNhF6YuNBdEPuICQ_S5_-6bdhXWJR8egP-Dz-RCzJm1YtBnYoNcopb4-iBtHAUeM_bUZp6gfAb0ckihUMg9vWXv8rDZ_y0X0DmNvcqWqdPQzSPKq0V4SPGQMkDyPnpZ1Iz0G90whNrC5TI_TyeEHUVwAZ4AKDSQxTRCx46tgIJhGwNj89qRw3s67D_5kW3cHRzw5xyi5wax4kDaWPGqj6RbGj_b3MHpFAn5MTyRUVec-9DzSRm3sdxbfSR6wVlrCoOFOE-59ZYRyhnBSBTMedwaTxCt8tA4i4-4HR1Ng-MtXhAoeMtxU8xNvFttwOI-3vuYQ-GqcXVVGKjTKf3l0bBMSFCD35hwX7LHuRuo-SP1g2xdnFbh-VBZ2aqcN6vDGe34Xenrh5g1cXQUyWScD3agExcKIlyBFdPgxz0_OHIhdrhXH0z9TWaHWI6_iingWhG0iE17fsv6AewVsrPtp_ooGcl5-Cs-QbOkvIdkP9BxvyBAKIBSuKREG4KoI-ulsCuZYhT0vz3o2K8pvNXk5II80KWEo3GltoL1_y5oXzy7PJoaO0E-DPXRlsGVZ1fti8fBRcjwk91eK8k0IFhBC49ig9IJqWlXu8C4-7PkYLC0UkLj75oEINL9C8jU04fi3_NNuXUsAx4-rLQCBo1Kgn20iECsGyC1S9YikdSzIszJ9qHMixW2LwOVKwlyLHy9hAAr0cAcK9vKnMZ9Qj3YApYar2ObSvcAPY87V4-ga8WP0CKinclOKQi_kvb7Mn0OQzsC48bNZT2S_wAb7NQQS7Y_aIS2AZr40k_pWXvnmRqpL9a-uvmpSN730o9EQUkqJmKvXAbAUnQFd9mrwOJ_ZW9BfByxPL2hy5QbKicAElcLyvTGgOrOdJLA3Stm-lMf5o7IPYMJPCqgo1K7B2MFsgi1isv2pHC-p0HZxpgkX5Qb2jZq-UjY2rAo1OODdr4wFFmsB_QAtEQxYWDBwZvNw1101YlEwUFBv2rza-Uvg-zLStvHmPkAzgHFyG_sdKpwIAuvFLwbQgvC71u_pPFZL9RGxbUtGHqvMQJq-xv-KvkDNII0eK-7CjUvUWI03V72_YdZ79Mub8ByMHX_Rh-aqqGwM0NqSNv7AL4_pOqtOm-yvnA428g1zL8G_7vcWAi8VkwFwi8Fqkuz2TmPljzyl-veeXkctXH8NbpxIL2wHHOgDtC2rpSW6CoNocIGwMwOYJHTmwXUmAM2UYm4-tkBFPX_dq-0vVDGXqScH3Nfyb9cvsG2EtbH3JFof7z1iITvSr1O_YdM7_h_zCzjwi_4nFbreBl6CL0sC8fd0B9wSDc2pOR2PY5jY9_ain1x_hUNA7A9y7NTyqUMvCH2OJdHdXlJyXG1n0e-IfUcfptGPtND6_5CtNI4-00Rrz5_2vGAC48nD2UznNSgY57WvkgZB6HFif2r9QzreYohb1qLq8_POULt98nY7nFkx5_YfjvK71UcXCjY8txNIrtesaN12F_2XzIAtTezeWNpYHPwT15-AVaT-rceXmt0kWkth-7rcC15VVsPCqxTZ5_WPW-r58GfA3wF8xfML40XsAPj4M81fEdN0ZQ44jxi9Q4qT5zBS3Rxyh9ZR474Z8AXUAZ8VHt-6s1Q-jAB9F80ve7cDjoamdE3cUkfWOKPIF1x1lcmdaWBFHxxoTJl9YiZpay2an7jwpJvfp_rBuY6Xx7GQR5am0y2v5_vX7FnSDJkD9m3U4DqfkPUdsuRNySX2IspfNTW7hKnEZUwhA_V3_zerqWH-a-O1eXzpIFf3n7y9bfIGoa9Dfk71nFJ4C1Pl_j6ZaFJ9WBVUXXXGfMLxNU6beHwzGw_DNk2NRfjsux8Iv1dnyJnMoX4MYLUhnPz9CPupmy1EHd3qVPxQiPxovyLZi_JcuuzWEH2P3uEEpcMLPP2tTuy8tVRwS_b3cvay_NFpvZ6Lqi4YuCLiv6YvI_Wv3wtl2mymI3XlhBI0iJ92d3tSrmVV4rnmzRDu8oDG5-M7_ZK6dNO0-HSVdw1RgIAP4Q_roLbjNH2ht12alv91MNj8AEOm0-Wu0kQyQcE4GHxB63ogmeem3gB5y8W5jUpNM3Ji5eS2CR-2oH_wt-_VE-rGG0yEGLtmf7O3N_VBNn8au1B3CSt_7Rvd95t9UgtW-HWGO0DGQLfbfuLPL-l-UZXpBzNNHaaA-79VET2LO9XTn0xCRHqzT1wTDlcdwG0041f2gqHXMnwpSPTjeE5e6WjkC5cEIlT-lgYzN9et9A7KJGv8Btv05Rlb_I13t9_Q3f8Hf-ST_0erGSUAclSr_hqnnScgk3-_KW5Sf_x22R6geewAOf-9z1mCAZH8oblHv-iLSD0gNG_-yAN1ULalK6HtQ6aoHVPWQ_xcIo_2FUOyUWg-KiQyjqXScIAL3-JGQ_U-9xtch91rmdV3oS3HiTwaPz9iokl3-8Mz9iNnRhmD_zlkKE2ik5fz6CxkhQm86R4BgAO5SKEweeYgL6CDz3fuKAPigHAL1MUeG_uIU3M-emzycAPWI-yEAJmNZwJodyhF2H_2lGsQGdQFTw_-VT1Ho-ml3-jMwfA5xRhSrMwOmAAJfa3w0guSgjuu0_zMBV_yJes8h26I3CTQ8KEZQdpAAgR3RjcO4mXgWKHXguKC2U8liK4n3XlgORkiBGczsslzEw8WilxICQP9m-3X26NKFZQ6ZUkQ2lnSBNiheQPJFjmbyGyBiKC0Ux9l0sBQL24JQPZgQczMsKQMkQ-tGqBZsGzEvFnzojQJw8rSBaB7oDaB6Hj_AnQKQQC-nmgPQNogfQJjMNQk6BARVRQMwASBdflXgEQICBQ_EPQBiiuA8QKWBWLEI4VgGsIkQLo4NJCuA-QI2BWbFh6WIAOBJwPgAuwP9YdUDxsgmkuB1YDF0zQKOB2cgwB80CuAwwOoAdwLgeI5y-iLKERQDEiQMoyBG4Y3CWB6CmlmoQKmAjkD5QS3V7Qu9WiA3Skq4BChHcmIB3AKIE9AcAC-AJPSMco3EDw5oDAASQFnglAErK2uFhBLdRCUfF18Qa8AiI8lnQASYHNAfF3cUeoEkUsdnvcZ4Aes6cCWAJcEB4cDhzgbIOCsllWvcOHl4UOgn2sXXEryfIMBaKHjNm1YDSsYNmSsViHxsn1idc6wC56jrnXc6wG6scdngcgViTsFgBmsTWmoWmcCeMS1isQp1hFBh1iSs8oKiMr1nusj1gas0tnJQMiD4smyAp6XqFNBu9h64zXCME8kCJgQfF-84PEcgGUAFkdBizSZoKBGRji1AfQFIQ1ACuAboPOsHoLushNE2BC9iyQWOhJBickDqkIL6Q0IOJB6GDhBVDEhkRjm5cOjiKkDjzeAsQBSgv3n1i8QGNoQIzF0KGGzst8lG8M6HIGRQnjMULG0gM6ECA2NydEejmTsLwAKgrYJXAqTjwAVwBl8wfBXA2TieigfF7BlOTr0-nG-8FgGV0euE5BzIITyrIMoWqum7My4KZB3IPXB7IOJmEJDl0SYBN05gWkEm3F44pXx84Ngjlu2gTgsSwRGYqrU5CXyEFwcAGVSeIBVUwynVS-_U1SCoLtB5hky-3S2NS2zBv2YuDF0ASmZGbuC7MNZjlw4EJ3O9jmNAm_XyUWAG10VkQbMkQF7MVwFghbFnghsoAqgefDV0KujFwDJHV0xjGTMhEPQ6yo3PSo1BlB4NgAhRjyAhRSn3O1GEYcWEOx-FEJpy2WVGoKoMVBlgEy-V50RsoeXSaCTFz06fFYhm-0SSgELomwENm-UL0DwqPxRIcujIhkQFtKYQWhy1EKiMcDgTsCDl4hlaSueNAHNwRtxgY3aCnQTdxDsUiH6w3DjZOSEJQhk5DEhHYBwhhhGs0BkNMEdkLv4kaA9sEqmowLHz_kvNkNK0kOEhckIYh_oMDB6cGDBwoL0EbuELsk5AbBpaFqi6mDbS2EJihbSVDsawVIhBZg_63QEwh8UM5GSUM2unQ1RooTFchT_SLMn_XToqUIChFtF4GWUOGUOUPyhKkMywkkKHS_kNR8oEMChOkTQh-WDlwFNEQhgJmQh5EOkIHUIwhv9lwhWRQIhykKIhCkPbBPDCUhFuB0iOWjPBx-hjBIYN3sleRwAI1nqhlELUh3QD1Ba1kNBi1h46Pw3c-QkMCeA5nHMNmmbQ1UPmgCULLWiDGvamqVjBXXCOsdEKGGWTRv2KfSkEfdleBUzBw6m0PTCP4KtB9rltB7Vh0hDOiOhzUORookOyhO5x-hHEOb0ZOUtE9GgXKKj0tcIszgUgILDceYixA_QPqq0bjBBh6H4AObGFC_AAD4ViH4AH3mJh7AH4AhAFuA9wEeA3YxPArIB-wJHSEsqTEkAMoV_E8QAkwbfRSA3PFTQRblzEH3ilgyLEkAucH2AZBUkAwACigKHi1gOwHkAEsIJuMAHkA0WA8AYACWg3Y24Ab6gCg6wH4AoUH6AtAAphVMJuAdwAeA8KDzGDMNeATMOUsG8lZh7MOzcXMPCGvMMLcSILtSusJeAsCCiAwsP2AIiH7AbsJgEIAFJhIAHvCFMJQw_AC3KO5V4QfsMy-_AD7E_7SQglwSQACsH4AbvANhIABjhHsAA6NKhAAmvxmwOsLNIwcMphIAGThCcNzhKhH4A2cMyw_ABYo-cKThOjBThVcKzhup0rh1hGrhhcNrhxcJAAsJAbh-2GjhXHFxBAKAzhLcKLhVwB7hOTVZuxmBKCccMzhMMNj6K4DJhD6j7EQhQThMMBmwUEH4AbtXbhFQFoACQDdhAUALhYmRThbgC3hDSUZAXcJXhBcPXhw8JAAiEBUIeiD9hSwDXhcAC5SWSAphb6nLhY2FXhKgEzhl8OrgEwCvSPgxlk_sPPhj8OO21ABfhEzCGo4jjnhDoWc0CcKaoOsIISwcLFw_AFtSiCNCYyCMDSXaQphy8MEA_blZ2aiQ0Sjc3cMTCV0S14HCcOACJgXIEARejFwREYGj4dCMUAQnxAAreRnhk5H4AD2VQR66jYRkmDqyIxCEAXODZuXAAmAWCMRgZCKJg3dQsAXCLyy9WQGy_CPniWCOoR1cFoRDCOURjCPvhOCMUR9CLoRlCPERBcIey0vA7AEADyAWCISgq0lG8zCOnhxJG7hIACTCHCMWwkiLqytiOlw9iP6yqIEGymCKXh_AAAAxAzQwALvCvEbL5-AOYjEkrdCv9NrCWYG01YEbPCWYFkBt4frDIkRXCO4RHsPEawjrEUbDaYUxACAAlATwMIAsUqzC5eDi5EgLvBuAHABeoFgAGoFgB5AL1BEgA1BEgJUiiIA1AiIKlB_YUgjUkTTCTYUQACAIjBskX74IkJ8BRuAQACkUUiSkWUjgABUiqkTUi6kQ0imkW7hDYW0jHgB0iMYItIekX-A-kfkikgEMjSkeUjKkdUjgALUjeoPUjgAI0j-ADNgokpXCJ4CnCSClrCEkUV4YoHFAKYT3kUYDnCQAITgd8M_D24dIhT1AABKxGAaQWgbsAKHg5IsULfI35H-8dgC3WZwAZQJYCSKM8BQ8BoBaCJ9CuAPUA-DWIB2AAADttYD0eYXm4A7QGphxsMeAIwAJR3SNyRfSKeoUAEA25oFYSucBcsMPSgALEG1wRADgAucFrg-AGIAUAHaAYgFcQ1o3z2bSCNgUgFcAEgALScYBAAXvT-gScL1cIxG1gjiJrAlcKSRsMBaRuKPSRtBF0sloBEAbNyOcuILCGBQHNA_vERgAAHZIkHMBQoCIA8kQlAf4LpZRwN0RVkHJIloCMixkTsi9kQcijkcKjMsKciO4ecj24Zcjmkdci5JLciT4VcAHkSKjpUSAApClKiJEYkiYdMkinEa0i8UU8AFvCqiLQFEUioBqjuYdqi9UQai7gIKA3oKsjTUb99LUVIUzUbAAbUVsjxkbsjJkYcimkScirEaaEPUbQUrkWNgZUbABfUfcje8oGiw0dfC2CLfDQ0QXCg4fEio0Sp05Kmp0M6BvCKFEGcD4O2jYgLfCfVCZgwXJ650kNsBuAGZBjkYNQq0e6jL4ZUMl0b8QZ0D3Df4VYMu0aHD3wl2i20Q-pVOnAAqKgfDKFmeBUeEGdpFPqAZSP1g_4aiA1GmcI5MJjdMANAg8ABui_6Cuj5gCnD10c6jN0VEiBQA0490YHCD0b2i7EVfDj0QOjT0UOjL4XC9r0TIoDQCMB0AEZBc4Cphc4FrAucEyijIHfCWkW-lj5DAZI0byIP4RfCC4UXC34cRjz4V_CC4chjGIpnC1EfvD24dzwtQN-5MVGXDdTt8cqMSnDDEeQBUALnAVLH4jg0VRkU4Q0A2kPYAFepBhaAItIpHqfDQmCRjqMfwBygPYhc4DkRBMYxjL4X4x8gCkAknKAjZMeup5MRcjaULnA8uFPs9MZRi14QpjC4ZQAMMUO92MUngDMRvDj0EYizMdLgHMXBinMYyjCkXZiK8G5iC4YtJWABhj3URRjXMVxj24VEAZwMZjwgB-iXMYthfMQTDgsL4iYse_DQsZfDbAJQAkwOxixcK3lG4W6if0e3C_0a2ju0SDRQgCBie0S98_MVBiwKoOjz0TnAr0TYsb0UhiUMa4Bc4NQoicEHFc4MWpsMf4A60RBj8MePhI4ZoQfMSliyMW3DgsbFjhsfwBaMcoh6MXvDhMUxiWMRlA2MUljqMHFiVANvA-MQJiqEUJj05CJixMRJiFpEtJvMXJiJsSAAlMSkAVMTOA1MXNiNMfAB7EDpj_QMtjOMRZjDMTMBjMaaAjsfpiTsehjMMSfCxscljnsY5jIqh9jzMZ_CU4exNPMWMpHsR1ATsf5jAsXli_sStiTseFjzsWrhosQjinsaDj8sQljgcSFiAcalj_EBliG4VljSyN-i_UQXCCsYG4okUEAiIKViwMeVioEYgAT0Wej24QvNL0aoYCalUBc4K-8PqLnBbehOpecfr1c4H9QPAEeAGIHmDjTD2BzbPZ0tdnKBqcYgBFoFmQiACpBr-EnBs9vNAucdLkEhG7wkVJZhyIAUA0MTLj2gHLiFcRoQlcc8BdbEol1QPrjr-A1joQDAAacV6i-0Q-oCMQNiYYKtjyMYxUScU8jq0WujZND1jRUc8j4cLZwHsZfCzwGeAckFhJlICogSgkEohQIUB_0ZYiokfAQjYN1jwMQHiysV-oGcUzjYMQXDWcXVih9H9QqGGrjqADAdVcTHjqABrjxMIhiy3j1hjXP7jqMAziXcVgjVscXjF4FPC3UKtjGDCTQoeF1wNPD-4MoOxjssaTjf0X7iE8SwiA8dPBaAEHE6UM6BRAGnig0Rni2RFnjoMczjL4XnjVDDYsD4JPjZIjPj3Oo7jesc7j-sfIjjsXjiRsZSIocfEsTsVNj14QxjrsQXDmMaxj7ajjjxsafi14etj-MdEArsTtj24aJjxMQ4ADsTJj0cdDjX8adjbsedjVMVtj1MQXDNMXdiowQ9igCZfiQCUok3seKBn8f9jMcZfDvsbZiL8YnCMCQXDwcWgTEcSATwcbnAvMTgTVsbDjq0QgTcCaRjQ4SjhIsUIjyCSdic2OFhCCRjjaCSoACcZljJyEPjvcaujycaPirES8jj2DvR3kd-4sJASiRgA7gp8U7Jd8W9BZ8Z-jx8UGiBAGAAgoLTiX0oeiKsT2Js8TVi2cSSoBccpD9Cbb0hcTAARccpZxcasAwKpzjX3p0BVCZQB5cYYQVCQO4y8XriIsTYSVCUFAHCVmQnCTrjW8RrjTfGABnCeRdaUFbiIsW7wAiQO5bcR4TKAPXiA8X1jS2K7iW8YES7MTQTLMV3jiaD3j9BH3jkeIPivcdcj-CfFigyooSxsWwjXsdET1CdtlNCcviqsTBjdCVeiecXzijCYLjhcaLiVLLBgOcR4B_CbfxWVBbjAiVXjb0Z5U4QAIBc4ORB4gC1i7CbnAbAC1jivPvj60ZBiexE3il4UkSPACkTO8YwkMib3jMCujwciQ3DeCfkS8sb7iiiWPiSianC9pGDhxiWoT58WGjF8XhjKsREBqsSziL0fUTNgAYTp0E0TIgCYSzCWLiLYI0g5KtYScgLbjsIAyBzieUTjiUoSA8T7iBCUcTCsfwA-8lcTu0XTjM8fMTGcSvic8fAiumpvi3QNsBtgGUTy8RkhYiUGj4iRHDm8V9jvQKZjNfqkSU4ekTMiXrV-8bkTl0XwSDiVCSLYMUScJsgj4gNsA4IOrB-MZUgMgP1I3kVHDQMRoT4SUejtCaiS6iRvj-iQaA70JyTKgIyjRIHyS4CQSTRSYgBFiYRUTscB8oAAbjz8RSTVsfjBnQKsSTsSZjc4KejtgEQB6SQgxh8VjjoSZTiM0PwBQ_BUFd4MZjbACBjISYUSWSbMSg0SFcl4aYk2SSABkOI8hc4H0NXSQUSQAH-iq0bKjBsSkiFUSbCAyVENZgBABOsBzCc3JqiZwAW4CoHHgVINIBj-FU5wuByVZiJ6B4siHA-hgWjYEOWjFAKMilAKWjiiRYBfSVuj_SUWSLsVQBHSSGSmSe6TQcp6Sw0d6S5UdGS0kbGSiyQajEyVm54gH0N0ySL448dmStYLmTVAPmTXAIWTu9oBtmyb2hSySHByyZWSKybUiayewBXUTcSUkUSTCMeqSQCXGSNcRaSzEraSA8XGTGUQ7QZgK2Syce2TIcRGSI0T2So0TGTHgJeTByUmTs3KOTU0JmSUgJOSKQCh48yc6oCyZeSngCNwFvBLDGkRWSKkRuSK0S6irEbuSncQsSj8UsSTsceT14bhBssTCSGyd3sRieqBbySPijiY-SZic-SIMa-T5yV4MEyZ-SRyamSUgGOTfyf-TpyRgBZyRRTAKeRAVyZBSqyTBTqyWCTtyQhTESUvjkSWqTNCKtj0Ke3isKeeSg0ZeSmyWH4MgLnBG3gRT24WqICSWwiTXgnC31FYjFXtrhKIH1DIgBTCZfFYjc8iKSC4W6SQAKMMWSss5dMTMjwALrIsERJSAMXaScKYGTryfJTQXopTL4cpTOyboi1KTl8nkVpSMgDpTzcPpSZwQ3jTseyNjKWci2yWZSDhGMNLKQ9jrKU2E7KbA96ydJTyIK5ShHu5S_MRllyhCpSdAD5S_XppTx9IFTh6AnCDKU8ijKfTjcsXeToqfGFYqephlSQXDEqT6TkqVEi0QLABKSPCTIqdVTPKYZTwqZVTTKeZT2BPVSvKWGimqVH0WqY5S2qScg1LAGtMqWTDsqdUJcqRVSkSQNSYqRZThqQlTbKc1T2IUL8A4YvDSKfEsnkRwTY4ZHBcqYhSIMWHDhqinC04TsAB4bxScsaZSTqc7Bcqfxk58ZVShMqxF8sXMt7qVYiEolUTU4enDJ4e4jL4Z4ig-ElBCBluTEGDOg4EXgSdYTEjj4WdSBKS0jLqfZprqb3CnqfHC8iXMTTKZ6irEc80N4fDSd4V5T-AK9T_qR9SAEWujvqRNTvjkdTLMfK4JUQ-SnkedS5iSjSktGjTR4eaAMaZnCsaaFScabWjiaeEiQvCnD6adkJWSdDTaaWjSd0f_DEacKTKqazTeEOzT8CKzcuaZDSrSZfCUEQLT8ad_D70bujNadGUo4u3Cf4XgAH0TJjfqTxF_qbalgaVGTOESzBaADeSRqTWBsEaeBBMW-jGCToivEQlAYAEmAzIFZBzVA7SLAGOCQqVGjPEQlBXAIjAwAFZBCcUngfkeOC0ESAAQ6WZBkYETAiYA1SLAFHxY6TbSQ6b8iwAGZBTMUnhYqkHSIMaDT0AAlAPAGZAo6RXgfQRnTeRP4jXAAlBI6SsT_adZBZfEnh_EVjAEoEmBEYKnT2ALqiW6RXh_EVHx0AIjA86RXhpwYXS5iaDSZfP7xPaVuTayQlSMEcGlO0nIj24T1g4IEojRvAABSVGBB8LemjeShHz01NLzpeREqAGEG5guJFjjYNHrwSVFMIi-kmQm-kdgpsFcTVGD2UxPEZoGGkcEoDFIUAWnM00Kny0-2nuY0uE_UxknVUjWl402bQpwz-lz4sBk5lAhAQMtM5z4wrHv0yzGQM50osFGWmVEiKnIktoJ34jSnI02YDxaK6mA4tgiq04Blg4q9JeAIdHQMtdphY-Bm5UwApplSHGXwyBkvU-DL_UwLIao2qQpw4ABu8aZEtI9hlSw4-kigX8QiAYcA6IXqLG9O_CBI6ynsM_IB3I0qnEDM8kOUmmkJIj-nFY9BnLUwSl_0sHF5woBn7EkBmBpOhngMmhnawErF60mBkGPYxlogMWkrgJBlwMkxmoMkajqMvqlIk6Bofpb_G-UlJFaMohmxAEhl6MshnXpShlPIrWlFYkxmGM8xmggSxmmMqxGk0zBn8M32SWY7hk6MXhkpI_hnAQQRnCMnzBiM4cASMwgBSMvhkboNyJyM0cEKM7IZjY2xntw6nFOM70KYMrxkAM4hm6M7Gmhk0BlBMoxmXwyplmMzLwMMlOHtMxBkS0ipn24hxka8b-lI0vckPqbBnuMgql4MmYAEM1GneMv2k80iEmhky9IBMsJnUMtpn241ZlOlA2nrMh3HRM1hmxMgpmyBBJk8MhqmVww5lpMjxEgAIRlROURnBQdgA5MufHd1M5lmZWRlk4mXzU0jqB9My-HJ4uvHDM2WlIk2pn4EnRkLMr0lNMgxkdMhEApwn5mp4qhlbM2Bkr05xAp4v2G9MlRmWY6FlwAQZm4YhJE_0uIljMtxnzgMBFYcTxn4M3sqEMupk-Mhpm80pZnkM9DCbM6qnosulldMhFkOIJFksM6KJvUlamHM-JlcM1vFwaU5kdw85lf0uVFXMjJm3M8RmQEPJkpMgpmvM4KkfMw6mosi5F2EqpmmYuWkks7cpksoFmAMkFldksFm0xCFnVU0Emws-rLbMguGgklFlzEjgnkAMolKsv5kYM1VnTM0lmzM8lnzMhkl-M9uHNMhJHBM0okXEmIn6splmXwq1k-s6xlv0r5kFwoElYWINm2sjRlTMmZls0uZm-MxplRUj1lzEr1mnE4EloASNlGs_1lhss4kZss1mSU-VkWsyzHREzFnKs_6muM-TI543BnEsh1nqsp1mas-pnaskynUslZn6sxVmXErNkmsvRg2svZnssthlcszhntw4ACW4lYRhEpJn8s1JlCswbEism5lSIO5kPMyVlRomRnXoWVk7Uspmhs2Ellsmplqs8OH_0htkUsptldUlOHJs0KmpsuEmds-FmXwuEnms0KkcEqyClsqNnOMwSkVsnBlLEaymAskuGNs11mJs6qnLMihl0slOHnslpnhMxhkFwoDkJImJn9UgdlFQLhnm8VwDJMpdmCsjlnYI65kiMudnisyRk30_JkvMldnyMuVlgiEAnb46fFckvfH8U_5maMndkasz9kHs79lUspNngso1kpwojmyEkjlQM4DmdMrtkgAZjnZAOQnBs5RlFspjnPwHfGsch9lkcu1kuMvFmVswllMQ9PGUc-tnUcl1mWk0hkbwmlmBMz1mtMguHcclDGscxlmccrTm8cgWmQczllmZI5mwc8dkO055kWgARmXM1DmZM-dkSsrDlSsnDlFMxKAlMvtqv0_jm3syzEykrkkuwHkkZIRUlvIsTnRsmtmxshWnxsylmLM-jl6sxjnusjkm-c-Um8k0jpKkv1mccnzlyk_zkMfFLk3sgPEcE9LnckhUnJcrJCicpmkjMpCnvpKTnqUt9kxsx1lxs51kJsujm_s1TkAcuLlQAWUkFcpLn8k0QkXsixnq0-LkZcwrldcqylPIozmCUuJmDsy-GSw99DakxWETspDnpM2dlZM-5kOcp5kCs5zlvMtznEaddkKsipmNk4MmPs6pmVUt9L1wjxlRoj9kCsgZANcqLnVU9hFts3bm4U_bk9ciJmXw80K5Uv6mYMvRGZAFgDOYyPjWUvRHL0kGmOQM8DT0iHj8svREyI-rLDgimHwwVaQtI8HmuI2RFjuFOGg02Xy-g-6k5coNEcE6SkOk3tBbso7lABUojSc99lycurkmUwnmRc0FlRU27mxctpmNknHna4XTmXsguGvcgWnvcyqmfcgxE_cjsFw87hEtEAHkFwzxFngXvJmQXVFagMHm886REI8yHmCI6LFFCchF_ciXm8ItxH88_xGo8gETo8gtkEc2Gn-kjt4uSZ0lYsn9kpw6nnscyFkVM3XknIfXmM83rmac2akHclVkScoYKXcqrlEs8rksUEYIwc9uHpCBPz8s87n1ww9lcc82kfcxXkq8-OkwAYXm6o-jE88qRH6I77kDY48FR8nhFH0hOHwwAACcCvOj5EPOxyiqWT5-HPKZbTPN5TpOUQjKMXpBpIFpplON56nKFpZvKXJevKL5VvOe5NvLukePId5GASd5p3IPxjvLuQ7vMsxXvKrKFnORJF2SAkB2U-pAbMV5mfOXpxPNrZu7Lrh5PP95bPKRJ_3KR5K9LgAa9NcKGkF3p6_PCc-9IT5LiL4Rj2SX5INLD5VkBF5kfJSR8PL35AiPkc-lPT5PCK-5hiIGxfeTXZOEzz5BcOkp15Nyp5fIl5LXNp5uFPf5qXKZ5imPhhzfOfZBPLb5kzNC5tXPC5l8L95tHInxgfPZ5ivLv5XPPj5Z_OD5B_IF5jkCB5uqIyg6vJv5u_LcRUPOT58vJ35kvIv5IfJR5qPMhpGPLDRWPMbJ5EA_5oZIr5KbI059pLoF-FP_51vMAFyHmAFtxM752qCJ5NXLrZpPLOZTvLn58AoX5iAs55cfLwF-_KAkyPLMgZkAygCUGvAKfPF5GfKl5l_MYJcvNh5qAvUFZAvQFqvMoFGvKUZnzJ25P_MDJ9PLkpClLu55gpQ8MlMdJ6VJoUDAqipf7NpZdvP-pvvPJ51lLfSUHk0JYaJsRxlNy5ugB8iUQDSAx9MsFwxIWogmIiFgSJBOHY1gFQaNG5LSK8iIQr8i3TIL5_LJSFr1FGA9qRzYcED3ZmsKf54tLMFr_Lp5BfMcF84DQxscgiZNPNKFuFIiFFQrU5hvJU5rbOC5T7MEF0_M95s_ISFo1NmCx9KGEgmLSyPJKEwi7NCpSQqc5VnO5ZQ7KGFNfOMxfghRIctQQ5EGMnZyHP4AtnNEZ2QEMR5pMc5iHPW5-lJER2HItAuvGGAoHOjhWziIA_Yi6cc3LMyI0CYGWCPhg_vCWA5oHhgIYjEFT1H7ZZmT8AH8CtpVMJX569M35rnPX52_ImF5oC-FhIMIF_qNz5G7Kcpdgpcp1gtqFrAt_5swEaFzgqa5rQtK55HI6FVHIu5dyH5ZPgpgR5WP8F0Xz8FmPOCFvkTCFlzJcpUQq2xf_PMRW3NKZ4JMSF-zMqpKQvJF3VNmAmQuCF2QpGAuQoyA-Quk5UIpKFiIucpyIsbeVQvBk3_LqFIotex8IuU5cGOa57gu3ZU_OxFMAqU5CSMUC_QphZjfJoAwwq_prqPGFuwsmFE3ILhwABmFYfjmFx6WBgSxiWF2NPm5NnNFZUiE2FYMlGFtor2FpVIOFIIuOFHZO_h5wsuFQTmuFFoFuFkUiXhDwqeFLwr2JcxPn5Y3IKZYIp-F1iL-Fa_N3pY4I3pwIsNFoIviA4Ipl59yMFFAnPu5gZLSpsosr5azKlFdgoLFblLL5LbP_ZiovtZYXL3ZIgtxF_fPxFLUBJFVMOJFgQtJFrkTZFx9LSp1IrUR9AqYRcQsFEPQtmxfbMwZrItCF1VP7F1lKyFfmB5FpHH5FzvNk-FiOf50ItSp6oEaF4ooskkouFFpYvXFhYuaF8ovRF2LLK5F1JJ5UArJ5oguHF6CMqkmorvh2ooIAuoseZvbP2AHwqNFHvMm5ZoqEwFooWF1ooDFfcKnZKHIdFSKO-52wtW5y7Jc5aMGkZBTK9FpwtThvovecf4qDFe-NhgoYqMK4YreFU7OjFnwozFcYtXp_wqTFO9NTFywpjFOEohF7AC7pRQpsZ0IvHRvQCxA_YnXgBvN_pJ4pZpZ4rrFANI5p48Lup_vNMpHRG3FV8K-ME6IjRT3NglNEs7RAtI1FlzMmggmMg01aLURxvWdAZ8RdFQaKjFLSJDS5AoSguqOxC_vEXR_fJDSSfMJFYbIpA1_P7pttJhwWCLCco3hwAuqL4cjwssl1kuY0afMslIYiCR1lJDSZEph5OYq85KcNEldEpDR1YoBZrEsVpI7k4lk8Ku5lPLRFVYoRF_EpvhQkpN5xrIAF0Uo7RsUvVFfQskl0TDURMkvdRckpN6H4iUlYaINFxEpM5Uwsm5mAGFe8AHkAAAC6_xdZzhWesLHRSBLGgFrAq2HlKg0a4K7UsolvoCnDeJf3y2pUMRrJJdj2xSPC3ma3TTJQeSmHMeD2AFXSbJdvSg-NjAXJYcLCmWTjpYkNLjJXHSbaK7jbREsB7JZoRdUajBnJYfgoJWZlO8Nrg-pYKkBpXLyKJWqLIxeIKsJUFkDBfGKoAPhKZpSmK_xbGL3JcQKQRa_R4glgjIus_TDpRaBYxSHzV6aztExWtJ_eBvycAGZAU-URLXRYGLuUi2L2JcNKTJetLzJa4V-0JoRbJejKYYI5KsqEEjPJblzLMX5K2hYdyApcqL5OYjLgpf3DQpRTydWVFTcaXFKupVRlkWZryX-Xow9EB1SopVNSOZXKK94evAeBRAKhBeeLK4QZJmZVdLQqSpKUkSGlruuqxhEX9LVJZ2kyJdgirYifCL6VJLAEU7TSOUAio_iMApGX69tCFkjTEZZFKJSGyhRYIB2ZSVyixabzL4VzLGJddz_GZFKRucyLjOW-KEmWJkbRaezVOWpZvap1L24d1L_peaBuRbyLenByLFxf7KkJchzXCs8KcAP7wwJXaKDqRBjlZd3TsEWrKL6c7StsbYBtZbrK31DojsEcfCDULvDAJYtynRaBKc5STS3YfnL1ZWsKgJfZzMOXNKssf7KZWZczE5ZXKQACnLp2WnK1ERnLQYFnKliPrKJpWjAIxUxLMRQLLOhdAKRZVQKWZdCKbZTNSm-TYLTWezKMWcBtURUbyv-azybpSQKY-ffzj6c3LVZelL25ZrKH4ZnL76dnK1pEsA7RDIKs-SPzEoBfLM-fpLRvGoDaybAIfASxAr3CkBQQTFwQAGJheUJypZBEYhYaCkBzNAwsOuIFZK-P4Q84K5ZVFPJBEYGZAgzkQNYFVpAbFoHT9fGKlXRk_MxIIyCatBlBArMIpaeFDxLADYgCDClZgFZQtoUY2IzwKooxMCgrNaAGdbMLB9LMOGBbGKhdWaG6A5YhTRYAFHhtSI1IsIAnhmsgwq16nDQHsgPkC3oCNUEgcQ0FVMBtFjU0fuNYZy-CmIlFDIqVDE3M84HA58Fb9xnADYhGEuqNH-ZW92mJqkkBa7BxwKIELOu4EZ0bj5xICMBzAJjd2aPoq5EoVs2BLRKljNBsHMG2JIpMpcvUJIqhFC55pFQAsXLDlB_eEwrEaGSRofHrFnVL4B_MO0AgSV-hcYh5g0sgyUJaNbp6gGtQrPnmtIleIr2AB4q5Tt9xs4Bdhc4AGDUeIkYx-jgATESL9Keqjx7rO1xiaAYtNDEYsbEG0gsFkmA0YCUr3FWYshFBgsAFnqAMFVDx0eOnBoIDYhFsYUqU6U45b7CuDs0mXxQeEIo33OIoH3N3k1eQDcAWi8DQEagBPalILOpHQrCPtsA8ZnlI5nPegDIBNJ_qP5gRooTcDbAb9SnHiTv3goFulIFES0LjRYPmkrJFcYtRPA1gc4NvYx5tBB_uDlB3mUMrGphA5XLNA5hFqJ5NIXJ5E7IVZEoE0qN-BgrVwTgreQfJATCmJhNVqsBvaPkg8Zu9RdGr2d2FfOAcEHSVxwHiUCSikBl1OkhaAIiA_nlhA8MlzcndgwsVwbuDoVYlBF0TQrJ9gErjesI1AjulU4aGWdc5CUk3VMiqvthlI0VczxvNmJhrwNhFqANL9QpMR0SPNqRzUFsRI6nSV8VFQBtYKNQRHiwqwlqMA5MGwrmeGkqUeG9YKlXrVKVZqCeQZQtMFhfcROh8rx-ksrbMLsoUPPlItMMu8ZltyplUKQoT0GqqOFXzdN9gt5ntG6A4zq5F7VQIw7uEilEbBTQEEmSxxMJcrnOsjQZ6IGr89jDy4lWWtezkmBRruGrA8AErezqglEYIS0JovURaLs0BU1aYIYeW-BK3hlIhhJlIQWHxAyIGaAnFd0BYpJ1JY3pKqMEDWtuVPnx8QAnVqlgErYQJ5tdeEyperizdvNkAqeFhfdIVfIphaOIZR_OQiwVTQZfGlZ4z8ppUV3DpUODGBkcUX2THgATVqKSmTuYfRSJyZqtJAB2Ax0JuqOVKNxTUcxAloK_LuAJBojKoTRTKlDw7POOq9alOq6FtOq13MAs5QORSl1cOSV1eEM11VmSN1Vuq0ADuqIAHuqQuJBobasopoIPbVOKRLCKkRLDakbjg5eC6CdrLT0KtGXlqtLkratPVpFFEBrODFf5R1VMBb1RxVc4GAq_uCJ10eG0h8FSoYPLAmCFeozwTgAmj1UX0MZYM_LMgYfw4Xi4p35RxJqkICpkuKjoqFPJIQVDj0FzNBRCHLr97KN1RbLGuhMekPkQVC4oYNfMY3xisg-xr-VqaosphpuNs0laeB8POUI0gWTcDBuxrxNWjobetJqEEB7NqwLdpG9ITN1kI8VmZvYcMRmSM3wHHpmwODt2-L9pRQjABl6N9FEYMD55ihRV0mnVAskfMUkIqaQ6oF0j5ihRiCKpoRPNbAAskUm9XoYJoukQOJ7RF8CEBLMFVNdUJbwKeQFYfu0FqdQAe-BqNlaAwIMTiJIIsAlhr8rKM1RC0JiwiapbKlVU-Wk2Ebnr51itVAklVOKhFAnGFiwiPp4wtrc1lP4AQRA-q_oHWF8hrsI0uuCI8huDFEREts4aixE-tTVFMsD1qhtScInjtBUxtQkMjwLcIJtWNgptSpFChqH14ht8JFtey9BBGcoOtSMIiAhvxGtXj48hrb1_4etq7BvVqxcFgJZgtkAddqRs-zkKdkaC8V5JnqUckt7B7taH1-whYNptTCIntZtqkRItqMhnSLBjLYBA0KeQOiLqIPtbNrugJxNBfEN4jwJ9qyHIwAuKpcFQmGPdjVhDr14KTFjtUjrUyBdr8dcoMRtfaw6YrjqYdVtqyWMoN0hHjr31IOKKqguUydXNtE7h5zxscTqPeloQpRItqo-hYjTCMJ8IwAlhjtQTqyWCRFIdLdrkwrZTp6vFrKpE1r6hECMxsOnw6wm7gztY-iDJQrrTtfr1_4Y7VydVNJpdeSdydWz8JoSUMPetLE1dT9qVIlrq5tptqDJVqcudQNE15DcIVAR3ENodRhjtQXFsVq7qDhMhdWdAzqxdQXFNBEYQq_GqJqtXs4UMOnw1RDOgmwrehdZMHqZhkbsxREHqxdfzl4dBYF30LiQetIlwUdNpqwVCss-NbbBEte_QdgWTd1NF8sTNcZq2vgJIOtYuYcni6AEVg5RTPvfLOBsCI2pqXq0iEdN69W5z9NMCILKLKMm9XNNjNOkkKtUAdRcXPU5dft8Z2OCty_DMYNoPtgrMBtg7llPqCXl2FD9i1A0RuuIrtZlgVVGqo1kPNUPDjiNWqgxpzVNPVEngvUL4icYOZlKUFkEXVvxiyZMitLF3NVDNPWiF5sYNbq_ek3VO5NZNj-DrrtcPnrUAMlrvYArDbtBiNOdf4pAcAS9pcBxiWddLhgtcvC_YsqdoZuwBcwmsgdovIB5JfABigB99ACh98yjGWl-kh98YClDNlxm5KZeRWll6OIkdxmpKx3BWkkDfPEPvhAaTBfpjxEqJJEDefr5AD30UPOgbxEpgaHJk3IashLztxi7rZgrDBgElNg4JOAlIgP_C95P5FmNO0APImwbXghpS5EjSIdEe_8eIi_rlxhzzY-RWlkoGQbesmgKw0osRvpmO5aDTqcTEhNUYuht5RcWkArFJvqujED4m2XV0vclAUg1NzqhqKn8NvL4LLXDZrbYAJq78C35ttA5qM9UCpUdNnqLzDtR-qIQ4f9epr3NupobzOj5S9W1qpgF3qCQpQd_zNyFSCLEa69YYVXlI3qOtc3rPCK3r1xO3q4SAlgkjUJqe9bka-9ZVVaYvZkcvMPrAcKPrFUFsEfdKkagVpPrSqNPqZsLPqa8fpR-qB-R7lovq7hivqbhmvqAgfs8zVJNod9flqkDXJMD9TUdHWpl4coMwa_-HBofDYQA_DR7Ar9ZhlVcrfqK8Pfqfjo_rMvM_qCDYKNOxOlqFoB98R5IoEf9X_q6jajhpjWi9GnHPUwDfyJHdQntA2NbTMNHAamDWfrljVKVVjd8YGJRwawfh6UsDTwaOiPwaVDU9Q1DeuMiDfI4SDR99yDUvTKDepBvEQzQITZAbeRHQa-KdVVpcIzo7NdYbxjd9FNKPtgHDS9wnDdAamKhc9emEjDnNJ4bMNW7BrCOnq2NeQos9fJpRwI5BU9YyazNPxrovgsg1NFYhbtEppujZAR1jTpozNFTN-dUmE-TeKb-9QMx_Dc2LqTRYb8TWZpBTdybhTb4aayPKaUrrDp_gdxZw3BzAFlTUJJZpgYP5UggTMYEJghJurTQO4pqSZsSz8v3jxQVKxJQSEodfkd91PpvpxQLz8dqHdqTld7NDLMUCJZtnNBQcNCvFI_ZQXq_YaaDHMnQdEhJNRx5c4IwZoICoozPPGadQImboIEotCFuIoEzUmbdFpmaUzWma7PMkZ6PIxZmLMmaseCWb0jL95TwMD1xQPwoiAKmr4hBnFWtT1NgIoWl6zSarodjYtzQFZAgziZiM1BVFvBo-jK-kKAbRq51FIm2aukQDVPeI2iPxI-A6AOaAXLHBIoIKHx-QGDIPoF8hwMC2gsJMUJ8Vht421YRdw1DlMpNRYF4mWI1MQBVEGukW0bAjUlxBifqyoVmR76r39ZTChgCjlw0Uqu0BHALphMwF8kzWr9FhAJ7FWVfCDTzZ1JcypebJgos9nsPFrapNKMsLMfoutckQ_ag-a4vI-k7PjkAkLSF4NyugEXcXGU8Wplh6vK3lbdMhazsvuTBxMS8pgL9rOggObftSa1rGlvCDDi1hPwthb9DiiBWVM0BRmqapqjdJEjmXAB-FI-csHvoDHzv2bBtSpFXzgs1YWtsBJONxakPPrFmhLupJdoYQpLbBbhlFM8wAHiYKoKpb7ASVJOKE-bQSnr4oLUVBheNxbeLT_0wakczjLQkaLbApEapEVBjLTfxbTVkStiQ6aTsqOAaza4A6zYjAhLc2b6jCZEzLdhFABhvxhYH9pTzdJaZiM0IVLWpbDQG5DPhr5bJIheEl9deEhVDnkLoAXQhVFmQYrdLshhj9cppLVJjLRAV05PthA1ftgi0BTIEDffF05PIArgNBpA1chp9sG0E0AEZxhYPeJ5JdsBarYa8UFFcBGrXY8UFAiN1AXy10Yt3z4LdxbjpmABJLfeJKIHlIALmVA9vkNaVLaNb5nr0kdGCl5praebhrXNbPhp5FcAlNaEARYBuLUC8CWhpo0AANaI2qIR-rfEyxrRc0ZPkGZRddBak9cebNvjv4Lzav5d9GsUVemJB_KfX98YlRa1te9aTyXy18qpRa8hs80-Whu0T9U9bp9CF5p8k60q_ImNqQPxtiakJsXKqF4YANPJLlCDaMLf900OIKEF7NQBzcNR9kWDsk2Gs5qb6NfU0be3kMbciwYZHUFj6OPodkinycZRp8n0CIjVoONA6AJMbcoE-gxUlmRGbW1EugGVUEko-NmbTtAC4pihCoDtAzittB40BXhTwKX1toNvoBzehpt9C9awcrib4AIjbuqoOh-obyJtoGGAC4j_dBqLpsDzrKa8aDjVbrelkLAvoNGzY9a3HoAVXrVKALbaPRftWHomzYsJetdgggzPpacHLbBu-SVhzzQcIwLURgetdxagrTdbOXrvoCVAgUIAFzgzsHWF8RNyhnQigoBrbQ4VrbNa7oGABzrRNajrvZA8hsVbcjKdbapIf4l4pMw92kSgE7WdbA1eThIdAcJjvIMZ59GzZdTGzYXekg5bHOQM5bRvpJ9ODbMvCnwvfl95qwCiE_fjeaIsBMCDQuMFUtjsAgOjFdufpF9_jT6a08Ib8Apqt19chq1MiqechasbcbQlLUyLdCB4sqPrcofNo6oSuBI9Z70sZvr46qYnAnMBS4ogE4g4oFMNVwsyA8gqGseSIvb9AFL0vfNpYldsft8_rE8kwo69B-lv1SgtpYKok680BueM_HjyQWxt69sPopkGUuXqxICN8OPgqVE-iA637cfwU1A68lPqhaxcPhaxcLoVzAi_bQHTSQWxnA7kPv8MVIkZ80HSZ8PXqN5JmA15b0Cz8RqEC8FJjK8rAiisbNEg6wHSg7R7dsBafpT9LrZwMa-fBaa5CT9UWgNBgHf_b2HVrAPKPpRuHdJ8i4jSJMHUYUouothaHeQ6YXo5R5tGw6aSEX0v2gz8QFKLUw_BAUMfsA92LIg6xHQQ6UHQrbKHvZp1IPfbtLLONdTr9qerX9A4ySVq2hNisbHTyRtBnLt6sPb0gaAIw4QIDQz2rgFVRJ8ZHFea1ZurjRNKhH4fMGwEJXpTRForrEuAsyAqjvaVA0OHbTxBSB0pFMBimASUncgm1FDT2tRtj5g_am7VgbeyYgmqsY8sDKEtHZ5bFhJLaM0DU7HhNqpH0sc9V_PLatsgAFoGrgEL2u95nbY07vquAzOXqfbV_DfaVvmclx9IxsB-tJFXqFU7--r7aawoWQywtM7enXVUz6nM7anQ606_su0UfOU77wJU7lnWKg1nfUIX9sn5QbQvl5ivU8J8ou0Y7WfIxsBSRysaJINfkzErHa068hk074Ypeo2nSe0zsn_TccsOKw9eyajBoc6ugGP9_bT1a4SEC7DhEbq1hEI6D_mZ14lRsrAYIS53rU3d3rWcczdOPoGncC6wbXvoQvOacGJnjaxpK9qete9bMUCa99hBYN-HTdxx9B8BRbTraJwgaRaGhh1xnZJsidcy7oTltI8hkw6VSoUKKJvJ8VtZy6dHSv4WollMaMPFkXHXVVlBnWE1quThmNnjVUXUGM8XUFUfLjo0fohwwHSvwlMwhlJRIIsxRolB8GeeEF-VGZgRnbPQ9XSSl_AlW9Z6IjdUVADhk8ICgq7RmhnHVy70OJ0axXVAl69ZzaNCM46oEpdsGtZ7rU7QK7NvpnbcOlWQQHSIc3kDb5RAokB4mZvoaPvGrcZuVwVMBYqxyODJOpE2EC-JUAcIHLEq3ogBCHho63kOr0Wne47NHXkNKXVNBIuvkRnHZS6FHRz8u4plhK3WH4xyq66JwvVr8avo6RnfNUOtGtShMN9qXbfw6syIo75yht5-HaYI6wp-bPIZui96apCLEvW7u3UvQK3U274wo27jwE2EGHbDDpSNzxiLiBwbHgZDiOiYdyIm-z6OgDhsuN0AKaFW9F2uCxx9AZDc_lMZ9dPZYt3Ze78kABdT3rZh_sOocWsCS68gKwJkWs0giIFBsnXbdBDbB7B4KBCBRmp4E-1pPB73r0ggaPBwZUEhwxXU67A2ou13rYKqAaAMAV_Cvb_ys-x_3XGSHsI67BXaS60OCh7u1Gh61vtAF73WhxzcIgNWbIabh7YzxOHYtAacHh7A3bC6HpkoJXTXz9RviNRBftMd3rVe6t7cu7dZBuQSXYx6F3cWEhPdS6TIZOQi9FOhQzd7MIzXs9coX7YSocjRePQ45r_hwNRMu5gSGEu6aAOK7hdYYVIomll0ypcZk_rtqYPbp6EPZNbK0hRZGeFOhKyrglfCPvdbXHR5vuBWaWLJlhIZhxZDTnw75EgI689OphaPb1kqOItBnLUQ4yfJ_tn2BuwvGAtcIrph7xTKgBzOHQc4SIB6vGMdbK0vIlzPTyEspv9c55LApQ3OjDJAAogggVLNTTdxA-4AiCzQFopt5AHBd5LxJklLMBkxJlqa2ByDtYFzgjgNEDEQbMBzQJiAtFMAla2d16yUcqgBkVuUBvR8Al0O4psNZdhcNWHiAFktZCNcRq6tKRqjBJD1X5VopcBF6oLDmoQMgejIbJJIB1vTZIrtK29T_Nh4kEFB4gkKzgzgMdxsklMAa2NzxMgAZgV_E9wYcLbb8KhlCv7Mp7GkLS7lcJvoZ8NeBwgBEA8Nsng0LON8YsPF9QBLMx5mOPhxniIMGoElDEkuQNYfflDBDtew_vdE5UAA1A39D7B_vdQBEksPgZ8A1A8fUbBEkjBLomPC5thTNhw5crAZgA1BIuhpBEkte9fUQ1AzIMj6Z8FRJDOA1B8okNR9mJ1AvvbPJcmIcxx8O1AZzLd77vbCArmAAoN1CINgFGgpJJJ_JLSi2C7JLFIP5BzJLStra6AJfJMAMr6n5JRxfvdj77mC7IDJFr6ZJEpw0LHewKwafgRfSPs0FOaFBdDGRCfTpxu-LyFNGOZDAYIEst0FTA90ECRInlSg0QEGUnvXcBRCPSBYQP76Olja46GGrkmqKdCdQHuxwBaUy2sEyiLKjQAUFBkAxQM0BQ7BZ9LGk0wWmMJgLARNRYsAn7JKkogVEKn7p4hFpHelFhqyLcoGPpGAvdUDY6GKOA29H81NeGkwmmALY4vmLZ6_TCN1YKclnsLCZwLDiVaGCaQ-_Wl7y_UP6R2NgRTwI36vdc9hW9FK5jfpsNNnMpN7cJP76HHqNcoA3pS_WYwcCMOkkBCP6ocMGQG_fQ48HOw8jqCv6l_ZacaGFMaosJiB4DEbbTPYu0oIGhjkaCaSxgNwc2sDf7WcGf7u_W4aEvr2k9XFcAn_eY4ACpy4AA6-CgAzNhtXE9EX_YIRTZHW6e5AAHnQDAGpzO11ILZn7unIGkFnAMR7UF688_TgB_OVrBi_bdi4oFX6-SbXlR_fn6jvU_EiAzKwj6KQHrfbYAADEK5p_eThK_bQGJXiv4wiCJAn9Ln7coO0ByXtegSA-wHFoHlI2SicAxgHlFi4odr49ISpFIrlxxwA_BxeNQH7UmwGc2DNSkgLalENtRhRA6MAcAPwHiAyoGVSvbo9AzQHq_UcBFcZcxXuSK77cPgHk_VQHXmYIHGPv2kxgMYGHA5GA2sEe7YAC4GDAwQ8O_aRgbA4QH7A94G48AYHsCAX6cKgQHUFKn6m_dWAPAwyhAg6YHkBPoATBhs6N-FBBhwQXxIBuU5uDkkHVhEJ6N5GKB3GpwM2EHJDQlAZY3_fiRSPRGBhwUww46NUGsyJOCag_nRJwRiQS9LTY2ROnwSbJOR0g2LhJwez9sveThL7DqYO7JjRs1IabWvk390IO44dCI7hwzGZ6ORpMH0oSINGg5VCMoVAEYsHXReBsDgszPlC1gwsGh6MaAtg9PZ8kG_9mIsRkLaF2DbGMsGr6BcHcaCcH1gzc5iVIcGLaByopsOd8A6Af7S2rTZkbGMHk-Cf6F2ADB3gV6N2bfFlNYBPBLlG_ha7Yaarjv3oXXb_goStEBNXGNhnHfwMLRBa4kQ6J7phvv7SMO3acXWu0M0NEGzOKRxEg_FlwQ1FhqAACG2bJl7AwqRxNA736r2GnhiQ7B61am1hyQ54pKQ3GSu5PR6CQ7bAS_eGgwvBKbOLlqR8iO_7vtFRAa0vTgAYFJNl_TvoO7UW0RQwogo6HF5sUA-B5Q7MBmA6f6EdDZ7coGY8tQJ9BVILOBctTA6bYNp7ygyKRkvTZ7g_odCNvLYBdQ0K9caJFFr4X4IW-j0lHQw56MrWKIVlMfbX6J5tHxMMZkBLsNnKiF4IwikGxIIwc39qaGIKFSQ39pSNAw5l5Ave0AqbAx6BoK-IWcJIRJvSmI8NbN6ulYGCFvdO4yNc4DEYZlbJyIPJfjj0GGls6wFYBlAosQtFf3Vkh1IIKq8uEcBFoKYI7mAjiQkRp76FVOB2_QpMmqJ0GxsEuDZof2GxoYOH2RJ9DYlChAZsKdp9sPb7mvQqUqOLOHMsNmwMgAuGxsL7og7pRsawPWpgmhGp5AVHoOMLqIKg_ZkVhjNgxGKaVomHmdeKWwwImDowVmGZpTaNQ1xQg1As2vNU6_X4HsKkX7IgxdA1wr4iO4g-HyQ2OZKbVHgnwy-H7cBMRKMMuaxzNH67cPp02un_Q_w6gAjXttxtcMBHXta-Hs-mF6II8WooIy-hX4bBHfiIkl9mAmAAYMmIfMR0HA8A-HUkmAAGoO_7RwKn6KI2AIMkD6H2ZMMZqI1FhvQyObfQyiB6IwXrkwaoIMANRGxwyfopSkPgR2KxHSMLCZuIwl7SOGJHN8Il7JI-z7DGGSH6Q7LCpbZqHRlDJH6cLjp6I6doGoKdptI-6JzcLpGDIwTBtI8OHdI8OHJI9qY56hpHBg3PV6I0oDEdqsY4AA1AHI1Hp6I5w6RQFIKmfQ-HCIx1A1w_E8tlHp1i4qQRGAPt7pIEcRNwPRHOoPOGwLC07OHXopKRmydcmJb6HveIkkoRj6Yo6Wxf-k3R6I6Jl8oRlG08DWxiod7Zco-mEUfXr7xEvb6CffhZ39LwhSo75H34fFHx8IogtxKVGpAClHYQA1H2APYwfMYMwhNJBHHA8I6wlTmwEozpb0jaRxRoylCacElG5mB1H8CpysMoQ1Alw2Rwso3D60o_lHgAMtGio-QNSo1eHdfWj6OfcXF6o-IlNoxNHmo0JY2owL7S2Hd6rfV1Geo3Jitw4FGyof1rpcI9H3Xg6QwNAl111G9Gzio9HWVF3bgTRsxWvXJhSpC5H2VjD7gAI9Hso5gB6bs_1MAEZHoiqf4do11H34VDGLo-IkpAJRBEYwIAUY91H7o9LhMYw1704L5GxGJvp_AFowbw-6t-tEsisUlchFpHswTw8EwTmCV9H2KzgoEKfIYyN-w7JKIkXmNnpR5JhFZfSr7wDK0gp5BxFBY9r7K2IVHyOFawBVnSwzo6WxRY89JqwAOHpfUb6vXES4twYTBFfdUKZfWzI5fTXp9aHew1Y5aVZ_Z_wzfV3pAQ-bGlOLJw7JBewgfaBYFY7bHt2ARxeI-OHnZCDI7YyQwh5DEHPdBedKZMbGndNjHi5OawgZB5IM0F5IrpND7vbKrHxY8b7bnflCY43rGhYx51O4Br6mIZNVIZK5GIDuApQ4wDJOWMYlsZAogbfanobnbhsROJvopY47GWOCRwRo-Rxq48rG2Q4aaHOB5wddKOwL_VZwZw25xHfYfpXY0JHm4_ODY2KMpy429Hy41nHF9uXHTY-rArgOepzfYJ4vogDBdTXUCAzecCDuvxZmNcJZSuHJIqAIx834AEItyqWTR3DmxwuNgAtFJgBrRIrMA4MrNa3GfG1YOFAQlNBATkPMAflEijviUKAygxLBFLK0S8wWpZBXHQosFJqrylemIdVRlAuQXqq9wYarOFiJ0tBL2rOFv2rMBbQZxQaFYpQbpqUXlYghLkbBDvA7IdqFV8ZQNpYXxKpco5pgndoDIhAzc6D6TdwZGLLmlLACTQPrG1xKxKwtkzZQmVDDQmcrHQnpxHQtCzWjwmE3VoaEzpduFkbVGExdgqE7wnf5qwtOEwu4hE8wnKlc4BueBjxdLke4qUfbU2FhQnJEzwnpE7InoIG-5-E3nA2kEomDPJdVsNUonNPBfc_uJwYDE72rdE8lZjE3wmCFgXNqFip55E0bVFE8lYheheiiFg4ntE0IpLE0gsAla1j-gHxAivNvG5MI5sLqBu8T3fkh0VRnQzVYWAh9kbFv3dehi9mWs89pTQCVCZhMAAQGzFSFdrvcGdaFKRxGVfK8kbIHhKPYqF3MGZDlfAiBoADBdMaM5CrADAmnDHAnB1ZYB5fCYddLBlBiVaBlcPtNMKaBVAAEzlYgExp5dVSyC2QRAmnDCJ1RCGZDek9qqBkyAnIVfqqUxGQsjVUtYxiK0n2k_zVhXXyJGoZuGM2QmYoof2Z3RLnAdk5ratTliA2k6s8dJDMMjzVKAkWMnpKAGKBMLupdDqusNRNjaY7wZ18_qvNDaTrn55CNxdDIZFcV4yMpE6J8cqbG0huLrKkT1oP9HwAF53nC6rddGPUPkyBQ5JCCmAbGh0rbAF5V6ugmOBHY1kgLGdUiPcSy1mHV21GDgwhrmAWVYUBRpq9tW9uPsMkLLr0Qc-A8QFpJl1PrZBIywECAH9RggE6rHGdNMMuvCmxSIinuLhBckPfNDdLL25lZBSAkU3_snTPUCThB8m7k3xdgU6CnwglFN66EP9eola73HjCmKGqKn13rOA4U6eDhU7cmtU-0huLh-AJ7ZgIMU4MVrNKrYRU5hdxU7_QnPU3JJLnYm84B4nWFs4m0vpjMULm4qN-E6ciiJHMyToSE-UwDZ8roA5TqmE1XrhdUzDI8qLE0YnpPHwmAmkV5xUwrZXzRCmE09xdAwnUFFYIvBFGK6pG8C30TUwY4lBHiDcNNam5UxW1_Ctkmi06IgqbDWDw0MZgEQGXgCgGVFI7rl4EAjSJHkwucVciyYOvg8M-WtZpm003ksiqzgpU2sIctP2nRnadwFvJ8dinicd9U7KmxUz8n2pk68606lMDETOAm05XcW00ddR6JOnPk-q086N08ndnJ9Ofnw63fmScRLjE9y7MN45_memI9jUbR0xumzLGfVZrtOd5Nm61T05QJ5DlM87DhVAHDvM9n03M88TDpaFKDumy8Nit_07Tqn-bqVr0x-nJni7cVbi34X05ic30-YEx09YC3hizNHDiuVCEz6cPzkBmI-rOnDU-Km3HdhmAM-p7yJjh0bTCBnG8OKmodViBPjmcVv0-MBKjos9k08qnnAkKBvIKSn5cU49MvA2m10wkBUM0RhWM0UcbOrqna6A-mSarMAJUBhnBZuSmlU0UdqyHBIqMx2BbU2CnQ_kUcMU0pmCMzanjU2pnCjn4dzQIZmn9nr5lM6iU4M16dFzrFcLZgc8vgmTY4fq_qImlwnVE9QnKlXwnWFgE0-0xJnN1l8DJTmGm6AZvYVEyKBhE-om5E9om3U99cA6Pqmy8Imm5vnRmDUzpmXYMV9erb5nAKAQmb01iBq7EXpK0zcm50xgmy0-tUxILnAb47NBtZNcma0-jY8GM9coMNlnq03vxG-IqVTCbfHSs7hpys8VnpWBGAis41mSs8mEys5yEq6Q1MUFg79ZgCfZIgFMGsBBxmV0yZAUgOumD0-n18ogDGUs979e7SaZ-7TBZI3lrFBIxEpPYoDBSU_4C-1L7F7SgAwrbKkIhqYnBcU7l48pLMH7SoYgM0x9RZQD5hMPDg7xM7Nm0wpG9RmvRdb0NcmswEeAWADEjUUmJgYiMum-M9NmBMyRk2wrenrs0tgWk7JAD4J5mXs8dmk4gjmUE-qnYc_en4c-Sm9k1zhzoNPRRrtBmEM4en9fH9BowmHUD4FPQtYMYIkc5ZhMLijm3QGTnXAPwVIcxUBAaA9mlgU9n901s9ZIOaAKoHjmvk6M7I3h9nzoOfHcwNlmgaN2o7fDkAG0SOojIOT6-rbMApgxh6zaFdnakgJDHNHXRZg1bYTgDB1uRRUxAjujQt4JcGjHINIKzmo0sU8NChM7Zg5A1KBzXeugnMAmtUVIJGXVUR8tMCGZGpGWsbRl1AczhDmC8glhagzLz9VHHQGg4ri5c2XR5oQ7mhQ4ylrlF46AWj50PMCGZ86qiphwNGFsXLi4D4GC4ugJ0xR4Fv0gnHSpzhROAQBg3pJXJ_wpg3ZVH48s4o8C_G2ibu8vg53ZC837BAEhmgG9PS57nIkIhXBZKsqAS9G8_y5m82VUMzLI4ZeVPZ1HJkGCAP3JqwJU0OUDDALFXhhFvDlAC83y0J8xEo8MOk5FgpoQLFaPZ4AJPZoQOk9RiqgAPyBk9F_erAx8HvU_sOTrintxt-QAUmVJlvG8k-fmUPFUmr6DfR9rU4hhGt8ITk6snkoYoakAkOEJs8DmZsxznKolumUMO2NnsOfhYdYlBA-IYQxgJv1MBlLtwgrU5tSPip2aA05_9VwBmnBdRi0HASQ1jVAyQNGccbg5gN_bvUEIEk6H7OMAJbgQX96pecgBmKkuKoyJaBmN4xgFcAxgKYJCBm5zMnlQWwC1pBzqPDAwaYu0RgA2aFHYHxF2jAA-C6AXaC5MwrNswXLjNh0G9IfnCCxkgadYENqNDDAlCyMBnNagA-HE5ql88xoNCzVA-HCoWIlLoXVC3NKshjWBpC-hhZC9bhyddislCxPmmbWoWtC7YX1C0zbFvMxpeC_oWXCw4W5pacwl_rODP-DIXyC_IWrC8oXNC5oRkaHYWQi24WV8xEX586-gjC9yGtJrKBS48udLeF30_CyUxUzNrrOHAfmzC_4X9dVHn-Fd5gr8zmxCHOwBuzr2dNDm715uNiB5wJwq7AECwOwKVJ1-tgBJ4IPYdGIOdr-BREHENyoekFX4fmLpYddsLxAk6Rx0DoaJ9egPob86H7lczmhVbGk9aM1sAhi7GINlo0Sn8_K8ei15nT8_cDA8KrZ-ixU8Ki_9GQw9zY4UmPZ1QNMXlvvO1_LWJAzIRUWFgnCRuk1Ar8iOBmFC7V03SIKcH1gZLtyo9qgxFlQk8LZIriz6JQmAmYriyGIDdcWGrJvravAd3apiM57uEy5naEw0B6E3pdYmhl94aC9m9rtJF9PsWoN3UEAoAObhcaL1pg888HJoQcGpoDNCnXuiWeeJsB5wDiXh4rI6CfKPQss9cnas5Rggc7mn-M2zEvM18FvC6BMus9Kwesy1nJiOnoWY18qUFr49tLBx9CWvetH1kt81ABE9PLk8mFGrZhBAoMXGPj5howp7QtMJoc6i-gBSpHW5r-NHD5wM2g_YUDR2aGlk9Qvr1R9dga5DekWmdbDAKi8VGf7LaWkoacpmKhvwzIQrmjIWUgSS5y9owpqWGixHEh1lpg61hymP0DKQ6SogFbVJkHtRJcGgy5usJpLWtNUoGWIk8zx1U4WqHOkEBzAM9sXcjaY2Lk5EUzMNDKVkTb8kK1pTEmcUiIGvkLZkEnLkOMWIwKWWHsGcVliyh53hoUXT_AsWfbaMXySOMXf6GcUWy5JwWy_Wg9LV6hfHqPqtvBKWZ0Ipc8i_Jmz1r49804tm00JV9QXtV8eSBGBwPtXqaAI19G-HRqSeiO554gJZcYR_KOUCwlrwHR53lVArk6dMD-FnUqjyzlBmC2eXnAHrBLyzCrfQUKXBjBkralce4tQSoYhFP4Q2kAaACBmKkxMBIXbMC-W6lXdV-rNqCYFrhrvy_mXDEA6scgM8BnfJPDk3VuKvU2JAgK2-WtIWBWry3ArbMBGBUKyBXgVZ-XIK8YVKUGJg8HUXhZ6MYqLXUi7HQKQg5kt6pUsl0B-iGqyZSOkhCpN81AFXwsiETolXyylZD0AKgfcE2DSeNRF_UR6KLABQhZxVcAiBq2x083Lh_eDoKVMpAQ7NGmXRwWZA5K-2W78NeA9pKOCdUVYhw2f6jCBnuY-gKnN_UdpK9zPVbI-JBLiVrZhTKv9xArB4poirB1sC9Kl5wMkAk4Pfb6gK-6vGEvU8gH5FYsMprRwMZbbwHHFGbArQ8zM1J-hKdxqFLZ8nvhYBudjkGNlo9JnbpX9ZqjQB7ehKakg4kBO6KORA1WVr93mOUUqxlW8-uRnxJvu8OHqSscKmm4a3geX2Dt0pA1UDQbELeX3KxL1d4KnRPNqLAp9lEsAtNAhhc26BcUbGSahDiBts5sKT-BOSBq7-r6q3eX54iaTQit5sgzhHN6QItqJwMpo0uE5hnCSZgjvf01TbO5gLJT3kxESU5SViaIhgAvmxohwABtg6ULJXeQGVsxcawP4QdY0iZFsNYBOiDkB60uXarqxYAbqym7UgPdWHMGVLa1k5kXq0GcmVoUswUbdWZSF9X2mHtJqqwI84kgDW5VMnAxbuuoHq_wtby7rjOokn7n4dLc0lSpAPAMrAbEHAAOAOGgWsUsBecUTWPAC96V_C1iUXDtW9QjlBecZTXTy3y0B3PJBc4AO5bMFTXtWixUEnMr5Q-LvElqzKQq_GOghfBZCx0DzXUgDghmk4kabTPjWPFFgBN7Xs5Q-JSsx0C8mcoPLXRyGN4tIB1aUXKHwnXirWpoGOhRCHiAx-v7ECoDKBS4VzpOS4Yg3wblBQ-Hf49FTm7JyAbXVRJStSayi4cgKYJDRHiIB3CtAezUUIP1FTkFSpqkUgHbXpcA7WfWJSt2GrZhXa-RKxcH7WMOpqkPAEHXFsCHWjgOdQUgGVAI649paVdLgY63vd4YQnXVw6P4p3UZI_CPJBH-R2G5VDDAjqq7BWAEOJzdjgD0_MKAhgFBwaoBMI4CQPowZO8JpWKLnzAFjWeAkrQ0lT1gBeLcn-3NeZc4BEpR60DBc4C96Q6xGA8ALnB2ABvTzy86mQE2nXrNkbBIQdchc0K-Wjy98MbFqXXYLNvw566ORby5eWVoGKkZmIyj563FY7y5yCV6wjt169EAIwMfWb65LWj-ofWpoE_WQE6KlLjGXo56wvWP6_9xb6_KqYAPfXc0P_X-y60FBawfQ8Qa8IZ65X1N4pSsIADaYaHEDAgzhGA-CjVAq_JW55-qg30G80AbFhMW5-Ef0cG5Ss0G5SsRrUGcCG7zonAEcFL63vWb2k5FWAEsAAWKSAWG-MA8zPMFgkHvmylE5FlaIw2gYEw3WGzMAOG04AuG2JBGa5oRsgn2BNYHmYZG2B9hG5c63Pi9CX0Mr5J4bvEuHpSib68po1gRZDVG7OAbFgeXt6zghtGwfRVGwO59Gxo3l6yF86VQdW1aD3XREqNcvopvDIwbIJXc-3WXqJ3WI1WeXjJNvEPACW0xGsZJJOAPWfGzPWm6z6CZpQNnRfgyAfG2fFrzJAFCrrlNh65Qcom0PXfG_DDHlLf4wfeYBigFjWIwNBosa7fElgHk2b4ikA3UEU33gF_EOQFfrLwTe1-3DjXsADE2-Q_25GkEugXvbeInIp0AoGh5EPABp1xbQDhnQFAB3pO7dTxH035wHHEsazDBobv033pK3lTuJM35wDYwRbe4B-m-QlrGLOb66dLV58iM3YkhDXN-us2v1HM3HwSv5igBpBoNAc2bGN_E12XHrQBGc3UQJgcawPfs0AI-BNA4GNUsAk5LvfF1Iop4iGMnKANIIn4jbbmFwSKSV5AHlVUQBc3qm4MJkmwPF9kFgAGm2com65d6ya4k2wpHnEB4n42QmxBmrm93Xam5QBoW2fFd4k02egC03TbT97gagQB3qxZIWpjrHUhspprkNCl1gLFJUhmUCqEk9wISK79eGquZlfFhBj6AnRKVotJTtniJOW0fQWWxwAU67S2yoCtAa6JcYGSP34GFt43QODPgUQI_FYm88nppr_9ULYYQ1W5aG5VOep6fGO4bEAyADIsLxSnpxXVFsBWGmuKh29ndATW2XNgKzDBSpMYXixgq32qFZbMfSiByW5GB54vq3ssANIC-Bk3qwHKpTwAFXEgAZFwHNolTW--4SW8MYvW_w1YrFvEUm9eYfli2auxlu8coJIAAAHqeIpaDDaenO-I3gAT5YACIwClDZt3EG8APNvYwAttFtmGA5t0tv5twtscgSDSsQclhbAGes_LTJuWYEqsZoFaBsiF9AI7LxSCTN9gb59ZtK6-oxANvtuRV66ALBVGAeoN3Dx11esrXXNDjtjVzny91DPGoahEcYltY1nxuuAWFv4tjwBFvZdJ3QbJs0IspsFN9gAntkpuFN4dmfxUpv8rblIUoK_X91yFu4IndvCAvYAHt-JtdjJFtyt1FtpN9Fu7msUSbtlJvbt2c1Y1_duNZGNu32ONsDxGejhobtxgd2zKIt8RtQdneLduf9ugCQDvQdvFugdt9vgd6u3dhBkAFYDyEzcL1vKtwjsZ2YkIVQYyRkd76BBnXCvvlurT0muVtet6jsjkOFvEOdYAqNsXzotlFzMFsqA2LHCstKm1toVoFXaQgisGgIisRNjlAjAe70kd2DtxNyjv-SBevXlp8v4dmVgCAR-J1NrABKt8NA0G5FvReCLC__Pf2KmsUTft_ty4t2c2vtjEJy7NLxI87wF5egEEAeLwbFek03eCBhaZpHQQ5pQawmgGhGaIhhEcgWM1b2cKHnWMUGlxkazqQEawRQcFsb8PuaJWKBxsLbbg18uNL0m68AigFywEK3NI2GAjXceIEZU8EUAlwdOCDg6sCQ8KopFwURT-o2ePIVqYApdtLuQqjLtiKLLv8eIEbNcABbMGeRUALFQyFdiwDyeEUDKLUcEVdhhb2W2knI8TgyDd7IkFzALvoFPWrYFS_I8V82aJCaoTqQd_X-t2grqQEgqRdxeM5ifU2FKTDzrxk7pxuZYoJuIRpJuDtyazfWZGzb-C6zSRCrRRjxAoSDxmabGGweHhTqgos3fcZgEcdyNP61CTyOWu6o6eJ6r72cEAHzFz1KKy0HmeSzw3VEHsziGsRvzNL4xzSNxBms8vCE4PHC8etyuUUp7Xd5sTzFWstg1QArmWu6Do9s8AFddfM49vy2RIIPEk4Wstmam221KBerHW95T0m-Dw3hQTR-N9-wQ1GCyBvPoKvUgu12JUQjaqTnuZCchiP5w1TNpVC089oXvvRfntBmdnun-FC14Z-sHtOpnZ23dP76-KsFX2q7bm2FwJ-lo8AaoyqRQbXQFS9tBTKdUAV3Ib9JKZI0O2rRO3jPL50vpdAJu8-Jk4WuxLyOiYLXGB7qTkSH6G9vgUGobvkadbVQuBUJzD_bVLSGsQBKZ4YLxM8Jx8OdoCMAYPsDIbvlLAOm1x9-Ptx9uuXH2_XuYWvr21i-3uftOXtW9rspp9yAXJaZfOlMUoixRZ7BiYTwJL1N1QOxVWhxdBgq0oBLIGEGEBVsN2FnYLcO62OLpIheGF3o0eEvrCLC89-DIDHWivJATBKiZ0Xsc9vvvk0zgxMZYvttt1z6XJ0JSIeNJubJFVuKoQsS7aJKuEHVntQmUcBqlNQbIeBfakSEJqDJVlKz9lXvlZlYHO6W9DLFYvQWhNFv496uSWEgGq3nbLpLGVI7-sG1oCcDnWccUeEMcD_vVgRHu74fru_6Dvs3guTVQPbejVgp8HqYF8GW1j8FXQr8GktTVKPeV7v8ePiFp1UGBvlX5PNNDzIfeV4JFQj7xrYR0gNQsGGMQrPgStBQFoD53TLiziHbQl7tKK56EJfSLWZ8FbSCaS6HNCZkaUDqiHUD0Hu61STx0D0ARQQY6HI0KVQsDmoRsD9sN_Q9SFo8FzwPzZwC8D00QMDwJ4JNYQfXQ8SHtPTVKXVKdV94n7sPVXTyKeFAeedXVqP9nzp7ONJrgwlhoGDqgjLdOWq-a1yGt5bpbyDlT3ldSweOKsQfFGXOuFhsUTIw_04blkjwhwW_L35CeC7dsCD1YXRpOCDlX_m-bhTAa8YDcYcKNSGxvGl2-AVoBpyoTKwYg-X7w4FJyLrAS7zWO8tIS4-XpCG1A2m9Dvpd9AocfiF9RWcLIdapNlG5Dm8ZCG1IvnGuUCd9e3h1DsodWICoe8GqRF69NcqE0WoeRDDyKNDmIByGpioGQdrwjiDvsjFrof-EeUvsHLppL1BITy9ZIcg-NMIdPKId1aYSRzDm8Z6e5MZSZnoTNmhf0_jBIsjOwc1SPMz229LnuZ99wcD6zi3uczFvJDv0pZeRFI4A07OIVuTCoJZXVNDTG5kqU4dZZPlrESW8DJiA_I4FBjNghnEpKhMGQF1jNDTOjLLy9cdhwZ9YeyKYEevp5BgBDuEf-EYZhqANlgoj4MMVQct2uZMGTz-WB4_-vger-DbDIj4MvESGGE-Z_XzRhGO30IIm4OYeAhyYGvnJ9MAr-lRngaB5kdthCeA6U8EcWAX4eJAf4cBDs-qMZy_2tYUGQjQlkcwAHSn5ECUe6iTrAzYCUfcj4VBij8Ev-thcoSjp-X2dkLiBzc4EtjZztCWPbtnQefCpEJWatub-BGjtlGSILWYmj67p1ufWZaKeauGza0cqzB0e4xEJQoh6ICHOaFwCIT-PmE1SyMuRKI4eU8bpuGiCZuD-Bfk2iljkotxBjrRQ_YbqBqCWJVAoWMdFQeMe9DyRAPxxCQwcNLbBj3oE4uBHCQINjYhQVPD6ACxambKJZT6RYxirdmgcVd0plrUD5rISfYkfdba1nK6vurWxgzbLECjgFSr5UBzC_fTvvdADirSPaNYlXLDTnZjsePwfq4oeaR4V7Xlbu7RbAX0F4tSrMisdbRbYn56ssq6EotLASSL1AXnipEL6I-YTRGkrQHbqrK3yv3Zo4xHYYz-Jj0YkqUOolXQa6GPHh4KQVIatrfpZtSFpaoJasfB7XRoKrDGvZJnPV3IYFOXYMRqviW5DxBUJ52rIJLMrYXgKcF71erdYsWAJUBUnO1aGEGGDDYYwgVPHJbfLK-p7DwIq9OPrCQT09BDUEAvoUKaMDQGccVXQE55rFp5giV8R4T70BCTYUCnkBoAJGfjaTGMVA5LPsv38Jic6gPFvFkGieRrBHgYARifMTpwPsAVifQYd8g4wbMZLdBIw8T_vLn4MiePHJnX5EPieQTnAAJOBScLjgIZqTmbAqTuic4AHD4aTu9ZM6_Sc6T3Cf8T6-g5QQyfY7YyeSe36HSRYQ5Jj9AApjp6jYbNsJuIUCdUjWicMooC63_fsjmTmNZAnQuIyfKALUUfyep3O4NhT08dOLNEclaYlgva7EcDu7qPUT8rzYrWiYoBtDu4zcrylVqJa7KH2q8a_8eIpwCczVgS58LZXYTOg55GIVryawV44rllDwQTuicETl70w24GrTpwYywTlSalEACfpwJQjmoggBVT2qeuwGccB2yfruYV8SvJVwq7qKkbvR3Ijj-MacPaTfoz-KkYJ-PfooYZqeU6oIYl5jMdFj7APBBiINU2Vyfr-OacADaqey4Be2qj43ZBjPDsgVcnYn9EHrICFHZE7OVDACDk4hbCR1mayoapDPj7f9Uv3EV0sezVumiBaAd6fAHrauBDV44Qdpa5QMVKwgZODAasD6DPSQAUIbWCd9zlTb1WlgkqVsC83brYBYOzV6YC4CXVgGtKrHGYc7SnavjsW6oJAVYpbD8O40GeggNzumpDF7bURLV5vdJVb7VFfQZaucCQEdPjGoCNZ-bRrZEADTBt7Pi3ROhkNivD6d3T1mdf2UYpD5vDCWobmfRLGxttSUDatvamfiYD4gEAOmdi3QlyMz5OpA8SwAXYMBXU9ORak0CWd-2KWeQEGWfkAbmcy3Uqcs7Siw3TlIac7dg5NbMvVmhBXuARSjMiAKmJ2zGGQfR3kxgyVT5Ezu2YafMXZ3QE_jkDKbqb2snWa4fmcAqdDDOz7j7K1OOf8ziU2BzinZn9Suhote2dVjLPr1oCZtJztQtnD-6Y7TMDrh_UoD5zs9udQfOd4QUVSo11rYUkcQ6TxDHY6MEMva2VWhaxTPbH8QqoXD8wDrJ64dG2nl0SjQuTa4O7X5zyA5r9i1vYRQvR3qe1v8bWmeIwVIZjOJqXEzs_o-z7shPlX-3WaVIbJ9Q8BtVp2SCDS1Vj9Te0j7QL4DSZASWtxc7TzkntA6TecisO1t-W137qvJYz7ziYvPYQdpT9bJ4TTufoem9nZ2zNfqgaBafb9RotYAFaetDfQD0zql007O2bA6g-1i6vuLxzpWrHzwhIWyVLRgyXefZAZ-cmCFh2Mt8OcMupXtyqH7bm7P6c2LcqvTCOwCVjOGsdSU9Q-YWCDwQI2z7msaJJoTJ0S0L0zWDfM7OKwLS3ibeCLCE12i3DqQLFyOouV-tbluZWhsqYkrsBZoCxvZDg-O1BVRLAs5z0MnhLoXGi24b2Kzi7FQE7IGjObGqBBQEQCOIFyuTLCtVbAQ2A5SVDCEw-piNSU9ScLyUA0p0ac3kqJYZSbN5MqTuvqoIJzBJodaFqxzoxbIKacPHmdxLKhf0fBeqnqGpig0TmC40V9HwQZau91viDKzy7FRLSlbhq2TS5QOeefThmfFSWg51LPmdOdblTKyzqTpj5LbuPQ8fnUUmcdSVBKxvJiIG2TVKoJaCB5bfJdXV7k787c2wG2UeeVLEJZ0fKLY5koQbnQelFh0KxW9TkQ5TgHvaurTNaKTp7V2AL-pefGnFXV70gG7A_yKzkBG6xBkgDAPIBnYZ7anHaZcz0FpZVB4i7aOT3Pm2BWFWzvysovGhcubRXYK99XbsHJudHgbXb66nbZHL92ZybTtMa1FXa0Lk5euhG5drLwue7GIwhSt_HbPL03ZKavlpmQ4ZcPrHCE2mKdDOQIMqeR2Plp-Bvyngc3Dgri2CQr-_lrjyIBV-MFdmgE-JSCsUAMKgoCroXIxBj-nBwr9FdPxTFej7Wxi4r5FdEAVFcEweFdCgMbI4ffFewr6ldErulcUrh4dI0LqQhAN_NOzmOc640DYPKXVvRzkUKK9i5ajzpfr8WzCIi7OpeDNzXiCrr_hfoHYsH7WVcTN5fMDzykcgdWVdYF-ehGyARcR-Wg7cr_Em_2pNDy1JpftTFqOUnDJdyrnwNu5UedkYPcYwdrdNGruBcxz7FbdyTQ3d98UuyriAYgDKz2Orm1fKDdoDDZd1etuz1e8DKz04WHmhOrjJAurxNHoAf7iaBv8jGrz1f-rmNfE0WkP7Wi1eaW03tXBAFCJr-Of-rnT7SFPIvBoKYARqrtZFne6jsR60a5gIJftMCaJw0I1caL9RenqQ2LL6IwoVQFNfm55PBnYFrA2ACy5y4V-F4g-2iz0TwIVfcsM-hXxKTjSZL5QjyLciPuQ7F9DApzvnbvSPOdteD5fg4RyFLrnRgrrmg5ZcbnAAFjkbvoJPg5ryNew3BddeA-0qMBM_p9gEghaYqIBjRTcbsdc0dHr2-AnrruS3r1wAeRB9eaB31car3FoTeH9fOz8BudeMGRsG4XiDVJKFqO9msFtUGDrmhasS9vlq986UvC8WXYD-I4BDtIBej-Wfq-z5N2gbnfob9LfoOkPDfYAEBdIldzCxK-DfKBWVdL9BVfX1NLLKrrkR3qcgDzBOobeehSaIb0cp1-T1fsbmWt4W23xPUQHUrXNQAzYLaBNVt6CngfecIZo8Bt-Qvx4CNLJhtUcDewXUpiYayuBWMis2qmDoOjAdTmtWg5DRXpoIqI5z_cSQCk0c6je5jNcxrgBu1_DfgT5gzejFI5zE0ZfPujmbi7OYbRyblu18b3T2Ol1GAPYOTfmbnKDmb2JqRDJKp2bvzd2byoMZr99f5EOTc2Kuvz11t6Dvr3txSCtk5yb99eRQplcQrklfYrmcC4r1LeRAGlfEr2PmE5UpmemG1cPryLeBboAExbhvwPr5WAsrnzfSz4aF5bule1-t1o2rmA5MjQLcFryyeBbkp12T73PjGWDfr57jdLeR3rx-U4uQnRoLkpD56wO5la5GMA5C4CNc2rs-oZL-arSgLdcZL5fMwwOjfrb7LHFkfrczb9fxDbv7QzblOMkBdp5eoVbfm2JwMDbg7ejbgAbZrl9eLbuDPLb6-oXbmAArrprafkZQZbb_OfGFw20l94srtKJIB_ZVRqB1V7fulbWI5sJeqrL35eE7QLQCrK2xg7nbaLLlfkh-ODoogXGgWugd73UUjjSd6M50AWSQTbpDcVPbjfghzDZrLmGCHbq7f7bine3bmAYH9hcrQ745d_L9qtRdsSCNvQ-G2AI2R6WOAHICV7eYT_YaVSQ1utN0hBwALnc3PI1sCWnCKKBIXe8MHNjiVG7W1SCU2vbmGBHMnFo75Iuf9_OWJHMsDacrs5M4QUJa5BQ1Q6NLV12bY-eL1cwDZAQm7ZL8oDyMBHBWtMbCkkC4A-6BdVPARmE2wsMecw2imOwgqBRjpxD6AViCtOEOBWQLGCeIukAMgJpD6Ac0BJgb2lQy4_lWQVQWEDvc3FxfvKi6wXcDSFXfxMgKKcwNljK71XfA6sqAJT-nfuGkXdi7uAHEt9ncl71YRlRcXe87mbf87gaIuzv62V7-ADV7nndJ2ouQs1MzXkNvThp2nDFIkKzvMNH103ayqRfToR4c70XerCcXdYCOvdALgXfa4bj5C7jKfN1mIAT7lvfLhMvdZJBhZwvFx6fYANOvT7TbovTR6YvYUDYvLJ6-pPF4uSF710KxdNQb0MOIdaFz_cWzfQuaIIRAdqntqxFd5AQNC7OBZwFJt_3zfTR7k4N-fuYNP1ZahPzj-ZoCb9M_fYAcA8kbhSavb2Yvg9FXdiDDyYzbtdeymTDrTvcEQjT4dpj9Udqb9V7dBbh_d_z2A_THEYAJOAg_mbjfx-3IAY4fCg92bqg_mJNdQv-blOF9OAG_CLMgV7lfdc71vdFyafcy4iABstrQZwA74YvRmsBkHv4RNFAzeUrV_cgGhEAf741bf72pBLasXDiHlHX37oqDvKlsMcMFisbwKQVf7o5w_7y1WiHiwAjAZICcTFNfSH7Q_v7vQ-oARQ8FJ4w95gZIBqHiw9aHt_fSseQ_6H6FyGH5nUhlL1CgfeDdi4Up6vbxKulFCMDnzpDN_QRt53zzSJHbrdf2thg_6nUCGgvATevJH8PS4WD5gZ0F5kZgXvnTsUS3KrJLGAA5d2If5DXwg4cVTvHajwaraM8L9fhV9zCsjLJOnFR4qmHH9MVHUHZY9qTPNHyLYYjFzTvVeA897mbebbgcDTNl1BodYowK9wdeEXEcbqDUXbTlgvLgbhe6WbsRuSsLkQYwAkC5JZlY44J-DwAYYAGWpEIYwLY9S0IqBfOP-AcgGY-jHt7VTABJw0gsjDfOVA3awHHBWgFBTDaVwrXH7mvYoV2BrGCqCAPbshoTgA0WSn0HGEc4_MmRKpawHSQ-sSVgJz7FB3QbFBTdPJpoAIZsykNACZcIEOvHx5vYoKSdXIb5x4t5c3uiVc1EAdc3qYTc3yvf1GlQIE8XHxE8IR90QrHwRzgn98D38TE-eubE_S1vE8EnrJBEnlDwknilBknm4fdtueqwwbFDInnBBIn90SfkdQAP7doCAAYz_XwDO35VVcAF55x3VfAaIYT3hQXUA83tAu0BAABGk0p-eyYMitEaAEg3CDDJPFKFmPZzDQ6MOzo1mc2SBIIL1Hx3Rlm9oGq9BEFq9R4kkQa9EiB1zAyBJPVdPSwKIQyCfKMlRnosEPdPuX8xUMEPcR-QZ8_MaoOlBFngcMOl3c9XXY8MQRhMTcZ8M8dFiIMDFjSM7npjmWczITTfEeWYA8fBHX0PQApnLjXMZnja61w4iTh_WYk4SgKfN7paM4cCYk4qairEvMzHF_YwGFN09cdE4geHE4ZZ6U4iXunjS8QM4VHAHPdiVbjI54DyrcZU46u7SwrcclM459HCQ54Isjsd7Pl7Bs4u-B7Pg5-JbBijmByFg6-J_YgHWSH6Er4P7B74ICUcA6oHfp9TPFBlkHfkOIHDENchzuo7DJaQkHb5kiCUCyEMN5_aD4MNzuyrAfPagIvP6hkt-r5nDP0C0_PDEJAh9tZaN7HDqYrA53Oj54ozHA7is0Z6eMoRj0HCBVVGEqYSYApk399XgEH9dAZM0-fGpwLwwv2K1ch_DCIHb0OwvISIvP5JkTPsZ7QvXJgIvSB1MHApmoPp-wZMryWFMXyRnKtgPJIN_DIvWdhIvF5SoSKJktS99G7nPB2IHMWyiBhdY_eKZ-iMaZ4kTTFmGkn5_sHbLbQYSg9EHsl_NCede917htGIKMN-8Big5jRZ4wvOcdLkecbRYUChXW6vu5jJMiY4FZ7ckEChBk8ebtY6xWHYVkf4r57GdjfZ9I4VscvYhnH8vleF_M3l4PY1scbwU59Cv97HCvfeAIm8sjnYPl4CvDsfzYTsbCvq57J7J7D5PqV-ivl4K-iXp5yBDMnngj4AMUoOnZwvzGZQ7OEiBCBk1Hu3WsIWQJ27Np5CBW8j3EO8gPEdXuDNayGuYkPWYkqyGsIWinyviKHdPhQKh6zggGvO8B9PwkH_jpc1FGjCzBmlUx4g71256dPRjmh_ATmuZ42q-Z9P7w8k_1R9tn7nhB3PIA_vBm14PP80CPP0A7PPwI_gHo1AZ67PQYvDY9CceF-i2Ng4kv_A-_PDY-oviF5MmtPTuvayD7GrkKburIx4Yg1U9O8CDZtgBokK3_heXJ_BgOcqjWQ5ht_9oTHm88CCTwSN6hvZhrBLie_oHAg8uG6J1kv2S9vmt190huUxMQc9wWQy7SKhayFRMU29tyCvaBvKDrM12-sv45-qYYFFzJv4_z0vWN7evp6g-vpOWQ8ul5uHng6sbZ5c8IJl-2vWsHMvGrCNOIMi9ATLkauOzHPE88H2wI8hljY8iKt3sCUmU8eDkIrH2wdkznBVrBlvuaDZE5omiA0vrdwjokDr2sfBkZt_dEnoktvccjFwfoidEREh1jOm2Okc6AAH8sDyvuIDdPVCEfAnhCUz1hHKv-16WB1V5DcAIPFmDD2tPglltP4IPLWqe3O7qsz6evp-3mjAMwKViFAWJC3Uqr58UMZ9w_LJifgW193fc6wFqun1zLy6d5wWx9wQ1b3erAt80rvc7isQq5yB5o803O1RmVBFd7quCp3WAjqaIWGCwRL1YER-HivLv2l1ETfd4sACv3-VSv1t-6wHN-VSufMVvwnvNvwXmfsxsUtQNZwa17PL-58LPVtkb2xgId2PJBt8YR-wi7viI6LGdswjM-iXs4Gi2EY10sU9kHuDdxiDfsYHj9pSpwAqgMOZKsngxueRLrSQtijFw5F5KYmAM-HVoBi_h4xi9jO2y9nAcZ2j-ouR8w2wETd3b0KkyN0xnAezRuZJxFEfT1VsL_ZiDbpu1eFFQgd5rzKaVnCTC4v0491FXrjuV6AH4X0OvY13AHjA-fBMZGPPxKhgHzQnPPiF5Tvpd5s8N5-525MbuxeUDdQb0Kggv-00v0MNgjvhGyXGd4fm2d4_M0C1gWl93_miCzuvv-0Mhhf1XD3tyKhWR3juUU6GWN31VwUMOwhA90GO995auYZZiCkeF9oFG39qeUkZn344d3Y0ymzs9AcXIQBcXRwE0OharNAjKeWX6NxUf64arbuj-rIvPl9y6B2J3iGfwz2oQTueJ0WOas1j2M0d2OYT6jmSeCKhH9xJvZHWVtep0HdnN6kvij55v4g-6AJd8zvD7gUfht3vOdym4f2mN4fmLyGYv-x74KOQSfE-QMl7dR_766khhNULgvB0sZdaT9AEXD8UXpT974_D7Ddjv3IzT57kv4j7fmtA6JvQ5RgBHAd8fjeAu-s7VevjELiejvxQnlAJ2i2hHT4u_x51ov0Kfkl54YlT8rPEz5WfQPw2fdg-xvfT_9I7A4vPtd9Tvc7gKf64fFXHERKf2gR6fxjCdu5D2VkJ6BQONT9sHC5U6fWmMeffD85CAj8NuIj7uh119LmI8z7mLd84fxT66ffz_KfyNCggYV1hgeF8YeMF5EHO5yYqpg2fP_Y_bveCzIWd173aikSmf9kPHyTdy68Q60JfzT-wh1j-mOGKkEhpg76Okxw2flryR2A6ZMHvPnQObF_e1Di2yePG0fTqgB4vjGd_TnwzJfpGb51RXlr8ZbvDeEL2jYw3mUGIr4xbf9HNrt3xZf6fRgNjT-2YvL_DYjhXXp4r5zUSeHlfKN41flm3MY2r91fWWla0zxsfllzeFU6Bypeqtibuij7pf8z92fFzqONGKgkhFF85CmT7xvmqW7v1C17vPCzuv2ZYpfV0OZG5iU9qST7T2ozoUmbuzufkoB52cmoWf_pG8hHt1ufTr52fQL8t7mxjHnoR7cur6Yz-SANtucz4ZfCVw2foI35TQo8DTIEZvahqd5zryQ_-gT-4vPyRszszz_AmGYw4Vb_cm4VUwudb7FKCjtJiwmb8O6CcIBbj1TT6WG5PiAMcBP32G8wl7FQGKd7fvqXEvoTAfDeEcHnNj5MfgNGCuXuc09r0XQfLaZC1pg7CureWGelb--TEVrmyxN57fqfqpsryTCuShQFfwT7pW7b5Lonb70-lKSvfF0Bvffb5xH0sTCuGQ8UKyESSuchxnf2r9cK87-vfckgT8lr-owU3iA_WFxNfl5WCqH77AAX7_NfZghMSOJr1OL17Uvpz-44u8GCOU51kgWT6xfs1-8MbmboWd1_GM911ue2z-efmb8xvRI5Ofgj7RS1H73gPr9GoA95aVUL8wiDz7Kf8uky139oReQj_FGwL5qNmqXHvsi0nvC81UvTH-i-xD-9mwn5uh7H-6AM94k_JiyR-0n6tD6T7ehRD99NoLyI45z7hhfN4kvgt-F-uXrDvYs2XjccwaBUd93LLGrOgVo8vjpo9tHFbl9PgWeCzsJfhLcl2e7TmaCzUifzv7mZ8_Sl48_MidCzhqu8TViHMTTie8T1id_mViD9fS9ZE8jibfLEX4dBQKGHT5lm-QlYIfBW18Hjz2b_zWEgaf70POh6WfZ1pyktTnyflToeiPtOQ30AJaeEugacK_sWpF-X0WAHryc3vgTzofmenOv8UJYfW0Pkv0JZYTTE7hL7CcDfYz4L6-X9ee-760IZq4frAl4Y_cg5OfcOYK_hn_6_7n_8_5H7G_TVDFquDpIzqr8_IFJzm_RL_ZvPJ5w_POYC8xH7kv637UTqYg0TWifC_SibuvFX4RTZ7-R7BJwbaCTGe_vKde_s39zQFN6iz1Gd0zI9z0dVmhlThqaq_b34m8H36GYFX9yzWFyIzh37-_x3_QO9X6NgqmeB_eahxmGqfVT798mWosiL27pV7Wtb9JfB3kq_ndQXTxX6BTjX4Tn12rHfknFh_4P-p_oXWJYdP5v4kXUK3YJU9fjA6-_NyEa_SMzJ_mtTTTlP_izpade_q3-yfUiA-7hiasTsad_mT355TvP7F_3oxh_Cv95z4qabuY77atiMfQALpyD2Ib9gvbFhJ_IwE6UgKYF_Rqc9tPP7V_Fb7Etk5AOeSKcbLr36xjDal1_ZJxinWADZYrP9HI7P4x_7VS5_gT0t_EP5hmJv7q_Zv5ozl3_xvbifsTkaeS_Xice_Wn8Y_b14Z_9yb5_Xy8u_Ol5M_Bl68HNV8277MAmBTLeO90d5CBEVkl_qiiqMG79Vdm7wKvISjB8rnozPvijZsmX6u9HKA6_s2_bPQ8fgkQgGFe43o9vsswof5X1vBauRb_aXEgH9D56_n4MuvAF5oHbnpk_if9N0rkPYHvN4Tg_N6Ntpn41HFn_Zglp-fYjGuKKjV7BBDCz_HaRqF0GwzwhKFgAqOFHpN5SigvKSyP_8mtP_z7AyN3VA27LEB290kD297KvCjAhEoDgQ9jv-UGoAgBk41ZoCEKHfALpo7KBxqHXpwvCm4om6BCC-q35JOwl160Y5kgieIrjh8uIjYkPQ8WNiCFtBrXlgoB_6M3Oj0SQJb_qjoQHiZQO_-m3oGEECgYUakAUl2wZoiljyQRTyQ9BHe1n7BsEGaWCgQqtIoWCrBGLgq-CqEKogmAoJnlkcoab67nsf-g6Ym3F_aF5xVmrYgF5wRzOAugRpaarJoIRrtUBecMRovnPsWHmBFPhKuglpO3F2WEVrdVMgc3tyLFMdIFbx11upmZ6xi7O6GoAjtVtpQXho4AWE8pxaaaiyacgFsmotcTqDF6jhQFlpkiCCIZxi6iLxQbRpa-F18NZSCTiMIngFK-ELW7ojQhvPq7RrPGhPqmvh9-I9orAHNcNgqOcBLWFwBeoALiPiGdwxYvNk8DK6jgBJuufhSbrxEMm7F-O4BgQFZBMc6OLyZAaJujfhMDJJuPKD5AR34woTQYAEBi2pnGISO5gDHhBkBvqRQHpkMOprrXvHoEmj86JQAtvpyasD4gn44PsIBSb71KNg-rPxYJnr88n76fmMBh3wcerMBQjy8xpjQmwQf7O6Wb0B9hsNCawHG3BsBewG7Jrh-DHD8AQFGX_CWrvBAQwGscF04vrieuMRUqjiVQlcBnzh-uMAIOziPATcBOwH66GNwLwHQuB64uPgCsNBQaTwLXP1QaTwXAbDYRl6zAJAYqaDQGGI0BJijAKgAUJAm_BYANAE0kC48MzC7FrVOjXw4lEXoSIFvIC48rbr9nGBOMBBrlguCDlbqgMgBMzirAblAP9CYgUoILjh0uNXmmNBfBHb8nt4d9owGTLjAGIzgUIHgGBCBU2BQgbAYFAHg6E_-BXqtwJd6dn7biKbQMZBk-kUI5x6TgsUy6_LnHu84UoGk8CFAi0IhAEfQcc60AOcekLiKgV-wo8DagSYeMvKygRvS5x4VlLGIxMBodNxgCWge7tqQptDVALmIkoC9OP2IfvjDgIegNaq2SExk5oEA3DYseigw7GYAloHJkmnwW5S5iARio7hbiBKBgNKRwLq4zoDJEA_ADTjnHkZA4D5FCNGBEECxgdjIfoHZuAGBarJBgePgAcqKYEKAnNK55jaB3gBZgaWws8BexAZAaYG9gIWBWADFgbwgOYEFQHmBZPrS8CAMVYE1gazc17zlgS-qGYG1sq2BdYEnCvmBIrh-ilMALYHtStmB17wSgRsIGQAEgqzc88RXAJ4iiMBl0mAAKfJxqglgMYE0AB6Bp-AVgdaBgYEjgSWBMEpTgV2BtoE7gbWB7YG-gZ2Bw4EzUruBuYECAFOBTYEuDOeBwYEngWpAZ4HbgReBtYF7gR04g4EHgUWBR4FtgV7E44HPoteBjYEzgewAc4ELgUuBSYGjEmuBqYHPgZmBP4G9gXmB0Kb3gaOBf4GHoF4AAEG3gYQAXaSzgfOBZkCLgcuBq4EEAOuBp4FWgV-B1YFwQXuBkLikQT2BY4GoQROB14HvOFhBIEE4QXhBEEHqgCmBWSSbgVRBcEGY-pzSevoxkCaBnMCjgpqByjj8FrpA5x4dOP6iYkGccLdSQNLAQaiaYADnHmhBU4CbynkAujhGgW3-Gl7ubtrg5x6ugSOgIaTYQKcA2wDSgUPm_qIaQFJBhkDKgXWGqoHCbAU44kHJ0J5sBhoZIPEEEYDmgD6Cu9KuQUCK5x7DgqZB5kEnZumCc4Ep8goKgfBxgSP8M4D9gf6okkFYAPKBnaQygaN45x5SwotKo4I2QFFB0EEkQUhBJYE8QYjgAPqIAMtGYYEyQZHAjEHyQURBT4FpQS-BwYGZQXr6iAAOQGmwdvrhAB0QkYEwAMVBxgBxvF-gizAu-v4IZKjMKAPkjmxQAEwE9qz-YCBgZarU-DDsnEHngfaBdqSI9jGQ8YFTZlOBkUGsQcKA7EF-TuA-4UF64IjAlkArgcmBUEENxsricuBaQDL4lkD7QT4Ah0HzQbqwhEFKgeeCVOZXOCFBy0FageRKFkA-ABtBkEFnQdWAXNKFQT4iJ0GLQc6I6EH6KpHwB0FrQUdB_0HaQL5BX94D9s0afa7GgZWUagBXAHH2xUGjQS-B40EBykHiOUFEhoeg5NJ1mHLIsMEwQd2BdqQIwYj2iACIAK4ATj7e-qnGcoB-gLoMmkFGegIAcYGWQV9CXLbqgY1BjrDnCnqBeeZ34MzBr0FsitPGvTiPgN-IbIoiIKwAKQDGCFgAJABKgLPUNmwEANwA4QBgANqiigAb0kmA9gB41ikAG9I_IiUgqsBYALLBWoBKwb3SSsE70j8iPyLawXrBeqLawULBDAxwAOrBmsG4orLBGUBKwY5A1sGSEklUGMBx4tbBMdLr8ojAjkAKwZrBssFngBvSGkAawRpAVsEaQCnyssH2ABageADawbakZsGGwejA0e7RwUmAHsE_IpbSU1IRwbqiAZJOAOgAccEaQGnBSYAawXqieoBmQErB9gAy-K4AVkD5wcXBMdLawQlA-cEuwb8iiMCVwUXBJcHawVXBFcGIwPYAVcGRdDXBzcFVwXqAgcHNwbqiddL5wU3BOsG_IpXB-sG1wU3BBcENweXBw8E_IuaA7cEtwdrBXcH9wRpAfcHNwQPBjcH9wSPBHcFQAC7B9gBJgMvB48FlwT8iY8EDwTPBU8G6otrB1sGewd7BvsFWwXLB1sHuwUmAlBizHq9BwEFY1qzsO1ZLAO_B5ErJ0qIisx7eQXdBwMGxQdAqwMHVAIUyxYJKQZOB1QDnHmjBIMGwAIpBdEEqQVhIaMDmQdxge8ZDVjVApCgmXE5gzKBoAJoKI4I90lZA_vC6QILgcMGwQcW4qIATQUHiViAkIdjBZCEOgXjBBMFEwShgukEq0M6A4_jNQYIEf_aivJ2qDkCwqEcAMOyepkSi-SROgVNBNMHRgtZB9MHygV04xMDAIUzBk0rAwX_Bwe4AISZB5ErJQeceXsZaQRkAikHhgc7AqQoR8FSMj4DkUsyiACpmkKzCzECJSLAgCZJR7qxAE4q-DoCiMABmQJMSKGKJkjMAOCRPwdohGACJQYWAObDrgd4O0PSOTs5Ounq7_qV6pXDuTmQ4To5tuKEhtACNuJEh5Cg3AAUA0qwEQFfG38AJEPEEFqr_yld6ow7IeKJcvTggTowOuk7eTgMYKSFBGnEhM4ASsKfS8QSptsAAwADDaKW2MAi8AM4A2MDGCEtA9jBywmSm9k45ITEha4A5VF4BPoCUYMBOMSFL7v0hvSFzdI6AOVSuTl5OHSyowvl6TiAeAPmOW05-7oEhhf5ggs1BdRBPUI0QFQDVSD6BOHh9YF4wQKA7IXVwC6DkxjBABY6ZjgegnJi--qCoohBtYCXAsKIzuO4YOoD8KLlY6GodIn82vfqv5Cgo-04RjJ6MAZi2VD-s8NpbSJQ-4HrNZCjaEfRRYF0AdRw8uKZ6Y8StYCgkzQA2VunANiBGwpxGwdCM8Oeo49qhMG1g4KFpSAbQDgTwoYihtwDIoVKGR6a1urwkX6xygHihSKHMRprEdNBNEDpIuASYft2OpGDgemuEimxLimhGpVRK0GuEvARMUEyhVKFvQOJE6p5Q8OIYyEg4bAPu0KFjOKdO8VSYoXyhw6TIoeIcj4BVhgA-_QC1hhMMSwDFAA2GXQBHACcYnozIaPzaPKGxYFihwxg0oEaiAXIH5MP8IrA_YGrMuCRh-ryhEKH8oXY0nRz24LEGLYzKhhfgH6jSoXahRuiMMC3QpGDOoSg6rqGuYO6hYKEyoeKoD4DyCKWQ6pBn8IGhVJodhn6hWsDdhjWA_UhWXPOAIB6uYMUaHqHYoa08keZWBoP6CPA4YFmhYogDzoM-uaE0oJ6hoOw1pjFUxow2LNoYlgCqKCOylqr0gIB8S6DxquRKQfDi6HkA9QCI1uYheNARAIBId2D1oYSA28Dw8KNcCfApMPwslgC1obKadgCjoTrixJQeYndgPwAvbMZga8B9rolwXTziQOjEIvDYob5WfZDkUrLw-pZi-kFARECBpMNWWZLbcJIAPKL64hShBKF8odDsY6xjYEmhAHzDoT6hBqEhoR5iadCtoVpAWZDYELYAagTtIP0AW_qGoSiARSgJ1Bh8fOoJYI2h8PDAZsGhrKEmOI4MNVRp_EOKvW4eHMGhZaHwAE6AtJagwtmhpTKPoZNOGaFGodQoGGF_gFHUqPRcFIHIRwCEYbySB4a2odihxqFEYeRhk-zZoCxOx_DZoIJMRGE-TkgMhhSb9DAqpghmQAWhQjByTkIIKaFQ_BkAPs4foTYEvYZIzusInsS5GPshBEgEsH96aszKwFh26GG8kmRgoH5YhGRMxW7W6GyoSWD24DchW7j3IY8hZ4DQYbyhZVTjjJ-aMtCjNGWszYbSnFFgObQU5n7Ei0BbwAnm7aBCgGWUFUiAoCOa0QCNVjph8UAdiCYIdmGkYNJhbKiOYYjEfcjWoUs8KtrYYWeSAfQ5uCJhlyDc4IxhySCQZDQAndIRgMlAfrwgTDQoadrhyjlAPGFcTIJhnGEfRohCwmF5YaYIOWEJYT7O_GH2ZIRO-WqVYbQcQsgHHC0G8WF6rvJA8vRtpDZsbJxyYeqwimHyzMphIHaqYQFy6mGIfpVh4coRKGVhuAxTABVhwmG0HNVhbDznEMJhQgCpyElhm3IxhGna5VxSrs3OFG4u6oP4j6GASFwACThj-Owch2F4iA1h5YaNzmv0B2HoAMAuC_hfqPth6GDNDK1hF2EVbCuuh2HmIoBIO0RvNuhgh2HF1LNhL2GbrkeAK672SDowy-Z9oUeM6hRUIE_GOUByYTAgrcBR1G7wwOEwIFMc3pSfYVe8XsR-7gvE057rrmi06GDcOMcQ2OHPmnNEfmgTWuwc-OE2LGjhCbyY4QyhN_wernHgU2EE4Uf4uOEk4eYAemHb7NLEaOGk4ZzhB9Rk4eHKNOGo4Xjh6OHYFnJgbOGF2szhgjiM4UvEbURo4VSenG4S4RThguFU4SDAdBzgGtJkwa704UwMkuEipOLh8tai4dz28VQy4d9hfmhUnqYIn2F84dUcR-rrYaL4K2EH1HLh9CBPxraudyLWvmNhDOH4DFbhc2H47tPUX8p3FMaWoUHeYOGWbixTAGZAnNKVMPVkgYg5SHFhuWGu4eGgMCrnUMXoz2EMmGJhC9Z8YWVAyeHmJOdhHF5-ppQIaIyYHt6UGeFTgJmSWY4YFnphT4AEotSASYbu4RdhC0T6AMXhdHr5zjiARsDooWNUwmH4YMDm6tru4HCAaNZfQvnh_KSd4XwQGWovHGfEt6CUPqTEx4bAmh-a1KgwdDZhgWHAmm1gDmHiJM5h_kg-YMhAQfrkQMLmQ6zV4V3hzQgE0H3hcBLqQDPh_SwshrvhsghhYTIktEBxWLwga-G80Mfh0SAxHKMADeEqevXhJVSRYWNgVDR62tFhhaFLEIWU_fyefG9s42C20PKqBQAzVrTh_OqVYcth1WFfqJVh4mxRzESh_c5f4U_yUeT_YQyYheE14bII4wTLYQ_hTeHUYI-hi7YETltIg_jj-C7hmuEzYfFh4BHBAGoei05gEaMAh2EkHg-hSM7LYXgRCnxobg9hTiA3YSO0J2FsEaVhCeEF4RVsV2E_YTdhtBGLYCwRT2EbYQDh96BvYTdhIOqPoebIDG5awNmgSOFQ4VsA9ODa4NjA8eFR4UwMaSB-tuuoy2HA4W7wy-bmyLsak2HEEXbhihHkAI7hbKFlvu1ES2GjAK6cy2H5pjF0-7y6EaDhWYSjAL_cLlBUEXI4ITjdFNwRSMYLHsB08pDCYdARZJwbQBO-7KHgev2210CkaHy6i2Cl9sJhP8IFQK6csx6lMu9MmnRIEQXhm-H94V6MdeGCrpgR9xZSYehghrY0xFEmdBEUYSm2O2HelKZ83hHqEZ4EJBGiEcgR4VD4NtYRNuEKUIO0LBGnYbgeHBE-AFwRdRE8EULwfBGsEbdhbUTCEVURCWGNzhIRXQGW4SdmhREiTvBw8QDq4fbhShHqsC6gM0YKbERhI2FUJEQRRiATYfFh5WFk4QsRZhGvMhQ2aRG-Efs0FeBmxJsReAwjEeVcDRF7EaYR5hE1HApsA7afYXoR-vDbNmlI1VTYAlbhQRGUCCERQZC8obBhi7YfqLDe8BFIYe5yZn5zxh32uS7sbNtO2wS-IaNe3t7enh8wQSH2fvaeLV41em1ezp49AVk6CJEFXlxIHjgy4uzGVCBfOJsAUQAp8Jh4-nafTKcA5PCI8DgAVPDg8BdY9PCaFPuhLPBs8D8hHlxvQnQ-r6Y1vrlWvKQFXnJqw_6HnjNgVrBw3NRwCbD--kQgxJH4EM1k-7xdyCkCUzhHgCBMxVa2vP0GuR7odksC1dpe3hMAkQLisIKBL_6JAG_-nqgHegIQyJEbxr3AmoCZauuaX0AugB16lXqSIDYsScDAav9wDQBTwBJYiZInepxIaJGOnhiR-8ghKLSkDjzAQEIA2pA2kZKAjFas3D16bo7whk5uRzjejjiCX8Z-jr_GAY4NcFmweNY-NnSwT7ZGJMpIMQYEdunY30A41i7yeYAydvmRdHboVnneX5Z6gMveNQKblvABY7hEATGQGSpeKs12omLupukqgnYYLNkq4ih5Kg1gyZ6TJkAmiPyvllYgL5Z1XO0qnSrdKr0qkKLrABkqjZGtdo2RiirceJCqqirHuBoq6cD_dtWA9yoaLDwYjCRiKC1wryqP7ml-w16renkCntwZAkZY1H5i9HTIMFY8oroev2Y76Hfy4KSZFKyud0DdQi2RyPxCKFORciozkXVoSirzkTYgaipLkWLydKqOTuVIgWQ0pj7CqZAUllNYEQa-xGJg2jy4fgPkuYzXkf2MBiIyoAEqMFGCKtT4lKgZSATMWmAMjlmciZYcKuZo0FHcqBEq76BGwBQgi0DU-ATMWs4F8gRRDUhVFqkQ_7yVqqIqaUgpLoVIeUgz0IjAx1iIQFwA_Kq2YA9WgPrGKpasFiCy6vAezKDbHudgesCgiBlIwSDhYMmc50AfbBlUrS55lpEmuyoAtJTQF8CjND5g7ags5syaWBZ6wlLcEyjezCJM3C58hlIKOCCa4AIAeW4vercAHSjuAP1IYG6nACiounrMmheA5Ha5oDVktlH-AM82aQhkgPYABAAJONZRkGDvcP4Amka8wBYgj4CIwJtaZoSzEDeoKpQ2KjYsl0qDGGWRSiopWBliX7A-UR5RsWDVBoscOjBWBDYsSVHceOXAbtb5Ufx45cBEVvr4RVHflslR-ZYcgBtgaABqNAzhgQCspmmW5EqugDowaYQBURlRjSjerorYOVFyYDYsxZEidmBWYnaPaANRoFalkd-WgB7YHsi2LHY-UHFB01E5kS6Am_SjUfhWEFZ6gOP4VHYLUTQAghEcoDh8v2YxUXwh81GkKDR2pggbUUdRjaycDIkA8noqlMkApgj6Ks-6sFHCtDu-JRZZhFIK67S3kbNRAVF-UR8AbfCIrvEAdmhIUfagM2AkgDNgl1G1oPtgcVEykOZReW77YMDRmWCg0Z289GivUWkBjepWWqdRRHZ5kTyw2ZFnUSgQoVxcJB-Im8TpkXi2ATbveO9Rb0C0tGO4KXAaDGB-eNG2MFBmFYT9uL2YKpRBNik2VQaFkZjR3QBMFnL4SwCB8OE2JNEA0WTRguQU0R04aDZqoa_BuTZXth4AjNFoKAIAN7ZY1lLRL8SXtnLRWSzqkG6gcvhdzvZkn1G4ALakVYTXwiwA51E2uD5RX1G2pAUGuaCuFF58e1ED4HjoFtFjSPdRaFFTNDWAPgBu4dbRcmCtaPr4sND1UZrhjVFspuYAqapg7mMQhtG4AIEAqkD4DuVUmtEESOQAEYBjLldReOj6KuE4H8FBnMr4wGrPaJIG_tEdKEbRgaRVhFjWikpi2AHRIhSPSkpudKgkUdhEI6j20RYAjtHZUftRj2iJTmHRQdFoACHRD2Bh0drAEdFR0WDRKJxQrjYs8MCZYa4Uqao2LInRcKIf5gq-QNi50drR1wRZ0blKOdFp0VrRgaSh0bnRtdFwgf1gM9GT0eHRkdGbjtHRpvgrKh3ROAAp8qYi3dEJ0RZCSdED0Q3RudEdELzw8jgfKqnRvlG4ABDymdE00QdmxGC50RDyPfoV2gzu6VFBUeZojtjO-vyBahBu-nYAfpHY7ClWj2GZ6BH6sTSukYGAj2yFfA-gGfot-sCQzTBh-Amh7KHM1sCwozgN0Z360dBMjKAxZNzt8n9uTyTQMTuOUACYBnAxVyFRYJ1mA2TiVHEWaAZ4MQUGE0RR4MVgBKQWIPCBpRhqkLSBaLg5oKEG0XAWIBsBHGFXHG0QPpC-5mfRA9Ct0H3mZ9EnBjwxHWAB5kPmimSCMYPmErL4hrYExDE82JjQvqJ0McLE39BCMWk440T0MWIxTQZD5uqG6wCIMd1A8DGDGGkG_eb1LCAMEYbb-urmvgYG4K6RcNoNAE6ROADfyko8xfhNUN0Gi4bSzlDgydDONKawsfpxrDQA41yzEFhI1bKYzJ-svKEMKty6fuCukTSgYTEq4cRgUWBdmHZR1GHWMXB0ltAhMWsInVGFKMrwcFqM8HTBmuBRIRWQbWBf_ogu_2AGMQUxGVG6lPEwhNwvodFgkTEkIGEKNRpaiMJcG6D1CIFRCTFljIZRTTGd8PWRRCyNkS5YSwCDkXgs7ZG5Kpqqw0goMaRgeBBGUbLqTGx2MQ0AOAATMXTgpsAtMf4APrCNMUJRXQCLMVxsVjHjARRglTGB1I6RMzHhBrYGodHh-n5EkSCC5KLa2BAHENsxEGapMdUxyTFsEG16pzEqhsQx79Bp4NyGJDGuImQx26YRMckx5QAfMU_RR1AdYlyQ-tBKMUHQp9HqMUHQ-yCQEEQxoTFTgKf41CjXoHfm5EBgsUdUELE6MXLsmKSwAG_a7ChP8CwAlK48BhcxPJBXMWgekbSc_jFhW3LYiPyAgbTChlFgBxDOQFNmqTqtpkbA_eTuBoSxWsBpAPGM3WAwdorYCRbtJCtA_TGZ3sORBGoV8GORlxiKOnSGysDbwHgAAKyZehKaEJRiuhEAkrH6ekA8WGH9MMyxUWC-PP0WmXr38Iqx6TwfAAshBACP7vx6unoKsQ6ourGpbPoAxNDchv-Gxag6IIDQ4aA4ejiUbWAasRKWWrHmsTQAhrGVuvqxlrFy7M6x_Zwr0S0ABzR3otAA1uRL1Po80KCr1NZctqidivICxlDb-r_ssu6aPHl0sKTyAlA6t_g1YXjeDBxHFvaA5jH4Bhugi7RYtHVCTdqYAPoRXeb-jsNoYy6HjE9R0nYj7MsYOwYdDHDG2HTn4NWxBmC1sQ2xNBZ0DC4xovrZAJOYAdgsDNpAbAw-EAG8EWDNsfMArbHKehgMtBb5ECOx3bE7Bm7hyna9buPm5m5P7kVA9m4fFJGRno6jOBPmXbFjsfnYRbGiDF5ulzwb8DIeOh4eHrYeBh5KHjlAa5H_KhuRzyrbkXnAbyoouHHQpip3cDcx5WDYgcxAuIErwklECcYFkTWxPbE52ElEb3oqHjZuwHHP7rncVh7uHjYedh51Tk2yFRD_AacWMaEIXhYAosLZIAyG8_rMTCWhtLGrpikADLFDRiyxNJBXMRyxfgB4iFK-WIb5-lhxmABoAFJAtKDlVDkeejFkiAA6vRiPNtCxsWAUcQUADLGdJjahrHEeOkxx7NjwmB4BWQT4nA72x9qTEjxxlHF8cTRxOAa7ENxxmjq8cc3gAnGjGCL2cjG-oWJxda7yccUBinGiTgkwibq0cUPq2vD5CkbAezgRgKxO9kijALdA8jwqcbJx4nHqcU0BJQEouIHS6jpnZpyxiTFbMWyxuNTOcW7W6Db4cW8ghHHxAJyxfHZDGBeAswCGcXCQfnHEcZxMpHGZYGFxXLGJTuyhbHEzgBxxvc5bct5xfOjssdFxlcS0on4AeRYqbuB4bdz2qB-GGQBLQHoxl_6OyGrsIwGs_Oqaaxr6_LPaJD4ZBuuGIfyJGlZaPZGVKn2RdSqOcZVxgGQZAH2Mv-TqQLnAs97SLLnAs4zcAj4xf0CiAtfKUUgMgHKeZSp9Ji1xQF4SGHUqjjpclO5gC1A17jfuz_jUYOVxCmTHPFFIkwFsvBio23GLhrtxYLxEOtq8ZIxfRjWAm3FgvHg-3qhVRG8GIP7B5Lxms7TxsVM80KT5dPM8l3GFaKy0xZALUBcg3XEdcb9xaLy58GGUrXQ7cY7Iq3EdcXPax3F0OmC8YNSNvMD4q4b5kStqswSGtgZKBa6wwI28JqQX9N3UupzGnjW6H0wz1nJ-en6S_OHm236eeMDxttzPcQ-0FxTvcYTxNXHezOy-yTobcWlQAPGvLgI-zPEEIKOMr0Lk8QIcoPE7UODxar6xYhXgwgIV4NLuQcg_HGjxmhC6fnTxyR76AVSIwJZjYL6SZgGmiLzx-lAs8dpsKvGQEOLui3FlkNMSDCqGMVsMM2AHAc7wF5xFWlKWTRYbhkZIR3EW8RDx1XHTqLVxWdgPAd8BTwENQl8BRx7O8RRMVTGg-kUGWbFTADmx7DHbvEYx-zgQAGAxyQDmMcjC6QEn7tk8DXynFqu6mxQYAK8k0fFIbvk8CkzFqL9RN5H80VWENqqXkWnx_1F60dFAgmisrpUGH3H3iL_hVE7kBvfweSTckAQ62LEzgFSwWhF9zkCIVvEl8ZA6Ya5kcXgGDHGqccxxRWHYEJQwcmBYUK-h0TGdYIBhpK6n-Fuop4D8TN0oRnb3cY7kX6Aucb3xaChj8aOAE_H5gnzqT6BMMHFUE5ZYYCtUfww9hv9xHPFovCtxPO45sSVxO1Bq7BrxGppBfOfxVXFLATQo-2DKPks8SvH3QKIwMgAxdFRG1SH8hqhG9uCUBt-Gh-APhvjgEMC2-BdBw_xqgbkxoKCkwDXcCEZjmLax9UCKRuJGkAk2sQng8EYSsQVAzeA2Ri7YkrHN4ARGYuCmihgx7mzxdNNGEjCWkbTAdMSbRhecdZaI1J78gMbUfjoaoMZvxKy0u0ZclAQgsPoEIAwJO1pwAswJMgI87gs6rAk-8Q1AQdA8CUk82AC3hu0B2AA8CZ0BDUCdATwJ4zEdMTAJbWDSCasxs3LAmkiYz4BXMRpGlzFucTwJqfEGIn9RpNGtIA1AWgnXkbnxWY6tIDwJxsRYrlOABQB6CVUh8gA8CUHQgTjiwTBojvFu8TcBtgmB4GK4Dgk-uK8BuPgMCeTAfsQuoKVGsAlCTITcLTorEXMw1AlKCSVI2ETRMAEKOhoUkEtG7PFMIOD0PAkPPPEJYPFwAq4JmNB8CeRGOhqCCSMiuQliCfHxnMASCYUJagBSCSsxiwgaRvIJiwg8CUIAIgCqCYEJrnF-RJoJRsA58boJgmj6CS0J2gnp8XnxFoSmCd-65gnBYDOAVglxwMh4dK59dleCb7C-oqOC4AkRCXYJXTiw-k4JMLguCToaQdDuCQ1AnglO8csJwJq-CSTE9EZSAEQJ-gC-RvjG1GB5MCEwq3yGXqfgX9HJqISRYCClxgmYzt5W3scC64YS3n8B3VAAgVreBLDNnt6aJD7BxmiwssbTASKatvENqAp-_MbfSNWA77Fy5kJ-2V5WIMwxKAE5oEFebrheCarIDwn23v62rvFLCbj4pt7YyFcJdpD-8aLeGxYUgSre08g9_lYIHfY4iXz4dGozIYcwf_AmkYYANiyrIQ0QyqBQbDDsj6EI4dthMZAgpjQA_vC-9K8yVwCciQQA_vCMtteAxNDjKvGaVWgXomBWM6DqsOpASS4isJMMp4Da4It2nY5PUP7wkwx_ynbgK4x9TiqJrdRWcF4o3IlQmNegbwJciUKJIolvlpMqLBg5wJKJK4DSiZb0as4azgSw8omjgIqJHcjKiVyJaolOiRqJlU7aiYBg6d5PUPXSPImGiedgfolWQCaJoonmiRKJIZ7WiSKwMol2ifPOcokzoAqJGomngPyJ9dLuiYRcL6CaiSmJVkA6iVYgXij-iQaJcUBGiZkiIYkisDgAwolhieKJlomRiRCO0Ym2iRvW9onwQI6J6YlKiSOkxYlpic6Jmol5idmJPonKgk9QndIBiYWJQYlpYXGJBLBliaaJEyqVidpCUom1iSMMsYmpDE2JHYnJiX2JiMDtiZ6JronqziuJPYnVgF4o_YkFifFAO4kjifBAY4kVieIoEYk6gu2sM4myiQ6JCYkeiRmJWgQbiauJGYleJA-JW4kWAHPOA4nxQFeJR4nliWaJk4lWiTWJBLAxifWJh4m4xDeJzYkuiRYEsYmPiepARiBzzjmJ6wAgNsfyH4lXAIhJigqliT-JE4mniVWJ54lYaJeJas7H8vOJYEmLieya-ElmQNBJ39QkSRvWx_LwSVkkj6G47slwH4iLhCKwfWEqlG1-qIDH7tlqKEAhlmAAmKqVOPCYguAgFk5gsvZGuEJJR6BoKLgufIjiDEiswkmmFNJJDeqSSRFglqGC-DJJlOShAHxJWwQ0-MKA3Qx7YUjOI_jejMKAeB7V-JO0d2EoYJahG_iUrIL4pghKSfCYy-a3iDS62sCOAJgAn2ARoMTwo3hYAAzQgpZmAI-hoiRMSQphaknyzH9olD63iBxJBQgksd5JKaGJMU68ivi4tPrh10iiSXZJEkkwwlJJGkkqSWPqBtAKMmWQOBHp9A4E_In-8BrgWQTZAAvODAjnUGSIRGD0SfZqtjC-SfBALElUMMFJWWqhSdKRW_JttnVUlqHyzNjIj6G9Yf5JmCAP8PjRtDiUPpahTXxiiGfE6LAygMjg6naAgOmiCUy-2DlJKokLzgNJM5iPoWFAvpijnP3-EqCmEaFWe0hjFqKgVmDNOILgHUli3CJOqQw1SWtJ88AO4a8yRGANnixhySDqoCKwHIAU7ncR6okCAKoRrhSFWu2W20lPLO4AS-6dSUphPUm2MDdJBLALSUjO-yFhghPAzEC-9GyJFvAhrOESK4BR1DaJTnChIoZAHsAjtrng6wDfSf1hv0nFgmjJ3UlnxN4gjEmlRMxJXUkvoD5J-Ml-SWrMViDlSWfEVUmJADVJDBZ6UZTJJMnVSYTJ5vqtEUjO2uJ5SLDhoMms4BDJQbT3AkjOoUBbADDh4AicyWbQ3MkoTqDhiaAO4dritLiUiNWAHMnzAPDhiQDqsJuEDuHqsLZJT8YakZCRQHrmfqLMS8Y0kJIA1H7f_kgg5XqFcIJAaY6ekTRATp4-kTh4jn6JIc5-l3Y4ePaRdgB7MS6RyTHukdUgMa4C6Lc41GTyWD6Or8bXgf6O7ijVduoqQPBJWPV2c3rMAuwAQckEKnA4dXZl8OHJjXYreiiggHjuKJwenO6T7kfxRHjajowB8PSHkQRxbwAbJECg2ljOAPnJtSxzKsbu6UjlSJdASrymLsyAqCQeyQMBXsl4_gcAz-biWAQ4ASovvNpiAKB2AKWuCWyfUM84Elh_vGtWlSAw0PoAi9AN6s3wHyr2cSOq2Sb1ydBAjckxQL-AyAhjLoFAL3pgAAk4dgD8dkQAldA2LI7RAWAwwGZAG0g2LDdRe8kDypX0OHwbyVbWK0iHyS0Aj2hbyR3Sxhbl1mvJz2iaRE76RyHUfg2sfsAe-mgGkTzQMeBgsDFCYIYx8fqOTv8xzfqgYOgGCQAEMQApLHF4Br8xQgBkMVAxYCl_yW360CnTEsVAeYwgKZqIuDGBpFQxw6i0MaIxz3r4sfgpseAGCeNcRgl3kThAAjEmkCQpOgkZ8R-UynHoRteAaICiIObgAwm2MPNgRCmxYNQp3QnGCR-UfwbVgPoxyDGLHjbAOVy1CSIIIeAh1FeRpCltCWUkZgmkrpYJqEQucV7xXHFkYCXJERRzbmERcilDCYz4Wb7B3OWGpBDaqOVclDD2hja-himaKbOAuhTpsKwp8ilGpBrRnfqMKbhoVilaKT4U0qGZbikA7GS8KZsxrehMKXgALClmKfNgXClkKfnxdhq2KaRgtTFaZGMAezG7oAVxK_FHhioJbnGPMcUxozgVMQq-M_oN-t4pjiluKQXxMxRRySHJmXbxyWB4tJHDSPl2UnEnSRlkzQBmFOMEoiRYEcopBaQOKX4p1wQ5KbHJDXZgeD-E2oSUAB0gsICQYI5UFTR48fQp6pDpKfUpmRSPUX3O8fpeKXUprimtIDOU3IZjKcwpBMAZKf4pnQmGCdIpMzyMMWMx3im-KRMp2imZYAEpyynv5kWh1GArQDkpMclHWGHJXSrceLoGMirTkQoqDHau9pHJqXbByccpoclxyWcpa0TddsosNzEmkmkp4ykWCU4p3L4qFG8xMyl4APMpgmhTKRG85nSm5rl2-XbMVrho30SDoXMAsswd3InQeZYeGgpMcQAtsRspPymZKYbkbfG1KaIgwKmG5FNAjSknKc8pSiqFKXl2FfCTMHIJ6ylzKYMpOEBFCIu09yQJ8VFguKlAqbSpHNGrAOipNKmbKTYp3pSMqUgUJdDBodypfymJtiqxAmFWBi4pmKmTKdk8fKlCbhmg3OwRqtwwqikXKBU8o6iq1EhmqqnfVLRGbKkzlBKpgwlYqcKp6zh3Ns9gqCndjPrxmbGyAn2OczHI0O6-iinoQJUGOinWBH5QDqnqticG2qhh1C6p21qMCS_8394SBnI6sjHl8WEp_fZrJsnuC36yXskpQan9PCCRsTGhKfEp6XF3PJKk8Mr1MUex-75uqdu-gxjmhLJ2Jim54YMYr1BetkM4rCl-elACLToPPAaei2CNhBvuiMRiYH3uw657un68mBZXGvZouAiVIAOsLCEdqtyoUALcWnTEsZbtqbME_YzLlMR0l-HqgNWuJayJrKFIOm7CFF3uo1rVqS08whSmWinwG2EKRGNGkUQaQN82C6nG5DxOZEyyJDDAGakMgPfwPE7nFhN-o8mJAJeR6AB5qXG-b0Ai7OMQSqmskPdR0YShsYgkewAy0I1I4xjnugkAZ6l_rgCwuERQAHmpIqYMKr9-mgxHqSepean9-N1qU1F6SXNRI_ib9LmpaUjEHiZJDr5WWtBp6-YLtMv8X6k_qQamf6nM_n-2bP6RcdLgYmCjNMyADgTGSFhIjowjqG8ArnxCUH4GsCmUAIkAxckeAP10V6l0aYQQFdYMgL9u1GAkaaBG16nr-MZIH2HEBFh0bhHIZonQSQBAaTBpmGkBNthpi9xAuKrQtcnpBGlIW0ABHKOo5GmRUHQwnGnMaaIMLnH8YjsoZGkX_FUJ9Qg5kFExkqkgqZakxNHWvgxpHBCqaQd-kXzOAKBRxQx3ALpx9mT6aIhp-amkrq2M7YzHJmSwp75L9uyIxDHkYJxpVml6UcVgZ_yEIDOsD0w7XoycaOw6nviecAJf6ns0uRBu4DupMnIDPmu-7axvqWlIv6kF4WfU37akrrmopmlMaZlpDCqfkJQwtHEAqZjgvmnWaQFp5bSsnELAaLzESFrxEwnXQCR2t3gijvzqckyiqbVhh7F37rkJoUnYvLnoFqlzCUE4A-Y5oO4J43wb4BWQQB5PjIJuHG6gHpzA4_jcbniInQEzabTugxHjfq1Rl26T7DTuhO507qPc-WrBHqhgnXQvsZNqYGkfzlhusR7MiOZuf87zTgRuRG5Lacpsy3HZqd6UUAIeqckQJakSfNlEVlrxafzhWB5obh1o4GnHYZAAeIg1aXAC4B5z-HBpAhTnbr2p7e4uSBnuIOqofGPuze7c7rwefO6z7gNEC-4DSAWGfsRqtsjpxkh0xNnWmJofEZOQeGnDgC4Efe4e9NXA0ABq4Zq2MUnnDqDpfjF8aRbhnxHNseoesa4tqbEq8jBdPP3sCjx-MaLiKBbuAJOS84B8yvjpFubRkbG8i0j8QFpAPmBEwGjAnaEWuhlIvURMBEDQ6SYZAGOgH0y-bhlIYryTYspg8eJMfBYRYmB25qZgjTjc6eYAbsRiNuTcOmFw0FpgBSa1VpsuFwCjXMnmzICIqKIEkHoePk7mzAySAAv4nxEPVmF4tTD26dRWoNBXjuzQQdB1LNCmD0T55pHAOUhy5LSgO0nslMrEUyxaujloSQCfEZXC4WwgDO7Qv2K66UgWXOm_Zpbhp3C-bl_kOjCEHhoe0C5vvpSBgeD2CZ9GNOC-bpv0fWkX8PkcgukP7rPQepbV9FPCVelUdD28tHQaYPIGdgD8AGK8kLhlwmnpnOnBYJnpFeC-bm7hEukJUSQM5GjAXCXpXTh4iFpA5elSHhVAqwlQsfFUvm59saPpeOlbGnTIsLjHlozp7yo2LE-xGLgb6cn4sLik0Lnpp2n0HnUMQZz76Z64AtovIUf0NziSWCPAjzishkTgPG4C2jDAFbF-epEeDwaFSKrWPRyM6Z7JgzgLyanMaOBb6REox-mBQH5RMhQMFkc4ABlcepuEoBnoITcB9m4QGYapluHn4D4ACU6z6QNAXRE-8UlUfuataFgZN8mYGaQQTh64GQ0GBBltRDlpP5zcaeUMfmluwrQxdMSw0YjE-Qik6jNuceBgAo2EbBnzpMDqlxi6qWwpPPjmhHSukgJsGTYqnBl56foqPBm14EYpvynJoPDCTaLxJB9pYg7GqcyatGkUkMsxGCYyCbwqBml1QNi8Ymlm9hqpttwOBEXJ16lXHDppwLqIwkKpE2lMGRtxiPHRqbgQAymWGTfwRKlPKc0pzYjFdjU0Z4CiKIhx7KGBqbS05zEGGRPUbnEtAS_kBZQicVRpnzEoYPKpA0iKqYxpPNQKHPH64Rm0aUeoAaEEgL_Q4anhGanwavr9ruAipQEIvnEpfkTDaYeG7VT5GeyxPMyJKU8xMal-RG8xiRkmGQEZ7DSrKUEJAwKRvuUZheSxGYEZVRnKuNepL7CkMRgpqSR68WyRYohQoULeCXqkHOL6twnE7AQgisZ9mBOAJRnxXn8Jqt6kyISJD0gLGda0kfFQwXbeujplAesZKImbGVICHwnhLp_2OJAyCVMZL4iLKVIptCnXAvnIhkhc-JYpbKknGYsZOaD2CViJBImDaSJBOxlxSOQ-WSHhCXRqJ5GEsV0ZtIlBDjYsnYHOyTDsSCBJpJExbskzIEx2WNFEdn0xrZHAVvR24FZlkYO4Pg5RjjWR7ihdMdQsPTEQ2JL-gPCjKu1wv4lTKsXMicm4VNR4X0S9NM2hxhltGUcAh6DpQBchRDBmGUjalhm6GU3WxaiBENaM8QAaVlZguK5_aJIGYKmgRm5xtjH2MQcxKiC_EeEE7NB4TmwQd6xJ-iogJrpyJNXJJyCp0LrpzsmuwieglAY3MWEpQpkzMSDQUplksJKZsQDSmREGkYAjKtBAYyqEmfVcdeTfOFgxyWmcsdaZ_ZCiIdkZthmgjKwAgTHVcisQcJBsmd5hUABcmRgAPJm-qZhhbfGBqTpIvpmAgDDh0zFliYkB1PSEGFXkzgD9WLTwYal0MNZpvWAGSHBO5J4q9lapA25amboGStAo4KycM2Dj0gJWmWCYmXnA2JlBnCJW1GDFmd4qTZFlmd4Z9uDoxO0xCglZmVap6hlHGQoJ2aj5nhmZM26jMfn61qAyCQNuwVTMmUZpfrY3MTz8dBlzaiVgcRaWaWVpUDDQKaqZTNQlxmCI7xYOBF-J4lQmmWaZmEnqVM8aboE_rCuZcBgzJviZJ4mbmftgrgAwzKrOwEnynvuZppkEmRuZD7jPGlhIy5lziSKwe5l4mVeZh5m3mYtxPhlJmcVgY7rpSXLsNXRjmTZpJWDLySEAESizmV-ZHWBYABTuiZl6URxsdwA_mcvmPG7KKXOZsFmxYBlW4xDgWTDg8Fk5QG6MoEYYWbHg7YjoWTBZ35lh-MvmFgF2GWRgeFnmMFBZoSmUWVhZvJgambRZYfj4jsfaRiD4qQapA5naGQapKCm9mQoJ_ZnSGfqpVhnchhkZYFlEWSmZ6fqeKfEpGRn5QLz6BD7choGcFgA2LKI09aoXNMBRJmDwHnlhRTopyHHeSKksqbCpY0REafGANiyqwAWA2sAAKkA-b7ZZIPEArFq2uuRWwjROyHrswMCqYLVWmFEhcc9AeSzqCZqEtEg-qB9Qzj7DgIIEQSquNFZc_BE9ABLy30SGWdEsv_yVqr_8tVZe0c1RWkCNSPOxCln3oRN8PFmLCHxZ2qnSqUHYGOkSYSCsvFmoHlUx9ZmgvFapI0l56bd0qphvtBlZWWgk8S1cA6jO0UcALYZ1URU4ngSxWcEAvtH7bot8eVl56Qk4lZmlmfFRQZz8WVKpaH4DWYZpsqnIYQZ2X_yWhq64t2krXNjRBtDQmTNZRHZ_tnzqaNGuUTfwy1GidqtR1VFfqCtZNHaHziZpfZlsGTh8O1kugP1RgnYNkTIqvirxUctZMJmrWf8IwGYHWXnpN1FJNgtZrlH_npsxhVlCPMVZfR4IUJ1ZMsnKKR9ZNCjFWdiQvRmdhjX6Qik4bguZhFm-wsRZIwqbMfCxcUAAWcmZ6GDlWRmgY2kT-B0RkGkQ2TDgxklSBsn41mkucYGpWRkJHtPxNUAE2ZRZZGDE2ULg1mnDpGeCnmzcMOTZkFmb-HppyFk-kBlWTNk1QKBZEdDU2XGpuFlEWR1g7YjIaQuxadRgyIjZBNnxKVkZpak7WmBpgdhEAMVghknESIjZONnLaXOZYtknMUTZgtlU2XpRak45QLT6bnJ0caqOrzKI2WPgyNkNcVjZDmhQ2amQMNnjuvLsKJDvVqLZVTGE2bz6ktnpqfOAry7ESB-w51AMkHbZSZnwUJvxwrbe2TBZXchc5lXUIG7oQF3I2Obi3nBIdOb2EWZ6dOYYDFDKdNrGjPKQ-Nko3FjOFFz1AFqAX2xaYNPAXf75ABwqyQAaaEdBOISi5qwA4ubnYM6RH8A7ABr-BqZ5ccEBB9DC1mOCTwrR2S1cftnygLEEuNBKZjXZCeBJEZ9pnGE4HhBpeIgRAJ_cjUGcAIIRSFnxKWUZotrOSUJ8CBH2aRFgcdl3WctpEQCYPHXZIvjc1lXSLx6u2aYB_fyt2X7hQRxDgEc0PdkIMcZAiNljOIfZfCnIcSfZSZkmOHixhsjS2RjZ_2lgyErZpPF_yKC8WZkAWdgQANnzgFapxZAY8TBK2tkDKjNcyR7_2Th8Hkr9_PqZdWQWFjKZqChaHHYAoHqDqfaAEal5OoioRunNgOb4nAT42Y5EuulK5pEeyR4JOLrZLVwY8cGZsDGf9DBA4ZmViElYCl4xmXGZ_hATvidQyR4pCRYASz4RKeGZJakaVn0ANzxoNtHwMvg9Ke8GlRlpcWcxBjFw8Sf6IsxLSScx5QiigQwA-MKtwufiAbJFgH8ApYB0ghSwv4A9YvFizVa6YpfCXBYIwKo5oBJp5l7EApIFwotijukc3FkEOEBvoh_AFCCDnNqmlmCAAT8AxYDVADUKYSLoxNxinMAcQDo5b6Kj7LLUJFKj0IpiEkApwvDAHdJWSvXiejCagCnCabb10tHKmMDBOVxy3pHeOfwA4TlEwJjAOABd0p6SITlHwGE5ZkAIwEUq0TnXwEABoQAy1u3CabaJOVkibWipOcGipo4ZOUUq-qId0jk5RCjVcLVwYTldIhjAuAqtUiTeUvAy8BCQ8vBDMpfCabYw8kUq4HIB4kEIfQAhCPqIYTlWQFk5pTn1kp1EIKiVOVwW0TmJuKCeaoSFOZk5XBbS8GYRjSplOb7JleY_xi3m7jSFOeM5JTnROaGOyZKwAT7uW5aibt5KjMKIALbCnu7cwt7u38DnObFutTmAAc7ClTmHOWU5NIJ0gkZKhTlZIh5KZTlDOSoSVpqoEvs5EznROSN6mIBhOTDyGMCTOVEie8ZqsgfGFZZhOc05yTnROQM4bpEDYvE5mTnVOc85IZFWgGE5ETn-8FE5CeJnMBGICjm4AK_KOMLBAnjC9YrfSkgAbCJt8G5sIZE9IPwA8gAKADYJQAA`} mdxType=\"Playground\">\n  <Map viewport={{\n        center: [0.026, 123.61],\n        zoom: 5\n      }} mdxType=\"Map\" />\n    </Playground>\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"],"sourceRoot":""}