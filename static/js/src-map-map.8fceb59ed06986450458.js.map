{"version":3,"sources":["webpack:///./src/map/glmap/map.css","webpack:///./src/map/lib/Pack.js","webpack:///./src/map/lib/pelagosClient.js","webpack:///./src/map/proptypes/tracks.js","webpack:///./src/map/proptypes/layers.js","webpack:///./src/map/proptypes/shared.js","webpack:///./src/map/config.js","webpack:///./src/map/module/module.actions.js","webpack:///./src/map/module/module.selectors.js","webpack:///./src/map/tracks/tracks.selectors.js","webpack:///./src/map/constants.js","webpack:///./src/map/utils/heatmapTileData.js","webpack:///./src/map/utils/buildEndpoint.js","webpack:///./src/map/heatmap/heatmapTiles.actions.js","webpack:///./src/map/heatmap/heatmap.actions.js","webpack:///./src/map/glmap/viewport.actions.js","webpack:///./src/map/glmap/interaction.actions.js","webpack:///./src/map/utils/map-colors.js","webpack:///./src/map/heatmap/HeatmapSubLayer.js","webpack:///./src/map/heatmap/HeatmapLayer.js","webpack:///./src/map/tracks/TracksLayer.js","webpack:///./src/map/activity/ActivityLayers.js","webpack:///./src/map/activity/ActivityLayers.container.js","webpack:///./src/map/glmap/Map.js","webpack:///./src/map/glmap/Map.container.js","webpack:///./src/map/glmap/style.reducer.js","webpack:///./src/map/utils/getMainGeomType.js","webpack:///./src/map/glmap/style.actions.js","webpack:///./src/map/store/index.js","webpack:///./src/map/tracks/tracks.actions.js","webpack:///./src/map/utils/withReducerTypes.js","webpack:///./src/map/module/module.reducer.js","webpack:///./src/map/tracks/tracks.reducer.js","webpack:///./src/map/heatmap/heatmap.reducer.js","webpack:///./src/map/heatmap/heatmapTiles.reducer.js","webpack:///./src/map/glmap/viewport.reducer.js","webpack:///./src/map/glmap/interaction.reducer.js","webpack:///./src/map/store/reducers.js","webpack:///./src/map/map.js","webpack:///./src/map/basemaps/index.js","webpack:///./src/map/map.mdx"],"names":["module","exports","map","googleLogo","byname","Uint8","size","Uint8Array","BYTES_PER_ELEMENT","array","getter","setter","Int8","Int8Array","Uint16","Uint16Array","Int16","Int16Array","Uint32","Uint32Array","Int32","Int32Array","Float32","Float32Array","Float64","Float64Array","writeStringToArrayBuffer","str","start","end","buf","bufstart","undefined","length","i","charCodeAt","arrayBufferToString","String","fromCharCode","apply","Pack","typemap","byarray","pack","typespec","value","littleendian","ArrayBuffer","DataView","stringToArrayBuffer","res","Uint8ClampedArray","buffer","name","spec","PelagosClient","_classCallCheck","this","MAGIC_COOKIE","url","token","Promise","resolve","reject","request","XMLHttpRequest","open","setRequestHeader","concat","responseType","onload","handleData","bind","onerror","send","self","error","readyState","success","status","isFileUri","response","byteLength","dataView","headerLen","cookie","slice","getInt32","offset","headerIsLoaded","header","JSON","parse","rowLen","colsByName","colidx","cols","col","idx","type","multiplier","min","max","orientation","errorLoading","toString","allLoaded","result","rowidx","row","val","colValues","eval","trackTypes","id","PropTypes","string","isRequired","data","object","color","oneOf","layerTemporalExtents","arrayOf","number","fitBoundsOnLoad","bool","shape","hue","filterValues","endpoints","temporalExtents","temporalExtentsLess","field","values","node","VESSELS_BASE_RADIUS","MAX_SPRITES_PER_LAYER","TILES_URL_NEEDING_AUTHENTICATION","startLoader","dispatch","state","loaderId","timestamp","Date","getTime","payload","onLoadStart","completeLoader","getState","loaders","onLoadComplete","onViewportChange","interactionState","callback","viewport","zoom","center","latitude","longitude","bounds","canZoomIn","canZoomOut","mouseLatLong","setHighlightTemporalExtent","highlightTemporalExtent","getTemporalExtent","temporalExtent","getHighlightTemporalExtent","getGeojsonTracks","createSelector","tracks","filter","t","getGeojsonTracksReady","mergeStyles","style1","style2","sources","_objectSpread","layers","_toConsumableArray","filterGeojsonByTimerange","geojson","_ref","features","featuresFiltered","reduce","filteredFeatures","feature","properties","coordinateProperties","times","filtered","geometry","coordinates","filteredCoordinates","coordinate","index","timeCoordinate","push","filteredFeature","getFullTracksStyles","hasTemporalExtent","hasTracks","timerange","acc","track","source","style","_defineProperty","paint","line-width","line-color","circle-radius","circle-color","getHighlightedTrackStyles","getTracksStyles","trackStyles","highlightedTrackStyles","TRANSITION_TYPE","BRUSH_RENDERING_STYLE","NORMAL","BULLSEYE","BRUSH_ZOOM_RENDERING_STYLE","CUSTOM_LAYERS_SUBTYPES","getTemporalTileURLs","urlTemplate","params","arguments","urls","forEach","extent","urlParams","startTimeISO","toISOString","endTimeISO","tileCoordinates","x","y","z","templateSettings","interpolate","template","urlTemplateCompiled","buildEndpoint","temporalExtentsIndices","indexOf","getTilePromises","tilesetUrl","promises","urlIndex","obtainTile","getCleanVectorArrays","rawTileData","vectorArray","groupData","cleanVectorArrays","columns","currentArray","totalVectorArraysLength","sumBy","a","filteredColumns","column","console","warn","key","cumulatedOffsets","appendValues","set","getTilePlaybackData","prevPlaybackData","tilePlaybackData","zoomFactorRadius","convert","getZoomFactorRadius","zoomFactorRadiusRenderingMode","getZoomFactorRadiusRenderingMode","zoomFactorOpacity","getZoomFactorOpacity","columnsArr","Object","keys","c","storedColumns","sigma","weight","hidden","pull","uniq","numPoints","newFrames","timeIndexes","_loop","point","timeIndex","getOffsetedTimeAtPrecision","datetime","_lngLatToWorld2","_slicedToArray","lngLatToWorld","worldX","worldY","radius","sigmaToRadius","opacity","weightToOpacity","series","frame","addTracksPointsRenderingData","hasFishing","_lngLatToWorld4","getTracksPlaybackData","playbackData","vesselSatisfiesFilters","every","selectVesselsAt","tileData","tileQuery","startIndex","endIndex","currentFilters","vessels","toleranceRadiusInWorldUnits","_loop2","f","_loop3","wx","wy","filters","pass","some","vesselSatisfiesAllFilters","vessel","getTilecoverLimits","viewportZoom","Math","ceil","tilesAvailable","min_zoom","max_zoom","flushToReleaseTiles","heatmapTiles","currentToLoadTileUids","currentTilesToReleaseUids","currentToReleaseTileUids","releaseTiles","markTileAsLoaded","tileUids","flushTileState","forceLoadingAllVisibleTiles","currentVisibleTiles","tilesToLoad","tilesToReleaseUids","currentLoadedTiles","visibleTile","find","uid","loadedTile","tilesToLoadUids","tile","referenceTile","ADD_REFERENCE_TILE","visibleHeatmapLayers","heatmap","heatmapLayers","visibleHeatmapLayersIds","visible","getTiles","updateLoadedTiles","debouncedFlushState","debounce","updateHeatmapTilesFromViewport","mapViewport","width","height","currentTransition","boundsViewport","PerspectiveMercatorViewport","unproject","wn","es","w","s","e","n","boundsPolygonsCoordinates","limits","w1","e2","geom","viewportTilesCoords","tilecover","tiles","viewportTilesIndexes","indexes","visibleTiles","coords","prevZoom","queryHeatmapVessels","temporalExtentIndexes","uids","_queryHeatmap2","_queryHeatmap","layer","isEmpty","isCluster","isMouseCluster","foundVessels","highlightedVessels","layerId","layerPayload","tilesetId","subtype","HIGHLIGHT_VESSELS","clickableCluster","highlightableCluster","clearHighlightedVessels","highlightVesselFromHeatmap","heatmapTiles_actions_objectSpread","UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES","UPDATE_HEATMAP_TILE","getTemporalExtentsVisibleIndices","loadTemporalExtent","currentExtentStart","currentExtentEnd","indices","temporalExtentStart","layerIds","referenceTiles","newTemporalExtentsToLoad","loaderID","join","tilesByLayer","heatmap_actions_toConsumableArray","allPromises","heatmapLayerHeader","_heatmapLayerHeader","heatmap_actions_objectSpread","temporalExtentsIndicesLoaded","queriedTemporalExtentsIndices","visibleTemporalExtentsIndices","temporalExtentsIndicesToLoad","difference","tilePromise","Error","pelagosPromises","allLayerPromises","all","then","loadedLayerId","loadLayerTile","_ref2","parseLayerTile","loadAllTilesForLayer","layersVessels","availableTiles","bestTile","layerVesselsResult","layersVesselsResults","layerVessels","v","uniqBy","updateHeatmapLayers","newLayers","currentLoadTemporalExtent","prevLayersDict","newLayer","prevLayer","interactive","prevLayerId","l","transitionTo","increment","getFields","glFeature","fieldsDefinition","metadata","fields","k","fd","fieldKey","pow","area","toLocaleString","maximumFractionDigits","getAreaKm2","def","label","title","isLink","isMain","mainField","getFeature","mapInteraction","interactionType","glFeatures","glGetSource","legacyHeatmapFeature","currentStyle","mapStyle","toJS","event","currentLegacyHeatmapData","count","group","clusterPromises","getStaticLayerIdFromGlFeature","interaction_actions_objectSpread","cluster","clusterPromise","clusterId","cluster_id","glSource","getClusterExpansionZoom","err1","getClusterLeaves","err2","children","childrenFeatures","child","getCluster","autoClusterZoom","clusterBehavior","clusterZoom","zoomIntoVesselCenter","cursor","onClick","onHover","hsvToRgb","h_","s_","v_","h","parseFloat","floor","p","q","mod","r","g","b","round","hueToRgbDefaults","hueToRgbString","rgb","hexToRgb","hex","exec","parseInt","hueIncrementToHue","hueIncrement","wrapHue","HeatmapSubLayer","baseTexture","renderingStyleIndex","useNormalBlendMode","stage","PIXI","particles","ParticleContainer","scale","alpha","position","uvs","blendMode","BLEND_MODES","SCREEN","spritesPool","initialTextureFrame","Rectangle","mainVesselTexture","Texture","_setTextureFrame","clearSpriteProps","spritesProps","spritesPropsCount","destroy","textureFrame","clone","hueToHueIncrement","VESSELS_HUES_INCREMENTS_NUM","update","numProps","resizeSpritesPool","sprite","setTransform","numSprites","delta","toRemove","removeChildAt","toAdd","_addSprites","num","Sprite","anchor","addChild","worldToPixelsSimple","m","HeatmapLayer","React","Component","_build","_destroy","_redraw","nextProps","useRadialGradientStyle","props","setBrushZoomRenderingStyle","_this$props","rootStage","customRenderingStyle","subLayers","renderingStyle","rendering","setBrushRenderingStyle","brushRenderingStyle","toUpperCase","_setBrushRenderingStyleIndex","brushZoomRenderingStyle","_this","cappedZoomRenderingStyle","newStyleIndex","subLayer","setRenderingStyleIndex","_this2","_this$props2","defaultHue","allHuesToRender","currentlyUsedHues","allHues","_createSublayer","_destroySubLayer","_setSubLayersSpritePropsForTile","numFilters","hueToRender","render","_this$props3","viewportLeft","viewportRight","len","fi","scaledX","scaledY","mtx","pixelProjectionMatrix","_ref3","HeatmapLayer_slicedToArray","pitch","worldToPixels","pushSpriteProps","defaultOpacity","defaultSize","removeChild","TracksLayer","Graphics","nativeLines","clear","highlightTemporalExtentIndexes","overInInner","overExtent","drawFishingCircles","fishingCirclesRadius","drawOverTrack","_drawTrack","substr","lineThickness","lineOpacity","prevSeries","prevWorldX","prevWorldY","_ref$worldOffset","worldOffset","circlePoints","lineStyle","duplicateWorld","currentSeries","_worldToPixels2","TracksLayer_slicedToArray","moveTo","abs","atDatelineWorldY","isWestToEast","worldXEnd","atDatelineEndWorldX","atDatelineStartWorldX","_worldToPixels4","x1","y1","lineTo","_worldToPixels6","x2","y2","beginFill","circlesLength","drawCircle","endFill","ActivityLayers","pixiReady","touches","queryCoords","clientX","clientY","heatmapFadingIn","heatmapStage","_heatmapFadeinStep","BaseControl","setState","exportNativeViewport","_context","_updateViewportSize","_this$props$viewport","pixi","transparent","antialias","renderer","canvas","view","container","appendChild","baseTextureCanvas","blurFactor","tplCanvas","document","createElement","tplCtx","getContext","diameter","yCenter","gradient","createRadialGradient","rgbString","addColorStop","rgbOuter","fillStyle","fillRect","beginPath","arc","PI","fill","lineWidth","strokeStyle","stroke","getVesselTexture","fromCanvas","ticker","add","_onTick","viewportWidth","viewportHeight","resize","dim","_viewport$unproject2","ActivityLayers_slicedToArray","wrappedLongitude","heatmapFadeinStartTimestamp","now","timeElapsed","highlightedClickedVessel","highlightLayerData","highlightFilters","ActivityLayers_objectSpread","leftWorldScaled","rightWorldScaled","shouldUseRadialGradientStyle","toggleHeatmapDimming","_startHeatmapFadein","gl","getError","err","log","_this$_getHighlightDa","_getHighlightData","react_default","ref","onMouseMove","onTouchStart","react","heatmap_HeatmapLayer","tracks_TracksLayer","propTypes","func","contextTypes","getHeatmapLayersAsArray","ActivityLayers_container_objectSpread","getTracksWithData","getTemporalExtentIndexes","startTimestamp","endTimestamp","getHighlightTemporalExtentIndexes","connect","ownProps","nativeViewport","topLeftPx","bottomRightPx","topLeftWorld","pixelsToWorld","pixelUnprojectionMatrix","bottomRightWorld","northWest","southEast","north","south","west","east","PopupWrapper","closeButton","onClose","esm","offsetTop","tipSize","closeOnClick","defaultProps","Map","Map_classCallCheck","Map_getPrototypeOf","call","Map_defineProperty","Map_assertThisInitialized","entries","_entries$0$contentRec","contentRect","setViewport","Map_objectSpread","lngLat","onMapInteraction","glMap","getMap","getSource","isDragging","resourceType","match","headers","Authorization","mouseOver","_mapContainerRef","_containerResizeObserver","ResizeObserver","_containerResize","disconnect","maxZoom","minZoom","transitionEnd","onClosePopup","clickPopup","hoverPopup","hasHeatmapLayers","markers","interactiveLayerIds","className","styles","observe","onMouseLeave","onMouseEnter","assign","getRef","transformRequest","onTransitionEnd","getCursor","clickRadius","ActivityLayers_container","Map_PopupWrapper","content","marker","getInteractiveLayerIds","staticLayers","glLayer","glLayerId","getMapStyle","mapStyles","trackLayersIndex","lastIndexOf","finalMapStyles","mergeIn","mapStylesLayers","get","trackLayer","insert","fromJS","interaction","internalCursor","moduleCursor","lat","long","attributions","GL_STYLE","sourceKey","attribution","setLayerStyleDefaults","layout","temporalField","visibility","initialState","cartoLayersInstanciated","basemapLayers","TYPES","geoJSON","INIT_MAP_STYLE","SET_MAP_STYLE","MARK_CARTO_LAYERS_AS_INSTANCIATED","SET_STATIC_LAYERS","SET_BASEMAP_LAYERS","setDefaultVectorTiles","currentSource","refLayerUrl","refLayerUrls","style_actions_objectSpread","style_actions_toConsumableArray","setMapStyle","setStyleTemporalExtent","applyToThrottled","glLayers","currentFilter","getIn","isLegacy","setIn","applyTemporalExtentThrottled","throttle","applyTemporalExtent","updateGLLayer","refLayer","currentStyleLayers","newStyle","glLayerIndex","findIndex","toggleLayerVisibility","isBasemap","refLayerOpacity","labelsVisibility","showLabels","colorPaintProperty","currentGlLayer","glType","defaultStyles","styleType","refLayerStyle","hasFeatures","applyStyleToAllFeatures","allPaintProperties","glPaintProperty","glPaintFinalValue","selectedValue","fallbackValue","paintOrLayout","includes","originalLayerStyle","layerColorRgbString","layerColorRgb","replace","applyLayerExpressions","addCustomGLLayer","tileSize","allGeoJSONTypes","numByGLType","geoJSONType","glTypeMax","getMainGeomType","layerIndex","reverse","splice","instanciateCartoLayers","sourceId","cartoLayersPromises","sourceCartoSQL","mapConfig","options","sql","mapConfigURL","encodeURIComponent","stringify","cartoAnonymousMapUrl","fetch","json","layergroupid","catch","instanciatedCartoLayers","cartoLayer","tilesURL","newSourceId","deleteIn","commitStyleUpdates","bl","currentGLSources","workspaceGLLayers","workspaceGLLayer","finalSource","existingLayerIds","layerToAdd","layerToAddId","sourceLayer","existingLayers","newLayerGroup","newLayerIndex","findLastIndex","updateWorkspaceGLLayers","customLayers","isCustom","glSources","cartoLayersToInstanciate","newSource","cartoLayerInstanciated","composeEnhancers","compose","process","MAP_REDUX_REMOTE_DEBUG","REACT_APP_MAP_REDUX_REMOTE_DEBUG","store","createStore","applyMiddleware","thunk","targetMapVessel","geoBounds","vp","fitBounds","minLng","minLat","maxLng","maxLat","padding","timelineBounds","ADD_TRACK","UPDATE_TRACK","getTrackDataParsed","time","Infinity","getTrackBounds","tbbox","getOldTrackBoundsFormat","addOffset","geo","lng","updateTracks","newTracks","prevTracks","newTrack","trackId","prevTrack","trackHasData","trackHasUrl","cleanData","rawTrackData","statusText","_getTrackDataParsed","finally","withReducerPropTypes","propTypesSchema","reducer","onAttributionsChange","withReducerTypes","instanceOf","action","module_reducer_objectSpread","module_reducer_toConsumableArray","loaderIndex","exact","tracks_reducer_objectSpread","tracks_reducer_toConsumableArray","trackData","removedTrackId","DEFAULT_TRANSITION","transitionDuration","transitionInterpolator","FlyToInterpolator","transitionEasing","easeCubic","bearing","mapReducer","combineReducers","ModuleReducer","TracksReducer","newVisibleTemporalExtentsIndices","indicesRemoved","heatmap_reducer_objectSpread","heatmap_reducer_defineProperty","heatmap_reducer_toConsumableArray","newTile","layerTiles","tileIndex","tileUid","releasedTileIndex","releasedRefTileIndex","newHeatmapLayers","heatmapTiles_reducer_objectSpread","tileUidsMarkedAsLoaded","newMapStyle","glyphsPath","style_reducer_objectSpread","style_reducer_toConsumableArray","viewport_reducer_objectSpread","currentZoom","interaction_reducer_objectSpread","mapReducers","replaceReducer","throttleApplyTemporalExtent","setTemporalExtent","updateViewportFromIncomingProps","incomingViewport","viewportUpdate","MapModule","initialized","errorInfo","prevProps","indicesToAddByLayer","heatmapLayer","oldVisibleTemporalExtentsIndices","indicesAdded","layerIdsWithIndicesToAdd","currentViewport","componentStack","react_redux_es","Map_container","MDXContent","map_map_classCallCheck","map_map_possibleConstructorReturn","map_map_getPrototypeOf","components","_objectWithoutProperties","dist","parentName","href","index_m","__codesandbox","__position","__code","__scope","map_map"],"mappings":"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","file":"static/js/src-map-map.621857af.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"map\":\"map_map__1CWd_\",\"googleLogo\":\"map_googleLogo__2KshJ\"};","/* eslint-disable */\nvar byname = {\n  Uint8: {\n    size: Uint8Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint8',\n    setter: 'setUint8',\n  },\n  Int8: {\n    size: Int8Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint8',\n    setter: 'setUint8',\n  },\n  Uint16: {\n    size: Uint16Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint16',\n    setter: 'setUint16',\n  },\n  Int16: {\n    size: Int16Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getInt16',\n    setter: 'setInt16',\n  },\n  Uint32: {\n    size: Uint32Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint32',\n    setter: 'setUint32',\n  },\n  Int32: {\n    size: Int32Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getInt32',\n    setter: 'setInt32',\n  },\n  Float32: {\n    size: Float32Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getFloat32',\n    setter: 'setFloat32',\n  },\n  Float64: {\n    size: Float64Array.BYTES_PER_ELEMENT,\n    array: 'Float64Array',\n    getter: 'getFloat64',\n    setter: 'setFloat64',\n  },\n}\n\nvar writeStringToArrayBuffer = function(str, start, end, buf, bufstart) {\n  if (end == undefined) {\n    end = str.length\n  }\n  if (start == undefined) {\n    start = 0\n  }\n  if (bufstart == undefined) {\n    bufstart = start\n  }\n  for (var i = start; i < end; i++) {\n    buf[i - start + bufstart] = str.charCodeAt(i) & 0xff\n  }\n}\n\nvar stringToArrayBuffer = function(str, start, end) {\n  var self = this\n\n  if (end == undefined) {\n    end = str.length\n  }\n  if (start == undefined) {\n    start = 0\n  }\n  var res = new Uint8ClampedArray(end - start)\n  writeStringToArrayBuffer(str, start, end, res, 0)\n  return res.buffer\n}\n\nvar arrayBufferToString = function(buf) {\n  return String.fromCharCode.apply(null, new Uint8Array(buf))\n}\n\nvar pack = function(typespec, value, littleendian) {\n  var array = new ArrayBuffer(typespec.size)\n  new DataView(array)[typespec.setter](0, value, littleendian)\n  return arrayBufferToString(array)\n}\n\nvar Pack = {\n  typemap: {\n    byname: byname,\n    byarray: {},\n  },\n  pack: pack,\n  arrayBufferToString: arrayBufferToString,\n  stringToArrayBuffer: stringToArrayBuffer,\n  writeStringToArrayBuffer: writeStringToArrayBuffer,\n}\nfor (var name in Pack.typemap.byname) {\n  var spec = Pack.typemap.byname[name]\n  spec.name = name\n  Pack.typemap.byarray[spec.array] = spec\n}\n\nexport default Pack\n","/* eslint-disable */\n\nimport Pack from './Pack'\n\nclass PelagosClient {\n  constructor() {\n    this.MAGIC_COOKIE = 'tmtx'\n  }\n\n  obtainTile(url, token) {\n    return new Promise(\n      function(resolve, reject) {\n        this.request = null\n        if (typeof XMLHttpRequest != 'undefined') {\n          this.request = new XMLHttpRequest()\n        } else {\n          throw 'XMLHttpRequest is disabled'\n        }\n        this.resolve = resolve\n        this.reject = reject\n        this.request.open('GET', url, true)\n        if (token) {\n          this.request.setRequestHeader('Authorization', `Bearer ${token}`)\n        }\n        this.request.responseType = 'arraybuffer'\n        this.request.onload = this.handleData.bind(this)\n        this.request.onerror = this.handleData.bind(this)\n        this.request.send(null)\n      }.bind(this)\n    )\n  }\n\n  handleData() {\n    var self = this\n    if (!this.request) {\n      return\n    }\n    if (this.error) {\n      return true\n    }\n\n    if (this.request.readyState == 4) {\n      /* HTTP reports success with a 200 status. The file protocol\n       reports success with zero. HTTP returns zero as a status\n       code for forbidden cross domain requests.\n       https://developer.mozilla.org/En/Using_XMLHttpRequest */\n      var success = this.request.status == 200 || (this.isFileUri && this.request.status == 0)\n      if (!success) {\n        this.resolve(null)\n        return\n      }\n    }\n\n    if (!this.request.response) {\n      return\n    }\n    var length = this.request.response.byteLength\n    var response = this.request.response\n    var dataView = new DataView(response)\n\n    if (length < 4 + 4) {\n      return\n    }\n    if (self.headerLen == null) {\n      var cookie = Pack.arrayBufferToString(response.slice(0, 4))\n      if (cookie != this.MAGIC_COOKIE) {\n        this.reject(\n          'Could not load ' +\n            this.url +\n            ' due to incorrect file format. Cookie: [' +\n            this.cookie +\n            ']'\n        )\n        return\n      }\n\n      self.headerLen = dataView.getInt32(4, true)\n\n      self.offset = 4 + 4\n    }\n    if (length < self.offset + self.headerLen) {\n      return\n    }\n    if (!self.headerIsLoaded) {\n      self.header = JSON.parse(\n        Pack.arrayBufferToString(response.slice(self.offset, self.offset + self.headerLen))\n      )\n      self.rowLen = 0\n      self.header.colsByName = {}\n      for (var colidx = 0; colidx < self.header.cols.length; colidx++) {\n        var col = self.header.cols[colidx]\n        col.idx = colidx\n        self.header.colsByName[col.name] = col\n        col.typespec = Pack.typemap.byname[col.type]\n\n        if (col.multiplier != undefined && col.min != undefined) {\n          col.min = col.min * col.multiplier\n        }\n        if (col.offset != undefined && col.min != undefined) {\n          col.min = col.min + col.offset\n        }\n        if (col.multiplier != undefined && col.max != undefined) {\n          col.max = col.max * col.multiplier\n        }\n        if (col.offset != undefined && col.max != undefined) {\n          col.max = col.max + col.offset\n        }\n\n        self.rowLen += col.typespec.size\n      }\n      self.offset += self.headerLen\n\n      // Add the padding to nearest 4-byte-boundary\n      self.offset += (4 - (self.headerLen % 4)) % 4\n\n      self.headerIsLoaded = true\n      if (self.header.orientation != 'rowwise' && self.header.orientation != 'columnwise') {\n        self.errorLoading({\n          orientation: self.header.orientation,\n          toString: function() {\n            return (\n              'Could not load ' +\n              this.url +\n              ' due to unsupported file orientation. Orientation: ' +\n              this.orientation +\n              '. Supported orientations: rowwise, columnwise.'\n            )\n          },\n        })\n        return true\n      }\n\n      // Empty tile, stop parsing.\n      if (!self.rowLen) {\n        self.allLoaded()\n        return true\n      }\n    }\n    if (self.header.orientation == 'rowwise') {\n      var result = {}\n      for (; self.offset + self.rowLen <= length; self.rowidx++) {\n        var row = {}\n        for (var colidx = 0; colidx < self.header.cols.length; colidx++) {\n          var col = self.header.cols[colidx]\n          var val = dataView[col.typespec.getter](self.offset, true)\n          row[col.name] = val\n          self.offset += col.typespec.size\n        }\n        // self.rowLoaded(row);\n\n        result[col.name] = row\n      }\n      if (self.rowidx == self.header.length) {\n        // self.allLoaded();\n        this.resolve(result)\n      } else {\n        // self.batchLoaded();\n      }\n    } else if (self.header.orientation == 'columnwise') {\n      var colValues = null\n      var result = {}\n      if (length >= self.offset + self.header.length * self.rowLen) {\n        for (var colidx = 0; colidx < self.header.cols.length; colidx++) {\n          var col = self.header.cols[colidx]\n\n          colValues = new (eval(col.typespec.array))(\n            response.slice(self.offset, self.offset + col.typespec.size * self.header.length)\n          )\n          self.offset += self.header.length * col.typespec.size\n\n          result[col.name] = colValues\n        }\n\n        // self.allLoaded();\n        this.resolve(result)\n        return true\n      }\n    }\n  }\n}\n\nexport default PelagosClient\n","import PropTypes from 'prop-types'\n\nexport const trackTypes = {\n  id: PropTypes.string.isRequired,\n  url: PropTypes.string,\n  data: PropTypes.object,\n  color: PropTypes.string,\n  type: PropTypes.oneOf(['geojson', 'pelagos', undefined]),\n  layerTemporalExtents: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.number)),\n  fitBoundsOnLoad: PropTypes.bool,\n}\n","import PropTypes from 'prop-types'\n\nexport const heatmapLayerTypes = {\n  id: PropTypes.string.isRequired,\n  tilesetId: PropTypes.string,\n  subtype: PropTypes.string,\n  visible: PropTypes.bool,\n  hue: PropTypes.number,\n  opacity: PropTypes.number,\n  filters: PropTypes.arrayOf(\n    PropTypes.shape({\n      // hue overrides layer hue if set\n      hue: PropTypes.number,\n      // filterValues is a dictionary in which each key is a filterable field,\n      // and values is an array of all possible values (OR filter)\n      // ie: filterValues: { category: [5, 6] }\n      filterValues: PropTypes.object,\n    })\n  ),\n  header: PropTypes.shape({\n    endpoints: PropTypes.object,\n    colsByName: PropTypes.object,\n    temporalExtents: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.number)),\n    temporalExtentsLess: PropTypes.bool,\n  }).isRequired,\n  interactive: PropTypes.bool,\n}\n\nexport const basemapLayerTypes = {\n  id: PropTypes.string,\n  visible: PropTypes.bool,\n}\n\nexport const staticLayerTypes = {\n  id: PropTypes.string.isRequired,\n  // TODO MAP MODULE Is that needed and if so why\n  visible: PropTypes.bool,\n  selected: PropTypes.bool,\n  selectedFeatures: PropTypes.shape({\n    field: PropTypes.string,\n    values: PropTypes.arrayOf(PropTypes.string),\n  }),\n  highlighted: PropTypes.bool,\n  higlightedFeatures: PropTypes.shape({\n    field: PropTypes.string,\n    values: PropTypes.arrayOf(PropTypes.string),\n  }),\n  opacity: PropTypes.number,\n  color: PropTypes.string,\n  showLabels: PropTypes.bool,\n  interactive: PropTypes.bool,\n  filters: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.string)),\n  isCustom: PropTypes.bool,\n  subtype: PropTypes.oneOf([undefined, 'geojson', 'raster']),\n  url: PropTypes.string,\n  data: PropTypes.object,\n  gl: PropTypes.object,\n}\n","import PropTypes from 'prop-types'\n\nexport const popupTypes = {\n  content: PropTypes.node,\n  latitude: PropTypes.number.isRequired,\n  longitude: PropTypes.number.isRequired,\n}\n\nexport const viewportTypes = {\n  zoom: PropTypes.number,\n  center: PropTypes.arrayOf(PropTypes.number),\n}\n","// Application settings\nexport const TIMELINE_STEP = 24 * 60 * 60 * 1000 // 1 day\nexport const MIN_FRAME_LENGTH_MS = TIMELINE_STEP // 1 day\n\n// vessels rendering\n// from this zoom level and above, render using circle style instead of heatmap\nexport const VESSELS_RADIAL_GRADIENT_STYLE_ZOOM_THRESHOLD = 6\n// the base radius, it can only be scaled down by the radius factor calculated on the dataset\nexport const VESSELS_BASE_RADIUS = 8\n// in heatmap style, defines how 'blurry' a point will look. Higher = less blur\nexport const VESSELS_HEATMAP_BLUR_FACTOR = 0.15\n\nexport const ACTIVITY_HIGHLIGHT_HUE = 312\n\nexport const VESSELS_HEATMAP_DIMMING_ALPHA = 0.5\n\nexport const TRACKS_DOTS_STYLE_ZOOM_THRESHOLD = 2\n\nexport const MAX_SPRITES_PER_LAYER = 200000\n\n// interaction\n// radius of vessels lookup in pixels,\n// ie how large the clicked region should be for including vessels\nexport const VESSEL_CLICK_TOLERANCE_PX = 10\n\nexport const CLUSTER_CLICK_ZOOM_INCREMENT = 1\n\nexport const MIN_ZOOM_LEVEL = 1\n// user can zoom up to this z level, but it doesn't guarantee availability of tiles\nexport const MAX_ZOOM_LEVEL = 14\n\n// data\n// Limit tile loading for activity layers up to this z level.\n// Beyond, layer is still displayed but with coarse data from the lower zoom level\nexport const ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING = 10\n\n// Sets what should be the discrete zoom level to load tiles, from a non-discrete\n// viewport zoom values. For instance, a values of 0.5 will load z 3 with a viewport\n// z of 2 (ceiling of 2 + 0.5)\n// this has a direct impact on the number of points displayed on the map, thus on the\n// performance of the app.\nexport const TILES_LOAD_ZOOM_OFFSET = 0.5\n\nexport const STATIC_LAYERS_CARTO_ENDPOINT =\n  'https://carto.globalfishingwatch.org/user/admin/api/v1/map?config=$MAPCONFIG'\nexport const STATIC_LAYERS_CARTO_TILES_ENDPOINT =\n  'https://carto.globalfishingwatch.org/user/admin/api/v1/map/$LAYERGROUPID/{z}/{x}/{y}.mvt'\n\nexport const TRACKS_LAYER_IN_FRONT_OF_GROUP = 'temporal'\n\nexport const TILES_URL_NEEDING_AUTHENTICATION = 'dot-world-fishing'\n","export const INIT_MODULE = 'INIT_MODULE'\nexport const SET_TEMPORAL_EXTENT = 'SET_TEMPORAL_EXTENT'\nexport const SET_HIGHLIGHT_TEMPORAL_EXTENT = 'SET_HIGHLIGHT_TEMPORAL_EXTENT'\nexport const START_LOADER = 'START_LOADER'\nexport const COMPLETE_LOADER = 'COMPLETE_LOADER'\nexport const SET_MODULE_CURSOR = 'SET_MODULE_CURSOR'\n\nexport const initModule = (props) => (dispatch) => {\n  dispatch({\n    type: INIT_MODULE,\n    payload: props,\n  })\n}\n\nexport const startLoader = (dispatch, state, loaderId) => {\n  const timestamp = new Date().getTime()\n  const generatedLoaderId = loaderId !== undefined ? `${loaderId}_${timestamp}` : timestamp\n  dispatch({\n    type: START_LOADER,\n    payload: generatedLoaderId,\n  })\n  if (state.map.module.onLoadStart !== undefined) {\n    state.map.module.onLoadStart()\n  }\n  return loaderId\n}\n\nexport const completeLoader = (loaderId) => (dispatch, getState) => {\n  dispatch({\n    type: COMPLETE_LOADER,\n    payload: loaderId,\n  })\n  const state = getState()\n  const loaders = state.map.module.loaders\n  if (!loaders.length && state.map.module.onLoadComplete !== undefined) {\n    state.map.module.onLoadComplete()\n  }\n}\n\nexport const onViewportChange = (interactionState) => (dispatch, getState) => {\n  const state = getState()\n  const callback = state.map.module.onViewportChange\n\n  if (callback === undefined) {\n    return\n  }\n  const viewport = state.map.viewport\n\n  callback({\n    interactionState,\n    zoom: viewport.viewport.zoom,\n    center: [viewport.viewport.latitude, viewport.viewport.longitude],\n    bounds: viewport.bounds,\n    canZoomIn: viewport.canZoomIn,\n    canZoomOut: viewport.canZoomOut,\n    mouseLatLong: viewport.mouseLatLong,\n  })\n}\n\nexport const setTemporalExtent = (temporalExtent) => ({\n  type: SET_TEMPORAL_EXTENT,\n  payload: temporalExtent,\n})\n\nexport const setHighlightTemporalExtent = (highlightTemporalExtent) => ({\n  type: SET_HIGHLIGHT_TEMPORAL_EXTENT,\n  payload: highlightTemporalExtent,\n})\n\nexport const closePopup = () => (dispatch, getState) => {\n  const state = getState()\n  if (state.map.module.onClosePopup !== undefined) {\n    state.map.module.onClosePopup()\n  }\n}\n\nexport const setCursor = (cursor) => ({\n  type: SET_MODULE_CURSOR,\n  payload: cursor,\n})\n","export const getTemporalExtent = (state) => state.map.module.temporalExtent\n\nexport const getHighlightTemporalExtent = (state) => state.map.module.highlightTemporalExtent\n","import { createSelector } from 'reselect'\nimport { getTemporalExtent, getHighlightTemporalExtent } from '../module/module.selectors'\n\nexport const getTracksData = (state) => state.map.tracks.data\nexport const getGeojsonTracks = createSelector(\n  getTracksData,\n  (tracks) => tracks.filter((t) => t.type === 'geojson')\n)\nexport const getGeojsonTracksReady = createSelector(\n  getGeojsonTracks,\n  (tracks) => tracks.filter((t) => t.data !== undefined)\n)\n\nconst mergeStyles = (style1, style2) => ({\n  sources: { ...style1.sources, ...style2.sources },\n  layers: [...style1.layers, ...style2.layers],\n})\n\nconst filterGeojsonByTimerange = (geojson, { start, end }) => {\n  if (!geojson || !geojson.features) return null\n  const featuresFiltered = geojson.features.reduce((filteredFeatures, feature) => {\n    const hasTimes =\n      feature.properties &&\n      feature.properties.coordinateProperties &&\n      feature.properties.coordinateProperties.times &&\n      feature.properties.coordinateProperties.times.length > 0\n    if (hasTimes) {\n      const filtered = feature.geometry.coordinates.reduce(\n        (filteredCoordinates, coordinate, index) => {\n          const timeCoordinate = feature.properties.coordinateProperties.times[index]\n          const isInTimeline = timeCoordinate >= start && timeCoordinate <= end\n          if (isInTimeline) {\n            filteredCoordinates.coordinates.push(coordinate)\n            filteredCoordinates.times.push(timeCoordinate)\n          }\n          return filteredCoordinates\n        },\n        { coordinates: [], times: [] }\n      )\n      if (!filtered.coordinates.length) return filteredFeatures\n\n      const filteredFeature = {\n        ...feature,\n        geometry: {\n          ...feature.geometry,\n          coordinates: filtered.coordinates,\n        },\n        properties: {\n          ...feature.properties,\n          coordinateProperties: {\n            times: filtered.times,\n          },\n        },\n      }\n      filteredFeatures.push(filteredFeature)\n    }\n    return filteredFeatures\n  }, [])\n  const geojsonFiltered = {\n    ...geojson,\n    features: featuresFiltered,\n  }\n  return geojsonFiltered\n}\n\nconst getFullTracksStyles = createSelector(\n  [getTemporalExtent, getGeojsonTracksReady],\n  (temporalExtent, tracks) => {\n    const hasTemporalExtent = temporalExtent && temporalExtent.length > 0\n    const hasTracks = tracks && tracks.length > 0\n    if (!hasTemporalExtent || !hasTracks) return null\n\n    const timerange = {\n      start: temporalExtent[0].getTime(),\n      end: temporalExtent[1].getTime(),\n    }\n    const styles = tracks.reduce(\n      (acc, track) => {\n        if (!track.data) return acc\n\n        const source = `${track.id}Track`\n        const style = {\n          sources: {\n            [source]: {\n              type: 'geojson',\n              data: filterGeojsonByTimerange(track.data, timerange),\n            },\n          },\n          layers: [\n            {\n              id: `${track.id}Lines`,\n              source,\n              type: 'line',\n              paint: {\n                'line-width': 1,\n                'line-color': track.color,\n              },\n            },\n            {\n              id: `${track.id}Points`,\n              source,\n              type: 'circle',\n              filter: ['match', ['geometry-type'], ['', 'Point'], true, false],\n              paint: {\n                'circle-radius': 4,\n                'circle-color': track.color,\n              },\n            },\n          ],\n        }\n        return mergeStyles(acc, style)\n      },\n      { sources: {}, layers: [] }\n    )\n    return styles\n  }\n)\n\nconst getHighlightedTrackStyles = createSelector(\n  [getHighlightTemporalExtent, getGeojsonTracksReady],\n  (highlightTemporalExtent, tracks) => {\n    const hasTemporalExtent = highlightTemporalExtent && highlightTemporalExtent.length > 0\n    const hasTracks = tracks && tracks.length > 0\n    if (!hasTemporalExtent || !hasTracks) return null\n\n    const timerange = {\n      start: highlightTemporalExtent[0].getTime(),\n      end: highlightTemporalExtent[1].getTime(),\n    }\n    const styles = tracks.reduce(\n      (acc, track) => {\n        if (!track.data) return acc\n\n        const source = `${track.id}HighlightedTrack`\n        const style = {\n          sources: {\n            [source]: {\n              type: 'geojson',\n              data: filterGeojsonByTimerange(track.data, timerange),\n            },\n          },\n          layers: [\n            {\n              id: `${track.id}HighlightedLines`,\n              source,\n              type: 'line',\n              paint: {\n                'line-width': 1,\n                'line-color': '#fff',\n              },\n            },\n          ],\n        }\n        return mergeStyles(acc, style)\n      },\n      { sources: {}, layers: [] }\n    )\n    return styles\n  }\n)\n\nexport const getTracksStyles = createSelector(\n  [getFullTracksStyles, getHighlightedTrackStyles],\n  (trackStyles, highlightedTrackStyles) => {\n    if (!highlightedTrackStyles) return trackStyles\n    return mergeStyles(trackStyles, highlightedTrackStyles)\n  }\n)\n","export const GL_TRANSPARENT = 'rgba(0,0,0,0)'\n\nexport const TRANSITION_TYPE = {\n  ZOOM: 'ZOOM',\n}\n\nexport const ENCOUNTERS = 'Encounters'\n\nexport const BRUSH_RENDERING_STYLE = {\n  NORMAL: 0,\n  BULLSEYE: 2,\n}\n\nexport const BRUSH_ZOOM_RENDERING_STYLE = {\n  RADIAL_GRADIENT: 0,\n  CIRCLE: 1,\n}\n\nexport const POLYGON_LAYERS_AREA = 'POLYGON_LAYERS_AREA'\n\nexport const CUSTOM_LAYERS_SUBTYPES = {\n  geojson: 'geojson',\n  raster: 'raster',\n}\n","import pull from 'lodash/pull'\nimport uniq from 'lodash/uniq'\nimport sumBy from 'lodash/sumBy'\nimport { lngLatToWorld } from 'viewport-mercator-project'\nimport convert from '@globalfishingwatch/map-convert'\nimport buildEndpoint from './buildEndpoint'\nimport PelagosClient from '../lib/pelagosClient'\n\n/**\n * Generates the URLs to load vessel track data for a tile\n *\n * @param {string} tilesetUrl       the tileset base URL\n * @param {array} temporalExtents   all tileset temporal extents\n * @param {object} params           - tileCoordinates: this tiles tile coordinates (zoom, x, y). Will default to 0,0,0\n *                                  - temporalExtentsIndices: restrict to these temporalExtents indices\n * @returns {Array}                 an array of URLs for this tile\n */\nconst getTemporalTileURLs = (urlTemplate, temporalExtents, params = {}) => {\n  const urls = []\n\n  ;(temporalExtents || [null]).forEach((extent, index) => {\n    const urlParams = {}\n    if (extent !== null && params.temporalExtentsLess !== true) {\n      urlParams.startTimeISO = new Date(extent[0]).toISOString()\n      urlParams.endTimeISO = new Date(extent[1]).toISOString()\n    }\n    if (params.tileCoordinates) {\n      urlParams.x = params.tileCoordinates.x\n      urlParams.y = params.tileCoordinates.y\n      urlParams.z = params.tileCoordinates.zoom\n    }\n\n    const url = buildEndpoint(urlTemplate, urlParams)\n\n    if (\n      params.temporalExtentsLess === true ||\n      !params.temporalExtentsIndices ||\n      params.temporalExtentsIndices.indexOf(index) > -1\n    ) {\n      urls.push(url)\n    }\n  })\n  return urls\n}\n\n/**\n * See getTemporalTileURLs.\n */\nexport const getTilePromises = (tilesetUrl, token, temporalExtents, params = {}) => {\n  const promises = []\n  const urls = getTemporalTileURLs(tilesetUrl, temporalExtents, params)\n  for (let urlIndex = 0, length = urls.length; urlIndex < length; urlIndex++) {\n    promises.push(new PelagosClient().obtainTile(urls[urlIndex], token))\n  }\n\n  return promises\n}\n\nexport const getCleanVectorArrays = (rawTileData) =>\n  rawTileData.filter((vectorArray) => vectorArray !== null)\n\n/**\n * As data will come in multiple arrays (1 per API query/year basically), they need to be merged here\n *\n * @param cleanVectorArrays an array of objects containing a Float32Array for each vessel param (lat, lon, weight...)\n * @param columns the keys to pick on the vectorArrays (lat, lon, weight, etc)\n * @returns an object containing a Float32Array for each API_RETURNED_KEY (lat, lon, weight, etc)\n */\nexport const groupData = (cleanVectorArrays, columns) => {\n  const data = {}\n\n  const totalVectorArraysLength = sumBy(cleanVectorArrays, (a) => a.longitude.length)\n\n  const filteredColumns = columns.filter((column) => {\n    if (cleanVectorArrays[0] && cleanVectorArrays[0][column] === undefined) {\n      console.warn(`column ${column} is present in layerHeader.colsByName but not in tile data`)\n      return false\n    }\n    return true\n  })\n\n  filteredColumns.forEach((key) => {\n    data[key] = new Float32Array(totalVectorArraysLength)\n  })\n\n  let currentArray\n  let cumulatedOffsets = 0\n\n  const appendValues = (key) => {\n    data[key].set(currentArray[key], cumulatedOffsets)\n  }\n\n  for (let index = 0, length = cleanVectorArrays.length; index < length; index++) {\n    currentArray = cleanVectorArrays[index]\n    filteredColumns.forEach(appendValues)\n    cumulatedOffsets += currentArray.longitude.length\n  }\n  return data\n}\n\n/**\n * Converts Vector Array data to Playback format and stores it locally.\n * The data structure is an array indexed by a time unit, ie a set of points every day\n * This preprocessing step allows playback to play smoothly as the necessary conversions and data structure set up\n * is done once (after tile has been loaded)\n *\n * @param data the source data before indexing by day, an object containing\n *  - a vector (Float32Array) for each header's column in the case of Pelagos tiles\n *  - an array of points int the case of PBF tiles\n * @param colsByName the columns present on the dataset, determined by tileset headers\n * @param tileCoordinates x, y, z\n * @param prevPlaybackData an optional previously loaded tilePlaybackData array (when adding time range)\n */\nexport const getTilePlaybackData = (data, colsByName, tileCoordinates, prevPlaybackData) => {\n  const tilePlaybackData = prevPlaybackData === undefined ? [] : prevPlaybackData\n\n  const zoom = tileCoordinates.zoom\n  const zoomFactorRadius = convert.getZoomFactorRadius(zoom)\n  const zoomFactorRadiusRenderingMode = convert.getZoomFactorRadiusRenderingMode(zoom)\n  const zoomFactorOpacity = convert.getZoomFactorOpacity(zoom)\n\n  // store all available columns as object keys\n  const columns = {}\n  const columnsArr = Object.keys(colsByName)\n  columnsArr.forEach((c) => {\n    columns[c] = true\n  })\n\n  // columns specified by layer header columns\n  let storedColumns = [].concat(columnsArr)\n  if (columns.sigma === true) storedColumns.push('radius')\n  if (columns.weight === true) storedColumns.push('opacity')\n  if (columns.longitude === true) {\n    storedColumns.push('worldX')\n    storedColumns.push('worldY')\n  }\n  if (columns.id === true) {\n    storedColumns.push('series')\n  }\n\n  // omit values that will be transformed before being stored to playback data (ie lat -> worldY)\n  // only if hidden: true flag is set on header\n  ;['latitude', 'longitude', 'datetime'].forEach((col) => {\n    if (colsByName[col] === undefined || colsByName[col].hidden === true) {\n      pull(storedColumns, col)\n    }\n  })\n  // always pull sigma and weight\n  pull(storedColumns, 'sigma', 'weight')\n  storedColumns = uniq(storedColumns)\n\n  const numPoints = data.latitude.length\n\n  const newFrames = {}\n  const timeIndexes = []\n  for (let index = 0, length = numPoints; index < length; index++) {\n    let point = {}\n    columnsArr.forEach((c) => {\n      point[c] = data[c][index]\n    })\n\n    const timeIndex = columns.timeIndex\n      ? point.timeIndex\n      : convert.getOffsetedTimeAtPrecision(point.datetime)\n\n    // FIXME: this should not be done when headers declare worldX/Y -  if (!columns.worldX) {\n    const [worldX, worldY] = lngLatToWorld([point.longitude, point.latitude], 1)\n    point.worldX = worldX\n    point.worldY = worldY\n\n    if (columns.sigma) {\n      point.radius = convert.sigmaToRadius(\n        point.sigma,\n        zoomFactorRadiusRenderingMode,\n        zoomFactorRadius\n      )\n    }\n    if (columns.weight) {\n      point.opacity = convert.weightToOpacity(point.weight, zoomFactorOpacity)\n    }\n    if (columns.id) {\n      point.series = point.id\n    }\n\n    if (!newFrames[timeIndex]) {\n      timeIndexes.push(timeIndex)\n      const frame = {}\n      storedColumns.forEach((column) => {\n        frame[column] = [point[column]]\n      })\n      newFrames[timeIndex] = frame\n      continue\n    }\n    const frame = newFrames[timeIndex]\n    storedColumns.forEach((column) => {\n      frame[column].push(point[column])\n    })\n  }\n\n  // finally, copy new frames to the overall tilePlaybackData object\n  // frames previously existing here will be overwritten\n  timeIndexes.forEach((timeIndex) => {\n    tilePlaybackData[timeIndex] = newFrames[timeIndex]\n  })\n  return tilePlaybackData\n}\n\nexport const addTracksPointsRenderingData = (data) => {\n  data.hasFishing = []\n  data.worldX = []\n  data.worldY = []\n\n  for (let index = 0, length = data.weight.length; index < length; index++) {\n    const [worldX, worldY] = lngLatToWorld([data.longitude[index], data.latitude[index]], 1)\n    data.worldX[index] = worldX\n    data.worldY[index] = worldY\n    data.hasFishing[index] = data.weight[index] > 0\n  }\n  return data\n}\n\n/**\n * A simplified version of getTilePlaybackData for tracks\n * Converts Vector Array data to Playback format (organized by days) and stores it locally\n * @param vectorArray the source data before indexing by day\n */\nexport const getTracksPlaybackData = (vectorArray) => {\n  const playbackData = []\n\n  for (let index = 0, length = vectorArray.series.length; index < length; index++) {\n    const datetime = vectorArray.datetime[index]\n    const timeIndex = convert.getOffsetedTimeAtPrecision(datetime)\n\n    if (!playbackData[timeIndex]) {\n      const frame = {\n        worldX: [vectorArray.worldX[index]],\n        worldY: [vectorArray.worldY[index]],\n        series: [vectorArray.series[index]],\n        hasFishing: [vectorArray.hasFishing[index]],\n      }\n      playbackData[timeIndex] = frame\n      continue\n    }\n    const frame = playbackData[timeIndex]\n    frame.worldX.push(vectorArray.worldX[index])\n    frame.worldY.push(vectorArray.worldY[index])\n    frame.series.push(vectorArray.series[index])\n    frame.hasFishing.push(vectorArray.hasFishing[index])\n  }\n  return playbackData\n}\n\nexport const vesselSatisfiesFilters = (frame, index, filterValues) => {\n  const satisfiesFilters = Object.keys(filterValues).every((field) => {\n    if (frame[field] === undefined) {\n      // this field is not available on this layer. This can happen in an edge case described\n      // here: https://github.com/GlobalFishingWatch/map-client/issues/661#issuecomment-334496469\n      return false\n    }\n    return filterValues[field].indexOf(frame[field][index]) > -1\n  })\n  return satisfiesFilters\n}\n\nconst vesselSatisfiesAllFilters = (frame, index, filters) => {\n  const satisfiesAllFilters = filters\n    .filter((f) => f.pass !== true)\n    .some((filter) => vesselSatisfiesFilters(frame, index, filter.filterValues))\n  return satisfiesAllFilters\n}\n\nexport const selectVesselsAt = (tileData, tileQuery, startIndex, endIndex, currentFilters) => {\n  const vessels = []\n\n  const { worldX, worldY, toleranceRadiusInWorldUnits } = tileQuery\n\n  for (let f = startIndex; f < endIndex; f++) {\n    const frame = tileData[f]\n    if (frame === undefined) continue\n    for (let i = 0; i < frame.worldX.length; i++) {\n      const wx = frame.worldX[i]\n      const wy = frame.worldY[i]\n\n      if (\n        (!currentFilters.length || vesselSatisfiesAllFilters(frame, i, currentFilters)) &&\n        wx >= worldX - toleranceRadiusInWorldUnits &&\n        wx <= worldX + toleranceRadiusInWorldUnits &&\n        wy >= worldY - toleranceRadiusInWorldUnits &&\n        wy <= worldY + toleranceRadiusInWorldUnits\n      ) {\n        const vessel = {}\n\n        Object.keys(frame).forEach((key) => {\n          vessel[key] = frame[key][i]\n        })\n        vessel.timeIndex = f\n        vessels.push(vessel)\n      }\n    }\n  }\n  return vessels\n}\n\n/*\nexport const getHistogram = (tiles, propName = 'weight') => {\n  let data = tiles\n    .filter(tile => tile.ready)\n    .map(tile => tile.data\n      .map(frame => frame[propName]));\n  data = flattenDeep(data);\n  if (data.length) {\n    const bins = d3.histogram().thresholds(d3.thresholdScott)(data);\n    const x = d3.scaleLinear().domain([0, d3.max(bins, d => d.length)]).range([0, 50]);\n    console.table(bins.filter(bin => bin.length).map((bin) => {\n      const binMin = d3.min(bin).toLocaleString({ maximumFractionDigits: 2 });\n      const binMax = d3.max(bin).toLocaleString({ maximumFractionDigits: 2 });\n      return {\n        range: [binMin, binMax].join('﹣'),\n        bars: Array(Math.round(x(bin.length))).join('█'),\n        num: bin.length\n      };\n    }));\n  }\n};\n*/\n","import template from 'lodash/template'\nimport templateSettings from 'lodash/templateSettings'\n\nexport default (urlTemplate, urlParams) => {\n  templateSettings.interpolate = /{{([\\s\\S]+?)}}/g\n  const urlTemplateCompiled = template(urlTemplate)\n  return urlTemplateCompiled(urlParams)\n}\n","import tilecover from '@mapbox/tile-cover/index'\nimport debounce from 'lodash/debounce'\nimport { PerspectiveMercatorViewport } from 'viewport-mercator-project'\nimport { ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING, TILES_LOAD_ZOOM_OFFSET } from '../config'\nimport {\n  getTile,\n  releaseTiles,\n  highlightVesselFromHeatmap,\n  updateLoadedTiles,\n} from './heatmap.actions'\n\nexport const SET_CURRENTLY_VISIBLE_TILES = 'SET_CURRENTLY_VISIBLE_TILES'\nexport const SET_CURRENTLY_LOADED_TILES = 'SET_CURRENTLY_LOADED_TILES'\nexport const SET_CURRENTLY_SWAPPED_TILE_UIDS = 'SET_CURRENTLY_SWAPPED_TILE_UIDS'\nexport const MARK_TILES_UIDS_AS_LOADED = 'MARK_TILES_UIDS_AS_LOADED'\nexport const RELEASE_MARKED_TILES_UIDS = 'RELEASE_MARKED_TILES_UIDS'\n\n// restrict tilecover to a single zoom level\n// could be customized to load less or more detailed tiles\nconst getTilecoverLimits = (viewportZoom) => {\n  let zoom = Math.ceil(viewportZoom + TILES_LOAD_ZOOM_OFFSET)\n  let tilesAvailable = true\n  if (zoom > ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING) {\n    zoom = ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING\n    tilesAvailable = false\n  }\n  return {\n    min_zoom: zoom,\n    max_zoom: zoom,\n    tilesAvailable,\n  }\n}\n\nconst flushToReleaseTiles = () => (dispatch, getState) => {\n  const state = getState()\n  const currentToLoadTileUids = state.map.heatmapTiles.currentToLoadTileUids\n  // console.log('Tiles left to load: ', currentToLoadTileUids);\n\n  // Tiles are released only when all to-load tiles have finished loading\n  // this is to ensure smooth visual transitions between zoom levels\n  if (!currentToLoadTileUids.length) {\n    const currentTilesToReleaseUids = state.map.heatmapTiles.currentToReleaseTileUids\n    // console.log('no more tiles to load, releasing ', currentTilesToReleaseUids);\n    dispatch(releaseTiles(currentTilesToReleaseUids))\n    dispatch({\n      type: RELEASE_MARKED_TILES_UIDS,\n    })\n  }\n}\n\nexport const markTileAsLoaded = (tileUids) => (dispatch) => {\n  dispatch({\n    type: MARK_TILES_UIDS_AS_LOADED,\n    payload: tileUids,\n  })\n  // console.log(tileUids, 'have finished loading');\n  dispatch(flushToReleaseTiles())\n}\n\nconst flushTileState = (forceLoadingAllVisibleTiles = false) => (dispatch, getState) => {\n  const state = getState()\n  const currentVisibleTiles = state.map.heatmapTiles.currentVisibleTiles\n  let tilesToLoad = []\n  const tilesToReleaseUids = []\n\n  if (forceLoadingAllVisibleTiles === true) {\n    tilesToLoad = currentVisibleTiles\n  } else {\n    const currentLoadedTiles = state.map.heatmapTiles.currentLoadedTiles\n\n    currentVisibleTiles.forEach((visibleTile) => {\n      if (currentLoadedTiles.find((t) => t.uid === visibleTile.uid) === undefined) {\n        tilesToLoad.push(visibleTile)\n      }\n    })\n\n    currentLoadedTiles.forEach((loadedTile) => {\n      if (currentVisibleTiles.find((t) => t.uid === loadedTile.uid) === undefined) {\n        tilesToReleaseUids.push(loadedTile.uid)\n      }\n    })\n  }\n\n  const tilesToLoadUids = tilesToLoad.map((t) => t.uid)\n  // console.log('force loading:', forceLoadingAllVisibleTiles)\n  // console.log('visible', currentVisibleTiles.map(t => t.uid))\n  // console.log('load', tilesToLoadUids)\n  // console.log('release', tilesToReleaseUids)\n  // console.log('----')\n\n  tilesToLoad.forEach((tile) => {\n    dispatch(getTile(tile))\n  })\n  dispatch({\n    type: SET_CURRENTLY_LOADED_TILES,\n    payload: currentVisibleTiles,\n  })\n\n  dispatch({\n    type: SET_CURRENTLY_SWAPPED_TILE_UIDS,\n    payload: {\n      tilesToLoadUids,\n      tilesToReleaseUids,\n    },\n  })\n\n  dispatch(updateLoadedTiles())\n  dispatch(flushToReleaseTiles())\n}\n\nconst _debouncedFlushState = (dispatch) => {\n  dispatch(flushTileState())\n}\nconst debouncedFlushState = debounce(_debouncedFlushState, 500)\n\nexport const updateHeatmapTilesFromViewport = (forceLoadingAllVisibleTiles = false) => (\n  dispatch,\n  getState\n) => {\n  // if in transition, skip loading/releasing\n  // else\n  //   collect all tiles in viewport\n  //   save them to reducer: currentVisibleTiles\n  // if not zooming: flush immediately\n  //   if forceLoadingAllVisiblelTiles\n  //     get tiles from currentVisibleTiles\n  //   else\n  //     get tiles from currentVisibleTiles\n  //     make delta with currentLoadedTiles\n  //     get tiles from delta+\n  //     release tiles from delta-\n  //   save to reducer: currentVisibleTiles -> currentLoadedTiles\n  // if zooming: debounced flush to avoid \"tile spam\"\n  const mapViewport = getState().map.viewport\n  const viewport = mapViewport.viewport\n\n  // do not allow any tile update during transitions (currently only zoom)\n  // wait for the end of the transition to look at viewport and load matching tiles\n  if (!viewport.width || !viewport.height || mapViewport.currentTransition !== null) {\n    return\n  }\n\n  // instanciate a viewport instance to get lat/lon from screen top left/ bottom right bounds\n  const boundsViewport = new PerspectiveMercatorViewport(viewport)\n  const bounds = [\n    boundsViewport.unproject([0, 0]),\n    boundsViewport.unproject([viewport.width, viewport.height]),\n  ]\n\n  const [wn, es] = bounds\n  const [w, s, e, n] = [wn[0], es[1], es[0], wn[1]]\n  const boundsPolygonsCoordinates = []\n\n  const limits = getTilecoverLimits(viewport.zoom)\n  if (limits.tilesAvailable === false && forceLoadingAllVisibleTiles !== true) {\n    return\n  }\n\n  if (e > 180 || w < -180) {\n    // deal with the antimeridian situation by splitting the bounds polygon into two polygons\n    const w1 = e > 180 ? w : w + 360\n    const e1 = 180 - 0.001\n    const w2 = -180\n    const e2 = e > 180 ? e - 360 : e\n    boundsPolygonsCoordinates.push([[[w1, n], [e1, n], [e1, s], [w1, s], [w1, n]]])\n    boundsPolygonsCoordinates.push([[[w2, n], [e2, n], [e2, s], [w2, s], [w2, n]]])\n  } else {\n    boundsPolygonsCoordinates.push([[[w, n], [e, n], [e, s], [w, s], [w, n]]])\n  }\n\n  const geom = {\n    type: 'MultiPolygon',\n    coordinates: boundsPolygonsCoordinates,\n  }\n\n  // using tilecover, get xyz tile coords as well as quadkey indexes (named uid through the app)\n  const viewportTilesCoords = tilecover.tiles(geom, limits)\n  const viewportTilesIndexes = tilecover.indexes(geom, limits)\n  const visibleTiles = []\n\n  viewportTilesCoords.forEach((coords, i) => {\n    const uid = viewportTilesIndexes[i]\n    const zoom = coords[2]\n    if (zoom >= 2) {\n      visibleTiles.push({\n        tileCoordinates: {\n          x: coords[0],\n          y: coords[1],\n          zoom: coords[2],\n        },\n        uid,\n      })\n    }\n  })\n\n  dispatch({\n    type: SET_CURRENTLY_VISIBLE_TILES,\n    payload: visibleTiles,\n  })\n\n  const isMouseWheelZooming = mapViewport.prevZoom !== viewport.zoom\n\n  if (isMouseWheelZooming === false) {\n    dispatch(flushTileState(forceLoadingAllVisibleTiles))\n  } else {\n    debouncedFlushState(dispatch)\n  }\n}\n\nexport const queryHeatmapVessels = (coords, temporalExtentIndexes) => (dispatch, getState) => {\n  // use tilecover to get what tile quadkey/uid \"belongs\" to the point\n  const geom = {\n    type: 'Point',\n    coordinates: [coords.longitude, coords.latitude],\n  }\n  const zoom = getState().map.viewport.viewport.zoom\n\n  // get quadkey for tile at current zoom level, but also neighbouring zoom levels,\n  // in case current zoom level tiles has not been loaded yet\n  const uids = [zoom, zoom - 1, zoom + 1]\n    .map((z) => getTilecoverLimits(z))\n    .map((limits) => tilecover.indexes(geom, limits))\n    .map((indexes) => indexes[0])\n\n  const query = {\n    ...coords,\n    uids,\n  }\n\n  // console.log(query);\n  dispatch(highlightVesselFromHeatmap(query, temporalExtentIndexes))\n}\n","import difference from 'lodash/difference'\nimport uniq from 'lodash/uniq'\nimport uniqBy from 'lodash/uniqBy'\nimport {\n  getTilePromises,\n  getCleanVectorArrays,\n  groupData,\n  getTilePlaybackData,\n  selectVesselsAt,\n} from '../utils/heatmapTileData'\nimport { markTileAsLoaded } from './heatmapTiles.actions'\nimport { startLoader, completeLoader } from '../module/module.actions'\n\nexport const ADD_HEATMAP_LAYER = 'ADD_HEATMAP_LAYER'\nexport const UPDATE_HEATMAP_LAYER_STYLE = 'UPDATE_HEATMAP_LAYER_STYLE'\nexport const ADD_REFERENCE_TILE = 'ADD_REFERENCE_TILE'\nexport const HIGHLIGHT_VESSELS = 'HIGHLIGHT_VESSELS'\nexport const INIT_HEATMAP_LAYERS = 'INIT_HEATMAP_LAYERS'\nexport const REMOVE_HEATMAP_LAYER = 'REMOVE_HEATMAP_LAYER'\nexport const UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES =\n  'UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES'\nexport const UPDATE_HEATMAP_TILE = 'UPDATE_HEATMAP_TILE'\nexport const RELEASE_HEATMAP_TILES = 'RELEASE_HEATMAP_TILES'\nexport const UPDATE_LOADED_TILES = 'UPDATE_LOADED_TILES'\nexport const HIGHLIGHT_CLICKED_VESSEL = 'HIGHLIGHT_CLICKED_VESSEL'\nexport const CLEAR_HIGHLIGHT_CLICKED_VESSEL = 'CLEAR_HIGHLIGHT_CLICKED_VESSEL'\n\n/**\n * getTemporalExtentsVisibleIndices - Compares timebar outer extent with temporal extents present on the layer header\n * @param  {array} loadTemporalExtent Current timebar outer extent\n * @param  {array} layerTemporalExtents Temporal extent present on the layer's header (an array of extent arrays)\n * @return {array}                    Indices of the layer's temporal extents that should be visible\n */\nfunction getTemporalExtentsVisibleIndices(loadTemporalExtent, layerTemporalExtents) {\n  const currentExtentStart = loadTemporalExtent[0].getTime()\n  const currentExtentEnd = loadTemporalExtent[1].getTime()\n  const indices = []\n  layerTemporalExtents.forEach((temporalExtent, index) => {\n    const temporalExtentStart = temporalExtent[0]\n    const temporalExtentEnd = temporalExtent[1]\n    if (temporalExtentEnd >= currentExtentStart && temporalExtentStart <= currentExtentEnd) {\n      indices.push(index)\n    }\n  })\n  return indices\n}\n\n/**\n * loadLayerTile - loads an heatmap tile.\n *\n * @param  {string} layerId              layer id\n * @param  {object} tileCoordinates      tile coordinates from reference tile\n * @param  {string} token                the user's token\n * @param  {array} temporalExtentsIndices which of the temporal extents from  temporalExtents should be loaded\n * @param  {string} urls                 tile endpoints provided by header\n * @param  {array} temporalExtents       all of the layer's header temporal extents\n * @param  {bool} temporalExtentsLess    true = don't try to load different tiles based on current time extent\n * @return {Promise}                     a Promise that will be resolved when tile is loaded\n */\nfunction loadLayerTile(\n  layerId,\n  tileCoordinates,\n  token,\n  temporalExtentsIndices,\n  { url, temporalExtents, temporalExtentsLess }\n) {\n  // console.log('loadLayerTile', layerId, tileCoordinates, temporalExtentsIndices)\n  if (url === undefined) {\n    throw new Error('URL/endpoints object is not available on this tilesets header')\n  }\n  const pelagosPromises = getTilePromises(url, token, temporalExtents, {\n    tileCoordinates,\n    temporalExtentsIndices,\n    temporalExtentsLess,\n  })\n  const allLayerPromises = Promise.all(pelagosPromises)\n\n  const layerTilePromise = new Promise((resolve) => {\n    allLayerPromises.then((rawTileData) => {\n      resolve({\n        loadedLayerId: layerId,\n        rawTileData,\n      })\n    })\n  })\n\n  return layerTilePromise\n}\n\n/**\n * parseLayerTile - parses an heatmap tile to a playback-ready format.\n *\n * @param  {Object} rawTileData          the raw tile data, loaded either from the pelagos client or as a MVT/PBF vector tile\n * @param  {array} colsByName            names of the columns present in the raw tiles that need to be included in the final playback data\n * @param  {object} tileCoordinates      tile coordinates from reference tile\n * @param  {array} prevPlaybackData      (optional) in case some time extent was already loaded for this tile, append to this data\n * @return {Object}                      playback-ready merged data\n */\nfunction parseLayerTile(rawTileData, colsByName, tileCoordinates, prevPlaybackData) {\n  let data\n\n  const cleanVectorArrays = getCleanVectorArrays(rawTileData)\n  data = groupData(cleanVectorArrays, Object.keys(colsByName))\n  if (Object.keys(data).length === 0) {\n    return []\n  }\n\n  const playbackData = getTilePlaybackData(data, colsByName, tileCoordinates, prevPlaybackData)\n  return playbackData\n}\n\n/**\n * getTiles - loads a bunch of heatmap tiles\n * @param  {array} layerIds                 list of layer Ids that need to be loaded for this/these tiles\n * @param  {array} referenceTiles           list of reference tiles (tile data regardless of layer) that need to be loaded\n * @param  {object} newTemporalExtentsToLoad (optional) a dict (layerId is the key) of temporal extents\n * indices that should be appended to existing data\n */\nfunction getTiles(layerIds, referenceTiles, newTemporalExtentsToLoad = undefined) {\n  return (dispatch, getState) => {\n    const state = getState()\n    const loaderID = startLoader(dispatch, state, layerIds.join('-'))\n    const token = state.map.module.token\n    const heatmapLayers = state.map.heatmap.heatmapLayers\n    const tilesByLayer = {}\n    layerIds.forEach((id) => {\n      tilesByLayer[id] = [...heatmapLayers[id].tiles]\n    })\n    const allPromises = []\n\n    layerIds.forEach((layerId) => {\n      const heatmapLayerHeader = heatmapLayers[layerId].header\n      const { temporalExtents, temporalExtentsLess, colsByName } = { ...heatmapLayerHeader }\n      const url = heatmapLayerHeader.endpoints.tiles\n\n      referenceTiles.forEach((referenceTile) => {\n        // check if tile does not already exist first\n        let tile = tilesByLayer[layerId].find((t) => t.uid === referenceTile.uid)\n        if (!tile) {\n          // console.log('create tile ', referenceTile.uid)\n          tile = {\n            uid: referenceTile.uid,\n            temporalExtentsIndicesLoaded: [],\n          }\n          tilesByLayer[layerId].push(tile)\n        } else {\n          // console.log('found tile', referenceTile.uid)\n        }\n\n        const queriedTemporalExtentsIndices =\n          newTemporalExtentsToLoad === undefined\n            ? heatmapLayers[layerId].visibleTemporalExtentsIndices\n            : newTemporalExtentsToLoad[layerId]\n\n        const temporalExtentsIndicesToLoad = difference(\n          queriedTemporalExtentsIndices,\n          tile.temporalExtentsIndicesLoaded\n        )\n\n        const tilePromise = loadLayerTile(\n          layerId,\n          referenceTile.tileCoordinates,\n          token,\n          temporalExtentsIndicesToLoad,\n          {\n            url,\n            temporalExtents,\n            temporalExtentsLess,\n          }\n        )\n\n        allPromises.push(tilePromise)\n\n        tilePromise.then(({ loadedLayerId, rawTileData }) => {\n          tile.temporalExtentsIndicesLoaded = uniq(\n            tile.temporalExtentsIndicesLoaded.concat(temporalExtentsIndicesToLoad)\n          )\n          tile.data = parseLayerTile(\n            rawTileData,\n            colsByName,\n            referenceTile.tileCoordinates,\n            tile.data\n          )\n\n          dispatch({\n            type: UPDATE_HEATMAP_TILE,\n            payload: {\n              layerId: loadedLayerId,\n              tile,\n            },\n          })\n        })\n      })\n    })\n\n    Promise.all(allPromises).then(() => {\n      dispatch(completeLoader(loaderID))\n      dispatch(markTileAsLoaded(referenceTiles.map((tile) => tile.uid)))\n    })\n  }\n}\n\n/**\n * getTile - This action is emitted when a new tile is queried from panning or zooming the map\n * This will load a tile for all currently visible heatmap layers\n *\n * @param  {object} referenceTile a reference tile containing xyz coords and uid\n */\nexport function getTile(referenceTile) {\n  return (dispatch, getState) => {\n    dispatch({\n      type: ADD_REFERENCE_TILE,\n      payload: referenceTile,\n    })\n    const visibleHeatmapLayers = getState().map.heatmap.heatmapLayers\n    const visibleHeatmapLayersIds = Object.keys(visibleHeatmapLayers).filter(\n      (id) => visibleHeatmapLayers[id].visible === true\n    )\n\n    if (visibleHeatmapLayersIds.length) {\n      dispatch(getTiles(visibleHeatmapLayersIds, [referenceTile]))\n    }\n  }\n}\n\n/**\n * releaseTiles - This action is emitted when an existing tile is removed from panning or zooming the map\n * @param  {array} uids tile ref uids to release\n */\nexport const releaseTiles = (uids) => ({\n  type: RELEASE_HEATMAP_TILES,\n  payload: uids,\n})\n\nexport const updateLoadedTiles = () => ({\n  type: UPDATE_LOADED_TILES,\n})\n\n// triggered when a layer is added or set to visible\nfunction loadAllTilesForLayer(layerId) {\n  return (dispatch, getState) => {\n    //                current layer, all reference tiles\n    const referenceTiles = getState().map.heatmap.referenceTiles\n    dispatch(getTiles([layerId], referenceTiles))\n  }\n}\n\nexport const addHeatmapLayer = (layer, loadTemporalExtent) => (dispatch) => {\n  const layerTemporalExtents = layer.header.temporalExtents\n  dispatch({\n    type: ADD_HEATMAP_LAYER,\n    payload: {\n      ...layer,\n      // initially attach which of the temporal extents indices are visible with initial outerExtent\n      visibleTemporalExtentsIndices: getTemporalExtentsVisibleIndices(\n        loadTemporalExtent,\n        layerTemporalExtents\n      ),\n    },\n  })\n\n  if (layer.visible === true) {\n    dispatch(loadAllTilesForLayer(layer.id))\n  }\n}\n\nexport const removeHeatmapLayer = (id) => (dispatch) => {\n  dispatch({\n    type: REMOVE_HEATMAP_LAYER,\n    payload: {\n      id,\n    },\n  })\n}\n\n/**\n * updateLayerLoadTemporalExtents - when outer time extent changes, checks if more tiles needs to be loaded\n * by comparing the outer time range with the temporalExtent already loaded on each layer.\n * @param  {array} loadTemporalExtent Current app-wide extent of tiles that need to load, expressed\n * as an array of two dates\n */\nexport function updateLayerLoadTemporalExtents(loadTemporalExtent) {\n  return (dispatch, getState) => {\n    const state = getState()\n    const heatmapLayers = state.map.heatmap.heatmapLayers\n    const indicesToAddByLayer = {}\n\n    Object.keys(heatmapLayers).forEach((layerId) => {\n      const heatmapLayer = heatmapLayers[layerId]\n      const temporalExtents = heatmapLayer.header.temporalExtents\n      const oldVisibleTemporalExtentsIndices = heatmapLayer.visibleTemporalExtentsIndices\n      const newVisibleTemporalExtentsIndices = getTemporalExtentsVisibleIndices(\n        loadTemporalExtent,\n        temporalExtents\n      )\n\n      const indicesAdded = difference(\n        newVisibleTemporalExtentsIndices,\n        oldVisibleTemporalExtentsIndices\n      )\n\n      const indicesRemoved = difference(\n        oldVisibleTemporalExtentsIndices,\n        newVisibleTemporalExtentsIndices\n      )\n\n      if (indicesAdded.length || indicesRemoved.length) {\n        // add new loaded indices to heatmap layer if applicable\n        dispatch({\n          type: UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES,\n          payload: {\n            layerId,\n            newVisibleTemporalExtentsIndices,\n            indicesRemoved,\n          },\n        })\n      }\n      if (indicesAdded.length) {\n        indicesToAddByLayer[layerId] = indicesAdded\n      }\n    })\n\n    // getTiles with indices diff\n    const layerIdsWithIndicesToAdd = Object.keys(indicesToAddByLayer)\n    if (layerIdsWithIndicesToAdd.length) {\n      dispatch(\n        getTiles(layerIdsWithIndicesToAdd, state.map.heatmap.referenceTiles, indicesToAddByLayer)\n      )\n    }\n  }\n}\n\n/**\n * Returns clusters or vessels data from a tileQuery\n * @param {object} state - the application state\n * @param {string} tileQuery - the id of a heatmap layer\n * @return {object} { isEmpty, isCluster, isMouseCluster, foundVessels, layerId, tilesetId }\n */\nconst _queryHeatmap = (state, tileQuery, temporalExtentIndexes) => {\n  const layers = state.map.heatmap.heatmapLayers\n  const startIndex = temporalExtentIndexes[0]\n  const endIndex = temporalExtentIndexes[1]\n  const layersVessels = []\n\n  Object.keys(layers).forEach((layerId) => {\n    const layer = layers[layerId]\n    if (layer.visible !== true) {\n      return\n    }\n    const allPossibleTilesByPreference = tileQuery.uids.map((uid) =>\n      layer.tiles.find((tile) => tile.uid === uid)\n    )\n    const availableTiles = allPossibleTilesByPreference.filter(\n      (tile) => tile !== undefined && tile.data !== undefined\n    )\n\n    const currentFilters = layer.filters\n    if (availableTiles.length) {\n      const bestTile = availableTiles[0]\n      layersVessels.push({\n        layer,\n        vessels: selectVesselsAt(bestTile.data, tileQuery, startIndex, endIndex, currentFilters),\n      })\n    }\n  })\n\n  const layersVesselsResults = layersVessels.filter(\n    (layerVessels) => layerVessels.vessels.length > 0\n  )\n\n  // it's a cluster because of aggregation on the server side\n  let isCluster\n  // its a cluster because or multiple vessels under mouse\n  let isMouseCluster\n  let isEmpty\n  let layerVesselsResult\n  let foundVessels\n\n  if (layersVesselsResults.length === 0) {\n    isEmpty = true\n  } else if (layersVesselsResults.length > 1) {\n    // if there are points over multiple layers, consider this a cluster (ie don't select, zoom instead, or don't highlight)\n    // there's an exception if vessel selection contains an encounter, in which case it will take priority\n    isCluster = true\n  } else {\n    // layersVesselsResults should contain a single result\n    layerVesselsResult = layersVesselsResults[0]\n\n    // we can get multiple points with similar series and id, in which case\n    // we should treat that as a successful vessel query, not a cluster\n    const vessels = layerVesselsResult.vessels\n\n    if (vessels.length === 0) {\n      isEmpty = true\n    } else {\n      // look up for any negatives ids (clusters on the server side)\n      const clusteredVessels = vessels.filter((v) => v.id < 0)\n      if (clusteredVessels.length) {\n        isCluster = true\n      } else {\n        foundVessels = uniqBy(vessels, (v) => v.series)\n        isMouseCluster = foundVessels.length > 1\n      }\n    }\n  }\n\n  const layer = layerVesselsResult === undefined ? {} : layerVesselsResult.layer\n\n  return { isEmpty, isCluster, isMouseCluster, foundVessels, layer }\n}\n\nexport function clearHighlightedVessels() {\n  return {\n    type: HIGHLIGHT_VESSELS,\n    payload: {\n      isEmpty: true,\n      clickableCluster: false,\n    },\n  }\n}\n\nexport function highlightVesselFromHeatmap(tileQuery, temporalExtentIndexes) {\n  return (dispatch, getState) => {\n    const state = getState()\n    const { layer, isEmpty, isCluster, isMouseCluster, foundVessels } = _queryHeatmap(\n      state,\n      tileQuery,\n      temporalExtentIndexes\n    )\n\n    if (\n      isCluster === true ||\n      layer.id !== undefined ||\n      state.map.heatmap.highlightedVessels.layerId !== layer.id\n    ) {\n      const layerPayload =\n        layer === undefined\n          ? null\n          : {\n              id: layer.id,\n              tilesetId: layer.tilesetId,\n              subtype: layer.subtype,\n              header: layer.header,\n            }\n      dispatch({\n        type: HIGHLIGHT_VESSELS,\n        payload: {\n          layer: layerPayload,\n          isEmpty,\n          clickableCluster: isCluster === true || isMouseCluster === true,\n          highlightableCluster: isCluster !== true,\n          foundVessels,\n        },\n      })\n    } else {\n      dispatch(clearHighlightedVessels())\n    }\n  }\n}\n\nexport const highlightClickedVessel = (id, layerId) => ({\n  type: HIGHLIGHT_CLICKED_VESSEL,\n  payload: {\n    id,\n    layerId,\n  },\n})\n\nexport const clearHighlightedClickedVessel = () => ({\n  type: CLEAR_HIGHLIGHT_CLICKED_VESSEL,\n})\n\nexport const updateHeatmapLayers = (newLayers, currentLoadTemporalExtent) => (\n  dispatch,\n  getState\n) => {\n  if (newLayers === null) {\n    console.warn(\"New layers in updateHeatmapLayers can't be null\")\n    return\n  }\n  const prevLayersDict = getState().map.heatmap.heatmapLayers\n\n  // add and update layers\n  newLayers.forEach((newLayer) => {\n    const layerId = newLayer.id\n    const prevLayer = prevLayersDict[layerId]\n    if (prevLayer === undefined) {\n      // console.log('adding', layerId)\n      dispatch(addHeatmapLayer(newLayer, currentLoadTemporalExtent))\n    } else {\n      if (prevLayer.visible !== newLayer.visible && newLayer.visible === true) {\n        dispatch(loadAllTilesForLayer(layerId))\n      }\n      if (\n        prevLayer.visible !== newLayer.visible ||\n        prevLayer.hue !== newLayer.hue ||\n        prevLayer.opacity !== newLayer.opacity ||\n        prevLayer.filters !== newLayer.filters ||\n        prevLayer.interactive !== newLayer.interactive\n      ) {\n        // console.log('updating', layerId, ' with visibilty', newLayer.visible)\n        dispatch({\n          type: UPDATE_HEATMAP_LAYER_STYLE,\n          payload: {\n            id: newLayer.id,\n            visible: newLayer.visible,\n            hue: newLayer.hue,\n            opacity: newLayer.opacity,\n            filters: newLayer.filters,\n            interactive: newLayer.interactive,\n          },\n        })\n      }\n    }\n  })\n\n  // clean up unused layers\n  Object.keys(prevLayersDict).forEach((prevLayerId) => {\n    if (!newLayers.find((l) => l.id === prevLayerId)) {\n      dispatch(removeHeatmapLayer(prevLayerId))\n    }\n  })\n}\n","import { fitBounds, pixelsToWorld } from 'viewport-mercator-project'\nimport { updateHeatmapTilesFromViewport } from '../heatmap/heatmapTiles.actions'\nimport { onViewportChange } from '../module/module.actions'\nimport { CLUSTER_CLICK_ZOOM_INCREMENT } from '../config' // TODO MAP MODULE\n\nexport const SET_VIEWPORT = 'SET_VIEWPORT'\nexport const UPDATE_VIEWPORT = 'UPDATE_VIEWPORT'\nexport const SET_ZOOM_INCREMENT = 'SET_ZOOM_INCREMENT'\nexport const SET_MOUSE_LAT_LONG = 'SET_MOUSE_LAT_LONG'\nexport const TRANSITION_END = 'TRANSITION_END'\nexport const SET_NATIVE_VIEWPORT = 'SET_NATIVE_VIEWPORT'\n\nexport const setViewport = (viewport, interactionState) => (dispatch) => {\n  dispatch({\n    type: SET_VIEWPORT,\n    payload: viewport,\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  dispatch(onViewportChange(interactionState))\n}\n\nexport const updateViewport = (viewportUpdate) => (dispatch) => {\n  dispatch({\n    type: UPDATE_VIEWPORT,\n    payload: viewportUpdate,\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  dispatch(onViewportChange())\n}\n\nconst transitionTo = (increment, latitude = null, longitude = null, zoom = null) => (dispatch) => {\n  dispatch({\n    type: SET_ZOOM_INCREMENT,\n    payload: {\n      increment,\n      latitude,\n      longitude,\n      zoom,\n    },\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  dispatch(onViewportChange())\n}\n\nexport const transitionToZoom = (viewport) => (dispatch) => {\n  dispatch(transitionTo(null, viewport.center[0], viewport.center[1], viewport.zoom))\n}\n\nexport const transitionEnd = () => (dispatch) => {\n  dispatch({\n    type: TRANSITION_END,\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  dispatch(onViewportChange())\n}\n\nexport const zoomIntoVesselCenter = (latitude, longitude, zoom = null) => (dispatch) => {\n  dispatch(transitionTo(CLUSTER_CLICK_ZOOM_INCREMENT, latitude, longitude, zoom))\n}\n\nexport const fitToBounds = (bounds) => (dispatch, getState) => {\n  const state = getState()\n  const vp = fitBounds({\n    bounds: [[bounds.minLng, bounds.minLat], [bounds.maxLng, bounds.maxLat]],\n    width: state.map.viewport.viewport.width,\n    height: state.map.viewport.viewport.height,\n    padding: 50,\n  })\n  dispatch(transitionTo(null, vp.latitude, vp.longitude, vp.zoom))\n}\n\nexport const exportNativeViewport = (nativeViewport) => (dispatch) => {\n  const topLeftPx = [0, 0]\n  const bottomRightPx = [nativeViewport.width, nativeViewport.height]\n\n  // compute left and right offsets to deal with antimeridian issue\n  const topLeftWorld = pixelsToWorld(topLeftPx, nativeViewport.pixelUnprojectionMatrix)\n  const bottomRightWorld = pixelsToWorld(bottomRightPx, nativeViewport.pixelUnprojectionMatrix)\n  const leftWorldScaled = topLeftWorld[0] / nativeViewport.scale\n  const rightWorldScaled = bottomRightWorld[0] / nativeViewport.scale\n\n  // lat/lon corners for miniglobe\n  const northWest = nativeViewport.unproject(topLeftPx)\n  const southEast = nativeViewport.unproject(bottomRightPx)\n  const bounds = {\n    north: northWest[1],\n    south: southEast[1],\n    west: northWest[0],\n    east: southEast[0],\n  }\n\n  dispatch({\n    type: SET_NATIVE_VIEWPORT,\n    payload: {\n      leftWorldScaled,\n      rightWorldScaled,\n      bounds,\n    },\n  })\n}\n","import area from '@turf/area'\nimport { POLYGON_LAYERS_AREA } from '../constants'\nimport { clearHighlightedVessels, clearHighlightedClickedVessel } from '../heatmap/heatmap.actions'\nimport { zoomIntoVesselCenter } from './viewport.actions'\n\nexport const SET_POPUP = 'SET_POPUP'\nexport const CLEAR_POPUP = 'CLEAR_POPUP'\nexport const SET_MAP_CURSOR = 'SET_MAP_CURSOR'\n\nconst getAreaKm2 = (glFeature) => {\n  const areakm2 = 10 ** -6 * area(glFeature.geometry)\n  const formatted = areakm2.toLocaleString('en-US', { maximumFractionDigits: 0 })\n  return formatted\n}\n\nconst getFields = (glFeature, source = null) => {\n  if (source === null || source === undefined) {\n    // console.warn('Couldnt find source when looking for fields of layer', sourceId)\n  }\n\n  const fieldsDefinition =\n    source === undefined ||\n    source.metadata === undefined ||\n    source.metadata['gfw:popups'] === undefined\n      ? []\n      : source.metadata['gfw:popups']\n\n  const properties = glFeature.properties\n\n  // whitelist if 'gfw:popups' exist, if not return all\n  const fieldsKeys = Object.keys(glFeature.properties).filter(\n    (k) => fieldsDefinition.length === 0 || fieldsDefinition.find((fd) => fd.id === k) !== undefined\n  )\n\n  const fields = fieldsKeys.map((fieldKey) => {\n    const value = fieldKey === POLYGON_LAYERS_AREA ? getAreaKm2(glFeature) : properties[fieldKey]\n    const def = fieldsDefinition.find((fd) => fd.id === fieldKey) || {}\n    const label = def.label || fieldKey\n    return {\n      id: fieldKey,\n      label,\n      value,\n      title: `${label}: ${value}`,\n      isLink: def.isLink,\n      isMain: def.isMain,\n    }\n  })\n\n  const mainField =\n    fields.find((f) => f.isMain === true) ||\n    fields.find((f) => f.id === 'name') ||\n    fields.find((f) => f.id === 'id') ||\n    fields[0]\n\n  if (mainField !== undefined) {\n    mainField.isMain = true\n  }\n  return fields\n}\n\nconst getCluster = (glFeature, glGetSource) => {\n  const clusterId = glFeature.properties.cluster_id\n  const sourceId = glFeature.source\n  const glSource = glGetSource(sourceId)\n  const promise = new Promise((resolve, reject) => {\n    glSource.getClusterExpansionZoom(clusterId, (err1, zoom) => {\n      glSource.getClusterLeaves(clusterId, 99, 0, (err2, children) => {\n        if (err1 || err2) {\n          reject()\n        }\n        const childrenFeatures = children.map((child) =>\n          getFeature(child, glFeature.layer.id, glSource)\n        )\n        resolve({\n          zoom,\n          childrenFeatures,\n        })\n      })\n    })\n  })\n  return promise\n}\n\nconst getFeature = (glFeature, layerId, source) => {\n  const feature = {\n    properties: glFeature.properties,\n  }\n  const fields = getFields(glFeature, source)\n  feature.fields = fields\n\n  // Get most likely feature title\n  const mainField = fields.find((f) => f.isMain === true)\n  feature.title = mainField === undefined ? layerId : mainField.value\n\n  return feature\n}\n\nexport const mapInteraction = (interactionType, latitude, longitude, glFeatures, glGetSource) => (\n  dispatch,\n  getState\n) => {\n  if (interactionType === 'click') {\n    dispatch(clearHighlightedClickedVessel())\n  }\n\n  const currentStyle = getState().map.style.mapStyle.toJS()\n\n  const event = {\n    latitude,\n    longitude,\n    features: [],\n  }\n\n  // Collect and normalize features on legacy heatmap\n  const currentLegacyHeatmapData = getState().map.heatmap.highlightedVessels\n  let legacyHeatmapFeature\n\n  if (currentLegacyHeatmapData.isEmpty !== true) {\n    const foundVessels =\n      currentLegacyHeatmapData.foundVessels === undefined\n        ? []\n        : currentLegacyHeatmapData.foundVessels\n    const properties = foundVessels.length === 0 ? [] : foundVessels[0]\n    const isCluster = currentLegacyHeatmapData.clickableCluster === true\n    const count =\n      isCluster === true && currentLegacyHeatmapData.highlightableCluster === false\n        ? -1\n        : foundVessels.length\n    legacyHeatmapFeature = {\n      isCluster,\n      count,\n      layer: {\n        id: currentLegacyHeatmapData.layer.id,\n        group: 'legacyHeatmap',\n      },\n      properties,\n    }\n    event.features.push(legacyHeatmapFeature)\n  }\n\n  // Try to retrieve 'gfw:id' (generated when instanciating CARTO layer to preserve original style.json id)\n  // In most cases it won't exist, so fall back to source id\n  const getStaticLayerIdFromGlFeature = (glFeature) =>\n    (glFeature.layer.metadata !== undefined && glFeature.layer.metadata['gfw:id']) ||\n    glFeature.layer.source\n\n  // Collect gl features\n  const clusterPromises = []\n  const allGlFeatures = glFeatures || []\n  allGlFeatures.forEach((glFeature) => {\n    const layerId = getStaticLayerIdFromGlFeature(glFeature)\n    const source = currentStyle.sources[layerId]\n    const feature = {\n      layer: {\n        id: layerId,\n        group: glFeature.layer.metadata && glFeature.layer.metadata['mapbox:group'],\n      },\n      ...getFeature(glFeature, layerId, source),\n    }\n\n    if (glFeature.properties.cluster === true) {\n      // lookup for cluster\n      const clusterPromise = getCluster(glFeature, glGetSource).then((cluster) => {\n        feature.cluster = cluster\n        feature.count = cluster.childrenFeatures.length\n      })\n      clusterPromises.push(clusterPromise)\n      feature.isCluster = true\n    } else {\n      feature.isCluster = false\n    }\n    event.features.push(feature)\n  })\n\n  Promise.all(clusterPromises).then(() => {\n    // The whole set of features is considered a cluster\n    // if any feature is a cluster, or there is more than one feature\n    event.isCluster =\n      event.features.length > 1 || event.features.some((feature) => feature.isCluster === true)\n\n    // legacy heatmap layers can yield clusters with an unknown number of features, handle this here:\n    if (legacyHeatmapFeature !== undefined && legacyHeatmapFeature.count === -1) {\n      event.count = -1\n    } else {\n      event.count = event.features.reduce((count, feature) => {\n        let featureCount = feature.count || 1\n        return count + featureCount\n      }, 0)\n    }\n\n    if (event.count === 1) {\n      event.feature = event.features[0]\n    }\n\n    // When autoClusterZoom is set to true, we handle zoom here\n    const autoClusterZoom = getState().map.module.autoClusterZoom === true\n\n    // Check if cluster using customizable isCluster() callback\n    // If not set resolves simply to (event) => event.isCluster === true\n    const clusterBehavior = getState().map.module.isCluster(event)\n    event.isCluster = clusterBehavior\n\n    if (autoClusterZoom) {\n      if (interactionType === 'click' && event.isCluster === true) {\n        dispatch(clearHighlightedVessels())\n        const clusterZoom = event.features[0].cluster && event.features[0].cluster.zoom\n        dispatch(zoomIntoVesselCenter(latitude, longitude, clusterZoom))\n      }\n    }\n\n    let cursor = event.features.length ? 'pointer' : null\n    if (event.isCluster === true) {\n      cursor = 'zoom-in'\n    }\n\n    dispatch({\n      type: SET_MAP_CURSOR,\n      payload: cursor,\n    })\n\n    const callback =\n      interactionType === 'click' ? getState().map.module.onClick : getState().map.module.onHover\n\n    if (callback !== undefined) {\n      callback(event)\n    }\n  })\n}\n","const RGB_MAX = 255\nconst HUE_MAX = 360\nconst SV_MAX = 100\n\nexport const VESSELS_HUES_INCREMENTS_NUM = 31 // 360 / VESSELS_HUES_INCREMENTS_NUM - 1  should give a round number\nexport const VESSELS_HUES_INCREMENT = 360 / (VESSELS_HUES_INCREMENTS_NUM - 1)\n\n// Legacy: this is only here for compatibility with pre-mapbox branch workspaces\nexport const COLOR_HUES = {\n  orange: 0,\n  peach: 22,\n  yellow: 60,\n  green: 85,\n  brightGreen: 145,\n  lightBlue: 182,\n  blue: 236,\n  purple: 284,\n  pink: 312,\n}\n\n// FIXME mark explicitely as legacy. Check all usages.\nexport const getKeyByValue = (obj, value) => {\n  let result = null\n  Object.entries(obj).forEach((entry) => {\n    if (entry[1] === value) result = entry[0]\n  })\n  return result\n}\n\n/**\n * Converts an RGB color value to HSV. Conversion formula\n * adapted from http://en.wikipedia.org/wiki/HSV_color_space.\n * Assumes r, g, and b are contained in the set [0, 255] and\n * returns h, s, and v in the set [0, 1].\n *\n * @param   Number  r       The red color value\n * @param   Number  g       The green color value\n * @param   Number  b       The blue color value\n * @return  Array           The HSV representation\n */\nexport const rgbToHsv = (_r, _g, _b) => {\n  const r = _r / 255\n  const g = _g / 255\n  const b = _b / 255\n\n  const max = Math.max(r, g, b)\n  const min = Math.min(r, g, b)\n  let h\n  const v = max\n\n  const d = max - min\n  const s = max === 0 ? 0 : d / max\n\n  if (max === min) {\n    h = 0 // achromatic\n  } else {\n    switch (max) {\n      case r:\n        h = (g - b) / d + (g < b ? 6 : 0)\n        break\n      case g:\n        h = (b - r) / d + 2\n        break\n      case b:\n        h = (r - g) / d + 4\n        break\n      default:\n        h = 0\n    }\n\n    h /= 6\n  }\n\n  return [h, s, v]\n}\n\n// converts hue, saturation, luminance to an rgb object\nexport const hsvToRgb = (h_, s_, v_) => {\n  const h = ((h_ % HUE_MAX) / parseFloat(HUE_MAX)) * 6\n  const s = s_ === SV_MAX ? 1 : (s_ % SV_MAX) / parseFloat(SV_MAX)\n  const v = v_ === SV_MAX ? 1 : (v_ % SV_MAX) / parseFloat(SV_MAX)\n\n  const i = Math.floor(h)\n  const f = h - i\n  const p = v * (1 - s)\n  const q = v * (1 - f * s)\n  const t = v * (1 - (1 - f) * s)\n  const mod = i % 6\n  const r = [v, q, p, p, t, v][mod]\n  const g = [t, v, v, q, p, p][mod]\n  const b = [p, p, t, v, v, q][mod]\n\n  return { r: Math.round(r * RGB_MAX), g: Math.round(g * RGB_MAX), b: Math.round(b * RGB_MAX) }\n}\n\n// returns an rgb string with default saturation and luminance values\nconst hueToRgbDefaults = (hue) => hsvToRgb(hue, 50, 100)\n\nexport const hueToRgbString = (hue) => {\n  const rgb = hueToRgbDefaults(hue)\n  return `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`\n}\n\nexport const rgbToHexString = (rgb, css) => {\n  const str = ['r', 'g', 'b']\n    .map((channelName) => {\n      const channelValue = rgb[channelName]\n      let channelStr = channelValue.toString(16)\n      if (channelValue < 16) {\n        channelStr = `0${channelStr}`\n      }\n      return channelStr\n    })\n    .join('')\n  const prefix = css === true ? '#' : '0x'\n  return `${prefix}${str}`\n}\n\nexport const hueToRgbHexString = (hue, css) => {\n  const rgb = hueToRgbDefaults(hue)\n  return rgbToHexString(rgb, css)\n}\n\nconst closestNumber = (numberArray, goal) =>\n  numberArray.reduce((prev, curr) => (Math.abs(curr - goal) < Math.abs(prev - goal) ? curr : prev))\n\nexport const hueToClosestColor = (hue) => {\n  if (hue === undefined || hue === null) return undefined\n  const colorHueValues = Object.keys(COLOR_HUES).map((key) => COLOR_HUES[key])\n  const closestHue = closestNumber(colorHueValues, hue)\n  return getKeyByValue(COLOR_HUES, closestHue)\n}\n\nexport const hexToRgb = (hex) => {\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex)\n  return result\n    ? {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16),\n      }\n    : null\n}\n\nconst rgbToRgbaString = (rgb, opacity) => `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`\n\nexport const hueToRgbaString = (hue, opacity) => {\n  const rgb = hueToRgbDefaults(hue)\n  return rgbToRgbaString(rgb, opacity)\n}\n\nexport const hexToRgba = (hex, opacity) => {\n  const rgb = hexToRgb(hex)\n  return rgbToRgbaString(rgb, opacity)\n}\n\nexport const hueIncrementToHue = (hueIncrement) => hueIncrement * VESSELS_HUES_INCREMENT\n\nexport const hueToHueIncrement = (hue) =>\n  Math.round((hue / 360) * (VESSELS_HUES_INCREMENTS_NUM - 1))\n\nexport const wrapHue = (hue) => hue % 360\n\nexport const hueOrColorToHexColor = (color, hue) => {\n  if (hue !== undefined) {\n    return hueToRgbHexString(hue, true)\n  }\n\n  return color\n}\n","/* global PIXI */\nimport 'pixi.js'\nimport { hueToHueIncrement, VESSELS_HUES_INCREMENTS_NUM } from '../utils/map-colors'\nimport { VESSELS_BASE_RADIUS, MAX_SPRITES_PER_LAYER } from '../config'\n\nexport default class HeatmapSubLayer {\n  constructor(baseTexture, renderingStyleIndex, hue, useNormalBlendMode = false) {\n    // this.stage = new PIXI.Container();\n    // the ParticleContainer is a faster version of the PIXI sprite container\n    this.stage = new PIXI.particles.ParticleContainer(MAX_SPRITES_PER_LAYER, {\n      scale: true,\n      alpha: true,\n      position: true,\n      uvs: true,\n    })\n    if (useNormalBlendMode === false) {\n      this.stage.blendMode = PIXI.BLEND_MODES.SCREEN\n    }\n\n    this.spritesPool = []\n\n    const initialTextureFrame = new PIXI.Rectangle(\n      0,\n      0,\n      VESSELS_BASE_RADIUS * 2,\n      VESSELS_BASE_RADIUS * 2\n    )\n    this.mainVesselTexture = new PIXI.Texture(baseTexture, initialTextureFrame)\n    this._setTextureFrame(renderingStyleIndex, hue)\n\n    this.clearSpriteProps()\n  }\n\n  clearSpriteProps() {\n    this.spritesProps = {\n      x: new Float32Array(MAX_SPRITES_PER_LAYER),\n      y: new Float32Array(MAX_SPRITES_PER_LAYER),\n      a: new Float32Array(MAX_SPRITES_PER_LAYER),\n      s: new Float32Array(MAX_SPRITES_PER_LAYER),\n    }\n    this.spritesPropsCount = 0\n  }\n\n  pushSpriteProps(x, y, a, s) {\n    this.spritesProps.x[this.spritesPropsCount] = x\n    this.spritesProps.y[this.spritesPropsCount] = y\n    this.spritesProps.a[this.spritesPropsCount] = a\n    this.spritesProps.s[this.spritesPropsCount] = s\n    this.spritesPropsCount++\n  }\n\n  setRenderingStyleIndex(renderingStyleIndex) {\n    this._setTextureFrame(renderingStyleIndex)\n  }\n\n  destroy() {\n    this.spritesPool = null\n    this.stage.destroy({ children: true })\n  }\n\n  /**\n   * Updates the main texture frame offset to show different brush styles and hues\n   * Both args are optional, if one is omitted, previous value is used\n   * @heatmapStyle bool whether to use heatmap style or solid circle style\n   * @hue number hue value between 0 and 360\n   */\n  _setTextureFrame(renderingStyleIndex = null, hue = null) {\n    const textureFrame = this.mainVesselTexture.frame.clone()\n\n    if (renderingStyleIndex !== null) {\n      // one diameter + tiny offset between 2 frames\n      textureFrame.x = VESSELS_BASE_RADIUS * 2 * renderingStyleIndex + renderingStyleIndex\n    }\n\n    if (hue !== null) {\n      let hueIncrement = hueToHueIncrement(hue)\n      if (hueIncrement === VESSELS_HUES_INCREMENTS_NUM - 1) {\n        hueIncrement = 0\n      }\n      textureFrame.y = hueIncrement * VESSELS_BASE_RADIUS * 2\n      if (hueIncrement > 0) {\n        textureFrame.y += hueIncrement\n      }\n    }\n\n    this.mainVesselTexture.frame = textureFrame\n    this.mainVesselTexture.update()\n  }\n\n  render() {\n    const numProps = this.spritesPropsCount\n    this.resizeSpritesPool()\n\n    for (let i = 0; i < numProps; i++) {\n      const sprite = this.stage.children[i]\n      const s = this.spritesProps.s[i]\n      sprite.setTransform(this.spritesProps.x[i], this.spritesProps.y[i], s, s)\n      sprite.alpha = this.spritesProps.a[i]\n    }\n\n    const numSprites = this.stage.children.length\n    for (let i = numProps; i < numSprites; i++) {\n      const sprite = this.stage.children[i]\n      sprite.x = -100\n    }\n  }\n\n  resizeSpritesPool() {\n    const numProps = this.spritesPropsCount\n    const prevNumSprites = this.stage.children.length\n    const delta = numProps - prevNumSprites\n    // console.log(prevNumSprites, '->', numProps, ' delta:', delta);\n\n    if (delta < -4999) {\n      // sprite needs to be removed. Do that progressively (max 100) to avoid UI lock\n      const toRemove = Math.min(100, -delta)\n      // console.log('removing ', toRemove);\n      for (let i = 0; i < toRemove; i++) {\n        this.stage.removeChildAt(0)\n      }\n    }\n\n    if (delta > 0) {\n      const toAdd = Math.max(5000, delta)\n      // console.log('adding ', toAdd);\n      this._addSprites(toAdd)\n    }\n  }\n\n  _addSprites(num) {\n    for (let i = 0; i < num; i++) {\n      const vessel = new PIXI.Sprite(this.mainVesselTexture)\n      vessel.anchor.x = 0.5\n      vessel.anchor.y = 0.5\n      // ParticlesContainer does not support .visible, so we just move the sprite out of the viewport\n      vessel.x = -100\n      // vessel.blendMode = PIXI.BLEND_MODES.SCREEN;\n      // vessel.filters=  [new PIXI.filters.BlurFilter(10,10)]\n      this.stage.addChild(vessel)\n    }\n  }\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport uniq from 'lodash/uniq'\nimport * as PIXI from 'pixi.js'\nimport { worldToPixels } from 'viewport-mercator-project'\nimport { BRUSH_RENDERING_STYLE, BRUSH_ZOOM_RENDERING_STYLE } from '../constants'\nimport { vesselSatisfiesFilters } from '../utils/heatmapTileData'\nimport HeatmapSubLayer from './HeatmapSubLayer'\n\n// This is a faster version of worldToPixels that omits pitch,\n// and ignores values from the matrix that are consistently = 0\nconst s = 1 / 1.5\nconst worldToPixelsSimple = (x, y, m) => {\n  const fx = s * (m[0] * x + m[4] * y + m[12])\n  const fy = s * (m[5] * y + m[13])\n  return [fx, fy]\n}\n\nclass HeatmapLayer extends React.Component {\n  componentDidMount() {\n    this._build()\n  }\n\n  componentWillUnmount() {\n    this._destroy()\n  }\n\n  componentDidUpdate() {\n    this._redraw()\n  }\n\n  componentWillReceiveProps(nextProps) {\n    if (nextProps.useRadialGradientStyle !== this.props.useRadialGradientStyle) {\n      this.setBrushZoomRenderingStyle(nextProps.useRadialGradientStyle)\n    }\n  }\n\n  _build() {\n    const { layer, rootStage, useRadialGradientStyle, customRenderingStyle } = this.props\n    this.subLayers = {}\n    this.renderingStyle =\n      layer.header && layer.header.rendering ? layer.header.rendering : customRenderingStyle\n\n    this.setBrushRenderingStyle(this.renderingStyle.style)\n    this.setBrushZoomRenderingStyle(useRadialGradientStyle)\n\n    this.stage = new PIXI.Container()\n\n    rootStage.addChild(this.stage)\n  }\n\n  setBrushRenderingStyle(style = BRUSH_RENDERING_STYLE.NORMAL) {\n    if (typeof style === 'string') {\n      this.brushRenderingStyle = BRUSH_RENDERING_STYLE[style.toUpperCase()]\n    } else {\n      this.brushRenderingStyle = style\n    }\n    this._setBrushRenderingStyleIndex()\n  }\n\n  setBrushZoomRenderingStyle(useRadialGradientStyle) {\n    this.brushZoomRenderingStyle =\n      useRadialGradientStyle === true\n        ? BRUSH_ZOOM_RENDERING_STYLE.RADIAL_GRADIENT\n        : BRUSH_ZOOM_RENDERING_STYLE.CIRCLE\n    this._setBrushRenderingStyleIndex()\n  }\n\n  _setBrushRenderingStyleIndex() {\n    // only NORMAL brush styles support different zoom styles\n    const cappedZoomRenderingStyle =\n      this.brushRenderingStyle === BRUSH_RENDERING_STYLE.NORMAL ? this.brushZoomRenderingStyle : 0\n    const newStyleIndex = this.brushRenderingStyle + cappedZoomRenderingStyle\n    if (newStyleIndex === this.renderingStyleIndex) {\n      return\n    }\n    this.renderingStyleIndex = newStyleIndex\n    Object.values(this.subLayers).forEach((subLayer) => {\n      subLayer.setRenderingStyleIndex(this.renderingStyleIndex)\n    })\n  }\n\n  _redraw() {\n    const { filters, baseTexture, layer } = this.props\n\n    if (\n      layer === null ||\n      layer === undefined ||\n      layer.tiles === undefined ||\n      layer.visible === false\n    ) {\n      this.stage.visible = false\n      return\n    }\n\n    this.stage.visible = true\n    this.stage.alpha = layer.opacity\n\n    const tiles = layer.tiles\n    const defaultHue = layer.hue\n    const allHuesToRender =\n      filters !== undefined && filters.length\n        ? filters\n            // pass is set to true by filterGroupActions when none of the filters fields\n            // in the filter group is supported by the layer headers\n            .filter((f) => f.pass !== true)\n            .map((f) => (f.hue === undefined ? '0' : f.hue.toString()))\n        : [defaultHue.toString()]\n    const currentlyUsedHues = Object.keys(this.subLayers)\n\n    // get all hues, old and new\n    const allHues = uniq(allHuesToRender.concat(currentlyUsedHues))\n\n    for (let i = 0; i < allHues.length; i++) {\n      const hue = allHues[i]\n      if (allHuesToRender.indexOf(hue) === -1) {\n        // not on new hues: delete sublayer\n        this._destroySubLayer(this.subLayers[hue])\n        delete this.subLayers[hue]\n        continue\n      }\n      if (currentlyUsedHues.indexOf(hue) === -1) {\n        // not on old hues: create sublayer\n        this.subLayers[hue] = this._createSublayer(baseTexture, this.renderingStyleIndex, hue)\n      }\n      this.subLayers[hue].clearSpriteProps()\n    }\n\n    if (!allHuesToRender.length) return\n    tiles.forEach((tile) => {\n      this._setSubLayersSpritePropsForTile({\n        data: tile.data,\n        numFilters: filters.length,\n        defaultHue,\n      })\n    })\n\n    allHuesToRender.forEach((hueToRender) => {\n      this.subLayers[hueToRender].render()\n    })\n  }\n\n  _setSubLayersSpritePropsForTile({ data, numFilters, defaultHue }) {\n    if (!data) {\n      return\n    }\n\n    const { startIndex, endIndex, viewport, filters, viewportLeft, viewportRight } = this.props\n\n    for (let timeIndex = startIndex; timeIndex < endIndex; timeIndex++) {\n      const frame = data[timeIndex]\n\n      if (!frame) continue\n\n      for (let index = 0, len = frame.worldX.length; index < len; index++) {\n        let hue\n        if (filters === undefined || !filters.length) {\n          hue = defaultHue\n        }\n        for (let fi = 0; fi < numFilters; fi++) {\n          const filter = filters[fi]\n          if (vesselSatisfiesFilters(frame, index, filter.filterValues)) {\n            hue = filter.hue\n            break\n          }\n        }\n\n        // no filter passes: bail\n        if (hue === undefined) {\n          continue\n        }\n\n        // wrap worldX when point crosses the antimeridian/dateline\n        // world points go from 0 to 512. There is no way to determine if worldX is on the \"wrong\" side\n        // of the antimeridian just by looking at its value (where with lat/lon we can simply look at -/+)\n        // Therefore we compare it to the viewport's left or right boundary, depending on what is currently\n        // \"the right side\" of the antimeridian\n        let worldX = frame.worldX[index]\n        if (viewportLeft > 0 && worldX < viewportLeft) {\n          // worldX is \"behind\" viewportLeft, which means it is \"on the right\" of the antimeridian\n          worldX += 512\n        } else if (viewportLeft < 0 && worldX > viewportRight) {\n          worldX -= 512\n        }\n\n        const scaledX = worldX * viewport.scale\n        const scaledY = frame.worldY[index] * viewport.scale\n        const mtx = viewport.pixelProjectionMatrix\n\n        const [x, y] =\n          viewport.pitch === 0\n            ? worldToPixelsSimple(scaledX, scaledY, mtx)\n            : worldToPixels([scaledX, scaledY], mtx)\n\n        if (x > -10 && x < viewport.width + 10 && y > -10 && y < viewport.height + 10) {\n          this.subLayers[hue].pushSpriteProps(\n            x,\n            y,\n            frame.opacity ? frame.opacity[index] : this.renderingStyle.defaultOpacity,\n            frame.radius ? frame.radius[index] : this.renderingStyle.defaultSize\n          )\n        }\n      }\n    }\n  }\n\n  _createSublayer(baseTexture, renderingStyleIndex, hue) {\n    const subLayer = new HeatmapSubLayer(\n      baseTexture,\n      renderingStyleIndex,\n      hue,\n      this.brushRenderingStyle === BRUSH_RENDERING_STYLE.BULLSEYE\n    )\n    this.stage.addChild(subLayer.stage)\n    return subLayer\n  }\n\n  _destroy() {\n    Object.values(this.subLayers).forEach(this._destroySubLayer.bind(this))\n    this.stage.destroy({ children: true })\n    const { rootStage } = this.props\n    rootStage.removeChild(this.stage)\n  }\n\n  _destroySubLayer(subLayer) {\n    this.stage.removeChild(subLayer.stage)\n    subLayer.destroy()\n  }\n\n  render() {\n    return null\n  }\n}\n\nHeatmapLayer.propTypes = {\n  layer: PropTypes.object,\n  rootStage: PropTypes.object,\n  viewport: PropTypes.object,\n  startIndex: PropTypes.number,\n  endIndex: PropTypes.number,\n  filters: PropTypes.array,\n  baseTexture: PropTypes.object,\n  useRadialGradientStyle: PropTypes.bool,\n  customRenderingStyle: PropTypes.object,\n  viewportLeft: PropTypes.number,\n  viewportRight: PropTypes.number,\n}\n\nexport default HeatmapLayer\n","/* global PIXI */\nimport 'pixi.js'\nimport React from 'react'\nimport PropTypes from 'prop-types'\nimport { worldToPixels } from 'viewport-mercator-project'\nimport { TRACKS_DOTS_STYLE_ZOOM_THRESHOLD } from '../config'\n\nclass TracksLayer extends React.Component {\n  componentDidMount() {\n    this._build()\n  }\n\n  componentDidUpdate() {\n    this._redraw()\n  }\n\n  _build() {\n    const { rootStage } = this.props\n    this.stage = new PIXI.Graphics()\n    this.stage.nativeLines = true\n    rootStage.addChild(this.stage)\n  }\n\n  clear() {\n    this.stage.clear()\n  }\n\n  _redraw() {\n    const { tracks, zoom, startIndex, endIndex, highlightTemporalExtentIndexes } = this.props\n\n    this.clear()\n    if (!tracks.length) {\n      return\n    }\n\n    const overInInner =\n      highlightTemporalExtentIndexes === null\n        ? undefined\n        : [\n            Math.max(startIndex, highlightTemporalExtentIndexes[0]),\n            Math.min(endIndex, highlightTemporalExtentIndexes[1]),\n          ]\n    const overExtent = overInInner && overInInner[1] - overInInner[0] > 0 ? overInInner : undefined\n\n    let n = 0 // eslint-disable-line no-unused-vars\n\n    const drawFishingCircles = zoom > TRACKS_DOTS_STYLE_ZOOM_THRESHOLD\n    const fishingCirclesRadius = 1 + (zoom - TRACKS_DOTS_STYLE_ZOOM_THRESHOLD) * 0.5\n    const drawOverTrack = overExtent !== undefined && overExtent[0] > 0 && overExtent[1] > 0\n\n    tracks.forEach((track) => {\n      n += this._drawTrack({\n        data: track.data,\n        startIndex,\n        endIndex,\n        drawFishingCircles,\n        fishingCirclesRadius,\n        color: `0x${track.color.substr(1)}`,\n        lineThickness: 1,\n        lineOpacity: 1,\n      })\n\n      // Draw the highlight over the track when the user hovers over the Timebar\n      if (drawOverTrack === true) {\n        n += this._drawTrack({\n          data: track.data,\n          startIndex: highlightTemporalExtentIndexes[0],\n          endIndex: highlightTemporalExtentIndexes[1],\n          drawFishingCircles,\n          fishingCirclesRadius,\n          color: '0xFFFFFF',\n          lineThickness: 2,\n          lineOpacity: 1,\n        })\n      }\n    })\n\n    // console.log(n);\n  }\n\n  /**\n   * Draws a single track (line + points)\n   *\n   * @param data track points data in 'playback form' (ie organized by days)\n   * @param extent extent, in day indices\n   * @param offset object containing info about the current situation of the map viewport, used to compute screen coords\n   * @param drawFishingCircles whether to draw fishing circles or not\n   * @param fishingCirclesRadius radius of the fishing circles\n   * @param color\n   * @param lineThickness\n   * @param lineOpacity\n   * @param worldOffset offset to use when a track crosses the dateline (ie 512 to add a second world to the right)\n   */\n  _drawTrack({\n    data,\n    startIndex,\n    endIndex,\n    drawFishingCircles,\n    fishingCirclesRadius,\n    color,\n    lineThickness,\n    lineOpacity,\n    worldOffset = 0,\n  }) {\n    const { viewport } = this.props\n\n    let n = 0\n    let prevSeries\n    let prevWorldX\n    let prevWorldY\n\n    const circlePoints = {\n      x: [],\n      y: [],\n    }\n\n    // line thickness is ignored in native mode anyways.\n    this.stage.lineStyle(lineThickness, color, lineOpacity)\n\n    let duplicateWorld = false\n\n    for (let timeIndex = startIndex; timeIndex < endIndex; timeIndex++) {\n      const frame = data[timeIndex]\n\n      if (!frame) continue\n\n      for (let i = 0, len = frame.series.length; i < len; i++) {\n        const currentSeries = frame.series[i]\n\n        n++\n\n        const worldX = frame.worldX[i] + worldOffset\n        const worldY = frame.worldY[i]\n\n        const [x, y] = worldToPixels(\n          [worldX * viewport.scale, worldY * viewport.scale],\n          viewport.pixelProjectionMatrix\n        )\n\n        if (prevSeries !== currentSeries) {\n          this.stage.moveTo(x, y)\n        }\n\n        // more than a ½ world of distance between two points = crossing the dateline\n        if (prevWorldX && Math.abs(worldX - prevWorldX) > 256) {\n          // worldOffset === 0 -> this is the first time drawTrack is called\n          if (worldOffset === 0) {\n            // set a flag to call drawTrack again at the end of the loop\n            duplicateWorld = true\n          }\n\n          // get Y coordinate where track intersects with dateline\n          const atDatelineWorldY = prevWorldY + (worldY - prevWorldY) / 2\n\n          // whether tracks crosses dateline from west to east\n          const isWestToEast = worldX - prevWorldX < 0\n\n          const worldXEnd = worldOffset + (512 - 0.000001)\n          const worldXStart = worldOffset\n\n          // get X coordinate ending at dateline\n          const atDatelineEndWorldX = isWestToEast ? worldXEnd : worldXStart\n\n          // get X coordinate starting at dateline\n          const atDatelineStartWorldX = isWestToEast ? worldXStart : worldXEnd\n\n          const [x1, y1] = worldToPixels(\n            [atDatelineEndWorldX * viewport.scale, atDatelineWorldY * viewport.scale],\n            viewport.pixelProjectionMatrix\n          )\n          this.stage.lineTo(x1, y1)\n          const [x2, y2] = worldToPixels(\n            [atDatelineStartWorldX * viewport.scale, atDatelineWorldY * viewport.scale],\n            viewport.pixelProjectionMatrix\n          )\n          this.stage.moveTo(x2, y2)\n        }\n\n        this.stage.lineTo(x, y)\n\n        if (drawFishingCircles && frame.hasFishing[i] === true) {\n          circlePoints.x.push(x)\n          circlePoints.y.push(y)\n        }\n\n        prevWorldX = worldX\n        prevWorldY = worldY\n        prevSeries = currentSeries\n      }\n    }\n\n    if (drawFishingCircles) {\n      this.stage.lineStyle(0)\n      this.stage.beginFill(color, 1)\n      for (let i = 0, circlesLength = circlePoints.x.length; i < circlesLength; i++) {\n        this.stage.drawCircle(circlePoints.x[i], circlePoints.y[i], fishingCirclesRadius)\n      }\n      this.stage.endFill()\n    }\n\n    if (duplicateWorld === true) {\n      ;[-512, 512].forEach((offset) => {\n        this._drawTrack({\n          worldOffset: offset,\n          data,\n          startIndex,\n          endIndex,\n          drawFishingCircles,\n          fishingCirclesRadius,\n          color,\n          lineThickness,\n          lineOpacity,\n        })\n      })\n    }\n    return n\n  }\n\n  render() {\n    return null\n  }\n}\n\nTracksLayer.propTypes = {\n  zoom: PropTypes.number,\n  rootStage: PropTypes.object,\n  viewport: PropTypes.object,\n  startIndex: PropTypes.number,\n  endIndex: PropTypes.number,\n  highlightTemporalExtentIndexes: PropTypes.array,\n  tracks: PropTypes.array,\n}\n\nexport default TracksLayer\n","import React, { Fragment } from 'react'\nimport * as PIXI from 'pixi.js'\nimport PropTypes from 'prop-types'\nimport { BaseControl } from 'react-map-gl'\nimport { lngLatToWorld } from 'viewport-mercator-project'\nimport {\n  hsvToRgb,\n  hueToRgbString,\n  hueIncrementToHue,\n  wrapHue,\n  VESSELS_HUES_INCREMENTS_NUM,\n} from '../utils/map-colors'\nimport {\n  VESSELS_BASE_RADIUS,\n  VESSELS_HEATMAP_BLUR_FACTOR,\n  ACTIVITY_HIGHLIGHT_HUE,\n  VESSELS_HEATMAP_DIMMING_ALPHA,\n  VESSELS_RADIAL_GRADIENT_STYLE_ZOOM_THRESHOLD,\n  VESSEL_CLICK_TOLERANCE_PX,\n} from '../config'\nimport HeatmapLayer from '../heatmap/HeatmapLayer'\nimport TracksLayer from '../tracks/TracksLayer'\n\nconst shouldUseRadialGradientStyle = (zoom) => zoom < VESSELS_RADIAL_GRADIENT_STYLE_ZOOM_THRESHOLD\n\n// builds a texture spritesheet containing\n// - the heatmap style (radial gradient)\n// - the circle style that is used at higher zoom levels\n// - the 'bullseye' style used for encounters\n// as well as a number of hues for each in a 2D grid.\n// Then, only the texture frame (mesh UVs) is modified depending on the zoom level,\n// in order not to have to recreate sprites\nconst getVesselTexture = (radius, blurFactor) => {\n  const tplCanvas = document.createElement('canvas')\n  const tplCtx = tplCanvas.getContext('2d')\n  const diameter = radius * 2\n  const NUM_STYLES = 3\n  tplCanvas.width = diameter * NUM_STYLES + (NUM_STYLES - 1) // + (NUM_STYLES - 1): tiny offset between 2 frames\n  tplCanvas.height = diameter * VESSELS_HUES_INCREMENTS_NUM + VESSELS_HUES_INCREMENTS_NUM\n\n  for (let hueIncrement = 0; hueIncrement < VESSELS_HUES_INCREMENTS_NUM; hueIncrement++) {\n    const y = diameter * hueIncrement + hueIncrement\n    const yCenter = y + radius\n\n    // heatmap style\n    let x = radius\n    const gradient = tplCtx.createRadialGradient(\n      x,\n      yCenter,\n      radius * blurFactor,\n      x,\n      yCenter,\n      radius\n    )\n    const hue = hueIncrementToHue(hueIncrement)\n    const rgbString = hueToRgbString(hue)\n    gradient.addColorStop(0, rgbString)\n\n    const rgbOuter = hsvToRgb(wrapHue(hue + 30), 80, 100)\n    gradient.addColorStop(1, `rgba(${rgbOuter.r}, ${rgbOuter.g}, ${rgbOuter.b}, 0)`)\n\n    tplCtx.fillStyle = gradient\n    tplCtx.fillRect(0, y, diameter, diameter)\n\n    // circle style\n    x += diameter + 1 // tiny offset between 2 frames\n    tplCtx.beginPath()\n    tplCtx.arc(x, yCenter, radius, 0, 2 * Math.PI, false)\n    tplCtx.fillStyle = rgbString\n    tplCtx.fill()\n\n    // bullseye style\n    x += diameter + 1\n    tplCtx.beginPath()\n    tplCtx.arc(x, yCenter, radius * 0.4, 0, 2 * Math.PI, false)\n    tplCtx.fillStyle = rgbString\n    tplCtx.fill()\n    tplCtx.beginPath()\n    tplCtx.arc(x, yCenter, radius * 0.95, 0, 2 * Math.PI, false)\n    tplCtx.lineWidth = 1\n    tplCtx.strokeStyle = rgbString\n    tplCtx.stroke()\n  }\n\n  return tplCanvas\n}\n\nclass ActivityLayers extends BaseControl {\n  state = {\n    pixiReady: false,\n  }\n\n  componentDidMount() {\n    this._build()\n    this.setState({\n      pixiReady: true,\n    })\n  }\n\n  componentWillUnmount() {\n    this._destroy()\n  }\n\n  componentWillReceiveProps(nextProps) {\n    this.props.exportNativeViewport(this._context.viewport)\n\n    if (\n      nextProps.viewport.width !== this.props.viewport.width ||\n      nextProps.viewport.height !== this.props.viewport.height\n    ) {\n      this._updateViewportSize(nextProps.viewport.width, nextProps.viewport.height)\n    }\n  }\n\n  _build() {\n    const { width, height } = this.props.viewport\n\n    this.pixi = new PIXI.Application({\n      width,\n      height,\n      transparent: true,\n      antialias: true,\n    })\n\n    this.renderer = this.pixi.renderer\n    this.canvas = this.pixi.view\n    this.canvas.style.position = 'absolute'\n\n    this.container.appendChild(this.canvas)\n\n    this.stage = this.pixi.stage\n\n    const baseTextureCanvas = getVesselTexture(VESSELS_BASE_RADIUS, VESSELS_HEATMAP_BLUR_FACTOR)\n    this.baseTexture = PIXI.Texture.fromCanvas(baseTextureCanvas)\n\n    this.heatmapStage = new PIXI.Container()\n    this.stage.addChild(this.heatmapStage)\n\n    this.pixi.ticker.add(this._onTick)\n  }\n\n  _destroy() {\n    this.pixi.destroy()\n  }\n\n  _updateViewportSize(viewportWidth, viewportHeight) {\n    this.renderer.resize(viewportWidth, viewportHeight)\n  }\n\n  toggleHeatmapDimming(dim) {\n    if (this.heatmapStage === undefined) {\n      return\n    }\n    if (dim === true) {\n      this.heatmapFadingIn = false\n    }\n    this.heatmapStage.alpha = dim === true ? VESSELS_HEATMAP_DIMMING_ALPHA : 1\n  }\n\n  onTouchStart = (event) => {\n    if (!event.touches.length) {\n      return\n    }\n    this.queryCoords(event.touches[0].clientX, event.touches[0].clientY)\n  }\n\n  onMouseMove = (event) => {\n    this.queryCoords(event.clientX, event.clientY)\n  }\n\n  queryCoords(x, y) {\n    // bail if all heatmap layers are set to non-interactive\n    if (this.props.heatmapLayers.every((l) => l.interactive !== true)) {\n      return\n    }\n\n    const { viewport } = this._context\n    const [longitude, latitude] = viewport.unproject([x, y])\n\n    let wrappedLongitude = longitude\n    if (wrappedLongitude > 180) {\n      wrappedLongitude -= 360\n    } else if (wrappedLongitude < -180) {\n      wrappedLongitude += 360\n    }\n\n    const [worldX, worldY] = lngLatToWorld([wrappedLongitude, latitude], 1)\n\n    const toleranceRadiusInWorldUnits = VESSEL_CLICK_TOLERANCE_PX / viewport.scale\n\n    this.props.queryHeatmapVessels(\n      {\n        longitude: wrappedLongitude,\n        latitude,\n        worldX,\n        worldY,\n        toleranceRadiusInWorldUnits,\n      },\n      this.props.temporalExtentIndexes\n    )\n  }\n\n  _onTick = () => {\n    if (this.heatmapFadingIn === true && this.heatmapStage.alpha < 1) {\n      this._heatmapFadeinStep()\n    }\n  }\n\n  _startHeatmapFadein() {\n    this.heatmapFadingIn = true\n    this.heatmapFadeinStartTimestamp = undefined\n  }\n\n  _heatmapFadeinStep() {\n    if (this.heatmapFadeinStartTimestamp === undefined) {\n      this.heatmapFadeinStartTimestamp = Date.now()\n    }\n    const timeElapsed = (Date.now() - this.heatmapFadeinStartTimestamp) / 1000\n    let alpha = this.heatmapStage.alpha + (1 - this.heatmapStage.alpha) * timeElapsed\n    if (alpha >= 1) {\n      alpha = 1\n      this.heatmapFadingIn = false\n    }\n    this.heatmapStage.alpha = alpha\n  }\n\n  // FIXME move to container?\n  _getHighlightData(highlightedVessels, highlightedClickedVessel, heatmapLayers) {\n    const hue = ACTIVITY_HIGHLIGHT_HUE\n    let highlightLayerData = {\n      id: '__HIGHLIGHT__',\n      visible: true,\n      opacity: 1,\n      hue: ACTIVITY_HIGHLIGHT_HUE,\n    }\n    let highlightFilters = []\n\n    if (\n      highlightedVessels !== undefined &&\n      highlightedVessels.layer !== undefined &&\n      highlightedVessels.foundVessels !== undefined &&\n      highlightedVessels.isEmpty !== true\n    ) {\n      const sourceLayer = heatmapLayers.find((l) => l.id === highlightedVessels.layer.id)\n      highlightLayerData = { highlightLayerData, ...sourceLayer }\n      highlightFilters = highlightedVessels.foundVessels.map((vessel) => ({\n        hue,\n        filterValues: {\n          series: [vessel.series],\n        },\n      }))\n    } else if (highlightedClickedVessel !== null) {\n      const sourceLayer = heatmapLayers.find((l) => l.id === highlightedClickedVessel.layer.id)\n      highlightLayerData = { highlightLayerData, ...sourceLayer }\n      highlightFilters = [\n        {\n          hue,\n          filterValues: {\n            series: [highlightedClickedVessel.id],\n          },\n        },\n      ]\n    }\n    return {\n      highlightLayerData,\n      highlightFilters,\n    }\n  }\n  _render() {\n    const {\n      zoom,\n      heatmapLayers,\n      temporalExtentIndexes,\n      highlightTemporalExtentIndexes,\n      highlightedVessels,\n      highlightedClickedVessel,\n      tracks,\n      leftWorldScaled,\n      rightWorldScaled,\n    } = this.props\n    const { viewport } = this._context\n    const { pixiReady } = this.state\n\n    const startIndex = temporalExtentIndexes[0]\n    const endIndex = temporalExtentIndexes[1]\n    const useRadialGradientStyle = shouldUseRadialGradientStyle(zoom)\n\n    if (highlightedVessels.isEmpty !== true) {\n      this.toggleHeatmapDimming(true)\n    }\n    if (highlightedVessels.isEmpty === true && tracks.length === 0) {\n      this._startHeatmapFadein()\n    }\n    if (this.renderer && this.renderer.gl && this.renderer.gl.getError !== undefined) {\n      const err = this.renderer.gl.getError()\n      if (err !== 0) console.log(err)\n    }\n\n    const { highlightLayerData, highlightFilters } = this._getHighlightData(\n      highlightedVessels,\n      highlightedClickedVessel,\n      heatmapLayers\n    )\n\n    return (\n      <div\n        ref={(ref) => {\n          this.container = ref\n        }}\n        style={{ position: 'absolute' }}\n        onMouseMove={this.onMouseMove}\n        onTouchStart={this.onTouchStart}\n      >\n        {pixiReady === true && (\n          <Fragment>\n            {heatmapLayers.map((layer) => (\n              <HeatmapLayer\n                key={layer.id}\n                layer={layer}\n                filters={layer.filters || []}\n                viewport={viewport}\n                startIndex={startIndex}\n                endIndex={endIndex}\n                baseTexture={this.baseTexture}\n                rootStage={this.heatmapStage}\n                useRadialGradientStyle={useRadialGradientStyle}\n                customRenderingStyle={{}}\n                viewportLeft={leftWorldScaled}\n                viewportRight={rightWorldScaled}\n              />\n            ))}\n            {this.stage !== undefined && (\n              <HeatmapLayer\n                key=\"highlighted\"\n                layer={highlightLayerData}\n                filters={highlightFilters}\n                viewport={viewport}\n                startIndex={startIndex}\n                endIndex={endIndex}\n                baseTexture={this.baseTexture}\n                rootStage={this.heatmapStage}\n                useRadialGradientStyle={useRadialGradientStyle}\n                customRenderingStyle={{ defaultOpacity: 1, defaultSize: 1 }}\n                viewportLeft={leftWorldScaled}\n                viewportRight={rightWorldScaled}\n              />\n            )}\n            {this.stage !== undefined && (\n              <TracksLayer\n                tracks={tracks}\n                viewport={viewport}\n                zoom={zoom}\n                startIndex={startIndex}\n                endIndex={endIndex}\n                highlightTemporalExtentIndexes={highlightTemporalExtentIndexes}\n                rootStage={this.stage}\n              />\n            )}\n          </Fragment>\n        )}\n      </div>\n    )\n  }\n}\n\nActivityLayers.propTypes = {\n  zoom: PropTypes.number,\n  heatmapLayers: PropTypes.array,\n  temporalExtentIndexes: PropTypes.array,\n  highlightTemporalExtentIndexes: PropTypes.array,\n  highlightedVessels: PropTypes.object,\n  highlightedClickedVessel: PropTypes.object,\n  tracks: PropTypes.array,\n  queryHeatmapVessels: PropTypes.func,\n  exportNativeViewport: PropTypes.func,\n  leftWorldScaled: PropTypes.number,\n  rightWorldScaled: PropTypes.number,\n}\n\nActivityLayers.contextTypes = {\n  viewport: PropTypes.object,\n}\n\nexport default ActivityLayers\n","import { connect } from 'react-redux'\nimport { createSelector } from 'reselect'\nimport convert from '@globalfishingwatch/map-convert'\nimport { exportNativeViewport } from '../glmap/viewport.actions'\nimport { getTemporalExtent, getHighlightTemporalExtent } from '../module/module.selectors'\nimport ActivityLayers from './ActivityLayers'\nimport { queryHeatmapVessels } from '../heatmap/heatmapTiles.actions'\nimport { MIN_FRAME_LENGTH_MS } from '../config'\n\nconst getHeatmapLayers = (state) => state.map.heatmap.heatmapLayers\n\nconst getHeatmapLayersAsArray = createSelector(\n  [getHeatmapLayers],\n  (heatmapLayers) => {\n    const a = Object.keys(heatmapLayers).map((id) => ({\n      ...heatmapLayers[id],\n    }))\n    // console.log(a)\n    return a\n  }\n)\n\nconst getTracks = (state) => state.map.tracks.data\n\nconst getTracksWithData = createSelector(\n  [getTracks],\n  (tracks) => {\n    const tracksWithData = tracks\n      .filter((t) => t.type !== 'geojson')\n      .filter((t) => t.data !== undefined)\n    return tracksWithData\n  }\n)\n\nconst getTemporalExtentIndexes = createSelector(\n  [getTemporalExtent],\n  (temporalExtent) => {\n    const startTimestamp = temporalExtent[0].getTime()\n    const endTimestamp = Math.max(\n      temporalExtent[1].getTime(),\n      temporalExtent[0].getTime() + MIN_FRAME_LENGTH_MS\n    )\n    const startIndex = convert.getOffsetedTimeAtPrecision(startTimestamp)\n    const endIndex = convert.getOffsetedTimeAtPrecision(endTimestamp)\n    return [startIndex, endIndex]\n  }\n)\n\nconst getHighlightTemporalExtentIndexes = createSelector(\n  [getHighlightTemporalExtent],\n  (highlightTemporalExtent) => {\n    if (\n      highlightTemporalExtent === undefined ||\n      highlightTemporalExtent === null ||\n      !highlightTemporalExtent.length\n    ) {\n      return null\n    }\n    const startTimestamp = highlightTemporalExtent[0].getTime()\n    const endTimestamp = highlightTemporalExtent[1].getTime()\n    const startIndex = convert.getOffsetedTimeAtPrecision(startTimestamp)\n    const endIndex = convert.getOffsetedTimeAtPrecision(endTimestamp)\n    return [startIndex, endIndex]\n  }\n)\n\nconst mapStateToProps = (state) => ({\n  highlightedVessels: state.map.heatmap.highlightedVessels,\n  highlightedClickedVessel: state.map.heatmap.highlightedClickedVessel,\n  viewport: state.map.viewport.viewport,\n  zoom: state.map.viewport.viewport.zoom,\n  heatmapLayers: getHeatmapLayersAsArray(state),\n  tracks: getTracksWithData(state),\n  leftWorldScaled: state.map.viewport.leftWorldScaled,\n  rightWorldScaled: state.map.viewport.rightWorldScaled,\n  temporalExtentIndexes: getTemporalExtentIndexes(state),\n  highlightTemporalExtentIndexes: getHighlightTemporalExtentIndexes(state),\n})\n\nconst mapDispatchToProps = (dispatch, ownProps) => ({\n  queryHeatmapVessels: (coords, temporalExtentIndexes) => {\n    dispatch(queryHeatmapVessels(coords, temporalExtentIndexes))\n  },\n  exportNativeViewport: (viewport) => {\n    dispatch(exportNativeViewport(viewport))\n  },\n})\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(ActivityLayers)\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport MapGL, { Popup, Marker } from 'react-map-gl'\nimport 'mapbox-gl/dist/mapbox-gl.css'\nimport { TILES_URL_NEEDING_AUTHENTICATION } from '../config'\nimport ActivityLayers from '../activity/ActivityLayers.container.js'\nimport styles from './map.css'\nimport ResizeObserver from 'resize-observer-polyfill'\n\nconst PopupWrapper = (props) => {\n  const { latitude, longitude, children, closeButton, onClose } = props\n  return (\n    <Popup\n      latitude={latitude}\n      longitude={longitude}\n      closeButton={closeButton}\n      onClose={onClose}\n      anchor=\"bottom\"\n      offsetTop={-10}\n      tipSize={4}\n      closeOnClick={false}\n    >\n      {children}\n    </Popup>\n  )\n}\n\nPopupWrapper.propTypes = {\n  latitude: PropTypes.number.isRequired,\n  longitude: PropTypes.number.isRequired,\n  children: PropTypes.node.isRequired,\n  closeButton: PropTypes.bool.isRequired,\n  onClose: PropTypes.func,\n}\n\nPopupWrapper.defaultProps = {\n  onClose: () => {},\n}\n\nclass Map extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      mouseOver: true,\n    }\n    this._mapContainerRef = null\n    this._containerResizeObserver = new ResizeObserver(this._containerResize)\n  }\n\n  _containerResize = (entries) => {\n    const { width, height } = entries[0].contentRect\n    const { viewport, setViewport } = this.props\n\n    if (width !== viewport.width || height !== viewport.height) {\n      setViewport({\n        ...viewport,\n        width,\n        height,\n      })\n    }\n  }\n\n  componentWillUnmount() {\n    this._containerResizeObserver.disconnect()\n  }\n\n  onViewportChange = (viewport, interactionState) => {\n    this.props.setViewport(viewport, interactionState)\n  }\n\n  onMapInteraction = (event, type) => {\n    this.props.mapInteraction(\n      type,\n      event.lngLat[1],\n      event.lngLat[0],\n      event.features,\n      this.glGetSource\n    )\n  }\n\n  onHover = (event) => {\n    this.onMapInteraction(event, 'hover')\n  }\n\n  onClick = (event) => {\n    this.onMapInteraction(event, 'click')\n  }\n\n  getRef = (ref) => {\n    if (ref !== null) {\n      this.glMap = ref.getMap()\n      this.glGetSource = this.glMap.getSource.bind(this.glMap)\n    }\n  }\n\n  getCursor = ({ isDragging }) => {\n    const { cursor } = this.props\n    if (cursor === null) {\n      return isDragging ? 'grabbing' : 'grab'\n    }\n    return cursor\n  }\n\n  transformRequest = (url, resourceType) => {\n    const { token } = this.props\n    if (token !== null && resourceType === 'Tile' && url.match(TILES_URL_NEEDING_AUTHENTICATION)) {\n      return {\n        url: url,\n        headers: { Authorization: 'Bearer ' + token },\n      }\n    }\n  }\n\n  render() {\n    const {\n      viewport,\n      maxZoom,\n      minZoom,\n      transitionEnd,\n      mapStyle,\n      onClosePopup,\n      clickPopup,\n      hoverPopup,\n      hasHeatmapLayers,\n      markers,\n      interactiveLayerIds,\n    } = this.props\n\n    return (\n      <div\n        id=\"map\"\n        className={styles.map}\n        ref={(ref) => {\n          this._mapContainerRef = ref\n          if (this._mapContainerRef !== null) {\n            this._containerResizeObserver.observe(this._mapContainerRef)\n          }\n        }}\n        onMouseLeave={() => {\n          this.setState({ mouseOver: false })\n        }}\n        onMouseEnter={() => {\n          this.setState({ mouseOver: true })\n        }}\n      >\n        <MapGL\n          {...viewport}\n          ref={this.getRef}\n          transformRequest={this.transformRequest}\n          onTransitionEnd={transitionEnd}\n          onHover={this.onHover}\n          onClick={this.onClick}\n          getCursor={this.getCursor}\n          mapStyle={mapStyle}\n          maxZoom={maxZoom}\n          minZoom={minZoom}\n          onViewportChange={this.onViewportChange}\n          interactiveLayerIds={interactiveLayerIds}\n          clickRadius={4}\n        >\n          {hasHeatmapLayers !== false && <ActivityLayers />}\n          {clickPopup !== undefined && clickPopup !== null && (\n            <PopupWrapper\n              latitude={clickPopup.latitude}\n              longitude={clickPopup.longitude}\n              closeButton\n              onClose={onClosePopup}\n            >\n              {clickPopup.content}\n            </PopupWrapper>\n          )}\n          {this.state.mouseOver === true && hoverPopup !== undefined && hoverPopup !== null && (\n            <PopupWrapper\n              latitude={hoverPopup.latitude}\n              longitude={hoverPopup.longitude}\n              closeButton={false}\n            >\n              {hoverPopup.content}\n            </PopupWrapper>\n          )}\n          {markers !== null &&\n            markers.length > 0 &&\n            markers.map((marker, i) => (\n              <Marker key={i} latitude={marker.latitude} longitude={marker.longitude}>\n                {marker.content}\n              </Marker>\n            ))}\n        </MapGL>\n        <div className={styles.googleLogo} />\n      </div>\n    )\n  }\n}\n\nMap.propTypes = {\n  token: PropTypes.string,\n  viewport: PropTypes.object.isRequired,\n  mapStyle: PropTypes.object.isRequired,\n  clickPopup: PropTypes.object,\n  hoverPopup: PropTypes.object,\n  maxZoom: PropTypes.number.isRequired,\n  minZoom: PropTypes.number.isRequired,\n  setViewport: PropTypes.func.isRequired,\n  mapInteraction: PropTypes.func,\n  onClosePopup: PropTypes.func,\n  transitionEnd: PropTypes.func,\n  cursor: PropTypes.string,\n  hasHeatmapLayers: PropTypes.bool.isRequired,\n  markers: PropTypes.arrayOf(\n    PropTypes.shape({\n      latitude: PropTypes.number.isRequired,\n      longitude: PropTypes.number.isRequired,\n      content: PropTypes.node,\n    })\n  ),\n  interactiveLayerIds: PropTypes.arrayOf(PropTypes.string),\n}\n\nMap.defaultProps = {\n  token: null,\n  clickPopup: null,\n  hoverPopup: null,\n  mapInteraction: () => {},\n  onClosePopup: () => {},\n  transitionEnd: () => {},\n  cursor: null,\n  markers: null,\n  interactiveLayerIds: null,\n}\n\nexport default Map\n","import { connect } from 'react-redux'\nimport { createSelector } from 'reselect'\nimport { fromJS } from 'immutable'\nimport { TRACKS_LAYER_IN_FRONT_OF_GROUP } from '../config'\nimport { closePopup } from '../module/module.actions.js'\nimport { getTracksStyles } from '../tracks/tracks.selectors.js'\nimport { mapInteraction } from './interaction.actions.js'\nimport { setViewport, transitionEnd } from './viewport.actions.js'\nimport Map from './Map'\n\nconst getStaticLayers = (state) => state.map.style.staticLayers\nconst getHeatmapLayers = (state) => state.map.heatmap.heatmapLayers\nconst getInternalCursor = (state) => state.map.interaction.cursor\nconst getModuleCursor = (state) => state.map.module.cursor\n\nconst hasHeatmapLayers = createSelector(\n  [getHeatmapLayers],\n  (heatmapLayers) => {\n    return Object.keys(heatmapLayers).length > 0\n  }\n)\nconst getInteractiveLayerIds = createSelector(\n  [getStaticLayers],\n  // Note: here we assume that layer IDs provided with module match the GL layers that should\n  // be interactive or not, ie typically the fill layer if a label layer is present\n  (staticLayers) => {\n    return staticLayers.reduce((acc, layer) => {\n      if (!layer.interactive || !layer.visible) return acc\n      // We also need to check nested layers interactivity when custom gl layers are provided\n      if (layer.gl !== undefined) {\n        layer.gl.layers.forEach((glLayer, index) => {\n          // layers.length === 1 is used to ensure when parent layer is marked as interactive we have to\n          // have at least one interactive sublayer, then checked eah one individually\n          if (\n            layer.gl.layers.length === 1 ||\n            (glLayer.metadata !== undefined && glLayer.metadata['gfw:interactive'] === true)\n          ) {\n            const glLayerId = glLayer.id || index > 0 ? `${layer.id}-${index}` : layer.id\n            acc.push(glLayerId)\n          }\n        })\n      } else {\n        acc.push(layer.id)\n      }\n      return acc\n    }, [])\n  }\n)\n\nconst getMapStyles = (state) => state.map.style.mapStyle\nconst getMapStyle = createSelector(\n  [getMapStyles, getTracksStyles],\n  (mapStyles, trackStyles) => {\n    if (!trackStyles) return mapStyles\n\n    const currentLayerGroups = mapStyles\n      .toJS()\n      .layers.filter((l) => l.metadata !== undefined)\n      .map((l) => l.metadata['mapbox:group'])\n    const trackLayersIndex = currentLayerGroups.lastIndexOf(TRACKS_LAYER_IN_FRONT_OF_GROUP) + 1\n\n    let finalMapStyles = mapStyles.mergeIn(['sources'], trackStyles.sources)\n    let mapStylesLayers = mapStyles.get('layers')\n    trackStyles.layers.forEach((trackLayer, i) => {\n      mapStylesLayers = mapStylesLayers.insert(trackLayersIndex + i, fromJS(trackLayer))\n    })\n    finalMapStyles = finalMapStyles.set('layers', mapStylesLayers)\n    return finalMapStyles\n  }\n)\n\nconst getCursor = createSelector(\n  [getInternalCursor, getModuleCursor],\n  (internalCursor, moduleCursor) => {\n    if (moduleCursor !== null) {\n      return moduleCursor\n    }\n    return internalCursor\n  }\n)\nconst mapStateToProps = (state, ownProps) => ({\n  viewport: state.map.viewport.viewport,\n  maxZoom: state.map.viewport.maxZoom,\n  minZoom: state.map.viewport.minZoom,\n  cursor: getCursor(state),\n  token: state.map.module.token,\n  mapStyle: getMapStyle(state),\n  hasHeatmapLayers: hasHeatmapLayers(state),\n  interactiveLayerIds: getInteractiveLayerIds(state),\n})\n\nconst mapDispatchToProps = (dispatch) => ({\n  setViewport: (viewport, interactionState) => {\n    dispatch(setViewport(viewport, interactionState))\n  },\n  mapInteraction: (type, lat, long, features, cluster, glGetSource) => {\n    dispatch(mapInteraction(type, lat, long, features, cluster, glGetSource))\n  },\n  transitionEnd: () => {\n    dispatch(transitionEnd())\n  },\n  onClosePopup: () => {\n    dispatch(closePopup())\n  },\n})\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(Map)\n","import { fromJS } from 'immutable'\nimport uniq from 'lodash/uniq'\nimport GL_STYLE from './gl-styles/style.json'\nimport {\n  SET_MAP_STYLE,\n  MARK_CARTO_LAYERS_AS_INSTANCIATED,\n  INIT_MAP_STYLE,\n  SET_STATIC_LAYERS,\n  SET_BASEMAP_LAYERS,\n} from './style.actions'\n\nconst attributions = uniq(\n  Object.keys(GL_STYLE.sources)\n    .map((sourceKey) => GL_STYLE.sources[sourceKey].attribution)\n    .filter((source) => source !== undefined)\n)\n\nexport const setLayerStyleDefaults = (layer) => {\n  if (layer.layout === undefined) {\n    layer.layout = {}\n  }\n  if (layer.paint === undefined) {\n    layer.paint = {}\n  }\n  if (layer.metadata === undefined) {\n    layer.metadata = {}\n  }\n  // initialize time filter for time-filterable layers\n  if (layer.metadata['gfw:temporal'] === true) {\n    const temporalField =\n      layer.metadata['gfw:temporalField'] === undefined\n        ? 'timestamp'\n        : layer.metadata['gfw:temporalField']\n    layer.filter = ['all', ['>', temporalField, 0], ['<', temporalField, 999999999999]]\n  }\n\n  if (layer.metadata['mapbox:group'] === undefined) {\n    layer.metadata['mapbox:group'] = 'temporal'\n  }\n\n  // set all layers to not visible except layers explicitely marked as visible (default basemap)\n  if (layer.layout.visibility !== 'visible') {\n    layer.layout.visibility = 'none'\n  }\n  return layer\n}\n\nconst setStyleDefaults = (style) => {\n  style.layers.forEach((layer) => {\n    setLayerStyleDefaults(layer)\n  })\n  return style\n}\n\nconst initialState = {\n  mapStyle: fromJS(setStyleDefaults(GL_STYLE)),\n  cartoLayersInstanciated: [],\n  staticLayers: [],\n  basemapLayers: [],\n  attributions,\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case INIT_MAP_STYLE: {\n      const newMapStyle = state.mapStyle.setIn(['glyphs'], action.payload.glyphsPath)\n      return { ...state, mapStyle: newMapStyle }\n    }\n    case SET_MAP_STYLE: {\n      return { ...state, mapStyle: action.payload }\n    }\n    case SET_STATIC_LAYERS: {\n      return { ...state, staticLayers: action.payload }\n    }\n    case SET_BASEMAP_LAYERS: {\n      return { ...state, basemapLayers: action.payload }\n    }\n    case MARK_CARTO_LAYERS_AS_INSTANCIATED: {\n      const cartoLayersInstanciated = [...state.cartoLayersInstanciated, ...action.payload]\n      return { ...state, cartoLayersInstanciated }\n    }\n    default:\n      return state\n  }\n}\n","// This utility looks at GeoJSON features and returns the predominant geometry type\n\nconst TYPES = [\n  { gl: 'line', geoJSON: ['LineString', 'MultiLineString'] },\n  { gl: 'fill', geoJSON: ['Polygon', 'MultiPolygon'] },\n  { gl: 'circle', geoJSON: ['Point', 'MultiPoint'] },\n]\n\nexport default (geoJSON) => {\n  // collect all geoJSON geom types\n  const allGeoJSONTypes = geoJSON.features.map((feature) => {\n    const geom = feature.geometry\n    if (geom === undefined) {\n      return null\n    }\n    return geom.type\n  })\n\n  // collect number of geometries by GL geom types\n  const numByGLType = TYPES.map((type) => {\n    let num = 0\n    allGeoJSONTypes.forEach((geoJSONType) => {\n      if (type.geoJSON.indexOf(geoJSONType) > -1) {\n        num++\n      }\n    })\n    return { gl: type.gl, num }\n  })\n\n  // get feature types with the higher count\n  let glType = 'fill'\n  let glTypeMax = 0\n  numByGLType.forEach((t) => {\n    if (t.num > glTypeMax) {\n      glType = t.gl\n      glTypeMax = t.num\n    }\n  })\n\n  return glType\n}\n","import { fromJS } from 'immutable'\nimport convert from '@globalfishingwatch/map-convert'\nimport uniq from 'lodash/uniq'\nimport throttle from 'lodash/throttle'\nimport { hexToRgb } from '../utils/map-colors'\nimport { STATIC_LAYERS_CARTO_ENDPOINT, STATIC_LAYERS_CARTO_TILES_ENDPOINT } from '../config'\nimport { CUSTOM_LAYERS_SUBTYPES, GL_TRANSPARENT } from '../constants'\nimport GL_STYLE from './gl-styles/style.json'\nimport { setLayerStyleDefaults } from './style.reducer.js'\nimport getMainGeomType from '../utils/getMainGeomType'\n\nexport const INIT_MAP_STYLE = 'INIT_MAP_STYLE'\nexport const SET_MAP_STYLE = 'SET_MAP_STYLE'\nexport const MARK_CARTO_LAYERS_AS_INSTANCIATED = 'MARK_CARTO_LAYERS_AS_INSTANCIATED'\nexport const SET_STATIC_LAYERS = 'SET_STATIC_LAYERS'\nexport const SET_BASEMAP_LAYERS = 'SET_BASEMAP_LAYERS'\n\nconst setDefaultVectorTiles = (currentSource, refLayerUrl) => {\n  if (currentSource.type !== 'vector') {\n    return currentSource\n  }\n  const tiles = currentSource.tiles\n  const refLayerUrls = refLayerUrl === undefined ? [] : [refLayerUrl]\n\n  const newTiles =\n    tiles !== undefined && tiles.length > 0 ? uniq([...refLayerUrl, ...tiles]) : refLayerUrls\n  return {\n    ...currentSource,\n    tiles: newTiles,\n  }\n}\n\nexport const initStyle = ({ glyphsPath }) => ({\n  type: INIT_MAP_STYLE,\n  payload: {\n    glyphsPath,\n  },\n})\n\nconst setMapStyle = (style) => ({\n  type: SET_MAP_STYLE,\n  payload: style,\n})\n\nconst setStyleTemporalExtent = (dispatch, getState, temporalExtent, applyToThrottled = false) => {\n  const state = getState().map.style\n  let style = state.mapStyle\n  const currentStyle = style.toJS()\n  const glLayers = currentStyle.layers\n\n  let start = Math.round(temporalExtent[0].getTime() / 1000)\n  let end = Math.round(temporalExtent[1].getTime() / 1000)\n\n  // TEMPORARY, remove later - temporal layers points should have a timestamp, this is legacy\n  // logic for legacy encounters layer that only have a 'timeIndex'\n  const startIndex = convert.getOffsetedTimeAtPrecision(temporalExtent[0].getTime())\n  const endIndex = convert.getOffsetedTimeAtPrecision(temporalExtent[1].getTime())\n\n  for (let i = 0; i < glLayers.length; i++) {\n    const glLayer = glLayers[i]\n    if (glLayer.metadata === undefined || glLayer.metadata['gfw:temporal'] !== true) {\n      continue\n    }\n\n    if (\n      (applyToThrottled === true && glLayer.metadata['gfw:temporal:throttled'] !== true) ||\n      (applyToThrottled === false && glLayer.metadata['gfw:temporal:throttled'] === true)\n    ) {\n      continue\n    }\n\n    // if layer is temporal, a filter must always be preset on the style.json object\n    // because each layer can have a different time field to be filtered\n    const currentFilter = style.getIn(['layers', i, 'filter']).toJS()\n    if (currentFilter === null) {\n      throw new Error('filter must be preset on style.json for temporal layer: ', glLayer.id)\n    }\n\n    // TEMPORARY, remove later - temporal layers points should have a timestamp, this is legacy\n    // logic for legacy encounters layer that only have a 'timeIndex'\n    const isLegacy = glLayer.metadata && glLayer.metadata['gfw:temporalField'] === 'timeIndex'\n    currentFilter[1][2] = isLegacy ? startIndex : start\n    currentFilter[2][2] = isLegacy ? endIndex : end\n    style = style.setIn(['layers', i, 'filter'], fromJS(currentFilter))\n  }\n  dispatch(setMapStyle(style))\n}\n\nconst applyTemporalExtentThrottled = throttle((dispatch, getState, temporalExtent) => {\n  setStyleTemporalExtent(dispatch, getState, temporalExtent, true)\n}, 400)\n\nexport const applyTemporalExtent = (temporalExtent) => (dispatch, getState) => {\n  setStyleTemporalExtent(dispatch, getState, temporalExtent)\n  applyTemporalExtentThrottled(dispatch, getState, temporalExtent)\n}\n\nconst applyLayerExpressions = (style, refLayer, currentGlLayer, glLayerIndex) => {\n  let newStyle = style\n  const currentStyle = style.toJS()\n  const glType = currentGlLayer.type\n  const defaultStyles = currentStyle.metadata['gfw:styles']\n  const metadata = currentGlLayer.metadata\n  ;['selected', 'highlighted'].forEach((styleType) => {\n    // get selectedFeatures or highlightedFeatures\n    const features = refLayer[`${styleType}Features`]\n    const refLayerStyle = features && features.style ? features.style[glType] : {}\n    const hasFeatures = features !== null && features !== undefined && features.values.length > 0\n    const applyStyleToAllFeatures = refLayer[styleType]\n\n    const defaultStyle = defaultStyles[styleType][glType] || {}\n    const layerStyle =\n      (metadata && metadata['gfw:styles'] && metadata['gfw:styles'][styleType]) || {}\n    const allPaintProperties = { ...defaultStyle, ...layerStyle, ...refLayerStyle }\n\n    if (Object.keys(allPaintProperties).length) {\n      // go through each applicable gl paint property\n      Object.keys(allPaintProperties).forEach((glPaintProperty) => {\n        const selectedValue = allPaintProperties[glPaintProperty][0]\n        const fallbackValue = allPaintProperties[glPaintProperty][1]\n        const paintOrLayout = ['icon-size', 'icon-image'].includes(glPaintProperty)\n          ? 'layout'\n          : 'paint'\n        let glPaintFinalValue\n        if (\n          hasFeatures === false &&\n          applyStyleToAllFeatures !== true &&\n          applyStyleToAllFeatures !== false\n        ) {\n          // style reset when no features filter is declared and neither is applyAll\n          const originalLayerStyle = GL_STYLE.layers.find((l) => l.id === currentGlLayer.id)\n\n          if (originalLayerStyle !== undefined) {\n            // for reset: do not repaint with default style when layer as a custom main color property\n            if (\n              currentGlLayer.metadata &&\n              currentGlLayer.metadata['gfw:mainColorPaintProperty'] === glPaintProperty\n            ) {\n              glPaintFinalValue = null\n            } else {\n              glPaintFinalValue = originalLayerStyle[paintOrLayout][glPaintProperty]\n            }\n          } else {\n            // this will happen when no style exist in the original definition (ie custom layers)\n            // in this case set glPaintFinalValue to null and we'll just skip applying\n            // any selected/highlighted style for this layer\n            glPaintFinalValue = null\n          }\n        } else if (applyStyleToAllFeatures === true || applyStyleToAllFeatures === false) {\n          glPaintFinalValue = applyStyleToAllFeatures === true ? selectedValue : fallbackValue\n        } else {\n          let layerColorRgbString = ''\n          if (refLayer.color !== null && refLayer.color !== undefined) {\n            const layerColorRgb = hexToRgb(refLayer.color)\n            layerColorRgbString = `${layerColorRgb.r},${layerColorRgb.g},${layerColorRgb.b}`\n          }\n          glPaintFinalValue = [\n            'match',\n            ['get', features.field],\n            features.values,\n            typeof selectedValue !== 'string'\n              ? selectedValue\n              : selectedValue.replace('$REFLAYER_COLOR_RGB', layerColorRgbString),\n            typeof fallbackValue !== 'string'\n              ? fallbackValue\n              : fallbackValue.replace('$REFLAYER_COLOR_RGB', layerColorRgbString),\n          ]\n        }\n\n        if (glPaintFinalValue !== undefined && glPaintFinalValue !== null) {\n          newStyle = newStyle.setIn(\n            ['layers', glLayerIndex, paintOrLayout, glPaintProperty],\n            glPaintFinalValue\n          )\n        }\n      })\n    }\n  })\n  return newStyle\n}\n\nconst toggleLayerVisibility = (style, refLayer, glLayerIndex) => {\n  const visibility = refLayer.visible === true ? 'visible' : 'none'\n  return style.setIn(['layers', glLayerIndex, 'layout', 'visibility'], visibility)\n}\n\nconst updateGLLayer = (style, glLayerId, refLayer) => {\n  const currentStyle = style.toJS()\n  const currentStyleLayers = currentStyle.layers\n  let newStyle = style\n\n  const glLayerIndex = currentStyleLayers.findIndex((l) => l.id === glLayerId)\n  const glLayer = currentStyleLayers.find((l) => l.id === glLayerId)\n\n  // visibility\n  newStyle = toggleLayerVisibility(newStyle, refLayer, glLayerIndex)\n\n  if (refLayer.isBasemap === true) {\n    return newStyle\n  }\n\n  const refLayerOpacity = refLayer.opacity === undefined ? 1 : refLayer.opacity\n\n  // color/opacity\n  switch (glLayer.type) {\n    case 'fill': {\n      newStyle = newStyle\n        .setIn(['layers', glLayerIndex, 'paint', 'fill-opacity'], refLayerOpacity)\n        .setIn(['layers', glLayerIndex, 'paint', 'fill-outline-color'], refLayer.color)\n        .setIn(['layers', glLayerIndex, 'paint', 'fill-color'], GL_TRANSPARENT)\n      break\n    }\n    case 'line': {\n      const color = refLayer.color || (glLayer.paint && glLayer.paint['line-color'])\n      newStyle = newStyle\n        .setIn(['layers', glLayerIndex, 'paint', 'line-opacity'], refLayerOpacity)\n        .setIn(['layers', glLayerIndex, 'paint', 'line-color'], color)\n      break\n    }\n    case 'symbol': {\n      if (glLayer.metadata && glLayer.metadata['gfw:isLabel'] === true) {\n        const parentLayerIsVisible =\n          newStyle.getIn(['layers', glLayerIndex, 'layout', 'visibility']) === 'visible'\n        const labelsVisibility =\n          parentLayerIsVisible && refLayer.showLabels === true ? 'visible' : 'none'\n        newStyle = newStyle.setIn(\n          ['layers', glLayerIndex, 'layout', 'visibility'],\n          labelsVisibility\n        )\n        if (refLayer.showLabels !== true) {\n          break\n        }\n      }\n      newStyle = newStyle.setIn(['layers', glLayerIndex, 'paint', 'text-opacity'], refLayerOpacity)\n\n      if (refLayer.color !== undefined) {\n        newStyle = newStyle.setIn(['layers', glLayerIndex, 'paint', 'text-color'], refLayer.color)\n      }\n      break\n    }\n    // Event layers and custom layers with point geom types\n    case 'circle': {\n      newStyle = newStyle\n        .setIn(['layers', glLayerIndex, 'paint', 'circle-opacity'], refLayerOpacity)\n        .setIn(['layers', glLayerIndex, 'paint', 'circle-stroke-opacity'], refLayerOpacity)\n\n      if (refLayer.color !== undefined) {\n        const colorPaintProperty = glLayer.metadata['gfw:mainColorPaintProperty'] || 'circle-color'\n        newStyle = newStyle.setIn(\n          ['layers', glLayerIndex, 'paint', colorPaintProperty],\n          refLayer.color\n        )\n      }\n      break\n    }\n    case 'raster': {\n      newStyle = newStyle.setIn(\n        ['layers', glLayerIndex, 'paint', 'raster-opacity'],\n        refLayerOpacity\n      )\n      break\n    }\n    default: {\n      break\n    }\n  }\n\n  newStyle = applyLayerExpressions(newStyle, refLayer, glLayer, glLayerIndex)\n\n  return newStyle\n}\n\nconst addCustomGLLayer = (subtype, layerId, url, data) => (dispatch, getState) => {\n  const state = getState()\n  let style = state.map.style.mapStyle\n  const currentStyle = style.toJS()\n\n  // add source if it doesn't exist yet\n  if (currentStyle.sources[layerId] === undefined) {\n    const source = { type: subtype }\n    if (subtype === CUSTOM_LAYERS_SUBTYPES.geojson) {\n      source.data = data\n    } else if (subtype === CUSTOM_LAYERS_SUBTYPES.raster) {\n      source.tiles = [url]\n      source.tileSize = 256\n    }\n    style = style.setIn(['sources', layerId], fromJS(source))\n  }\n\n  if (currentStyle.layers.find((glLayer) => glLayer.id === layerId) === undefined) {\n    const glType = subtype === CUSTOM_LAYERS_SUBTYPES.geojson ? getMainGeomType(data) : subtype\n    const glLayer = fromJS({\n      id: layerId,\n      source: layerId,\n      type: glType,\n      layout: {},\n      paint: {},\n    })\n    const layerIndex =\n      subtype === CUSTOM_LAYERS_SUBTYPES.raster\n        ? // if raster, put at index of last raster layer except labels\n          currentStyle.layers.length -\n          1 -\n          currentStyle.layers\n            .filter((l) => l.id !== 'labels')\n            .reverse()\n            .findIndex((l) => l.type === 'raster')\n        : currentStyle.layers.length - 1\n    style = style.set('layers', style.get('layers').splice(layerIndex, 0, glLayer))\n  }\n\n  dispatch(setMapStyle(style))\n}\n\nconst updateWorkspaceGLLayers = (workspaceGLLayers) => (dispatch, getState) => {\n  const state = getState()\n  let style = state.map.style.mapStyle\n\n  workspaceGLLayers.forEach((workspaceGLLayer) => {\n    const { id, gl } = workspaceGLLayer\n    const finalSource = setDefaultVectorTiles(gl.source, workspaceGLLayer.url)\n    style = style.setIn(['sources', id], fromJS(finalSource))\n\n    const existingLayerIds = style\n      .get('layers')\n      .toJS()\n      .map((l) => l.id)\n    const layersToAdd = gl.layers.filter((layer, index) => {\n      const layerId = layer.id || index > 0 ? `${id}-${index}` : id\n      return !existingLayerIds.includes(layerId)\n    })\n    layersToAdd.forEach((layerToAdd, index) => {\n      // doesn't add a sufix in the first elements but it will for the following ones\n      let layerToAddId = layerToAdd.id || index > 0 ? `${id}-${index}` : id\n      const defaultGlLayer = setLayerStyleDefaults(layerToAdd)\n\n      const glLayer = {\n        ...defaultGlLayer,\n        id: layerToAddId,\n        source: id,\n      }\n\n      // set source-layer - defaults to source id\n      if (gl.source.type === 'vector') {\n        const sourceLayer =\n          layerToAdd['source-layer'] === undefined ? id : layerToAdd['source-layer']\n        glLayer['source-layer'] = sourceLayer\n      }\n\n      // find correct z-index\n      const existingLayers = style.get('layers')\n      const newLayerGroup = glLayer.metadata['mapbox:group']\n      const newLayerIndex = existingLayers.findLastIndex((l) => {\n        return newLayerGroup === l.toJS().metadata['mapbox:group']\n      })\n      style = style.set('layers', existingLayers.splice(newLayerIndex, 0, fromJS(glLayer)))\n    })\n  })\n\n  dispatch(setMapStyle(style))\n  dispatch(applyTemporalExtent(state.map.module.temporalExtent))\n}\n\nconst getCartoLayerInstanciatePromise = ({ sourceId, sourceCartoSQL }) => {\n  const mapConfig = { layers: [{ id: sourceId, options: { sql: sourceCartoSQL } }] }\n  const mapConfigURL = encodeURIComponent(JSON.stringify(mapConfig))\n  const cartoAnonymousMapUrl = STATIC_LAYERS_CARTO_ENDPOINT.replace('$MAPCONFIG', mapConfigURL)\n\n  return new Promise((resolve) => {\n    fetch(cartoAnonymousMapUrl)\n      .then((res) => {\n        if (res.status >= 400) {\n          console.warn(`loading of layer failed ${sourceId}`)\n          Promise.reject()\n          return null\n        }\n        return res.json()\n      })\n      .then((data) => {\n        resolve({\n          layergroupid: data.layergroupid,\n          sourceId,\n        })\n      })\n      .catch((err) => {\n        console.warn(err)\n      })\n  })\n}\n\nconst instanciateCartoLayers = (layers) => (dispatch, getState) => {\n  dispatch({\n    type: MARK_CARTO_LAYERS_AS_INSTANCIATED,\n    payload: layers.map((layer) => layer.sourceId),\n  })\n  const cartoLayersPromises = layers.map((layer) => getCartoLayerInstanciatePromise(layer))\n  const cartoLayersPromisesPromise = Promise.all(cartoLayersPromises.map((p) => p.catch((e) => e)))\n  cartoLayersPromisesPromise\n    .then((instanciatedCartoLayers) => {\n      let style = getState().map.style.mapStyle\n      const currentStyle = style.toJS()\n      instanciatedCartoLayers.forEach((cartoLayer) => {\n        const tilesURL = STATIC_LAYERS_CARTO_TILES_ENDPOINT.replace(\n          '$LAYERGROUPID',\n          cartoLayer.layergroupid\n        )\n\n        // replace gl source with a new source that use tiles provided by Carto anonymous maps API\n        const newSourceId = `${cartoLayer.sourceId}-instanciated`\n        style = style.setIn(\n          ['sources', newSourceId],\n          fromJS({\n            type: 'vector',\n            tiles: [tilesURL],\n          })\n        )\n\n        style = style.deleteIn(['sources', cartoLayer.sourceId])\n\n        // change source in all layers that are using it (generally polygon + labels)\n        currentStyle.layers.forEach((glLayer, glLayerIndex) => {\n          if (glLayer.source === cartoLayer.sourceId) {\n            style = style.setIn(['layers', glLayerIndex, 'source'], newSourceId)\n            style = style.setIn(['layers', glLayerIndex, 'metadata', 'gfw:id'], cartoLayer.sourceId)\n            const refLayer = layers.find((l) => l.refLayer.id === cartoLayer.sourceId).refLayer\n            style = updateGLLayer(style, glLayer.id, refLayer)\n          }\n        })\n      })\n\n      dispatch(setMapStyle(style))\n    })\n    .catch((err) => {\n      console.warn(err)\n    })\n}\n\nexport const commitStyleUpdates = (staticLayers, basemapLayers) => (dispatch, getState) => {\n  // Store a copy of static and basemap layers. This is not used directly by\n  // the Map component which only needs a prepared style object\n  dispatch({\n    type: SET_STATIC_LAYERS,\n    payload: staticLayers,\n  })\n  dispatch({\n    type: SET_BASEMAP_LAYERS,\n    payload: basemapLayers,\n  })\n\n  const layers = [...staticLayers, ...basemapLayers.map((bl) => ({ ...bl, isBasemap: true }))]\n\n  const currentGLSources = getState().map.style.mapStyle.toJS().sources\n\n  // collect layers declared in workspace but not in original gl style\n  const workspaceGLLayers = layers.filter((layer) => layer.gl !== undefined)\n\n  if (workspaceGLLayers.length) {\n    // Adds the gl layers again in case the source is a dynamic geojson source\n    dispatch(updateWorkspaceGLLayers(workspaceGLLayers))\n  }\n\n  // instanciate custom layers if needed\n  const customLayers = layers.filter(\n    (layer) => layer.isCustom === true && currentGLSources[layer.id] === undefined\n  )\n  if (customLayers.length) {\n    customLayers.forEach((layer) => {\n      dispatch(addCustomGLLayer(layer.subtype, layer.id, layer.url, layer.data))\n    })\n  }\n\n  const state = getState().map.style\n  let style = state.mapStyle\n  const currentStyle = style.toJS()\n  const glLayers = currentStyle.layers\n  const glSources = currentStyle.sources\n\n  const cartoLayersToInstanciate = []\n\n  // update source when needed\n  staticLayers.forEach((refLayer) => {\n    const sourceId = refLayer.id\n    if (currentGLSources[sourceId] !== undefined && refLayer.visible === true) {\n      if (refLayer.data !== undefined) {\n        style = style.setIn(['sources', sourceId, 'data'], fromJS(refLayer.data))\n      }\n      if (refLayer.url !== undefined) {\n        const newSource = setDefaultVectorTiles(currentGLSources[sourceId], refLayer.url)\n        style = style.setIn(['sources', sourceId], fromJS(newSource))\n      }\n    }\n  })\n\n  for (let i = 0; i < glLayers.length; i++) {\n    const glLayer = glLayers[i]\n    const sourceId = glLayer.source\n    const glSource = glSources[sourceId]\n    const layerId = (glLayer.metadata !== undefined && glLayer.metadata['gfw:id']) || sourceId\n\n    const refLayer = layers.find((l) => l.id === layerId)\n\n    if (refLayer === undefined) {\n      if (glLayer.type !== 'background') {\n        // console.warn('gl layer does not exists in workspace', glLayer);\n      }\n      continue\n    }\n\n    // check if layer is served from Carto, which means we need to instanciate it first\n    // TODO BUG: check if layer is not instanciatING too\n    const sourceCartoSQL = glSource.metadata !== undefined && glSource.metadata['gfw:carto-sql']\n    if (sourceCartoSQL !== false && sourceCartoSQL !== undefined) {\n      // only if layer is visible and has not been instanciated yet\n      const cartoLayerInstanciated = state.cartoLayersInstanciated.indexOf(sourceId) > -1\n      if (\n        refLayer.visible === true &&\n        !cartoLayerInstanciated &&\n        !cartoLayersToInstanciate.find((l) => l.sourceId === sourceId)\n      ) {\n        cartoLayersToInstanciate.push({ sourceId, sourceCartoSQL, refLayer })\n      }\n      continue\n    }\n\n    style = updateGLLayer(style, glLayer.id, refLayer)\n  }\n\n  if (cartoLayersToInstanciate.length) {\n    dispatch(instanciateCartoLayers(cartoLayersToInstanciate))\n  }\n\n  dispatch(setMapStyle(style))\n}\n","import { compose, createStore, applyMiddleware } from 'redux'\nimport thunk from 'redux-thunk'\n\nimport { fitToBounds } from '../glmap/viewport.actions'\n\nlet composeEnhancers = compose\nif (\n  (process.env.MAP_REDUX_REMOTE_DEBUG || process.env.REACT_APP_MAP_REDUX_REMOTE_DEBUG) &&\n  process.env.NODE_ENV === 'development'\n) {\n  const composeWithDevTools = require('remote-redux-devtools').composeWithDevTools\n  composeEnhancers = composeWithDevTools({\n    name: 'Map module',\n    realtime: true,\n    hostname: 'localhost',\n    port: 8000,\n    maxAge: 30,\n    stateSanitizer: (state) => ({ ...state, map: { ...state.map, heatmap: 'NOT_SERIALIZED' } }),\n  })\n}\n\nconst store = createStore(() => {}, {}, composeEnhancers(applyMiddleware(thunk)))\n\nexport const targetMapVessel = (id) => {\n  const track = store.getState().map.tracks.data.find((t) => t.id === id.toString())\n  store.dispatch(fitToBounds(track.geoBounds))\n\n  return track.timelineBounds\n}\n\nexport default store\n","import tbbox from '@turf/bbox'\nimport { targetMapVessel } from '../store'\n\nimport {\n  getTilePromises,\n  getCleanVectorArrays,\n  groupData,\n  addTracksPointsRenderingData,\n  getTracksPlaybackData,\n} from '../utils/heatmapTileData'\nimport { startLoader, completeLoader } from '../module/module.actions'\n\nexport const ADD_TRACK = 'ADD_TRACK'\nexport const UPDATE_TRACK = 'UPDATE_TRACK'\nexport const REMOVE_TRACK = 'REMOVE_TRACK'\n\nconst getTrackDataParsed = (geojson) => {\n  const time = { start: Infinity, end: 0 }\n  if (geojson && geojson.features) {\n    geojson.features.forEach((feature) => {\n      const hasTimes =\n        feature.properties &&\n        feature.properties.coordinateProperties &&\n        feature.properties.coordinateProperties.times &&\n        feature.properties.coordinateProperties.times.length > 0\n      if (hasTimes) {\n        feature.properties.coordinateProperties.times.forEach((datetime) => {\n          if (datetime < time.start) {\n            time.start = datetime\n          } else if (datetime > time.end) {\n            time.end = datetime\n          }\n        })\n      }\n    })\n  }\n  return {\n    geojson,\n    timelineBounds: [time.start, time.end],\n  }\n}\n\nconst getTrackBounds = (geojson) => {\n  const bounds = tbbox(geojson)\n  return {\n    minLat: bounds[3],\n    minLng: bounds[0],\n    maxLat: bounds[1],\n    maxLng: bounds[2],\n  }\n}\n\n// Deprecated tracks format parsing\nconst getOldTrackBoundsFormat = (data, addOffset = false) => {\n  const time = {\n    start: Infinity,\n    end: 0,\n  }\n  const geo = {\n    minLat: Infinity,\n    maxLat: -Infinity,\n    minLng: Infinity,\n    maxLng: -Infinity,\n  }\n  for (let i = 0, length = data.datetime.length; i < length; i++) {\n    const datetime = data.datetime[i]\n    if (datetime < time.start) {\n      time.start = datetime\n    } else if (datetime > time.end) {\n      time.end = datetime\n    }\n\n    const lat = data.latitude[i]\n    if (lat < geo.minLat) {\n      geo.minLat = lat\n    } else if (lat > geo.maxLat) {\n      geo.maxLat = lat\n    }\n\n    let lng = data.longitude[i]\n    if (addOffset === true) {\n      if (lng < 0) {\n        lng += 360\n      }\n    }\n    if (lng < geo.minLng) {\n      geo.minLng = lng\n    } else if (lng > geo.maxLng) {\n      geo.maxLng = lng\n    }\n  }\n\n  // track crosses the antimeridian\n  if (geo.maxLng - geo.minLng > 350 && addOffset === false) {\n    return getOldTrackBoundsFormat(data, true)\n  }\n\n  return {\n    time: [time.start, time.end],\n    geo,\n  }\n}\n\nfunction loadTrack(track) {\n  return (dispatch, getState) => {\n    const { id, url, type, fitBoundsOnLoad, layerTemporalExtents, color, data } = track\n    const state = getState()\n    if (state.map.tracks.data.find((t) => t.id === id)) {\n      return\n    }\n\n    const payload = {\n      id,\n      url,\n      type,\n      color,\n      fitBoundsOnLoad,\n    }\n    const trackHasData = track.data !== undefined && track.data !== null\n    const trackHasUrl = url !== undefined && url !== null && url !== ''\n    if (trackHasData) {\n      payload.data = data\n      payload.geoBounds = getTrackBounds(data)\n    }\n    dispatch({ type: ADD_TRACK, payload })\n\n    if (trackHasData || !trackHasUrl) {\n      return\n    }\n\n    const loaderID = startLoader(dispatch, state)\n    if (type !== 'geojson') {\n      // Deprecated tracks format logic to be deleted some day\n      const token = state.map.module.token\n\n      const promises = getTilePromises(url, token, layerTemporalExtents)\n\n      Promise.all(promises.map((p) => p.catch((e) => e))).then((rawTileData) => {\n        const cleanData = getCleanVectorArrays(rawTileData)\n\n        if (!cleanData.length) {\n          return\n        }\n        const rawTrackData = groupData(cleanData, [\n          'latitude',\n          'longitude',\n          'datetime',\n          'series',\n          'weight',\n          'sigma',\n        ])\n\n        const vectorArray = addTracksPointsRenderingData(rawTrackData)\n        const bounds = getOldTrackBoundsFormat(rawTrackData)\n\n        dispatch({\n          type: UPDATE_TRACK,\n          payload: {\n            id,\n            data: getTracksPlaybackData(vectorArray),\n            geoBounds: bounds.geo,\n            timelineBounds: bounds.time,\n          },\n        })\n        dispatch(completeLoader(loaderID))\n      })\n    } else {\n      fetch(url)\n        .then((res) => {\n          if (res.status >= 400) throw new Error(res.statusText)\n          return res.json()\n        })\n        .then((data) => {\n          const { geojson, timelineBounds } = getTrackDataParsed(data)\n          const geoBounds = getTrackBounds(data)\n          dispatch({\n            type: UPDATE_TRACK,\n            payload: {\n              id,\n              data: geojson,\n              geoBounds,\n              timelineBounds,\n            },\n          })\n          if (fitBoundsOnLoad) {\n            targetMapVessel(id)\n          }\n        })\n        .catch((err) => console.warn(err))\n        .finally(() => dispatch(completeLoader(loaderID)))\n    }\n  }\n}\n\nconst removeTrack = (trackId) => ({\n  type: REMOVE_TRACK,\n  payload: {\n    trackId,\n  },\n})\n\nexport const updateTracks = (newTracks = []) => (dispatch, getState) => {\n  const prevTracks = getState().map.tracks.data\n  // add and update layers\n  if (newTracks) {\n    newTracks.forEach((newTrack) => {\n      const trackId = newTrack.id\n      const prevTrack = prevTracks.find((t) => t.id === trackId)\n      if (prevTrack === undefined) {\n        dispatch(loadTrack(newTrack))\n      } else if (prevTrack.color !== newTrack.color) {\n        dispatch({\n          type: UPDATE_TRACK,\n          payload: {\n            id: newTrack.id,\n            color: newTrack.color,\n          },\n        })\n      }\n    })\n  }\n\n  // clean up unused tracks\n  prevTracks.forEach((prevTrack) => {\n    if (!newTracks || !newTracks.find((t) => t.id === prevTrack.id)) {\n      dispatch(removeTrack(prevTrack.id))\n    }\n  })\n}\n","import PropTypes from 'prop-types'\n\nconst withReducerPropTypes = (name, propTypesSchema) => (reducer) => {\n  if (process.env.NODE_ENV === 'development') {\n    return (state, action) => {\n      const result = reducer(state, action)\n      PropTypes.checkPropTypes(propTypesSchema, result, 'reducer', name)\n\n      return result\n    }\n  }\n  return reducer\n}\n\nexport default withReducerPropTypes\n","import PropTypes from 'prop-types'\nimport withReducerTypes from '../utils/withReducerTypes'\nimport {\n  INIT_MODULE,\n  SET_TEMPORAL_EXTENT,\n  SET_HIGHLIGHT_TEMPORAL_EXTENT,\n  START_LOADER,\n  COMPLETE_LOADER,\n  SET_MODULE_CURSOR,\n} from './module.actions'\n\nconst initialState = {\n  loaders: null,\n  token: undefined,\n  temporalExtent: [new Date(1970), new Date()],\n  highlightTemporalExtent: null,\n  cursor: null,\n  onViewportChange: undefined,\n  onHover: undefined,\n  onClick: undefined,\n  onLoadStart: undefined,\n  onLoadComplete: undefined,\n  onClosePopup: undefined,\n  onAttributionsChange: undefined,\n}\n\nconst moduleReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case INIT_MODULE: {\n      return {\n        ...state,\n        ...action.payload,\n      }\n    }\n\n    case SET_TEMPORAL_EXTENT: {\n      return {\n        ...state,\n        temporalExtent: action.payload,\n      }\n    }\n\n    case SET_HIGHLIGHT_TEMPORAL_EXTENT: {\n      return {\n        ...state,\n        highlightTemporalExtent: action.payload,\n      }\n    }\n\n    case START_LOADER: {\n      const loaders = state.loaders !== null ? [...state.loaders] : []\n      loaders.push(action.payload)\n      return { ...state, loaders }\n    }\n\n    case COMPLETE_LOADER: {\n      const loaders = [...state.loaders]\n      const loaderIndex = loaders.findIndex((l) => l === action.payload)\n      loaders.splice(loaderIndex, 1)\n      return { ...state, loaders }\n    }\n\n    case SET_MODULE_CURSOR: {\n      return { ...state, cursor: action.payload }\n    }\n\n    default:\n      return state\n  }\n}\n\nconst moduleTypes = {\n  loaders: PropTypes.arrayOf(PropTypes.number),\n  token: PropTypes.string,\n  temporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  onViewportChange: PropTypes.func,\n  onHover: PropTypes.func,\n  onClick: PropTypes.func,\n  onLoadStart: PropTypes.func,\n  onLoadComplete: PropTypes.func,\n  onClosePopup: PropTypes.func,\n  onAttributionsChange: PropTypes.func,\n}\n\nexport default withReducerTypes('module', moduleTypes)(moduleReducer)\n","import PropTypes from 'prop-types'\nimport { trackTypes } from '../proptypes/tracks'\nimport withReducerTypes from '../utils/withReducerTypes'\n\nimport { ADD_TRACK, UPDATE_TRACK, REMOVE_TRACK } from './tracks.actions'\n\nconst initialState = {\n  data: [],\n}\n\nconst tracksReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case ADD_TRACK: {\n      const data = [...state.data, action.payload]\n      return { ...state, data }\n    }\n\n    case UPDATE_TRACK: {\n      const trackData = action.payload\n      const data = state.data.map((track) => {\n        if (track.id !== trackData.id) return track\n        return {\n          ...track,\n          ...trackData,\n        }\n      })\n      return { ...state, data }\n    }\n\n    case REMOVE_TRACK: {\n      const removedTrackId = action.payload.trackId\n      const data = state.data.filter((track) => track.id !== removedTrackId)\n      return { ...state, data }\n    }\n\n    default:\n      return state\n  }\n}\n\nconst tracksTypes = {\n  data: PropTypes.arrayOf(\n    PropTypes.exact({\n      ...trackTypes,\n      data: PropTypes.object,\n      timelineBounds: PropTypes.array,\n      geoBounds: PropTypes.exact({\n        minLat: PropTypes.number,\n        minLng: PropTypes.number,\n        maxLat: PropTypes.number,\n        maxLng: PropTypes.number,\n      }),\n    })\n  ),\n}\n\nexport default withReducerTypes('tracks', tracksTypes)(tracksReducer)\n","import difference from 'lodash/difference'\nimport {\n  INIT_HEATMAP_LAYERS,\n  UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES,\n  ADD_HEATMAP_LAYER,\n  UPDATE_HEATMAP_LAYER_STYLE,\n  REMOVE_HEATMAP_LAYER,\n  ADD_REFERENCE_TILE,\n  UPDATE_HEATMAP_TILE,\n  RELEASE_HEATMAP_TILES,\n  HIGHLIGHT_VESSELS,\n  UPDATE_LOADED_TILES,\n  HIGHLIGHT_CLICKED_VESSEL,\n  CLEAR_HIGHLIGHT_CLICKED_VESSEL,\n} from './heatmap.actions'\n\nconst initialState = {\n  // a dict of heatmap layers (key is layer id)\n  // each containing data, url, tiles, visibleTemporalExtentsIndices\n  heatmapLayers: {},\n  // store a list of tiles currently visible in the map\n  // those are necessary when adding a new layer to know which tiles need to be loaded\n  referenceTiles: [],\n  highlightedVessels: { isEmpty: true },\n  highlightedClickedVessel: null,\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case INIT_HEATMAP_LAYERS: {\n      return Object.assign({}, state, { heatmapLayers: action.payload })\n    }\n\n    case UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES: {\n      const heatmapLayers = state.heatmapLayers\n      heatmapLayers[action.payload.layerId].visibleTemporalExtentsIndices =\n        action.payload.newVisibleTemporalExtentsIndices\n\n      // also removing indices within each tile\n      // adding is done after tile has actually loaded\n      heatmapLayers[action.payload.layerId].tiles.forEach((tile) => {\n        tile.temporalExtentsIndicesLoaded = difference(\n          tile.temporalExtentsIndicesLoaded,\n          action.payload.indicesRemoved\n        )\n      })\n      return { ...state, heatmapLayers }\n    }\n\n    case ADD_HEATMAP_LAYER: {\n      const heatmapLayers = Object.assign({}, state.heatmapLayers, {\n        [action.payload.id]: {\n          tiles: [],\n          ...action.payload,\n        },\n      })\n      return Object.assign({}, state, { heatmapLayers })\n    }\n\n    case UPDATE_HEATMAP_LAYER_STYLE: {\n      const newLayer = action.payload\n      const layer = { ...state.heatmapLayers[newLayer.id], ...newLayer }\n      const heatmapLayers = { ...state.heatmapLayers, [newLayer.id]: layer }\n      return { ...state, heatmapLayers }\n    }\n\n    case REMOVE_HEATMAP_LAYER: {\n      const heatmapLayers = Object.assign({}, state.heatmapLayers)\n      delete heatmapLayers[action.payload.id]\n      return Object.assign({}, state, { heatmapLayers })\n    }\n\n    case ADD_REFERENCE_TILE: {\n      return Object.assign({}, state, { referenceTiles: [...state.referenceTiles, action.payload] })\n    }\n\n    case UPDATE_HEATMAP_TILE: {\n      const layerId = action.payload.layerId\n      const newTile = action.payload.tile\n      const layer = { ...state.heatmapLayers[layerId] }\n      let layerTiles = [...layer.tiles]\n      const tileIndex = layerTiles.findIndex((t) => t.uid === newTile.uid)\n      if (tileIndex === -1) {\n        layerTiles.push(newTile)\n      } else {\n        layerTiles = [\n          ...layerTiles.slice(0, tileIndex),\n          newTile,\n          ...layerTiles.slice(tileIndex + 1),\n        ]\n      }\n      layer.tiles = layerTiles\n      const heatmapLayers = { ...state.heatmapLayers, [layerId]: layer }\n      return { ...state, heatmapLayers }\n    }\n\n    case RELEASE_HEATMAP_TILES: {\n      const uids = action.payload\n\n      // remove tiles\n      const layerIds = Object.keys(state.heatmapLayers)\n      const heatmapLayers = { ...state.heatmapLayers }\n      layerIds.forEach((layerId) => {\n        const prevLayer = { ...heatmapLayers[layerId] }\n        uids.forEach((tileUid) => {\n          const releasedTileIndex = prevLayer.tiles.findIndex((tile) => tile.uid === tileUid)\n          if (releasedTileIndex > -1) {\n            // console.log('releasing', layerId, tileUid);\n            prevLayer.tiles.splice(releasedTileIndex, 1)\n          }\n        })\n      })\n\n      // remove reference tiles\n      let referenceTiles = [...state.referenceTiles]\n      uids.forEach((tileUid) => {\n        const releasedRefTileIndex = referenceTiles.findIndex((tile) => tile.uid === tileUid)\n        if (releasedRefTileIndex > -1) {\n          referenceTiles = [\n            ...referenceTiles.slice(0, releasedRefTileIndex),\n            ...referenceTiles.slice(releasedRefTileIndex + 1),\n          ]\n        }\n      })\n\n      return { ...state, heatmapLayers, referenceTiles }\n    }\n\n    case UPDATE_LOADED_TILES: {\n      const newHeatmapLayers = { ...state.heatmapLayers }\n      return { ...state, heatmapLayers: newHeatmapLayers }\n    }\n\n    case HIGHLIGHT_VESSELS: {\n      return Object.assign({}, state, { highlightedVessels: action.payload })\n    }\n\n    case HIGHLIGHT_CLICKED_VESSEL: {\n      return { ...state, highlightedClickedVessel: action.payload }\n    }\n\n    case CLEAR_HIGHLIGHT_CLICKED_VESSEL: {\n      return { ...state, highlightedClickedVessel: null }\n    }\n\n    default:\n      return state\n  }\n}\n","import uniq from 'lodash/uniq'\nimport {\n  SET_CURRENTLY_VISIBLE_TILES,\n  SET_CURRENTLY_LOADED_TILES,\n  SET_CURRENTLY_SWAPPED_TILE_UIDS,\n  MARK_TILES_UIDS_AS_LOADED,\n  RELEASE_MARKED_TILES_UIDS,\n} from './heatmapTiles.actions'\n\nconst initialState = {\n  currentVisibleTiles: [],\n  currentLoadedTiles: [],\n  currentToLoadTileUids: [],\n  currentToReleaseTileUids: [],\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case SET_CURRENTLY_VISIBLE_TILES: {\n      const currentVisibleTiles = [].concat(action.payload)\n      return { ...state, currentVisibleTiles }\n    }\n\n    case SET_CURRENTLY_LOADED_TILES: {\n      const currentLoadedTiles = [].concat(action.payload)\n      return { ...state, currentLoadedTiles }\n    }\n\n    case SET_CURRENTLY_SWAPPED_TILE_UIDS: {\n      const currentToLoadTileUids = uniq(\n        state.currentToLoadTileUids.concat(action.payload.tilesToLoadUids)\n      )\n      const currentToReleaseTileUids = uniq(\n        state.currentToReleaseTileUids.concat(action.payload.tilesToReleaseUids)\n      )\n      // clean to load tiles of tiles that needs to be released\n      const newToLoadTilesUids = currentToLoadTileUids.filter(\n        (tileUid) => currentToReleaseTileUids.indexOf(tileUid) === -1\n      )\n      return { ...state, currentToLoadTileUids: newToLoadTilesUids, currentToReleaseTileUids }\n    }\n\n    case MARK_TILES_UIDS_AS_LOADED: {\n      const currentToLoadTileUids = state.currentToLoadTileUids\n      const tileUidsMarkedAsLoaded = action.payload\n      const newCurrentToLoadTileUids = currentToLoadTileUids.filter(\n        (tileUid) => tileUidsMarkedAsLoaded.indexOf(tileUid) === -1\n      )\n      return { ...state, currentToLoadTileUids: newCurrentToLoadTileUids }\n    }\n\n    case RELEASE_MARKED_TILES_UIDS: {\n      return { ...state, currentToReleaseTileUids: [] }\n    }\n\n    default:\n      return state\n  }\n}\n","import FlyToInterpolator from 'react-map-gl/dist/esm/utils/transition/viewport-fly-to-interpolator'\nimport { easeCubic } from 'd3-ease'\nimport { MIN_ZOOM_LEVEL, MAX_ZOOM_LEVEL } from '../config'\nimport { TRANSITION_TYPE } from '../constants'\nimport {\n  SET_VIEWPORT,\n  UPDATE_VIEWPORT,\n  SET_ZOOM_INCREMENT,\n  SET_MOUSE_LAT_LONG,\n  TRANSITION_END,\n  SET_NATIVE_VIEWPORT,\n} from './viewport.actions'\n\nconst DEFAULT_TRANSITION = {\n  transitionDuration: 500,\n  transitionInterpolator: new FlyToInterpolator(),\n  transitionEasing: easeCubic,\n}\n\nconst initialState = {\n  viewport: {\n    latitude: 0,\n    longitude: 0,\n    zoom: 3,\n    bearing: 0,\n    pitch: 0,\n    width: 1000,\n    height: 800,\n  },\n  maxZoom: MAX_ZOOM_LEVEL,\n  minZoom: MIN_ZOOM_LEVEL,\n  prevZoom: 3,\n  currentTransition: null,\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case SET_VIEWPORT: {\n      return {\n        ...state,\n        viewport: action.payload,\n        canZoomIn: action.payload.zoom < state.maxZoom,\n        canZoomOut: action.payload.zoom > state.minZoom,\n        prevZoom: state.viewport.zoom,\n      }\n    }\n\n    case UPDATE_VIEWPORT: {\n      const viewport = { ...state.viewport, ...action.payload }\n      return {\n        ...state,\n        viewport,\n        prevZoom: viewport.zoom,\n      }\n    }\n\n    case SET_ZOOM_INCREMENT: {\n      const currentZoom = state.viewport.zoom\n      const zoom = Math.min(\n        state.maxZoom,\n        action.payload.zoom || currentZoom + action.payload.increment\n      )\n      const viewport = {\n        ...state.viewport,\n        ...DEFAULT_TRANSITION,\n        zoom,\n        latitude:\n          action.payload.latitude === null ? state.viewport.latitude : action.payload.latitude,\n        longitude:\n          action.payload.longitude === null ? state.viewport.longitude : action.payload.longitude,\n      }\n      return {\n        ...state,\n        viewport,\n        canZoomIn: zoom < state.maxZoom,\n        canZoomOut: zoom > state.minZoom,\n        prevZoom: state.viewport.zoom,\n        currentTransition: TRANSITION_TYPE.ZOOM,\n      }\n    }\n\n    case SET_MOUSE_LAT_LONG: {\n      return { ...state, mouseLatLong: action.payload }\n    }\n\n    case TRANSITION_END: {\n      return { ...state, currentTransition: null }\n    }\n\n    case SET_NATIVE_VIEWPORT: {\n      return { ...state, ...action.payload }\n    }\n\n    default:\n      return state\n  }\n}\n","// TODO MAP MODULE remove whole reducer\nimport { SET_MAP_CURSOR } from './interaction.actions'\n\nconst initialState = {\n  cursor: 'progress',\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case SET_MAP_CURSOR: {\n      return { ...state, cursor: action.payload }\n    }\n    default:\n      return state\n  }\n}\n","import { combineReducers } from 'redux'\n\nimport ModuleReducer from '../module/module.reducer'\nimport TracksReducer from '../tracks/tracks.reducer'\nimport HeatmapReducer from '../heatmap/heatmap.reducer'\nimport HeatmapTilesReducer from '../heatmap/heatmapTiles.reducer'\nimport ViewportReducer from '../glmap/viewport.reducer'\nimport StyleReducer from '../glmap/style.reducer'\nimport InteractionReducer from '../glmap/interaction.reducer'\n\nconst mapReducer = combineReducers({\n  module: ModuleReducer,\n  tracks: TracksReducer,\n  heatmap: HeatmapReducer,\n  heatmapTiles: HeatmapTilesReducer,\n  style: StyleReducer,\n  viewport: ViewportReducer,\n  interaction: InteractionReducer,\n})\n\nexport default mapReducer\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { combineReducers } from 'redux'\nimport { Provider } from 'react-redux'\nimport throttle from 'lodash/throttle'\nimport { trackTypes } from './proptypes/tracks'\nimport { heatmapLayerTypes, basemapLayerTypes, staticLayerTypes } from './proptypes/layers'\nimport { viewportTypes, popupTypes } from './proptypes/shared'\n\nimport Map from './glmap/Map.container'\nimport {\n  initModule,\n  setTemporalExtent,\n  setHighlightTemporalExtent,\n  setCursor,\n} from './module/module.actions'\nimport { updateViewport, transitionToZoom } from './glmap/viewport.actions'\nimport { initStyle, commitStyleUpdates, applyTemporalExtent } from './glmap/style.actions'\nimport { updateTracks } from './tracks/tracks.actions'\nimport { updateHeatmapLayers, updateLayerLoadTemporalExtents } from './heatmap/heatmap.actions'\n\nimport store from './store'\nimport mapReducers from './store/reducers'\n\nconst mapReducer = combineReducers({\n  map: mapReducers,\n})\n\nstore.replaceReducer(mapReducer)\n\nconst throttleApplyTemporalExtent = throttle((temporalExtent) => {\n  store.dispatch(applyTemporalExtent(temporalExtent))\n  store.dispatch(setTemporalExtent(temporalExtent))\n}, 16)\n\nconst updateViewportFromIncomingProps = (incomingViewport) => {\n  store.dispatch(\n    updateViewport({\n      latitude: incomingViewport.center[0],\n      longitude: incomingViewport.center[1],\n      zoom: incomingViewport.zoom,\n    })\n  )\n}\n\nclass MapModule extends React.Component {\n  state = {\n    initialized: false,\n    error: null,\n    errorInfo: null,\n  }\n\n  componentDidCatch(error, errorInfo) {\n    console.log(error, errorInfo)\n    this.setState({\n      error: error,\n      errorInfo: errorInfo,\n    })\n  }\n\n  componentDidMount() {\n    // First trigger synchronous actions that should happen before any map render\n    // At the end of this, set a flag to allow map rendering\n\n    if (this.props.viewport !== undefined) {\n      updateViewportFromIncomingProps(this.props.viewport)\n    }\n\n    // TODO\n    if (this.props.glyphsPath !== null) {\n      store.dispatch(\n        initStyle({\n          glyphsPath: this.props.glyphsPath,\n          // TODO apply URL updates here\n        })\n      )\n    }\n\n    if (this.props.onAttributionsChange !== undefined) {\n      this.props.onAttributionsChange(store.getState().map.style.attributions)\n    }\n\n    if (store && store.getState().map.module.token === undefined) {\n      store.dispatch(\n        initModule({\n          token: this.props.token,\n          autoClusterZoom: this.props.autoClusterZoom,\n          isCluster: this.props.isCluster,\n          onViewportChange: this.props.onViewportChange,\n          onHover: this.props.onHover,\n          onClick: this.props.onClick,\n          onLoadStart: this.props.onLoadStart,\n          onLoadComplete: this.props.onLoadComplete,\n          onClosePopup: this.props.onClosePopup,\n          onAttributionsChange: this.props.onAttributionsChange,\n        })\n      )\n    }\n\n    if (this.props.highlightTemporalExtent !== null && this.props.highlightTemporalExtent.length) {\n      store.dispatch(setHighlightTemporalExtent(this.props.highlightTemporalExtent))\n    }\n\n    if (\n      (this.props.basemapLayers !== null && this.props.basemapLayers.length) ||\n      (this.props.staticLayers !== null && this.props.staticLayers.length)\n    ) {\n      store.dispatch(\n        commitStyleUpdates(this.props.staticLayers || [], this.props.basemapLayers || [])\n      )\n    }\n\n    if (this.props.tracks !== null) {\n      store.dispatch(updateTracks(this.props.tracks))\n    }\n\n    // Now trigger async actions\n\n    if (this.props.temporalExtent !== null && this.props.temporalExtent.length) {\n      throttleApplyTemporalExtent(this.props.temporalExtent)\n    }\n\n    // eslint-disable-next-line react/no-did-mount-set-state\n    this.setState({\n      initialized: true,\n    })\n\n    // heatmap layers\n    if (this.props.heatmapLayers !== null) {\n      store.dispatch(updateHeatmapLayers(this.props.heatmapLayers, this.props.loadTemporalExtent))\n    }\n  }\n\n  componentDidUpdate(prevProps) {\n    // tracks\n    if (this.props.tracks !== prevProps.tracks) {\n      store.dispatch(updateTracks(this.props.tracks))\n    }\n\n    // heatmap layers\n    if (this.props.heatmapLayers !== prevProps.heatmapLayers) {\n      store.dispatch(updateHeatmapLayers(this.props.heatmapLayers, this.props.loadTemporalExtent))\n    }\n\n    // basemap / static layers\n    if (\n      (this.props.basemapLayers !== null && this.props.basemapLayers.length) ||\n      (this.props.staticLayers !== null && this.props.staticLayers.length)\n    ) {\n      if (\n        this.props.basemapLayers !== prevProps.basemapLayers ||\n        this.props.staticLayers !== prevProps.staticLayers\n      ) {\n        store.dispatch(\n          commitStyleUpdates(this.props.staticLayers || [], this.props.basemapLayers || [])\n        )\n      }\n    }\n\n    // loadTemporalExtent\n    if (this.props.loadTemporalExtent !== null && this.props.loadTemporalExtent.length) {\n      if (\n        prevProps.loadTemporalExtent === null ||\n        !prevProps.loadTemporalExtent.length ||\n        this.props.loadTemporalExtent[0].getTime() !== prevProps.loadTemporalExtent[0].getTime() ||\n        this.props.loadTemporalExtent[1].getTime() !== prevProps.loadTemporalExtent[1].getTime()\n      ) {\n        store.dispatch(updateLayerLoadTemporalExtents(this.props.loadTemporalExtent))\n      }\n    }\n    // temporalExtent\n    if (this.props.temporalExtent !== null && this.props.temporalExtent.length) {\n      if (\n        prevProps.temporalExtent === null ||\n        !prevProps.temporalExtent.length ||\n        this.props.temporalExtent[0].getTime() !== prevProps.temporalExtent[0].getTime() ||\n        this.props.temporalExtent[1].getTime() !== prevProps.temporalExtent[1].getTime()\n      ) {\n        throttleApplyTemporalExtent(this.props.temporalExtent)\n      }\n    }\n\n    // highlightTemporalExtent\n    if (this.props.highlightTemporalExtent !== null && this.props.highlightTemporalExtent.length) {\n      if (\n        prevProps.highlightTemporalExtent === null ||\n        !prevProps.highlightTemporalExtent.length ||\n        this.props.highlightTemporalExtent[0].getTime() !==\n          prevProps.highlightTemporalExtent[0].getTime() ||\n        this.props.highlightTemporalExtent[1].getTime() !==\n          prevProps.highlightTemporalExtent[1].getTime()\n      ) {\n        store.dispatch(setHighlightTemporalExtent(this.props.highlightTemporalExtent))\n      }\n    } else {\n      if (this.props.highlightTemporalExtent !== prevProps.highlightTemporalExtent) {\n        store.dispatch(setHighlightTemporalExtent(this.props.highlightTemporalExtent))\n      }\n    }\n\n    // viewport - since viewport will be updated internally to the module,\n    // we have to compare incoming props to existing viewport in store, ie:\n    // update viewport from incoming props ONLY if zoom or center is different\n    // from the internally stored one\n    // TODO FFS incoming lat lon should be an object, not an array\n    const currentViewport = store.getState().map.viewport.viewport\n    //                                        stop propagating updates from outside when zooming in\n    if (\n      this.props.viewport !== undefined &&\n      store.getState().map.viewport.currentTransition === null\n    ) {\n      if (\n        currentViewport.latitude !== this.props.viewport.center[0] ||\n        currentViewport.longitude !== this.props.viewport.center[1] ||\n        currentViewport.zoom !== this.props.viewport.zoom\n      ) {\n        // if zoom delta is precisely === 1, zoom with a transition\n        if (Math.abs(currentViewport.zoom - this.props.viewport.zoom) === 1) {\n          store.dispatch(transitionToZoom(this.props.viewport))\n        } else {\n          updateViewportFromIncomingProps(this.props.viewport)\n        }\n      }\n    }\n\n    if (this.props.cursor !== prevProps.cursor) {\n      store.dispatch(setCursor(this.props.cursor))\n    }\n  }\n  render() {\n    if (this.state.error !== null) {\n      console.log(this.state.error)\n      return (\n        <div>\n          <h2>Map component crashed!</h2>\n          <p className=\"red\">{this.state.error && this.state.error.toString()}</p>\n          <div>Component Stack Error Details:</div>\n          <p className=\"red\">{this.state.errorInfo.componentStack}</p>\n        </div>\n      )\n    }\n    // won't render anything before actions in componentDidMount have been triggered\n    return this.state.initialized !== true ? null : (\n      <Provider store={store}>\n        <Map {...this.props} />\n      </Provider>\n    )\n  }\n}\n\nMapModule.propTypes = {\n  token: PropTypes.string,\n  viewport: PropTypes.shape(viewportTypes).isRequired,\n  autoClusterZoom: PropTypes.bool,\n  isCluster: PropTypes.func,\n  tracks: PropTypes.arrayOf(PropTypes.exact(trackTypes)),\n  heatmapLayers: PropTypes.arrayOf(PropTypes.shape(heatmapLayerTypes)),\n  temporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  highlightTemporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  loadTemporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  basemapLayers: PropTypes.arrayOf(PropTypes.shape(basemapLayerTypes)),\n  staticLayers: PropTypes.arrayOf(PropTypes.shape(staticLayerTypes)),\n  cursor: PropTypes.string,\n  // customLayers\n  hoverPopup: PropTypes.shape(popupTypes),\n  clickPopup: PropTypes.shape(popupTypes),\n  glyphsPath: PropTypes.string,\n  onViewportChange: PropTypes.func,\n  onLoadStart: PropTypes.func,\n  onLoadComplete: PropTypes.func,\n  onClick: PropTypes.func,\n  onHover: PropTypes.func,\n  onAttributionsChange: PropTypes.func,\n  onClosePopup: PropTypes.func,\n}\n\nMapModule.defaultProps = {\n  token: null,\n  glyphsPath: null,\n  autoClusterZoom: true,\n  isCluster: (event) => event.isCluster === true,\n  highlightTemporalExtent: null,\n  tracks: null,\n  hoverPopup: null,\n  clickPopup: null,\n  heatmapLayers: null,\n  temporalExtent: null,\n  loadTemporalExtent: null,\n  basemapLayers: null,\n  staticLayers: null,\n  cursor: null,\n  onViewportChange: () => {},\n  onLoadStart: () => {},\n  onLoadComplete: () => {},\n  onClick: () => {},\n  onHover: () => {},\n  onAttributionsChange: () => {},\n  onClosePopup: () => {},\n}\n\nexport default MapModule\n","import GL_STYLE from '../glmap/gl-styles/style.json'\n\nconst AVAILABLE_BASEMAPS = GL_STYLE.metadata['gfw:basemap-layers']\n\nexport default AVAILABLE_BASEMAPS\n","\n  import React from 'react'\n  import { MDXTag } from '@mdx-js/tag'\n  import { Playground, PropsTable } from 'docz'\nimport Map from './index.js'\n\nconst layoutProps = {\n  \n};\nexport default class MDXContent extends React.Component {\n  constructor(props) {\n    super(props)\n    this.layout = null\n  }\n  render() {\n    const { components, ...props } = this.props\n\n    return <MDXTag\n             name=\"wrapper\"\n             \n             components={components}>\n<MDXTag name=\"h1\" components={components} props={{\"id\":\"map\"}}>{`Map`}</MDXTag>\n<MDXTag name=\"h2\" components={components} props={{\"id\":\"description\"}}>{`Description`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`This component displays and load fishing activity and fishing-related layers on a map, used in various GFW projects:`}</MDXTag>\n<MDXTag name=\"ul\" components={components}>\n<MDXTag name=\"li\" components={components} parentName=\"ul\"><MDXTag name=\"a\" components={components} parentName=\"li\" props={{\"href\":\"https://github.com/GlobalFishingWatch/map-client/blob/9c5179358d4870c0fd4c2c0742917e72e6025c59/app/src/map/components/MapWrapper.jsx#L5\"}}>{`Map client`}</MDXTag></MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\"><MDXTag name=\"a\" components={components} parentName=\"li\" props={{\"href\":\"https://github.com/GlobalFishingWatch/vessel-profiles/blob/aa0e17395f6a4947bb3fdf3106cb9d0a744ba64f/src/profile/components/MapWrapper.js#L3\"}}>{`Vessel profiles`}</MDXTag></MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\"><MDXTag name=\"a\" components={components} parentName=\"li\" props={{\"href\":\"https://github.com/GlobalFishingWatch/data-portal/blob/96b1e24efcff58ade672a67229da0610d9d241ab/src/map/MapWrapper.jsx#L2\"}}>{`Data portal`}</MDXTag></MDXTag>\n</MDXTag>\n<MDXTag name=\"h2\" components={components} props={{\"id\":\"available-properties\"}}>{`Available properties`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`TODO: fix crash on PropsTable docz component`}</MDXTag>\n<MDXTag name=\"h2\" components={components} props={{\"id\":\"basic-usage\"}}>{`Basic usage`}</MDXTag>\n<Playground __codesandbox={`N4IgZglgNgpgziAXKCA7AJjAHgOgBYAuAtlEqAMYD2qBMNSIAPOhAG4AEE6AvADogAnSpQL8AfIwD0LVmJABfADQg0mXACsEyEFRp0CDSQCojvVO3YAVPBDjsAwpUwBlAIYYARpSzs8rux4wdOyuAK4ElESuBBDkrlBQAJ7sAOZ0MALRMOjsoXBoKWYWAAZUmHDu6F5YGcU47ACSYOyJlKEA5AIw7OShAhBtdniUAO7sBH4Evq4ADjPp6IotbT3uRT14MOQA1uxtU20C7OiU5EMZMIi-BAQzcIiSkikQE6EeOFREkqiUrGiJkjK8Eq1QyZnWTWWoXY2Hm_To5G67mScAIAlCKRSsDsIxeeHGNjsFU83iWM1g_m6mVsSPMtjgoRg62oqTxb3qiAAlGYjJIzBAiDNKAIpgAlGCuchTMBCIjsToSqXtADc_MFwrFioIABEAPIAWXYMsi8q6koIAFoTkQVWqhSKHJEhah9EbZfKcJJsK5BbBbagzOLzXr9TguhgMgAKdbMNhidYWRh4ADMYkc6pdNE46pF2XYuImPScwJJNQEiCkKfj5gs7EYMzEkYaUyiyRdedc6BYMWo8XYMyEd3GlFSMCmL3Y4cw_VQKXzMASnKkDYTdfTztdkmriekccUZhOvSI-hwaQIAFFYMeaAAhRINdCRzrCAjtbmoTnKhTKb2-mA4TQyB0ahaHoRAVBzKZ9VmN0TXaT04AEchJCiGZJFUbAALgf0BXtTVzVguUFXNdo7Q1dhgHYTQfHkQj5QAARgIgRAGVBAWFGBSIDVBdFRY5TgAL2cAhEmxdhuAo9YogEZ5UCudoAAZ2GTGYsHafcaxmTsWFneSABZVPYAA2VT1PWMAQIAMR9aBEnk_hnEORFHUwdgAAUhH4JZmJ-OAtMRMyawsmhnAgATLnYABGPSNPkcEeOoPiAEE5nE9hI0o8gbCgdBw3YeROXEsR0pjGR2FRUSYG4YBDyEkTsXkbda2ALLoFy4IADIOvGRJ5koZpWpyvLuBG-UwFCHie1Qdp2AAfg2Nrw0jQqrkG9rUDimspBkat3zMWFyMwMAwigKZlqKkqtpSlca0TIMpRwSzMhSa8CCa2s62gmZ2D-GARjw6rMv0DIrgAbQUnAFIAJiMpZIqh5McCMyKAF0lgE4QiCuABWfLaK3VcpHughHue16mqka7drMb8QEQ5DUPQiMNC0CgQP0BgDodSijpOqZaONIjPVQriuamSiCFcGSxy-gA1eA4AXfK6PgyRUQ40WsDwijjhgY7QlOkI7CS2WkoaAAZJKb3N88AH0byS5xz31JK3OcZXBY9SQPEpVDsJppQ6aQlDZhDmYsKA3RQIMcDcPI4mVbNJUyIdDzKBmSxevgFWB3Ti0RPmf3UDj7miyIDw0BgcV0FCREBDsAX3QVGu1JT8X3KEP5pw9puk8tLoW64kupgmIQblgFWoCcfw8EkUeRAIP0251tFJW2TPC57uDPVzmYC_gOfMh2Ivh51zZolQ83XESDIN_gJYfcVy_r9vrO4CWVFoliK-b4EO-G5VjvQc-84CSCgC_euQ9II61-v9DU_8yTp1CBnN-W8haSF3iAtWfgB5cWXl9QBTwoCMy-h8ECrhK4CCgdrYA6w0AvH1E4A2MANIWEVgQSwTF7TxHPFgaOrDypjgABIQBSHgKAojCCcJzDwvh-gBHsPsH0OAwpYqEOYjXWAKEmGwBwOaViJ9oGUWQegLIssIB_TwksVeqB8hTUsJQAAWpjNBXssSM1gXhPRUoDHUPIpRehBBhKVSWJ8IgLxgmwAAKozFMbQd-IQ5hJGkdwqAvDo6uNVu40OFVdH6MSn40uJisiWCPtsABntVar2PofNecBvFTUMTQ3IsSshCIlMQWYP8MgJOKbQbpAhzaUE7Ck4Usjo4VKbp6c-nS0IzNQg03x8VT7qy6IQ1ZnFl6oWrrXHp6yIhdEkAPXZkD4q8RbLMHZdc0qfAri6K5PSMpSVmFcbZ2QTnvzMAVeKGywwwHJJKKu7y66RjeTXOue0Eq2JHngMei8YDXWSVwsZaS5FZgkvPceMBIyRloDI1F0dCrcGKrQmsvyWB-WiFlSMsxySJFGZkAl-hcXIsZek_QnJ3xsIOf-ClWkCDUvYQy8ZzK8WpPZTQTlXy4ZGUheclpcSYDmMsRqJ6kQGgJXCbONOQ4JKRjQJ8Aoyq4EiiJSS9Y5LbD8upauPpSqLEmoIE826tZwExAIKETAVwDWRCNQ6rxiI9ACHBmjVcFgp6zheJ6iKPqtUpGNQG4GwbUYCI-hjSI3rNV-pVSKHA6aiCpvyly9g75NpmHIOAuAdgvqMM0d0bAoF0B2GJjgdc1BXSku5VkNKnbayBIgPEMK2QrjHSgIrQtGQhDlnYKgA2UAJ0CCnRqiyVxZ0JAEWWmsnwNw0G1FwewVK8CRknaomEi7hTLsoIVXtFheKUF0VPFIx7z0CCWCegQl7i0WAmLYHA7DhJZGdR9Cw76rjvsLSBl9l6wNQdQBZQt3yaybtvU6dtu6uCMImk669q5HjsEshAeuI9-iYgyOVRIPFYXUEGCEHxiUCTRHKsMA2OQ_BzGCIECyazkTsFQpOOg05cOSHYElGF9aMB7GaD-hJ7CQhGnAXOCIIQEijF4zBKcGQCjxQ-hAZouLCQ4F3vUzx5EACEo0JpHUrugHDLqLB2oTaq2UGrDXasHHAfTv6jM4BM6a1cyHax4csLqPUq5dPpWk4Z9zp4kgzDwHANy0R8TmYkmuqAtngPlR5TgPlh7ox2b7cXIJ9VsU3sy6kWL8XEsTCuJF7zWJepVaSxB4DQWQu6kSXS9gUTRTmwVVkc4XQw21kQ5lr9-VtN9r03V6L1BRNoggB4cIBj7B-FnN0FLuQIyQBdDZySBWZvp3qXNm4_QluNNW-4NIkZflngA7QZaOAFm5P_NEBb52DHjYCxYcLN2eXsC6lljip4xz3exZyJ7swns6P_BEbYwQRoSUs3razGXgOWspQKo9w2ftFdrcwoD5Xv2UHh3JAkXnotw7oC1j6YQIj2CgHkWgAhnEZvJ_U7zdPKAM6ZxkVnBacd9rgDz1EIN2dRaOzgWwIvmc09rNQRzIpLvrdqwZ7zCv_UamV2kOXFhqBCN-GLw7dwcD68N6-wXevUAM9iNsVXFPJfUBtzsXXexUBDM7ABkU9uOezfd8M9AXuCCu-oB79A65YC0B9xLk3oeA8R7HCwy3buGeUEVm5JBMxo_q-t1PdPmeQ-oHm2d5biVtcRWN8dovp3Ful9seXuXo3gNfcmz96bavos2DERIsRHDWUiqzJttLAPuqV_wJInvUj-9MpoDgWAs4Jho4-hj61R72EiO75Ivv-KJVOrH138RW_hUz4IFKl133OB6eG5533kvH5MS6RAuwQ-50j_F95-_z9f71PnykRf7AAAfAA6_MfT-GIcgAZZ_UaYfQHUAyWcAyAufOgP_PAcbJfWsFfPLQXMJCJErGJRVDzOAr-CAp_QAgA9gUGNGd_aLT_R_b_MgiglGcbCwFvbiHTdvB3E3apcpdgF_RcfbTLTArHSMO1UpOpG_GPepbguAM_D6C_PDAAOVUwW1IyOH8Ao3IFo0aVb0vwiw70lzFRRV314OgNf1gP0K4On13yQIX1QIEOA0xXhURXpSsLRT3wsKkNcMJX8x0Lw3gAkRoCtFsFcA8FgAtBdD4QtACKpC1G-EoCCPQAtGYiwwtHYVSPgKZBdUi3_QyMJx0yKwHQkXCnQFq3RCT3P0hQ-jw3mRgnAW_zCw4NvxNxqJmEgJMNSznXQO5WB1y2ELtXaQvjoMeX3w6S_x6WsQ8LnwD2P131kJG3WAC23TQx1C4HwMAwHBgFYB1RkPsIsDw2kIaL0M4KkLKSgIkg2K2Mp1OK6KBy6ByytTy1ENOIkO82kLmIsHkOExaPYDqJ6UOJeM71GKGPrnaP7C6EuMlxaMgJuKEOpX6KBNaKfwBMhIRMgImOOKmJGS8I5VYKE3YFoO-mEzANiB-Kf3-JAMmIJLaL4KgDfzHypKfxsJQMKiAIpIxOJJIPoJpLpMmI5MQN_0X1XBuN-0F3pN9mBLOLBM2O2JwAZPoNZIK2_V5PgO_lIM2wuJlL5LJIKxuO6LuN6JtUVNrBwOK0qjWPiWRJNy1PlPIMoPRKaPqTlL2SAMYOYNrDdM2jkN8OEynixJ3zcP-LH19PQBmLcNBJgNH0mODNDOjiZP_zKzb0uiJw1Oi2jOxPRVMISDIMF1MxTMlzTP9NjIFPxAVKJyDOmPTIIBDRBw4QFHB1BLzJNwLPFTcOrLPEsDrPOlLPK3LL9JbOjlBlRhrI7OPHOnVPBJlObKMNbKHPbM7LdN1NuN5QeL6NaX6QgTDxjP0EIKjIrMLJxOG09PmJdX2MrMDMmMMLZTDO5PMIxMvIHxJmLOFKvyNMbM8P3IzI6KzO7My1zInMp0rLjJLOAKNLH3vJPzbLHBHPrPHOlIAo_KrIUhRmHPnOzNAovMrMHOQrnNHMKlgohMsIQqwpQtwuG0XMcNgGcK3JoEtPfP7I5UPJ8LYMCy-InyPzPJdV-33zYt72oqmBvMjIxIP0n233otnyfN2KmyTPKzfPH0314srPEkzNpJ_OAz_LgshJ4qnwQqArQrLMmOEvYqIqQpIpgpGmT1ksMoUuMuwqgtQtUo-m4vku0rEqrNnLstwvaIsv_M0uctEunIHPctrNIp1MkuX2ywNLX2ES0v8qvOjlorksP2stcveOPLkJhDHW6ATN0ISqspcoCtdHwplLytiofMXNhKioIA3ySvyritFQMpir4tSo-KYrxN8ymAtHKgNW6HavzGgFpMCH61oByDQGZ1QHiCSGHAJG6A0WYULTwxGG6D8FYG6CU23Slm6FjQKDBKOymuwFsBiFnB-k1wdDQCXKWAsUQDxLtWOpzWlHdC2qOqM3YF1AUPNgAE1dD809gjhA1mdOA7AWAwAwALgaA8TPYJhNqg1xqEgUQeUch208Tgs9R8NLJ3ZHq5w3UfiWQ4BmMcp8TaQ9gPB1Athg8Z0RAQhzApZMhEhVx5VehF19BFcpgJJbtQdciIcFl2qfMTrRATzhMidBahbhagdvpd5XAUgv4jq7U7BPZ9h8hXIRhNhzB81tq0BySDtJjerNtkcds8wuphs2bitANOaoduaGbwwOFMhbEXhWIlKvyoAhSwqcrsC-hLbma58v4PVXJNsx9zak0Q09LysLambeapjI1vaNtRo_aw6_qMgsKg7MsQ6aAPbvrfataw780yLna9jhNwtvrMBTpXAAapTyAaRJrEcop0YXECx8Ri6bE7FWJBdftoIJg9EPAPNk6CBU6XFOqY67q81MYiVRpIpFy9TlzMdqUG7bbqAHF-cEr2rmqRsMrFYc7awHNea1UiAXNfU3MjsF7ea3SWqCsjzj7zyMSGaVEjgirotL7hQYSIqVzBUxwlF65hQEq76BBUqjyjyNMBBzoysuKDMwD_x31wzOjna70H1KAn1siMicB303SugPUBBzB8sidYxZBk8kwoYxACEljMwphyBMhcbshTNKxcHsHvoK1_A4AFCfQqp-AB5xBgA4GsgEGX0eTf0QGOGp0cAIhhIZwn1OR5Blx3pytMG0xUNCH2AAMdh2BzxOHtQxwKEx0KxdwsGjTExqHK06GGG-BBBsgWG2HaBeGL04NKAyEMx9A5HthRGMFxGPpto4wyKmKqjhMRhqB2gpg_7KbEgf0jrOMOItCDFOBzACH9A910BMMsxlruhAhggVC0hmGXVkG-hzATH_x-1B1ijQS0RGQ5oZ1X8rh0HgNGA04u4yMNlqoNlGpBdGACFgAcBmnK98ZHG6xJAKmuAMhxHi1NpN0a0YcY9_4e11gqcycdV_4_0FtZwBF2qrhJm34_02NsV2r_4IdbBxQABHUIQjbIARLnGXPnTGBZwcKZrwe9ARaXRnUXadRZwuHAcaHiARaQ059OKZ6m6-XUMASMe5-ABBrAc0XFMpdZzkARKEp_N5lBB5z5xIb535s5pZ3G2YbFCF3-UFl5ysqFj5xdL5n5v5-pNAT-HiGAeF7ULITlcFxqrFjud5pZ2F-FglqXaFdwREMlilsF9YKcuqmgbF-l3FuF_FxFh5olyWEl9l2gSl9YJ0-uPlmFgVxl4V_55F-YSMGVjFi1FUzknpOV_5hloVulh5lV7Fa01-QuKVrdZRYUXV-pVEIRgRPDXodWIgSA9YYYFagQDPGYZBG15ZlFyMIUb16F-ATlrdCRHYL1n12l4N21lZgNzPdZgRBrOLBLJLX1u1goARDXO68vX1p58gLN_3T3SWb3aNqZ_NwtsPBPKPMtpZit5kXPW3PNiaAthtg3D15t55ht4vWvC7NbNITt1tmsJ3PPGASNrPWth5-tjaeKQZutHLPWPmbY0ZmscZ1dOdJNyrVNmrIp9ddYQ5m55nfnUoxkK54XQ9sXY9FayVC6TYk8a53nI4Su_J8oiwEqvi9dvd1d04z9-dN183cd39gRCtW3QD3dv9msNFnV8DzFhCoDrlvc1y-DmsGV-4GDzV4gyA5D29K16dNLQt5m3N9KM1CiJQBtsPIPEpkj4AMj4dot8PJ0SPCKc6YlUjwt53O3Yji6Gjwt9ty96j2jq3Htj7Mvft5jgT9j0dsDljklWjzdMWXWfWQ2Od5hAOZQemMONWHlJmNQCObQKODmWOIxMuIUcdHoM0WgYSDiJYWlJIfULgdAWAEYDazJY5VuYuaBV4VAXYSpNz_OPACabYPBDz5pSADhSgG8NoDASZbeT0bJNCbm_JWxYLyPEztPGAc8VANbOuOwCSJYxWfkF8iwANoQREKtBB1AVgHAF2NyW2UUc8bUKJAADTq-dl1EsDtm1HPBvCiQAHEGDc4yv6k6Aqv6ukp7BLBbZXZauavWvGuWv6v9R2vOvuu-vCoDbNJSuFYKuquFCQs7ZzwFDZZ7b5RMAVqp4ZhXouI0d6bUNFYAB1PEZR1gBxe9XL_jHZvZp8LoZiWgC0Pzs7iIN7t8Kx0zmAR7iYZ717sddYfLjLrL1lvZPLu78Hp7zY6HjzMrca48eSAhWav0QtM0U6Osk9192sYYVEbHiKdoKeOIKACn18QtPCK4AADgUnZ8LSiCwCSgHeUgUkLRAbcAKPCmnT-wpYugynYGaemayG8heR1ml54dQiWBaPkj28m6dlFAaCSnNgaEcQa5mlogKg3VLTOUSimA2RuQs5gCs66BxQk7Y7S8Vky-y8eVs8SHs67Cc42v00C85UhQU_lRLbPDlgViVj1S4Go9h_N_GDKTSiNrB0ewWWkJy2iFcEedUBxVPwuhJi4BO64H4coEEYKGWmLQqsjDC4cUi8s0ILKRBwi6i6bTP3WDSdQdj7Xn4brOiOr-i6-XigU95gNgt55TU6DgZlDgJNAQwhZkjnZjAggm1l6_NltmcEsHeptkATi-IVDixHSMqlAReywi8bN-hRE1NgtithtntkdmdldndgkiX5X7X5tiexUbiVcFBnaBSDABGEQAJKiKfztAUY_fLWIdEXZD8z-ZsS2NbDtgOwnYNXZwKPw06MxMEb8WpMfD05sw9A8_U-ASxziDh84b8YLoHxj7cERmEkXtFwHTYzMUgUuOANs12YDwBEfQKANQPtbrB3-vrSgMTVJrAd701rSdsqxoEvMs4XAl0PC0_5pBKAmgLxksHaDzAFMaedSFtisy7YmCAiX4n_ErJocmW-rBFoaz1YKsDWMbHALOnLgZALWFgMLj3ybS6h6OvrC5hB02i0xkBocVAYXDASMlAI-nOfjHAX7kQ8BlSXeIQMLjEDQBDoeVFBz_ioIKBdCEooINtY0C6BDAvZosDGbQB4AY4B8GwMzYWo3g-8HIbM3WB_B8goRCKEy0cHgtGQvrMwYEAtzDt_ILwOyAkNMGhBzB9QqwdAGZw6ClW9SPQauCZbGs8iLFXwAU3Nz9BygpJX-KMM2rNB2Ew2ALuUN6GtD2hLWPDJAFOgZBZY8QRkHYFsByYWAdGcagIGSBnUlasQfEIqHxDw5ThdgYuhsOZwhEJ4kABcGkIKx4ZKgP0HYdnH2HuAQgArSTMplpKmdShE8VgN8LsCRhdQooI0F0IsHDY8Ml1WEZsIEDbDGc8AK4JlCyApBhQzQ0GNjCWBGQUYE2ArA8K2EQiuBPAqUAhmLShs32EoacOmzjZlYBMQoUaj0IMHHYqRweOmm9zvD0MceLQ7gSTWpGrhwKu-DkSYL0G6CjB-gkwbUIsF0jaw4otwnAHNgKwHBwgCDh8Q2b0CYAn3JgXQiDT6IVqmoy5n324gkDT-6rGIfYSoEtCM2RQmsCUMWywAzRTgkAdrHlSmtohm8WITWHtGDCkhmzfUYwP2brA2sKNGruwCW6NcN-DQOwBMEYzthMAOQT4eFhUT5g8AtNZ0bYFdFLDORspLUQogXCk1h0LQyoRalLFShsglkDpH0AxEOjmRq4F4TlEKEpBC04I9EZKJxY01FWhYx0SkCVHG83WMVcsRUOLGjisQW-WsfWK6A9ikWzYl1K2PiFBj2BLqLsbsN9bSjlhg44cUqPTiSgmhNQtoXUL4FTw7mu44QRamGAjAr4gQNRhWMnEBjjRPiU0U-PNFBQ4RsrFoTuMLF_iTBe4pUdLiZxs4Jxn4thPkNEFCjxBPzUGLrWsxyCpBMg6aHIJIbM4gBSolge2IEScChR3IzdpSJFE8iZ2qAFwcHBQHAI0ByLAeJgOAjYC_BuA3ofgLzggIwhXomPoG2QTkD7CBnXli0J-CYANBXtaNCePaHJDQxqQjQdQGeCR0xJdQiSQaPDGkT9o4QohjHzWa2je0-aeSRkGA5JptxsoplgqK_qxQkBFEnftvzQikIo4FCF0AIDol8TGJxnXQC6ClCuctQ_3d5O51PiZRrezgasQcg8mKxYAycELv4kIgAApd2I3DggCgiA4QJ4ZsnCmlxLAoocbgAGlnAtsS2O9XPCihbYDQBQrbEsiihXqk3XUJZFti9cypUSNyJkmabsQ4MoiQpO3ArTpdx2DU4WDDm0Tzsku9STQK1J1jtlTikSbOLFKFiehpC6A8pH-kCnCgBpTSCKahA1SPCjhDUpmGtKmiLJEoWEIaZRHYTM1rE1tRutQEy45AJpXsRLkcMWlDSCElST0F9GC7yo7sWrNonqhAYkcleUOQ_j6LgDloY-Z4AYrMnenpRPpF0b6eHBaL4BUS2pF6VkOhrxBX6V9NKGL0lYQz4GCyUahkCS4fBcOAM0_iHxhzIzhQqM8Gax0hnQ552n9E_nxD8BwBgZYxEEnl38nzT_66wUGEDNhnf5Q0NYSMFEJ2KscysrfcwLqG5E4AbhHmAWRDmLLsBioCkBYmYHfDwyCAq0nGW-JgADIHw73Yhh0ht5szSmnM9mphyfy8zc67AJQjW02BrJFqRsBkMeAYxTBNBjQbUHYFziVMcgtdXjDDjUxY5pq7AJflML2RJiLeeNdABGOEyDVsZR8GICtR-rk0yaFiHqDMFiATVkgkNZEbSWdnhZi64CB8UHKOD7CNiisMGnzL-lR9UmY4dJllhNnf4_k4KbFDSnIAFsC5FczLL9lMyaDmWW0tgN0BdKdyIEPNUETAEKgizaM5ABEcJnu5Igx0I4FMVNSyhbBdgLoUXDkE0F7DXxscpoVmOCBOsIgcoLEAXLuFrJ3Z3TcOQVl-xdzD5OtbbKjjXpXyoAntOuVxnPCSgj0kYLEAMgurMw25gtPDOvN0qV1IoJdPIHmCUx0AGQNs5Wv2A2pZhs5dgaSPDjTEbye5cc22XE2HDJ5qirgOOYxgpB8R20YTVBd0AZChEIEExXeZsB2B5gJQ-IQhaoDYBcBQgac5PCKS0aupB5WIJ-T0kAUj1E6gtD-VAAGSv9JY7_UEghN2xv5P5g848KIrT6SCf-iAaOSaM4jEjn2ZRI-u6TXofQXpQiiBA-DSjSLf4UuHIC6Wn5yz2ASkeaMUAAAkwALuVwHkAWg7F0_eQMUHYBXAHF58kWpKHICGY8gR6IxRkAfCaLj6ROJvOlQXCr1sqFgXxf4txqRgvFHpYbGPN8X-YlglBPpkrNplTAQ-swMae9zRkjyMZ7DZ7CVkhwzAxpBMviHksqUlYreesgKaFIOSGzalBSpYCNLqQFKzZ6UVCO0vb47AClv8xMpGFMzcEhl_GFBuYD6UlZ_pzFFDKfy7oDJeuQgZBO9xmX79hshfaKctC2UAKyR_9RJSR0fmyLOwafcRbfN2xukKlOKdLBdBOVv95F7QVCNUEQApBVlMwTCbyNP7cFICGqNQDcjdr6BllHyn_P4FVnMx4WaUzKdlNyn5TCpxU0qeVNtiVTqptUtyIVAADUUUHQqlx2zxAvoBStKBsuxCv9pYGqSMJ_xUR9AyuQA46WvAKV_onIIbVcKlxJXwBQZ7K-pGeCfDry3wYospIyv2XChX51KYFmvC_mcBhltYLlZyvyWzLECRLDIHvjKR_LmY7AbFRACWCCwdlvyiBN_XGz4qoAhK2ZWlCNUmr9-c0p1DT0AFy86l-_aEquDHnmr5VmypDNku4gqySZT7czo0oNkcyzwas1BkjNw4dKZYxM3Dj0v1SIyoA3q7yBGrfpf1uO_xfHjAG9XgN-C2VMeamu9VuNawY86OTDVzXuqPw1Si5HUpKSUBl2H0jIksFGCoBtiJHQnPMxrmmMuaYddqgIi57HtW1_4dtQPW7WYwu1aAHtZTO5pap-cwHXDlcDPDeqilSotdr2oqVUzmEhfUnF2tdVujRwBAC1bAHnXgt_AjMiUlcHplHrES3-fdUaOIVaym0M6hGdev0VNpL1G0OVDH1Qh7pJ6eABxNWvSiRUm1vaQ6bzRKadqiF6sqaGDmlWRUbsY4ZmpGBA3KKjhEGvphupmBBqkuJTfeEsDdRYaZJ2qucffB6AXtX0FWXrqDmZWQan6R6FaZvNYi4os4WG6IDhtmZGh8NCSCtI-w6VQBSNQScjchrGYnSZ6qAc6VR2TUuooN09KaOdNL4LFJOHUzPCJqFmrgoN7U_PEG2k1IZYoAfNSYpz5hFhUAbkp1M8grW0Bv17mFDR-tXymajsSsyMF9HfDkTx-aEVNb1NXX9THJvgzmNpvlRFSGgk3WMVEg34SR2gPmvzSFgC3nhNYHE0_k7Em4dd9QbkaETr1tjngmuHXBQpYDSjtAYttsOLQlvSnL8UtaWywJFvIjypstQiBoL1yES68qtsW52HlqS2FbDuGWoLeVsq3Vb2tdW-LYloK2pbmtJWiITH1X5JRRQk3c2LqCShdcYRrWywCNrG0TaptA29Saf3sAGg3INsDrjlIW35TMtq2-LRtrtjjbJt-UpbXpr4jZb_NV_ewD1mcDQjMtF2sLVdpu3Qj2JpWmPoEnxwTw9URmJtX-tE0WAoNZWAoY0AUK-bbYl288Ez2vjBkrgRmE3haNUlRa-In8EUGHjIx6pIqH8WtdjU7DBK9simrdKQLrKfxBQaUF0GMHJYPYIcOFcHNH0JnpBMgw1NHR-hyASRgyeOi5aoLzDWK7F7OlnfIFth2KYgx4EnTMDcUeLxgxOyWIKA4GUbhhwO4baNq23HbRQUO0SAHjvX2Ssg6AZnQ-Hh0Bi9MlM1Nabno5B5OdKOK5ZJSN1DM48xbKWNhkVk1gx5fOh8AjoiJI71Jf4fpAHnR3pQXd-O4qJGEx3bqIN_244HLqB3QS9t6288JtqO1Ta1dMOnHdOD10LFi03ojIoYuNlU66dfEPne92t3zt89dCPTJ3J931xdKgOQvautt0McvdUdJHJcuyDoFq9uiWvdW1p0lr5OXmmPtm0dTl5UZCG8DRkV-2Uaw1xtdGQToWXI7M9EkV6SbVz1EMJqPseRqzUxlQ5jdfevCOXkmy_Y6eUAFfbsEroSLm9klEWY7un1TBeqa-0pWbV5qTZ99h-4YUPtYhg5C0Ok26o6h5oD180haOOtOlBjc1uabqKNEJM_1eJgDMk0AzAB6UWAvANfK4NzXgPRc_97gfnBqkQOx00DmMDVKgdQD85dQ4QTAwPTiD4HMYhBkiR9GSKKwr4BAIZLpHAMahocoC2g_QY7Fp63dVo5HVBUUp6oVRhKCXr2gV2x6ct9Wnrclr63paBEWkdXZ2FqyVlNNnot7af3XzUsEKqM99pWX_VjNoJbWqrTVqERdaGtvWordIeh0a7fAah1yooctE97FlUnTPKjNH2frx9oeqfWduH7do592ezvSMtb3_gR2cmoNubr1p7Yys_hk3anlU3IJdlXepQ4NpUMv1cOqMz-todXa6GRDEO22NdtFC3bVd6wGQ0ns_o2GHNmneLpIGumNJ3NDEhgL5NhEEAbBCSFOTUDHQOJ7uwofGpdPaDtUkiGQOIAcgtC5xiJ-0oajADPUdlsQW9Zml1MkAtFZjCJCY3qxukjGt9WuMTjMec3G7-pIx-wObCiSr94VuxhoPYAym2xHEuoA0AivsCLdmtMx3QJABSAzRIxHWaMRDviPLbztIh2WA0HPD3c8tLW-UNlu-O_H_jp2-VHVO1BJRNtwJv49CIBPtAITUJu2DCdBOI7lDnxybuccuNFTrjzsW461pENYn9QVxm4-lrBNDbMjuofY4dqhNbaFC_XAk6FupM5TaT42-k-SdP7QqFCzgXzQ0FerJaFC2oTLVyZ5OWA-TxUw7tqA5MYnbYChKEw0FljImfjsJ0bfdpENymxTip22CibhOvaEj3B7urzVRnwaaN1ANw4Hr-3uHAdYojI5Nx1OjbE9FhztRwZrBQb4SgxDOBkLgBTHea6mgHXLtWNK4xO0anuWaZH2m9bDHu0Y9Mb1TtVzSxS1jkHso2_zrTWRaCYiehPKn_jjpuQ4wZFDxn9d_pz9SITXJjGFjXpn03dT9Ph7izgZggOXnU2bog-Am-xCOAj48Qfu8iUku6mjRk6N22NCOr2YdrV0TQDtZw6vhTMR6bT8wK4NlqJMkm8TUh1cIUYsPZUDUnZmgC1hAOR0tzUBnc8Nl_3pKXTRZ1fCWcVTjGKzsoWDXMSg11mGzZ-bvVGYk2sQ56LiWM4fQl6WnzUrpuXc-dnqUBIw-HPMyTH_0holg_tINFhXAuZ0h6EZtE_qeIzuBTpQmiTHqnHOHpJzxZyPTOasDpTuTvJ_k5KcLM1nTz7p2ZIse9NXnfTN5gM6gEI7BmHz7xjw-wHzSrTKA8sKtAuHsBJpUZ256NExtkn8WWLb58DuhaxyYXTzf51AA4kjC7H9jHXAqUcZONnGLjxJnE6ScsAMaezYBiNIJbAP5pGLkZ9E9KBeBV9G-hS5A030_Nj6Q9I-sPRnq8O2WF9hO0_qwG-gSRrB5l4YZZbQ6gxQYPlp7GgHNjMaArWqWg1QX8vmXIcWAYKx2PxJRWue4V2A31XQA7sx1HasOriFSt4BC0mwLfFcHSsD1uaeV3vFDq7AFAcY_PY8yRbyxSWZLQFty57W0ssIfo4cXS9AfAvhwDLcF93cZZhBqT6Gsc-1HdVRnjUhrzNMS1lF_lB9046osAAQDcg-AJI4MJYEhUX3xWbgkQUUFvkWtpRQYY13uR7SysTAlgB1lah7RKuEBgBzFR1k6HCDdBYA81ymjkBIyEBJMYAdhImJHCYA-wXs9wMLs0wsA_h9IRkOtYiCtE9YBAdowIHxrnEIALRuAG0Y6OPhwbc1ha1gFOtfxzrYdZowuCiSoAhjpNViK3X6BYB09MfLwJtaIDbXe80N2G_2HhtRKkbMNx8JTf3k03CAi1zG-NZxuM2oA-Nwm0cJJvw3ybp_R61DeRvOA6eeYDFLNcht030AgdYTGdeGtf64A0t9a69Ylss2pb8QGWxtfZtb4FbStmdFjdVteJ1betybP_OiBgIWQVAVBnsi4y8Z6EWIbgZkUv3k0RQeAaeXxFSxm2PaE0QW3vjlvzXFrot5HfsDwCvy_bptnmwPSDtCBiJarBeFtZ2tk31rPlldh9B-De3V0GoH2_ADcrJXqVaVqOzHeLuFpFqqIfO97d9uIVkrEoGu-VHLvgqwLju2XVhenMRRstGphU0qZBNwmcz8Q7KuLYVu63YAbwzLFrfHvS2p7wGHywhn13ODA4rgtCOUcP5ubvBWA6OLUeM46qYpKseKYlLKFDTdAHre6nBHohu2fYUASALjQKDOcscYcC0OfeVVDSJoEALZpPGni41JAn9rZkNIordBKkU8UxH_eAcjHNgWABxKKBSAeAZjy2MdC_aoAXilppcYbWKfsAsm8puR7I3Nt1ACntQCWoqZpdkazasHOD_KdlPsAEOctFsc8NlMlMkP0tdx6gA8Z2PyXLjcKvB84CiQ3g1-bkRh0sEf4im3II22410cannJ_r6DqYI_1X7r9zwhCXfi9gP7lKUJIx9hAMjGnKMlOBAGLugkP7HI64e05eHkrQCkbIgd8Tfv_ZiDIOLHqAKx0QDvh6mPjUwELeDtdhP8lHmWzx7N0Uc2xpTUwC7d48CfKPGTXj2ruE-CcxiRtpx2h6NsIc8PspjsBFcNoUL2BteHXIU0FpdiigEndDlJ1N2ylFSMnWTpE1KfgvuPZGIhzB8caoe5G1TGvChw05SexPstcA2_rVxSfNPr-8A7x-05yWCIdQ4A06PLClDCgKLKRoFSFGZVLAugYAAZFEhhu_y99sznjTSthxZxQS3R0msKDfBn6q5bfLuo5C2cX7mL9j7OHlw2dnOkIsOL05rb1jLOYb73RZy89pLH6m9OQeaJQQl2gx3nECFZ1AGuvrXyd0zvgFkS9MhHrMdJL07pXlmFMAHlK6XoC9_jAulg0vK53ACYIS60XGQYF3MosBjyys0vU5_M7FFenV0f0Cixuk4N2G-IgSMaajMojJsmshYAqIIZ0M4X_HYT5_pDoKPmHczZWNl9uxysyavkr6xIzus3XdAa1lUNI9-ltNROfHNsMw7IfiEvYbDZakZ2NL4qozg98-2gNYgUOdZkklAawHCkntmr4gisaazHxAZZ6J94OZdS9i5ZjgsslUePuvvtWwB1rpz-pWvsqjbLnAsRz20EuZk9Bbn5S9eZNlS4o6WaMYpLGGEb4sobKplc6MJkijs8FIxaVLgJjSit08AKbyzGm9crEUadmbqKDm8qLsAgsYh9KaKHeoLOmIhubs2Rj7rT4j5_YSgOyKYxtB8aGC-ulLp9AzB7SJdWAJLXIA5jzZj6Eks7cneShkgCIKLt0ILmOy3ck1Id_KABv_LsAXET2wm73dLW9NF9mst8w-uJ4QydZUTB5C2B5jqAZbgqjQEgrBVwcEdqYAJmPc3JqAZ7s8Be_YTZBoKt7roGXXyCPv-D-gCtx5XfeTZnbiSj1xADSgKRlQnAOsBVn5LIEJgqHiAJisxXoFdFAyQxXou_ygwIA119gulAjciKzlksE7iftMXkFqPpy9_got_7gUgBeTDRZAxAhoBQb5-HQmwsyw0okk9KC11RixSs7o6ZRKRSR4yA0fWPX_RReBUQDAP0AnH32tx4crpR3eDiS1wvGteV1R0q9QHMx8eWSw2Pqn6fKp4k_wp1Pai6T4yDQI8eaAfHj28eTxLhZ4F4wafDZ2RH_UEpfEeIM50SABBugxcj1yyAzmH8UJRNYiXiUCBxBQFMIN-eu9IPTBcF4e4GqDRHh1lYRrwqaoNQOVGMXU9NDZwRhRHevg3ga1AJSptXf5lBWqsaN-Mwkhuw3UlSMF3Qq__VK6aWG4vPDGDk6FGL6J8Act4xM4CaUpWTDjQ0cqJzAzt8CgXPkicbhFkfVqvzSsANuRtzb_jMxDjluoO3Pn_FN27ZE0AiQYcjL0iEl0i7pdY79nBO5gBTuZ3Iwud5oQXePel3MIBKFhj2TOyQ5m75INu-8Z1lj3B740u9rVEffp3xH4RSx_OWme5PDkuHxZ6U_sfp8BGV4Zx8rrA_jwoPumuV-_FYVQYUMNRQDXVFPfCmR79VQVZLZ80dFBPlEcT5RhM-0otgcn59_mhfvqfX37xRgUDeevdE7CClZ_z5UXU5BByulVFNDddfvxcxI8lBvYS7qTWJWQyzq90-Vl9PkntKMA5xSGufDJrhCr_JyKVQ-KSZlw05eNdHfrDsfJz9KnYB6R2eWmqM-r_UN8GtD1l830a4TPfm2E7NE35WTN-r5XD2OyD5Kn3aie-Kmvuz4H8PTB_ZeVv596fjd3yp3eAyXhMXPA-2IyZJWFt0s_IVRvGaNAXroj5W_6Kf5Ye1LuTuZdBu_XLlviAG69c1_YclAHZR-4qw2ObnhfggMX-EX7x1rg_U6ESs7-W0xpCnp5d_1_5qOgB615H8XWH_6Ae_Mi8z64HWDKgqVgU7IMoPaAlVN_yFF-W_JxQvY740qvDGeEETNLZx0QBsXYFJk7_0AdYq__OO-V8QQaj_65_xjz-_xQYti4AEf6zjyAH_FBngBigCj3B9T-fFwEBq_FjTf87AQHFf8gAxIS9d5oeAOv9pmSqE5koAO-GJFMRU-mYt6ZQAOv8zVVjQzVaSOAOICb5LnRyAyAmAJ8wIRBF0sVn_KYHd49XSgCSgEgAgPnE0oCANBg__eYFBdSvGPgH9TSL7R00h-ApR4CSsLAIwCsAhgho5GAguWr9r8WfzfxZ_Szyn9iRQHFUDUfRAHUCJAk3yzhcXF0jkCBA0_gmpEsUah1RlVCxHe5KIaXiECxpTF2aZNBBwKl5mmCAOZcL8X7DFliJCWRgBQvGlASBzAmgEsCRQawJlksPOwmypT_EcHngMQS4VS9bOVOTKEKsGBVGodqOEBEhhsbwNJpfA_wLMC7JBa0HArAkNkeYRVA_0EUggwoPThlVRIGlUdFB1w390ANEQKYJIfIIsCig0IPgAMAyoJCCRIZnzWsjSeVFHQD9NeGaC5XIER6COgmIC6CsQSYOqCRQRIGZ9UYbAk4kCg3UEGRr4fYD2t2gWIGoBUiIdC39dg1AAtABQCWlUVmWdjXKAKggoN6Dag5PHmh6vfYDB8iceSC0hRqZ4OAxUuWYIKCCMGGjGDm6IrkFp8A4gKM9bXboA24haZgMkDWA9gPIDHPcEI6hk8KEJN8YQqAA4Ds4TbGM93PMbG0U63IknqV5xD1yVpggH4GgCEA_zzIx9hTABoYB4Z6xnQYAPEEpC7hUTzYDHadhXlRhQURDQB4gHR358FHfl24UK9HbEfAjle5RMUTuLukX9jFNb3mVysX7E5DZIHkIgRmXCgIt1T9GJVaxhMZ20JCCAK4BOAE5fjDeCswL2SECBfboGJDzAZ2X8A5MPeRNAogM6lQdSZXeBqDk8EZVdDjSDZylD5PZQIhCRaAv0tovQpH2X9LPe0Otx-BT1huCpgxICx9Rob4PaD5gzIPYUWCXEI-g4wmgF-D4gMYL7MEgd0NogolLKndCLANMIIAMwqACzCJIBUO5DEfMaVBgjQggHWCf4fYGZ9iw24NAChaXAMyw8wzKhTC8Q-71xAsyNjHmBzAC0PJozQ_qwOowmf2UrCYaRTn7QWQfVG6BbQuUHXlQlEYTOppMVYFXpZMYsNLCswpTGHxPhRahp5aSdQAm84AbYAgBvod3i0wkw3sJ4wQpMsXQBZjMcRyAXsI0FJkNwzQXdCdwqsPLDwOZPA7Dl6fMJypkQ2AAcRWQ9ENy54QhglAiYAcCNhCYAk7ixCx6CrEqDdw74TShYI-CLRCQQ6CPmgHwmsSaCMIkdGX1Rg74UFwuw6JWTxUuTQUcALxOBw8Bi-I6iC0Pg9uT0wIAshAvESAt_A4jHQ6-gsxvnFCM9taI8MIYi0oaB1gd4HSMF4jww1cPDQIEOiOFAGIpiLnAJIH_xEj6I-BzDAlAXnQUjRIrSJSAdI-xT0jNI94A8A3FACOTwfwv4Iwjlrd0OeVD0QKBFpJBMcGUEUA-cQz5XhZKyJx3I_5k3F74d0P3h-oc_0fCswzbHaBBxViMFp8IxoP-DbwiwAKtYo74T-QAURECfAbFerksgeHbI11BxtAqVFBeuG8GUENIpSPgcVIpUSFogo5oGGDD9MKNGgIomgSiiicZANIidgOKL9CJdGqLIj0RFKPAQ0o9oAyjzwLKKShcHHKLyi6uQqOKiTI0qMYiaBCqPKw2w4DAvxKPa4NGp0I9ERhdJFBHzQjfwjCJpIUIqv359Do4NyF9avd0JF9bVDDzL81AMkDWCNg1oHCBONOYIyDFg13CLCoAHaJsj0RZPE0VAIiJRJEdRFvmOdzAY6Nr8mzUgRgYsQTWQgRzEUoWgBt5eV1gBc_SVQjdj3e11cs8xCuAkQRILgOedB5F0WSD1FApgeCCYv0Al12gH4BdAwfMeV-kEZOr1F8ro3-GPc5BOoieC5BAmPhiRISXw5jsYu4JUkoUPiDtQl-Ij0RiWrVGMWAP_AZHRj6_aN0b8zQtrzb8G_WAFBklY_8FjcawSvz-goAt12YpCPa6OwBAVLvzGlECYUOPdblY5XFDK6cWLb8I3Q2JH8SsE2Mz5RQ1jkfk8-K2MR8Qla22EweYpoXWBQY8YIiBMQZWJhjMYzmMSBALLWJz9JY_P1Rif5XfXYi8Y6ULgAbwcUnct4Q9AjHl_Yjuzr8fGROIyBdQRoRxiJIDiMPEy6IuIEjKAwpmAUrgEuMLicxCOSLALxSQFLjfYslALAsoKj0R9-GLOAI9KQZrwSB2gTEWGx_YsnUjjKoQXCtVhferx6RlBWOJuj5QOsK38NhKAAtAW4rmKoIIAguKPERITRUnjavC6Ia9S_JmOZg5BRePF9-qVePCBoiV-3DDJfGSIvFd406PpjLoueOwBT4goKXiL4viMl9RHPC2cBxHernS03SDwDNBtgPNVvQ-4mnkrhB4lz3r9ww3GM_95PPiIYJBFYRTrDZPNBIKCRfSuBviLxL5QKwR41LDHja_InD3jn4w-MZjglE-IXiP4lmJwS146MI3i84gQC3iy4vmNISn4g-Jnij4qhPnj5BWhPlBr47-KoI-I4BNATwEzcO6AIoxIHLh70GBLXM9MMzzkU6PBH1h9gw7QLZ8QiBcBjCMUbjw1D5ULSEtotZOAFhj8xcSGTx_YmsiniGY1-IxtBEzYPCAt_H2PXjh6ILVJjkpInHlQ85KJVMSsYhGIspYFOg30UTEzGInhAcDiNxpRge8SiUTuF9kKZujUJM4hyYymI8TysQhPpCRgUfyfjk8LhMgQeEj9GoTHgxxPZjQ43mLpVqIrRLHRfEsOMFxNFX7AiTbxaJLHQuPJz1xCQEiUDASjSP6OHjiE8YMsTOE6eLyTKEgpL4Sz4ndwbRV4uuLvjmE1hKaFa3FaPvjSZVUNCNFydJP6S6Y3JOwh8k5mJoT3guQVoBIiYRORjB5URMYoCsdpNcBOkr0g29zwa9idlSCT4SXDu3L2VO9clGABNAQEOmkgSy6JCD9Ah4ghN6TR4zJJKwJ4gZJsSPYwpLGT2gH5IrQYASZO3jGE45N_hZkneNBSNkwZK2ThknZP4S9k-UBhSwiO1hJw4UhhOmTEElhLrj5kjr0WT-IxvUoDFyW7gvFnomoJh8l_ZRI_5tA0MMUiIw-MJejOPF0mhTCMWFNwSDnQXDWTekshJySMU2eIhTRkgRL4imUhYO8jgMalNqSzkzLAuSrktKmNJIE9CQyB5EnpOBS5Y9ZIhVSmTLE2TpUrWUhSBEzoHBUMgeFLYTyko0k3i641xnOTxEgTzE0xnXUOdoNUvNQCx0k1PwgR0_ecUz8PMf2KRS9JYZO2S445ikzjek5Pxj5tIJRGdZhYiBDJkoJeYAY0mYiWJYElgd_kmscrC3299eJB11n0i09r3jd-fSmUP52Vf11liRAw_giBW_L2JCAuwFuy2ddCCcBOB4AaaE_csACcJvg6fHKlVimVLZzgBQYTQQfAHPWlLVCwjeQOpV7nHtGTkIoUhX3gAYjr1XSdnSumu1V-bhxGjqHFfn4dBHRh3r4UJGEmZVU-Ojwkh3-fzBXpZhMGQzS5XUaB3TgsYk2Kc-HAR3eohHZwDDBbUpNWyoF0xEE74xIZaxYFFothAvSrnUKHCg0oKGGxgjICRLfCm_MhKpVmVTFMnT0AKggPsbsXjWziRlEdP2UnYiNxI5qPN2NGgMM1xJUFZ0gj0BlMArdPKhH0k7hfS903B2ykP049J_TkJOb0KZHHZxzvgg9NPhWgGMjwD78TAmpUR8zVWUB2U1zeIQwyWsQDIig5M4bGB0sQO-C3MHE71J45hsOsJwCaReQMnT1VSF0EJGM7dK4c30_dN4cj0r9JPTdUgQEFx5oREWaBbMskHCAQgccHVVgoytB8Y_09d2wBEQPeFJIHxIl0FoCMxkllkLQZPGAUIs9kPrS1Y7UhFoM-FEXNixQvPnCjvEsdH5Vbwv5A9ZFYdryFoM-DADNjnY4qEfk107H1szMsl4P9CbGGNzCyIg9gE6pIoVcCQz5Y9hF5VLow_h5UpUiHD8hw2bFAMz54_nmGS5fSbAV8ZYWVz-wFXHq3lQ7UaG3KR_IGAFTT6CPVE8YBAebMBQlsnpALS4_SfR99mLR128NnXCtI9cWs6tPKVa05ilWz1sxEE2yhQsoLFUrsylBuzzYKWLD1PbAJAljD5WiAkhHshbNuz5Ao1TudnIVmjHA9HPmAmcDkCi0EVR0-5yWBfsjbJezB5FgXGxTs8pQGSFMzFK4AsMqTNDdAc3DNlD5UfalRACgG9QL0QUgrBrJ2shr2uUm00N2uVUIZLJdiTFcbC8Sn8cCLbS59R-UIyksxJXz9p-OoOYsMMtKC8UGCcxURcedYAEcVnFSXOZhxdb1F58PoMeVMwicw6hSBSci4MZwrgijP8xxsdeXZz0AUoIEBRVd-U0F9c7-TUABcvDG7S4AXtNbS0xBjMgAfAdcM2BYRIjAyomIbcnxJXMicH7DaSBbxdyLIFTFxAjqdtGCyPoGiIgR9cgxTZ1I81gK7BxQsxXVVxc9gB_8pclxVlz3FeXOGx5UIQMDD4-McF5DKoMHKH4PMU3LjybMHQnDcJM_0VITmmXPJL9m6WTNjykoLsFT0jSBTPlyWsZaN7DZMBTIAFphTqiECvrdtMXSuAYbF-wuFBTO7j5gE7j2dJnKhHpSHXZlRFiKk9FnLzUMrZ37y9U6dKozQjQpjz5PFZvK7AN8-5y3yqEcDNrAI3E_MRAz8rHxHzEQAZDOTJ5WEQkwHbUDymABIE4OZhs8mPhVySc0gmQyusvlTdJ5UcnRBU2gdy2GSx_FHxeVvAN5Q-Vp_ArFAK_oS1IBUJIP_NnBHYjACvhUQIrLuV3Dae2BiMk8AuQQTuUrJb86c6AvZTYCrAHgKICxAs7C3SVHJOixwKnO4Txw4nMwLGSXrNiBsUMAv1i7EobOwziMg1RdNO7U80V8Jsl7BotizF31coilZdWN1Q_U_GmzAZF-nt1KAS1OJYy6LIDThwkVej1QDpZlT1178tNQ0LnAAAEU-sTl3cN5UVCEcBmpVSJ1h15MGA-yCrYwolj04RpExFyoLZlYFTCg9BFAi-KwuVh5AYkSPI7C2YAcKHjHrD6x0ChKEwAesY42kZmUaKVeppmIRl0xw4-wvYdREOYnpoNCpKEpiZEwYC-hgXNKHqdsHYp0SdgsIhxYdLAXqMBR0omrlW0FCSyEq1lBHIscLYi2tzjSxgPQppAcUecXvQVqaVRBphCOICCKii6gBKK8gMotWctlSGlq9pIkNjezgMepKEEr_OwDEAJIB31zdcQqBn_BnOVBkjBigYMm2pPMtNOOgMhHIDsUFMh8DcVVwgYsVg_kZO1XDM4udAojBcMeQ8iUJPLJGwac5Wl19BMtYsVz4AEYtKxV8jIHeUIC-0Xf5BQmEuQQuAV3HuL57RgsPJrlfozFVJ0AXOn170I4qlhavHEoxKXTcGNP5RWVlgHRaAQIoiBQZXnO_xtsotIks8sbCwih8nQpySdGnVJ1KduTWbUydsnBrmHtD8uuQZz6SiwXuVB5VEv3F_XDQsgJni9_wAVRSzQRIz1CoIq0KxWHQtoB5SsUq_pFY2Uqfx5ShLFlAaQNKHlK9EBIE699S7_ENKblANhI5w4LEvfli0keXyKrSnpENL5S1cH4YgS6NW0KqS7IBpLNCp_AFzK0uWK98k-H6XOzZXH_MWVYsqr10Rac_4txw_S7XUDKTY-7PflJi2kv1VQSsAL4hsXWIoqLWnKoosyaHOhzFMbYJh0FN6ixorSjk8AaJ4capKkzcgGgKU1dwsyoMuMVNBREpTkFc5vEryRhLoFSjugQ-QUy-qQsGLohvMcv-9kvbFx2oPZfEmSBAyymhmLqDNTCHBXYBoBWDT-Kvw8K0oH_w7LhFVEqcUKSniH9L0AYoEFxmCwXzpjJUjHOUFdyrZynTXcbDI1DHKaCTnyDkJyOFpsXMGALLesJVLkJNFSlPCo5Yw_kLpE8KePvLQkN0oclUSpggHLzZLKCuwSFZlUnCJqbt3-8XOPIDVozoNIC11YaHtySAcRcwGxV0smQldojY2rOfkMynFAjdo0i3NzKVo6jzHLK6Q8slKPCoSLHDkMsFJfiZUt-PlAFMyX0fL7nT2NvDry_8F4qKE2xLkFZ_Lfwn8lFezxgq1SjiqfKK828PlQIA4XMZJhQxnJKy_kMlMtjRodiuMUpSgysfzxK_nyFjEc3-EmykYqAuRLo43-FXDAIwGJPoQKmq2EJJC312V8psnXK9LHSnFBxLcyw4pwBjioksXQvsHqy4NPdcJGECYAeM0KU_pB-FTjoSD3yD8mSsPTwxbeK7yoAZgZIGCiOSOkIJIj5eoGsB9hfYR-ApgUBRyAWAd_MmoPAZ732IXc_BhSLjQmwA7jqASahTE7hKUkMS8wN8OFFSacQpZLu7WczqdiyrkqFLW1VUm_xiLVM3fKcLTpxv5ZuFJ2mrUOfXXWt15Pa0V43pJ_EcDZSVKsZJRS0In_VXA2UnnQAaFOKfh5eOJIKhOQfgM9tJQ82CBz3_cMtNpw4GtNlcFYmHLK4W01B2aVu3akPARaQs4WFBrs-JlcyqqycOnC-wUcvJzPbeHOezQZbnOZxblHMpdjOFWkmWTUceOPSgkaxbJsqeFCSjKw8MFvKbR_ZQ-W2qJaOyUnC4gVemi80K34WOAKMGyE0IuMnGmZUlNOXVmzwap7MJrICSMAJrbsmQiyUbrPOhZYzy7tCeTtq8LBTESvJ6tAkXWAAtKqDlU1L90MakrMHkQJZ1liSZPQHGerXq8dK8Ud8hj3WBi0dZ2dZMPWwgI8la9MqNzyg5UtzKoNJNKVrbsnUr_RH0rNPk9HKruVzSC5S9NcBRCktXWsDs8tI-q0AkhJ-ITsqtJ9cqlHOOqyQoWOuDdEym2MR8dZWLMFDgs3RSNq7YmrJOi0Mh_Rj4TKnpAcQNUFMtoA9rR6t7CbqMcpHD5a3nz-lDc43KGLmE6VW9E9y4uOYSTFf4kNq0MngI8LiRHGq2juoDiPcS9a1pIUT0oDiLEVh69UKvLk6m8pNTr8-AGUFUSuQXf5JfbDJnrBM5JQvkE4wypYFNo-esGCY-ESuByRnYvPGd9nP-C9NOvT0Jer-6-CojSHJZHIXqwKtHPRToK0wufKpfCOMyT8czsL9Ta3eD1S4kPCSBQ80PRgGGSf8CIJw88PGjMJlq8mBrI9FojurUqWU0yq5qxM3JSgBXq4jyNqB6tSrQaY-IXL1QlE2j2Lo56qgO6gKGxTwUquATCQYJUSnQk0rmE7SufknY_Av0qyMmPOzTKUjYrJT6PQSOdoJ8ruLXTwow_URKMAQ5w1DbrWxHxKwqwkqfAqatNOtyDQlXI3l8wPmoWyLU_VVVAT6GMsOp-Pa5LxJF5eRi8800_YUVgBAFahyBPYQMrhyOq_EGPAkLecHpCwFEcFPLNSzahMsiMJGnax2AHrl65VoKhV2BLG6YUqqKabxqpKipfriB5505lUDLLCuIoqxXqqguPqaGtJovStAhSo7LUiPwoYKN0pJvMKQizELBC38BTOSaymiuOoznaPDC6rThZoG89x6z4XpkDQhJjpBJanxpyBB0mMvr9YK8uo1Lzy713YYS6-uCGbKS7XWZY1AeFilKLFC0Caz966SkILDK8eqJiEQnMnGbJmqWuGoR8LZtgrEbSgB2afGgrJFDuGn4l-qYAaPNGgpS7On0TDmsuu6b_S-JSPQjCtSo_gSmoIpSaX6otDVTgMKODc91vUCpEDrKgZDsqxYruMcqIAsWpL10ocZqOaTml5pJrua4sxiasgNMqRIEWp5orqXSvDM8rn6GVx8qIWwy1KNGYaaRT4t7VmHold7Izm1gCADwGqAVYeiBQYwAb2GqARjYPnGyZgDixCkZjDZGC5fJdYDnJYAQ0qTYX6CkDosb6pKAFZPkGsB7LKdVwAOYuwMQmPgM8dkXFAIwIRkVbxWq2jqQ3IOokP0dWr5FsckHUBBaJFjRVq0dafZnVCRGORPGZ0NjHqS2NljJi3lRJtbUBy10pE40y0PWr1sylYnDMzthoVH1qC0g2_1pONYnRbl1AtTENoylMtaNtjbvWjKWek1CvVp2BFWxLHrh9bD-XeSz0-yyJ0HZCgRrlS2ZdECREgN9AwArgJSCPIJ8vNu4zTPetuoBHmVjXQIOa1ABbaaA_fzFVfIgXMiF_AaCly5BcXyJjxig2AMRCjSEdudDOg-pCoBhQHSF0Kpg6wP2bJ2_DVHaZ2shHnbuQrUqXb_mAG3Hbh2tdunbpg2duEABABdp3aEw6wM74RdegIVllm_mQHbidRcinbd209q3axrMdjfab2_5m7b35RVABtcSjrwA68vaBoBsZeU1B7DwOhNzSgQO48AAi70nKjg7ugYqHA6BMLirQ7ULY4CyAAbSyK6S96oCoucSXVcHbbC0AG275zLP8rrIIOsmkw7MMul35iVZVVu2BGjVGXbbpYqYCzsMURlu8Bc26QTm9i0YjpdQwraICuAfLUGGTBkrMKwYNxOpCk55XAGK1E74rGvigtVwRKxk7zLJnwY7N0PDGUYNifozAVTid8IEAogKYEMT8gWcB1d_3HKGY7GjSyGFBTOg1zT4bOLsAA8PXDyzBCOO673GDwjWnyuAy2orArbVwATGraGO8N3eTs7GVSCslOgLqaF5OxTu9SLQWLpEhOeIKwYNkuoLuE6FO2KyuAku5qUC6wu4zr91EPZDyw16s69LT5L0scGo7iyHD3Q9auzgAQbJKHPJw68vCrslgqugG1Qb_iZDvQ9oO2n369qOmDva7qu-DvPxEO37F67UO6jvQ7naOjtg7WusbtMacG7swW6Ouvi0wBuuzij0wsaaBqkFArd3GiAbifbpE7E3N1FvTgIy-UYxioE7uy6ju52lu6Eu7SqHSz6F1BojmI7DvW69zaNC26Vo7SDc6WadONEaduo6mgb9ijUKgAjqTFQkhkwIyHvagGj1JWjIeucD273kg7titjutHuk6nC5Hou7uwy-SOoburHuy7ZwTHssZ1OnHss7EekkQbjuCczjTxFYRMRdz_rOsgmEB0ZijrbyeknrnBOqE7rS65wYqGTBsYJSEBx_u4GlkxQQzKgziiC6zpDIykOzoc7ogATMlhjpW3xDqndIgqB0SeCgn677daxBm6MAZKykFtO-KHzYpoZPWY7xVHYDRwx5GPyxwds4tLKx5UD7KWB_azDXqNGjOwTDxvarQQQo2NcMLzTzlb7IGVNUw9zLT3q_4kpkU-eEt0rcUEjlz4pPCSEj4bic_Q9T5Alc07BIunTDRL16GGxaxMNH_IvEWsTyxr4vegPAQx5A7giER_ARVu186-Wetqa982Anr7zlGkkr6ykavrgByipHBhtMmt_CPqBKXIF77woj4K4oO-mvpBLsqDPoNyxFdrpX8Csafvr5WOw7Ns6vLfNIkTAdZdKuA_WuNtuiNXP5tlCx-teE77a-_uSr7_AYFxT7gY4FrzKnZcvVbLRm1HXL07erKCx0KWQMh2dwo9ttkbn8vTtA9tdEPtlpFeu_ueBNCJTEGoIKvZpUQHZUxGe96gn5SJTzAG_TbUN9IZnGYBygxONLGep10WNDSkQjz7hwddQLk-KCitlCLAM0omoSuX1EZ7bSmYHtKPgPLGPQSOF0ohwlioYtcARgS1pBKCCgFuLrJW2vsOyGcCUClb58mVppoPMTIE4GMhRVo8qRlUzFhT3ARVqAoUI1PvCVtyviEkHmOgQdSAPlRVs69-B5zooJ6yjbs4hXcGnm-7MAb8qJx2gZDqsHysCKM0xV6swcWot8OwcywIo0RCiA3B2sAQqyB2_p-hpWgEVaCVW04nVazvTVunACgPQc0GykGQfUHOO8yydddQGzvl7zLezpM6lemIbXg4hvwZPNRq9hWB1w23foCSNXf5JFpkS90LwlOlNVsNbshtPjg1AhmmnmiicKQUaMxOqK2N7Aorvkrg2h5Tui4f213EE5ysf6I-hlNe1u91cdf-hd1tQJen-jKIgsNJExwOEgWKjSb0roBW6wWT2yicDYsSEtiuWV2LHfAkCEBBvP6GG8p0FYt2GPURGwbR3iogt-K5vJMoBKJ4tgeV6g6piv8HWXJttQB9e48Ao6a-ZWBX7YhtPizbFYR8HX72QtQob5_hwEbXhGjV4dXCFqn8vTM3ISE021ih28On6yhv0IqH4oz7tcA71fjuoA3oy_PeTGjYke_Ruhl0DJHcwwYdXDfsEvui4y-zsAw6pYWpV5aFwfVHUr2wiiN3jAq59CTVWOUKvCr-RpegsACstOXt4LoMYfr1mdRJXv6Zh7-kd0ySjQdbcVqZjtRluCEJS5d0jHC0Tbg25NvVck9IHTKQ28j4m1derBC1GNmOwpXBcjO5a1xdEzPX2dcvOi4mtGnXRPgjro-tPgbjtIOkJup1YkZVtG6kdAiDGMBP9pxRQx7YD7bSBE0dZ0Mk5jp7qkCziXBJ1R84hTHTiM5qz54-oyt0S14MSrYj0oV0bj4vnOlLXooNaMjKR_65jtmGJuvTCLGO-ZBKHwaXOvlESyxqcwKHkR1Ef1HMpV3ExGew-0UjGTFYkb4jqXTgZbGA-gCMbwCOp4fV6kKyVpaQtsGqsAGCjdMbqRm68oPrHretYo7lIxuwH7ldxzMbj6c-HMalIXuOvmT7naKDR-5DcS3s3HtgZnNYI3Kle3U4LJOZARJ5jD0x2lbEao1pb_BB0CBoQacMGchQHX-1ngAJ0GgChl4ABx_twHWeAAcP7YuC2Y7wGCZnh_7RCbvB9pYVrspRWrAYCj5WiVuEGIc4UDEHr4OVqLDdB5zqwnayUVtqGM2yibJRApdkbHRRMNRAelPQM1o_HyLaQbT4RjRBUWMkoNUR90LpQhAtb4XbY2XgDpG1vL07WmUfL0nWutBc08kV1qMtLRv1qERzwKE1WqLM31u1BPW9Sc0nBnCzMDaURpE1th9JywC0nRo8J0y1w28ycsn4VGJ2qdmLP1syj8pQ7nsBg2hhx0nPW1ycASPJ-hyCcnJ-VAq19DTrW1NGHJ2BerMtEKY61atcKecBIp5wFidPHOycMnWMvx1B1JuVKZ6dSyqNra4tTbKcacE2_KbthCpnh2MmuxsyY0mLJtKfhVctcQya10tWFW21PWoqW1BjjRh3MSawBExMnNtMqYszRDbrXy0JDIrWanjtVqcFMOppKaCmY-WyeqnZuCsoid5QOaYMnauRabymbYG_iqnVpgKc6mgterk2mnYbaZqm1phh2mmLRmp3Db49Brl2n7-Zad6nDtFqdunYnGKYMNJuJSwykbpxUwSnzwVJvaBXpsKY-mvpiKd-nYnXYw0mCpAGbimgZz1u-nIp3bU2nIZ9rTensjXXhONgZn6fNhguYwFMBzAIwG3USB3xNgB_lXgrsBOqdcA2pExOsh9gjgfYDIwG0V0C9lFvBmbO8pvV0Ci8Xc52XPhBMPGfYB6IQxJ9ALAYAFhZaIblgfIHADZ286aZvYHusjgFmbp98Z_malhBZiiBFniB7QSsAu3eWbZmswDmYesIECKN8AGRMjBpQqaAEWCjtZ2FlIH2ARWZJc1ZjqOAwSZsrkBEM5TQUNnmZ1UQ3dIkljEm93EooF5AzAM3rtp2ybQSJnrmjAFJm5RvskT8fekgZu5i6jZ13wzdNnUQ5E_V92gp2vMry79d8c6WFzU5nlmLsM3NvwYVnZ-0a5ZI87QXXGxVZQvNzsAdutIFKyZOYT8C5kNEr7KyXOYxRMKZYO26IsduYkwdixOovA3CM3VgJG52nzrB5_GgBzmMAYUgjmyuV5ujULc4BqBiplMJkOF4AN3Rxn_Z5PQGRFjBrOT07hcwG-IrnHAH9nt5pWcyA5QCiEHFRZx9Q6js5bxUVmBZq-eAAhqqUFogrnRwA_aBsTLCuciwb-fiQ6IRZwgnVqDIXPnn5oWZvnCB4IAdmM5UBSoQvrUnHAXlZl-bVnlCuACdns4c4U6qpMF3I9mJkOiGbmHyc7wHccgQanZ1H5vmYgXr5mgVogWBOwAdnJdCeFZFe3VmdPlUxRcqNnJh5BcvmhZtBY1nMsDCuCjXZg2fOBJhohdpJ5ZolyfmUFoWccEP57QXVEq0Ryhk9r0rxmIx05EcGDIsvQCddA5y-_ARpwmSWYBt-raOHPmSXeUtohGF2nFpZ9C1akmA-qLMkGphiqADsad5DJgyEJ3ISf9m-QODBbZze4Ml3mMhUpiUzV2DIS_nz27drwnicddTGZtBTBbImdYN3u0EDfVykh9lFzaDRx5GlRGgYn0cwc7AglgngLkTCz-bPaL2gjXQWEli2r0wj6ksbqagdKjBOGxgRRnOGETXrC9AMAV5Jv9uREumhqcFVRiSk3ce72xcxwMRenBKs9dIMSFwCWjTxDSnAYyE8Bt3sQHUlxPwSQte2AAiXylxJe_R4lueeiXlRRRYVhiLFPwSABkOZYkgKBi0oUEZlo0uoGWVXWNIbI8hZdwmgU2xcGKLhiEulUJqM5dwmpCH0s0HuJyWAFyXFlamGFw8oSZvVhSvHTlwAV2AGNb3K_yqQxeiogtNznlu5c3mTAbefM7oY9Fk8XOqbFcPmuF2ZCYXVqEcGLoAURIEP0vJTsGSAuMUztPm8ZnhZVngAbIPfnJwDga4G6PQWgzlJBklbxGcNXHRyAGQyGiOAIaF3OuWcROwBA52ZtQl6r9QWWEsBOmG8EsgAh-fJJWmV1BYFZaIVB2TjEgAUW6BhaKnhv9cFxcPvQ2hLPwi8swZ3KpAOBklaZ7kxIIByBwBqGkuC8wa1Zfy-wClcP08RjVaFm35ggA_nwlspaiWGFxyk8W52yJc_bZad0GAWgJ0BZISZF3hdVmtV08YNbr4I1vOVgMSMC8LWIeIEKgHQvuOgHQFh2W1nnOO4SgAzQdAGSAKForo3CrnGznYwJMJTA3Cb03mfogSXVlYDXrF4DC9W14alarXeMaErzBW1m2d8Wg5lkGxXCl7FFhWYAHVsbjdV_Vf16Nl4NajWyQCclontgGQfsJUuVtf9dJWoiYEASJ0LydchB9wAPWj1iQY5XAVoOo4FzlOfQonJYfQcInGh0iaWBO13IM7o-RPVYYY5iLwPFlJZeEd4UIG6XtXnKCfFoMSN17QZFax2SDfqH3-O1rHR-RBhiXW01FdYGw116Ulg2gVleerle1uiclgMV3GZtmCZ6F06pgyXqqWxKMQEWPnHnNteoXhZlNYwzQ1--YnDLi6YW1kN3eeWdXk9PMH9zbAOeE2AGa2jeI2L55lbVnY1hEDgjoXIWgkQCFJzL1gQFu1YixPFsRS6BJac9uxBjV1uU43HVwrwetvFujdkWKIf1dohwXbQQcQw8dKBzXewO5WLpDhM6CFz9hDORuFCoYRa1nVRbeZLns4f729n8aQalpQBMTxo4LVcn1bxmx1_xeDnsJ-AB1LtZXPxAXaXeMfM3NCgPDSgGPG3qIKX-wtK9965lQ3D6fDf4q8T5Rx_roNn-4PRAYfe7WQAhWFp8AtA3wFnIhjScUZpQHw4JQsQH5AgWSa2-1KHGhkBZSvq9M7wEWNI5WVR9XqRwxzkYFzsXAbYgQyPTDJ2rmmAWRm3kKbF0Wj_ok5Y-jflqutxURtquZNzH1aMdP4ohAYm7gJIBbYwzkKbmbBAkx0_glgUliRYlElF_3sQ3v1h2WD7bA-be5kMgI7bIxAImbN76Ttj7YEAvthyRYX2RYDI3m_BiTZJYKLHbdbrdFqHYyEgOx1jCbdCP-fUa-litYZFl3ftJf9CMVEEFxUuP-YxR-txIAGQJ0x9T38nY7PlY4SYXZkT6P_eLYyEcAWnbqTS9K5xQjslxRsfQnwXWW7Q_55QUh3EQRYyZ2ZQyqM8Wa84Wlp2a4hTbjWhd2neJHKlvZcEnBVsGEAqtUssmJ3Sds7YXm2diiMQ63y3sNCqud9oAshLMElf53pdyTdl2Rd4YcQrmLHZkcGQyXZfXmh29hTM2_eizZS26l0I3dD5oU7fJ2h5fMRIGEl90NHGSBj3c7Ayd7NOrqk6Bub96El8PbjHwJuNfVrMse3fhBHduPcV3XcE-YV3ndtHT7KPoWQcuc0VuxbzmClp5b3UoSlnVdwBdqTYTKg1gBf2WyyZZeTxc90mYT3XcfXfsw8-wKJSXe9v3oe3Bh1VNyGJg35e12S9mkCL2rnM0peHKIChZvUFnK9bhWg-oDopGEyp3dJn891LcQmU9nskZ229srnz2yEHiCV6D9-AAT3Vw1cJPnZ-mBWzap13fensl92dfomRaHVaQ3jwYkdr2hd0pcb3tl7lcZ2R1wWiL28h4Qi72t-7rAenjphaYYdiRvsbAP5I7NM8UIVx9XJGSV4kaGHwlX6I9IoqnQkuWoAAIPW27lmQjWHligXOlHyQB1uf7phpeig0-JjIQEn89lYrh3Bd-F1FK2dnPkZ3md4OuPodOzFd5noN_efKq7hdaX2EmIF4D2aRwyctOG_5_YTT2LEexvdAtIfTQuKjgVWiOoM5VCG3mhDxxazkUt4d2eFSZDCq7pJqceu-IAxojcTXmVkzfp2ZdzxeLpa9vldsl6EI6iwBEgASH_nz2w-ZyBadnxacnx18wGg2mDhndgB0t1ecy2HeijS7sDsaCRcmhotycydPJtV20yhXeIS_2MhPTJW73Es9VBl3q5dR62AdsPOYssjgo442JId9YA3ijj02hJEstGuvxI-C6EqOQZJ_EW2A9wmPhChSQTz0xGjpmQwWm0ZQcvG5daDY8xujiUli2KCNI9gAmCR8ZJFeDiw_4x8FOvezhOqbQ6S4S6MQ5uA8wSQ_MAMCxTE8X9ha8bcXPYJQ-LgQ81Q8xhtqDQ9mBfV5NZpo6FrgCpmJ4RZ1yB7jqai6AFj3w4unmLN46btFjwpVp3Nh9KCENoJA6Y0mjpwqcWnnAQ0YsN_j80ZirRjfPYhcuORMyBOcLK6aemIT80f2ISMZJk2PoFXOSsa7hLsDzBSZWTCUw_Zvxcmg7aYMlZCKLdIfBaKM-wlt6nR800ko8MB2a7oC5GzizIHD7F3kCJjt6vy2I66GX5PCjqDSGPKVM7bi3bD7EBGz-YuE-0hsjtNL1RNBAVYz2UqdKowsC2sWwrm_ejhvk8LthyXQWRq0A7GqRMXSagPap_IxdQ4DrZScDyFZ_OyZCKt7FS9sFuhRNWJF0xc9yvN4-R6pEk8cvxBHTmWeZxd8YbHcSg9xXbvVSqE_BCTh5BJYf2LehQ3x2dTtJbIol7MQoN0Na4xXWagesrHLGA8Gk4rNhQek-1qbMMWsfM-rA47LMqjpU_Sh6jx0eTMw9REaVddRkqYtOcp3B2mqZMtM6RXCN7ebtQBkTcg1nOqEcLpmjgExe1nkK9bDY0wmvYWaBmINZDnKeqvTZ43KFxqpM4pYC45dzRz7zvZX1sf0_9llC5TErXq1oSaGWrhAOuuOGN244TP1DV-ktpOsC0Cyt60MMmEXoXf7y42tF8vv6sM_BWvxnrQv4VhYXZzxk-7wd0db8OItlkH7ONyfOeIWo5tU8T9Qj6uXCPMqngYctK6w7I9H2tgo8628jhEhhlqz-ohW7vT_XKm3phCgQvxyjvwKlkCjiHDG2GTngc9sohcSIKPI9vHQvyg-DWf-2CL_U-NnDT7QX6aDgHKDDnwz53eYvuLhyTDON9v6qu2-IcnWEupLgU6jOJRMObjP8dmC5Pw5cI051IMB97UV3ya_WyT3JN-M7kvEkkS9Jm5ce9CaDTLhS8KOWCHS_JLFd8UD28DL3TGYPsUQXEsv5LzPed25cEy-HkzL6S7GwBy37G9P9Lg3NllE853acvDccK4iDFyD4TbShvGte9OpqMw6sbmgRILiAyhQXCbOeyTsdMn-p0aPqnhpxqcsAxprrgmn2pjychOSho0fdDQlkWj8vA9my-JHvT6K7sbBhqcf-aVo0K6JPYrm2rXpiL8vNIv46M7dZ89Lvq-6uD-vEiGP9zlK4An9MkbYh48AePfLy0oSi_8Chr8mpGuv6f4iY3lr1a_Jr-j7Kig1BccU_2u8QQ667A3-5rfwvZkAyuCOCNLa67Adrhcj9Tez3mfFAplKVaI0b_I4BWpOLZpLEVPYfQ5gALCxkBOFfV1-e5FaIR1z7pmepJFTlzekBihuoFq53BuMgZIHhvNqBGgyuiVvjC_C21kl2sOAkOAHPBBQFLoBojmYjVsBMMRWGpvtVRviYmEkOTLtWshC6Q-P5UW2DT3EgM9Wz94_dG4huK2u7bcJj3VYtsLHl5bKXUFkfI_Evs60tPt1v3TuYQoxb8dIGDPbLnzQKRb6OFVusKLaqfxmbzbeYoNr0vODKYdmLYD1muyW99115Vi5Z1Foq7qzO_TzT0nqUla_up7PbMwIZ7A94nbvc3L7XwyEMbk4WF2-j0UuZ2ioYbC7lsXQ8fYPqdzg94bnjrkfdJ5A_pegAkpRE69uq0H2-xA7wP25AWajqMBAIEdjg4nhqGuF10QG-mdO92XUSlKznLabryR4A6g5UKPfsVO7zkwI-FxRaZLzjqLs951oPBE07soQotW5grHXlmbheYh77To0gBuQpNDgIju6MPmYmnUQIFRAhd-DZJWg74W6p954zW4EqZfFERkIu86Y8Qx9b7_GZvxQBkFOh3uMe8XvRt78XVqdS5m-OUYY2-58xX72WXllzaltJeBDZ4unY1bmAmiS9V6YKIlp3lD73N69ZwRFsaqmbpnddxwc9kfYG4l4F6r_7_6kS8wgYB6OAEpYngoOAhwG7sBkcLB8GB3PMBrgA6btNSI04HgGnJu94Z7wjzf4c-_gAh-Kh5N2MAZm7xqdSkxNvuL7kvKA3LFdAlsAaHouJt93PeYZyob7_B54er7-gNHpWTvOhNXuME-VYWDHPYA9ZxvHB4nh15O1ptpu4DcL_uiNWs-6ATgW3PnuRzOUFFYGROtSOBjH7xksM_KcbGaqLgX--2OsAfzPN7wsGe6Vh57u2icOs_P4RXcfvGm-HDnGyRM4ApgX3PGBLk8L36BOQxMJ0wEHgB90STG5WGAjSan0gNvuHph6vv-3H2d8e5MCzqhj-MS-5e6C5Rh-Ke9T-uDKeS8ke7xJbZdLzP9sHmIFweul_c_yBwkEGqgfl29MQlizhEJ_prsQ3sNtlfNp1Ys4N3f84Yzm5BWHGhaSTx9pIeb06wpp9HxB8yPb7ip6qfToN-_wfOj9KFmfYG2whO5we8fLJuKb5ICSeBnsR6iCfSYQF2BSC52x4wXQSWiGs9hCmv0HH2G_wyYXcmxrUeFaEeQEvCNR9myBDbiSF2eC7w5VYASOKrjz4wet0j30iNQF_fu4rwa4SeevER8PI9d4dqZvVnxvS_s7wBofwelgODQhe5peEGtm5Qsh-Ifqbs1Uxf8HmR6muf6Iuu1OyL0p8yfynr3dhd5oGjgl1NBdZ8fIIESbBJdqHk54upkXyNNpuKXojUZvLMZm596Zjpi38PCNCUEB2Xw5m4AYcNtvlZKrgKGcMN4pxKc7OjnoR-aEX2FrBA4dgJKWpuSIzKm7OeDuV4guj5mKiYmt6M9VxRA7oW5WWC51W8Qu2-ZC-y21itC_GCI-lbrn2-c459ofhXhm4BpyH8N9Yemg1Z-D7uboW6dfDaWtWUyXXzG_z7KyVW46PD-wEPifKXjZv4UEDn2pyAy77T0pket5V_fu75zbC8UnabKlZzf4RLH36jM8rGdk2X3bHuD_w9hSxHyhpvOlCc-0XexB2bqFcNOvTdm9QPN0nCy7kJ3snhFoDT4d_wvpwdA-GxcrxaoigtXu0xBmXquXBtP2FTQWHfG34MldxBHoV-TwTX7YDNeiNb1BFen2aCLMVyX0BTzf4Q13BKoL3x9ivfKXl25nfysaN-leKIo-7x6qIgrGU0KQJV78p4X_B-rMwlWV5UmanEqg45wPvloj4JY-i8D0UTtd-RnAZtGc-nYZzd6hPhXMLBz6Gr_KFhOGXIhhA_qqESgDLw2JBSYmnDbUebOIocGZG0zJjD-hmsPjGcimSPqMzIsej0axQL9qwecHPDfCXmNPX-qibBwlZMPV-x-C5bOUpEGnJYJKTi_gAUJTh2WvMAePiUlWBbcwajSx-AcbFUHJl5Mc2JICPdHckMLjmlwvPx3rfFq7cv0dLMj5P2P4-aKh2rFUZP8UtQvrblnSBTVvPsswHjPms4uITP2ICrIzt_4kC-lTxvrvlLns7U52YGJ8G0gCgKaP4bl3uXQVOAd_-slUlldS9mIvsdF4fbwvp2-HlwyJz_k9x6wHDc-JLv042bFyPM87ACzyYyLOIEC29mHx8nN57XwSYRXHqmxu8Xxi_T7TwsACv_U4KZuv4RUWEC32sEG-HJBhOK-ev4xWm_-v08eEVm7mb6W_vxPcZApkyDr-1qaNOORG_tv4hXubBcDndyWnwPpES-KtiWJmgvZHmK5jTrEr8q_h5TRRXeHCfK76n5py09VcBXdhR3ee30cZ8_iR9xL-_ev4eWJHFhIH-MVFhYkYYTwf-TwYTiR5u5h-HJZu9audviKAq_u5MDV7lOrnkbpf0zuceEGFxiaCXGAxl6n_WqLkrn8_v8Uz9Pxzbyb61GeBncfu-77jAD0rLmhO7p_SzgY-LNKzxU9sqOfxUZ7PSJMlpyRtOExx4Vt7GlsM4_xtqUiA7kIFAbkQSLozc5BW6BE-15fk5FsdNjIZjF-qEZeGtGHkUVamQppU4hml6kHX6Gkz1A39sc5jYU-BQ9U5eAvNsQK37YnOJxmFEnSVc3-XhmaZ36N-iEDxDDpPflKRCcSsH39i4_fkX-DdA_0-DQ0jhUP8mlw_tCBf1m2wP51cwUDX-R5y4SuAN_MeKSBhwrgNX4N-XmH9isBTiQv7dYESTV4RIy_yDnLNsQSv49MKLav-5RKoWcxD-7fjoWAsrgb3_b-rmU0zJwY_qaGr-T7z49NC0_uuHMlHNBP6IQ9-bEC05g3FCVn4ajcCF7R-AHLKbokAdgBZ4BEfgFFd-AK4H4BCAW4HuBHgSQdPA2QJbBsanJKxkkBi_bgXiACMB-1nB7uQ9Bftd-UVxDhbmSQFth9gb1gIBJAYAGCgBjklgOwHkA__2toaQHkAhmA8AYAFmgkg24AL7C8g6wH4AfkH6AtAD3-7AAP-NwDuADwCOQHAzP-rwAv-fRl8E1_1v-t9gf-NgCf-L_1QgFoFUcA4BeAB8CiAn_32AasDoB8SEQBNYH4As_nQBZWE4BswFeUPZX-kG_2yo_AH_4UjVWUGAG4BGAJAAVPHQBIgNTiFoDEBjfH4AxH2GwyAK1YkgP4AMgI3-agOIIygIwOtYH4A4FA0B0gIYYsgJAARgJAAKgIKwhgNOIxgK0B-_3MBtgMsB-gIsAcgJuqMwAtAXGEe84gPDkQgKkB9gKkB__C8B0jV8B66TNGq4B3-iin_4sbg3-oMGGwlEH4AY-W0BdMCyACQHoBXkCkB6WTMBbgFoAaQLQBzgJawCQJUAvgIcBudgmA6RClgGQP4AWQOSBShG9ssjBLYegMKBUgKSBDgPIqVQJUAcAALiU0HQBd1WaBiQJKBUgPeUxBGYQggKWAiQK6Be8HX-pPCsBmWCKBrQMCBSWBkSY4EhuIAHGBnQO6B0wJEeYQPYAyVkiBk_lmU3ANUBdMEaCRwKNI_AGXiZwKFoFwK_i4YXQBcQMEA8DlcAkYEGiw0VGiq2nGiBURvAq1hwA2MG5AawKkBMkB9gkYH54oIMUAubn4AF-XCB5wJ0AgqT9cQgOTw_AHxScKUJS8OEfOXAAmA9wKhgPwOxgqu1cBsIN-SKILRARKWFSdmViBTDCeBIIPBB1IIhBAIIpBwILBBoIP-BeIKkByIP-4nYAgAeQHuBkUAJEliihBOwOhBmWAP-L4SuB5WCRBcIKZACIPYU4oMJB6RCEAaIL4i9wP4AAAGJgaGAAOgcqCc3JCCvioY1qekMNkAYXUpQR9BkAakDsYpKDu3gYDzAY85yQTCDD_tgDHgH_gvTFaARAI-dkbJ4DbABQCUgBaAWeFDAAAOx6IOYB-QEQDX_VgCRQOeCjvP_4VAP_5XOWaBYAaqBYAeQAdQRIDVQRICJggSDVQASBxQEADDYJVKGArOBmA2zLsAoUFWg2ADQZc0HsAODKwwY4FvYEvA9A5IEEIMRQAASqhgCkEigLPADkwgChiSwGbBrYPbBcpmcASUCWARUnPAvXAaASwE4QuLH1AKwNiAdgAAA7XWBi6LCg9YNwBt_FgDj_pIARgJuDTwJ2DdEJ8BNpFAAOlhaBCorbB9jPMYoAGhBmcEQA4ALbA_YPgBiAFAB2gGIAJwVeDARFEhFYFIBXABIAQEvGBswefhC0JoCC7BUCyQRaD8QbycbQUThMAUf8cAY6DsQM6DLQKtkcoO6DH_l6CfQf6DaUEGCQLJEAKjGGCRln_9bEOGDYALGD4wYmDkwcABUwR1B0wcABMwfwAcwS1g8wfMACwX-kiwcBhDARkIywegDKwUeYXUNUDKkoICQIVICwIWDBBcJBD7QU8BsXHBDXQSzYkIZ6DvQX6CAwXcAhQJhCvgKGCCIZkI8IXAByKqpCiIcAAEwUmCUwWmCMwVmDaIccC-_MkDCwWsCTIWxCh0BxD4MlxDjQSABhgeARRgaKD7IVwCjQWKCHIYop8mnAA_CmYD57sRtPYI5DYgKMCd5GshLbLABraNsBuAHpAaISfQ6IeYD8wckCVqPPlYoXIR_wSAAfYBMBlgWiBaaO5DXIcv4XISxDPIb_xvIb5DkgZFNzwBNxiNkipDQJlDsxLIoThD9Ru4GudMAHvA8AKlClovFDTIQ4DkoQcgOoYKDLQYKB_rIVD8QW5D-IfiC8mhoUCmo7Rkgf5D8ZjVD8wOgAtILbAfgLbBJYPDgbwVpAxgcJDioYgAuJHcAlQewp5gYMDNAaYCCgcnhjoWYCRgEtCKEL4D1gTUCHAfdxiHElAXZE0CLoS0CToSoBa4KgBbYP0YOgQ9CpAQ0AokPYAFCA4BsRLiI3oUdCPoWYDygKIhbYMgR_oZUkzAcox8gCkADrNQBIYULRLoWZD_kLbANqCv5zoVDCBgWYDVoetDJQbMDBaNjCHAWAQuQYTCsYdDDZofAQ8gLbBEgGSCKYUTgqYUMDfgGtDEoezDysJzDeAbOA8YeEB2oXTDKYQzCeoZph1QWLCOYRLCWgSohkwHoDBcBfkXAQJDEoZLCUob-C0oRECQAEND0QCNCpAWNC16PsDEAKVCZoQ4CKoVVD5oWVJDQNdDlofOIFsIRFbYKApNof4BmIcWCFKvtC-IUYMiYcUCSYWdC-YXMC5YfwA7YbdDEYQ-IzAU9DxHK9CZYfzDg4V9DyAD9C_oXSCQAADD-AEDCQYWDDaADiJVgYHDgMALCQALDCUgPDDLOinC04SAAUYaIh0YQGBY4UHDiYTjCZgHjCzQJjDxYfXDSgZQA1oVE8W4bLC24VICaYYIC84R9AC4f3CWYWzDVYUPD44TiJWADzCGIbXD84fHCogELC6cKLDB4c1B44R6xdMN3C44b3CJgZQBFYc4DlYYeQuoerCpAb1DhQP1C-YfwAggAJADYZwCCoXlCioZNCgitNDsgb9NKoRloOylUBbYI5VIaLbApBAWhpqH_D3kkQBbYItQPAMeAkINEBT0FIIqeEbBTbB_t5QNfDEADNAXSEQAZIHnxrQmptWIN_DPsu8lYEZgj_kBqACgCtDkNogiYAAJBkEQwQ0Ec8BkFIaEiEULC8-AtDr4e7DH4YoovYfcCC4VoD8oCrDj4bPCNYX1CLIdYCQADWDe2FsD-AOeBzwI4g0ONJBKEI94DEKbgZIBfD9AcKCxEIrA3YQ_DRoffDxoUMCvIVNCfIebCpAZbCMtEYAcNItR_6FgjqAPUcCEc8BqADgj8MDbC7HvFgm7Cwj7IZ7DM8N7DQYAXCLEcXBQgUoAdYDvCQAAloPqL1x-TMU4JHElA9ATwiTISfDV_jfUlEelDc4LQBCIgCgXQKIANEYbCtEcbDdoWbDX4TbArYXRBEkY-EUkWOAXEZaC3EUGwPEe9CAkVwjx4WvCAkaHCkgfdCkYckCo4S9DWylvC64X7DkgZyDE4b9DogOHCFwGYCM4aDCD0NnCIYXPCJ4QEii4SXDCgGXDmkQ4DK4WjCv4BjCJkXUiukQ4Chyk3CJQB0j54dUiO4WTCdkZMj1kX3CmYQPDakULN44SPDWYYci1kQsCd_tzDTIavCLkQEjF4cXDl4TcjnkccjYkf0BpYU8j_EV8jOgXvClYUaQokUIjuoafC4kYIjiwSIiRODXCHAfFoBJlcBNwSMAJcEkjhqMUiSYKkj4kTrCBAGABmILfDdYZkiNQibCckeVC34VVDf4f_CKFEAjIgKAiYAOAi-jFAjiNJ_CPADgi0JHijKAJQiXSLiiEHAQi8IMQjHKp0AOUVyjyCDyi4Ed4i2UZOAwALyi7AEOV6EcXCqeAs5pUfYiDQFKj8UVCiPIeUi1lBwj44Tyimgf8i7kYEjcou9QQkcVIwkWNxIkUfDokXwiIUZrC7IZaDyAI3DcUeqj-IXfC2UgbCJobojn4fojcke_DAEVSj_UcAi6UQyjIEQchlKhEAv4Y5Uo0bQixUQtDJivCABALbA8IPEBbYM6iO4TYBU0RvMNUR7C2Ee4idUQEi9UQUCDUZ9CgkSajQkaWUpuBajnAaCjiweCjYkXai_wTrCEMuki3UZQ0PUToiSoXoiyodTDApAFD3QNsBtgE6i5EYlBSkZ6jf-OwjYgZwifQATDiPsWizAaWjTUVyVK0RpNLUXFDrUeWD60QIj7UfiDR0NsBwENFxfoYlAMgOCI6wa6jCUe6j0kWOjTYV2iDEQ5ByUcYiVUYaBd0fuim0IejbEMejlkTXC5cCbCJ0a4V44dM8oACQj4OkWiC4RjAXQPqiC4fjDbYD5DtgEQBV0Z2FeERuiQAGfCyQduipAQE8g0NeCKEN7DhAQlCbUZujz4dmjLQYJDGCGhir4XclrwffZPQQSi60chjIUV1DrQUJDbQWuCcAXewzvBJCEIYkQqMQUBZIWhDAwYpDr_u_xPrDpxQ8gOgvQBRjJANxjZwKpDQEFRClADpD5MamCL4RYAVtulC2MQY4S4VQBAnjRiYkXRjNYQxjsQIdCIISAA7QeuD1MXAAOMW6CpMShC5IehCBMXuChMaMsRMSvIxMeZiOllpig0DJj__pmDFAApjfMUpitYcBhcweei20ZeiO0XtC80ZOj44epicEfBilomRiQAOZi_4VccW0XhikMShjSkaxDDMeBCPIaZjWMRRjLMVJDrMbxj5IRhDBMWnxhMaoBRMa4BxMduQngKHBsXN5j5MQmD_MUZCCsMFijYcSjdob-iKCAXCYsUkDuEXS81MRRik0RqAdMfhi9MQIiDMVmimMcZi8sY8BzMYVjEIcVjUIaVj7MVhDHMQY5nMfABXMRJi8IF5i5Mb5iWsWRC2sZlgOsUSidoVqiDoVFiAkf1jfESrCEsUliMMczhbYLM9xsUhj22plidAJQ8N_ka9jgag8MgNBAsAPzh0Adm54oTekwsfRCkMeiE6Is0p1_t-jwAKxp7gQ9jG0dxDEsSNjJaI3C3saljaMZ9iiMfiCAccBCRHvFDCcUDiQcRv8wcccCIcdoiocWYCYcfeg4cSsiEcb5EPESjjtYWjiksXhBXsYvd3sWYC8cSTifsaTwBcY-wycZjBQcVVYhEdTiskbRj6cQkAibEzidoSzjkcUNicUcwh64Lzjkgfziqcd6NIcWli6cfhpYcfLiv0YrikcbEC2cSNh0oeiAIoRZiulhriHAVrjJcTriacXrjkgbLjGccbiYQUrizcbj8NNEgDU4WSQcsULNjgYajFAZZgvsZ1idoTQU6CsggzAaIC14CEDlMXnDacckDQ8RID8cZkCNMu2jV_qUlfYklDEkonjVYfwA6wlniMofHifAaSCzAZqDWwXpBYegXi0MbhjDUVGCFwGaDw8RdiYQVHieyrHj5AanjfAVaiwUbpjzIfFCFMn5DTQekD08TxCHomkjncc4lcoT1D88YFjrkuzih4cHjPoWUC8AEBDW8RejncR3iPlF3j3AQoCy8UoCF8Rbj10YxDbmF9jh8ckC18Rvjj8foCG8Z9C6odlDVgfFCI8e3i-AXAVO8Snju8Yfiw8cfiBofZDaMZcDx8XTAual_isoQ1DcoUPjmVGfku8eASVgZATjgcXjdccvEK8YHiPIaLgZgKOjawA8CzwB0DWoZiCQACyCVQZFAYAMmA9IEZAJ5OniPoNm4OeIiCQAMqDIoK4AoYGAAjIPvDXcC2DaCdKD6CdFAYYNjBsYFgSLAMmAc3K7hiCa2CwAHpACYa7g9ihLjrgfQSFIOgBIoB4Aa8QIT2AML1OCbITNQa4BIoKwSPACoS4euoTBaCqCFIMjBIoMmAoYCoTfQcIS6CZqChCegAoYJITk8GzwDCcZjNQdm4WeCQTE8SpjmcRfF9gEIk7gckD4sOAgqQZYoAAKRwwdnhhE_h5YEm4EJAe1K54oSEqAINBCgA7wZAh4HRESoGEEjJT8ALOiZE5SCrWJYAxQKKDm4__HO0F5FKHNJEv4tvHGYnfEQFPyHqAv_FJ4l3EOAoAlQE85zJAoaFg0YAl95L8LtE8onYol1D34swEdEy0DtA4Amv44zEMNNUTzI4nGR49_G0FT_HUw-ol942tG6YuAAyJLwAzQ1on3OIYl9EronQEnokOA4YlfY1mLhAEvEHJS0AriMwHAAKnhZghHHnEzwEgQJUEgAUUDcCEQAjgRhCkhc2Bb4SEF3EiZL5AcKDi4lXEDElfE7EqWChATfGhY7fFzE6PGYExmG6AhomF4polSAlonHAy_GHEwxLgkvYmb5A4mGwjEn9E5fFCIw1F6w0IAACILIQkqXFdYyYlNJXoFlEBHE1EmPFwk8AgF4xDF-Q9Yn3oC_GgE9ElgkjknYkvl69E7knAEk4lT46XETJS4nJA64kMMW4k7Q-4mAAp4kvEymzvE6jDsAL4m94H4nSkv4nWQinHw9eLGo4gknFgw1HMIsYlVEjyH0k2EmLE-EnLEoqGAE_qg8k7YnJAw0lbEm_I4kq-HkI_EnNQEEn2k8hGkkqJTkkp3FZIqknTEv7Fv4mYD8A3fGMk2IDMk0_GzQtkmbE1Emck9DGukrEmn5Z0mJYxMnxQoUlnE0UkWIHKBXEm4nRE8wGikx4nkg54mvEpTAfEkcAqkwgBqkmEH3E_4nlg7NxAkvUlFQw1EH4NRHbQoRHjEk0nQkhYknIi0lro_vETYlElCItElSA1snOIpMlOkvkkOAscnqI-vEek6cmSINsnekmHhGkrfH-kxRSaJCOG_Y2kmzEkMkf4sMnmkpkkIklknRk2RKxk4cnxklRFOI9RGOkuFIpkmcntk4sEZk3XEyk7MmfQ4ADeIxxT5kmUlFkhInykt4kxiJUmVktJGq7QwEakgElakxsnukwkmfQtNG-kgja6400l1EvskIYqMnNEm0kTkpDFwUzCkwEsyEcot0lB4mClmAx1Gpo_CmrkyElZIpCnhkygmWkgAm6YocnFgkclIgp1FkU28m4UhwEkU7Clzkoil4U5iDLkx8lFQzsk5o3_ibkwZHbk09i7k0Mm1E6imRkgclIYtYlnk20mIgAsGsUuMm8k3-AqU9VHpkzPEvkrMmvCK4lyo0IJCwvMlUEgSGFkzol_k0smKkz4nfEzInqkyIh1kwEm6gpfHQU_UmfQ5tGVEtcldYqimHkiMnHktCnIkjCm3kswEeUtSnJkqclSA5tHcUtykhU_inwUgmHO4gMlbkoXGSU_cnSU3yk0U_skrEibEKUjYlKUpDGhUi8nqUsEDJAwqlPknSnO418n6U8UnY8VwBSkmsnmU4UkPA_8llkoCm2U0CkFkhymakq4ANk5ykn44Ek8UhwGFI5JH7okpHkUikmpU-YkHk3slHk2inEY-ilBUsKnKU5IHDU9FGjUiolLUu8kRUovFjwIpHrUgimlEgFGrU7IAYouKnjUv0mUkjclTE5KkzE4MlSUhkkZU2SnZU-Skxk_KlmA46lLQ_ak4UlMkfUjFHHEiqkikyIhikhwESk48D1U4zE_kiylGDEskKkwCk2U1Ul2UhqldUiCk9U7UmL4_qlNk-yGGo59GVAa8G8QD9F1gzykUU7yndk6ak6A2alZUq0kLUnMKYUswE40g9H402xqfo_KnsU5EnxAPdG40t9FfPZmm34wtCDE5IH0019GM0k9GsQM6lE0iakwgpKliUlKl3UtKkPUmal-UuamgQ1YmvU2mkC09mkvovGlHopmmE0zams0i4Ea0zmnC0nmnaUyfGZkoGlvkq4kAYoDEwAcGkeQyGlNU_gAtU6ykVk9qm_E5Gn1ktGlq7PmH80hwFJY6zHxUkvEKVCwEy06omk09KlmU_FBPUqmkTY5EFvU-0kjYgOnfU7amFwr1JfYpAnO4tkGZAFgC0wq4DJgBHFsgxUHJA5UGWQc8DuE7rj5ktkGoguFLHWUWHVtX4EF0iUFygkkFF0hwFV4nNwKyBEnRU5smfQp7HfeINCB03XHB06fA0kiSmy0qakR0sClR0_ylyU4ikSg-Ol-0kbHPYkqlsUlMlCBdOkFBEvFZ0jkG50vIk7Qwun-EtunngeDJ6QX0HagSulN06unog7KzoAiGAEifemX04kEKgw-lSA9ulagrum6k1yk90swHL0-uB4w2wBfY2jFx0tWl-0_undCf-kCU-yHdElOm2486kIUxKnKeEeniUr96uIxBn4oDHw5k5IG7ub_KmU3gF7kieny0qempIaOn2QjOlZIg-kXiSvEwAE-m-gu6EP02UHZ0zkHew_On0MoVIMJW-k4AAACcjdNlBV9PYZG_y9pUHxKJvtPQxYDJ6QEDO_-V8UrggDN0xwDOCp9pLEZf9OwxLNJ-pyj0gZg0ONJwlKs809NDpmqLQZqSAwZn0OwZagHzJClU5S4YQVSmQWSBVdKfpcKSLpdJPDphDILJ09KVpUgLIZXWIoZhGOnJGkOeBQ2QUgkRP8Zq1n-BPDKFSV9Nbpr9OoZRkFPpdDJhBNjPlBNdIxBddKrorDLCIjDN3pCGT6pwjPnJ6GIxxKWJPJHFPnpIDJyZ25GSxsJNXpKdPXpcDISp65LR8OjNupYdPwZMJLMBFgNcZReM3puuO3pOdOYZITLCI4TJVBlkFLpvoKSgndJ6ZRIPiZ19IIJ9dPvpsTMfp4zL6ZchI7pndKgphFJipCdJKZeEBkZsdMKZ8jMXp6zLGxydI0pyQMqZ4tIupl2P0ZKKFHpKDMGhjjLNJkdOIZM9OLB7jJSZcKTSZ3TOeZqBLbpekD0gSUEigN4E4ZF9N4ZtjImZSTLvpozObpz9MoZxdMWZSzMyZPtOyZ5GJKZv9O5xgNwXpxTLO8mmNXcGQGRZIUk2ZL1MUpVTJLxPlLuZFzNwZu0LUc7aPxBd_gpZloKOCJwSiAaQCeJSLJKoHQN_p2oPYUrlQFBjROfJzuNpZpwQZZCjI8xzOHzJtLImoowFXiHrHAQtzIQBsLLvx8LPRxiLMUZ2LIXAK0NPEK9M2pP9KXpirOxx-TL7hqtJOZ8DMopNzOaZSDNaZ4AG_ETxPpkHQNeSh6Kww1ZPKpZtN0pFtOqpINOtZgrLxhjLXBI55TtptaMapcpKspMYmyAnILgxiNIhp4FPrJ2IPsploFZYwwCJxIgNTsRACiIkNm_JEyX6gl7iapEMC3-DWQhgJPlNZTzKRploD8AU8A-Zo5I0hwRMCZ1bn8ZwTMjZFoELZ8RFrpHEOWZh1INJuTKxxPOKKZCLPRZmOKVZ55OeprJPxZ-rOqZJNMaZPZKIZJLIRxClXJZYWMpZIoKnZNLN0AdLLOCTxK7ZzLJThmOLZZ3Iy6SprO5ZWSN5Z9LI-xeTJ2hIrKDy4rIyAkrMuZjbJEZHbI0xXbNmeKrPaEqLKvZ14JvZbbJ1ZyAL1ZxwKEpglKNZWDJNZlNPshBygtZN5LcZyjxtZnROCx27K6xVVMwZLrJA5brJCI7ST-A2um9ZVpN9ZxZOdpAbJzpwbI6ptZO6pUUAjZ-bItA0bK8ZgQPjZibPmsybMiIqbPmEsQIzZSwAtA2bJrRRULzZobMiItbOLZB_1LZfjMiJNBJCJVbII5bHPrZG_3MJMrL5pcrM5xGoG7ZD7PlZ6LK5x2rICpb7P7ZH7M0ZX7OHZZNOcZ9zPHZiiknZ2iOnZYH0GBYB0SB87L5Z5YIeBXOJXZ6wI2ZhBLw6agz_ZloIg5h7KM5e7Pep-zIRxR7KngIwBPZMNhSxpPAvZYnJGxsnMXud7LqEUnPE5IoEk5wBNoxuVPZJBLMQp37IcBLTNs5O6PNZxZMtZKcNdZq7jtZRUPs5BHOBpUgOAA6XKww7rIQ5XrIo5FxN_J0NPQ5U4Mw5mXJ9ZHtNBx-HJY5UbMowxHLjZVNjI5G1II5VHLGpYMFo5WbJwAObMS5bjPaZlVImSbHPmZgRLLZ3HIiJfHMa5NbPiAdbMSZDbJE5q4EvZDkMZ0wUNgh0RHUZmiK8pk1KaZX-P3xwQJ8BJDPmpE2OiIUnKChvQGyx5TMOZ9uPW5V3KzR8UIA5xZPMoKcJsUpkPWBXxJdAKkRq5loOY5HkL8JkLLbpkUF9BDvhZ4MUNJZ18X4ZOnMWBBXApxIhLpg4Ng8RK1ksUOAF9BEVkzZEMHR5GSm4ZqPJJ8_INqR1QJwSgnKmZvnMGpQwPu5owLFpSnN2549P25DgKCBHEATxDzJjpeLLyp7bLW5IwOu5etJTJl3OchwBOe5CRNe56wPe5iUM-5lcB-5IbKy5ANMg5elOg5eXMwAYD3gA8gAAAXaVyHiVDTmqf6yquUGzGgJLBw2L9yoGTGTBjH1EPclDSieeBjSWVFyV4k9ktMLOy3AfWSEeerBrsWDAJOksA1CRjzwiezwUYATz3aZaBHKfbzS8XDyeqU7ykefcC3eewBseRQRfQXDB8eX-9q2ZHhmcKkRGhKXD66cJzUKUIj_ubVzLQONzOOatYpuZWz1eQJzFuQIyG6dWyG6CkTYgYs04YNhzRufNz2OSZifGZNzCRCzwAmTgA9IJwyZufbSU2S6lA-ffhQcaHzrNLECUeSmgKCJmzR-aDBceUhQCeWTzVmW0DeIYPSoSapzJ6UHyH8B4CjuUfjTWbRjB8eqzkgaMTu6VjTYKWrjtuX3DLyYIBj-biyzAedyYuUvz7qbczDAVqJBAbmzhuVkjr4rBNYWFiCa-Qjjr4iTzoaf09UifwBhedDTcCSnDbACp8RgD8SRHlQRIoA3SiibPzv6WZC1cdTyiqXaSNkRfyIuSrTFOUIjsubNzcufwBjIg-JkOUbyzySbzAUK9Ar-dIzSWfcTRWR5zzcGezkGX7zV4uL1uuRQQhsvRycACzxa-UDTyuXECuCf_zTKRYAHgUAKcCWNT1gWAK_oJAKX2CyC0ifQDGUAAKYaQBSdeW0JIQdIKieY8JNiRVzteW1SEaT7zlYYwKA-QkT-BVkSQAMIKd_qIL5YeALJBWURoBfnS8OYxz8obTyGmXfzmmY_y68Z_SVmQgK0BdbjBjGoypOVbiekD4L2RJfzrGdszECS_yPGU3TXmU8SjBdDTTBQ5DzBRMDLBbkSpBYSIlgJJ0wWdDzkmTMzAWeMzMhYIydgUeRrrM-Mx-Jpx7jKIgfxlL8yaojd-jHbR2EKrk5lHCcxTPqBfpsOCn-OeB6pBJAoYHpBiNnD0ehUpB8ZjQSlIHhhgFLAMZpqfx9QEVISpOlJmhTlJDuL1xLAEIhwdHdMmhS0KFCHbADjPVJhhdh164mxBvYqs8_6DeF1hO6ANwt9RYAOdw6QiERDcC24tWrkACnj0AJQWOELHpn1goi0QxhXxA4Zr9NspOlJ2pkloapJNofjOlpPvipZLjAsL6uM4AhELlFcnMZAzAI498SH3FXmRdQl9OYBGmpN5wocOt61JwseVjvTZaOaBSZHTwruQANIHpti3hVMAPhS9V-nHbBvhUDC7pizwYRRLV8bjBAtXLOEV5L4BVMO0BQiG7RownJhXkjodsaCTh6gNVQbbgrB8SIzg7Mp8d5UGSLspIVNrYD1gSpONxgsNNpUeTyC3WjHx5RQqZfNO9QWPqFM4pkIgokEtNkwPDAVRafxJRW2dbYO1N9QBML6TFNxzYG5AhEC9CIGr8CjRXxA42tlI9QGVcgRfOZQRYw4IRebAoRcJySRXE4WuP_EteB1xspEI4CpDw5YMosz4oIiI-_nSL2Vl0zARLs8-RdsBSCmdRcbGOgNIIiIlqKpgQamkB_ZGe88wN4icnn5sQHKTIDUJrltqLs8AxWSLUZscZTjMFgbYHhZ_Jm5AmuGlBeqQGK5LAcZFLFh9gRWpZMnBpZ2xU6KoIJML5zDbBFTKk0lmnhh4Flp9hLCaBSCs2tCQCxZo6udwH4N7kpgNblbcikBmFNbRaAEiAB7nnIw4i7NaNnCcXYC1wxxeeAJxe2KYodxArct6NdhcqSBQBOA_5ucUjqHc83xNvJtqguKYgkuL3DmcKFwAys8MDeA_AtQBkPgScssP1QSLL8QyFq5kvZFQApYKvRgbscLOZqMAyMKcK72GyE4TmqLvjGvwl0WeK-xbMKJxbtNldO1N6TO2L72vGKApCo8laIxhhnpN4M5BShdZJXV0JecKlMNotsXNqp3QJOU9goxLkGJkQ8ML1RvqP5F6kPhhyxd00WrMXRhJYCI76byLtFu4dkwPudJJffoHxe4dgolDB4WgyEAiHOA1JRqpUeX8D4xRuF2mnZs9mO5JcIARBIHiZJARC08-UNBKhlpcc7vK8B3ntNR4xXCA6VojwXZgjdw4AGKITiRKCJZVI0aLHpkPI6KYPsxZKikuiaioQ5mHLqBSHF1MLAKuCoIY8AOyjFg7_nfYPQY_ZD0AoiUgP_YbGpIBOwFqhcpSnJsIWHBZoGUKUgNwAbFC0VXqO0VeuB05JqtUVyymdM6itFLWHM294paJCkpTfZ4gNZin7FlBMpdlKMgLlL0APlLZgBAAipYzAbFI2V0VK2Umsf_8Ewf_9UwU9hWAK-BhxbhYYVI04EVFMLkVKiomynVJMtBx4VpT5LYirKYJEaRLeuFNwokAsLmtMcZ5TK9RMtCcB4IVZi0pbOAuIML8LwSb8U-PPcFpBUKcBC5JWZM0pSZEr9MhM0oRjCHMEKOPoKPkZRXKPJNmEIpNJKmzIi4AGLqhuUhtBvOoSlLdcvRgRtxRWm0rHChI3RizI_VP9L2ZPhN02sjKX9hFhriDnwMxmrUjxtTtp8k-kgtN_13wO-A4TmeAcZXN59fpjsGlFkAmlDfVSmKzKvhtaMBEFb1ykPH0qZffcaZah1A6pk0mZcM4IEWkAh_GDISsJFAsdJVAoYIq5TCmhw3tpHUYADAKMcgdUXsFDArmg3BhJN_gwYLtVKoDAKtHudUDZVnVeZMP8hgt-I2ZdQA7wNBRwAeME-OihIlgJJM9ejz4i0FJ9S9O20GCKZh22p20EAqPIiCrp8E6iziG7rSFvDISMO2izj65LsgcUMV57_Kxo8NG_4ctnTIn2iLpYpcBhX2le1s4L6EPoAXKMgte0I1uUtegsu1i5bWBS5WO1N2pGtF2oXKpCMToV2plg65Ru0K5VEsq5Xu1idHe1_iPTJB2jcQHZSiJ9bCO1_4fASG5Vssk5XWUjSBXxvxAGU0NvEg7Wo3ta5mTZ3hp7YAbJssolkQE3_Ou0T2lPLu5d-192mR5mYPyDPbLYANUNBRoiAHdjwNvLP2vsMS2lMBYCHWR75d2hGAPEUC9usU9MJfLpLJSNilGAdU5W_L4kIfKo1gvMu5Z-05IhSEB4MAre5be1vWAkot5UvLfnuyzk8M6oF5Qxxf9vHyjSJlBkFb5YqCPu0VdpyyYXqXpU5aAqBsP0d0FaPK05TAF7LjjtqFeiEs-sBhpeL5E5cBPKcoTDyWFWu12FScJ2yngqR0BgryFcvLsFZt9m5ZwrmmB3KT2nwrG9j3LNZV0MRdAIrqFT-0_9hnzwlF3lhsKnLIIgvNNFfhppjsS4iCjoraFRppXSOtZ22jHL9bKS5mmKR0WxKxoR0KxpzFfPZf6DL0vhg4qE0vToSwnOhrRgrKedpZx_VDWAjZEpc3COPonZdJZS_pjso1DXNABlnKpgIPLeDNrdXQKPMdKB_cGAit1B5XaNABnSQMxskqvaR3JYleoZ-5GkrgxpMpq5JHK-thAiUKkwqu0KWxlCunN5yC1gQuvEqX3EFQM5vNFcAhnp9-HX01xmL9d9k3IW5NwQgOh3JuCIHVw5avM0lCPt0Gouk1IkLpzxugB5AMx1LyqfVctnLF9dhjkYeYIKFMijA1lcqIPyt_1UDnhIDlCEqXZaz0UKsLLA6j8McZOthmhsMNsfru9IWD7CRaPAdOAPEIf_EMrHFF9zgAuO8KXLiNgdFAkqYqgcdMj2EPoL8qEmdlYYEsrLCwrWBgVaSCYEkMq-IqgdzkRjThaI8r7RC8qZlfIAwhgY5igJ8qtnKgcflciDvBj5FvxGDAHIljhlBC5FIgPASQhKooMlO0At_BirJfEa8jQGCEWQR9AAVY8q4pZ0ymGTAkYoBCqOVU3Tv4qUQGxhONcRgiqSiWdjG8N8UiCnLKbeLMpelSrKQjq4z3mvc5NZX4iXCowQdgfp8iCuSyS1FK4alNFQ9Ocx1vFX9LeZQGp9VTVRAlfwht1CEqOZTSso1JoYwZVErfXjHw8lVDKTtlYZE_G_h7Va5R-5akqB2ukrpCJkq1xtkr_iKZgXVR6qClX6qilR8UcwgTlC2hcr8xeLtwqPboT1O6qW5iZRK3FcqGlV6q05s0q6lRIl2lSBlABjPL3LgVg5VSH0BlazsW-kCtilW3wxlfENTCvuVplR3xHFBDLe8EB4ykAsrPEqWlllcnhVlT2EiGvc5NlYCrwDl_wvhgSrysPsrHZV8MjleUr1sKcr17gDY3ZVcrVFYLQEVWqreBQ8qIVSiqm1TsATFPIBW1YQBsgO8q4AFiqIVQplcVR-VoiOOrMsGyreVYIlieYkywVagc4pYDyDnPJBVQcDRr1Z1CaRsnhVdhyzs1EOsClGWrpCoqqNZbpkj5EQrcApqrV5tqrj6E74-rEjK4AEaqCZSar_FWeBLIJ4rRpLMpwZS-FDVbMoIlYKpsNY4jKPnL0GVLMppVLkrcNYRr9-CMrq5OMpDgZXJV5tKqgNfRr9-CrwqNWRqaNY7p7NKvZXxlP8k_h20qWov9fxqfB8Ycy1WWrlKzQCMYF0eWjWMsuiXoVI5PQDI4zvCMYFBqB9zVQh8olKEhyPi-F4PjG9AbjMYbfnhdxJkH8dYKxYaAOxZF7txYg0BtJKjEsgQpWVoRDAlo3ILtLInM5q6pGDNEZrbB3NR0L5QEx8CpD5qOnJkZvHDkY8jH05ZuKFqXtMM4zwDK0JQBlIiAOpLyGjhFM5VqcgvKAkEteRKbZvjMLQEZBiNvjDBFOiF6-BAS2_G5KNjnGN8YbBjDZbSVTgHrYVIk-A6ABaB9jMoJKIFzwBQG0InoElw90LJI0ODW1BOgYrgBsNQ3FXqqSwm-TClFiB0Qp80O0mOZ_ZWDI0Kr15X8C6RWKpF9LdGk8YvrohhRu0BHACxgswMKEG1SOEp4CThtqM7YVxFps3ZpNrRKkndFiDHwTtXo45wkgNmsnNrltXmBVKFPllAm29ntRt8MCDk11EldjsIKbVvnMNhfnBfl3Cls4qCpZ4vYYgV1rMe1l2pzlCtdDrwdg3FzhLkCJwuFhtAhDrgthdRmgNDVUlDGrPbCdqMpFRd1rmT9_AuNqj2m-1aLvfdVwJGAoxhdAbtRbpBNHw8lIC6Q6dTtgGdbH0wAJbcOdSeMaddQ0v7g8tT-CdqzVKNqCdaF5bSiuIRddEqvhBtEPLG-SRdSdwZNWaiK0eEieMmOBYta4B4tVDACtboqJdPDrx0uLq_AiQ1T-EdAhda8I4ALdqCiM212dZzqDcgnd9dbUFZAm0rHlvnJr0nrBPaPnJmdbLq_Ak6pNeuPl4hHbr1Mg-IWsP5F8-i8At1OpFKkvIArgHYp_Im4oWsGz40AJxwjoHQIvudsA49WQ87JHqFXdbTc7JBX1BfjP47JIYy85Z0JTdYeMwACRwwAHQJoIGdRqvvwoTtaXry9SeMKYgwxDnKpQ69ezqG9Qncdgup4WSJ9ri9TlA1btXVfsKGFC9dQ10CMPq3yZXraamc8iOgYrRtUNq3kvWYDHklqJtSRoyNFs4vOoTjo8hVg4dd-1CcbFiE6qiViPIVrh8QnUsQPg1OctxpXqjhk1Km35c4KXsiEv0VcJhsMISi25iJNKoz9RelZ1ERp0_EhZWIPPRN9RLF-RsrK5xUQABch_rQdV_rH2OqIcFNFsADUsBOGVPyCXpOhsQQtAhoHQAK1elBJ0MAoXSMgaVBjAA3ijqCu1YspsoOtBIIjcgSDeGBbSmtAzUFZExwOiFOvCQbONIVqvFJxpXqsBVJVTktQVvrtDzOyEKDXQBIIl1cEVhURqrGPI79TSB59dupGFcvr8NBd9ztYiAvOr5EmFbrqZ1MlqgAvvLrAoV0HZabqnXIYyPMKTq3_HIaUFVYI12oLqZdabqW0txpvZHnoIAPDhJqIob3UFHVIimgBC9WYb-9fXradZPrq9enFzIGu0HDeMFx9QV53tT85iljkBXkAXqJ9f5F-XgYr8NPS4ozNRpQzEgNazn381Mt2YOrAOY9LJC0BDavrNnPc4m1KJ9xXMTKJPh-AZtSGZMfrPQt0vVEz3j_0xNHLo1NQerhqHpqmJtWYrtbGUqKmGVBTq64oyj5UFYgy8-IOpimFSYNC0O1Z9zMuJbFYwQGOg3FDce5JPhLnYogEUQQHMQEWQIu5ofK8KE6ksoofLzcESFBsOjTLc8Lnf52HhrEPXMsbNjR6Z0Qhw91jU94z1EoNj3rQ8WkgAqActS9Z7kXqPQl352fNO4rjZV0f3li8ntV_KLAEDrBcKtANnG8aTjbMglBl8atnit1ddVS8pXgi99npXQrFOqqR0I8aolCPd4Boy5r3nnUaAMCaPjR10z3q-9Enu0cVuoKznjT9gMTfm8DakCaNjTib0-C-8yhI-8POplR7Mg1klmlVlwTbPcgKKyoqTQiQpDaI1r3sa9V3Oplf4Noj7RBcal3NSbBQkOMzrh8p5IMcaz1N4NVYbrrc9R9B1MaHLUAggqj0LKbuTbor8WkFhGoUphkGPCA45Bol1PFR4GdAAMRwui0QthFL13EpgIvNA8fqFyEZwjF5uMtbs8MBqgrDUvpsBj7l1FhjqW7EyqnFmvApqGOUx8qfrs9LNU8dFvRi_DyatdSlriUFTr9DWoau5MoEy7gj5mDaylKGpZ5GGoYFe9dvq12lO9sGpMaGcaTQUgkri1jURpzlqRiE6hNQozSCFczYhEXSGBsawNWbVDagExtgmaGxJLqyGhb5wzSzpIzS2a7eO2augPVsVDHNrB5lkl-6qF8VuoobE1RwohTYNde3tCspTRAUVDWmbjFD6FaGv2a4smub1EqaTHUiuqPoNLx0NfhoYzUAFZDaYVWlds8TzQ2J1Df8xCcRPV7je8IrniThbnniLKHt3d_nrcx5SiesiNFeaugJxpL9eRoSDjihCcUB0R2nea8uG-afImu1iTRBbH2B8A-DagAtFcWQSSkgVyzWPt1Ta89PzbhM3SCO0H2Ik9UXuN1Unhoq12nhaUXliEJEiqbE5Rhbe2nj83li8VKBoTjDSqwMfSif5hMNYBzQsMAJ4NN5qosQF9hLxBumLSElnufiNvDnJUALSt8NCXQhLbLh45CKtNqAgpgmEmJkRS6AyQg2Jgunck6BHm9hsJRbWNDI8GCNpaaAkWsU5drrWOLhayTd4bZQv_INjQyLvoNtV0vIkA3yR-a13H9Z1Pt5wfgCMAQYqqzaZjxaYAirxKgBPBDJRcArqD3MEPJcatTW_4--oDhNTacboLau4TuIs0biCqaYLcyaAPgsNMsIlbYregV1LYnLulZ14BTSpahze8M8VAbiMrflb_wMSaXSCybysGPJiTdipfIltrS5AhioiWn1grelasMCdxZHtlR9LUAE0oF1br_KiaPPBt57uHidwgNzgiNPzgS6KScYgrST3GmthHON0BvqNbIBnin4RrdTdxreZ8TaIoUhmAexH2GtbCTXiRVsEvJdCHeacKkdQlwmFBBlqRaowIVBH9GvA8SJCBoarJgQVtnA2nl1glMFewOULex1LZdab3tPqiTURpgJctQBgD6pcjgshjdN9b3rWH4XUCqbvrTch_rTABAbefDs3jp4VrWNah6MD0kjQkaO_JUbqPjNBAcNDazLWc8avrUadNXpyVXqKNmLITi1rTCAsraxpqyHea8bTTaYAnTaiNIPRIgDlc5dOZqIgExNrNWjVBjeka0jZTbYLD7jOTUQxkjJlaTwInLZZA8FXknqkJdJHKVovjb6TSI9h5WLb5QPmgv8h8EL8M99hDH5oQtc9orTjeqUjoCbE1Bkd5AjdbV9OPlkjRUagtFUaVdUdkI6pvpG2PIxIzh6NNrfOwzcB6xLzebbdgKPrIGK1FtgBDak_HqCIzK9Kp_qQgJfk5I97NrAE4L5wtQENJAhE3BghGxJ8ELMAl-F7L3IAXgk3GtlvtonBPJNQCsQENIHIvgyaAQeCKUH_8aCiXaPgFWgRjIdLesMdKGuHE1zpZdL0tNdKxTLdLFNU1IOHMvAkoB-KRIG0QXfiaImhJIAe7VvI-7YyRfHvJ5BpMvA1HOogocGcA5HOwAL7kOgxZF88yMLHa6yavEO6Mei7UskTEgMvFU2qfxx2PdxMgOxgfVFQM7gF50g3s1YBLALaELdpr0uDeBwgBEBvhinhR2ACN0gsFlbeoTBx2JHcRJJgBqoCYNAIsMbo0AA6LBrbTs8qOxH7ZtZUANVAVNDAAoHc_bAIoEZFYNVBkHeA6CsERyBAAYw2bGzaGiV1zwuDMBqoIs0FIIBEmnmWDqoHpAftqOw7BBxxqoFiFcAu0wWoAhbcAlIBx2E1AerEfaT7XCBhmFpJy5s1ZdJA5IQxEpJ57MA6vUAJJPLYpIwxPPY1oOGAahMWBJHVJJYeJA6n7dQB3RAo7DRHRwojAWITBNOxN0Jw6Atg5IhAj-pe0Gg6FNLJwzJJ6pdGEm5voCzMKai2g20DIxe0Och0QPPlz7TsRwjMggowD9oxRMAwy0tlRqDKSwO2PUzvaZFgbwVEVyEJQhxQM0AHaD47f0G-jJYJE6dseFAV7dvafVEN4l7ck6t7dA9_6KE6J7QIAMnUYaaejWB4nXZIMgAU7UZPoASXpLrKILXSVeAyFe8O_bKndYE6bb4JxQFKB5ApRAQNIBoRrMH1K8Jeba6aCRuaAM6XSJdZ-KKNBirPU7CADCQYNL6YNQtLxnTEaRanYLhRnf-89QUXVrGDQBHuAkB8bMkQaKOgRcnRE77JAU6Undk77iOrZqAAZp2vAFg7zOsZ3zHdRv5AkaWTg0t2SDM6qzCaZHnSPp8WtQAvoAP87aHqh1MdYge4msUx8PEayjWdFojpmktLepbkerQZVOgVgVTTC7ogO3Z4XYzaEAvn0DMFiAALec4a7l87UAHxwz7epjpVJFhvnbMBfnY-4AXfKB3WHqlYWpo7qPhU67kkS6DMCS7UNH39A7XIIqjTS6iwmOAonajJFnBRqD6iQF-vBi7jVDBAu6hXralI8NIsJi619ZMrxcFiBSEHdgL0ncgUbMK67NO9dmKLOpVbZLxbANqBnoLJA5wDYUthsxZMoMkZenR4Re6mLa5Ps7QC1Gbq9XdtQHgsMDGWol9yYo67Nbd7rV5jTJZxu3xbEHSsGBEXZUZP7Vhils5j_E6rrttAtzAGa7jiIGREBtxFwkuCVg3dbb5QIsZcbd1AWBJDhhCLXbl-GsKG7VaKkoBdL1Ji3baHG3aFCJyhrXT7qjSNhIh-tqJysAadNZSJgRYZyEBIJ-j5IMBKNqEcAZoNipxmHnDcAvS9Y0oFt_6PJ9xYKGdeaC1hB1JEBR3SOoh1MpkWzKxBzpKO7ZXC1g0HeOxjXtR9l3QsIAOAXgFhIeoCjvO7s7fXA49aj9ScghhtfOa7ZQl_aCsJgxG8gYxNDg0Tb0Lox9VjUxZlBUp_1cuDgAEwdV9uLgwnTMAHCgk6jnXrAEEqwpGiDgAv3T-7Snfk7_3ftEoOgZgSnYk66ySc6PWKbgsnaCtQnV0Vf3WU69YC5UKIhyzvncQ9oDStRqoDJxcQtkR8ti1riHrqAgnViED-uEpsPagByHplxmcAR6P3cR6jsqR7QFOR6jcDJ4RhiNhAIu0xEwF9Al-BdD5nbzQOWfoqwANVApXdy69YCJ7vXXABfXaGIi7OJ6DMA3Q5PfbtUQNJ7Z6DO6zpBgBxPZp6ULLMrk8B7aMgIp7f0IZ6BAOp6nbVFDWGEy6LPdJ7NXYmpjPdyokjImppPeypqoOyoXPQp1-cG57PPZjAXPZO7IgG57_PUQBzPfRYUKg56TdKF71sNJ6X9CtRSctVAYvTis8dHABpPWe9RQNiKKHRyzePc1BT1Nhdymt2FAcIwAR7Ywox7fQQtwNJ6WoKu7HDCmbuoGe9OpIP14zk4x9HafaIVSYNYHZV6g2E1ZoDNJ7wVoOZ_7RV7QOJnhw6BkbuvcaRlHdA6IVWg7UHbnggjMggRvVl65gbV7BvU5IRvaw7M8MfaDHfN6S0OV7MmMwZFYOx6frdsDAcFS7PWFV6fjZ6qN3cEZ6ve6FymGt6uHZdt75n_aqoMABjveOxOvZHQRveGgwHdVAXvYN7RHeg6OonA6EHdQA6HWCE5vRCrnvRd7kEMfto4Ct7OmLd6NvT9FyvYgo9kAJR3Qsj6K9Nkq25cLR0ffUhRSuj6LqHkbcRg0wpYPDgjgDcJ4vbfNmrN5693W97o0KLMvvcAB0fUN6uvZt65gUz7lvRCqpANBA93az6S0CIx6mJIB-PebAsvZgxCNLQwH3b_4n3TiIYGMrEYGJQA2mMNhnGJoxC9kqNZ2FDhd4DxIhDIgMcJMUIgNPhIfAkI6pHShoxpERIcgob7FHWGwBvUGxTfaKJIOJD6J2Eyx_VhupgcScxxHeJJzfRo6LABOpXfcZIJHR77lJL75DTHdRB2Oo6A_euUyXRMxlhNOwrcFo6wOEyxo_TJ7BNMJoWhAn7P6Dr7IONu65bmo7_ffPYcfYZI-xD8wBhLuIlxJlgTBgI7Q_f29-bXJI3fQpIc_fyaGJHI6hJIisWCL38H1NmkFxPKwC_XKIpmHuILHWYBSEEY73MJF1F1PhwlHVb6o2KP67fR6wwOJP6vfaS6-_mY62OA2xY_fJokTuY7-NL_rJNFW01_Uv7LWImpsOGpg93WhxZ_aBoY5L3JScshxyzv-MvUtY6J_ppwjNQ38xJjdJvpc5J6WhkIqAGo9KkPRAaCqpCb4h6wdOPu5l4JgBkDMBMm4GA5UJsAGouJBNTNZRA3ID0h5gBrIpwaGjhQNMYujD0YIEf0ZhQIMYk7KTQRjNhKNRXhKkoOeLVLIRLfpsRL49HE1xwY1L49H5KBmTFo2HI4VMJsTLFjAIhvjpSBaXFOJzVQ69ZQGepmBKWYETl6ZWJlMhXflDgTNQGLstDkZAEpYAPqNqYGgDyYYBLdM-nJIHmtDIHvjPIGr-BCcgte9MesFIGZA9dNPWhCclAzoGVA5qL9A89NxAyIZlA-loZA84B7uNNwbpotMTwa2U7pllpLA8YHrA5qLbA_YGDAww4nA9qBzpqeL4nLdM_A9yUSJQ1xMtOyVgg1EhnAyU4wg1U4sZafwQTltN2Sg4HGpdEH_A8VNDpnbAUgz4HKyiEHsZsJgHYf0B3JFc4P_WRglMMXQCnhPAWJYMiHxVpjSxVG5nWEOgnVp-dM-ppt45POcjHiowbinasrOlFsyg4MgnxSo87nY6h-cL_JUuN9QJIEW4PgJpK4NLzRxrdiofJTQH5zP5KYtHm4PXNi4koAeLBlr9aRlN9RioPgHcJcU58JReKiJY4GKA_SZ0CJMGRMBNx1RUcGK0ScGSA-OKyA-cGFtHE1KXNiAtgwMtCYv6aCuCWp9FavMysFqhbYB_oeDVQYFOiCHXfWCHlRF6Yvg4PckYqr7PVNdqbmF-pKAOKAFjoidCPd68fDF50w6gG9Fal34E9osYokC8dkBl1soZLX9bzRs4iQxkISQ02gG4obs4vu0BpnOLYpqEnplBF3QaQ9Eh7jp-AW0tM4XOGwHQRgD53FkCJhwFEQUtnOUMFKzrSGGvIA8DeFzZBuEnNiOAIFA2JyoMxARAPiAShMwpaSFJYwvAQBFqMEAagzDwMzqMpOQ8lsRkLSH7jsdczbdSGvTLA5SxJSA6Q2Tlb9BSHH_aSozQ-iGfjsSH7jmY1EoLF88lqSFOg0ps2JV-dBQ9tQOQ7aHsQPaGFjk6HeQzUbufg6HFYFDlOQ3aG0Q4mGEqjyHxsNrbgTm_Dkg_E5Ug3kH0gzVdhDXEYHNW-oSffxMldhws-DJaGrLPWdP1MyUTTmmYcLJEHDpTEG0nPoHpqlc4nQ8RZjvmrE4vt2H7jnIIpQ_QgZQ8npEvnGGQDtSgwACiHow16G76qr4BYtKBZw2xCy0hXxhQA_k5Q7OBWQsJdoXAya7XBqd7eihc9sn693RhzQ60l35dw4Wqy3pSHZ2hs4rw6Bdo6rl4ow-aG4xo2bN5amHPQ46HSQ5Wa4WuuH7nGHgCgDuHTLnuGczh8Hz9q-HMTYaZ_LsJsUnt2EnegnNXjUJNETjeG3Q1SGkI4KsKLKw17wyBHSVGNswzsXcGLsOkgTchH4XLH0qdpLLadidwCI7ohw7kEbyKKmGw8AvMaI4U70aW5V8fBhHUxNDs6LqRGQjrmV1nJeHcI7-1KdtmMqI5XQKFlbt8dD8aGIy-Gvw4rAnQwvMJI_Hck7mxGqPUU6Pwy-Gw8E6GA7ppGA8LaUKI-MAQ7sWg-w1MQ8llxhnIK-KUgMgjGbgBGtwykBgIzBGZTgyG_Qyd8EksPIIw4JHHI_8wGcizRKI8n1nIwo1XI8GRlBNi4E9rGGAowp9TI99x0wyFHPw-mHwozWATI0bsLQClHatrW5Qo6-HzbrHcjXWKcots68Qjn0xi0LlcdbdkZ3A9IHTA-iczptNUu6A-HElsP8pw281TThIGyozYG7A25AhHLkG7YEWG9XgdhGIwHgewym9ZI_FGhw_aj6owS0j0P2deI9FsZCqeYZwwEo5w-wGFw6oVT-LbBIAy2xaxCiGwcAa4GzlaY5dHNHcaIsYPRhGYc8vSioAxtGAlFtGXdSAHsUKtHTo-tH7_JtHsdGoT4NZaMNPp6ZJjFRYRrHqhzI5rI7Iw5Hs7u_5kIiJ8fzC4ZxPhkRJPu4ZHMpOEpLB_ALwjZa7I0chEw_KHewvmEG4ihg5cdMasyHOUzqO1Q0Y-VAYDdNQ5QPqb2_sbb3aEJHgslDHoamocrI_JgAlNmBjwEDZcgU1UBaLoQfo4BHtwwkAw5pgFYI2ycSRs-Hs4J7Aao-TG8Y6jHEoyzGuXfzHo1iaAhY15GKY-LG1MPDhdYEXR9zll9MIzzH5Y2f45yp7BC6JLBMVHjH9FQsclNtrGFwJLBosubI2EATHiYwr9SY6HRZYw1lioKrGuI-rGvqOccGDGtGSWPY0UQ1NQcFL24cgFliSFFpBg2fnqeWkaZ1rVTpl1LjGE6tfp1yh7RI4w3F9Qujt3OX4w-VjdQa4EIxE_Y0h4Whs5JqCiKDLIjqKENKAPwi7kC3MIs8Frp62Q9c83MsBY6QtotTOq1B1DrBGO5EM7EmUHKJnVvgqEbMAPaJyHy45B7hZO7dXuubJLTVd5eqN41SVtupuzHbZ5vO6B1bF0BEmOnBo6vNZI5PGzJwO3GfLJnZzLDGYMku5B4A0TYVqEgHMA6iJfTIvR149CN7lbWAfLIHYCbDgGpQJSo_GeoJVwBfGw6InZpBKTRKVM3HsrNBYB6KM774zWBq6vKhQYO5a30Di40oGvGE6gAmP4G-hTrKT4AE6gAwLDCBx0qPyugnJ18wLAnUYKAF5UD5YM8MRUy8HgqjbltUhg-9xoNgMGviXFVhjjBZIgNUs_dAQmwdnAA4Q-3d6Zb8GEQsZ1NwxyCOY2WFyY3caQNukx8Wr9gUOlFA2eAwQxgNA1Fmmzx0CFbkJQLSQmZsz1XPBAiuAOz0uqB6hP0ZwseCjcBNzvExEhrvaSKkQoYgsBdNEyOiVuiMBgFOgULFG2CETWMAkUbpLYel7TCckYn-E0pBOqBDB2eJVbEaolrmTWzx5AjABXE3wnTE4UxugJ1QrExLoBnpgn70IkASKsLg8FQvM_LAAngDagAIrDrKoExkp4k-VAIrIYmP4CkmYkz7zfBh9Bgk9gn68BEmMLVEmRgCgbYk4knik3EmUDTi4MlEUm0k1Umykz7y-mHl9sk-ZYsE6EmcE7_tIk35YRgAkmKCC1YSkz0makxQQuk8kmqk1An6k-BtIRnKAZzT8r9QEPwIAC0mSKnYMIFQNh2hjXx5k20nG5cIqvXdOK7haUHzcOPp2AK4d3Dn_MK5XcIcQM3i4ETsxOwDcI15tgBs4IBYGGN4c8-LEExEP7JaUG341mF6ZNlu9xdkwh7sXHx0AERIhSE-8neaBRZVbjpGtgObgZmrcm9DcAisNAQngU3bGy5sxQPk9iAvk-bcTkwT7Q3YLE3YsBZQU8zAuguR55AtcGTk0z5_iPsHOhTcQWIxzgAlGCsYQ8utf9jDzaCh4cm0Mi6haM0ISUymhk8B_oSUyT5G8HLg5dihb0aWNHio8q4rA-VHZA-oHEjsI5lzEbbjqLLHNqgnUxXqAohrUEAoAPzhtqBJBUIB7QLiONbNsNzQs6Bz0f5fe8HuJsAFwOqnmIqNAgY7mc9oyuHSwbkQ2Y39HOY-TG5fI0nawO7HEQA9GLo7kQ_1IiGAxTzcz1EC94WmUsEkMoUPXoeHX-seH7CNsn41hCm1Hkpgz_DRL-Y-wBLk-gAbhP_Y8-CICFwDJIB4YuLwvMo9TFcAimFT8r6VX_p-FRQQTk8z6dzMymwVM1YelBEUY-NcGQbXfoirOQm4MTZ8z_Cmnrkwt47DqLau_CAaVxQuA1xUwFZ5PSFJEPAZ040aHElrGLQnhycjQ0pt2mtDVOmiucWgCUiE6v8c9rL_p-041kzHrpLu5gebRSgJAVStRNY0xkASE8g9IwIenxsLaVAU8g94-u_7IU9PxotgGib0wY5UqLaVH0wCcP0yGha3PKgebkwqyXMGnC0DCcdTcJhGQ0-gebpOHxo_zJ7XovdHXgiRIwPM9GlRCo1ACGwQ7bxrJ_hxNqAXxFFpMJqpfvKgvgV442xZ0K-CTq5dRdkGiA2lArEzq5nALLBCM-RKKJQkH3hZu8pRXqKeSriZmhU1NZTFEhDQDD1gFHhgAk8JgTRWRm2MxpZspAoRuM_vNgFCWKcgM8BMvD4CimPezGM6SLmM2ZNWMwuYOMwCYBM-lAhM2pn1LIuZ3ReJnDQI1lIUHhhgTT7gS6CiLFrUV11qDEA_EjjEXkl0AkiHMT8SNbQO4gTUGhaR8HALlFoRKpm9pvYQxkCrhLFNIYrhFcAoYA1yV00HkrgHD0k2LPGycCzxpmXAYtbCsoggGThooAlmfiFvgbwOiIeqT6CBEByKIoAjAqwZpA-gBQdQs-DzpDAnq86fDA-_Q-L2ik1xmhYf7dgLCBw2PQDJqNaFjjfUADrfIwMKnkAzgvUhEZWOARdXeA_wtmtiaOBZvhOMGPXPOIIBDE6awO-smndFthRLRdaKsegaACcJ-XZga1s4kAE6JXR_IuHLWXl94cof1am8D8UsnnzRZjtvMHChfZCVl8DG4qTJ_IlNQhEDRnOs7-4ekHbQ6VgbB5-nlrTEHvBeNu6A7QaxiO2riA4Y4Gz0-MKAspcDnRpU9naM3xFoMQtkGVsRsBJvbJs4MRo4rJ8JeUWsgJ7SNQPniQoPXCjy4MriDnrNvMRZEMAIE3SEOAO6tZMCPzkKGfNDNkmsLZJ5biXOVh2LfxgcgMglIjXTmVZgzn2hEWFmcy7kleeEx4EhzmRNtQtuc3UI4DHzn4mBtF2c-REibkQURMACIhaCznoc4aFCQjQBmaWFsAxUCCHEEIg4ABwA9UKmilgH_Cjcx4AvOj6pU0XW4KwSRnT9WlA_4ZbmCc5nZbcwg5hMA7n-dXxAueIW5k3FzxpIh0oH4G34tUJ7m26Fqgfc6kA_c1Q92oVHHiVAp1ejRuKo8z4BOqFqhQ6nHmDnoUwlIHqFLc1zwOHh7nK6Fqh0CPiAIGneEsoLKBdAUhhXU2wh24viBQUAp1h5fCKgrUTh881R595qbnLczkBsVB_J0PAg55oLlrq2popfUkgU-4lZHlnajIEHJ1Qk1MJhW8xWDBcH3mk6H3EPAHXma3by795kOIW87pKbxUThp88BghAvPnMsA3mvaRfh8QJIAJIBkyB4zWrzAKDBC0gkhWAEUKYxaBnXsyKAhgKex8YygxP0Vho2hNyESWN7HzAECC4vMNUlM74A9c5JEEHHqg8ALbAP4KAWfoLbAvOg3mcUCAX2ACET2AGRnCM4VBhMNitLIL6QnUIgWzxaW78Zsfn9svHxbYCdwaM3Rn5oNXEwZAQX4C0QWsC5bnUC-gXIwJQWiA-8m0oNPDCC7RmzxVXEJdHBpyC7IxWCwwXqCwhKYAGgXhkE6h6C01wf0-9pA88W4Zw2e1-ZCVrxIvvMIAFDqmC8RtIwFFlyoG35v7MC9lC6oXmgPjNSXkHwlC_jMVC_vMjC51Qy9cRs9C2-onAKz44C9CKE6j6pADEsAtmGSBnC-MBwLMz4NEOgnAZHtYyaKwBwLI4WXCzMB3C04BPC9aI9rHd4HJX4WfoI4Wgi5hkojYCHJwPn9k3D4DpIsRsCM1gWOlIkW26MkW5wPjM0iwwWH4JkXi3MkWEHLkXjwVQX-mDfnT84Stv84OJ9zqaEowX0AlE58JGcFqh3JcJKdXIsJAC1fVhg-lBFhCRx4sC9w0Q1JFIfqoShsjQSXo7B9GQIAWVIhoZWkhLdwAvA5xIlMWhix4Bui1LI1egCHq5MUAgQS8CPyVpEzPUsA7FECDTwH4iji1pFzIpyAFlVf6anNrnKAO0gsADMW9UECDQkFWhcQ2iBtglQgkJFv4PAEU0xRqKVJzi6AoAPqt9tvX41sICW_wkCDQYACWFwPqsL8qlxoS3g13i3lwwSwuAxgoXw6tdoSSFfC0US2WEMItA1MS2vQES4Ix9ygpA7FESW0QBZFYWZsWTnDiXBGM37awFVs0AE-AJln59HcjchlFvm8HgsqCZoPJAFIO5xqS-YAf_BsRHcvIA7ihSWriytLOiysX7i48Xei4_n57WbnFiydtliwxE1i_zINi6fnJwPA4dc9gA6tc8WegK8WJDXA7UQAoRGc3qgTJEesOlMMhuGn7FPLUeti1TigLiKEg3aE2ppgyERO6G7Ql89aXCoNA03Sx3QKfhwBeet6XCmBbQddeCRm-H_mpS1o7UQFylZi470_w2N8gjQwREy1a6x5GbU1jeGEhEIyAxgu9wTbrJZvM5DNWMx9UcUC5sLoB8CfM8JnQYDcIskxTbR2KiAsy-MFjSwQBTS-0JcrReIGyzmWVeBqWx5GeAhs4kAxgvmXxosJn77Yz0qqGr1ri3gFsAIAWNDHXNUtbnEDs5IAAAHrKg2aCUqVwCeA3gC8ATDLAAKGAFQNcsblrcsowHct7l0GDrl9UGHl48ucgGxToQAFhbAfmR1zNV5f5s7OrgDl7fFWHT8F1aQXDIfhQWKKCyoNhXvl7Nqfl6bOnQLTq_l5dX4kACuKwICtnZiTrQCv8tTXX9gSG24sMRVwCyl6SLwOOtQUpC6DbFykFnF94AHF9gB4Vk4uHFvYtmRU4uvzOuIFQBZUBiqUsoVtCsjFhhKKloAszCLotepdYuFOn4rallYuoVmgToVjwCYVhFLRVTzMSRbiszluxKMVuctal5isiVhiL3ljOwa9VebIVp4F6ljCt7AClKxGvqyLCFzAbmcLgNluMvaVs3kGRrSsdmQyvEbHTOMOdTPNaSUvLFhssGV16Bxlmg01gaYPJF9UvdAYTBWJwqCGF8ysiZ_TNiZiTPGZiYvMWEYAn2vSvAFuYvFQMb7wFqjNlhg7aMgdYJcpHUtYAWMt6oOFUzCNZx6YMb6-2vuOrzWivwOGUu8VkYsvsTl2alxUFC_dDOlC83iyOF_2eaKMy_xJKDcmABL4mU0CUgxkHggzkBuOZiwimAizFSY9KRdIkzyQIkyBQCcvyodyZUmdLTUOTLSZcQVkzxFaU3gUUD7GRYWAJKbSN26ybi7PbiigF2DmwULrrAHrgvZJ2B5SULM1ZuE5zVhasESpav5SFav8uSLpUi34VUi5rTbVmsBZOUUDgzEPkaVy0YK6pdHK6oLQfV81EaTDqvyoZjLmZOTXsZazJ3TXtDtteSC7Klvh_peSAVZCx2h2jezlKHX7VVuloRSA-yZIY-ySwU-xQTRCYoTP-zwTZeD8hXxwPSaf5qOOf66ITRwSTdYChOaJz8uARCRBiKWfVnkrlOAUragARC8uWmtKOARDZaMKVrVamsiGLpz2TXIxCB7eDk117DKTNXw14WFHvcZFzrAPMtE1l_gY5K9OilBTIS6i6AK188BGygdWIgEXXIUGFF14K9PUyhTJfSNCqj6j1QBi7RzKhErBrF3iya1O0Q7dQeRCk4RqljMrBdyJ2vkXC5yO3eTzoJeiOSULuQ-1obb_B8R7pm2frSRv2sh1u9aB1qD6xi22g5MYtYgOb8S1rOsjuglESDLEn5e1oMJspSzwceHfJFVq24_KdHwOW5t7h5COso-YenoMt8k6JXfLWYJk04-IuyjuJqJcvUuvspcusGMyuuLRLuRjeZaztACahkqx8EhRwuuvCVawRWdoCMAAesV1oevsABA3T1mevT13QVeujOtg6ou138qutpbcOvbmrOvL1uWmfKUnzeMafBg-ALB4YWTAYVbar7hCmjj1PzL_Ie5L0EZrOxAVrPJAZH20I8epB6G_0EkShMe1IUmtHI8XhRdxLVGkutdlDTJf13mKZaFJIH1x8sFyCQ3G-OFZsV7PwKuMPSH8YVQufXbbOVNYqW13-C6ONis6lQqPgNnWLKjdzKx1xEuOWXtDsqEdA45aDTxVNUsa1ywSrAFSrf4JFra6FXYKIPaqmy8Y3SsI6osNu0j7sKWt14OVoTl00L-HIpTjXAhtv6EJjUANHBwACvM6eI4R0y3uKr0DmufffiHIFEYBK-HC7sqFDJf8LdiS-XGSL9UVzVYVAhu3eIu7VePwkNjJIqNnt1fJVeg01hRtluwxvNMcrbrlE32iNjtrT9AoUWN7oA81uqWllfiECvIxuW-P6RXAbRspHVxulePuLLVAZztnahzeNzXrWy7HSocAJvSNlxvmNkJur0BmtFOJXXM1vkoVOHJyKN4uqHNeht7NZay-Nsq15N55ra6A6qBNjVwX5Hxt2N7HQItfJt5gJJujDL1Lb5_NRaq8GOlh0O0cTXjLAIu-Ao1kABBYJcVIOT8XXPO4TyOd5JpFUGEs4ukIk5_2QbEa0Dv5t5IUqnKHLpYZwcZPazrAVlz-FYFWzxcZu3aBQjEq95UqRLfwzJ4niHNxqLhFARCbN-SD72sNQUFV6jEqtZOoSeUAnNmICPNzjxDDK5t4pCUE7Nu5v7NigjtAEtPPN2ZP0qi5tmAfgID8G_18dCZu_yW6wYx4dO0kKQQTN0cAfJN-DrWas27N8qS2iRFt7N1U0eRUUq9tLFOLNyZOlWorXwE_4j_w52v1LAxslKz4oe3TUv_wumW0W2FuA1SyXBRHhXLtNc6ByClufJBOpmCO8BL8DvxWAUGv6RoF08DSvxtCZDyrgdFu_N8tgrZ7FuYt-YAC5LihZwevgTNqFNYAeFjyt9LRAu4qDxWtehmCPDx0vaDXVyT5v7wGLCnWCVs_0Wtyn-D1z2G1BBSJpaiSIMjCCsqh6qZejLG7fqhg-L4J0ZeYBA4yVs1gPluJAAVsqtsbYGRwBjTYFYQWKN1u-t6vMPdH1sBxGLDDYaNswAP1sYoFYTLzPt2rzZNsWiTpv2Oc1qUhpQYR2jzSo1h0DesLMggTWCYYIOdAITL-x41uCaITIaT2yZCYVt1CZNt6MISTH4hcFcLgK2TJDoBxlEDGYOxn2O_OX2IiDX2KeC32bqVUA2YA3xSrjv2ZeBLYNqDnSHkUk1hds5QJdvKPeO3TLSVY24V0Au_CRAeADBBbttPA7tmgDYzPg7EbUjRa6QBYZyWIrD5bRazPEPp4jIrqg3WnMi52RaS-oRiBrQd4EAcoq_zPBYRguEWr0WIpQ3fha6nWJRYxgDv4LbchQ3aw7PzZjblYPugN7DZONiOtZvncNa4Ji9NDqA5NLAWoL1ALZ20kU0JKYRkHbzbtYOzTtzeXUmZS7DNglBn8WZCJDMbyZ3bmLYGJ2AYABHrKxYOzAC7mzZoC3t2tZLiq5yc3NNrH4YkO9YP44w2FJAHeN17ELW6KXzGwKGuktKn8ehZ4JmsDKgJ9wFzdb4UENLBMEc27yzNeWS6lgRZtH0Cyd_4jazQfpwd_hiHLZRafvG4j6dlBa7DEUDQUOQMdYB_XsASnTYoeWbfpwviOdurVukGzsydirjXuXHy3aV5aud49AzkLTsRALzu8VvRU5UMzs_7ZDvuO4bC-dwzs4AE9yxdpDvTyrACJdmGwGdq8E4AU5637ZLtxd6eVwDXPofRWzt5oNKBpd-lPxd1m1tp5bpom6qp_bL3KLtzpbKPfAaYBLhASdqt05d0gYa0Q21-d9BYPbe83jfXMjlds_brfZI4Ddmy7qt-Fj85BZrOJktDO0ehYLzN-rB28Bv0LD67EbAKQjlHgz4oYTvmwfrOa5v_PQbCs35RtSEYucN2Sd6M7Sdwzs9oOTtOO5MZEHI26e2RTsr9afD7dwggRgi7voLG7tXg4tCgND1wsCJW5BZ6Opwmqt17PFAioeIHvqqaBoNdaHtqAJrplYMQ00DDC1DeOAOKCc9gWIPZ2Ie392LGdrvjpeHvYAAhWIDWU7gN5Hvg7YatptU9YiDA5AXrXl1P7LdZxmp3QM9z43iylDFHrCF4vrZID7RGMXnt_GYCTJ9sRPT4BQ0dR5NPCeBWzdKDAKOEAiYFsrJpoW6SAG-BSwQDupyWGhgsaahtgXTbcbaVWsYC4Cvtyw5ygBQY094iaytSmj_CGmiAif1ZSrQ53bUYuiCF6IBmEo9ZFdc84PtiBa85MmgRoOHKTOkmDNMLlD69xuLmrJnrdASWRTUFOTyMSB7s9k3tu9pjSe9rfBvoAVC-9vmYzNv4T-rPTS_um3v4YdAsO9gETO2c86blVriWAHrBrCz1qfTT6hR9gcwx90qwwgePsfHFmUPrOfzwtfdZc9x7YB9rzo37YwJg2EQCZhJvvqiMHtttp9ZnrJvsEvN4ascdPh_e5QYx56BWLylotZ-ZHjT9u-485VBzmrDbP99o3uHrWVqB0A2qN90Qbr9pChQls1ZEAWJOUtlZKwJRRrCjUoD798wBkli_u0QIuRq59zIFyIHacRBdYMML3JTAaGrrhFTZp8YoBIMAxVghCRJjyaVnsRr8TUKuiIB9826llngaseasuvLO3sEALPs00XFCd9ssLd9uK60W-EsbOI9ZUPI8CfZ4agA9d7gMZz26NrIiLdiVGQQDnKPyKastWqe-pd-I9ZVlg3XOl7B7a6PAfFVgHvuZLW5DZWWQQW59bb98QZAUHDww90HuQ9m5NYARHscRy2iO9rgcD9ngekTU-VqARaJAKi_ujbWioBbNh4QiFnJtCHAfZAPAcaqSeYEAe0tj95C1B1seStrC7O8zK7PKqOwAHrBXPm9sRRKYNNaUrQM2laukIbIPYR39ffSJABHP4zFnNiKO1i1wbq2_CM2bm9x9NkLZIDDuB2Sf2RORXebi09uPtx3sRqGjC3mbaHDYiDcBWDbUDAlAiUYBuyDdYh9uohqhl8DiIUIeB9-kJDcKWDJAN-z1wUJifCHwf5MKUCqh2TAx43mZUhQhTUAZyA0oeazlBzxbtNJdMULX3u-rWwefPNCpiKIJhrIafjbUFqHXwGzjIinpa-PeUP4zfeaSSm-rpQWAfwD6-CFQHPupeA06GzRfsH96GMu5fp6AidHs3LXoO8zeYeBD6-BWStRlEKAsV9xYKJuQZVbHDt9u8LN_bPbexamrOfs6zA4A45vEbsIPNKJ4EzqwuNc64QrhbTgaRZULWRZFdkNbYdloDowX1YakLDbF0ZPtTAmzanjAYB5ASag1rafbwjs3vnDoWp4ncqwNxh2RLqmvueZk7tYjjHSGDZ4eLrElawKpozrrdNZ1DatXzF_MoLLMkeprMkdneoHVhlzDb0j_Dbz9dazXBiEdgKg1Oe2fNDWQefJpexMXI8Wdu5oM8D84MUcHICUdMMzDsUJ_keYweUdKRbEURDTTCzgWtCNl4ds1kOUe4i_J2aj_t0FAXUfKj0A2qjyIDqj8lIIpH9zSjkmCyjtUdGjlFLhxPOM2fS3gYVNu6DLbYd-PbpbESdgCSyf1yKDu7vBjuftiDInU-BADaUjn9bR8cMeLodFP1zOftQl0nyAD6a5ix_3sH9okAIB3TDyHThZczXi6Zj2xBUPDZAMcd4f2jY_b9GNssB9sQbv130e2sTwZz-IHqlj0AdZjheY2pLpkTLPfSKDsKpe9-82FQFsc9jjC3tAElJ1jnsd_e_sdW6eGitj78bDjzjFNcCZbj0MsdgDucfI2d6gTLWtp6YescnjPOu-dDiDLjtsfDjmxrWBDcctpX1BX6CEQbuCJ6DUZT0OdPMDDD-JgMhI6iljnIc8j3YBiKBcKrdC0DFQTjHvUYyPCYFEXhYGwBEnMnBxJGcMS0Ca2ReI-a8XVfwXRZqxb-P71b-WwZ7-FbOoOZfsxj48B79kFxH92FwukDCcwALCfnbBzgI4MCML9OdB_Yfcczjx7bH3f8fKYELxuyV_CowqIB0hFwaqk4rMWlQcdz9uQRMT1wBb-VieEACZacTgPvb7L-wUTmBWKDsQs7lNoQYq97jwlEwYcmt3Nv9v6Ada3OUe1hOrGM6FPPdoroIeNgcGxCBpldMHtmCGSf8DgFSw9uBrCD0QdvdD1w8itSf1BeMdI_VCcC5V5Ipjtbof8cgDM-afgrbWu5xq4HvbjjSeZdgrDzQV5I_tY9zDYVaD6j_9zMC4ajAeQoL3uTPzxsUaiddOsiUpPDB1Z5oXmZuiWLpox6EKEcK1u3WA0hc0LI2JriSAT6idUHKjyDHsfzjwd2DJoqdw5Ncek-RF3dt5GyUqYKd_exBCJTkwbQC8bDBT-cdpQecfLmZR5hVNcd9Ttcde2nsc8Tm4jBT15n2js9w8T2BzYi-M7BTnidy4UUdGjxUd5ALUdCMXUcrT50fij7EWupVSPdjufu9jrfCTTwafTfKUdnufifhcV0cJT2fDXTsx42j10fRdo6dgD-o5T9QafHj9_zBTkM31djrymYcnQqTroL-T3FzZUfyf_MDC3-TkArXay-Y-dQCJCTtsdjbX0egW2GdYT81bQJ5ye-j-evolAFIjAIGfjpEGeSZUwFXbYxrnPAHKwzoFL4z0GAgz5rLTjnsdIzi_sC5GUAMMNGcH95CgYWzGcX9mstuVE_PrCKsJJAO1r5VLePMz3OW5p1R44yCDs0TN8e19f1YNxEWfZwC4iojjSFY7A6jbUKzPXj7oDm4YKviHOgDpCXHz4ppQdINrPgg-cvw8DTEfSz-RSEzh_VUzmmeC_AUskrewcZrTGWU90wIhDfVpqMzadRDSOvwjRs6VdfAJPSpwrvhvEZDTlmxEZys0A6Srq_jpTtWCUmQ6T4QeldQQeFgOfonT3vB8D-OdmT2wgmT7ACWThrs1T0Od1TlmzvUBqddt5mw5QSlRyTsB2yDonuB9dbqPequdYAH3lwwLMORzoqf1z0nz9TsTQtzwudtzkaeFzpTR-z_wDkAgoA9z5OfXTnuef3IwdEFEwe89uY4vQl60SIF4Q5ANf4sgNltRbR2cMj-4QfhWwFmD4duWDxYeO92wcjgdefyMJwfZrGSDuAZoOcLWAY7ET4QuDsJ7Y0dwe-rCPvm9xmodpIYd6wYJijDwJjJABIdgXY7tQUUIasjhobSD-3VMjszqsjxs3mQWOdgNQzIg9zgeqrWnsCsYl7XtBrrmKDOdCD6fg5z_wa9dYF5c9pKeYTzydlK8OZa3coeOjscAA9IDw3uWKdgeWjTIdARql6PDabrS2cmzuQfDymGcv9mc0fQecdgwZ-fXwEOc5QJrhtz1Xa_jnhd4L38dCLuXBfT3yy8LjwdSLiRfLOwecBz0RcgL_ACKL5CHyLqkv9geEfUzlhdE9omdLdXgaueWdBkzqc0Uz84jaL22cly2Gf8L9ABNcZiNiL1ueeTw1TWL38f2LlRfiLpxctiaxdSLtxeILmmjILglNny5xcMMVRfemAOe-L43v-L_2fqLzxeTz1eaMLxVpvVmpyzPHIG2AF4RhLg-6oyeWdry7VTfiHMu4hr-Cye6wIxy3MvE6jzAHKfJcIMD1jhxeeWvCZfvyz0GArif7Uu15_IbhFcS9LRZ7bB5IIczfYRdyKwBLi9LyDhYIBnUfx7oAfMX7D8oDEMRbAK1TUJGzLoAnqFjEOg8_4kA8dv3_AOfP_Z-xYZiRD6AdCBVoXYSSAIyDIwZUEg2CFNEAV6AWgZMBkEjvlRMoyD_MgrDOqP_t0tqhXM4HMuNLt8nIUafjwsBpdNLtueFQXVuVWk7NaqwpfpLkpcSGlJfAr6wIQRNb5ZL2Gc5L6BUAnB7sqGCFfwAKFeZLmXUH3L0rUyswsmWwzC0MThNelQy3zylESc9wG6pLopfwAEpcV8WFfCD3JcoiUF75LvrUwa5Fe0J9gJrfJJf7ZRia33UTAaja9YobTe5v9EUA7JXe52Jfe7dCLzrJipFPrWGp21T7RqFz6xD4lVzNVwbEUaoBWz42ZB7v2wW6Y3ODzQL21vFbY9yoeZoDQNYVcGrrBd46sxckrRVqNLh256YeWc4Ty3SAtYxctiHVfjgZDx1daBryzmxd2L1Bemr_wYjAE9wer-ce_dQxd8QEYD5dgNdrjrbqtfFZpZreQYM-boS6UF0jgrmIDkrlldohNb5Ur0hFNeUVdbZdbgTtInB-rx-W9TvugKrxHjrTjBaoAVVdFYA9qLOnwAfy2VcCL3SURACKGlr5VcVr5GxqrlR41yrhfJAAeZRz4tfNrklhlrlVftrqtdY-zLChrieb1r9ACfUTt0lrwdetrytfIPQ76LKviAPttSeC4PMvyz5bNGz6nV-BD92zPOgeLBfRcET6stBrnGdE4WZ4hT2Bfqg6e6v3DC2zPacZQfJxWrzasX8xYwADZqqgHUGBi8LGsPYgNdbpwfVaZaa6eHOdww7rSOu8nF1CgvM7sl3f8DHnZWuzAaDdx3Cu73izLA3KW1cmW1Ge7wWEucoAxoRzq9LyYN7B0AZRj_IeEa4bpDqVdLu65zu5CyTxGCEgQOKXzR7CjweACcWp9ToARGBMbyJI5QKWwLwTkCkb-QInuNjd_oaWzvKqWCPYa0B2SW-N5pRGDe56jd5pKUbKDLTtuyyTejFpghkbvEoJlJKRqsIlhQbu5AXQO5DKDW0p3IEEucdNAD2cRI2Cb4PNGbwvhDIaWx1alrUKdNrVEADrVHCLrXIPULNFoNTf-DO5Cpt44DSbhTpabj8DWbmrV2poRiS8VrUJSJzdn-6gCubgxzubgqCeb-2cahN2VgwbzdoAB-CmbhTrIUdQDVbdoCAAYz-3wHLgaZmhwj1rZoki6m4sAAFvlBpyhGS7V52gIAAI0gK3oqTaEYnTQACk87Cnm_uqZG_6YBjQDmZEnKrjMC1-87GRrRbaX-0vwSELEg8BydtM1tdAN-IzBd-HExm37f3_gTAYsA_jke0X3wsA2WmKujWkkMmln5rWU1Y-2r223Jhma03Ndm0SumumBtq8z-2lj0j0xV03NcpMcYjtgkWqtOUjlhlX4wRlS4bCYwjb8dCHEmGx_o3YYzG191dd2wsHCQ4GndOGIXcignDMsJavaG8IXYeqVLD8oH7HQ4e_qvoB_pudKFSuADHl445uGx33zkk4TbBB3Yftr0lHGJ389nb04wwigOO-X9Dhmt95O8LYwnB4bRHBp3jHUsLdaCt-NakcsjpxEbSXCN8kjabk20n3gsje6Aa26e3UTcBDE8RqbsvCl3X41xXGrnUVzVp0UoTZEMx25Gm91ZsbJrdl35W1FINLAqbh72FtyTfcbIhnXeg02MM6u_S0Eu613qw2l3xrmWdqaofI8Te2k0_UV3f04gSljfO382hV0OTbFs5emdDpjHz03EV-cRTcxIII-wC4c8-Cfu4Xm-u4DwP_dsbMvEt8ge6Sbbjeu3Mejj022lFAPu7z0fu7m2Ce_7D_2_YupDXv6sC_z0ZzTwKxyhO4Me-ZGkdyj3PBTSiLumoSo9Gpb6rxib8fiT3N_Xd3xu9C0T29KjuRmhEVu5b3RTedL-_qcb8u-0Wye89S-jhab9s5RupYdT-MOE19f25BH-frxY3fqWYJkgXUwO7XEuQlXYNLBlEXfqZYo8YlYLpQI4vNCI48fpbYuO6CdF-67YtLqJ3N-6HYVuAo4fnRT9l-_I48eCp3g7Fk00Rgd9Ufrf3dHCZ3fbCx3r-9v3fDZv9i24V-_8CfAqak6KC-7fgvG9TUBvx41L40n-FLQzGw2-pakdpLbUwATtcECTtRAg7bZAlQQHdvcEB8GkIQ0ggPJyDm3vvwW3eIFm3BB-4gdRh36BowgOlU136i9tbOcbQ2klLQlrX2553v29dMafEYbEhukInO8Vl3O4KI8QF53Rwn53LwA7igu9YgMjea6fcWYPmUiz3G4sjroMBD369yr3sRfuX0TaH3T7Yn3yu6A7kBzja6h5D62g10Pfzxv2PDHhKbBzKQGBtOVqWWk8G8-Zympe4Ikqsl37CixcZSFdwvh43nEqqENhBXj39jbEUxh-1Sq9D1GEbQykFh8rOpGp2AW-t0P_DFjGNh8jrdh9Z7POX6VlMubVxb1Gg8R-Y6-Y2VSBh9t3LVnCPHe9ECp0Gn3mpdn31ryRDPylOIi-8EPksBX3grHVqTLG9AN8eyoAR52ACCGXeQh_19vAhTevwx6GlHV_EArBawrQzGPHR8BYXR8Fwp3QEdcuGx6ix_mPd3W9SvvtWEqx5isDBg2PZ4gxKGRxb97K9NClB7rgUB-8YpxBCjjR_gPwsr1ECv2QPJQrd-741t-Cvz6bp8EMuH-Zbbf9neP0AaFaNYBSm73wibwtfWAK0xOm60rV3pV3KuN0zamU0wEQakwBPjTgEQIJ6Frn3wEQ0R8Ku-UlhP5p18m7kylTiJ8gO4JxgO6wCSDYJ3hPGJ3WApu8lFeJ8qmZgbJPNYFN3MMx1ev0wEQ_mq1FsU21eDJ7JFItfQQ0MjEDfB8kPhDfQuUaeEwxkvckLwoRI3bl3XtwnXcrpuEw55xmHR1HXubvUEDcqeauFHcCu1lqw4u_vNkno4yzcmyU2xh2SA49XdWmhwzHEwHS4_wm6AbkgVgpQ5FDCXyOoUhzGAf3hHA2wDctWYguESmw_Ok3goWQMTcuFFmEPkHAre-Dx8KNxpEgMwKGGd_kaNi90v9TFn4btr0EbSfX5P0h6mg4jYF3uMmF3yh7kbmU1NFKTgH3osnFktDCrhGUD8R9jcogAsid3ih8SbuJCN3rB4Ku8J-yi4J923kJ8quU0wsPHWzJDd1x6OCwhYuyR612klzVP1zkFwyR6auQ9xsuA5Q-EI6YOOatEV2_pzOo55347j5rtyatEBohClcA7Q7HOnQ__OtQ7TkK5y7Pct1PLCTZSOgoSnSNCayjhEaNdYa3X2_Z6rDLl2y8ye1b2--xsu-e1dwyR7auqoxmXQV2CPxR9CP2Og62ER873Zpz0mdZ4syrZ-wuZR3zPWdzRhRZ5uu_4AFkXssFw-5-d3h56xyMPN_KrDZ8PzTF0PfKcFTX5-rk76wLPkF544vanTtv56rPJh-6ASJ4--4TgsPFX0wiB541cfz1beCvFKPHZ4lI-1nu-JiioI0vBovP22dVoF6Yvee5Yv56nGIEO9m-RbyHVzskAi1Tbz3dTrluwTZT3aJ6AvuDhAvsl7AvPgXwvtXkIvPDGlky71LEldQW2L570PIR9wv4F9RhGl-LP2OlLP2FzmGrDRUPWJ7iOfkylTuZ9J-al4gvZl-gv6dpFOZsuYvIpxs4dF-DI4RVIvkR_Iv-J9JPDDgsPXZp7Pj6j-e4LjF2o-8X6855j2jL190Wsq0vLFzGuQDqONFe3f8Wh7tOximW2fzyucwPdRWeEdUARWQMjNOwTuMV9oj1uxWihV8Myo0D1bk91xWpKlR7NLgR2aLyItRpGKv2V-Tw0vG6vtrD6ywRLqvFuVdwVV6uZB5tyvt8HhcGkN4KZ3e_c2KlHocuGKJs5vk8c5T4aU18Mx75rbP_F9SvctwyUZ22HenLKkv9jd_PFR_2HxJ9KmoV8rKFh_XTrQT8vAeDHPhQbfPDw-DX19aS9kY5yCAG12vTRwZKfz22vKV_gYp19Hu22zoue23eGfn1YAg2y1lfuyj2nLPswVodDbtYY_dbDQWO17mJmsC8m-J59NizMGNnfEaQ3_4DEj0dCRvgHunq6YbRvxC4Ni_y64qSUaZDYYeelZ5sHDNmAS3MlC2-eV-mv5IFmvgocoX6N_niTe9QV-HRQtz-UrONh0k2L1_DyU2Yt28O0LVOV4EvIpwvy_x1PP3Ictu-iRj4XN_QAUTsWMwPZFOZe5xvZ3bvT1V7p2jN5Z2pN9RvGt4yE37ipvuIRFO6zayybgUlvLB1JUM17SiQ2TVvZt55vdc2JGqLntvvxz_Qg19dvesE1v6qgWv4FZUxhBqWiHlWOvP553dIt6lv40jOvfcTRO401um1F7-gvP0buAN_YYQN6Mvg-9KPMl5-v0HHJ0ad8V-8d9XoFJ-YzTl7wvrl6gvRF7PggZ9nu5Z-balZ5Lv3QHpP7Hxw-mMycvGd8t8EZ-o-mmv8Kuh7kv1Z5ZPrd_rFHH1-mnd9b33d901vd_01IUl_Yg96abU--b35gFqP0H1DtD_q4mHv3b-rx-gQ0E0-P9ba_sK29qc2gdFAugc1FagYaACgdpPm27cDp95MDcQdumD25PvZ95X4bUY6jxEu6j6wFbDaQfbDTZ9RPuYaOmOQaiDzga5PXsHd-SxkaQB9sZciZ4EPOHE8jAMfwVU6k4j3N8bEnDb39ltC5DGYdvUaF7gfGD7TDGIdrDiD6OPN_oEbYdX4P8fj539hAkbch8rzaZ6BdTvRV3z9_vvF96vvZ0wsPMsYQfVdUrHSvV0Pce5Nbk95asHD6Hu0Lj_PoT2ajd948DD94hO7D5IjaselvyFF0AVY94fy952vtTdkfTsbEgoj_2H4j5fvXgfajBYa6jzgZkfhIdfD3oYpq2Ly2Y8Zx4YZoc3IhD-4fTqGSPGUa0jPIYOnr18HmC0aTDhD5Enlj4XqYzWpD-D_nDSt9PaJ-wcf9187ANCY8fWD9JeKvoXPhvYrjmfTnKr5zEg750dWw-WcWZN-ivNLlMfXpm0jug8wfCkbVqguDO7dIZI4HofTDZj8JYkKh-YRt7itC3bsu-h-_P8fhsf0xEIfoe2yf2IB7D7j4Cfi0aCfC96CvcTgKcwD_8DsQf0Dxj7wftj96f7Z-afFoaCfBV8If3PqQUDB1POd18Qv9F_fN5OjvO-gHyfP4emf5N4KflOrnlNT_xvToYWf2QCWfgqxm71T6RvtT9cfYJUaflvl2fFT9HGmz5oA2z4pqWj77iF168cBTgMf2UiLDE98MPZT4IfQT8g1FR63zKj9XvFRb63KB7KMVkgqMAf23vI25E10CDQLYniDUyRKZRudvNATmY8BWIF3AqIC9AcAC-AHEyks8L7uongKSA-cHiI0cgxfX5Q7bPxyUQFcE0IXRjY3FoB-OIxktFBEueD5sCWAjwe4cl4t-mDAa7tMAdWl-FmLdOWmsyDAeJYBjiPvQJizMQ9mBPkB3tMe25rAc5hIDemY0zT9_B0VJiOmlsHm09JgEQXVfFfRFn23spnlMWpmVfoD9VgdmoKQwzi64lkDzd5sFi0f8W6rw_t092oEaLU0EqsMhIzjrEHRf96CZRo4wz7aL6SJAb5aUC6l09MdgqsKXnpubwFiANWflQ5D8FPvaBbUrtce9D1Z69GRozftYA_0LDJdQgQA3ODBh9fA3xof2b4sAtdNRpzhKNm-Vk3-BhKGGY7qxggYq5fAr55fUkCC9-f1HFTwZbf0hnBIPajzfuD62funujPIUtjPlJ0fcZD5gfFD5kPVD9TP0jfTPDD8sbXxnlfo2k7v2u-Te09z19mF-wI2BnVQZOGSP31Gga30hd947u3fZBkiAFBgbvzjcPP-weluQXu3evb9d9PDH1TU7plZNl9MPlU2VfFh-jjXd__AIGml4A98kv5btry0l8FwCzs2-mxB7Uz75Pfr74JyjD4IlGr413db0QjltCptT79bTfz2uD0weDzvj5QGx74FwRpH3fLiDwnGzgWDcV6QvJlfIF2l3fN377Xf7DDA_5WGl49r8dfzr_qropnFMO0-g_RODL9SITCf4V0e9J3GHw-EXgYwBn4_l77H3ekcGNal169lwB4_qz-DIlaaHMylEp8wn7DoE47E_i_TanU10S3tH7t3G7_udp7_QMZOAPf0tx89nH-DoO76IAF7_7TxUCV4d78FwOqcffKn5_0L788S1IaHfor7Y__JmPSOACJMru4GtZF-Pv2r-ZMer7pMITU13Od-kv3shYM0QDYM6n6CbHz9XoRr_FMRDgBfud_cf7n-HwCX673Zr81MA9hVMlgFS_kX__fvH76fAOmabEL_abdR4RrcL4E1xaockSL8qFbFsCarxnW3u3jbcStHxKrOZOQHbasbL242ktX95Pib8nfyb9h406gXiQgDAe1dqOr2mlHfRwnjP325iAUh-x0lD4A0s76F39D5T3vX_1thX_sbafrI_-_UabbqfK_DT-rkkL5zb_W9Dgg29XUn0or0DX_n4LMt27rqvEPu2RM_LWzQGHFA_X9Rv1cXO5e_ERmzVBczv9jMEHtIkGHtvdpJ249sOdk9swPxbbG3uCv00xZsBl2L-V-HbZ8V-skJlwUkCkQ7YdHzLU6lqUuQhPUtngWGeHbIxjFgg1kOsRpg7t5RhtfyXA7boMut8QMgd3J-GhlWiGN0N34XtRXr-AJXqdswgY5_TQkgIIxn9TCJENuHdo3vqEGh2JmrqMnL9KkSUBmFNsHpMCwqWFQr5ak0WuEQfF9RlFMh9cgl8EvrrHqPw2qLvtCdoTQQ19U3Mr8Vggq5kctztVNF0JbcmFUvn1_J-0snfTlt1pT0vAW2WORpEDj1vzgUf7DT6BvWjGurkX2ZJEuqoX1eMue_xaSj6GY13WX28Q1y120GqP55lrjtNVJMsqT6wBuPkuukIMf_A3289Q31MvKvdMt2cjMq2UOf-zGld3J3xrbb46f6e4KG8D_Kv4tV-gDBT-MpN_hMtaUj38T8ESvd8Hn1y29ukHat3m18mFHTVMHgK2v-QwA3f9HcEheisu-xqVuatwo6b3TcGat0lUv-mFh2jmFCv_1AiAhxdK3W3uek9PcyqnPcUU8oXx4BA8cU9o0CbhH_goGHNfRsKysC9IXu_7TZ-_4RQ1C4fcRJWH_I7jP_7rurkEgUVu1CWFXoAUyWNf6-_GbwNnLmVfFSb_RP9__wQoO1VGf1mIbcY2vjfYSACwyCTLbTx_v3FmebVvyBzNCwBQ1TgAosgIglreFR95bW9pByx7Oxf_SAokAIgofv833EH_U_gBMFP_YgDMAKg8Kf9fDH8GTf8T3Gv_SKdb_wC7e_873BoXcd9afGoA8_9P3Ev_EhcIp3IXPf92AMP_LgCn_3YA0XQy_zPzJgDK2nQAY9wf_3NrL7cZlErUH9R1f1Q-TgMSNWZuGnwXQy1_fY1b7iR3DTVw8BnvJiYdANuuct49OUjPQG45mD19Qqwv9Ho_D_Q7AIgMVtNwWAKOSM59fwEmErdPpCL-OpBIzmtGDP9H1m8A91x5rFnsPWxNXE1_YAx5bElsOexWAyNsaICwgLMA8kNv9C_0Gex4gMnsMHdE_FVuPwCAAJQzDzAggIDPZHccgOhTdwDaAJoAVW5n1HtlcsMZgAs0Q9ArNF1QX9QbLHrURtR6Pjl7TG4A01vuEpgMUyQzMNNIBzl0QX8PTBVeLoDQ0wNnOXwBEFJ_AOw9fTmDO6hIjlPMcYD47EdQKYDHUFGAyVwYzxv9VyRX4yM0MHA6gMSWd9RKNG2AmzRefy5_euB7jzXsKf4FkHntXDN5-AqUewgcHUbfFDxy_hrfHjkyN3FsatoyN1M4QTQAmw7oM1ZaADI3LWxXgKB3Cdh7gJrACt8K2RCJMjdP8mn4HGADGk3QN5RVl1pICpRqgF34KUAYbHFDHER7CBsla-B87BdAaEDeewztYIxetzMAWECUpSl4Ggpd-H2hGdsMkF7QHvEsQI2wYeB_rDeAu08aYyUgUzA6QJoAHEDuICJA2-wSQLmJMkDM8EI5ZrkBAAUBZeMEQO8AXkCg2HzgS8INIE5AvsARQKwAMUDkEH5ArKAsA1uA_7h241lA-UDJt0lAwkDcf25A_BkNQMVAmNkhQLa5VkN1QJXickCmnhuA-do7UnBsUkErgGVBKGAlCTAAThkFJRZAyCB6QLd0aUD4QNJAs0C-QMwdKl9voFNAnwVxQKaeKUCdQMDA8kC_QJtArWxdQMRAn0DgwK1AuSAwwO9AoMCFQMjAvOATQOTA80DLwktA89o7UhVAkcZ2AHtAx0DnQN4IVkCCAHZA7UC4QJjA0UC4wNTAgUD2uWrAuUDawM1A76AqQKtAwUCtbFtAwsCHQL0gJ0CXQLLAisDEwKrA8MDfQPrA6MCRwPjA1sDpWHbA9rkuwKLA3sCSwNdA5NE2QI9ApMCeQObA1-xR2AUBFR1zAG0kL_I1AB6pX4Ca3xETVSAyN3BsULNTwLYbHYAQgTnAtUEyNy8AXMCOwOxFSqwwQNG_EfcZbQEAMjcMQOaENABr4lCIU4BtgDI3UZ1QswUgS8DNIDTwD4CQgC-AxnAfgI39H10HOkFVWxADvEjAC0BhekiJVCDK2TI3EECWwTAg9GMBBHtAzhkvmTZ4BkD8Ry9BW4CLwKwAZ4CcEmAgyxQyN0ABfYJwoB6pEyBKINXA4cDMwL5AuB1twOgdRABjvRuAn_EMAFvA4GhBwM9AxsD9QM4g87Bn7UQACyAnWH8zKRkXQBpAwcDjAHFnRdBumGsdJlpA5GikMcIKgygAeid-3DGAdah3JDfCXrcRIMDA5ECV4hhRewgtIFIg_0CKINLAt0CVwM0gRkCjQP3kWyClwI1Ad0CawGkgWSBq2mrcQyBs3D8g0CCfADcgkUAPIIG-CCCvX3mOM2wSIJ0gL0E_gIrBAyAgoIHAq8DtgBvAgsCP1WaAYKCxWHLA6cDHwPZBLpk86T8gqGBCoMMgFSAWINzEOGJeYhTVECdwQP3A7AArgGnrYSC1wL1AleIzIMI5KWseIPNwewgZ8UwMYeRGoLYg9cDX7DRAcyD2oMQAVc9_qERXaOB5IH9AOB90dxiHINA3gPCg1iBPgJyWe6x7wPjZf4CndBrfIEC4DH4gxIhjOWx3GGwnwE4EYzk1YFYAFIBMVCwAEgBlQGQqbNoCAG4AcIAwAG9BRQAQiWTAewA9cxSAEIkWwVgQSLgsABeg7UBPoMsJT6CIiRbBFsEgYNBgv0EgYMugyHo4AD-ggGC7QRegpKBPoMsgJGDkUTCqRGBwcyRgjgl_GShgSyB3oIBgl6DzwBCJBSB_oIUgRGCFIE4ZF6D7AH5QPAAgYOXiWGCIYIRgS5cmYOTAfGCWwRQJfwV6YN9BNjEnAHQAVmD5CU5g_UA9IE-g-wBs3FcAIyBhYPFgjgkgYMigYWDsYNbBKGBZYLFgiWCgYLlgmWCoYHsAOWDFmgVg9WC5YP1ACmD1YN9BLQlhYLVg4GDWwVlgsGDFYLVgkWCVYOlg82CWwQtAbWCNYKBgvWDjYIUgI2D1YJNg1WDjYItgnWCoAGxg-wBkwHdg62CpYJbBK2CTYIdgu2DfQSBgpGCCYKJgkmDEYNegpGC8YOTACLRIMx7xLsCgQWeBAnMlgGzgq3NeQTvpSDNsIISgoCCve1CzYuDpwKwABiDo3wfA6cAhQLKgiwBuoJVPMoQ1oNyg15keqSKgsqDN0G_9UHNyoF1kYIBPhFBQNABgWSuAX0EjIBZ4VSA0cBMg5MDWoJhRARAp4IGgmeCRoLGgsjBrU16yTEDyaGxAutx8ZmS8fWsIHndOCyARADIwXrc6jzMAbcEZfV-jNEDe0HeAiKD3S2-AmABngMhsHGBcIINsNnBsYGfgkEDDl2fgmiCYYGfgvb8PwPvA3aCF2V54FgQnwHmxMOBuVA5Ia_5UIA2EA-ARpQuXdCA92VAQaX0oYj0gW2A8ACWhCABDMGelNODAELrJcKcPWHZA3NtoAFAQVdt0AHXbRKc7v1f9ciAxUAO8Ots54E67LIAgHAYQ3xVVE1nAKWMiIHADCBxmEP1kVhCUgE-3CFt9HHSgFgRxO3j8JLs_uzD0GhCTf14Qyp9mcFpfcYJ__jfdOIFeAH-kXgBnABRgTFRZoBEYUAFCgDXTMTtuEPXAHoNlbgBQB7BhEO4Qxldq5FMQ30AMWidAG4p2ux67NDMYX0ZgfdtD2wx7E9sSYEoQwwB8Zn8IUaggiAqAZIICQNM1RLAT52EDIJCguDOQKx1Dh23bbZcswERXXwdXHX2dAzAXYFHBbBxVtF1ADKQfjD2lIgACAH5LdSMiaFx7YJYlllJwLhM2-DR7J_UNFTjPJ61X9VJocigDMC6AVT1E3DwAgsY6ND6gZoB6s3NgIRAsAT9dPiBzMHlABjw_625WWpD5PVjsIbw2kI6Q24AukId0LpIy8x7IRpZ5QFGQzpChkPgeGswkpHU8MO8_21_QJ61cYk4NAZ5HKEGQgMcu6ni8dCgNkMWQ03AhwifAXrhY9GUEN3oNFABCCLASeyI9QZD6kKtUCZCgdifAJKAG3X6AJt0poGUEYoBW3S6AI4AhdEQGR4o1kIcIR5DdhBJgecRnQCTDd1tYWCWwW89G60iwOpDwUJN0bRYMUAMwWa1l9g66ZV0b8E0URFCTkPbQThg0UN_QDFDn9ixQzPhpMFxQsFCi7DmkFn4-vEPIWUhyUMJANAh8WhJQvQZ0CHBEI4AQpGiddnAQ1TxQ-pCr-imUCRIgGF_QRBhwvwyYMogKj2FQs34TkOPOS6NdihuIJSDDDEsAeqRDKRUeBkBJnmUWP6wKwXZ4VtQ8gDKqAPJPFkSRU4B2SUVIVVCiQFrgIbh9zhF4SxgEC0sAZVCqixYsDIAyVl6qfuEccCBAIrouMArgECd6emUWcTczqCRQouxDuxrdRZdpAAwleYJocAEgfqgwcxkgSQBMuEkAN8FiEXmQ8ZDFkL_nTLAOUImeS1CiUOlQp5D-4SUobVCmdXIICQhbAAq8BKp-gC4YbNDkUNzQ0aAIQQfaUzB1UKG4GpDjkO2QwCxOiC8PbhMYP15QqlDUQD-QIMF30QFQ9tDVI3TQ-Bc-UORQyFCj0VlIfxhNZGwAjcQlezHQ99ET3WOQp5C50L-DD6B00Pf4Y1BguzT4Y1ALhihQlBU9rnqyaBpuhWxUPSB-0NQYIVDDdAXACvUDTh77PNC-vGdodNC52gvCcYJQkL0QAVhH7VvPBxA9S3gAXdDfb1mvIbIT0KxLXK1DtSjocXAkkIacVJD0kPPARtDpUOTsesottXxoaGptFg7dQKIDMCPqPWNbwhmgGuAx4x9QRmh3JBgQ4zp6VkdAYDDiVQ1UFDDf0EfQpOR0MJFoIARG600UAz43dwwIS9CF3lPTBHA8RmNQKxIaADMJSMBCiSKrAcouUNNwKKc0oCPQ-3xz0OK6fZ5D3yYw_B1dJX4w69D0DTFQ0TDRlBkw3i4ExHz2aZ077GYwn1Q1W2xWeM4X0NhYd9DAJk_Q3itl0MkqQa9-MPwdD-BJMMEw7FQlMMmGHvsl6CYKJjDjhhvQiBpDaCYwg04n-3f2OGcNFVjnB9D70C4AE9xIGlQcfzD0PBsw6cAn-zTnILD0ABEHfDw16F8wz5xz_CvQ3i4n-ywnfzD-QVQcExRmAL8wqLCryjcwpLD8JywnUwQGGFJ8VBwVglKyN-AEA1NKDvh94AWQRqoqeAKw_eBo9m_lINMTlFmTDm8yMB6Qhjw38HSwgPMOsJEafXZusOr1RuIDumI2brDWsO2XMUUbOW2GLcd70AEwtNkTCHJ3LrCZsJ6wqu4ovlPeJbDBsIGw0iohsPwdEFCVolGwjR4LEH4iBbCDaiWwhTp5sLXrfrDTsMywk5QzsPxmfbCxe0Ow3bCOvHSwqTDesMriE7CbsKCglbCVtTWwz7Cf3D-w7FQXsKinHUEcsPUwpzDggGh6IbCQEAQDP9BrIU0XMzCrMJBydTDZMO4gZ_JyalmbRkCpqBdASmYpgD0gBQFJ0KFAyzBSh1cw9TCpMMhw7jDjC1CwljDzAHgLADCbCxvFEnDEsMmGFTDlnwItJpCqcKm-eEB1c3N6HpDnwE3BGkAU3QSwjTCFESx7FUgWQF5w30dcQEVgfpDBCCYw99B2YyfQfXZOQn0AZt0hcPcw5XDucNYgbPYi-BoEEdA4zy4qc90Ook21UhYDQiQw0jDvlVQw3voqML9CTDCCmCUwCaAGQDmADUBeNk8WDXCxcI7aF6gucPdw-SBzcI6iYl0vcKUTa3DqMPqAZwBkEDwgYk4A8O8KScBRgClwwR8L-1jwnABG6xifdsJBDSJwAAcJUN1BZ_IDXjQOUWhb9gKeBHMmsMUwxzCokjkwjUJ-MO-WISZHhntnNMdVI1wCX7AOcJFwlXDzenqiY4ZY8Jlw2sB00OArRNxjAnblWOdUPARwubDrMOLwu8RggDrXBrp-MOOGfzCfV1XQ2dDVMFsnb94fMKV7SLCAsNQ8ZfCQsNywyYZwsIa6ZfDp8OAwOLD88mRwvLC3uBSwqLDz5S-Ef64-wDn6Y1B6sPKwrYAayGZwFGBoNFJwqKdVelYjKq1RgAKwqnhSfC7EXtVLMMHw2fs6ZT8gO_DHKU3ZI0gj62Hwxg5jhjjDDg1vy3Swr_CuAlGALT8cqAnw0YBgsNuaDfCwsMo3crBwCPUwivDBVmWgZm8lSCbQiEovy1OgD0hpkPcYIXDMoSygRg5IM1rw2sYwZAwI2H5I8L-dG2148IFwylMl8PvQHMtswjZCNNDZ0LOzUMcH2g_uJHCK9TJwtXCksNlkXQsICNLwjF4jgDg0LgiJECiw11dG4mCwiTDD8M3wnVYIsKyw6LCUIn3w0QjhcJ1WE_CG51t2dGMeCOc7K9h4gDbLQAiYcNhYTlAGvVabXtCXiidvE1g_8J-HIXDxCPSw6HDgCKHQcwsmCIckJ8gfol_w5_D_8IkIzfCpCKhw2_C_FBAItBUYKzgIorD_sJzLEHCwCKJIJjC8CNTEAgjRSEGQ5tCu8Lowogoa8O9pXt0wD0EQyJDj22iQvmgiEOQcE48zWH-YDxDsD3G3IIQCBCm3HVxqiM9YZiRzS1IRDX034ClsTYAogCbUHX50q0LGLbhyuBG4HAA9uC64AUxjuGx8M7gs00u4fQB28Nt6extKHyIjNhoDsx1-IpRfL2TPYbAmWHMabYACWHPtf-AeiIfwFtxinjQkdv4HyljHCHY7hmfLNZ0FK2rkHX5iH0EQ1oiCWEB_UOBgfwBAQ4DwfzrkOoixt2JgdO0OtRegV0BEfzCkU-A_zjsAFsomuAaAHOB4bEwQqe1AkOYkRojWJAYPOoxrqlQ2NbN70A8kbF987QfBDttGp1LnYSZKkD7bZANBQMHbKmtIOAALFYsqhDgiFYsVIipIuystnzuLMely3xCrJkj2AG8rSytOM0MzK19GpEwzadtsMyPvE0UunDq4f4V9jAEQITN4TxlFAqQHXwm4aERYT1uDHCVNRVN3MjMxSJUzQqZzRUtFM6UdeFtFQcF1gBNFG6tl-D-FdqZmtA9FEgMvRXBFSEUVSMxmOsVlLEbFfKR6qxbFJrhuSKU1XIpHjAd-AHZrfnfGIu8hpGtGIjwXfmmkH0iDZmGcYZ43wSVXIGwuNEYZfOoRAgtHEjhjPz1I_4Vbq3-FY0jwnAIlM0ifRXPpW8VI5F2YfvU5MHOJOodWAWY3IIBltDT7Kno8MGxuay0xwmkiDkE4agjIyG1SyILFB4U3wn-8fYQlxkYwA_A0JRcQf8VjQzrIjOR2RTnQRWAb4BmgN8Ilxhz7RRk5lA-EM5MsyHGeVltmgEWEIAY5ZlS8EZcKwSFMd5QC-HjFdi0X7RRFDORcyLWQW1dQUGY3brBZYB2IfYQNEFzHYdZ_kAEwC4ovhyNDLMV6RXbAg0IlMAwUYmNUf3KgfMi5lBVkJiZOED4QVUMni2xFB-BRRRtHLzpbgFjUdwBwRFknU4A2hBPAVH9LwEMrbnYQKP8AFktSBHJAewBskO18JCi4KMc9esx2YD4QJ8AoYG71fvwB0FkUX3Rpp3xmdPlmLEMzT747pkVhVdg0KMq4fwAwqhbja9ICKL-HYjZyKPCcd2A281Yo_lx3YGMzXsIOKO4zCijJM05AWrB_gHesWTBAgH1DFLMKwTdABhhgsiAog9BaKPqQUZ1YOiYo_6h8ZnZIhD9OSIkzbFR1KIHFXysuM31AbVd5CNS4YytdZHsrCBpUPBMonSt0PB0o9jNmtD8rfUALKMZAekiaAB9XeVB8uyBsQiijgHxmSyjTK2xUHyjKP1znRIAebV90ZIBsVCiFCy0viHFPHWJxbymAE9xwqNznYYEWAFdADFAkKOyQj4BreEVHeIAVlA5BZlBhsAxsYbAgqKTQFrBiKJFFPoAbRxawfKiCsEKooNBiqP2ndf9c50TLGYRnKN0rRkBXK2aovgCpK1lLXKtZolC3PosSOhrIkmAk0nDCKzgZgGCJIEFyolYaVW94HAoMX3QBi0ALIWoWSNRYAphsVCEJNXs2eC95cbBEqNFwvRAuwC5SEaiVCyWAHCtgQTwrGaiHJAIrE6jZZmIrQitSK1Oo2Ug_EVzcb_sdCDkotKjl4igCLaj9ADFEVKjcAGXiNp0nUCGyYW4PKL-HPNIVKPhECKj7hUJBM0JVwB8ASHDAaP-oBa9ewkOoAqpBMPEog0NzAHUleWdCjmeo3ABAgFkgPRt_iixo19DyAEjAOxJqqOktBEUQe3UlfGZpgxbKbVRPOk-o2NQXqP6oKAJxqJoEemjkKO-o_qhYjAS8Psi_AhIUBGpawGhoxiiGGDhonFQsiC-o2Ug5EQbUJLB8aPFoqWAiaJJo4KjiNBKoiGBCiSGySmik3DboGmjGE3GwAmjXqP58FmihGDZoxmiLSh1o8WicaLQAPGjTaIZo3AA5aOJonDtFaMX2RMV8ZghgThl84Jzg4jZqaLHBbWijaNwAaIhHuGysIcUxaOtojIoiUmZosqJWaKDo9miQ6PhwK504izo1GijQKOT8Kx1PiLaIWx07AFRIn90hAFpIADRYHwm-GEigwCrWC15x0HGTDZ0ViGiYVdxVXiyIaD1SEPxo4BgSPW0yfOjMdl0ZHmdckIiYTZ1-qB2dCuiEkLidcoBiQXDiYqs26Khsfqg2nQZCFahtiAjiPhBmgOedB0gAWDwgMn9sbCrMA509AD4QZIC8IHoXaNcLAAiIKoITcHfjQsB06AxIXejgKB6SSejosDbjBp196Jnos-iqyRruObpoPQ3oO6gywQno7ejjMEysRJk7vhPoyXAr6KDtIVNJsFtgGujqpxqdN-jq3wadSN1L6OUlWJ0OcBhI15YISIaAHABEUCRuWjRsqCWdArAVnWndJCx-qn4kIMlBFlc8QdB_AGbo9MddkOOQrVpfdDqwGEi_kGIYibDlRAMwUgxQKIXQyBj-0mSAiBiGBgUo7WVDMEWglkAgtFvgmCDkpCYYvJ15IQEwVbA2oAkIGhj_AEpSNhgE1XfwMhjP4AZZWNVrRHYDBtAGxHko2hjDsg_IhRi7eEFIraYqRVFItkjVSIlIvYwpSPlFaEQdaIMwe_BPyO6tC5YGgEhInAAzGOvNQWAlGP8ANVh5GK_IroB7GN67KujiUIRIADAJGLR7SxjYGNA9ShBa6O4YSWA0gB2o8PASDQkIFogvGL3Q9xj6GMwQ8AhSfVCYiQhv_j_la3p8WlujQlJ-6MkoUhiGGN7ooQB-6LSY--jHUEfo9qh_aJOsYCx2kFOnLJjBkIoYntCh0EWAvCBSmMLSdqgKmN7wYqtA4ihiK414pBL4FgBQDUkoKVDBLyiYu1cT6mzvWUI68L0wHpjJxzBndFDuTVYTFIB3TX3DExdCGMUozxjgmNewc8E_AGUoyZM8Ih0YzGYpRXhPdUjG7S1Iu0UJdABXSbB_zFrgPAAm5kDtZftlcnUtCIALmP-YLAi7nwHQkJ0DMB5uL5NA7UL4B5iB9Q-AcojHSOptE8B7mMXkH5jpVhoAP8dcXXIeRhA45H-dBl1gXTeYoW4PmMStP5i30HUtUFiCAHBYr113mODTO2iWgDETSORVGF0IDCo0rnoIFzhJrQ3gr_IDvmCtEYg5biqXTG5WfldiVH5OE1PQ0ZjJqLDdXqhQGOA9Azg-EHkCCdIwHS0saAxv8KfjK-MX4xvjUGASaN8GEW18wDu9HXQwHTzmaT9_iGCrALYZWOk_ExNRE2doRVj2MGVYjI0Gshh6OHoUrRyoDVj5gC1Y6Ax0PBETQ54CsENYo9VZWMhw6KsGMP_jeccC5xygIudhchLnSgAFbEpUS1jjWKrTTqcm51ZY_Mo510RAIdc21xZsDtd3uFrFD6YctFyiO0iEjm81NsVvYjDoNEUnqMmIfoDZkBVeeIEpPyzfKVilWLYMDqwkzmvtQXAHWILYtcdNLgDY0MimGWHXENiq1y7ydF07yCKAmoBCjmKrZJiOyFX0Hf1w2yOIZZjTjVmY-ZjoIlvIDtjZkCiY80o4sGLofEshXTidFohrIEwANABhIBI3Y-5f6ITcM9QJ2KfHSuilmMEvCdiCgHmYtnCqGI8YztjJ2NQAIPBqAO32SgI0mPHY3HQp2NoAUaiBHiA9E9jd2P3YogChmLnSTWht2NmQRdiz2K7_O9iJIFc7UwRRgH-KR3UflDrIS8BZgCFDPVBP2Lctc6B4bifY1CAX2L3YngCiAOQLCtkvaVS4eIAh2LoYgZjVmMHYjZi281ULSLBImLQ4pDi_AE8rbzoAOLuAd88QInWY4ugB5g6tYbA8OPr7Op9xcGvY9djEjXItOltsOJWYs4J0OPr7ajiQM3wwSxiGs2cuBeRIfwEAWaB1gCART9c_KD0GfQD8XmI1GcRjANtwPu887x6OaqdGqMODRUjDtyymPUVJWJKoAZBtBhkyeSBbYFZPFGZbYG8GQH5gnQ-gaH4shR3zaoQbg01MAgMlSL1FJU1XUA9cEqgSl2jnDrwFhDrvGJJqvTc40m1K3mmETziUGPc4sdBSghhNfB4IrTzXYDAJOPZNEM9ue0JNQvZYEgt4ZfIazgFkQ8YLmldiOnYIuKiUCU0ar3J4GKgtOMjrUs8cuIgQOdZFeAS46YRAIic46Fc3VW84ml42TQy40UoH1xaAizjxr2gVHMsYeSkXURdAbgCXZP8ukiPuXL5Lugyrae9ZONnvJWBe4z-eBTJBtiS42PoUuJPGHu9BuKYmTLiVI2y4vyhcuPw3fLiluMK4wwZiuK2cIjwyuJioZzi7IhwVZPBIfmTwCpcKRB7CNriKCBm46hQhuNS4lkFakVVhFbY3_3VeLzjzVWW4pVpnuJEoEpd7OKPITNEtWmXYj4YDzBc_cLid3WUyOtim9kW481U-KFVuFrB0uMzFd7jpOKsAkKR8-lOILcwogJ1sGICUlDiAtHiwgOPdLNDJCA6dauMOWPidBtB8eOaMCAAC6OSADljZ93nSWnxge2GA3ID-rQ1uAQCt_zp46FM9bhW6UBRMqPDInKik6jAqMOQQyM547KikqJ54vdR3RwHlALjCWBDeHGIrO1vo39B2mNgATpizlxL4XjC6W1-wGHiJeOzw8k1R8CyVcrpq0NHY-pBoMVp8BdjT2Nq8F6cgPT_oMjBe2PIY6cB5PEPkS3jzeIckLhQzwBaWJZIw6yQ_SgDF0BQ4-3iYsBrIZ3iB3SjXfkZQSH2KMDMRRjOvGPhVuJe49biVeik43vBnOMJ4hn8xOPqGOHi21Wu4lRVo-MPVGTiruKYmaHiCjizeR7i0GEV9GQBJVTE9N90-XQ3lcXA8nQA9LpIOWRewQGAe3GQseSAuGPusQ3gaPUhYw3BwvRw9UBQoWP-9crBzmKygIPB2-OksNoA--Np8Hj1BcHy5RuiaVmG7QHAHCMYAAEjyYHdCZ70CjmvTO2sHCKcYIu871XJ9YyI-3g-9Fa8sHS34jIAd-M6EA-4AHUHkZb4GzRRgQ_jgLGqgdqhL-KYAx91P_zUAS_jhV2qgYVdL-NMYtRinvUiwd_jnGO74jqIhABEAKJjwvRw4s4JL-I54qsiueKF4-KpqoDAEsMjBeNFwsaRL-KXCT2dZwDGkQGB5AEv49qg0bAAdVHiuNznsDATeaA5sO6CPyUx43ASwgJ34gmBbwk5QEb0rPSCYs4JQuI3owWhGAHX43EYLAHJ9K8kSNU8JQWhNBG-9Arjf4EVaS_jm7h4EvygSl3wEu6hr-OE9O9U7-Ml9B_jsACf4pni4wWAAV_i71W_4oAJwvRUEhsRL-P_442g0gCAE1jiIATvVGATCiDgEyMinvUMErKiBqIQEu9UkBNNHFASSsFr4oQJXRxD5So8gkCHQHqk8YDvVTATIbGwEkIC0gOyAUQTHUEIE6qBUgKx4yexyBN59fn1bwhoE3YZ8xWq9BgSMGADIjSkWBMAGHT06kH8EgGBgABv4u9V80AzBXz1JBJp45mB7-MFXWXI71Wf4xQT5BMv4kgDd8FVuIQSIeNB45L071S0EwASohJl4fQTcRgoEkWgIhKFoKQA5-P0ALL1OhLKYDRhemF9TIvAwf0QILoi_RHsID_Rdjz0kcv4s_XGPGmgMgPdeA2dWj0MAkShIeOWE-YSJh00A6TjtAMGPW31YAMsAkwCozz2EygxABhWE9YAU2K1TDoCQD0f3b84NQHno82wNQC_3YIDtbFIEyewVj02g2mxfBNXEZYQTJBqzFOiIf2XojhBeHVzEYP0ThOm_bWBTQgBEwi5Q7WcQl9CfiKUg7xDAiApQQZZet3TQ2rCOF3sIEkMaABZ4C0E8EO6wUagWeHtLG8B3qFDFbzV4VDfhTV8pWwFYeSBlhyhgI9Y7BjPAZnBIazHAbESCABZ4OwY6hTFwBwYf20JE78ohhlWkXESrdFcExoAcROJE0kSLK3DFZLQbYCpEl1BYWFpEzPt6RIFYRkSxwGZE-UAzwDZEjkSBeFVE7kT2EE1E_kTET1GobQk8RJFEtkTtCXFEskSpRMpE07dqRJpoBUShCxWHaMJC0CZE7kSNRKNEoyBORJ1E6dAeRLNEj0SN0HZrGgBjROFExiDRRIIAc0SkFxJEy0SKRJlEm0S5RJpE-UA6RIZE50SvRJZEiFQwxL9E5rIUxMEqe9RtCQNE4E9RqDMJE0SQxLZEx0ScAEjEyUToxP0zQtB5RITExUSkxJI6LMTR1V5EzjCoYE9EjY5vRL1EgsTWxP9EiEAWxKLEiKBVpFLE8sSwxUrE2UTacHjE9oBExOVE5MT2xNTEwcTuxMzE2cTsxLTEswk8xJrAOkT-xKuAKcT_F2HE8kSCpGtEpcw4xLtE2sSHRKVEmmgVRKXEpsS6RLbEtUSeROvEnsT1xPQLKJlNxIz7IQsomQtEisT9xJjEw8TxxOPEycSnxO-ZacSGxMvE9DUAJJvE3US6DTAkh8TN0HTQ7WdLOBoEcCI30NCAW88zVDjPO1gBVzJoATA1xTAAbCSE3DRwXhNULG-w4ZjawALcNfQAiOnQqD568PHmV3jaZ3t0f1tKJL0wOFDhuiIkh9jsk2Qk4bon5QuceDx00PAaJ-U3Vx58eBoYsLKwOFCyPH3mGDpsVCYk2nxSfDtYeC0pYEcATABRMH1QdbhLFCwAYGhhhPTQwcREJJpofTDfdFIfNEAMJLkAtHANJMvQuhiOHlIkliT0CFIkrLByJNsIT2tDdGokiySpxzoklzCg607w9_whvE1EhnBR3DOfAVhVsxyATqg8JPWAOCSZVSEYLSTr4B0k_-h0JKflOQCTiKCZcBsPIjhQwCY3dHTQvTDkJIMwnXD04w8sOM84UM9ecwAVIkeYWUBLsAEAeSTXsFE8FtD10C3jTUSStxyknqx00P8gI_QjQDjPbwiW5GD1DLMsUAvI9wAjJKV7QC5nOyPWCKTmkO_QnwjwoGLQeHct0IdQGlABWE5AamcoiKtUB_DgiVak7GJ4UA6k0tQ7iNrVJCSP0Iykkvg7COSkpXtQkOH9LOBUIAtBDETBRGOkr95GqhrErTJfcUcgnYB3yxdwfdh1pPSklSIAmwek2-BNpKdEblBQpNYCF6Tp0E0kr6TtJLSkmYTgQNQBEKSCgDCkxIAIpKRRYGSVIjBkiKSLHW4kpXtYETOoF9DqsKhwU6SupM5QirCLliqwg6TUZNZqTCcv8ItQGHDYEX9sAxdkZJxk8OBzpIFYHgJbCIFYaSSEA0eI3TRQkNeIt8YPTEkAIu8d72jtLUAsXxBI6BBcDyIgfA9QhBxrWtt97zQmQ-9l4DBI9yBfGOhIhhi4SLqMTjFv1D5sQxx5QCJIg-NsAxFY5aURXxOrcEVWuEFMC6srRXCcJYAtZMWFecxzqy14fWSrqw7tZTUZXw7bJNc0l2KXaFcO7Q4mcB8rWjdIj0xQ8I8AX0jhAzPUd2SBkAKDfpcKql6qY6AAHmXnZEVmgHlkqtRFZI3cc8c3ZBofG8i6QirhDiA7ACklMVYZqGiAUmwxnkxzRKADqH0ACugUlW9EdsVLcxgFfgkvt3DktyBFZNCgP8BUZBJo7yAFDRPcOwBDCyIAQOh8Zmho3jBQYD0gYkR8ZlCo1uT4YBrLIYJ8u3rk3pR8RA7kloBdJUbk0wkayzHkRpc7EjAARYIk6LxXIu9PTmi4Re0tQFbQNqoh3UJ0UuiomBiYbDAqmLidf-iS6J3QIejtnVQAXZ0d5Ono4D1cmMoAfJivXUHoqJh4zD-4ogj9eIHgSQZY6IeWUuj8OxHo3uRx6K3oqej_iB_k6LAzBIgE-AT6lAvoyQgmdkVgAXiLBJV8GXjbWDHAG8B0QFxofnBkBJSAMaQn6JlIQBTjBOF4t_De3WE4_-j86z4gIN5f4AWcF8AomNd6CBTwBMwU-KpnS2dYZBSPAhQ4ozAmGNIUUGQe8K3Y6VCtWgKARQJgbwh-QsdIrUHkdzCDhSOoeaAu5H4UmwS5wEBNGhTRFPjqRhS4FIQUvABaFJKwCQgBFJQUtHIVfGkUhoxZFKQUyRSFFIwUqBSFXCTY2gTvGNOGGBjV5PVzAJjKUkaE3DjdqPCY8RjCnQCwdhB4FICUeRTKoAhaNKAjZJ1k5atzZKUcMYjoRE2rS9iIsCzgQqpA3HqiSKI9eNlIWRSnFJECNxTTZMurJRw9AgTKSgAYkDhAA9BcsgeqfVipmN_QEBJHFK0Uj-px4mY46D17FPCU7JT3bwq3YqsClICUTRT2FNsE5xSdFO54-Kpu6MdIDRTMYAiUuVxEu3IU2ATdFK-0GLjysHmgNxSTZMlMPWSzpXCcHAB9SLRURMj0tABNIJp5q21kvpTdZLNkwZSBQiercGYmGOgxGRSslMqU5RTKoDNiRtiylNxoZpStlLkeYUN1q02rFzM6YxntR3DIRNcuHLx-01g1fwY4gE1YipTIhiqUr7RlMhMYwpT1lOr8UaAolP6UuZTPvm8UjasdeEKYL_jGlK2sIpTugGraeQJ_Ylp415S1lMeUjZSJ4EBwpViHlO1HOFSBnmk-XpIlbmjoapjYVLGkNGJ5MLyUohjsVJKwYHtIVO_yF1B31mElCQgmFLNuMbYqVJQbIiNaVPk8dhA9lJxvPFD3lKJUmNJCOi9dTNFcoA4GB-TjXXhXFKokww_4mV4OWIYUpG1d9lbeJT9tPElUliTxvijuUCNZVOlU4H4zEkl6FdCtFHSU6ITf3yq-RhNl7wqPGxTWjhECAoj9VOo4ip5TkIRSP1jJY1NUiDdc5yECUKsA6kWEFO4EgAbLI5pNpxJNeFd6BObuNrdulPhXd0I8MC2hPYQiQA2DKa0CmDXOA5UPlCK9ejB66maHfeDoVxO1X1T6RQzkMbweygmtMPDncJCHf2QCx3-3d0IoNwr4BvV_VPxXLLJ8WybUK9CWgg5HeUAFIB5LI0B8AEZAdEsou3JtMGBbVJrUgRgou0N1GWIu_CSAEMj0AGdUj68HoAA2bIg3gEdUMGiz_CJY3YQ61HxoGY0JBRW6Cahu1IsfAg5nVPtDLVp7H2oHS2gO1NBGZ1SIyxLlZ1c0PHMoqBogRGdUtOdcPCEkv68Wgj3U3YQz1w68adTdhAXUsLDPlx-YPotan3iuZWwKaBZAIbxZyMz1JjhhMkJufSge6KLsPJifZKa-ftSPZOaORYRuZ03zXS97Fm4YAdTgNMZANLDePEdXTRcBIxXUxIBO1P3U29TXK0oyRq8jvifUz4c9gEHcLcRjf0rqUhQv1JmQyDSgNNI8EDSUON-hfyQ3gE0ERxihVJ_4-0greORUnFTqEj6ozRdANMgIc_MYNN-YxV5nAHzI8ejArzkGS9SII02nShV-4zpTX9oVs2yjGBTgPX_QKDTv8D404GTtiHSGPHsNQjwka_YyZUywMwQSl0UVeNdiyDlwRtSrmTmGSlJhNJdU_t1zblorft0JtmAYeTSekC406kjNp2QoP-gf2O2U0HBbNPrgRTT6AWU0qZxglh5gQwZtNLW-X4d9HD0rTlw22NGUfNI8VLtYsPin5SFXeQTP40dQWlduhHi0vCA0bGS0jUBCBI1XU90nVyMojYNdFzrk_IS1AFQ8fyd0PGNXbzpj3F3woYJzV1Y8W2d_eNMwLddU-yBaPwZWB3jnfSdQe2PXT1cD1IEHefAs510I--RHOOSeJpDlvgQA8gg6tLW-a0N2FEaowzSnsJjnHLSTLBUIyAB0PAC0g-4DV0PUlCIR5TItNb43lzPw37BbZJTXSldslxpXaBV6VzUHLipGqIOUatSdkPKwDfNJsJt2EfY8MFJCMbx_VMbEH2BoAFuQ1yt72LW0uDSBtJ1JLDSs2O-gXqcRwh5FYhgGem82aRNF1TkTdwBpAFSBaRkUiKnXOaCVHjRAz2AlICUwbGB4YH1Qi4AOl3zAc4clMEwAS8FK4F0IXqd9hEgeEOEhAFLhLqhMAF-00uNaQHB0oGxzAFPCPiA1zgO1C8J7T3HAFR4Hs1xHDHSvZDdQSeN3GnS8eecTzhJwKuMLQEkAfDxftPYtRZxgmDqeJ0AXOGfFWjtgLENmVkNSZGjAyyxSh1-HIcIYoKGWRNMS6ANPX7TDARdyaMCfnmUBKnTKaBp09np8diJCIqd2tMDXQhcjSB203mg0bAsUEXpuoF6naBpPBPmsdnYPGEt0_YRM0woBUIE3dLJoV05B1jcaCcBvdJAASB4tbCN0904WelkTWnTk8F6nSHDUdNIozsIGCPqYjUAHdLB6N_Bep2KgdqhCBJQiItcJIET05IiiDWR0Oeww516nfGZuaETYldcLeDnsT6gPLBcXCNdPJ2I2SvSNbGr03jAUKOBeXmwWjDTgYiRibDTk-Gxbdn_jcVi3VNXQ3mw_ZHhNH3Yp1wVkhGwK5IoOG7BS9I_gWvTvIGyQqBUkUWRsafSolEpUNEVbF0X0sICi52X0-Ss3tJ8Af5cndIOTdDxD6N3TU_Se12ZNK_Tz9LDoJSiFr3NYyqIbNLI0uzSQNNeaTzTL2juAVfjsO3dCTLoRaA9Xab5kAmsXBhIe52jwJRTR_AcEuuJ4fmsXaadgDJCXV5kwDPFwCAzylHsCOHChaF-iH3ET8yo0xpQaNKa-dQS_zX4wNlTNlNY0124N_3c015ZvZPc03fYCDKuZFAySDJuiBYRWSJXYzJTdlNBUk7gvlNmUmJSX-F2rF6pzwDykLN4V2OkY17ArFKEYhlS4KlWY6QDhMgsqbAzL5MyYsrByVIhESlT3NOIOcMZQnTkM_9TjFGxQilDjGIMU3lBf1KvkyXgZHToAMM8OqMogCxS6BNFU9zAnVBIUtDjKzkEYsucbFMbYjQzqDPEM-pSWhNg3N88HDMfAcQyPDJRydzSF2AyY1-SgYl-44pCPLVx1aD4zAHZk8YT3_F7QPd5wRJb4Wwyzght9U4SW1Ed9AiQMOCKEg8Ca_UBkkDB5BI-Eo_juhHOElDgnGKACFIzmBDaUowSOlO0dc5hnxBw4CRTiDK3UdIziJBsAu6g0bAKM4CxCBI-E4ojdNGYE0O1_SNOIYRQERPxmHUCYGL_nU-B5BDIY2WToEBjtXuA47WXgPmTxvyRIwWSRX1LkyOS0A15oXoxiSLVk4YwO2xdFM0V2uDYyflwUyKEQMEU0yKV_V0jLHTxXBIT6ZjRQOx0V5IcdDtBo-E3kjDAu6N3k_Xj95JvkteS75NLMPlTQnWfk3lTG2LwUhCMw3QsM_MUrDOs0GJiPDOgY3xicAGyouLAZwUCYzVTCsKGsY9U6-m-0sEyRDLCYoRinDPA2ED4_jN8dNji1NWCM4p0ATJGAPlTnekAGMx4MJNi0-QDWNNKA5DNNJwhMg6FZQkiwYkzxsEGVbXiBrizUcTST809sc3ANUA1QeyQ3VMqE0W5AAJQAvgjvVPTLKrIN1WFoLD9_N1kAtPja_zKAg2dv02JGLD8mS2FXdjVCgJVuVUzUYBDvXYF5AnNwYwgKwg9YQUz4fyOAQHABTNQAIUz46FRgfeZrTNtM4NAkKEd0wphHTItMiXR0y0lYxI0hhVlPGa9kROCIMoQoiHx0n4ALQCJ-UEYLQA5QuZR5Ah5UvGcA53sACUF3uBvffYy3RSOMpRwTjLOMyEUAcnjMxMyy1wLktvNvqGWOZNpXRUOMk0iQRVOM70VIRQI4u-kYzMkGfb1UxmUg4whYhONM1sgXTMRcK0yPWF3wBOgJ5wFUNcZQ20cPXMpSKlx41aMshh2AWlM8N3xGEPozlV8fLIy34kFwLUycrkkGIedZwATMwkFU-M6EZCFVzNhSegRfyNKwgQRigD5LHdV7xj4iT2oO6DRAFQsRGFPVLq9K4HKqHYAV5DQ4cFVrzPEEOuJXqyENX_peVgzkEqhlIIPOOPgRwjgWGxpWRRyyb8yM5GgoGmZ_eNjM-szixlInInAhzM_dWMzLen12dTSq1Te49hQmAJTVHUzXKF1uOTpk8GFXdCzahN1M-njOU3YUWMzlzJSALcy_12O4nMy1zLLXPhULxF5LLAABmUYsyyAv1WiIW8yXTw1ECsFXcGiIRwTzOOGGR9cCGJGEYPiPwC63a2xz2wsAfGZdXQ4GF1CCgH8tOPhElHx07FQuli_QIjZxLLBHXhZbBzj4ayVzlDOoeQRshzpWGaBPx3BzC-dcmHGHULxlLLUswWZtZh07ScJYBjXmUmYEwD97KTCU-3lPOcA0AAsgKCCtggzkDk47EGYUPeD_ZD4wEDQlxjWoO6xCNL7gwXN52jDyP3sSLKos7cyd5BFWKahYzNhEZCFwaNis0mQqqgcsiyy5QGsxciz4ADzM6adjdOsxFKzNr1rAP3tSqxKszKyMsxdANiz7zIys0TZlwkrgV0darIgWTjEAelEooNTbhQ4tfuDH22B0ziwih0VQG-VPx0T072M20kqDCFMJME4xKageVlOnByzfFgsAEcyOVkrGXM5NNJi0k-Jguji0pTQlzJisiizlxC2s3KzdzIECIvpWVBvMjqp2LKrQIY0GrOgM1cAWrMEw_Sc09HwU9uB2WPoU6wzZQkr8eiSHOLM6cEgApBJeSViLiAVsJrgfrPBIBWx3qAtUoqyx2EuHThcDk39PTLA8RGSsT4hKrIg0u8zhRQqqNGF9x0nCFWxvZFcgZEB6JwLwx-SPDLnwCXkFFNYsk6z7zIQ2U9BuLPUrF6yPXBrgDm8DOh7bBZidCGa04rSb9FnMyiCytIEHUrT_Jwq09hci2jxGHRd9ZzkHYK5SFVhna60vtMyIbzDZtO3UuBdWMI9XHxdUF3q6OgBBJMXyVo0R_EcGd7gZbNVsyNcjSFQAQ1txlRj4Xqd69JCXa3TiRGxUa6y02XrVKOcDbOPAGxd3qE1s4vSpgDFYnDt253X0iOSEbAcIgBNLdIr0hNjpbEdY6ddm9K9svWwWQW5oDMUe9KNxYWwApyJwIvZfsAuIL6zl2k2wU5xVbJQifVTnLhksEmjMDLu04TAgw0UtOTAAAF64dOCiMu13JRRoySj9QxHAFp4WZG9udQ4Xcn6smHSpsKGIzYg_rLfwP0sPMCLXU8Y_rL-XK3NZUFxCBahkbFas-E17Y3u8JzYDULdyExZ4LLj4Pi0JqBI4ppDTbIl6XXiewnAIpgICN0UwEcB99GOAUczdgBpqEZcxMF9lY3SDtUwJW8JqbPDYLIA6bM3YmzksFGEwM_xPqCWTSupiQgXOMezMMVJoHEA8QBAuc7kIRlMCHUBodJdAIGzKu0Bs4ac28z7XVuy1xzg4_0V2FAWoTYB4rIDVHqzsBmrs5S1PYGrsEeBlQ3BUNbDySjgAeuwHEArsXucG13xWH-zQ53Q8AgcQsj1soqcO5inXVqy28yGshxNIYA7pPm8haHlQeccm5mns1dMz7PHjNsUr7PEwDXTGMGgcy7Tc52iAVztoiHOkBuyk-hQc3u5KAHQc-aB5x1zmNfTQ5yDwUwjewjP8ZhzkFSflG3sND2R1cDFX7KC8d-zlHJlVe3R-HIBoVBzhHPBUQphaHPHmCRyBF3OkaRyh9OANRIB7TJ-yZ2yy5Nds86JuHI_s-Hh0AAbsz2yB6DRFGzh1HIXASuAv7NcctWxpbBZVYCxDMD5sEOyhbH708OygDlb2QkyQmNYsgCwsAAscqhz8HNP4MViUDUSAEnwMHJDIF2zN9PsczxzoiCDwFxzAnPcctzIeHO8c4adfHItsfxyAfi70hcAQnKmgMOygiIKGKJy-1BvGWJyUnLVlIvSSNORMmJycWL5iN7TorM3MxMy38A9XaJdPQVQaSZjT3glBGScUuwXmeStqHImctRk8uwXmdhJbtPs_bByG12sc0OcVnPrs4ad1nKdYzZzWABjs9_x47O-sjtDgrT6cz0EcrIS7R9jOnIJs5xSa0PWQ5EzzaMQtTmjUqwSczdSJbN4kobJkQUh8MHtkQUmc32jzJyQ8aBovnJ77DBdd8Nxs4QycsEkGHKzOvDmc0HYsAFQaUJBYXLO8PLsEXKSs85zczOxFfizwXLQ4gTAKvHwOQTSkOmQQQ-zaADps6CzgMDX8VCDqs1UJHuTzbnwdIDp1DLXs8czawHoc71JzMOTweDZe1QK0ucz2FAXM4izNrP6ctcyXyl2sncyumVos1RBqImOs23ASbIlc58yEUlTw8O9_-wjlfFpnNLCMzt4T4NCVOpA0EnaIyYSffV-Ezy1WAySM3nhmjKGPUETHUHKMzIzGTKZTaYSO_lwsnIyO_lFMnW4NhP33LYTv2F8AzYTMuh6MiAQbjLFFde9PSM8YgIzhjIqwYkCxjN63CYzSeLMcEV8pS1srCj8uzBso0TN9KMQcPNsUHHDCBe1KIA0Yo6YtGMhOJt9gxV80T8Sipktkl0iOq1NCGhhlFioM1_SjgFiQmocWlFoM64VCVIYMgSoRi1AUOoE5jSyzATBdRxtcKXoDlJsUmEyrGP8Y-yRMiI28DOQs2nAIZdZTFOFM5mog5P-oEOSPJW6AMYyUAXoBVPswPUYU1Zie3NgYwxIR3P-YYdzYgFHctD1_6HwlHNyoxIjFCzI4LwKwNEV8GPA7Idjz3Lr4yCCsGOAwUIBWADQ4W9yW6JGUJtzFeigAVtyMAHbc1VSHzXucvGyyhE_c4sBTSlhMmARBTG1fLrgf0mcAXExDuD1U4BhXyIzwDEjJVyIufk8bGK6AIGdV3OGU0mgrsEr2ArBi31rAXDyLAHTcykURSPdgEiiWsEI84Uj2pn2MYjYk9JLQJhjQwlUYn_j0PJQ87FAa3IW_QohmPKBnXQz9eKFQD_igZxWKRoyKbzsSNjTeGJA-T_Sv2n3oAejRPP409zACTO4YODyh_QhsplMhvG3E6-BbNCIDFfg3IBDFPNyeHCuVZoRlPLrE3yT93M083NyRxKPc3BwrlUnM_TzTxJK3IzytPNM8xpwrlWP9U4YVPPDiWzyTPL3Ehzz7OPBc-TyjsHqtRNxtSQCwdU0xPPHo6uSQgA_gdwz53PiQGUh4XOyIHzy7gD880nxwnO884GTblhNwbbNYvJS87YgEvLSgErsMvPoBVLy-hGpnWDzMvPcwbLzWgkYUuLzbWCK8uTySvN881dxpJIq82rz4vNXcHWyT8yZU0FSzYnoM4pT3DJWUvvAf-L48rrzBPOKrOQzZPNtYODytRF4I5dy2OJG8zKAELVMMnU0xLOI2RKp_LNpqbciQHApnKTClMEiSMYB3j046WRSzQi8OGYRIrKCaDUN_hD4Qi081KymgeIBMdTdwOS09gDiqYagMNj-AGjAHs2bI0EZarJw4r1xHBDis62QpqGS8b4hBqk5QrLDQbMho26BFZjG-SyUxvgezIuzggCUgT4RbWPEs2az2AF68jjzYZ348utzilN4Irss-kggYEEz8yl4881dIsHo8xe5mPIKkkJd2pBdALmjgrUG879wRuIXPQhRYaLIwTt0RKKkwmHy0aOkokXQQeP686xcT3HI8zNzqPOI2Gnyg7yIMjHzBPMlQjKthvitdUex-tPDmUyjkqJYrRkjZfJ0rdDT_eP8o5KjRoDjcvSjDM0Eoteg1fPRQFJUEel_mAnyQl3y7PXypgDUolTMhSP58kijVfKcomNyswHlkcihjfKts0KjlSyV8wytDdxXY4nzAblJ89DcfPG584mcvfLskBjy1DTtQEkz9FVCM-6yFMx_UPLyovNK8jLkoTPnEIdAxPISwLUQqfLec4roXVx3UwFzo_PcwRWy4uJfI4GSUOIhc4wzYE0JTd81vk2K8_LzNSHPUthB8yKtUMQh4IJM6SlTKvJS7VFzY_PgAGUhts3I8MnNonwwIevyTVNx4yLzO_OiwD_hy_Ki0qSciABT84vy0ONL8r1SZtMz8yWyjJzz83dSzBBT8_Py3eOR0fMiZ_KJMhC1a_ML8-gEUuzSgYh0982VcpJ0beHG8-9AKTLPqaScFPPFwYfyCvL889PpwSBbLafyh_Nn8hC15_OYsHWN6-2X83agsHM2IV_zXyN9DL38oowuIIAKUvLkEb8cHylv8o7A5BCVjFo9lBB_86AjTnJNjYdiGsg75BA0FUKJIbfylzm42eI96gG1AH8VGMFzgSb98gHO4ZIAq8x8AcYtvY1YAX2NusChI2nhQ-n8GCIB2rnGCDUzavBoJOjlkAufyYPiFQD28cMN5VzYCugja5S3Uj5z-JNYCt88N_KyIvQy_kGcubwzFJLucnUkGMMm6NALHdLYXBAZ0cKmDL3N_NzUJIbIeAtifFyNvf3i-UiD5QHlXcmoRAtxsvGEuwBT8xAcLAvVdYTjtIFsCswR0CGa08QLV_LaEaQLqP0XudDyxPIkIb3yQpGY8t0hL10wdI_yHRWLktNDF7j0QAUC8uyClCILZly3c7cy-3LIwNHYKaHOU8iADVJasTMRbZHp0lsA23Gi8bfytgmN0yONIgo64k9wT_OfyS9d_3PLo1yALGKsYkDzPWljEE9JIPPq4Q7hmbwElKILBBMEFHxirGM9UrLMyqPvuMHFs3FSUq5y8bKTScJiH13VdYoV6pLY4hf4fBFG3Ff4TAWAxDiliwGJAKoBvADtSX8AKDmYhb5FM_DMBRxNIYB2C1OkZ40vCU9EpATnnXCBmFkBYSuTWoSngG-BvDjuFPuAb4nKAEEANgrJBbf5dYTskMwFp-CwgI4LWoUC2M8oZsUkoJhgtQDMBRcttCQ4FJGAWER2pZYygQv4AcELsYCRgfrloQsMYFuAwQr0gSGAcACayIjEQQqR_byQwQsRCmAVsQvShThCkmXhCjEKQeSxCtgkcUW8kfzhAuDBCw2VEYBGZGkLfuBeZWkLAeFcFZIFFyzvpLEKyqUtBQkJmlHRCzELmQrRxTGskpCFCxxN_uD8UQ0UcQuQxTYyMAyZRHYzhqi5CoyAsQqxClEKx2xSlSdtNlz5I4ds-cXP-RABSATWXZCENlyygZNyHRw1CiTUeOky7FULMQuJCnWEWWj6ANlp8YTBC1UKIYHtCtHEnguxIoUKiQpRCiu0sQDBCu-lEYA9C-yEk_PCgTe1V7RJIkJMgCQcBcELfgXVC2ULv_TmJX_0BgzBCpkLkQtlC1l8fjjBCmAUazNlC8NzNACFC_0EQwv5CzyRrQBzC1UKWeChCwLF-mBcEV4LcAFKlI_gyJHmC38ZaEHU5SvkrqB0Aa3hqVilAQjk5gH4AeQAFAHQEoAA`} __position={0} __code={'<Map viewport={{ center: [0.026, 123.61], zoom: 5 }} />'} __scope={{props: this ? this.props : props,Map}}>\n  <Map viewport={{ center: [0.026, 123.61], zoom: 5, }} />\n</Playground>\n           </MDXTag>\n  }\n}\n  "],"sourceRoot":""}