{"version":3,"sources":["/Users/joseangel/Workspace/map-components/src/map/glmap/map.css","/Users/joseangel/Workspace/map-components/src/map/lib/Pack.js","/Users/joseangel/Workspace/map-components/src/map/lib/pelagosClient.js","/Users/joseangel/Workspace/map-components/src/map/proptypes/tracks.js","/Users/joseangel/Workspace/map-components/src/map/proptypes/layers.js","/Users/joseangel/Workspace/map-components/src/map/proptypes/shared.js","/Users/joseangel/Workspace/map-components/src/map/config.js","/Users/joseangel/Workspace/map-components/src/map/module/module.actions.js","/Users/joseangel/Workspace/map-components/src/map/module/module.selectors.js","/Users/joseangel/Workspace/map-components/src/map/tracks/tracks.selectors.js","/Users/joseangel/Workspace/map-components/src/map/constants.js","/Users/joseangel/Workspace/map-components/src/map/utils/buildEndpoint.js","/Users/joseangel/Workspace/map-components/src/map/utils/heatmapTileData.js","/Users/joseangel/Workspace/map-components/src/map/heatmap/heatmapTiles.actions.js","/Users/joseangel/Workspace/map-components/src/map/heatmap/heatmap.actions.js","/Users/joseangel/Workspace/map-components/src/map/glmap/viewport.actions.js","/Users/joseangel/Workspace/map-components/src/map/glmap/interaction.actions.js","/Users/joseangel/Workspace/map-components/src/map/utils/map-colors.js","/Users/joseangel/Workspace/map-components/src/map/heatmap/HeatmapSubLayer.js","/Users/joseangel/Workspace/map-components/src/map/heatmap/HeatmapLayer.js","/Users/joseangel/Workspace/map-components/src/map/tracks/TracksLayer.js","/Users/joseangel/Workspace/map-components/src/map/activity/ActivityLayers.js","/Users/joseangel/Workspace/map-components/src/map/activity/ActivityLayers.container.js","/Users/joseangel/Workspace/map-components/src/map/glmap/Map.js","/Users/joseangel/Workspace/map-components/src/map/glmap/Map.container.js","/Users/joseangel/Workspace/map-components/src/map/glmap/style.reducer.js","/Users/joseangel/Workspace/map-components/src/map/utils/getMainGeomType.js","/Users/joseangel/Workspace/map-components/src/map/glmap/style.actions.js","/Users/joseangel/Workspace/map-components/src/map/glmap/viewport.reducer.js","/Users/joseangel/Workspace/map-components/src/map/store/index.js","/Users/joseangel/Workspace/map-components/src/map/tracks/tracks.actions.js","/Users/joseangel/Workspace/map-components/src/map/utils/withReducerTypes.js","/Users/joseangel/Workspace/map-components/src/map/module/module.reducer.js","/Users/joseangel/Workspace/map-components/src/map/tracks/tracks.reducer.js","/Users/joseangel/Workspace/map-components/src/map/heatmap/heatmap.reducer.js","/Users/joseangel/Workspace/map-components/src/map/heatmap/heatmapTiles.reducer.js","/Users/joseangel/Workspace/map-components/src/map/glmap/interaction.reducer.js","/Users/joseangel/Workspace/map-components/src/map/store/reducers.js","/Users/joseangel/Workspace/map-components/src/map/map.js","/Users/joseangel/Workspace/map-components/src/map/basemaps/index.js","/Users/joseangel/Workspace/map-components/src/map/map.mdx"],"names":["module","exports","byname","Uint8","size","Uint8Array","BYTES_PER_ELEMENT","array","getter","setter","Int8","Int8Array","Uint16","Uint16Array","Int16","Int16Array","Uint32","Uint32Array","Int32","Int32Array","Float32","Float32Array","Float64","Float64Array","writeStringToArrayBuffer","str","start","end","buf","bufstart","undefined","length","i","charCodeAt","arrayBufferToString","String","fromCharCode","apply","Pack","typemap","byarray","pack","typespec","value","littleendian","ArrayBuffer","DataView","stringToArrayBuffer","res","Uint8ClampedArray","buffer","name","spec","PelagosClient","this","MAGIC_COOKIE","url","token","Promise","resolve","reject","request","XMLHttpRequest","open","setRequestHeader","responseType","onload","handleData","bind","onerror","send","self","error","readyState","success","status","isFileUri","response","byteLength","dataView","headerLen","cookie","slice","getInt32","offset","headerIsLoaded","header","JSON","parse","rowLen","colsByName","colidx","cols","col","idx","type","multiplier","min","max","orientation","errorLoading","toString","allLoaded","result","rowidx","row","val","colValues","eval","trackTypes","id","PropTypes","string","isRequired","data","object","color","oneOf","layerTemporalExtents","arrayOf","number","fitBoundsOnLoad","bool","heatmapLayerTypes","tilesetId","subtype","visible","hue","opacity","filters","shape","filterValues","endpoints","temporalExtents","temporalExtentsLess","interactive","basemapLayerTypes","staticLayerTypes","selected","selectedFeatures","field","values","highlighted","higlightedFeatures","showLabels","isCustom","gl","popupTypes","content","node","latitude","longitude","viewportTypes","zoom","center","VESSELS_BASE_RADIUS","MAX_SPRITES_PER_LAYER","STATIC_LAYERS_CARTO_ENDPOINT","STATIC_LAYERS_CARTO_TILES_ENDPOINT","TILES_URL_NEEDING_AUTHENTICATION","initModule","props","dispatch","payload","startLoader","state","loaderId","timestamp","Date","getTime","map","onLoadStart","completeLoader","getState","loaders","onLoadComplete","onViewportChange","interactionState","callback","viewport","bounds","canZoomIn","canZoomOut","mouseLatLong","setTemporalExtent","temporalExtent","setHighlightTemporalExtent","highlightTemporalExtent","closePopup","onClosePopup","setCursor","cursor","getTemporalExtent","getHighlightTemporalExtent","getTracksData","tracks","getGeojsonTracks","createSelector","filter","t","getGeojsonTracksReady","mergeStyles","style1","style2","sources","layers","filterGeojsonByTimerange","geojson","features","featuresFiltered","reduce","filteredFeatures","feature","properties","coordinateProperties","times","filtered","geometry","coordinates","filteredCoordinates","coordinate","index","timeCoordinate","push","filteredFeature","getFullTracksStyles","hasTemporalExtent","hasTracks","timerange","acc","track","source","style","paint","getHighlightedTrackStyles","getTracksStyles","trackStyles","highlightedTrackStyles","TRANSITION_TYPE","ZOOM","BRUSH_RENDERING_STYLE","NORMAL","BULLSEYE","BRUSH_ZOOM_RENDERING_STYLE","RADIAL_GRADIENT","CIRCLE","CUSTOM_LAYERS_SUBTYPES","raster","urlTemplate","urlParams","templateSettings","interpolate","template","urlTemplateCompiled","getTemporalTileURLs","params","urls","forEach","extent","startTimeISO","toISOString","endTimeISO","tileCoordinates","x","y","z","buildEndpoint","temporalExtentsIndices","indexOf","getTilePromises","tilesetUrl","promises","urlIndex","obtainTile","getCleanVectorArrays","rawTileData","vectorArray","groupData","cleanVectorArrays","columns","currentArray","totalVectorArraysLength","sumBy","a","filteredColumns","column","console","warn","key","cumulatedOffsets","appendValues","set","getTilePlaybackData","prevPlaybackData","tilePlaybackData","zoomFactorRadius","convert","getZoomFactorRadius","zoomFactorRadiusRenderingMode","getZoomFactorRadiusRenderingMode","zoomFactorOpacity","getZoomFactorOpacity","columnsArr","Object","keys","c","storedColumns","concat","sigma","weight","hidden","pull","uniq","numPoints","newFrames","timeIndexes","point","timeIndex","getOffsetedTimeAtPrecision","datetime","lngLatToWorld","worldX","worldY","radius","sigmaToRadius","weightToOpacity","series","frame","addTracksPointsRenderingData","hasFishing","getTracksPlaybackData","playbackData","vesselSatisfiesFilters","every","selectVesselsAt","tileData","tileQuery","startIndex","endIndex","currentFilters","vessels","toleranceRadiusInWorldUnits","f","wx","wy","pass","some","vesselSatisfiesAllFilters","vessel","getTilecoverLimits","viewportZoom","Math","ceil","tilesAvailable","min_zoom","max_zoom","flushToReleaseTiles","heatmapTiles","currentToLoadTileUids","currentTilesToReleaseUids","currentToReleaseTileUids","releaseTiles","markTileAsLoaded","tileUids","flushTileState","forceLoadingAllVisibleTiles","currentVisibleTiles","tilesToLoad","tilesToReleaseUids","currentLoadedTiles","visibleTile","find","uid","loadedTile","tilesToLoadUids","tile","getTile","updateLoadedTiles","debouncedFlushState","debounce","updateHeatmapTilesFromViewport","mapViewport","width","height","currentTransition","boundsViewport","PerspectiveMercatorViewport","unproject","wn","es","w","s","e","n","boundsPolygonsCoordinates","limits","w1","e2","geom","viewportTilesCoords","tilecover","tiles","viewportTilesIndexes","indexes","visibleTiles","coords","prevZoom","queryHeatmapVessels","temporalExtentIndexes","uids","highlightVesselFromHeatmap","ADD_REFERENCE_TILE","HIGHLIGHT_VESSELS","UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES","UPDATE_HEATMAP_TILE","getTemporalExtentsVisibleIndices","loadTemporalExtent","currentExtentStart","currentExtentEnd","indices","temporalExtentStart","getTiles","layerIds","referenceTiles","newTemporalExtentsToLoad","loaderID","join","heatmapLayers","heatmap","tilesByLayer","allPromises","layerId","heatmapLayerHeader","referenceTile","temporalExtentsIndicesLoaded","queriedTemporalExtentsIndices","visibleTemporalExtentsIndices","temporalExtentsIndicesToLoad","difference","tilePromise","Error","pelagosPromises","allLayerPromises","all","then","loadedLayerId","loadLayerTile","parseLayerTile","visibleHeatmapLayers","visibleHeatmapLayersIds","loadAllTilesForLayer","addHeatmapLayer","layer","removeHeatmapLayer","updateLayerLoadTemporalExtents","indicesToAddByLayer","heatmapLayer","oldVisibleTemporalExtentsIndices","newVisibleTemporalExtentsIndices","indicesAdded","indicesRemoved","layerIdsWithIndicesToAdd","_queryHeatmap","layersVessels","availableTiles","bestTile","isCluster","isMouseCluster","isEmpty","layerVesselsResult","foundVessels","layersVesselsResults","layerVessels","v","uniqBy","clearHighlightedVessels","clickableCluster","highlightedVessels","layerPayload","highlightableCluster","highlightClickedVessel","clearHighlightedClickedVessel","updateHeatmapLayers","newLayers","currentLoadTemporalExtent","prevLayersDict","newLayer","prevLayer","prevLayerId","l","setBounds","setViewport","updateViewport","viewportUpdate","transitionTo","increment","transitionToZoom","transitionEnd","zoomIntoVesselCenter","fitToBounds","vp","fitBounds","minLng","minLat","maxLng","maxLat","padding","exportNativeViewport","nativeViewport","topLeftPx","bottomRightPx","topLeftWorld","pixelsToWorld","pixelUnprojectionMatrix","bottomRightWorld","leftWorldScaled","scale","rightWorldScaled","northWest","southEast","north","south","west","east","getAreaKm2","glFeature","area","toLocaleString","maximumFractionDigits","getFeature","fields","fieldsDefinition","metadata","fieldsKeys","k","fd","fieldKey","def","label","title","isLink","isMain","mainField","getFields","mapInteraction","interactionType","glFeatures","glGetSource","legacyHeatmapFeature","currentStyle","mapStyle","toJS","event","currentLegacyHeatmapData","count","group","clusterPromises","getStaticLayerIdFromGlFeature","cluster","clusterPromise","clusterId","cluster_id","glSource","getClusterExpansionZoom","err1","getClusterLeaves","err2","children","childrenFeatures","child","getCluster","autoClusterZoom","clusterBehavior","clusterZoom","onClick","onHover","COLOR_HUES","orange","peach","yellow","green","brightGreen","lightBlue","blue","purple","pink","getKeyByValue","obj","entries","entry","rgbToHsv","_r","_g","_b","h","r","g","b","d","hsvToRgb","h_","s_","v_","parseFloat","floor","p","q","mod","round","hueToRgbDefaults","hueToRgbString","rgb","rgbToHexString","css","channelName","channelValue","channelStr","hueToRgbHexString","hueToClosestColor","goal","colorHueValues","closestHue","prev","curr","abs","hexToRgb","hex","exec","parseInt","rgbToRgbaString","hueToRgbaString","hexToRgba","hueIncrementToHue","hueIncrement","hueToHueIncrement","wrapHue","hueOrColorToHexColor","HeatmapSubLayer","baseTexture","renderingStyleIndex","useNormalBlendMode","stage","PIXI","particles","ParticleContainer","alpha","position","uvs","blendMode","BLEND_MODES","SCREEN","spritesPool","initialTextureFrame","Rectangle","mainVesselTexture","Texture","_setTextureFrame","clearSpriteProps","spritesProps","spritesPropsCount","destroy","textureFrame","clone","VESSELS_HUES_INCREMENTS_NUM","update","numProps","resizeSpritesPool","sprite","setTransform","numSprites","delta","toRemove","removeChildAt","toAdd","_addSprites","num","Sprite","anchor","addChild","worldToPixelsSimple","m","HeatmapLayer","_build","_destroy","_redraw","nextProps","useRadialGradientStyle","setBrushZoomRenderingStyle","rootStage","customRenderingStyle","subLayers","renderingStyle","rendering","setBrushRenderingStyle","brushRenderingStyle","toUpperCase","_setBrushRenderingStyleIndex","brushZoomRenderingStyle","cappedZoomRenderingStyle","newStyleIndex","subLayer","setRenderingStyleIndex","defaultHue","allHuesToRender","currentlyUsedHues","allHues","_createSublayer","_destroySubLayer","_setSubLayersSpritePropsForTile","numFilters","hueToRender","render","viewportLeft","viewportRight","len","fi","scaledX","scaledY","mtx","pixelProjectionMatrix","pitch","worldToPixels","pushSpriteProps","defaultOpacity","defaultSize","removeChild","React","Component","TracksLayer","Graphics","nativeLines","clear","highlightTemporalExtentIndexes","overInInner","overExtent","drawFishingCircles","fishingCirclesRadius","drawOverTrack","_drawTrack","substr","lineThickness","lineOpacity","prevSeries","prevWorldX","prevWorldY","worldOffset","circlePoints","lineStyle","duplicateWorld","currentSeries","moveTo","atDatelineWorldY","isWestToEast","worldXEnd","atDatelineEndWorldX","atDatelineStartWorldX","x1","y1","lineTo","x2","y2","beginFill","circlesLength","drawCircle","endFill","ActivityLayers","pixiReady","onTouchStart","touches","queryCoords","clientX","clientY","onMouseMove","_onTick","heatmapFadingIn","heatmapStage","_heatmapFadeinStep","setState","_context","_updateViewportSize","pixi","transparent","antialias","renderer","canvas","view","container","appendChild","baseTextureCanvas","blurFactor","tplCanvas","document","createElement","tplCtx","getContext","diameter","yCenter","gradient","createRadialGradient","rgbString","addColorStop","rgbOuter","fillStyle","fillRect","beginPath","arc","PI","fill","lineWidth","strokeStyle","stroke","getVesselTexture","fromCanvas","ticker","add","viewportWidth","viewportHeight","resize","dim","wrappedLongitude","heatmapFadeinStartTimestamp","now","timeElapsed","highlightedClickedVessel","highlightLayerData","highlightFilters","shouldUseRadialGradientStyle","toggleHeatmapDimming","_startHeatmapFadein","getError","err","log","_getHighlightData","ref","BaseControl","propTypes","func","contextTypes","getHeatmapLayersAsArray","getTracksWithData","getTemporalExtentIndexes","startTimestamp","endTimestamp","getHighlightTemporalExtentIndexes","connect","ownProps","PopupWrapper","closeButton","onClose","offsetTop","tipSize","closeOnClick","defaultProps","Map","onLoad","getBounds","glMap","_ne","_sw","lat","lng","loadObserver","window","ResizeObserver","default","_containerResizeObserver","handleResizeObserver","observe","_mapContainerRef","contentRect","propsViewport","bearing","onMapInteraction","lngLat","getRef","getMap","getSource","getCursor","isDragging","transformRequest","resourceType","match","headers","Authorization","mouseOver","disconnect","maxZoom","minZoom","clickPopup","hoverPopup","hasHeatmapLayers","markers","interactiveLayerIds","className","styles","onMouseLeave","onMouseEnter","onTransitionEnd","clickRadius","marker","googleLogo","getInteractiveLayerIds","staticLayers","glLayer","glLayerId","getMapStyle","mapStyles","trackLayersIndex","lastIndexOf","finalMapStyles","mergeIn","mapStylesLayers","get","trackLayer","insert","fromJS","interaction","internalCursor","moduleCursor","long","attributions","GL_STYLE","sourceKey","attribution","setLayerStyleDefaults","layout","temporalField","visibility","initialState","cartoLayersInstanciated","basemapLayers","TYPES","geoJSON","INIT_MAP_STYLE","SET_MAP_STYLE","MARK_CARTO_LAYERS_AS_INSTANCIATED","SET_STATIC_LAYERS","SET_BASEMAP_LAYERS","setDefaultVectorTiles","currentSource","refLayerUrl","refLayerUrls","initStyle","glyphsPath","setMapStyle","setStyleTemporalExtent","applyToThrottled","glLayers","currentFilter","getIn","isLegacy","setIn","applyTemporalExtentThrottled","throttle","applyTemporalExtent","updateGLLayer","refLayer","currentStyleLayers","newStyle","glLayerIndex","findIndex","toggleLayerVisibility","isBasemap","refLayerOpacity","labelsVisibility","colorPaintProperty","currentGlLayer","glType","defaultStyles","styleType","refLayerStyle","hasFeatures","applyStyleToAllFeatures","allPaintProperties","glPaintProperty","glPaintFinalValue","selectedValue","fallbackValue","paintOrLayout","includes","originalLayerStyle","layerColorRgbString","layerColorRgb","replace","applyLayerExpressions","addCustomGLLayer","tileSize","allGeoJSONTypes","numByGLType","geoJSONType","glTypeMax","getMainGeomType","layerIndex","reverse","splice","instanciateCartoLayers","sourceId","cartoLayersPromises","sourceCartoSQL","mapConfig","options","sql","mapConfigURL","encodeURIComponent","stringify","cartoAnonymousMapUrl","fetch","json","layergroupid","catch","instanciatedCartoLayers","cartoLayer","tilesURL","newSourceId","deleteIn","commitStyleUpdates","bl","currentGLSources","workspaceGLLayers","workspaceGLLayer","finalSource","existingLayerIds","layerToAdd","layerToAddId","sourceLayer","existingLayers","newLayerGroup","newLayerIndex","findLastIndex","updateWorkspaceGLLayers","customLayers","glSources","cartoLayersToInstanciate","newSource","cartoLayerInstanciated","DEFAULT_TRANSITION","transitionDuration","transitionInterpolator","FlyToInterpolator","transitionEasing","easeCubic","composeEnhancers","compose","process","MAP_REDUX_REMOTE_DEBUG","REACT_APP_MAP_REDUX_REMOTE_DEBUG","store","createStore","applyMiddleware","thunk","targetMapVessel","fitToBoundsAction","geoBounds","timelineBounds","setTimeout","TRANSITION_DURATION","ADD_TRACK","UPDATE_TRACK","getTrackDataParsed","time","Infinity","getTrackBounds","tbbox","getOldTrackBoundsFormat","addOffset","geo","loadTrack","trackHasData","trackHasUrl","cleanData","rawTrackData","statusText","finally","removeTrack","trackId","updateTracks","newTracks","prevTracks","newTrack","prevTrack","withReducerPropTypes","propTypesSchema","reducer","onAttributionsChange","withReducerTypes","instanceOf","action","loaderIndex","exact","trackData","removedTrackId","mapReducer","combineReducers","ModuleReducer","TracksReducer","assign","newTile","layerTiles","tileIndex","tileUid","releasedTileIndex","releasedRefTileIndex","newHeatmapLayers","newToLoadTilesUids","tileUidsMarkedAsLoaded","newCurrentToLoadTileUids","newMapStyle","currentZoom","mapReducers","replaceReducer","throttleApplyTemporalExtent","updateViewportFromIncomingProps","incomingViewport","MapModule","initialized","errorInfo","prevProps","currentViewport","componentStack","AVAILABLE_BASEMAPS","layoutProps","MDXLayout","MDXContent","components","mdxType","parentName","__position","__code","__scope","Playground","PropsTable","__codesandbox","isMDXComponent"],"mappings":"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","file":"static/js/src-map-map.35996ef2.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"map\":\"map_map__1TLha\",\"googleLogo\":\"map_googleLogo__3lQ1y\"};","/* eslint-disable */\nvar byname = {\n  Uint8: {\n    size: Uint8Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint8',\n    setter: 'setUint8',\n  },\n  Int8: {\n    size: Int8Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint8',\n    setter: 'setUint8',\n  },\n  Uint16: {\n    size: Uint16Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint16',\n    setter: 'setUint16',\n  },\n  Int16: {\n    size: Int16Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getInt16',\n    setter: 'setInt16',\n  },\n  Uint32: {\n    size: Uint32Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint32',\n    setter: 'setUint32',\n  },\n  Int32: {\n    size: Int32Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getInt32',\n    setter: 'setInt32',\n  },\n  Float32: {\n    size: Float32Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getFloat32',\n    setter: 'setFloat32',\n  },\n  Float64: {\n    size: Float64Array.BYTES_PER_ELEMENT,\n    array: 'Float64Array',\n    getter: 'getFloat64',\n    setter: 'setFloat64',\n  },\n}\n\nvar writeStringToArrayBuffer = function(str, start, end, buf, bufstart) {\n  if (end == undefined) {\n    end = str.length\n  }\n  if (start == undefined) {\n    start = 0\n  }\n  if (bufstart == undefined) {\n    bufstart = start\n  }\n  for (var i = start; i < end; i++) {\n    buf[i - start + bufstart] = str.charCodeAt(i) & 0xff\n  }\n}\n\nvar stringToArrayBuffer = function(str, start, end) {\n  var self = this\n\n  if (end == undefined) {\n    end = str.length\n  }\n  if (start == undefined) {\n    start = 0\n  }\n  var res = new Uint8ClampedArray(end - start)\n  writeStringToArrayBuffer(str, start, end, res, 0)\n  return res.buffer\n}\n\nvar arrayBufferToString = function(buf) {\n  return String.fromCharCode.apply(null, new Uint8Array(buf))\n}\n\nvar pack = function(typespec, value, littleendian) {\n  var array = new ArrayBuffer(typespec.size)\n  new DataView(array)[typespec.setter](0, value, littleendian)\n  return arrayBufferToString(array)\n}\n\nvar Pack = {\n  typemap: {\n    byname: byname,\n    byarray: {},\n  },\n  pack: pack,\n  arrayBufferToString: arrayBufferToString,\n  stringToArrayBuffer: stringToArrayBuffer,\n  writeStringToArrayBuffer: writeStringToArrayBuffer,\n}\nfor (var name in Pack.typemap.byname) {\n  var spec = Pack.typemap.byname[name]\n  spec.name = name\n  Pack.typemap.byarray[spec.array] = spec\n}\n\nexport default Pack\n","/* eslint-disable */\n\nimport Pack from './Pack'\n\nclass PelagosClient {\n  constructor() {\n    this.MAGIC_COOKIE = 'tmtx'\n  }\n\n  obtainTile(url, token) {\n    return new Promise(\n      function(resolve, reject) {\n        this.request = null\n        if (typeof XMLHttpRequest != 'undefined') {\n          this.request = new XMLHttpRequest()\n        } else {\n          throw 'XMLHttpRequest is disabled'\n        }\n        this.resolve = resolve\n        this.reject = reject\n        this.request.open('GET', url, true)\n        if (token) {\n          this.request.setRequestHeader('Authorization', `Bearer ${token}`)\n        }\n        this.request.responseType = 'arraybuffer'\n        this.request.onload = this.handleData.bind(this)\n        this.request.onerror = this.handleData.bind(this)\n        this.request.send(null)\n      }.bind(this)\n    )\n  }\n\n  handleData() {\n    var self = this\n    if (!this.request) {\n      return\n    }\n    if (this.error) {\n      return true\n    }\n\n    if (this.request.readyState == 4) {\n      /* HTTP reports success with a 200 status. The file protocol\n       reports success with zero. HTTP returns zero as a status\n       code for forbidden cross domain requests.\n       https://developer.mozilla.org/En/Using_XMLHttpRequest */\n      var success = this.request.status == 200 || (this.isFileUri && this.request.status == 0)\n      if (!success) {\n        this.resolve(null)\n        return\n      }\n    }\n\n    if (!this.request.response) {\n      return\n    }\n    var length = this.request.response.byteLength\n    var response = this.request.response\n    var dataView = new DataView(response)\n\n    if (length < 4 + 4) {\n      return\n    }\n    if (self.headerLen == null) {\n      var cookie = Pack.arrayBufferToString(response.slice(0, 4))\n      if (cookie != this.MAGIC_COOKIE) {\n        this.reject(\n          'Could not load ' +\n            this.url +\n            ' due to incorrect file format. Cookie: [' +\n            this.cookie +\n            ']'\n        )\n        return\n      }\n\n      self.headerLen = dataView.getInt32(4, true)\n\n      self.offset = 4 + 4\n    }\n    if (length < self.offset + self.headerLen) {\n      return\n    }\n    if (!self.headerIsLoaded) {\n      self.header = JSON.parse(\n        Pack.arrayBufferToString(response.slice(self.offset, self.offset + self.headerLen))\n      )\n      self.rowLen = 0\n      self.header.colsByName = {}\n      for (var colidx = 0; colidx < self.header.cols.length; colidx++) {\n        var col = self.header.cols[colidx]\n        col.idx = colidx\n        self.header.colsByName[col.name] = col\n        col.typespec = Pack.typemap.byname[col.type]\n\n        if (col.multiplier != undefined && col.min != undefined) {\n          col.min = col.min * col.multiplier\n        }\n        if (col.offset != undefined && col.min != undefined) {\n          col.min = col.min + col.offset\n        }\n        if (col.multiplier != undefined && col.max != undefined) {\n          col.max = col.max * col.multiplier\n        }\n        if (col.offset != undefined && col.max != undefined) {\n          col.max = col.max + col.offset\n        }\n\n        self.rowLen += col.typespec.size\n      }\n      self.offset += self.headerLen\n\n      // Add the padding to nearest 4-byte-boundary\n      self.offset += (4 - (self.headerLen % 4)) % 4\n\n      self.headerIsLoaded = true\n      if (self.header.orientation != 'rowwise' && self.header.orientation != 'columnwise') {\n        self.errorLoading({\n          orientation: self.header.orientation,\n          toString: function() {\n            return (\n              'Could not load ' +\n              this.url +\n              ' due to unsupported file orientation. Orientation: ' +\n              this.orientation +\n              '. Supported orientations: rowwise, columnwise.'\n            )\n          },\n        })\n        return true\n      }\n\n      // Empty tile, stop parsing.\n      if (!self.rowLen) {\n        self.allLoaded()\n        return true\n      }\n    }\n    if (self.header.orientation == 'rowwise') {\n      var result = {}\n      for (; self.offset + self.rowLen <= length; self.rowidx++) {\n        var row = {}\n        for (var colidx = 0; colidx < self.header.cols.length; colidx++) {\n          var col = self.header.cols[colidx]\n          var val = dataView[col.typespec.getter](self.offset, true)\n          row[col.name] = val\n          self.offset += col.typespec.size\n        }\n        // self.rowLoaded(row);\n\n        result[col.name] = row\n      }\n      if (self.rowidx == self.header.length) {\n        // self.allLoaded();\n        this.resolve(result)\n      } else {\n        // self.batchLoaded();\n      }\n    } else if (self.header.orientation == 'columnwise') {\n      var colValues = null\n      var result = {}\n      if (length >= self.offset + self.header.length * self.rowLen) {\n        for (var colidx = 0; colidx < self.header.cols.length; colidx++) {\n          var col = self.header.cols[colidx]\n\n          colValues = new (eval(col.typespec.array))(\n            response.slice(self.offset, self.offset + col.typespec.size * self.header.length)\n          )\n          self.offset += self.header.length * col.typespec.size\n\n          result[col.name] = colValues\n        }\n\n        // self.allLoaded();\n        this.resolve(result)\n        return true\n      }\n    }\n  }\n}\n\nexport default PelagosClient\n","import PropTypes from 'prop-types'\n\nexport const trackTypes = {\n  id: PropTypes.string.isRequired,\n  url: PropTypes.string,\n  data: PropTypes.object,\n  color: PropTypes.string,\n  type: PropTypes.oneOf(['geojson', 'pelagos', undefined]),\n  layerTemporalExtents: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.number)),\n  fitBoundsOnLoad: PropTypes.bool,\n}\n","import PropTypes from 'prop-types'\n\nexport const heatmapLayerTypes = {\n  id: PropTypes.string.isRequired,\n  tilesetId: PropTypes.string,\n  subtype: PropTypes.string,\n  visible: PropTypes.bool,\n  hue: PropTypes.number,\n  opacity: PropTypes.number,\n  filters: PropTypes.arrayOf(\n    PropTypes.shape({\n      // hue overrides layer hue if set\n      hue: PropTypes.number,\n      // filterValues is a dictionary in which each key is a filterable field,\n      // and values is an array of all possible values (OR filter)\n      // ie: filterValues: { category: [5, 6] }\n      filterValues: PropTypes.object,\n    })\n  ),\n  header: PropTypes.shape({\n    endpoints: PropTypes.object,\n    colsByName: PropTypes.object,\n    temporalExtents: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.number)),\n    temporalExtentsLess: PropTypes.bool,\n  }).isRequired,\n  interactive: PropTypes.bool,\n}\n\nexport const basemapLayerTypes = {\n  id: PropTypes.string,\n  visible: PropTypes.bool,\n}\n\nexport const staticLayerTypes = {\n  id: PropTypes.string.isRequired,\n  // TODO MAP MODULE Is that needed and if so why\n  visible: PropTypes.bool,\n  selected: PropTypes.bool,\n  selectedFeatures: PropTypes.shape({\n    field: PropTypes.string,\n    values: PropTypes.arrayOf(PropTypes.string),\n  }),\n  highlighted: PropTypes.bool,\n  higlightedFeatures: PropTypes.shape({\n    field: PropTypes.string,\n    values: PropTypes.arrayOf(PropTypes.string),\n  }),\n  opacity: PropTypes.number,\n  color: PropTypes.string,\n  showLabels: PropTypes.bool,\n  interactive: PropTypes.bool,\n  filters: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.string)),\n  isCustom: PropTypes.bool,\n  subtype: PropTypes.oneOf([undefined, 'geojson', 'raster']),\n  url: PropTypes.string,\n  data: PropTypes.object,\n  gl: PropTypes.object,\n}\n","import PropTypes from 'prop-types'\n\nexport const popupTypes = {\n  content: PropTypes.node,\n  latitude: PropTypes.number.isRequired,\n  longitude: PropTypes.number.isRequired,\n}\n\nexport const viewportTypes = {\n  zoom: PropTypes.number,\n  center: PropTypes.arrayOf(PropTypes.number),\n}\n","// Application settings\nexport const TIMELINE_STEP = 24 * 60 * 60 * 1000 // 1 day\nexport const MIN_FRAME_LENGTH_MS = TIMELINE_STEP // 1 day\n\n// vessels rendering\n// from this zoom level and above, render using circle style instead of heatmap\nexport const VESSELS_RADIAL_GRADIENT_STYLE_ZOOM_THRESHOLD = 6\n// the base radius, it can only be scaled down by the radius factor calculated on the dataset\nexport const VESSELS_BASE_RADIUS = 8\n// in heatmap style, defines how 'blurry' a point will look. Higher = less blur\nexport const VESSELS_HEATMAP_BLUR_FACTOR = 0.15\n\nexport const ACTIVITY_HIGHLIGHT_HUE = 312\n\nexport const VESSELS_HEATMAP_DIMMING_ALPHA = 0.5\n\nexport const TRACKS_DOTS_STYLE_ZOOM_THRESHOLD = 2\n\nexport const MAX_SPRITES_PER_LAYER = 200000\n\n// interaction\n// radius of vessels lookup in pixels,\n// ie how large the clicked region should be for including vessels\nexport const VESSEL_CLICK_TOLERANCE_PX = 10\n\nexport const CLUSTER_CLICK_ZOOM_INCREMENT = 1\n\nexport const MIN_ZOOM_LEVEL = 1\n// user can zoom up to this z level, but it doesn't guarantee availability of tiles\nexport const MAX_ZOOM_LEVEL = 14\n\n// data\n// Limit tile loading for activity layers up to this z level.\n// Beyond, layer is still displayed but with coarse data from the lower zoom level\nexport const ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING = 10\n\n// Sets what should be the discrete zoom level to load tiles, from a non-discrete\n// viewport zoom values. For instance, a values of 0.5 will load z 3 with a viewport\n// z of 2 (ceiling of 2 + 0.5)\n// this has a direct impact on the number of points displayed on the map, thus on the\n// performance of the app.\nexport const TILES_LOAD_ZOOM_OFFSET = 0.5\n\nexport const STATIC_LAYERS_CARTO_ENDPOINT =\n  'https://carto.globalfishingwatch.org/user/admin/api/v1/map?config=$MAPCONFIG'\nexport const STATIC_LAYERS_CARTO_TILES_ENDPOINT =\n  'https://carto.globalfishingwatch.org/user/admin/api/v1/map/$LAYERGROUPID/{z}/{x}/{y}.mvt'\n\nexport const TRACKS_LAYER_IN_FRONT_OF_GROUP = 'temporal'\n\nexport const TILES_URL_NEEDING_AUTHENTICATION = 'dot-world-fishing'\n","export const INIT_MODULE = 'INIT_MODULE'\nexport const SET_TEMPORAL_EXTENT = 'SET_TEMPORAL_EXTENT'\nexport const SET_HIGHLIGHT_TEMPORAL_EXTENT = 'SET_HIGHLIGHT_TEMPORAL_EXTENT'\nexport const START_LOADER = 'START_LOADER'\nexport const COMPLETE_LOADER = 'COMPLETE_LOADER'\nexport const SET_MODULE_CURSOR = 'SET_MODULE_CURSOR'\n\nexport const initModule = (props) => (dispatch) => {\n  dispatch({\n    type: INIT_MODULE,\n    payload: props,\n  })\n}\n\nexport const startLoader = (dispatch, state, loaderId) => {\n  const timestamp = new Date().getTime()\n  const generatedLoaderId = loaderId !== undefined ? `${loaderId}_${timestamp}` : timestamp\n  dispatch({\n    type: START_LOADER,\n    payload: generatedLoaderId,\n  })\n  if (state.map.module.onLoadStart !== undefined) {\n    state.map.module.onLoadStart()\n  }\n  return loaderId\n}\n\nexport const completeLoader = (loaderId) => (dispatch, getState) => {\n  dispatch({\n    type: COMPLETE_LOADER,\n    payload: loaderId,\n  })\n  const state = getState()\n  const loaders = state.map.module.loaders\n  if (!loaders.length && state.map.module.onLoadComplete !== undefined) {\n    state.map.module.onLoadComplete()\n  }\n}\n\nexport const onViewportChange = (interactionState) => (dispatch, getState) => {\n  const state = getState()\n  const callback = state.map.module.onViewportChange\n\n  if (callback === undefined) {\n    return\n  }\n  const viewport = state.map.viewport\n\n  callback({\n    interactionState,\n    zoom: viewport.viewport.zoom,\n    center: [viewport.viewport.latitude, viewport.viewport.longitude],\n    bounds: viewport.bounds,\n    canZoomIn: viewport.canZoomIn,\n    canZoomOut: viewport.canZoomOut,\n    mouseLatLong: viewport.mouseLatLong,\n  })\n}\n\nexport const setTemporalExtent = (temporalExtent) => ({\n  type: SET_TEMPORAL_EXTENT,\n  payload: temporalExtent,\n})\n\nexport const setHighlightTemporalExtent = (highlightTemporalExtent) => ({\n  type: SET_HIGHLIGHT_TEMPORAL_EXTENT,\n  payload: highlightTemporalExtent,\n})\n\nexport const closePopup = () => (dispatch, getState) => {\n  const state = getState()\n  if (state.map.module.onClosePopup !== undefined) {\n    state.map.module.onClosePopup()\n  }\n}\n\nexport const setCursor = (cursor) => ({\n  type: SET_MODULE_CURSOR,\n  payload: cursor,\n})\n","export const getTemporalExtent = (state) => state.map.module.temporalExtent\n\nexport const getHighlightTemporalExtent = (state) => state.map.module.highlightTemporalExtent\n","import { createSelector } from 'reselect'\nimport { getTemporalExtent, getHighlightTemporalExtent } from '../module/module.selectors'\n\nexport const getTracksData = (state) => state.map.tracks.data\nexport const getGeojsonTracks = createSelector(\n  getTracksData,\n  (tracks) => tracks.filter((t) => t.type === 'geojson')\n)\nexport const getGeojsonTracksReady = createSelector(\n  getGeojsonTracks,\n  (tracks) => tracks.filter((t) => t.data !== undefined)\n)\n\nconst mergeStyles = (style1, style2) => ({\n  sources: { ...style1.sources, ...style2.sources },\n  layers: [...style1.layers, ...style2.layers],\n})\n\nconst filterGeojsonByTimerange = (geojson, { start, end }) => {\n  if (!geojson || !geojson.features) return null\n  const featuresFiltered = geojson.features.reduce((filteredFeatures, feature) => {\n    const hasTimes =\n      feature.properties &&\n      feature.properties.coordinateProperties &&\n      feature.properties.coordinateProperties.times &&\n      feature.properties.coordinateProperties.times.length > 0\n    if (hasTimes) {\n      const filtered = feature.geometry.coordinates.reduce(\n        (filteredCoordinates, coordinate, index) => {\n          const timeCoordinate = feature.properties.coordinateProperties.times[index]\n          const isInTimeline = timeCoordinate >= start && timeCoordinate <= end\n          if (isInTimeline) {\n            filteredCoordinates.coordinates.push(coordinate)\n            filteredCoordinates.times.push(timeCoordinate)\n          }\n          return filteredCoordinates\n        },\n        { coordinates: [], times: [] }\n      )\n      if (!filtered.coordinates.length) return filteredFeatures\n\n      const filteredFeature = {\n        ...feature,\n        geometry: {\n          ...feature.geometry,\n          coordinates: filtered.coordinates,\n        },\n        properties: {\n          ...feature.properties,\n          coordinateProperties: {\n            times: filtered.times,\n          },\n        },\n      }\n      filteredFeatures.push(filteredFeature)\n    }\n    return filteredFeatures\n  }, [])\n  const geojsonFiltered = {\n    ...geojson,\n    features: featuresFiltered,\n  }\n  return geojsonFiltered\n}\n\nconst getFullTracksStyles = createSelector(\n  [getTemporalExtent, getGeojsonTracksReady],\n  (temporalExtent, tracks) => {\n    const hasTemporalExtent = temporalExtent && temporalExtent.length > 0\n    const hasTracks = tracks && tracks.length > 0\n    if (!hasTemporalExtent || !hasTracks) return null\n\n    const timerange = {\n      start: temporalExtent[0].getTime(),\n      end: temporalExtent[1].getTime(),\n    }\n    const styles = tracks.reduce(\n      (acc, track) => {\n        if (!track.data) return acc\n\n        const source = `${track.id}Track`\n        const style = {\n          sources: {\n            [source]: {\n              type: 'geojson',\n              data: filterGeojsonByTimerange(track.data, timerange),\n            },\n          },\n          layers: [\n            {\n              id: `${track.id}Lines`,\n              source,\n              type: 'line',\n              paint: {\n                'line-width': 1,\n                'line-color': track.color,\n              },\n            },\n            {\n              id: `${track.id}Points`,\n              source,\n              type: 'circle',\n              filter: ['match', ['geometry-type'], ['', 'Point'], true, false],\n              paint: {\n                'circle-radius': 4,\n                'circle-color': track.color,\n              },\n            },\n          ],\n        }\n        return mergeStyles(acc, style)\n      },\n      { sources: {}, layers: [] }\n    )\n    return styles\n  }\n)\n\nconst getHighlightedTrackStyles = createSelector(\n  [getHighlightTemporalExtent, getGeojsonTracksReady],\n  (highlightTemporalExtent, tracks) => {\n    const hasTemporalExtent = highlightTemporalExtent && highlightTemporalExtent.length > 0\n    const hasTracks = tracks && tracks.length > 0\n    if (!hasTemporalExtent || !hasTracks) return null\n\n    const timerange = {\n      start: highlightTemporalExtent[0].getTime(),\n      end: highlightTemporalExtent[1].getTime(),\n    }\n    const styles = tracks.reduce(\n      (acc, track) => {\n        if (!track.data) return acc\n\n        const source = `${track.id}HighlightedTrack`\n        const style = {\n          sources: {\n            [source]: {\n              type: 'geojson',\n              data: filterGeojsonByTimerange(track.data, timerange),\n            },\n          },\n          layers: [\n            {\n              id: `${track.id}HighlightedLines`,\n              source,\n              type: 'line',\n              paint: {\n                'line-width': 1,\n                'line-color': '#fff',\n              },\n            },\n          ],\n        }\n        return mergeStyles(acc, style)\n      },\n      { sources: {}, layers: [] }\n    )\n    return styles\n  }\n)\n\nexport const getTracksStyles = createSelector(\n  [getFullTracksStyles, getHighlightedTrackStyles],\n  (trackStyles, highlightedTrackStyles) => {\n    if (!highlightedTrackStyles) return trackStyles\n    return mergeStyles(trackStyles, highlightedTrackStyles)\n  }\n)\n","export const GL_TRANSPARENT = 'rgba(0,0,0,0)'\n\nexport const TRANSITION_TYPE = {\n  ZOOM: 'ZOOM',\n}\n\nexport const ENCOUNTERS = 'Encounters'\n\nexport const BRUSH_RENDERING_STYLE = {\n  NORMAL: 0,\n  BULLSEYE: 2,\n}\n\nexport const BRUSH_ZOOM_RENDERING_STYLE = {\n  RADIAL_GRADIENT: 0,\n  CIRCLE: 1,\n}\n\nexport const POLYGON_LAYERS_AREA = 'POLYGON_LAYERS_AREA'\n\nexport const CUSTOM_LAYERS_SUBTYPES = {\n  geojson: 'geojson',\n  raster: 'raster',\n}\n","import template from 'lodash/template'\nimport templateSettings from 'lodash/templateSettings'\n\nexport default (urlTemplate, urlParams) => {\n  templateSettings.interpolate = /{{([\\s\\S]+?)}}/g\n  const urlTemplateCompiled = template(urlTemplate)\n  return urlTemplateCompiled(urlParams)\n}\n","import pull from 'lodash/pull'\nimport uniq from 'lodash/uniq'\nimport sumBy from 'lodash/sumBy'\nimport { lngLatToWorld } from 'viewport-mercator-project'\nimport convert from '@globalfishingwatch/map-convert'\nimport buildEndpoint from './buildEndpoint'\nimport PelagosClient from '../lib/pelagosClient'\n\n/**\n * Generates the URLs to load vessel track data for a tile\n *\n * @param {string} tilesetUrl       the tileset base URL\n * @param {array} temporalExtents   all tileset temporal extents\n * @param {object} params           - tileCoordinates: this tiles tile coordinates (zoom, x, y). Will default to 0,0,0\n *                                  - temporalExtentsIndices: restrict to these temporalExtents indices\n * @returns {Array}                 an array of URLs for this tile\n */\nconst getTemporalTileURLs = (urlTemplate, temporalExtents, params = {}) => {\n  const urls = []\n\n  ;(temporalExtents || [null]).forEach((extent, index) => {\n    const urlParams = {}\n    if (extent !== null && params.temporalExtentsLess !== true) {\n      urlParams.startTimeISO = new Date(extent[0]).toISOString()\n      urlParams.endTimeISO = new Date(extent[1]).toISOString()\n    }\n    if (params.tileCoordinates) {\n      urlParams.x = params.tileCoordinates.x\n      urlParams.y = params.tileCoordinates.y\n      urlParams.z = params.tileCoordinates.zoom\n    }\n\n    const url = buildEndpoint(urlTemplate, urlParams)\n\n    if (\n      params.temporalExtentsLess === true ||\n      !params.temporalExtentsIndices ||\n      params.temporalExtentsIndices.indexOf(index) > -1\n    ) {\n      urls.push(url)\n    }\n  })\n  return urls\n}\n\n/**\n * See getTemporalTileURLs.\n */\nexport const getTilePromises = (tilesetUrl, token, temporalExtents, params = {}) => {\n  const promises = []\n  const urls = getTemporalTileURLs(tilesetUrl, temporalExtents, params)\n  for (let urlIndex = 0, length = urls.length; urlIndex < length; urlIndex++) {\n    promises.push(new PelagosClient().obtainTile(urls[urlIndex], token))\n  }\n\n  return promises\n}\n\nexport const getCleanVectorArrays = (rawTileData) =>\n  rawTileData.filter((vectorArray) => vectorArray !== null)\n\n/**\n * As data will come in multiple arrays (1 per API query/year basically), they need to be merged here\n *\n * @param cleanVectorArrays an array of objects containing a Float32Array for each vessel param (lat, lon, weight...)\n * @param columns the keys to pick on the vectorArrays (lat, lon, weight, etc)\n * @returns an object containing a Float32Array for each API_RETURNED_KEY (lat, lon, weight, etc)\n */\nexport const groupData = (cleanVectorArrays, columns) => {\n  const data = {}\n\n  const totalVectorArraysLength = sumBy(cleanVectorArrays, (a) => a.longitude.length)\n\n  const filteredColumns = columns.filter((column) => {\n    if (cleanVectorArrays[0] && cleanVectorArrays[0][column] === undefined) {\n      console.warn(`column ${column} is present in layerHeader.colsByName but not in tile data`)\n      return false\n    }\n    return true\n  })\n\n  filteredColumns.forEach((key) => {\n    data[key] = new Float32Array(totalVectorArraysLength)\n  })\n\n  let currentArray\n  let cumulatedOffsets = 0\n\n  const appendValues = (key) => {\n    data[key].set(currentArray[key], cumulatedOffsets)\n  }\n\n  for (let index = 0, length = cleanVectorArrays.length; index < length; index++) {\n    currentArray = cleanVectorArrays[index]\n    filteredColumns.forEach(appendValues)\n    cumulatedOffsets += currentArray.longitude.length\n  }\n  return data\n}\n\n/**\n * Converts Vector Array data to Playback format and stores it locally.\n * The data structure is an array indexed by a time unit, ie a set of points every day\n * This preprocessing step allows playback to play smoothly as the necessary conversions and data structure set up\n * is done once (after tile has been loaded)\n *\n * @param data the source data before indexing by day, an object containing\n *  - a vector (Float32Array) for each header's column in the case of Pelagos tiles\n *  - an array of points int the case of PBF tiles\n * @param colsByName the columns present on the dataset, determined by tileset headers\n * @param tileCoordinates x, y, z\n * @param prevPlaybackData an optional previously loaded tilePlaybackData array (when adding time range)\n */\nexport const getTilePlaybackData = (data, colsByName, tileCoordinates, prevPlaybackData) => {\n  const tilePlaybackData = prevPlaybackData === undefined ? [] : prevPlaybackData\n\n  const zoom = tileCoordinates.zoom\n  const zoomFactorRadius = convert.getZoomFactorRadius(zoom)\n  const zoomFactorRadiusRenderingMode = convert.getZoomFactorRadiusRenderingMode(zoom)\n  const zoomFactorOpacity = convert.getZoomFactorOpacity(zoom)\n\n  // store all available columns as object keys\n  const columns = {}\n  const columnsArr = Object.keys(colsByName)\n  columnsArr.forEach((c) => {\n    columns[c] = true\n  })\n\n  // columns specified by layer header columns\n  let storedColumns = [].concat(columnsArr)\n  if (columns.sigma === true) storedColumns.push('radius')\n  if (columns.weight === true) storedColumns.push('opacity')\n  if (columns.longitude === true) {\n    storedColumns.push('worldX')\n    storedColumns.push('worldY')\n  }\n  if (columns.id === true) {\n    storedColumns.push('series')\n  }\n\n  // omit values that will be transformed before being stored to playback data (ie lat -> worldY)\n  // only if hidden: true flag is set on header\n  ;['latitude', 'longitude', 'datetime'].forEach((col) => {\n    if (colsByName[col] === undefined || colsByName[col].hidden === true) {\n      pull(storedColumns, col)\n    }\n  })\n  // always pull sigma and weight\n  pull(storedColumns, 'sigma', 'weight')\n  storedColumns = uniq(storedColumns)\n\n  const numPoints = data.latitude.length\n\n  const newFrames = {}\n  const timeIndexes = []\n  for (let index = 0, length = numPoints; index < length; index++) {\n    let point = {}\n    columnsArr.forEach((c) => {\n      point[c] = data[c][index]\n    })\n\n    const timeIndex = columns.timeIndex\n      ? point.timeIndex\n      : convert.getOffsetedTimeAtPrecision(point.datetime)\n\n    // FIXME: this should not be done when headers declare worldX/Y -  if (!columns.worldX) {\n    const [worldX, worldY] = lngLatToWorld([point.longitude, point.latitude], 1)\n    point.worldX = worldX\n    point.worldY = worldY\n\n    if (columns.sigma) {\n      point.radius = convert.sigmaToRadius(\n        point.sigma,\n        zoomFactorRadiusRenderingMode,\n        zoomFactorRadius\n      )\n    }\n    if (columns.weight) {\n      point.opacity = convert.weightToOpacity(point.weight, zoomFactorOpacity)\n    }\n    if (columns.id) {\n      point.series = point.id\n    }\n\n    if (!newFrames[timeIndex]) {\n      timeIndexes.push(timeIndex)\n      const frame = {}\n      storedColumns.forEach((column) => {\n        frame[column] = [point[column]]\n      })\n      newFrames[timeIndex] = frame\n      continue\n    }\n    const frame = newFrames[timeIndex]\n    storedColumns.forEach((column) => {\n      frame[column].push(point[column])\n    })\n  }\n\n  // finally, copy new frames to the overall tilePlaybackData object\n  // frames previously existing here will be overwritten\n  timeIndexes.forEach((timeIndex) => {\n    tilePlaybackData[timeIndex] = newFrames[timeIndex]\n  })\n  return tilePlaybackData\n}\n\nexport const addTracksPointsRenderingData = (data) => {\n  data.hasFishing = []\n  data.worldX = []\n  data.worldY = []\n\n  for (let index = 0, length = data.weight.length; index < length; index++) {\n    const [worldX, worldY] = lngLatToWorld([data.longitude[index], data.latitude[index]], 1)\n    data.worldX[index] = worldX\n    data.worldY[index] = worldY\n    data.hasFishing[index] = data.weight[index] > 0\n  }\n  return data\n}\n\n/**\n * A simplified version of getTilePlaybackData for tracks\n * Converts Vector Array data to Playback format (organized by days) and stores it locally\n * @param vectorArray the source data before indexing by day\n */\nexport const getTracksPlaybackData = (vectorArray) => {\n  const playbackData = []\n\n  for (let index = 0, length = vectorArray.series.length; index < length; index++) {\n    const datetime = vectorArray.datetime[index]\n    const timeIndex = convert.getOffsetedTimeAtPrecision(datetime)\n\n    if (!playbackData[timeIndex]) {\n      const frame = {\n        worldX: [vectorArray.worldX[index]],\n        worldY: [vectorArray.worldY[index]],\n        series: [vectorArray.series[index]],\n        hasFishing: [vectorArray.hasFishing[index]],\n      }\n      playbackData[timeIndex] = frame\n      continue\n    }\n    const frame = playbackData[timeIndex]\n    frame.worldX.push(vectorArray.worldX[index])\n    frame.worldY.push(vectorArray.worldY[index])\n    frame.series.push(vectorArray.series[index])\n    frame.hasFishing.push(vectorArray.hasFishing[index])\n  }\n  return playbackData\n}\n\nexport const vesselSatisfiesFilters = (frame, index, filterValues) => {\n  const satisfiesFilters = Object.keys(filterValues).every((field) => {\n    if (frame[field] === undefined) {\n      // this field is not available on this layer. This can happen in an edge case described\n      // here: https://github.com/GlobalFishingWatch/map-client/issues/661#issuecomment-334496469\n      return false\n    }\n    return filterValues[field].indexOf(frame[field][index]) > -1\n  })\n  return satisfiesFilters\n}\n\nconst vesselSatisfiesAllFilters = (frame, index, filters) => {\n  const satisfiesAllFilters = filters\n    .filter((f) => f.pass !== true)\n    .some((filter) => vesselSatisfiesFilters(frame, index, filter.filterValues))\n  return satisfiesAllFilters\n}\n\nexport const selectVesselsAt = (tileData, tileQuery, startIndex, endIndex, currentFilters) => {\n  const vessels = []\n\n  const { worldX, worldY, toleranceRadiusInWorldUnits } = tileQuery\n\n  for (let f = startIndex; f < endIndex; f++) {\n    const frame = tileData[f]\n    if (frame === undefined) continue\n    for (let i = 0; i < frame.worldX.length; i++) {\n      const wx = frame.worldX[i]\n      const wy = frame.worldY[i]\n\n      if (\n        (!currentFilters.length || vesselSatisfiesAllFilters(frame, i, currentFilters)) &&\n        wx >= worldX - toleranceRadiusInWorldUnits &&\n        wx <= worldX + toleranceRadiusInWorldUnits &&\n        wy >= worldY - toleranceRadiusInWorldUnits &&\n        wy <= worldY + toleranceRadiusInWorldUnits\n      ) {\n        const vessel = {}\n\n        Object.keys(frame).forEach((key) => {\n          vessel[key] = frame[key][i]\n        })\n        vessel.timeIndex = f\n        vessels.push(vessel)\n      }\n    }\n  }\n  return vessels\n}\n\n/*\nexport const getHistogram = (tiles, propName = 'weight') => {\n  let data = tiles\n    .filter(tile => tile.ready)\n    .map(tile => tile.data\n      .map(frame => frame[propName]));\n  data = flattenDeep(data);\n  if (data.length) {\n    const bins = d3.histogram().thresholds(d3.thresholdScott)(data);\n    const x = d3.scaleLinear().domain([0, d3.max(bins, d => d.length)]).range([0, 50]);\n    console.table(bins.filter(bin => bin.length).map((bin) => {\n      const binMin = d3.min(bin).toLocaleString({ maximumFractionDigits: 2 });\n      const binMax = d3.max(bin).toLocaleString({ maximumFractionDigits: 2 });\n      return {\n        range: [binMin, binMax].join('﹣'),\n        bars: Array(Math.round(x(bin.length))).join('█'),\n        num: bin.length\n      };\n    }));\n  }\n};\n*/\n","import tilecover from '@mapbox/tile-cover/index'\nimport debounce from 'lodash/debounce'\nimport { PerspectiveMercatorViewport } from 'viewport-mercator-project'\nimport { ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING, TILES_LOAD_ZOOM_OFFSET } from '../config'\nimport {\n  getTile,\n  releaseTiles,\n  highlightVesselFromHeatmap,\n  updateLoadedTiles,\n} from './heatmap.actions'\n\nexport const SET_CURRENTLY_VISIBLE_TILES = 'SET_CURRENTLY_VISIBLE_TILES'\nexport const SET_CURRENTLY_LOADED_TILES = 'SET_CURRENTLY_LOADED_TILES'\nexport const SET_CURRENTLY_SWAPPED_TILE_UIDS = 'SET_CURRENTLY_SWAPPED_TILE_UIDS'\nexport const MARK_TILES_UIDS_AS_LOADED = 'MARK_TILES_UIDS_AS_LOADED'\nexport const RELEASE_MARKED_TILES_UIDS = 'RELEASE_MARKED_TILES_UIDS'\n\n// restrict tilecover to a single zoom level\n// could be customized to load less or more detailed tiles\nconst getTilecoverLimits = (viewportZoom) => {\n  let zoom = Math.ceil(viewportZoom + TILES_LOAD_ZOOM_OFFSET)\n  let tilesAvailable = true\n  if (zoom > ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING) {\n    zoom = ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING\n    tilesAvailable = false\n  }\n  return {\n    min_zoom: zoom,\n    max_zoom: zoom,\n    tilesAvailable,\n  }\n}\n\nconst flushToReleaseTiles = () => (dispatch, getState) => {\n  const state = getState()\n  const currentToLoadTileUids = state.map.heatmapTiles.currentToLoadTileUids\n  // console.log('Tiles left to load: ', currentToLoadTileUids);\n\n  // Tiles are released only when all to-load tiles have finished loading\n  // this is to ensure smooth visual transitions between zoom levels\n  if (!currentToLoadTileUids.length) {\n    const currentTilesToReleaseUids = state.map.heatmapTiles.currentToReleaseTileUids\n    // console.log('no more tiles to load, releasing ', currentTilesToReleaseUids);\n    dispatch(releaseTiles(currentTilesToReleaseUids))\n    dispatch({\n      type: RELEASE_MARKED_TILES_UIDS,\n    })\n  }\n}\n\nexport const markTileAsLoaded = (tileUids) => (dispatch) => {\n  dispatch({\n    type: MARK_TILES_UIDS_AS_LOADED,\n    payload: tileUids,\n  })\n  // console.log(tileUids, 'have finished loading');\n  dispatch(flushToReleaseTiles())\n}\n\nconst flushTileState = (forceLoadingAllVisibleTiles = false) => (dispatch, getState) => {\n  const state = getState()\n  const currentVisibleTiles = state.map.heatmapTiles.currentVisibleTiles\n  let tilesToLoad = []\n  const tilesToReleaseUids = []\n\n  if (forceLoadingAllVisibleTiles === true) {\n    tilesToLoad = currentVisibleTiles\n  } else {\n    const currentLoadedTiles = state.map.heatmapTiles.currentLoadedTiles\n\n    currentVisibleTiles.forEach((visibleTile) => {\n      if (currentLoadedTiles.find((t) => t.uid === visibleTile.uid) === undefined) {\n        tilesToLoad.push(visibleTile)\n      }\n    })\n\n    currentLoadedTiles.forEach((loadedTile) => {\n      if (currentVisibleTiles.find((t) => t.uid === loadedTile.uid) === undefined) {\n        tilesToReleaseUids.push(loadedTile.uid)\n      }\n    })\n  }\n\n  const tilesToLoadUids = tilesToLoad.map((t) => t.uid)\n  // console.log('force loading:', forceLoadingAllVisibleTiles)\n  // console.log('visible', currentVisibleTiles.map(t => t.uid))\n  // console.log('load', tilesToLoadUids)\n  // console.log('release', tilesToReleaseUids)\n  // console.log('----')\n\n  tilesToLoad.forEach((tile) => {\n    dispatch(getTile(tile))\n  })\n  dispatch({\n    type: SET_CURRENTLY_LOADED_TILES,\n    payload: currentVisibleTiles,\n  })\n\n  dispatch({\n    type: SET_CURRENTLY_SWAPPED_TILE_UIDS,\n    payload: {\n      tilesToLoadUids,\n      tilesToReleaseUids,\n    },\n  })\n\n  dispatch(updateLoadedTiles())\n  dispatch(flushToReleaseTiles())\n}\n\nconst _debouncedFlushState = (dispatch) => {\n  dispatch(flushTileState())\n}\nconst debouncedFlushState = debounce(_debouncedFlushState, 500)\n\nexport const updateHeatmapTilesFromViewport = (forceLoadingAllVisibleTiles = false) => (\n  dispatch,\n  getState\n) => {\n  // if in transition, skip loading/releasing\n  // else\n  //   collect all tiles in viewport\n  //   save them to reducer: currentVisibleTiles\n  // if not zooming: flush immediately\n  //   if forceLoadingAllVisiblelTiles\n  //     get tiles from currentVisibleTiles\n  //   else\n  //     get tiles from currentVisibleTiles\n  //     make delta with currentLoadedTiles\n  //     get tiles from delta+\n  //     release tiles from delta-\n  //   save to reducer: currentVisibleTiles -> currentLoadedTiles\n  // if zooming: debounced flush to avoid \"tile spam\"\n  const mapViewport = getState().map.viewport\n  const viewport = mapViewport.viewport\n\n  // do not allow any tile update during transitions (currently only zoom)\n  // wait for the end of the transition to look at viewport and load matching tiles\n  if (!viewport.width || !viewport.height || mapViewport.currentTransition !== null) {\n    return\n  }\n\n  // instanciate a viewport instance to get lat/lon from screen top left/ bottom right bounds\n  const boundsViewport = new PerspectiveMercatorViewport(viewport)\n  const bounds = [\n    boundsViewport.unproject([0, 0]),\n    boundsViewport.unproject([viewport.width, viewport.height]),\n  ]\n\n  const [wn, es] = bounds\n  const [w, s, e, n] = [wn[0], es[1], es[0], wn[1]]\n  const boundsPolygonsCoordinates = []\n\n  const limits = getTilecoverLimits(viewport.zoom)\n  if (limits.tilesAvailable === false && forceLoadingAllVisibleTiles !== true) {\n    return\n  }\n\n  if (e > 180 || w < -180) {\n    // deal with the antimeridian situation by splitting the bounds polygon into two polygons\n    const w1 = e > 180 ? w : w + 360\n    const e1 = 180 - 0.001\n    const w2 = -180\n    const e2 = e > 180 ? e - 360 : e\n    boundsPolygonsCoordinates.push([[[w1, n], [e1, n], [e1, s], [w1, s], [w1, n]]])\n    boundsPolygonsCoordinates.push([[[w2, n], [e2, n], [e2, s], [w2, s], [w2, n]]])\n  } else {\n    boundsPolygonsCoordinates.push([[[w, n], [e, n], [e, s], [w, s], [w, n]]])\n  }\n\n  const geom = {\n    type: 'MultiPolygon',\n    coordinates: boundsPolygonsCoordinates,\n  }\n\n  // using tilecover, get xyz tile coords as well as quadkey indexes (named uid through the app)\n  const viewportTilesCoords = tilecover.tiles(geom, limits)\n  const viewportTilesIndexes = tilecover.indexes(geom, limits)\n  const visibleTiles = []\n\n  viewportTilesCoords.forEach((coords, i) => {\n    const uid = viewportTilesIndexes[i]\n    const zoom = coords[2]\n    if (zoom >= 2) {\n      visibleTiles.push({\n        tileCoordinates: {\n          x: coords[0],\n          y: coords[1],\n          zoom: coords[2],\n        },\n        uid,\n      })\n    }\n  })\n\n  dispatch({\n    type: SET_CURRENTLY_VISIBLE_TILES,\n    payload: visibleTiles,\n  })\n\n  const isMouseWheelZooming = mapViewport.prevZoom !== viewport.zoom\n\n  if (isMouseWheelZooming === false) {\n    dispatch(flushTileState(forceLoadingAllVisibleTiles))\n  } else {\n    debouncedFlushState(dispatch)\n  }\n}\n\nexport const queryHeatmapVessels = (coords, temporalExtentIndexes) => (dispatch, getState) => {\n  // use tilecover to get what tile quadkey/uid \"belongs\" to the point\n  const geom = {\n    type: 'Point',\n    coordinates: [coords.longitude, coords.latitude],\n  }\n  const zoom = getState().map.viewport.viewport.zoom\n\n  // get quadkey for tile at current zoom level, but also neighbouring zoom levels,\n  // in case current zoom level tiles has not been loaded yet\n  const uids = [zoom, zoom - 1, zoom + 1]\n    .map((z) => getTilecoverLimits(z))\n    .map((limits) => tilecover.indexes(geom, limits))\n    .map((indexes) => indexes[0])\n\n  const query = {\n    ...coords,\n    uids,\n  }\n\n  // console.log(query);\n  dispatch(highlightVesselFromHeatmap(query, temporalExtentIndexes))\n}\n","import difference from 'lodash/difference'\nimport uniq from 'lodash/uniq'\nimport uniqBy from 'lodash/uniqBy'\nimport {\n  getTilePromises,\n  getCleanVectorArrays,\n  groupData,\n  getTilePlaybackData,\n  selectVesselsAt,\n} from '../utils/heatmapTileData'\nimport { markTileAsLoaded } from './heatmapTiles.actions'\nimport { startLoader, completeLoader } from '../module/module.actions'\n\nexport const ADD_HEATMAP_LAYER = 'ADD_HEATMAP_LAYER'\nexport const UPDATE_HEATMAP_LAYER_STYLE = 'UPDATE_HEATMAP_LAYER_STYLE'\nexport const ADD_REFERENCE_TILE = 'ADD_REFERENCE_TILE'\nexport const HIGHLIGHT_VESSELS = 'HIGHLIGHT_VESSELS'\nexport const INIT_HEATMAP_LAYERS = 'INIT_HEATMAP_LAYERS'\nexport const REMOVE_HEATMAP_LAYER = 'REMOVE_HEATMAP_LAYER'\nexport const UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES =\n  'UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES'\nexport const UPDATE_HEATMAP_TILE = 'UPDATE_HEATMAP_TILE'\nexport const RELEASE_HEATMAP_TILES = 'RELEASE_HEATMAP_TILES'\nexport const UPDATE_LOADED_TILES = 'UPDATE_LOADED_TILES'\nexport const HIGHLIGHT_CLICKED_VESSEL = 'HIGHLIGHT_CLICKED_VESSEL'\nexport const CLEAR_HIGHLIGHT_CLICKED_VESSEL = 'CLEAR_HIGHLIGHT_CLICKED_VESSEL'\n\n/**\n * getTemporalExtentsVisibleIndices - Compares timebar outer extent with temporal extents present on the layer header\n * @param  {array} loadTemporalExtent Current timebar outer extent\n * @param  {array} layerTemporalExtents Temporal extent present on the layer's header (an array of extent arrays)\n * @return {array}                    Indices of the layer's temporal extents that should be visible\n */\nfunction getTemporalExtentsVisibleIndices(loadTemporalExtent, layerTemporalExtents) {\n  const currentExtentStart = loadTemporalExtent[0].getTime()\n  const currentExtentEnd = loadTemporalExtent[1].getTime()\n  const indices = []\n  layerTemporalExtents.forEach((temporalExtent, index) => {\n    const temporalExtentStart = temporalExtent[0]\n    const temporalExtentEnd = temporalExtent[1]\n    if (temporalExtentEnd >= currentExtentStart && temporalExtentStart <= currentExtentEnd) {\n      indices.push(index)\n    }\n  })\n  return indices\n}\n\n/**\n * loadLayerTile - loads an heatmap tile.\n *\n * @param  {string} layerId              layer id\n * @param  {object} tileCoordinates      tile coordinates from reference tile\n * @param  {string} token                the user's token\n * @param  {array} temporalExtentsIndices which of the temporal extents from  temporalExtents should be loaded\n * @param  {string} urls                 tile endpoints provided by header\n * @param  {array} temporalExtents       all of the layer's header temporal extents\n * @param  {bool} temporalExtentsLess    true = don't try to load different tiles based on current time extent\n * @return {Promise}                     a Promise that will be resolved when tile is loaded\n */\nfunction loadLayerTile(\n  layerId,\n  tileCoordinates,\n  token,\n  temporalExtentsIndices,\n  { url, temporalExtents, temporalExtentsLess }\n) {\n  // console.log('loadLayerTile', layerId, tileCoordinates, temporalExtentsIndices)\n  if (url === undefined) {\n    throw new Error('URL/endpoints object is not available on this tilesets header')\n  }\n  const pelagosPromises = getTilePromises(url, token, temporalExtents, {\n    tileCoordinates,\n    temporalExtentsIndices,\n    temporalExtentsLess,\n  })\n  const allLayerPromises = Promise.all(pelagosPromises)\n\n  const layerTilePromise = new Promise((resolve) => {\n    allLayerPromises.then((rawTileData) => {\n      resolve({\n        loadedLayerId: layerId,\n        rawTileData,\n      })\n    })\n  })\n\n  return layerTilePromise\n}\n\n/**\n * parseLayerTile - parses an heatmap tile to a playback-ready format.\n *\n * @param  {Object} rawTileData          the raw tile data, loaded either from the pelagos client or as a MVT/PBF vector tile\n * @param  {array} colsByName            names of the columns present in the raw tiles that need to be included in the final playback data\n * @param  {object} tileCoordinates      tile coordinates from reference tile\n * @param  {array} prevPlaybackData      (optional) in case some time extent was already loaded for this tile, append to this data\n * @return {Object}                      playback-ready merged data\n */\nfunction parseLayerTile(rawTileData, colsByName, tileCoordinates, prevPlaybackData) {\n  let data\n\n  const cleanVectorArrays = getCleanVectorArrays(rawTileData)\n  data = groupData(cleanVectorArrays, Object.keys(colsByName))\n  if (Object.keys(data).length === 0) {\n    return []\n  }\n\n  const playbackData = getTilePlaybackData(data, colsByName, tileCoordinates, prevPlaybackData)\n  return playbackData\n}\n\n/**\n * getTiles - loads a bunch of heatmap tiles\n * @param  {array} layerIds                 list of layer Ids that need to be loaded for this/these tiles\n * @param  {array} referenceTiles           list of reference tiles (tile data regardless of layer) that need to be loaded\n * @param  {object} newTemporalExtentsToLoad (optional) a dict (layerId is the key) of temporal extents\n * indices that should be appended to existing data\n */\nfunction getTiles(layerIds, referenceTiles, newTemporalExtentsToLoad = undefined) {\n  return (dispatch, getState) => {\n    const state = getState()\n    const loaderID = startLoader(dispatch, state, layerIds.join('-'))\n    const token = state.map.module.token\n    const heatmapLayers = state.map.heatmap.heatmapLayers\n    const tilesByLayer = {}\n    layerIds.forEach((id) => {\n      tilesByLayer[id] = [...heatmapLayers[id].tiles]\n    })\n    const allPromises = []\n\n    layerIds.forEach((layerId) => {\n      const heatmapLayerHeader = heatmapLayers[layerId].header\n      const { temporalExtents, temporalExtentsLess, colsByName } = { ...heatmapLayerHeader }\n      const url = heatmapLayerHeader.endpoints.tiles\n\n      referenceTiles.forEach((referenceTile) => {\n        // check if tile does not already exist first\n        let tile = tilesByLayer[layerId].find((t) => t.uid === referenceTile.uid)\n        if (!tile) {\n          // console.log('create tile ', referenceTile.uid)\n          tile = {\n            uid: referenceTile.uid,\n            temporalExtentsIndicesLoaded: [],\n          }\n          tilesByLayer[layerId].push(tile)\n        } else {\n          // console.log('found tile', referenceTile.uid)\n        }\n\n        const queriedTemporalExtentsIndices =\n          newTemporalExtentsToLoad === undefined\n            ? heatmapLayers[layerId].visibleTemporalExtentsIndices\n            : newTemporalExtentsToLoad[layerId]\n\n        const temporalExtentsIndicesToLoad = difference(\n          queriedTemporalExtentsIndices,\n          tile.temporalExtentsIndicesLoaded\n        )\n\n        const tilePromise = loadLayerTile(\n          layerId,\n          referenceTile.tileCoordinates,\n          token,\n          temporalExtentsIndicesToLoad,\n          {\n            url,\n            temporalExtents,\n            temporalExtentsLess,\n          }\n        )\n\n        allPromises.push(tilePromise)\n\n        tilePromise.then(({ loadedLayerId, rawTileData }) => {\n          tile.temporalExtentsIndicesLoaded = uniq(\n            tile.temporalExtentsIndicesLoaded.concat(temporalExtentsIndicesToLoad)\n          )\n          tile.data = parseLayerTile(\n            rawTileData,\n            colsByName,\n            referenceTile.tileCoordinates,\n            tile.data\n          )\n\n          dispatch({\n            type: UPDATE_HEATMAP_TILE,\n            payload: {\n              layerId: loadedLayerId,\n              tile,\n            },\n          })\n        })\n      })\n    })\n\n    Promise.all(allPromises).then(() => {\n      dispatch(completeLoader(loaderID))\n      dispatch(markTileAsLoaded(referenceTiles.map((tile) => tile.uid)))\n    })\n  }\n}\n\n/**\n * getTile - This action is emitted when a new tile is queried from panning or zooming the map\n * This will load a tile for all currently visible heatmap layers\n *\n * @param  {object} referenceTile a reference tile containing xyz coords and uid\n */\nexport function getTile(referenceTile) {\n  return (dispatch, getState) => {\n    dispatch({\n      type: ADD_REFERENCE_TILE,\n      payload: referenceTile,\n    })\n    const visibleHeatmapLayers = getState().map.heatmap.heatmapLayers\n    const visibleHeatmapLayersIds = Object.keys(visibleHeatmapLayers).filter(\n      (id) => visibleHeatmapLayers[id].visible === true\n    )\n\n    if (visibleHeatmapLayersIds.length) {\n      dispatch(getTiles(visibleHeatmapLayersIds, [referenceTile]))\n    }\n  }\n}\n\n/**\n * releaseTiles - This action is emitted when an existing tile is removed from panning or zooming the map\n * @param  {array} uids tile ref uids to release\n */\nexport const releaseTiles = (uids) => ({\n  type: RELEASE_HEATMAP_TILES,\n  payload: uids,\n})\n\nexport const updateLoadedTiles = () => ({\n  type: UPDATE_LOADED_TILES,\n})\n\n// triggered when a layer is added or set to visible\nfunction loadAllTilesForLayer(layerId) {\n  return (dispatch, getState) => {\n    //                current layer, all reference tiles\n    const referenceTiles = getState().map.heatmap.referenceTiles\n    dispatch(getTiles([layerId], referenceTiles))\n  }\n}\n\nexport const addHeatmapLayer = (layer, loadTemporalExtent) => (dispatch) => {\n  const layerTemporalExtents = layer.header.temporalExtents\n  dispatch({\n    type: ADD_HEATMAP_LAYER,\n    payload: {\n      ...layer,\n      // initially attach which of the temporal extents indices are visible with initial outerExtent\n      visibleTemporalExtentsIndices: getTemporalExtentsVisibleIndices(\n        loadTemporalExtent,\n        layerTemporalExtents\n      ),\n    },\n  })\n\n  if (layer.visible === true) {\n    dispatch(loadAllTilesForLayer(layer.id))\n  }\n}\n\nexport const removeHeatmapLayer = (id) => (dispatch) => {\n  dispatch({\n    type: REMOVE_HEATMAP_LAYER,\n    payload: {\n      id,\n    },\n  })\n}\n\n/**\n * updateLayerLoadTemporalExtents - when outer time extent changes, checks if more tiles needs to be loaded\n * by comparing the outer time range with the temporalExtent already loaded on each layer.\n * @param  {array} loadTemporalExtent Current app-wide extent of tiles that need to load, expressed\n * as an array of two dates\n */\nexport function updateLayerLoadTemporalExtents(loadTemporalExtent) {\n  return (dispatch, getState) => {\n    const state = getState()\n    const heatmapLayers = state.map.heatmap.heatmapLayers\n    const indicesToAddByLayer = {}\n\n    Object.keys(heatmapLayers).forEach((layerId) => {\n      const heatmapLayer = heatmapLayers[layerId]\n      const temporalExtents = heatmapLayer.header.temporalExtents\n      const oldVisibleTemporalExtentsIndices = heatmapLayer.visibleTemporalExtentsIndices\n      const newVisibleTemporalExtentsIndices = getTemporalExtentsVisibleIndices(\n        loadTemporalExtent,\n        temporalExtents\n      )\n\n      const indicesAdded = difference(\n        newVisibleTemporalExtentsIndices,\n        oldVisibleTemporalExtentsIndices\n      )\n\n      const indicesRemoved = difference(\n        oldVisibleTemporalExtentsIndices,\n        newVisibleTemporalExtentsIndices\n      )\n\n      if (indicesAdded.length || indicesRemoved.length) {\n        // add new loaded indices to heatmap layer if applicable\n        dispatch({\n          type: UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES,\n          payload: {\n            layerId,\n            newVisibleTemporalExtentsIndices,\n            indicesRemoved,\n          },\n        })\n      }\n      if (indicesAdded.length) {\n        indicesToAddByLayer[layerId] = indicesAdded\n      }\n    })\n\n    // getTiles with indices diff\n    const layerIdsWithIndicesToAdd = Object.keys(indicesToAddByLayer)\n    if (layerIdsWithIndicesToAdd.length) {\n      dispatch(\n        getTiles(layerIdsWithIndicesToAdd, state.map.heatmap.referenceTiles, indicesToAddByLayer)\n      )\n    }\n  }\n}\n\n/**\n * Returns clusters or vessels data from a tileQuery\n * @param {object} state - the application state\n * @param {string} tileQuery - the id of a heatmap layer\n * @return {object} { isEmpty, isCluster, isMouseCluster, foundVessels, layerId, tilesetId }\n */\nconst _queryHeatmap = (state, tileQuery, temporalExtentIndexes) => {\n  const layers = state.map.heatmap.heatmapLayers\n  const startIndex = temporalExtentIndexes[0]\n  const endIndex = temporalExtentIndexes[1]\n  const layersVessels = []\n\n  Object.keys(layers).forEach((layerId) => {\n    const layer = layers[layerId]\n    if (layer.visible !== true) {\n      return\n    }\n    const allPossibleTilesByPreference = tileQuery.uids.map((uid) =>\n      layer.tiles.find((tile) => tile.uid === uid)\n    )\n    const availableTiles = allPossibleTilesByPreference.filter(\n      (tile) => tile !== undefined && tile.data !== undefined\n    )\n\n    const currentFilters = layer.filters\n    if (availableTiles.length) {\n      const bestTile = availableTiles[0]\n      layersVessels.push({\n        layer,\n        vessels: selectVesselsAt(bestTile.data, tileQuery, startIndex, endIndex, currentFilters),\n      })\n    }\n  })\n\n  const layersVesselsResults = layersVessels.filter(\n    (layerVessels) => layerVessels.vessels.length > 0\n  )\n\n  // it's a cluster because of aggregation on the server side\n  let isCluster\n  // its a cluster because or multiple vessels under mouse\n  let isMouseCluster\n  let isEmpty\n  let layerVesselsResult\n  let foundVessels\n\n  if (layersVesselsResults.length === 0) {\n    isEmpty = true\n  } else if (layersVesselsResults.length > 1) {\n    // if there are points over multiple layers, consider this a cluster (ie don't select, zoom instead, or don't highlight)\n    // there's an exception if vessel selection contains an encounter, in which case it will take priority\n    isCluster = true\n  } else {\n    // layersVesselsResults should contain a single result\n    layerVesselsResult = layersVesselsResults[0]\n\n    // we can get multiple points with similar series and id, in which case\n    // we should treat that as a successful vessel query, not a cluster\n    const vessels = layerVesselsResult.vessels\n\n    if (vessels.length === 0) {\n      isEmpty = true\n    } else {\n      // look up for any negatives ids (clusters on the server side)\n      const clusteredVessels = vessels.filter((v) => v.id < 0)\n      if (clusteredVessels.length) {\n        isCluster = true\n      } else {\n        foundVessels = uniqBy(vessels, (v) => v.series)\n        isMouseCluster = foundVessels.length > 1\n      }\n    }\n  }\n\n  const layer = layerVesselsResult === undefined ? {} : layerVesselsResult.layer\n\n  return { isEmpty, isCluster, isMouseCluster, foundVessels, layer }\n}\n\nexport function clearHighlightedVessels() {\n  return {\n    type: HIGHLIGHT_VESSELS,\n    payload: {\n      isEmpty: true,\n      clickableCluster: false,\n    },\n  }\n}\n\nexport function highlightVesselFromHeatmap(tileQuery, temporalExtentIndexes) {\n  return (dispatch, getState) => {\n    const state = getState()\n    const { layer, isEmpty, isCluster, isMouseCluster, foundVessels } = _queryHeatmap(\n      state,\n      tileQuery,\n      temporalExtentIndexes\n    )\n\n    if (\n      isCluster === true ||\n      layer.id !== undefined ||\n      state.map.heatmap.highlightedVessels.layerId !== layer.id\n    ) {\n      const layerPayload =\n        layer === undefined\n          ? null\n          : {\n              id: layer.id,\n              tilesetId: layer.tilesetId,\n              subtype: layer.subtype,\n              header: layer.header,\n            }\n      dispatch({\n        type: HIGHLIGHT_VESSELS,\n        payload: {\n          layer: layerPayload,\n          isEmpty,\n          clickableCluster: isCluster === true || isMouseCluster === true,\n          highlightableCluster: isCluster !== true,\n          foundVessels,\n        },\n      })\n    } else {\n      dispatch(clearHighlightedVessels())\n    }\n  }\n}\n\nexport const highlightClickedVessel = (id, layerId) => ({\n  type: HIGHLIGHT_CLICKED_VESSEL,\n  payload: {\n    id,\n    layerId,\n  },\n})\n\nexport const clearHighlightedClickedVessel = () => ({\n  type: CLEAR_HIGHLIGHT_CLICKED_VESSEL,\n})\n\nexport const updateHeatmapLayers = (newLayers, currentLoadTemporalExtent) => (\n  dispatch,\n  getState\n) => {\n  if (newLayers === null) {\n    console.warn(\"New layers in updateHeatmapLayers can't be null\")\n    return\n  }\n  const prevLayersDict = getState().map.heatmap.heatmapLayers\n\n  // add and update layers\n  newLayers.forEach((newLayer) => {\n    const layerId = newLayer.id\n    const prevLayer = prevLayersDict[layerId]\n    if (prevLayer === undefined) {\n      // console.log('adding', layerId)\n      dispatch(addHeatmapLayer(newLayer, currentLoadTemporalExtent))\n    } else {\n      if (prevLayer.visible !== newLayer.visible && newLayer.visible === true) {\n        dispatch(loadAllTilesForLayer(layerId))\n      }\n      if (\n        prevLayer.visible !== newLayer.visible ||\n        prevLayer.hue !== newLayer.hue ||\n        prevLayer.opacity !== newLayer.opacity ||\n        prevLayer.filters !== newLayer.filters ||\n        prevLayer.interactive !== newLayer.interactive\n      ) {\n        // console.log('updating', layerId, ' with visibilty', newLayer.visible)\n        dispatch({\n          type: UPDATE_HEATMAP_LAYER_STYLE,\n          payload: {\n            id: newLayer.id,\n            visible: newLayer.visible,\n            hue: newLayer.hue,\n            opacity: newLayer.opacity,\n            filters: newLayer.filters,\n            interactive: newLayer.interactive,\n          },\n        })\n      }\n    }\n  })\n\n  // clean up unused layers\n  Object.keys(prevLayersDict).forEach((prevLayerId) => {\n    if (!newLayers.find((l) => l.id === prevLayerId)) {\n      dispatch(removeHeatmapLayer(prevLayerId))\n    }\n  })\n}\n","import { fitBounds, pixelsToWorld } from 'viewport-mercator-project'\nimport { updateHeatmapTilesFromViewport } from '../heatmap/heatmapTiles.actions'\nimport { onViewportChange } from '../module/module.actions'\nimport { CLUSTER_CLICK_ZOOM_INCREMENT } from '../config' // TODO MAP MODULE\n\nexport const SET_BOUNDS = 'SET_BOUNDS'\nexport const SET_VIEWPORT = 'SET_VIEWPORT'\nexport const UPDATE_VIEWPORT = 'UPDATE_VIEWPORT'\nexport const SET_ZOOM_INCREMENT = 'SET_ZOOM_INCREMENT'\nexport const SET_MOUSE_LAT_LONG = 'SET_MOUSE_LAT_LONG'\nexport const TRANSITION_END = 'TRANSITION_END'\nexport const SET_NATIVE_VIEWPORT = 'SET_NATIVE_VIEWPORT'\n\nexport const setBounds = (bounds) => ({\n  type: SET_BOUNDS,\n  payload: bounds,\n})\n\nexport const setViewport = (viewport, interactionState) => (dispatch) => {\n  dispatch({\n    type: SET_VIEWPORT,\n    payload: viewport,\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  dispatch(onViewportChange(interactionState))\n}\n\nexport const updateViewport = (viewportUpdate) => (dispatch) => {\n  dispatch({\n    type: UPDATE_VIEWPORT,\n    payload: viewportUpdate,\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  // Not needed as call the callback with the same values\n  // dispatch(onViewportChange())\n}\n\nconst transitionTo = (increment, latitude = null, longitude = null, zoom = null) => (dispatch) => {\n  dispatch({\n    type: SET_ZOOM_INCREMENT,\n    payload: {\n      increment,\n      latitude,\n      longitude,\n      zoom,\n    },\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  dispatch(onViewportChange())\n}\n\nexport const transitionToZoom = (viewport) => (dispatch) => {\n  dispatch(transitionTo(null, viewport.center[0], viewport.center[1], viewport.zoom))\n}\n\nexport const transitionEnd = () => (dispatch) => {\n  dispatch({\n    type: TRANSITION_END,\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  dispatch(onViewportChange())\n}\n\nexport const zoomIntoVesselCenter = (latitude, longitude, zoom = null) => (dispatch) => {\n  dispatch(transitionTo(CLUSTER_CLICK_ZOOM_INCREMENT, latitude, longitude, zoom))\n}\n\nexport const fitToBounds = (bounds) => (dispatch, getState) => {\n  const state = getState()\n  const vp = fitBounds({\n    bounds: [[bounds.minLng, bounds.minLat], [bounds.maxLng, bounds.maxLat]],\n    width: state.map.viewport.viewport.width,\n    height: state.map.viewport.viewport.height,\n    padding: 50,\n  })\n  dispatch(transitionTo(null, vp.latitude, vp.longitude, vp.zoom))\n}\n\nexport const exportNativeViewport = (nativeViewport) => (dispatch) => {\n  const topLeftPx = [0, 0]\n  const bottomRightPx = [nativeViewport.width, nativeViewport.height]\n\n  // compute left and right offsets to deal with antimeridian issue\n  const topLeftWorld = pixelsToWorld(topLeftPx, nativeViewport.pixelUnprojectionMatrix)\n  const bottomRightWorld = pixelsToWorld(bottomRightPx, nativeViewport.pixelUnprojectionMatrix)\n  const leftWorldScaled = topLeftWorld[0] / nativeViewport.scale\n  const rightWorldScaled = bottomRightWorld[0] / nativeViewport.scale\n\n  // lat/lon corners for miniglobe\n  const northWest = nativeViewport.unproject(topLeftPx)\n  const southEast = nativeViewport.unproject(bottomRightPx)\n  const bounds = {\n    north: northWest[1],\n    south: southEast[1],\n    west: northWest[0],\n    east: southEast[0],\n  }\n\n  dispatch({\n    type: SET_NATIVE_VIEWPORT,\n    payload: {\n      leftWorldScaled,\n      rightWorldScaled,\n      bounds,\n    },\n  })\n}\n","import area from '@turf/area'\nimport { POLYGON_LAYERS_AREA } from '../constants'\nimport { clearHighlightedVessels, clearHighlightedClickedVessel } from '../heatmap/heatmap.actions'\nimport { zoomIntoVesselCenter } from './viewport.actions'\n\nexport const SET_POPUP = 'SET_POPUP'\nexport const CLEAR_POPUP = 'CLEAR_POPUP'\nexport const SET_MAP_CURSOR = 'SET_MAP_CURSOR'\n\nconst getAreaKm2 = (glFeature) => {\n  const areakm2 = 10 ** -6 * area(glFeature.geometry)\n  const formatted = areakm2.toLocaleString('en-US', { maximumFractionDigits: 0 })\n  return formatted\n}\n\nconst getFields = (glFeature, source = null) => {\n  if (source === null || source === undefined) {\n    // console.warn('Couldnt find source when looking for fields of layer', sourceId)\n  }\n\n  const fieldsDefinition =\n    !source || source.metadata === undefined || source.metadata['gfw:popups'] === undefined\n      ? []\n      : source.metadata['gfw:popups']\n\n  const properties = glFeature.properties\n\n  // whitelist if 'gfw:popups' exist, if not return all\n  const fieldsKeys = Object.keys(glFeature.properties).filter(\n    (k) => fieldsDefinition.length === 0 || fieldsDefinition.find((fd) => fd.id === k) !== undefined\n  )\n\n  const fields = fieldsKeys.map((fieldKey) => {\n    const value = fieldKey === POLYGON_LAYERS_AREA ? getAreaKm2(glFeature) : properties[fieldKey]\n    const def = fieldsDefinition.find((fd) => fd.id === fieldKey) || {}\n    const label = def.label || fieldKey\n    return {\n      id: fieldKey,\n      label,\n      value,\n      title: `${label}: ${value}`,\n      isLink: def.isLink,\n      isMain: def.isMain,\n    }\n  })\n\n  const mainField =\n    fields.find((f) => f.isMain === true) ||\n    fields.find((f) => f.id === 'name') ||\n    fields.find((f) => f.id === 'id') ||\n    fields[0]\n\n  if (mainField !== undefined) {\n    mainField.isMain = true\n  }\n  return fields\n}\n\nconst getCluster = (glFeature, glGetSource) => {\n  const clusterId = glFeature.properties.cluster_id\n  const sourceId = glFeature.source\n  const glSource = glGetSource(sourceId)\n  const promise = new Promise((resolve, reject) => {\n    glSource.getClusterExpansionZoom(clusterId, (err1, zoom) => {\n      glSource.getClusterLeaves(clusterId, 99, 0, (err2, children) => {\n        if (err1 || err2) {\n          reject()\n        }\n        const childrenFeatures = children.map((child) =>\n          getFeature(child, glFeature.layer.id, glSource)\n        )\n        resolve({\n          zoom,\n          childrenFeatures,\n        })\n      })\n    })\n  })\n  return promise\n}\n\nconst getFeature = (glFeature, layerId, source) => {\n  const feature = {\n    properties: glFeature.properties,\n  }\n  const fields = getFields(glFeature, source)\n  feature.fields = fields\n\n  // Get most likely feature title\n  const mainField = fields.find((f) => f.isMain === true)\n  feature.title = mainField === undefined ? layerId : mainField.value\n\n  return feature\n}\n\nexport const mapInteraction = (interactionType, latitude, longitude, glFeatures, glGetSource) => (\n  dispatch,\n  getState\n) => {\n  if (interactionType === 'click') {\n    dispatch(clearHighlightedClickedVessel())\n  }\n\n  const currentStyle = getState().map.style.mapStyle.toJS()\n\n  const event = {\n    latitude,\n    longitude,\n    features: [],\n  }\n\n  // Collect and normalize features on legacy heatmap\n  const currentLegacyHeatmapData = getState().map.heatmap.highlightedVessels\n  let legacyHeatmapFeature\n\n  if (currentLegacyHeatmapData.isEmpty !== true) {\n    const foundVessels =\n      currentLegacyHeatmapData.foundVessels === undefined\n        ? []\n        : currentLegacyHeatmapData.foundVessels\n    const properties = foundVessels.length === 0 ? [] : foundVessels[0]\n    const isCluster = currentLegacyHeatmapData.clickableCluster === true\n    const count =\n      isCluster === true && currentLegacyHeatmapData.highlightableCluster === false\n        ? -1\n        : foundVessels.length\n    legacyHeatmapFeature = {\n      isCluster,\n      count,\n      layer: {\n        id: currentLegacyHeatmapData.layer.id,\n        group: 'legacyHeatmap',\n      },\n      properties,\n    }\n    event.features.push(legacyHeatmapFeature)\n  }\n\n  // Try to retrieve 'gfw:id' (generated when instanciating CARTO layer to preserve original style.json id)\n  // In most cases it won't exist, so fall back to source id\n  const getStaticLayerIdFromGlFeature = (glFeature) =>\n    (glFeature.layer.metadata !== undefined && glFeature.layer.metadata['gfw:id']) ||\n    glFeature.layer.source\n\n  // Collect gl features\n  const clusterPromises = []\n  const allGlFeatures = glFeatures || []\n  allGlFeatures.forEach((glFeature) => {\n    const layerId = getStaticLayerIdFromGlFeature(glFeature)\n    const source = currentStyle.sources[layerId]\n    const feature = {\n      layer: {\n        id: layerId,\n        group: glFeature.layer.metadata && glFeature.layer.metadata['mapbox:group'],\n      },\n      ...getFeature(glFeature, layerId, source),\n    }\n\n    if (glFeature.properties.cluster === true) {\n      // lookup for cluster\n      const clusterPromise = getCluster(glFeature, glGetSource).then((cluster) => {\n        feature.cluster = cluster\n        feature.count = cluster.childrenFeatures.length\n      })\n      clusterPromises.push(clusterPromise)\n      feature.isCluster = true\n    } else {\n      feature.isCluster = false\n    }\n    event.features.push(feature)\n  })\n\n  Promise.all(clusterPromises).then(() => {\n    // The whole set of features is considered a cluster\n    // if any feature is a cluster, or there is more than one feature\n    event.isCluster =\n      event.features.length > 1 || event.features.some((feature) => feature.isCluster === true)\n\n    // legacy heatmap layers can yield clusters with an unknown number of features, handle this here:\n    if (legacyHeatmapFeature !== undefined && legacyHeatmapFeature.count === -1) {\n      event.count = -1\n    } else {\n      event.count = event.features.reduce((count, feature) => {\n        let featureCount = feature.count || 1\n        return count + featureCount\n      }, 0)\n    }\n\n    if (event.count === 1) {\n      event.feature = event.features[0]\n    }\n\n    // When autoClusterZoom is set to true, we handle zoom here\n    const autoClusterZoom = getState().map.module.autoClusterZoom === true\n\n    // Check if cluster using customizable isCluster() callback\n    // If not set resolves simply to (event) => event.isCluster === true\n    const clusterBehavior = getState().map.module.isCluster(event)\n    event.isCluster = clusterBehavior\n\n    if (autoClusterZoom) {\n      if (interactionType === 'click' && event.isCluster === true) {\n        dispatch(clearHighlightedVessels())\n        const clusterZoom = event.features[0].cluster && event.features[0].cluster.zoom\n        dispatch(zoomIntoVesselCenter(latitude, longitude, clusterZoom))\n      }\n    }\n\n    let cursor = event.features.length ? 'pointer' : null\n    if (event.isCluster === true) {\n      cursor = 'zoom-in'\n    }\n\n    dispatch({\n      type: SET_MAP_CURSOR,\n      payload: cursor,\n    })\n\n    const callback =\n      interactionType === 'click' ? getState().map.module.onClick : getState().map.module.onHover\n\n    if (callback !== undefined) {\n      callback(event)\n    }\n  })\n}\n","const RGB_MAX = 255\nconst HUE_MAX = 360\nconst SV_MAX = 100\n\nexport const VESSELS_HUES_INCREMENTS_NUM = 31 // 360 / VESSELS_HUES_INCREMENTS_NUM - 1  should give a round number\nexport const VESSELS_HUES_INCREMENT = 360 / (VESSELS_HUES_INCREMENTS_NUM - 1)\n\n// Legacy: this is only here for compatibility with pre-mapbox branch workspaces\nexport const COLOR_HUES = {\n  orange: 0,\n  peach: 22,\n  yellow: 60,\n  green: 85,\n  brightGreen: 145,\n  lightBlue: 182,\n  blue: 236,\n  purple: 284,\n  pink: 312,\n}\n\n// FIXME mark explicitely as legacy. Check all usages.\nexport const getKeyByValue = (obj, value) => {\n  let result = null\n  Object.entries(obj).forEach((entry) => {\n    if (entry[1] === value) result = entry[0]\n  })\n  return result\n}\n\n/**\n * Converts an RGB color value to HSV. Conversion formula\n * adapted from http://en.wikipedia.org/wiki/HSV_color_space.\n * Assumes r, g, and b are contained in the set [0, 255] and\n * returns h, s, and v in the set [0, 1].\n *\n * @param   Number  r       The red color value\n * @param   Number  g       The green color value\n * @param   Number  b       The blue color value\n * @return  Array           The HSV representation\n */\nexport const rgbToHsv = (_r, _g, _b) => {\n  const r = _r / 255\n  const g = _g / 255\n  const b = _b / 255\n\n  const max = Math.max(r, g, b)\n  const min = Math.min(r, g, b)\n  let h\n  const v = max\n\n  const d = max - min\n  const s = max === 0 ? 0 : d / max\n\n  if (max === min) {\n    h = 0 // achromatic\n  } else {\n    switch (max) {\n      case r:\n        h = (g - b) / d + (g < b ? 6 : 0)\n        break\n      case g:\n        h = (b - r) / d + 2\n        break\n      case b:\n        h = (r - g) / d + 4\n        break\n      default:\n        h = 0\n    }\n\n    h /= 6\n  }\n\n  return [h, s, v]\n}\n\n// converts hue, saturation, luminance to an rgb object\nexport const hsvToRgb = (h_, s_, v_) => {\n  const h = ((h_ % HUE_MAX) / parseFloat(HUE_MAX)) * 6\n  const s = s_ === SV_MAX ? 1 : (s_ % SV_MAX) / parseFloat(SV_MAX)\n  const v = v_ === SV_MAX ? 1 : (v_ % SV_MAX) / parseFloat(SV_MAX)\n\n  const i = Math.floor(h)\n  const f = h - i\n  const p = v * (1 - s)\n  const q = v * (1 - f * s)\n  const t = v * (1 - (1 - f) * s)\n  const mod = i % 6\n  const r = [v, q, p, p, t, v][mod]\n  const g = [t, v, v, q, p, p][mod]\n  const b = [p, p, t, v, v, q][mod]\n\n  return { r: Math.round(r * RGB_MAX), g: Math.round(g * RGB_MAX), b: Math.round(b * RGB_MAX) }\n}\n\n// returns an rgb string with default saturation and luminance values\nconst hueToRgbDefaults = (hue) => hsvToRgb(hue, 50, 100)\n\nexport const hueToRgbString = (hue) => {\n  const rgb = hueToRgbDefaults(hue)\n  return `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`\n}\n\nexport const rgbToHexString = (rgb, css) => {\n  const str = ['r', 'g', 'b']\n    .map((channelName) => {\n      const channelValue = rgb[channelName]\n      let channelStr = channelValue.toString(16)\n      if (channelValue < 16) {\n        channelStr = `0${channelStr}`\n      }\n      return channelStr\n    })\n    .join('')\n  const prefix = css === true ? '#' : '0x'\n  return `${prefix}${str}`\n}\n\nexport const hueToRgbHexString = (hue, css) => {\n  const rgb = hueToRgbDefaults(hue)\n  return rgbToHexString(rgb, css)\n}\n\nconst closestNumber = (numberArray, goal) =>\n  numberArray.reduce((prev, curr) => (Math.abs(curr - goal) < Math.abs(prev - goal) ? curr : prev))\n\nexport const hueToClosestColor = (hue) => {\n  if (hue === undefined || hue === null) return undefined\n  const colorHueValues = Object.keys(COLOR_HUES).map((key) => COLOR_HUES[key])\n  const closestHue = closestNumber(colorHueValues, hue)\n  return getKeyByValue(COLOR_HUES, closestHue)\n}\n\nexport const hexToRgb = (hex) => {\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex)\n  return result\n    ? {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16),\n      }\n    : null\n}\n\nconst rgbToRgbaString = (rgb, opacity) => `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`\n\nexport const hueToRgbaString = (hue, opacity) => {\n  const rgb = hueToRgbDefaults(hue)\n  return rgbToRgbaString(rgb, opacity)\n}\n\nexport const hexToRgba = (hex, opacity) => {\n  const rgb = hexToRgb(hex)\n  return rgbToRgbaString(rgb, opacity)\n}\n\nexport const hueIncrementToHue = (hueIncrement) => hueIncrement * VESSELS_HUES_INCREMENT\n\nexport const hueToHueIncrement = (hue) =>\n  Math.round((hue / 360) * (VESSELS_HUES_INCREMENTS_NUM - 1))\n\nexport const wrapHue = (hue) => hue % 360\n\nexport const hueOrColorToHexColor = (color, hue) => {\n  if (hue !== undefined) {\n    return hueToRgbHexString(hue, true)\n  }\n\n  return color\n}\n","/* global PIXI */\nimport 'pixi.js'\nimport { hueToHueIncrement, VESSELS_HUES_INCREMENTS_NUM } from '../utils/map-colors'\nimport { VESSELS_BASE_RADIUS, MAX_SPRITES_PER_LAYER } from '../config'\n\nexport default class HeatmapSubLayer {\n  constructor(baseTexture, renderingStyleIndex, hue, useNormalBlendMode = false) {\n    // this.stage = new PIXI.Container();\n    // the ParticleContainer is a faster version of the PIXI sprite container\n    this.stage = new PIXI.particles.ParticleContainer(MAX_SPRITES_PER_LAYER, {\n      scale: true,\n      alpha: true,\n      position: true,\n      uvs: true,\n    })\n    if (useNormalBlendMode === false) {\n      this.stage.blendMode = PIXI.BLEND_MODES.SCREEN\n    }\n\n    this.spritesPool = []\n\n    const initialTextureFrame = new PIXI.Rectangle(\n      0,\n      0,\n      VESSELS_BASE_RADIUS * 2,\n      VESSELS_BASE_RADIUS * 2\n    )\n    this.mainVesselTexture = new PIXI.Texture(baseTexture, initialTextureFrame)\n    this._setTextureFrame(renderingStyleIndex, hue)\n\n    this.clearSpriteProps()\n  }\n\n  clearSpriteProps() {\n    this.spritesProps = {\n      x: new Float32Array(MAX_SPRITES_PER_LAYER),\n      y: new Float32Array(MAX_SPRITES_PER_LAYER),\n      a: new Float32Array(MAX_SPRITES_PER_LAYER),\n      s: new Float32Array(MAX_SPRITES_PER_LAYER),\n    }\n    this.spritesPropsCount = 0\n  }\n\n  pushSpriteProps(x, y, a, s) {\n    this.spritesProps.x[this.spritesPropsCount] = x\n    this.spritesProps.y[this.spritesPropsCount] = y\n    this.spritesProps.a[this.spritesPropsCount] = a\n    this.spritesProps.s[this.spritesPropsCount] = s\n    this.spritesPropsCount++\n  }\n\n  setRenderingStyleIndex(renderingStyleIndex) {\n    this._setTextureFrame(renderingStyleIndex)\n  }\n\n  destroy() {\n    this.spritesPool = null\n    this.stage.destroy({ children: true })\n  }\n\n  /**\n   * Updates the main texture frame offset to show different brush styles and hues\n   * Both args are optional, if one is omitted, previous value is used\n   * @heatmapStyle bool whether to use heatmap style or solid circle style\n   * @hue number hue value between 0 and 360\n   */\n  _setTextureFrame(renderingStyleIndex = null, hue = null) {\n    const textureFrame = this.mainVesselTexture.frame.clone()\n\n    if (renderingStyleIndex !== null) {\n      // one diameter + tiny offset between 2 frames\n      textureFrame.x = VESSELS_BASE_RADIUS * 2 * renderingStyleIndex + renderingStyleIndex\n    }\n\n    if (hue !== null) {\n      let hueIncrement = hueToHueIncrement(hue)\n      if (hueIncrement === VESSELS_HUES_INCREMENTS_NUM - 1) {\n        hueIncrement = 0\n      }\n      textureFrame.y = hueIncrement * VESSELS_BASE_RADIUS * 2\n      if (hueIncrement > 0) {\n        textureFrame.y += hueIncrement\n      }\n    }\n\n    this.mainVesselTexture.frame = textureFrame\n    this.mainVesselTexture.update()\n  }\n\n  render() {\n    const numProps = this.spritesPropsCount\n    this.resizeSpritesPool()\n\n    for (let i = 0; i < numProps; i++) {\n      const sprite = this.stage.children[i]\n      const s = this.spritesProps.s[i]\n      sprite.setTransform(this.spritesProps.x[i], this.spritesProps.y[i], s, s)\n      sprite.alpha = this.spritesProps.a[i]\n    }\n\n    const numSprites = this.stage.children.length\n    for (let i = numProps; i < numSprites; i++) {\n      const sprite = this.stage.children[i]\n      sprite.x = -100\n    }\n  }\n\n  resizeSpritesPool() {\n    const numProps = this.spritesPropsCount\n    const prevNumSprites = this.stage.children.length\n    const delta = numProps - prevNumSprites\n    // console.log(prevNumSprites, '->', numProps, ' delta:', delta);\n\n    if (delta < -4999) {\n      // sprite needs to be removed. Do that progressively (max 100) to avoid UI lock\n      const toRemove = Math.min(100, -delta)\n      // console.log('removing ', toRemove);\n      for (let i = 0; i < toRemove; i++) {\n        this.stage.removeChildAt(0)\n      }\n    }\n\n    if (delta > 0) {\n      const toAdd = Math.max(5000, delta)\n      // console.log('adding ', toAdd);\n      this._addSprites(toAdd)\n    }\n  }\n\n  _addSprites(num) {\n    for (let i = 0; i < num; i++) {\n      const vessel = new PIXI.Sprite(this.mainVesselTexture)\n      vessel.anchor.x = 0.5\n      vessel.anchor.y = 0.5\n      // ParticlesContainer does not support .visible, so we just move the sprite out of the viewport\n      vessel.x = -100\n      // vessel.blendMode = PIXI.BLEND_MODES.SCREEN;\n      // vessel.filters=  [new PIXI.filters.BlurFilter(10,10)]\n      this.stage.addChild(vessel)\n    }\n  }\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport uniq from 'lodash/uniq'\nimport * as PIXI from 'pixi.js'\nimport { worldToPixels } from 'viewport-mercator-project'\nimport { BRUSH_RENDERING_STYLE, BRUSH_ZOOM_RENDERING_STYLE } from '../constants'\nimport { vesselSatisfiesFilters } from '../utils/heatmapTileData'\nimport HeatmapSubLayer from './HeatmapSubLayer'\n\n// This is a faster version of worldToPixels that omits pitch,\n// and ignores values from the matrix that are consistently = 0\nconst s = 1 / 1.5\nconst worldToPixelsSimple = (x, y, m) => {\n  const fx = s * (m[0] * x + m[4] * y + m[12])\n  const fy = s * (m[5] * y + m[13])\n  return [fx, fy]\n}\n\nclass HeatmapLayer extends React.Component {\n  componentDidMount() {\n    this._build()\n  }\n\n  componentWillUnmount() {\n    this._destroy()\n  }\n\n  componentDidUpdate() {\n    this._redraw()\n  }\n\n  componentWillReceiveProps(nextProps) {\n    if (nextProps.useRadialGradientStyle !== this.props.useRadialGradientStyle) {\n      this.setBrushZoomRenderingStyle(nextProps.useRadialGradientStyle)\n    }\n  }\n\n  _build() {\n    const { layer, rootStage, useRadialGradientStyle, customRenderingStyle } = this.props\n    this.subLayers = {}\n    this.renderingStyle =\n      layer.header && layer.header.rendering ? layer.header.rendering : customRenderingStyle\n\n    this.setBrushRenderingStyle(this.renderingStyle.style)\n    this.setBrushZoomRenderingStyle(useRadialGradientStyle)\n\n    this.stage = new PIXI.Container()\n\n    rootStage.addChild(this.stage)\n  }\n\n  setBrushRenderingStyle(style = BRUSH_RENDERING_STYLE.NORMAL) {\n    if (typeof style === 'string') {\n      this.brushRenderingStyle = BRUSH_RENDERING_STYLE[style.toUpperCase()]\n    } else {\n      this.brushRenderingStyle = style\n    }\n    this._setBrushRenderingStyleIndex()\n  }\n\n  setBrushZoomRenderingStyle(useRadialGradientStyle) {\n    this.brushZoomRenderingStyle =\n      useRadialGradientStyle === true\n        ? BRUSH_ZOOM_RENDERING_STYLE.RADIAL_GRADIENT\n        : BRUSH_ZOOM_RENDERING_STYLE.CIRCLE\n    this._setBrushRenderingStyleIndex()\n  }\n\n  _setBrushRenderingStyleIndex() {\n    // only NORMAL brush styles support different zoom styles\n    const cappedZoomRenderingStyle =\n      this.brushRenderingStyle === BRUSH_RENDERING_STYLE.NORMAL ? this.brushZoomRenderingStyle : 0\n    const newStyleIndex = this.brushRenderingStyle + cappedZoomRenderingStyle\n    if (newStyleIndex === this.renderingStyleIndex) {\n      return\n    }\n    this.renderingStyleIndex = newStyleIndex\n    Object.values(this.subLayers).forEach((subLayer) => {\n      subLayer.setRenderingStyleIndex(this.renderingStyleIndex)\n    })\n  }\n\n  _redraw() {\n    const { filters, baseTexture, layer } = this.props\n\n    if (\n      layer === null ||\n      layer === undefined ||\n      layer.tiles === undefined ||\n      layer.visible === false\n    ) {\n      this.stage.visible = false\n      return\n    }\n\n    this.stage.visible = true\n    this.stage.alpha = layer.opacity\n\n    const tiles = layer.tiles\n    const defaultHue = layer.hue\n    const allHuesToRender =\n      filters !== undefined && filters.length\n        ? filters\n            // pass is set to true by filterGroupActions when none of the filters fields\n            // in the filter group is supported by the layer headers\n            .filter((f) => f.pass !== true)\n            .map((f) => (f.hue === undefined ? '0' : f.hue.toString()))\n        : [defaultHue.toString()]\n    const currentlyUsedHues = Object.keys(this.subLayers)\n\n    // get all hues, old and new\n    const allHues = uniq(allHuesToRender.concat(currentlyUsedHues))\n\n    for (let i = 0; i < allHues.length; i++) {\n      const hue = allHues[i]\n      if (allHuesToRender.indexOf(hue) === -1) {\n        // not on new hues: delete sublayer\n        this._destroySubLayer(this.subLayers[hue])\n        delete this.subLayers[hue]\n        continue\n      }\n      if (currentlyUsedHues.indexOf(hue) === -1) {\n        // not on old hues: create sublayer\n        this.subLayers[hue] = this._createSublayer(baseTexture, this.renderingStyleIndex, hue)\n      }\n      this.subLayers[hue].clearSpriteProps()\n    }\n\n    if (!allHuesToRender.length) return\n    tiles.forEach((tile) => {\n      this._setSubLayersSpritePropsForTile({\n        data: tile.data,\n        numFilters: filters.length,\n        defaultHue,\n      })\n    })\n\n    allHuesToRender.forEach((hueToRender) => {\n      this.subLayers[hueToRender].render()\n    })\n  }\n\n  _setSubLayersSpritePropsForTile({ data, numFilters, defaultHue }) {\n    if (!data) {\n      return\n    }\n\n    const { startIndex, endIndex, viewport, filters, viewportLeft, viewportRight } = this.props\n\n    for (let timeIndex = startIndex; timeIndex < endIndex; timeIndex++) {\n      const frame = data[timeIndex]\n\n      if (!frame) continue\n\n      for (let index = 0, len = frame.worldX.length; index < len; index++) {\n        let hue\n        if (filters === undefined || !filters.length) {\n          hue = defaultHue\n        }\n        for (let fi = 0; fi < numFilters; fi++) {\n          const filter = filters[fi]\n          if (vesselSatisfiesFilters(frame, index, filter.filterValues)) {\n            hue = filter.hue\n            break\n          }\n        }\n\n        // no filter passes: bail\n        if (hue === undefined) {\n          continue\n        }\n\n        // wrap worldX when point crosses the antimeridian/dateline\n        // world points go from 0 to 512. There is no way to determine if worldX is on the \"wrong\" side\n        // of the antimeridian just by looking at its value (where with lat/lon we can simply look at -/+)\n        // Therefore we compare it to the viewport's left or right boundary, depending on what is currently\n        // \"the right side\" of the antimeridian\n        let worldX = frame.worldX[index]\n        if (viewportLeft > 0 && worldX < viewportLeft) {\n          // worldX is \"behind\" viewportLeft, which means it is \"on the right\" of the antimeridian\n          worldX += 512\n        } else if (viewportLeft < 0 && worldX > viewportRight) {\n          worldX -= 512\n        }\n\n        const scaledX = worldX * viewport.scale\n        const scaledY = frame.worldY[index] * viewport.scale\n        const mtx = viewport.pixelProjectionMatrix\n\n        const [x, y] =\n          viewport.pitch === 0\n            ? worldToPixelsSimple(scaledX, scaledY, mtx)\n            : worldToPixels([scaledX, scaledY], mtx)\n\n        if (x > -10 && x < viewport.width + 10 && y > -10 && y < viewport.height + 10) {\n          this.subLayers[hue].pushSpriteProps(\n            x,\n            y,\n            frame.opacity ? frame.opacity[index] : this.renderingStyle.defaultOpacity,\n            frame.radius ? frame.radius[index] : this.renderingStyle.defaultSize\n          )\n        }\n      }\n    }\n  }\n\n  _createSublayer(baseTexture, renderingStyleIndex, hue) {\n    const subLayer = new HeatmapSubLayer(\n      baseTexture,\n      renderingStyleIndex,\n      hue,\n      this.brushRenderingStyle === BRUSH_RENDERING_STYLE.BULLSEYE\n    )\n    this.stage.addChild(subLayer.stage)\n    return subLayer\n  }\n\n  _destroy() {\n    Object.values(this.subLayers).forEach(this._destroySubLayer.bind(this))\n    this.stage.destroy({ children: true })\n    const { rootStage } = this.props\n    rootStage.removeChild(this.stage)\n  }\n\n  _destroySubLayer(subLayer) {\n    this.stage.removeChild(subLayer.stage)\n    subLayer.destroy()\n  }\n\n  render() {\n    return null\n  }\n}\n\nHeatmapLayer.propTypes = {\n  layer: PropTypes.object,\n  rootStage: PropTypes.object,\n  viewport: PropTypes.object,\n  startIndex: PropTypes.number,\n  endIndex: PropTypes.number,\n  filters: PropTypes.array,\n  baseTexture: PropTypes.object,\n  useRadialGradientStyle: PropTypes.bool,\n  customRenderingStyle: PropTypes.object,\n  viewportLeft: PropTypes.number,\n  viewportRight: PropTypes.number,\n}\n\nexport default HeatmapLayer\n","/* global PIXI */\nimport 'pixi.js'\nimport React from 'react'\nimport PropTypes from 'prop-types'\nimport { worldToPixels } from 'viewport-mercator-project'\nimport { TRACKS_DOTS_STYLE_ZOOM_THRESHOLD } from '../config'\n\nclass TracksLayer extends React.Component {\n  componentDidMount() {\n    this._build()\n  }\n\n  componentDidUpdate() {\n    this._redraw()\n  }\n\n  _build() {\n    const { rootStage } = this.props\n    this.stage = new PIXI.Graphics()\n    this.stage.nativeLines = true\n    rootStage.addChild(this.stage)\n  }\n\n  clear() {\n    this.stage.clear()\n  }\n\n  _redraw() {\n    const { tracks, zoom, startIndex, endIndex, highlightTemporalExtentIndexes } = this.props\n\n    this.clear()\n    if (!tracks.length) {\n      return\n    }\n\n    const overInInner =\n      highlightTemporalExtentIndexes === null\n        ? undefined\n        : [\n            Math.max(startIndex, highlightTemporalExtentIndexes[0]),\n            Math.min(endIndex, highlightTemporalExtentIndexes[1]),\n          ]\n    const overExtent = overInInner && overInInner[1] - overInInner[0] > 0 ? overInInner : undefined\n\n    let n = 0 // eslint-disable-line no-unused-vars\n\n    const drawFishingCircles = zoom > TRACKS_DOTS_STYLE_ZOOM_THRESHOLD\n    const fishingCirclesRadius = 1 + (zoom - TRACKS_DOTS_STYLE_ZOOM_THRESHOLD) * 0.5\n    const drawOverTrack = overExtent !== undefined && overExtent[0] > 0 && overExtent[1] > 0\n\n    tracks.forEach((track) => {\n      n += this._drawTrack({\n        data: track.data,\n        startIndex,\n        endIndex,\n        drawFishingCircles,\n        fishingCirclesRadius,\n        color: `0x${track.color.substr(1)}`,\n        lineThickness: 1,\n        lineOpacity: 1,\n      })\n\n      // Draw the highlight over the track when the user hovers over the Timebar\n      if (drawOverTrack === true) {\n        n += this._drawTrack({\n          data: track.data,\n          startIndex: highlightTemporalExtentIndexes[0],\n          endIndex: highlightTemporalExtentIndexes[1],\n          drawFishingCircles,\n          fishingCirclesRadius,\n          color: '0xFFFFFF',\n          lineThickness: 2,\n          lineOpacity: 1,\n        })\n      }\n    })\n\n    // console.log(n);\n  }\n\n  /**\n   * Draws a single track (line + points)\n   *\n   * @param data track points data in 'playback form' (ie organized by days)\n   * @param extent extent, in day indices\n   * @param offset object containing info about the current situation of the map viewport, used to compute screen coords\n   * @param drawFishingCircles whether to draw fishing circles or not\n   * @param fishingCirclesRadius radius of the fishing circles\n   * @param color\n   * @param lineThickness\n   * @param lineOpacity\n   * @param worldOffset offset to use when a track crosses the dateline (ie 512 to add a second world to the right)\n   */\n  _drawTrack({\n    data,\n    startIndex,\n    endIndex,\n    drawFishingCircles,\n    fishingCirclesRadius,\n    color,\n    lineThickness,\n    lineOpacity,\n    worldOffset = 0,\n  }) {\n    const { viewport } = this.props\n\n    let n = 0\n    let prevSeries\n    let prevWorldX\n    let prevWorldY\n\n    const circlePoints = {\n      x: [],\n      y: [],\n    }\n\n    // line thickness is ignored in native mode anyways.\n    this.stage.lineStyle(lineThickness, color, lineOpacity)\n\n    let duplicateWorld = false\n\n    for (let timeIndex = startIndex; timeIndex < endIndex; timeIndex++) {\n      const frame = data[timeIndex]\n\n      if (!frame) continue\n\n      for (let i = 0, len = frame.series.length; i < len; i++) {\n        const currentSeries = frame.series[i]\n\n        n++\n\n        const worldX = frame.worldX[i] + worldOffset\n        const worldY = frame.worldY[i]\n\n        const [x, y] = worldToPixels(\n          [worldX * viewport.scale, worldY * viewport.scale],\n          viewport.pixelProjectionMatrix\n        )\n\n        if (prevSeries !== currentSeries) {\n          this.stage.moveTo(x, y)\n        }\n\n        // more than a ½ world of distance between two points = crossing the dateline\n        if (prevWorldX && Math.abs(worldX - prevWorldX) > 256) {\n          // worldOffset === 0 -> this is the first time drawTrack is called\n          if (worldOffset === 0) {\n            // set a flag to call drawTrack again at the end of the loop\n            duplicateWorld = true\n          }\n\n          // get Y coordinate where track intersects with dateline\n          const atDatelineWorldY = prevWorldY + (worldY - prevWorldY) / 2\n\n          // whether tracks crosses dateline from west to east\n          const isWestToEast = worldX - prevWorldX < 0\n\n          const worldXEnd = worldOffset + (512 - 0.000001)\n          const worldXStart = worldOffset\n\n          // get X coordinate ending at dateline\n          const atDatelineEndWorldX = isWestToEast ? worldXEnd : worldXStart\n\n          // get X coordinate starting at dateline\n          const atDatelineStartWorldX = isWestToEast ? worldXStart : worldXEnd\n\n          const [x1, y1] = worldToPixels(\n            [atDatelineEndWorldX * viewport.scale, atDatelineWorldY * viewport.scale],\n            viewport.pixelProjectionMatrix\n          )\n          this.stage.lineTo(x1, y1)\n          const [x2, y2] = worldToPixels(\n            [atDatelineStartWorldX * viewport.scale, atDatelineWorldY * viewport.scale],\n            viewport.pixelProjectionMatrix\n          )\n          this.stage.moveTo(x2, y2)\n        }\n\n        this.stage.lineTo(x, y)\n\n        if (drawFishingCircles && frame.hasFishing[i] === true) {\n          circlePoints.x.push(x)\n          circlePoints.y.push(y)\n        }\n\n        prevWorldX = worldX\n        prevWorldY = worldY\n        prevSeries = currentSeries\n      }\n    }\n\n    if (drawFishingCircles) {\n      this.stage.lineStyle(0)\n      this.stage.beginFill(color, 1)\n      for (let i = 0, circlesLength = circlePoints.x.length; i < circlesLength; i++) {\n        this.stage.drawCircle(circlePoints.x[i], circlePoints.y[i], fishingCirclesRadius)\n      }\n      this.stage.endFill()\n    }\n\n    if (duplicateWorld === true) {\n      ;[-512, 512].forEach((offset) => {\n        this._drawTrack({\n          worldOffset: offset,\n          data,\n          startIndex,\n          endIndex,\n          drawFishingCircles,\n          fishingCirclesRadius,\n          color,\n          lineThickness,\n          lineOpacity,\n        })\n      })\n    }\n    return n\n  }\n\n  render() {\n    return null\n  }\n}\n\nTracksLayer.propTypes = {\n  zoom: PropTypes.number,\n  rootStage: PropTypes.object,\n  viewport: PropTypes.object,\n  startIndex: PropTypes.number,\n  endIndex: PropTypes.number,\n  highlightTemporalExtentIndexes: PropTypes.array,\n  tracks: PropTypes.array,\n}\n\nexport default TracksLayer\n","import React, { Fragment } from 'react'\nimport * as PIXI from 'pixi.js'\nimport PropTypes from 'prop-types'\nimport { BaseControl } from 'react-map-gl'\nimport { lngLatToWorld } from 'viewport-mercator-project'\nimport {\n  hsvToRgb,\n  hueToRgbString,\n  hueIncrementToHue,\n  wrapHue,\n  VESSELS_HUES_INCREMENTS_NUM,\n} from '../utils/map-colors'\nimport {\n  VESSELS_BASE_RADIUS,\n  VESSELS_HEATMAP_BLUR_FACTOR,\n  ACTIVITY_HIGHLIGHT_HUE,\n  VESSELS_HEATMAP_DIMMING_ALPHA,\n  VESSELS_RADIAL_GRADIENT_STYLE_ZOOM_THRESHOLD,\n  VESSEL_CLICK_TOLERANCE_PX,\n} from '../config'\nimport HeatmapLayer from '../heatmap/HeatmapLayer'\nimport TracksLayer from '../tracks/TracksLayer'\n\nconst shouldUseRadialGradientStyle = (zoom) => zoom < VESSELS_RADIAL_GRADIENT_STYLE_ZOOM_THRESHOLD\n\n// builds a texture spritesheet containing\n// - the heatmap style (radial gradient)\n// - the circle style that is used at higher zoom levels\n// - the 'bullseye' style used for encounters\n// as well as a number of hues for each in a 2D grid.\n// Then, only the texture frame (mesh UVs) is modified depending on the zoom level,\n// in order not to have to recreate sprites\nconst getVesselTexture = (radius, blurFactor) => {\n  const tplCanvas = document.createElement('canvas')\n  const tplCtx = tplCanvas.getContext('2d')\n  const diameter = radius * 2\n  const NUM_STYLES = 3\n  tplCanvas.width = diameter * NUM_STYLES + (NUM_STYLES - 1) // + (NUM_STYLES - 1): tiny offset between 2 frames\n  tplCanvas.height = diameter * VESSELS_HUES_INCREMENTS_NUM + VESSELS_HUES_INCREMENTS_NUM\n\n  for (let hueIncrement = 0; hueIncrement < VESSELS_HUES_INCREMENTS_NUM; hueIncrement++) {\n    const y = diameter * hueIncrement + hueIncrement\n    const yCenter = y + radius\n\n    // heatmap style\n    let x = radius\n    const gradient = tplCtx.createRadialGradient(\n      x,\n      yCenter,\n      radius * blurFactor,\n      x,\n      yCenter,\n      radius\n    )\n    const hue = hueIncrementToHue(hueIncrement)\n    const rgbString = hueToRgbString(hue)\n    gradient.addColorStop(0, rgbString)\n\n    const rgbOuter = hsvToRgb(wrapHue(hue + 30), 80, 100)\n    gradient.addColorStop(1, `rgba(${rgbOuter.r}, ${rgbOuter.g}, ${rgbOuter.b}, 0)`)\n\n    tplCtx.fillStyle = gradient\n    tplCtx.fillRect(0, y, diameter, diameter)\n\n    // circle style\n    x += diameter + 1 // tiny offset between 2 frames\n    tplCtx.beginPath()\n    tplCtx.arc(x, yCenter, radius, 0, 2 * Math.PI, false)\n    tplCtx.fillStyle = rgbString\n    tplCtx.fill()\n\n    // bullseye style\n    x += diameter + 1\n    tplCtx.beginPath()\n    tplCtx.arc(x, yCenter, radius * 0.4, 0, 2 * Math.PI, false)\n    tplCtx.fillStyle = rgbString\n    tplCtx.fill()\n    tplCtx.beginPath()\n    tplCtx.arc(x, yCenter, radius * 0.95, 0, 2 * Math.PI, false)\n    tplCtx.lineWidth = 1\n    tplCtx.strokeStyle = rgbString\n    tplCtx.stroke()\n  }\n\n  return tplCanvas\n}\n\nclass ActivityLayers extends BaseControl {\n  state = {\n    pixiReady: false,\n  }\n\n  componentDidMount() {\n    this._build()\n    this.setState({\n      pixiReady: true,\n    })\n  }\n\n  componentWillUnmount() {\n    this._destroy()\n  }\n\n  componentWillReceiveProps(nextProps) {\n    this.props.exportNativeViewport(this._context.viewport)\n\n    if (\n      nextProps.viewport.width !== this.props.viewport.width ||\n      nextProps.viewport.height !== this.props.viewport.height\n    ) {\n      this._updateViewportSize(nextProps.viewport.width, nextProps.viewport.height)\n    }\n  }\n\n  _build() {\n    const { width, height } = this.props.viewport\n\n    this.pixi = new PIXI.Application({\n      width,\n      height,\n      transparent: true,\n      antialias: true,\n    })\n\n    this.renderer = this.pixi.renderer\n    this.canvas = this.pixi.view\n    this.canvas.style.position = 'absolute'\n\n    this.container.appendChild(this.canvas)\n\n    this.stage = this.pixi.stage\n\n    const baseTextureCanvas = getVesselTexture(VESSELS_BASE_RADIUS, VESSELS_HEATMAP_BLUR_FACTOR)\n    this.baseTexture = PIXI.Texture.fromCanvas(baseTextureCanvas)\n\n    this.heatmapStage = new PIXI.Container()\n    this.stage.addChild(this.heatmapStage)\n\n    this.pixi.ticker.add(this._onTick)\n  }\n\n  _destroy() {\n    this.pixi.destroy()\n  }\n\n  _updateViewportSize(viewportWidth, viewportHeight) {\n    this.renderer.resize(viewportWidth, viewportHeight)\n  }\n\n  toggleHeatmapDimming(dim) {\n    if (this.heatmapStage === undefined) {\n      return\n    }\n    if (dim === true) {\n      this.heatmapFadingIn = false\n    }\n    this.heatmapStage.alpha = dim === true ? VESSELS_HEATMAP_DIMMING_ALPHA : 1\n  }\n\n  onTouchStart = (event) => {\n    if (!event.touches.length) {\n      return\n    }\n    this.queryCoords(event.touches[0].clientX, event.touches[0].clientY)\n  }\n\n  onMouseMove = (event) => {\n    this.queryCoords(event.clientX, event.clientY)\n  }\n\n  queryCoords(x, y) {\n    // bail if all heatmap layers are set to non-interactive\n    if (this.props.heatmapLayers.every((l) => l.interactive !== true)) {\n      return\n    }\n\n    const { viewport } = this._context\n    const [longitude, latitude] = viewport.unproject([x, y])\n\n    let wrappedLongitude = longitude\n    if (wrappedLongitude > 180) {\n      wrappedLongitude -= 360\n    } else if (wrappedLongitude < -180) {\n      wrappedLongitude += 360\n    }\n\n    const [worldX, worldY] = lngLatToWorld([wrappedLongitude, latitude], 1)\n\n    const toleranceRadiusInWorldUnits = VESSEL_CLICK_TOLERANCE_PX / viewport.scale\n\n    this.props.queryHeatmapVessels(\n      {\n        longitude: wrappedLongitude,\n        latitude,\n        worldX,\n        worldY,\n        toleranceRadiusInWorldUnits,\n      },\n      this.props.temporalExtentIndexes\n    )\n  }\n\n  _onTick = () => {\n    if (this.heatmapFadingIn === true && this.heatmapStage.alpha < 1) {\n      this._heatmapFadeinStep()\n    }\n  }\n\n  _startHeatmapFadein() {\n    this.heatmapFadingIn = true\n    this.heatmapFadeinStartTimestamp = undefined\n  }\n\n  _heatmapFadeinStep() {\n    if (this.heatmapFadeinStartTimestamp === undefined) {\n      this.heatmapFadeinStartTimestamp = Date.now()\n    }\n    const timeElapsed = (Date.now() - this.heatmapFadeinStartTimestamp) / 1000\n    let alpha = this.heatmapStage.alpha + (1 - this.heatmapStage.alpha) * timeElapsed\n    if (alpha >= 1) {\n      alpha = 1\n      this.heatmapFadingIn = false\n    }\n    this.heatmapStage.alpha = alpha\n  }\n\n  // FIXME move to container?\n  _getHighlightData(highlightedVessels, highlightedClickedVessel, heatmapLayers) {\n    const hue = ACTIVITY_HIGHLIGHT_HUE\n    let highlightLayerData = {\n      id: '__HIGHLIGHT__',\n      visible: true,\n      opacity: 1,\n      hue: ACTIVITY_HIGHLIGHT_HUE,\n    }\n    let highlightFilters = []\n\n    if (\n      highlightedVessels !== undefined &&\n      highlightedVessels.layer !== undefined &&\n      highlightedVessels.foundVessels !== undefined &&\n      highlightedVessels.isEmpty !== true\n    ) {\n      const sourceLayer = heatmapLayers.find((l) => l.id === highlightedVessels.layer.id)\n      highlightLayerData = { highlightLayerData, ...sourceLayer }\n      highlightFilters = highlightedVessels.foundVessels.map((vessel) => ({\n        hue,\n        filterValues: {\n          series: [vessel.series],\n        },\n      }))\n    } else if (highlightedClickedVessel !== null) {\n      const sourceLayer = heatmapLayers.find((l) => l.id === highlightedClickedVessel.layer.id)\n      highlightLayerData = { highlightLayerData, ...sourceLayer }\n      highlightFilters = [\n        {\n          hue,\n          filterValues: {\n            series: [highlightedClickedVessel.id],\n          },\n        },\n      ]\n    }\n    return {\n      highlightLayerData,\n      highlightFilters,\n    }\n  }\n  _render() {\n    const {\n      zoom,\n      heatmapLayers,\n      temporalExtentIndexes,\n      highlightTemporalExtentIndexes,\n      highlightedVessels,\n      highlightedClickedVessel,\n      tracks,\n      leftWorldScaled,\n      rightWorldScaled,\n    } = this.props\n    const { viewport } = this._context\n    const { pixiReady } = this.state\n\n    const startIndex = temporalExtentIndexes[0]\n    const endIndex = temporalExtentIndexes[1]\n    const useRadialGradientStyle = shouldUseRadialGradientStyle(zoom)\n\n    if (highlightedVessels.isEmpty !== true) {\n      this.toggleHeatmapDimming(true)\n    }\n    if (highlightedVessels.isEmpty === true && tracks.length === 0) {\n      this._startHeatmapFadein()\n    }\n    if (this.renderer && this.renderer.gl && this.renderer.gl.getError !== undefined) {\n      const err = this.renderer.gl.getError()\n      if (err !== 0) console.log(err)\n    }\n\n    const { highlightLayerData, highlightFilters } = this._getHighlightData(\n      highlightedVessels,\n      highlightedClickedVessel,\n      heatmapLayers\n    )\n\n    return (\n      <div\n        ref={(ref) => {\n          this.container = ref\n        }}\n        style={{ position: 'absolute' }}\n        onMouseMove={this.onMouseMove}\n        onTouchStart={this.onTouchStart}\n      >\n        {pixiReady === true && (\n          <Fragment>\n            {heatmapLayers.map((layer) => (\n              <HeatmapLayer\n                key={layer.id}\n                layer={layer}\n                filters={layer.filters || []}\n                viewport={viewport}\n                startIndex={startIndex}\n                endIndex={endIndex}\n                baseTexture={this.baseTexture}\n                rootStage={this.heatmapStage}\n                useRadialGradientStyle={useRadialGradientStyle}\n                customRenderingStyle={{}}\n                viewportLeft={leftWorldScaled}\n                viewportRight={rightWorldScaled}\n              />\n            ))}\n            {this.stage !== undefined && (\n              <HeatmapLayer\n                key=\"highlighted\"\n                layer={highlightLayerData}\n                filters={highlightFilters}\n                viewport={viewport}\n                startIndex={startIndex}\n                endIndex={endIndex}\n                baseTexture={this.baseTexture}\n                rootStage={this.heatmapStage}\n                useRadialGradientStyle={useRadialGradientStyle}\n                customRenderingStyle={{ defaultOpacity: 1, defaultSize: 1 }}\n                viewportLeft={leftWorldScaled}\n                viewportRight={rightWorldScaled}\n              />\n            )}\n            {this.stage !== undefined && (\n              <TracksLayer\n                tracks={tracks}\n                viewport={viewport}\n                zoom={zoom}\n                startIndex={startIndex}\n                endIndex={endIndex}\n                highlightTemporalExtentIndexes={highlightTemporalExtentIndexes}\n                rootStage={this.stage}\n              />\n            )}\n          </Fragment>\n        )}\n      </div>\n    )\n  }\n}\n\nActivityLayers.propTypes = {\n  zoom: PropTypes.number,\n  heatmapLayers: PropTypes.array,\n  temporalExtentIndexes: PropTypes.array,\n  highlightTemporalExtentIndexes: PropTypes.array,\n  highlightedVessels: PropTypes.object,\n  highlightedClickedVessel: PropTypes.object,\n  tracks: PropTypes.array,\n  queryHeatmapVessels: PropTypes.func,\n  exportNativeViewport: PropTypes.func,\n  leftWorldScaled: PropTypes.number,\n  rightWorldScaled: PropTypes.number,\n}\n\nActivityLayers.contextTypes = {\n  viewport: PropTypes.object,\n}\n\nexport default ActivityLayers\n","import { connect } from 'react-redux'\nimport { createSelector } from 'reselect'\nimport convert from '@globalfishingwatch/map-convert'\nimport { exportNativeViewport } from '../glmap/viewport.actions'\nimport { getTemporalExtent, getHighlightTemporalExtent } from '../module/module.selectors'\nimport ActivityLayers from './ActivityLayers'\nimport { queryHeatmapVessels } from '../heatmap/heatmapTiles.actions'\nimport { MIN_FRAME_LENGTH_MS } from '../config'\n\nconst getHeatmapLayers = (state) => state.map.heatmap.heatmapLayers\n\nconst getHeatmapLayersAsArray = createSelector(\n  [getHeatmapLayers],\n  (heatmapLayers) => {\n    const a = Object.keys(heatmapLayers).map((id) => ({\n      ...heatmapLayers[id],\n    }))\n    // console.log(a)\n    return a\n  }\n)\n\nconst getTracks = (state) => state.map.tracks.data\n\nconst getTracksWithData = createSelector(\n  [getTracks],\n  (tracks) => {\n    const tracksWithData = tracks\n      .filter((t) => t.type !== 'geojson')\n      .filter((t) => t.data !== undefined)\n    return tracksWithData\n  }\n)\n\nconst getTemporalExtentIndexes = createSelector(\n  [getTemporalExtent],\n  (temporalExtent) => {\n    const startTimestamp = temporalExtent[0].getTime()\n    const endTimestamp = Math.max(\n      temporalExtent[1].getTime(),\n      temporalExtent[0].getTime() + MIN_FRAME_LENGTH_MS\n    )\n    const startIndex = convert.getOffsetedTimeAtPrecision(startTimestamp)\n    const endIndex = convert.getOffsetedTimeAtPrecision(endTimestamp)\n    return [startIndex, endIndex]\n  }\n)\n\nconst getHighlightTemporalExtentIndexes = createSelector(\n  [getHighlightTemporalExtent],\n  (highlightTemporalExtent) => {\n    if (\n      highlightTemporalExtent === undefined ||\n      highlightTemporalExtent === null ||\n      !highlightTemporalExtent.length\n    ) {\n      return null\n    }\n    const startTimestamp = highlightTemporalExtent[0].getTime()\n    const endTimestamp = highlightTemporalExtent[1].getTime()\n    const startIndex = convert.getOffsetedTimeAtPrecision(startTimestamp)\n    const endIndex = convert.getOffsetedTimeAtPrecision(endTimestamp)\n    return [startIndex, endIndex]\n  }\n)\n\nconst mapStateToProps = (state) => ({\n  highlightedVessels: state.map.heatmap.highlightedVessels,\n  highlightedClickedVessel: state.map.heatmap.highlightedClickedVessel,\n  viewport: state.map.viewport.viewport,\n  zoom: state.map.viewport.viewport.zoom,\n  heatmapLayers: getHeatmapLayersAsArray(state),\n  tracks: getTracksWithData(state),\n  leftWorldScaled: state.map.viewport.leftWorldScaled,\n  rightWorldScaled: state.map.viewport.rightWorldScaled,\n  temporalExtentIndexes: getTemporalExtentIndexes(state),\n  highlightTemporalExtentIndexes: getHighlightTemporalExtentIndexes(state),\n})\n\nconst mapDispatchToProps = (dispatch, ownProps) => ({\n  queryHeatmapVessels: (coords, temporalExtentIndexes) => {\n    dispatch(queryHeatmapVessels(coords, temporalExtentIndexes))\n  },\n  exportNativeViewport: (viewport) => {\n    dispatch(exportNativeViewport(viewport))\n  },\n})\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(ActivityLayers)\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport MapGL, { Popup, Marker } from 'react-map-gl'\nimport 'mapbox-gl/dist/mapbox-gl.css'\nimport { TILES_URL_NEEDING_AUTHENTICATION } from '../config'\nimport ActivityLayers from '../activity/ActivityLayers.container.js'\nimport styles from './map.css'\n\nconst PopupWrapper = (props) => {\n  const { latitude, longitude, children, closeButton, onClose } = props\n  return (\n    <Popup\n      latitude={latitude}\n      longitude={longitude}\n      closeButton={closeButton}\n      onClose={onClose}\n      anchor=\"bottom\"\n      offsetTop={-10}\n      tipSize={4}\n      closeOnClick={false}\n    >\n      {children}\n    </Popup>\n  )\n}\n\nPopupWrapper.propTypes = {\n  latitude: PropTypes.number.isRequired,\n  longitude: PropTypes.number.isRequired,\n  children: PropTypes.node.isRequired,\n  closeButton: PropTypes.bool.isRequired,\n  onClose: PropTypes.func,\n}\n\nPopupWrapper.defaultProps = {\n  onClose: () => {},\n}\n\nclass Map extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      mouseOver: true,\n    }\n    this._mapContainerRef = null\n  }\n\n  componentDidMount() {\n    this.setBounds()\n  }\n\n  componentDidUpdate() {\n    this.setBounds()\n  }\n\n  onLoad = () => {\n    if (this.props.onLoad !== undefined) {\n      this.props.onLoad(this.getBounds())\n    }\n  }\n\n  setBounds = () => {\n    const bounds = this.getBounds()\n    if (bounds !== null && this.props.setBounds !== undefined) {\n      this.props.setBounds(bounds)\n    }\n  }\n\n  getBounds = () => {\n    if (!this.glMap) return null\n\n    const { _ne, _sw } = this.glMap.getBounds()\n    return {\n      north: _ne.lat,\n      south: _sw.lat,\n      west: _sw.lng,\n      east: _ne.lng,\n    }\n  }\n\n  componentWillUnmount() {\n    if (this._containerResizeObserver) {\n      this._containerResizeObserver.disconnect()\n    }\n  }\n\n  loadObserver = async () => {\n    if ('ResizeObserver' in window === false) {\n      const module = await import('resize-observer-polyfill')\n      window.ResizeObserver = module.ResizeObserver || module.default\n    }\n    this._containerResizeObserver = new ResizeObserver(this.handleResizeObserver)\n    this._containerResizeObserver.observe(this._mapContainerRef)\n  }\n\n  handleResizeObserver = (entries) => {\n    const { width, height } = entries[0].contentRect\n    const { viewport, setViewport } = this.props\n\n    if (width !== viewport.width || height !== viewport.height) {\n      setViewport({\n        ...viewport,\n        width,\n        height,\n      })\n    }\n  }\n\n  onViewportChange = (viewport, interactionState) => {\n    const propsViewport = this.props.viewport\n    if (\n      propsViewport.latitude !== viewport.latitude ||\n      propsViewport.longitude !== viewport.longitude ||\n      propsViewport.zoom !== viewport.zoom ||\n      propsViewport.bearing !== viewport.bearing ||\n      propsViewport.pitch !== viewport.pitch\n    ) {\n      this.props.setViewport(viewport, interactionState)\n    }\n  }\n\n  onMapInteraction = (event, type) => {\n    this.props.mapInteraction(\n      type,\n      event.lngLat[1],\n      event.lngLat[0],\n      event.features,\n      this.glGetSource\n    )\n  }\n\n  onHover = (event) => {\n    this.onMapInteraction(event, 'hover')\n  }\n\n  onClick = (event) => {\n    this.onMapInteraction(event, 'click')\n  }\n\n  getRef = (ref) => {\n    if (ref !== null) {\n      this.glMap = ref.getMap()\n      this.glGetSource = this.glMap.getSource.bind(this.glMap)\n    }\n  }\n\n  getCursor = ({ isDragging }) => {\n    const { cursor } = this.props\n    if (cursor === null) {\n      return isDragging ? 'grabbing' : 'grab'\n    }\n    return cursor\n  }\n\n  transformRequest = (url, resourceType) => {\n    const { token } = this.props\n    if (token !== null && resourceType === 'Tile' && url.match(TILES_URL_NEEDING_AUTHENTICATION)) {\n      return {\n        url: url,\n        headers: { Authorization: 'Bearer ' + token },\n      }\n    }\n  }\n\n  render() {\n    const {\n      viewport,\n      maxZoom,\n      minZoom,\n      transitionEnd,\n      mapStyle,\n      onClosePopup,\n      clickPopup,\n      hoverPopup,\n      hasHeatmapLayers,\n      markers,\n      interactiveLayerIds,\n    } = this.props\n\n    return (\n      <div\n        id=\"map\"\n        className={styles.map}\n        ref={(ref) => {\n          this._mapContainerRef = ref\n        }}\n        onMouseLeave={() => {\n          this.setState({ mouseOver: false })\n        }}\n        onMouseEnter={() => {\n          this.setState({ mouseOver: true })\n        }}\n      >\n        <MapGL\n          {...viewport}\n          ref={this.getRef}\n          transformRequest={this.transformRequest}\n          onTransitionEnd={transitionEnd}\n          onLoad={this.onLoad}\n          onHover={this.onHover}\n          onClick={this.onClick}\n          getCursor={this.getCursor}\n          mapStyle={mapStyle}\n          maxZoom={maxZoom}\n          minZoom={minZoom}\n          onViewportChange={this.onViewportChange}\n          interactiveLayerIds={interactiveLayerIds}\n          clickRadius={4}\n        >\n          {hasHeatmapLayers !== false && <ActivityLayers />}\n          {clickPopup !== undefined && clickPopup !== null && (\n            <PopupWrapper\n              latitude={clickPopup.latitude}\n              longitude={clickPopup.longitude}\n              closeButton\n              onClose={onClosePopup}\n            >\n              {clickPopup.content}\n            </PopupWrapper>\n          )}\n          {this.state.mouseOver === true && hoverPopup !== undefined && hoverPopup !== null && (\n            <PopupWrapper\n              latitude={hoverPopup.latitude}\n              longitude={hoverPopup.longitude}\n              closeButton={false}\n            >\n              {hoverPopup.content}\n            </PopupWrapper>\n          )}\n          {markers !== null &&\n            markers.length > 0 &&\n            markers.map((marker, i) => (\n              <Marker key={i} latitude={marker.latitude} longitude={marker.longitude}>\n                {marker.content}\n              </Marker>\n            ))}\n        </MapGL>\n        <div className={styles.googleLogo} />\n      </div>\n    )\n  }\n}\n\nMap.propTypes = {\n  token: PropTypes.string,\n  viewport: PropTypes.object.isRequired,\n  mapStyle: PropTypes.object.isRequired,\n  clickPopup: PropTypes.object,\n  hoverPopup: PropTypes.object,\n  maxZoom: PropTypes.number.isRequired,\n  minZoom: PropTypes.number.isRequired,\n  setViewport: PropTypes.func.isRequired,\n  setBounds: PropTypes.func,\n  mapInteraction: PropTypes.func,\n  onLoad: PropTypes.func,\n  onClosePopup: PropTypes.func,\n  transitionEnd: PropTypes.func,\n  cursor: PropTypes.string,\n  hasHeatmapLayers: PropTypes.bool.isRequired,\n  markers: PropTypes.arrayOf(\n    PropTypes.shape({\n      latitude: PropTypes.number.isRequired,\n      longitude: PropTypes.number.isRequired,\n      content: PropTypes.node,\n    })\n  ),\n  interactiveLayerIds: PropTypes.arrayOf(PropTypes.string),\n}\n\nMap.defaultProps = {\n  token: null,\n  clickPopup: null,\n  hoverPopup: null,\n  mapInteraction: () => {},\n  onLoad: () => {},\n  onClosePopup: () => {},\n  transitionEnd: () => {},\n  cursor: null,\n  markers: null,\n  interactiveLayerIds: null,\n  setBounds: undefined,\n}\n\nexport default Map\n","import { connect } from 'react-redux'\nimport { createSelector } from 'reselect'\nimport { fromJS } from 'immutable'\nimport { TRACKS_LAYER_IN_FRONT_OF_GROUP } from '../config'\nimport { closePopup } from '../module/module.actions.js'\nimport { getTracksStyles } from '../tracks/tracks.selectors.js'\nimport { mapInteraction } from './interaction.actions.js'\nimport { setBounds, setViewport, transitionEnd } from './viewport.actions.js'\nimport Map from './Map'\n\nconst getStaticLayers = (state) => state.map.style.staticLayers\nconst getHeatmapLayers = (state) => state.map.heatmap.heatmapLayers\nconst getInternalCursor = (state) => state.map.interaction.cursor\nconst getModuleCursor = (state) => state.map.module.cursor\n\nconst hasHeatmapLayers = createSelector(\n  [getHeatmapLayers],\n  (heatmapLayers) => {\n    return Object.keys(heatmapLayers).length > 0\n  }\n)\nconst getInteractiveLayerIds = createSelector(\n  [getStaticLayers],\n  // Note: here we assume that layer IDs provided with module match the GL layers that should\n  // be interactive or not, ie typically the fill layer if a label layer is present\n  (staticLayers) => {\n    return staticLayers.reduce((acc, layer) => {\n      if (!layer.interactive || !layer.visible) return acc\n      // We also need to check nested layers interactivity when custom gl layers are provided\n      if (layer.gl !== undefined) {\n        layer.gl.layers.forEach((glLayer, index) => {\n          // layers.length === 1 is used to ensure when parent layer is marked as interactive we have to\n          // have at least one interactive sublayer, then checked eah one individually\n          if (\n            layer.gl.layers.length === 1 ||\n            (glLayer.metadata !== undefined && glLayer.metadata['gfw:interactive'] === true)\n          ) {\n            const glLayerId = glLayer.id || index > 0 ? `${layer.id}-${index}` : layer.id\n            acc.push(glLayerId)\n          }\n        })\n      } else {\n        acc.push(layer.id)\n      }\n      return acc\n    }, [])\n  }\n)\n\nconst getMapStyles = (state) => state.map.style.mapStyle\nconst getMapStyle = createSelector(\n  [getMapStyles, getTracksStyles],\n  (mapStyles, trackStyles) => {\n    if (!trackStyles) return mapStyles\n\n    const currentLayerGroups = mapStyles\n      .toJS()\n      .layers.filter((l) => l.metadata !== undefined)\n      .map((l) => l.metadata['mapbox:group'])\n    const trackLayersIndex = currentLayerGroups.lastIndexOf(TRACKS_LAYER_IN_FRONT_OF_GROUP) + 1\n\n    let finalMapStyles = mapStyles.mergeIn(['sources'], trackStyles.sources)\n    let mapStylesLayers = mapStyles.get('layers')\n    trackStyles.layers.forEach((trackLayer, i) => {\n      mapStylesLayers = mapStylesLayers.insert(trackLayersIndex + i, fromJS(trackLayer))\n    })\n    finalMapStyles = finalMapStyles.set('layers', mapStylesLayers)\n    return finalMapStyles\n  }\n)\n\nconst getCursor = createSelector(\n  [getInternalCursor, getModuleCursor],\n  (internalCursor, moduleCursor) => {\n    if (moduleCursor !== null) {\n      return moduleCursor\n    }\n    return internalCursor\n  }\n)\nconst mapStateToProps = (state) => ({\n  viewport: state.map.viewport.viewport,\n  maxZoom: state.map.viewport.maxZoom,\n  minZoom: state.map.viewport.minZoom,\n  onLoad: state.map.module.onLoad,\n  cursor: getCursor(state),\n  token: state.map.module.token,\n  mapStyle: getMapStyle(state),\n  hasHeatmapLayers: hasHeatmapLayers(state),\n  interactiveLayerIds: getInteractiveLayerIds(state),\n})\n\nconst mapDispatchToProps = (dispatch) => ({\n  setViewport: (viewport, interactionState) => {\n    dispatch(setViewport(viewport, interactionState))\n  },\n  setBounds: (bounds) => {\n    dispatch(setBounds(bounds))\n  },\n  mapInteraction: (type, lat, long, features, cluster, glGetSource) => {\n    dispatch(mapInteraction(type, lat, long, features, cluster, glGetSource))\n  },\n  transitionEnd: () => {\n    dispatch(transitionEnd())\n  },\n  onClosePopup: () => {\n    dispatch(closePopup())\n  },\n})\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(Map)\n","import { fromJS } from 'immutable'\nimport uniq from 'lodash/uniq'\nimport GL_STYLE from './gl-styles/style.json'\nimport {\n  SET_MAP_STYLE,\n  MARK_CARTO_LAYERS_AS_INSTANCIATED,\n  INIT_MAP_STYLE,\n  SET_STATIC_LAYERS,\n  SET_BASEMAP_LAYERS,\n} from './style.actions'\n\nconst attributions = uniq(\n  Object.keys(GL_STYLE.sources)\n    .map((sourceKey) => GL_STYLE.sources[sourceKey].attribution)\n    .filter((source) => source !== undefined)\n)\n\nexport const setLayerStyleDefaults = (layer) => {\n  if (layer.layout === undefined) {\n    layer.layout = {}\n  }\n  if (layer.paint === undefined) {\n    layer.paint = {}\n  }\n  if (layer.metadata === undefined) {\n    layer.metadata = {}\n  }\n  // initialize time filter for time-filterable layers\n  if (layer.metadata['gfw:temporal'] === true) {\n    const temporalField =\n      layer.metadata['gfw:temporalField'] === undefined\n        ? 'timestamp'\n        : layer.metadata['gfw:temporalField']\n    layer.filter = ['all', ['>', temporalField, 0], ['<', temporalField, 999999999999]]\n  }\n\n  if (layer.metadata['mapbox:group'] === undefined) {\n    layer.metadata['mapbox:group'] = 'temporal'\n  }\n\n  // set all layers to not visible except layers explicitely marked as visible (default basemap)\n  if (layer.layout.visibility !== 'visible') {\n    layer.layout.visibility = 'none'\n  }\n  return layer\n}\n\nconst setStyleDefaults = (style) => {\n  style.layers.forEach((layer) => {\n    setLayerStyleDefaults(layer)\n  })\n  return style\n}\n\nconst initialState = {\n  mapStyle: fromJS(setStyleDefaults(GL_STYLE)),\n  cartoLayersInstanciated: [],\n  staticLayers: [],\n  basemapLayers: [],\n  attributions,\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case INIT_MAP_STYLE: {\n      const newMapStyle = state.mapStyle.setIn(['glyphs'], action.payload.glyphsPath)\n      return { ...state, mapStyle: newMapStyle }\n    }\n    case SET_MAP_STYLE: {\n      return { ...state, mapStyle: action.payload }\n    }\n    case SET_STATIC_LAYERS: {\n      return { ...state, staticLayers: action.payload }\n    }\n    case SET_BASEMAP_LAYERS: {\n      return { ...state, basemapLayers: action.payload }\n    }\n    case MARK_CARTO_LAYERS_AS_INSTANCIATED: {\n      const cartoLayersInstanciated = [...state.cartoLayersInstanciated, ...action.payload]\n      return { ...state, cartoLayersInstanciated }\n    }\n    default:\n      return state\n  }\n}\n","// This utility looks at GeoJSON features and returns the predominant geometry type\n\nconst TYPES = [\n  { gl: 'line', geoJSON: ['LineString', 'MultiLineString'] },\n  { gl: 'fill', geoJSON: ['Polygon', 'MultiPolygon'] },\n  { gl: 'circle', geoJSON: ['Point', 'MultiPoint'] },\n]\n\nexport default (geoJSON) => {\n  // collect all geoJSON geom types\n  const allGeoJSONTypes = geoJSON.features.map((feature) => {\n    const geom = feature.geometry\n    if (geom === undefined) {\n      return null\n    }\n    return geom.type\n  })\n\n  // collect number of geometries by GL geom types\n  const numByGLType = TYPES.map((type) => {\n    let num = 0\n    allGeoJSONTypes.forEach((geoJSONType) => {\n      if (type.geoJSON.indexOf(geoJSONType) > -1) {\n        num++\n      }\n    })\n    return { gl: type.gl, num }\n  })\n\n  // get feature types with the higher count\n  let glType = 'fill'\n  let glTypeMax = 0\n  numByGLType.forEach((t) => {\n    if (t.num > glTypeMax) {\n      glType = t.gl\n      glTypeMax = t.num\n    }\n  })\n\n  return glType\n}\n","import { fromJS } from 'immutable'\nimport convert from '@globalfishingwatch/map-convert'\nimport uniq from 'lodash/uniq'\nimport throttle from 'lodash/throttle'\nimport { hexToRgb } from '../utils/map-colors'\nimport { STATIC_LAYERS_CARTO_ENDPOINT, STATIC_LAYERS_CARTO_TILES_ENDPOINT } from '../config'\nimport { CUSTOM_LAYERS_SUBTYPES, GL_TRANSPARENT } from '../constants'\nimport GL_STYLE from './gl-styles/style.json'\nimport { setLayerStyleDefaults } from './style.reducer.js'\nimport getMainGeomType from '../utils/getMainGeomType'\n\nexport const INIT_MAP_STYLE = 'INIT_MAP_STYLE'\nexport const SET_MAP_STYLE = 'SET_MAP_STYLE'\nexport const MARK_CARTO_LAYERS_AS_INSTANCIATED = 'MARK_CARTO_LAYERS_AS_INSTANCIATED'\nexport const SET_STATIC_LAYERS = 'SET_STATIC_LAYERS'\nexport const SET_BASEMAP_LAYERS = 'SET_BASEMAP_LAYERS'\n\nconst setDefaultVectorTiles = (currentSource, refLayerUrl) => {\n  if (currentSource.type !== 'vector') {\n    return currentSource\n  }\n  const tiles = currentSource.tiles\n  const refLayerUrls = refLayerUrl === undefined ? [] : [refLayerUrl]\n\n  const newTiles =\n    tiles !== undefined && tiles.length > 0 ? uniq([...refLayerUrls, ...tiles]) : refLayerUrls\n  return {\n    ...currentSource,\n    tiles: newTiles,\n  }\n}\n\nexport const initStyle = ({ glyphsPath }) => ({\n  type: INIT_MAP_STYLE,\n  payload: {\n    glyphsPath,\n  },\n})\n\nconst setMapStyle = (style) => ({\n  type: SET_MAP_STYLE,\n  payload: style,\n})\n\nconst setStyleTemporalExtent = (dispatch, getState, temporalExtent, applyToThrottled = false) => {\n  const state = getState().map.style\n  let style = state.mapStyle\n  const currentStyle = style.toJS()\n  const glLayers = currentStyle.layers\n\n  let start = Math.round(temporalExtent[0].getTime() / 1000)\n  let end = Math.round(temporalExtent[1].getTime() / 1000)\n\n  // TEMPORARY, remove later - temporal layers points should have a timestamp, this is legacy\n  // logic for legacy encounters layer that only have a 'timeIndex'\n  const startIndex = convert.getOffsetedTimeAtPrecision(temporalExtent[0].getTime())\n  const endIndex = convert.getOffsetedTimeAtPrecision(temporalExtent[1].getTime())\n\n  for (let i = 0; i < glLayers.length; i++) {\n    const glLayer = glLayers[i]\n    if (glLayer.metadata === undefined || glLayer.metadata['gfw:temporal'] !== true) {\n      continue\n    }\n\n    if (\n      (applyToThrottled === true && glLayer.metadata['gfw:temporal:throttled'] !== true) ||\n      (applyToThrottled === false && glLayer.metadata['gfw:temporal:throttled'] === true)\n    ) {\n      continue\n    }\n\n    // if layer is temporal, a filter must always be preset on the style.json object\n    // because each layer can have a different time field to be filtered\n    const currentFilter = style.getIn(['layers', i, 'filter']).toJS()\n    if (currentFilter === null) {\n      throw new Error('filter must be preset on style.json for temporal layer: ', glLayer.id)\n    }\n\n    // TEMPORARY, remove later - temporal layers points should have a timestamp, this is legacy\n    // logic for legacy encounters layer that only have a 'timeIndex'\n    const isLegacy = glLayer.metadata && glLayer.metadata['gfw:temporalField'] === 'timeIndex'\n    currentFilter[1][2] = isLegacy ? startIndex : start\n    currentFilter[2][2] = isLegacy ? endIndex : end\n    style = style.setIn(['layers', i, 'filter'], fromJS(currentFilter))\n  }\n  dispatch(setMapStyle(style))\n}\n\nconst applyTemporalExtentThrottled = throttle((dispatch, getState, temporalExtent) => {\n  setStyleTemporalExtent(dispatch, getState, temporalExtent, true)\n}, 400)\n\nexport const applyTemporalExtent = (temporalExtent) => (dispatch, getState) => {\n  setStyleTemporalExtent(dispatch, getState, temporalExtent)\n  applyTemporalExtentThrottled(dispatch, getState, temporalExtent)\n}\n\nconst applyLayerExpressions = (style, refLayer, currentGlLayer, glLayerIndex) => {\n  let newStyle = style\n  const currentStyle = style.toJS()\n  const glType = currentGlLayer.type\n  const defaultStyles = currentStyle.metadata['gfw:styles']\n  const metadata = currentGlLayer.metadata\n  ;['selected', 'highlighted'].forEach((styleType) => {\n    // get selectedFeatures or highlightedFeatures\n    const features = refLayer[`${styleType}Features`]\n    const refLayerStyle = features && features.style ? features.style[glType] : {}\n    const hasFeatures = features !== null && features !== undefined && features.values.length > 0\n    const applyStyleToAllFeatures = refLayer[styleType]\n\n    const defaultStyle = defaultStyles[styleType][glType] || {}\n    const layerStyle =\n      (metadata && metadata['gfw:styles'] && metadata['gfw:styles'][styleType]) || {}\n    const allPaintProperties = { ...defaultStyle, ...layerStyle, ...refLayerStyle }\n\n    if (Object.keys(allPaintProperties).length) {\n      // go through each applicable gl paint property\n      Object.keys(allPaintProperties).forEach((glPaintProperty) => {\n        const selectedValue = allPaintProperties[glPaintProperty][0]\n        const fallbackValue = allPaintProperties[glPaintProperty][1]\n        const paintOrLayout = ['icon-size', 'icon-image'].includes(glPaintProperty)\n          ? 'layout'\n          : 'paint'\n        let glPaintFinalValue\n        if (\n          hasFeatures === false &&\n          applyStyleToAllFeatures !== true &&\n          applyStyleToAllFeatures !== false\n        ) {\n          // style reset when no features filter is declared and neither is applyAll\n          const originalLayerStyle = GL_STYLE.layers.find((l) => l.id === currentGlLayer.id)\n\n          if (originalLayerStyle !== undefined) {\n            // for reset: do not repaint with default style when layer as a custom main color property\n            if (\n              currentGlLayer.metadata &&\n              currentGlLayer.metadata['gfw:mainColorPaintProperty'] === glPaintProperty\n            ) {\n              glPaintFinalValue = null\n            } else {\n              glPaintFinalValue = originalLayerStyle[paintOrLayout][glPaintProperty]\n            }\n          } else {\n            // this will happen when no style exist in the original definition (ie custom layers)\n            // in this case set glPaintFinalValue to null and we'll just skip applying\n            // any selected/highlighted style for this layer\n            glPaintFinalValue = null\n          }\n        } else if (applyStyleToAllFeatures === true || applyStyleToAllFeatures === false) {\n          glPaintFinalValue = applyStyleToAllFeatures === true ? selectedValue : fallbackValue\n        } else {\n          let layerColorRgbString = ''\n          if (refLayer.color !== null && refLayer.color !== undefined) {\n            const layerColorRgb = hexToRgb(refLayer.color)\n            layerColorRgbString = `${layerColorRgb.r},${layerColorRgb.g},${layerColorRgb.b}`\n          }\n          glPaintFinalValue = [\n            'match',\n            ['get', features.field],\n            features.values,\n            typeof selectedValue !== 'string'\n              ? selectedValue\n              : selectedValue.replace('$REFLAYER_COLOR_RGB', layerColorRgbString),\n            typeof fallbackValue !== 'string'\n              ? fallbackValue\n              : fallbackValue.replace('$REFLAYER_COLOR_RGB', layerColorRgbString),\n          ]\n        }\n\n        if (glPaintFinalValue !== undefined && glPaintFinalValue !== null) {\n          newStyle = newStyle.setIn(\n            ['layers', glLayerIndex, paintOrLayout, glPaintProperty],\n            glPaintFinalValue\n          )\n        }\n      })\n    }\n  })\n  return newStyle\n}\n\nconst toggleLayerVisibility = (style, refLayer, glLayerIndex) => {\n  const visibility = refLayer.visible === true ? 'visible' : 'none'\n  return style.setIn(['layers', glLayerIndex, 'layout', 'visibility'], visibility)\n}\n\nconst updateGLLayer = (style, glLayerId, refLayer) => {\n  const currentStyle = style.toJS()\n  const currentStyleLayers = currentStyle.layers\n  let newStyle = style\n\n  const glLayerIndex = currentStyleLayers.findIndex((l) => l.id === glLayerId)\n  const glLayer = currentStyleLayers.find((l) => l.id === glLayerId)\n\n  // visibility\n  newStyle = toggleLayerVisibility(newStyle, refLayer, glLayerIndex)\n\n  if (refLayer.isBasemap === true) {\n    return newStyle\n  }\n\n  const refLayerOpacity = refLayer.opacity === undefined ? 1 : refLayer.opacity\n\n  // color/opacity\n  switch (glLayer.type) {\n    case 'fill': {\n      newStyle = newStyle\n        .setIn(['layers', glLayerIndex, 'paint', 'fill-opacity'], refLayerOpacity)\n        .setIn(['layers', glLayerIndex, 'paint', 'fill-outline-color'], refLayer.color)\n        .setIn(['layers', glLayerIndex, 'paint', 'fill-color'], GL_TRANSPARENT)\n      break\n    }\n    case 'line': {\n      const color = refLayer.color || (glLayer.paint && glLayer.paint['line-color'])\n      newStyle = newStyle\n        .setIn(['layers', glLayerIndex, 'paint', 'line-opacity'], refLayerOpacity)\n        .setIn(['layers', glLayerIndex, 'paint', 'line-color'], color)\n      break\n    }\n    case 'symbol': {\n      if (glLayer.metadata && glLayer.metadata['gfw:isLabel'] === true) {\n        const parentLayerIsVisible =\n          newStyle.getIn(['layers', glLayerIndex, 'layout', 'visibility']) === 'visible'\n        const labelsVisibility =\n          parentLayerIsVisible && refLayer.showLabels === true ? 'visible' : 'none'\n        newStyle = newStyle.setIn(\n          ['layers', glLayerIndex, 'layout', 'visibility'],\n          labelsVisibility\n        )\n        if (refLayer.showLabels !== true) {\n          break\n        }\n      }\n      newStyle = newStyle.setIn(['layers', glLayerIndex, 'paint', 'text-opacity'], refLayerOpacity)\n\n      if (refLayer.color !== undefined) {\n        newStyle = newStyle.setIn(['layers', glLayerIndex, 'paint', 'text-color'], refLayer.color)\n      }\n      break\n    }\n    // Event layers and custom layers with point geom types\n    case 'circle': {\n      newStyle = newStyle\n        .setIn(['layers', glLayerIndex, 'paint', 'circle-opacity'], refLayerOpacity)\n        .setIn(['layers', glLayerIndex, 'paint', 'circle-stroke-opacity'], refLayerOpacity)\n\n      if (refLayer.color !== undefined) {\n        const colorPaintProperty =\n          glLayer && glLayer.metadata && glLayer.metadata['gfw:mainColorPaintProperty']\n            ? glLayer.metadata['gfw:mainColorPaintProperty']\n            : 'circle-color'\n        newStyle = newStyle.setIn(\n          ['layers', glLayerIndex, 'paint', colorPaintProperty],\n          refLayer.color\n        )\n      }\n      break\n    }\n    case 'raster': {\n      newStyle = newStyle.setIn(\n        ['layers', glLayerIndex, 'paint', 'raster-opacity'],\n        refLayerOpacity\n      )\n      break\n    }\n    default: {\n      break\n    }\n  }\n\n  newStyle = applyLayerExpressions(newStyle, refLayer, glLayer, glLayerIndex)\n\n  return newStyle\n}\n\nconst addCustomGLLayer = (subtype, layerId, url, data) => (dispatch, getState) => {\n  const state = getState()\n  let style = state.map.style.mapStyle\n  const currentStyle = style.toJS()\n\n  // add source if it doesn't exist yet\n  if (currentStyle.sources[layerId] === undefined) {\n    const source = { type: subtype }\n    if (subtype === CUSTOM_LAYERS_SUBTYPES.geojson) {\n      source.data = data\n    } else if (subtype === CUSTOM_LAYERS_SUBTYPES.raster) {\n      source.tiles = [url]\n      source.tileSize = 256\n    }\n    style = style.setIn(['sources', layerId], fromJS(source))\n  }\n\n  if (currentStyle.layers.find((glLayer) => glLayer.id === layerId) === undefined) {\n    const glType = subtype === CUSTOM_LAYERS_SUBTYPES.geojson ? getMainGeomType(data) : subtype\n    const glLayer = fromJS({\n      id: layerId,\n      source: layerId,\n      type: glType,\n      layout: {},\n      paint: {},\n    })\n    const layerIndex =\n      subtype === CUSTOM_LAYERS_SUBTYPES.raster\n        ? // if raster, put at index of last raster layer except labels\n          currentStyle.layers.length -\n          1 -\n          currentStyle.layers\n            .filter((l) => l.id !== 'labels')\n            .reverse()\n            .findIndex((l) => l.type === 'raster')\n        : currentStyle.layers.length - 1\n    style = style.set('layers', style.get('layers').splice(layerIndex, 0, glLayer))\n  }\n\n  dispatch(setMapStyle(style))\n}\n\nconst updateWorkspaceGLLayers = (workspaceGLLayers) => (dispatch, getState) => {\n  const state = getState()\n  let style = state.map.style.mapStyle\n\n  workspaceGLLayers.forEach((workspaceGLLayer) => {\n    const { id, gl } = workspaceGLLayer\n    const finalSource = setDefaultVectorTiles(gl.source, workspaceGLLayer.url)\n    style = style.setIn(['sources', id], fromJS(finalSource))\n\n    const existingLayerIds = style\n      .get('layers')\n      .toJS()\n      .map((l) => l.id)\n    const layersToAdd = gl.layers.filter((layer, index) => {\n      const layerId = layer.id || index > 0 ? `${id}-${index}` : id\n      return !existingLayerIds.includes(layerId)\n    })\n    layersToAdd.forEach((layerToAdd, index) => {\n      // doesn't add a sufix in the first elements but it will for the following ones\n      let layerToAddId = layerToAdd.id || index > 0 ? `${id}-${index}` : id\n      const defaultGlLayer = setLayerStyleDefaults(layerToAdd)\n\n      const glLayer = {\n        ...defaultGlLayer,\n        id: layerToAddId,\n        source: id,\n      }\n\n      // set source-layer - defaults to source id\n      if (gl.source.type === 'vector') {\n        const sourceLayer =\n          layerToAdd['source-layer'] === undefined ? id : layerToAdd['source-layer']\n        glLayer['source-layer'] = sourceLayer\n      }\n\n      // find correct z-index\n      const existingLayers = style.get('layers')\n      const newLayerGroup = glLayer.metadata['mapbox:group']\n      const newLayerIndex = existingLayers.findLastIndex((l) => {\n        return newLayerGroup === l.toJS().metadata['mapbox:group']\n      })\n      style = style.set('layers', existingLayers.splice(newLayerIndex, 0, fromJS(glLayer)))\n    })\n  })\n\n  dispatch(setMapStyle(style))\n  dispatch(applyTemporalExtent(state.map.module.temporalExtent))\n}\n\nconst getCartoLayerInstanciatePromise = ({ sourceId, sourceCartoSQL }) => {\n  const mapConfig = { layers: [{ id: sourceId, options: { sql: sourceCartoSQL } }] }\n  const mapConfigURL = encodeURIComponent(JSON.stringify(mapConfig))\n  const cartoAnonymousMapUrl = STATIC_LAYERS_CARTO_ENDPOINT.replace('$MAPCONFIG', mapConfigURL)\n\n  return new Promise((resolve) => {\n    fetch(cartoAnonymousMapUrl)\n      .then((res) => {\n        if (res.status >= 400) {\n          console.warn(`loading of layer failed ${sourceId}`)\n          Promise.reject()\n          return null\n        }\n        return res.json()\n      })\n      .then((data) => {\n        resolve({\n          layergroupid: data.layergroupid,\n          sourceId,\n        })\n      })\n      .catch((err) => {\n        console.warn(err)\n      })\n  })\n}\n\nconst instanciateCartoLayers = (layers) => (dispatch, getState) => {\n  dispatch({\n    type: MARK_CARTO_LAYERS_AS_INSTANCIATED,\n    payload: layers.map((layer) => layer.sourceId),\n  })\n  const cartoLayersPromises = layers.map((layer) => getCartoLayerInstanciatePromise(layer))\n  const cartoLayersPromisesPromise = Promise.all(cartoLayersPromises.map((p) => p.catch((e) => e)))\n  cartoLayersPromisesPromise\n    .then((instanciatedCartoLayers) => {\n      let style = getState().map.style.mapStyle\n      const currentStyle = style.toJS()\n      instanciatedCartoLayers.forEach((cartoLayer) => {\n        const tilesURL = STATIC_LAYERS_CARTO_TILES_ENDPOINT.replace(\n          '$LAYERGROUPID',\n          cartoLayer.layergroupid\n        )\n\n        // replace gl source with a new source that use tiles provided by Carto anonymous maps API\n        const newSourceId = `${cartoLayer.sourceId}-instanciated`\n        style = style.setIn(\n          ['sources', newSourceId],\n          fromJS({\n            type: 'vector',\n            tiles: [tilesURL],\n          })\n        )\n\n        style = style.deleteIn(['sources', cartoLayer.sourceId])\n\n        // change source in all layers that are using it (generally polygon + labels)\n        currentStyle.layers.forEach((glLayer, glLayerIndex) => {\n          if (glLayer.source === cartoLayer.sourceId) {\n            style = style.setIn(['layers', glLayerIndex, 'source'], newSourceId)\n            style = style.setIn(['layers', glLayerIndex, 'metadata', 'gfw:id'], cartoLayer.sourceId)\n            const refLayer = layers.find((l) => l.refLayer.id === cartoLayer.sourceId).refLayer\n            style = updateGLLayer(style, glLayer.id, refLayer)\n          }\n        })\n      })\n\n      dispatch(setMapStyle(style))\n    })\n    .catch((err) => {\n      console.warn(err)\n    })\n}\n\nexport const commitStyleUpdates = (staticLayers, basemapLayers) => (dispatch, getState) => {\n  // Store a copy of static and basemap layers. This is not used directly by\n  // the Map component which only needs a prepared style object\n  dispatch({\n    type: SET_STATIC_LAYERS,\n    payload: staticLayers,\n  })\n  dispatch({\n    type: SET_BASEMAP_LAYERS,\n    payload: basemapLayers,\n  })\n\n  const layers = [...staticLayers, ...basemapLayers.map((bl) => ({ ...bl, isBasemap: true }))]\n\n  const currentGLSources = getState().map.style.mapStyle.toJS().sources\n\n  // collect layers declared in workspace but not in original gl style\n  const workspaceGLLayers = layers.filter((layer) => layer.gl !== undefined)\n\n  if (workspaceGLLayers.length) {\n    // Adds the gl layers again in case the source is a dynamic geojson source\n    dispatch(updateWorkspaceGLLayers(workspaceGLLayers))\n  }\n\n  // instanciate custom layers if needed\n  const customLayers = layers.filter(\n    (layer) => layer.isCustom === true && currentGLSources[layer.id] === undefined\n  )\n  if (customLayers.length) {\n    customLayers.forEach((layer) => {\n      dispatch(addCustomGLLayer(layer.subtype, layer.id, layer.url, layer.data))\n    })\n  }\n\n  const state = getState().map.style\n  let style = state.mapStyle\n  const currentStyle = style.toJS()\n  const glLayers = currentStyle.layers\n  const glSources = currentStyle.sources\n\n  const cartoLayersToInstanciate = []\n\n  // update source when needed\n  staticLayers.forEach((refLayer) => {\n    const sourceId = refLayer.id\n    if (currentGLSources[sourceId] !== undefined && refLayer.visible === true) {\n      if (refLayer.data !== undefined) {\n        style = style.setIn(['sources', sourceId, 'data'], fromJS(refLayer.data))\n      }\n      if (refLayer.url !== undefined) {\n        const newSource = setDefaultVectorTiles(currentGLSources[sourceId], refLayer.url)\n        style = style.setIn(['sources', sourceId], fromJS(newSource))\n      }\n    }\n  })\n\n  for (let i = 0; i < glLayers.length; i++) {\n    const glLayer = glLayers[i]\n    const sourceId = glLayer.source\n    const glSource = glSources[sourceId]\n    const layerId = (glLayer.metadata !== undefined && glLayer.metadata['gfw:id']) || sourceId\n\n    const refLayer = layers.find((l) => l.id === layerId)\n\n    if (refLayer === undefined) {\n      if (glLayer.type !== 'background') {\n        // console.warn('gl layer does not exists in workspace', glLayer);\n      }\n      continue\n    }\n\n    // check if layer is served from Carto, which means we need to instanciate it first\n    // TODO BUG: check if layer is not instanciatING too\n    const sourceCartoSQL = glSource.metadata !== undefined && glSource.metadata['gfw:carto-sql']\n    if (sourceCartoSQL !== false && sourceCartoSQL !== undefined) {\n      // only if layer is visible and has not been instanciated yet\n      const cartoLayerInstanciated = state.cartoLayersInstanciated.indexOf(sourceId) > -1\n      if (\n        refLayer.visible === true &&\n        !cartoLayerInstanciated &&\n        !cartoLayersToInstanciate.find((l) => l.sourceId === sourceId)\n      ) {\n        cartoLayersToInstanciate.push({ sourceId, sourceCartoSQL, refLayer })\n      }\n      continue\n    }\n\n    style = updateGLLayer(style, glLayer.id, refLayer)\n  }\n\n  if (cartoLayersToInstanciate.length) {\n    dispatch(instanciateCartoLayers(cartoLayersToInstanciate))\n  }\n\n  dispatch(setMapStyle(style))\n}\n","import FlyToInterpolator from 'react-map-gl/dist/esm/utils/transition/viewport-fly-to-interpolator'\nimport { easeCubic } from 'd3-ease'\nimport { MIN_ZOOM_LEVEL, MAX_ZOOM_LEVEL } from '../config'\nimport { TRANSITION_TYPE } from '../constants'\nimport {\n  SET_BOUNDS,\n  SET_VIEWPORT,\n  UPDATE_VIEWPORT,\n  SET_ZOOM_INCREMENT,\n  SET_MOUSE_LAT_LONG,\n  TRANSITION_END,\n  SET_NATIVE_VIEWPORT,\n} from './viewport.actions'\n\nexport const TRANSITION_DURATION = 500\n\nconst DEFAULT_TRANSITION = {\n  transitionDuration: TRANSITION_DURATION,\n  transitionInterpolator: new FlyToInterpolator(),\n  transitionEasing: easeCubic,\n}\n\nconst initialState = {\n  viewport: {\n    latitude: 0,\n    longitude: 0,\n    zoom: 3,\n    bearing: 0,\n    pitch: 0,\n    width: 1000,\n    height: 800,\n    bounds: {},\n  },\n  maxZoom: MAX_ZOOM_LEVEL,\n  minZoom: MIN_ZOOM_LEVEL,\n  prevZoom: 3,\n  currentTransition: null,\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case SET_VIEWPORT: {\n      return {\n        ...state,\n        viewport: action.payload,\n        canZoomIn: action.payload.zoom < state.maxZoom,\n        canZoomOut: action.payload.zoom > state.minZoom,\n        prevZoom: state.viewport.zoom,\n      }\n    }\n\n    case SET_BOUNDS: {\n      return {\n        ...state,\n        bounds: action.payload,\n      }\n    }\n\n    case UPDATE_VIEWPORT: {\n      const viewport = { ...state.viewport, ...action.payload }\n      return {\n        ...state,\n        viewport,\n        prevZoom: viewport.zoom,\n      }\n    }\n\n    case SET_ZOOM_INCREMENT: {\n      const currentZoom = state.viewport.zoom\n      const zoom = Math.min(\n        state.maxZoom,\n        action.payload.zoom || currentZoom + action.payload.increment\n      )\n      const viewport = {\n        ...state.viewport,\n        ...DEFAULT_TRANSITION,\n        zoom,\n        latitude:\n          action.payload.latitude === null ? state.viewport.latitude : action.payload.latitude,\n        longitude:\n          action.payload.longitude === null ? state.viewport.longitude : action.payload.longitude,\n      }\n      return {\n        ...state,\n        viewport,\n        canZoomIn: zoom < state.maxZoom,\n        canZoomOut: zoom > state.minZoom,\n        prevZoom: state.viewport.zoom,\n        currentTransition: TRANSITION_TYPE.ZOOM,\n      }\n    }\n\n    case SET_MOUSE_LAT_LONG: {\n      return { ...state, mouseLatLong: action.payload }\n    }\n\n    case TRANSITION_END: {\n      return { ...state, currentTransition: null }\n    }\n\n    case SET_NATIVE_VIEWPORT: {\n      return { ...state, ...action.payload }\n    }\n\n    default:\n      return state\n  }\n}\n","import { compose, createStore, applyMiddleware } from 'redux'\nimport thunk from 'redux-thunk'\n\nimport { TRANSITION_DURATION } from '../glmap/viewport.reducer'\nimport { fitToBounds as fitToBoundsAction, transitionEnd } from '../glmap/viewport.actions'\n\nlet composeEnhancers = compose\nif (\n  (process.env.MAP_REDUX_REMOTE_DEBUG || process.env.REACT_APP_MAP_REDUX_REMOTE_DEBUG) &&\n  process.env.NODE_ENV === 'development'\n) {\n  const composeWithDevTools = require('remote-redux-devtools').composeWithDevTools\n  composeEnhancers = composeWithDevTools({\n    name: 'Map module',\n    realtime: true,\n    hostname: 'localhost',\n    port: 8000,\n    maxAge: 30,\n    stateSanitizer: (state) => ({ ...state, map: { ...state.map, heatmap: 'NOT_SERIALIZED' } }),\n  })\n}\n\nconst store = createStore(() => {}, {}, composeEnhancers(applyMiddleware(thunk)))\n\nexport const targetMapVessel = (id) => {\n  const track = store.getState().map.tracks.data.find((t) => t.id === id.toString())\n  store.dispatch(fitToBoundsAction(track.geoBounds))\n\n  return track.timelineBounds\n}\nexport const fitToBounds = (bounds) => {\n  store.dispatch(fitToBoundsAction(bounds))\n  setTimeout(() => {\n    // needed as the transition end is not being called on first fitToBounds trigger\n    if (store.getState().map.viewport.currentTransition !== null) {\n      store.dispatch(transitionEnd())\n    }\n  }, TRANSITION_DURATION + 1)\n}\n\nexport default store\n","import tbbox from '@turf/bbox'\nimport { targetMapVessel } from '../store'\n\nimport {\n  getTilePromises,\n  getCleanVectorArrays,\n  groupData,\n  addTracksPointsRenderingData,\n  getTracksPlaybackData,\n} from '../utils/heatmapTileData'\nimport { startLoader, completeLoader } from '../module/module.actions'\n\nexport const ADD_TRACK = 'ADD_TRACK'\nexport const UPDATE_TRACK = 'UPDATE_TRACK'\nexport const REMOVE_TRACK = 'REMOVE_TRACK'\n\nconst getTrackDataParsed = (geojson) => {\n  const time = { start: Infinity, end: 0 }\n  if (geojson && geojson.features) {\n    geojson.features.forEach((feature) => {\n      const hasTimes =\n        feature.properties &&\n        feature.properties.coordinateProperties &&\n        feature.properties.coordinateProperties.times &&\n        feature.properties.coordinateProperties.times.length > 0\n      if (hasTimes) {\n        feature.properties.coordinateProperties.times.forEach((datetime) => {\n          if (datetime < time.start) {\n            time.start = datetime\n          } else if (datetime > time.end) {\n            time.end = datetime\n          }\n        })\n      }\n    })\n  }\n  return {\n    geojson,\n    timelineBounds: [time.start, time.end],\n  }\n}\n\nconst getTrackBounds = (geojson) => {\n  const bounds = tbbox(geojson)\n  return {\n    minLat: bounds[3],\n    minLng: bounds[0],\n    maxLat: bounds[1],\n    maxLng: bounds[2],\n  }\n}\n\n// Deprecated tracks format parsing\nconst getOldTrackBoundsFormat = (data, addOffset = false) => {\n  const time = {\n    start: Infinity,\n    end: 0,\n  }\n  const geo = {\n    minLat: Infinity,\n    maxLat: -Infinity,\n    minLng: Infinity,\n    maxLng: -Infinity,\n  }\n  for (let i = 0, length = data.datetime.length; i < length; i++) {\n    const datetime = data.datetime[i]\n    if (datetime < time.start) {\n      time.start = datetime\n    } else if (datetime > time.end) {\n      time.end = datetime\n    }\n\n    const lat = data.latitude[i]\n    if (lat < geo.minLat) {\n      geo.minLat = lat\n    } else if (lat > geo.maxLat) {\n      geo.maxLat = lat\n    }\n\n    let lng = data.longitude[i]\n    if (addOffset === true) {\n      if (lng < 0) {\n        lng += 360\n      }\n    }\n    if (lng < geo.minLng) {\n      geo.minLng = lng\n    } else if (lng > geo.maxLng) {\n      geo.maxLng = lng\n    }\n  }\n\n  // track crosses the antimeridian\n  if (geo.maxLng - geo.minLng > 350 && addOffset === false) {\n    return getOldTrackBoundsFormat(data, true)\n  }\n\n  return {\n    time: [time.start, time.end],\n    geo,\n  }\n}\n\nfunction loadTrack(track) {\n  return (dispatch, getState) => {\n    const { id, url, type, fitBoundsOnLoad, layerTemporalExtents, color, data } = track\n    const state = getState()\n    if (state.map.tracks.data.find((t) => t.id === id)) {\n      return\n    }\n\n    const payload = {\n      id,\n      url,\n      type,\n      color,\n      fitBoundsOnLoad,\n    }\n    const trackHasData = track.data !== undefined && track.data !== null\n    const trackHasUrl = url !== undefined && url !== null && url !== ''\n    if (trackHasData) {\n      payload.data = data\n      payload.geoBounds = getTrackBounds(data)\n    }\n    dispatch({ type: ADD_TRACK, payload })\n\n    if (trackHasData || !trackHasUrl) {\n      return\n    }\n\n    const loaderID = startLoader(dispatch, state)\n    if (type !== 'geojson') {\n      // Deprecated tracks format logic to be deleted some day\n      const token = state.map.module.token\n\n      const promises = getTilePromises(url, token, layerTemporalExtents)\n\n      Promise.all(promises.map((p) => p.catch((e) => e))).then((rawTileData) => {\n        const cleanData = getCleanVectorArrays(rawTileData)\n\n        if (!cleanData.length) {\n          return\n        }\n        const rawTrackData = groupData(cleanData, [\n          'latitude',\n          'longitude',\n          'datetime',\n          'series',\n          'weight',\n          'sigma',\n        ])\n\n        const vectorArray = addTracksPointsRenderingData(rawTrackData)\n        const bounds = getOldTrackBoundsFormat(rawTrackData)\n\n        dispatch({\n          type: UPDATE_TRACK,\n          payload: {\n            id,\n            data: getTracksPlaybackData(vectorArray),\n            geoBounds: bounds.geo,\n            timelineBounds: bounds.time,\n          },\n        })\n        dispatch(completeLoader(loaderID))\n      })\n    } else {\n      fetch(url)\n        .then((res) => {\n          if (res.status >= 400) throw new Error(res.statusText)\n          return res.json()\n        })\n        .then((data) => {\n          const { geojson, timelineBounds } = getTrackDataParsed(data)\n          const geoBounds = getTrackBounds(data)\n          dispatch({\n            type: UPDATE_TRACK,\n            payload: {\n              id,\n              data: geojson,\n              geoBounds,\n              timelineBounds,\n            },\n          })\n          if (fitBoundsOnLoad) {\n            targetMapVessel(id)\n          }\n        })\n        .catch((err) => console.warn(err))\n        .finally(() => dispatch(completeLoader(loaderID)))\n    }\n  }\n}\n\nconst removeTrack = (trackId) => ({\n  type: REMOVE_TRACK,\n  payload: {\n    trackId,\n  },\n})\n\nexport const updateTracks = (newTracks = []) => (dispatch, getState) => {\n  const prevTracks = getState().map.tracks.data\n  // add and update layers\n  if (newTracks) {\n    newTracks.forEach((newTrack) => {\n      const trackId = newTrack.id\n      const prevTrack = prevTracks.find((t) => t.id === trackId)\n      if (prevTrack === undefined) {\n        dispatch(loadTrack(newTrack))\n      } else if (prevTrack.color !== newTrack.color) {\n        dispatch({\n          type: UPDATE_TRACK,\n          payload: {\n            id: newTrack.id,\n            color: newTrack.color,\n          },\n        })\n      }\n    })\n  }\n\n  // clean up unused tracks\n  prevTracks.forEach((prevTrack) => {\n    if (!newTracks || !newTracks.find((t) => t.id === prevTrack.id)) {\n      dispatch(removeTrack(prevTrack.id))\n    }\n  })\n}\n","import PropTypes from 'prop-types'\n\nconst withReducerPropTypes = (name, propTypesSchema) => (reducer) => {\n  if (process.env.NODE_ENV === 'development') {\n    return (state, action) => {\n      const result = reducer(state, action)\n      PropTypes.checkPropTypes(propTypesSchema, result, 'reducer', name)\n\n      return result\n    }\n  }\n  return reducer\n}\n\nexport default withReducerPropTypes\n","import PropTypes from 'prop-types'\nimport withReducerTypes from '../utils/withReducerTypes'\nimport {\n  INIT_MODULE,\n  SET_TEMPORAL_EXTENT,\n  SET_HIGHLIGHT_TEMPORAL_EXTENT,\n  START_LOADER,\n  COMPLETE_LOADER,\n  SET_MODULE_CURSOR,\n} from './module.actions'\n\nconst initialState = {\n  loaders: null,\n  token: undefined,\n  temporalExtent: [new Date(1970), new Date()],\n  highlightTemporalExtent: null,\n  cursor: null,\n  onViewportChange: undefined,\n  onHover: undefined,\n  onClick: undefined,\n  onLoad: undefined,\n  onLoadStart: undefined,\n  onLoadComplete: undefined,\n  onClosePopup: undefined,\n  onAttributionsChange: undefined,\n}\n\nconst moduleReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case INIT_MODULE: {\n      return {\n        ...state,\n        ...action.payload,\n      }\n    }\n\n    case SET_TEMPORAL_EXTENT: {\n      return {\n        ...state,\n        temporalExtent: action.payload,\n      }\n    }\n\n    case SET_HIGHLIGHT_TEMPORAL_EXTENT: {\n      return {\n        ...state,\n        highlightTemporalExtent: action.payload,\n      }\n    }\n\n    case START_LOADER: {\n      const loaders = state.loaders !== null ? [...state.loaders] : []\n      loaders.push(action.payload)\n      return { ...state, loaders }\n    }\n\n    case COMPLETE_LOADER: {\n      const loaders = [...state.loaders]\n      const loaderIndex = loaders.findIndex((l) => l === action.payload)\n      loaders.splice(loaderIndex, 1)\n      return { ...state, loaders }\n    }\n\n    case SET_MODULE_CURSOR: {\n      return { ...state, cursor: action.payload }\n    }\n\n    default:\n      return state\n  }\n}\n\nconst moduleTypes = {\n  loaders: PropTypes.arrayOf(PropTypes.number),\n  token: PropTypes.string,\n  temporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  onViewportChange: PropTypes.func,\n  onHover: PropTypes.func,\n  onClick: PropTypes.func,\n  onLoad: PropTypes.func,\n  onLoadStart: PropTypes.func,\n  onLoadComplete: PropTypes.func,\n  onClosePopup: PropTypes.func,\n  onAttributionsChange: PropTypes.func,\n}\n\nexport default withReducerTypes('module', moduleTypes)(moduleReducer)\n","import PropTypes from 'prop-types'\nimport { trackTypes } from '../proptypes/tracks'\nimport withReducerTypes from '../utils/withReducerTypes'\n\nimport { ADD_TRACK, UPDATE_TRACK, REMOVE_TRACK } from './tracks.actions'\n\nconst initialState = {\n  data: [],\n}\n\nconst tracksReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case ADD_TRACK: {\n      const data = [...state.data, action.payload]\n      return { ...state, data }\n    }\n\n    case UPDATE_TRACK: {\n      const trackData = action.payload\n      const data = state.data.map((track) => {\n        if (track.id !== trackData.id) return track\n        return {\n          ...track,\n          ...trackData,\n        }\n      })\n      return { ...state, data }\n    }\n\n    case REMOVE_TRACK: {\n      const removedTrackId = action.payload.trackId\n      const data = state.data.filter((track) => track.id !== removedTrackId)\n      return { ...state, data }\n    }\n\n    default:\n      return state\n  }\n}\n\nconst tracksTypes = {\n  data: PropTypes.arrayOf(\n    PropTypes.exact({\n      ...trackTypes,\n      data: PropTypes.object,\n      timelineBounds: PropTypes.array,\n      geoBounds: PropTypes.exact({\n        minLat: PropTypes.number,\n        minLng: PropTypes.number,\n        maxLat: PropTypes.number,\n        maxLng: PropTypes.number,\n      }),\n    })\n  ),\n}\n\nexport default withReducerTypes('tracks', tracksTypes)(tracksReducer)\n","import difference from 'lodash/difference'\nimport {\n  INIT_HEATMAP_LAYERS,\n  UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES,\n  ADD_HEATMAP_LAYER,\n  UPDATE_HEATMAP_LAYER_STYLE,\n  REMOVE_HEATMAP_LAYER,\n  ADD_REFERENCE_TILE,\n  UPDATE_HEATMAP_TILE,\n  RELEASE_HEATMAP_TILES,\n  HIGHLIGHT_VESSELS,\n  UPDATE_LOADED_TILES,\n  HIGHLIGHT_CLICKED_VESSEL,\n  CLEAR_HIGHLIGHT_CLICKED_VESSEL,\n} from './heatmap.actions'\n\nconst initialState = {\n  // a dict of heatmap layers (key is layer id)\n  // each containing data, url, tiles, visibleTemporalExtentsIndices\n  heatmapLayers: {},\n  // store a list of tiles currently visible in the map\n  // those are necessary when adding a new layer to know which tiles need to be loaded\n  referenceTiles: [],\n  highlightedVessels: { isEmpty: true },\n  highlightedClickedVessel: null,\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case INIT_HEATMAP_LAYERS: {\n      return Object.assign({}, state, { heatmapLayers: action.payload })\n    }\n\n    case UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES: {\n      const heatmapLayers = state.heatmapLayers\n      heatmapLayers[action.payload.layerId].visibleTemporalExtentsIndices =\n        action.payload.newVisibleTemporalExtentsIndices\n\n      // also removing indices within each tile\n      // adding is done after tile has actually loaded\n      heatmapLayers[action.payload.layerId].tiles.forEach((tile) => {\n        tile.temporalExtentsIndicesLoaded = difference(\n          tile.temporalExtentsIndicesLoaded,\n          action.payload.indicesRemoved\n        )\n      })\n      return { ...state, heatmapLayers }\n    }\n\n    case ADD_HEATMAP_LAYER: {\n      const heatmapLayers = Object.assign({}, state.heatmapLayers, {\n        [action.payload.id]: {\n          tiles: [],\n          ...action.payload,\n        },\n      })\n      return Object.assign({}, state, { heatmapLayers })\n    }\n\n    case UPDATE_HEATMAP_LAYER_STYLE: {\n      const newLayer = action.payload\n      const layer = { ...state.heatmapLayers[newLayer.id], ...newLayer }\n      const heatmapLayers = { ...state.heatmapLayers, [newLayer.id]: layer }\n      return { ...state, heatmapLayers }\n    }\n\n    case REMOVE_HEATMAP_LAYER: {\n      const heatmapLayers = Object.assign({}, state.heatmapLayers)\n      delete heatmapLayers[action.payload.id]\n      return Object.assign({}, state, { heatmapLayers })\n    }\n\n    case ADD_REFERENCE_TILE: {\n      return Object.assign({}, state, { referenceTiles: [...state.referenceTiles, action.payload] })\n    }\n\n    case UPDATE_HEATMAP_TILE: {\n      const layerId = action.payload.layerId\n      const newTile = action.payload.tile\n      const layer = { ...state.heatmapLayers[layerId] }\n      let layerTiles = [...layer.tiles]\n      const tileIndex = layerTiles.findIndex((t) => t.uid === newTile.uid)\n      if (tileIndex === -1) {\n        layerTiles.push(newTile)\n      } else {\n        layerTiles = [\n          ...layerTiles.slice(0, tileIndex),\n          newTile,\n          ...layerTiles.slice(tileIndex + 1),\n        ]\n      }\n      layer.tiles = layerTiles\n      const heatmapLayers = { ...state.heatmapLayers, [layerId]: layer }\n      return { ...state, heatmapLayers }\n    }\n\n    case RELEASE_HEATMAP_TILES: {\n      const uids = action.payload\n\n      // remove tiles\n      const layerIds = Object.keys(state.heatmapLayers)\n      const heatmapLayers = { ...state.heatmapLayers }\n      layerIds.forEach((layerId) => {\n        const prevLayer = { ...heatmapLayers[layerId] }\n        uids.forEach((tileUid) => {\n          const releasedTileIndex = prevLayer.tiles.findIndex((tile) => tile.uid === tileUid)\n          if (releasedTileIndex > -1) {\n            // console.log('releasing', layerId, tileUid);\n            prevLayer.tiles.splice(releasedTileIndex, 1)\n          }\n        })\n      })\n\n      // remove reference tiles\n      let referenceTiles = [...state.referenceTiles]\n      uids.forEach((tileUid) => {\n        const releasedRefTileIndex = referenceTiles.findIndex((tile) => tile.uid === tileUid)\n        if (releasedRefTileIndex > -1) {\n          referenceTiles = [\n            ...referenceTiles.slice(0, releasedRefTileIndex),\n            ...referenceTiles.slice(releasedRefTileIndex + 1),\n          ]\n        }\n      })\n\n      return { ...state, heatmapLayers, referenceTiles }\n    }\n\n    case UPDATE_LOADED_TILES: {\n      const newHeatmapLayers = { ...state.heatmapLayers }\n      return { ...state, heatmapLayers: newHeatmapLayers }\n    }\n\n    case HIGHLIGHT_VESSELS: {\n      return Object.assign({}, state, { highlightedVessels: action.payload })\n    }\n\n    case HIGHLIGHT_CLICKED_VESSEL: {\n      return { ...state, highlightedClickedVessel: action.payload }\n    }\n\n    case CLEAR_HIGHLIGHT_CLICKED_VESSEL: {\n      return { ...state, highlightedClickedVessel: null }\n    }\n\n    default:\n      return state\n  }\n}\n","import uniq from 'lodash/uniq'\nimport {\n  SET_CURRENTLY_VISIBLE_TILES,\n  SET_CURRENTLY_LOADED_TILES,\n  SET_CURRENTLY_SWAPPED_TILE_UIDS,\n  MARK_TILES_UIDS_AS_LOADED,\n  RELEASE_MARKED_TILES_UIDS,\n} from './heatmapTiles.actions'\n\nconst initialState = {\n  currentVisibleTiles: [],\n  currentLoadedTiles: [],\n  currentToLoadTileUids: [],\n  currentToReleaseTileUids: [],\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case SET_CURRENTLY_VISIBLE_TILES: {\n      const currentVisibleTiles = [].concat(action.payload)\n      return { ...state, currentVisibleTiles }\n    }\n\n    case SET_CURRENTLY_LOADED_TILES: {\n      const currentLoadedTiles = [].concat(action.payload)\n      return { ...state, currentLoadedTiles }\n    }\n\n    case SET_CURRENTLY_SWAPPED_TILE_UIDS: {\n      const currentToLoadTileUids = uniq(\n        state.currentToLoadTileUids.concat(action.payload.tilesToLoadUids)\n      )\n      const currentToReleaseTileUids = uniq(\n        state.currentToReleaseTileUids.concat(action.payload.tilesToReleaseUids)\n      )\n      // clean to load tiles of tiles that needs to be released\n      const newToLoadTilesUids = currentToLoadTileUids.filter(\n        (tileUid) => currentToReleaseTileUids.indexOf(tileUid) === -1\n      )\n      return { ...state, currentToLoadTileUids: newToLoadTilesUids, currentToReleaseTileUids }\n    }\n\n    case MARK_TILES_UIDS_AS_LOADED: {\n      const currentToLoadTileUids = state.currentToLoadTileUids\n      const tileUidsMarkedAsLoaded = action.payload\n      const newCurrentToLoadTileUids = currentToLoadTileUids.filter(\n        (tileUid) => tileUidsMarkedAsLoaded.indexOf(tileUid) === -1\n      )\n      return { ...state, currentToLoadTileUids: newCurrentToLoadTileUids }\n    }\n\n    case RELEASE_MARKED_TILES_UIDS: {\n      return { ...state, currentToReleaseTileUids: [] }\n    }\n\n    default:\n      return state\n  }\n}\n","// TODO MAP MODULE remove whole reducer\nimport { SET_MAP_CURSOR } from './interaction.actions'\n\nconst initialState = {\n  cursor: 'progress',\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case SET_MAP_CURSOR: {\n      return { ...state, cursor: action.payload }\n    }\n    default:\n      return state\n  }\n}\n","import { combineReducers } from 'redux'\n\nimport ModuleReducer from '../module/module.reducer'\nimport TracksReducer from '../tracks/tracks.reducer'\nimport HeatmapReducer from '../heatmap/heatmap.reducer'\nimport HeatmapTilesReducer from '../heatmap/heatmapTiles.reducer'\nimport ViewportReducer from '../glmap/viewport.reducer'\nimport StyleReducer from '../glmap/style.reducer'\nimport InteractionReducer from '../glmap/interaction.reducer'\n\nconst mapReducer = combineReducers({\n  module: ModuleReducer,\n  tracks: TracksReducer,\n  heatmap: HeatmapReducer,\n  heatmapTiles: HeatmapTilesReducer,\n  style: StyleReducer,\n  viewport: ViewportReducer,\n  interaction: InteractionReducer,\n})\n\nexport default mapReducer\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { combineReducers } from 'redux'\nimport { Provider } from 'react-redux'\nimport throttle from 'lodash/throttle'\nimport { trackTypes } from './proptypes/tracks'\nimport { heatmapLayerTypes, basemapLayerTypes, staticLayerTypes } from './proptypes/layers'\nimport { viewportTypes, popupTypes } from './proptypes/shared'\n\nimport Map from './glmap/Map.container'\nimport {\n  initModule,\n  setTemporalExtent,\n  setHighlightTemporalExtent,\n  setCursor,\n} from './module/module.actions'\nimport { updateViewport, transitionToZoom } from './glmap/viewport.actions'\nimport { initStyle, commitStyleUpdates, applyTemporalExtent } from './glmap/style.actions'\nimport { updateTracks } from './tracks/tracks.actions'\nimport { updateHeatmapLayers, updateLayerLoadTemporalExtents } from './heatmap/heatmap.actions'\n\nimport store from './store'\nimport mapReducers from './store/reducers'\n\nconst mapReducer = combineReducers({\n  map: mapReducers,\n})\n\nstore.replaceReducer(mapReducer)\n\nconst throttleApplyTemporalExtent = throttle((temporalExtent) => {\n  store.dispatch(applyTemporalExtent(temporalExtent))\n  store.dispatch(setTemporalExtent(temporalExtent))\n}, 16)\n\nconst updateViewportFromIncomingProps = (incomingViewport) => {\n  store.dispatch(\n    updateViewport({\n      latitude: incomingViewport.center[0],\n      longitude: incomingViewport.center[1],\n      zoom: incomingViewport.zoom,\n    })\n  )\n}\n\nclass MapModule extends React.Component {\n  state = {\n    initialized: false,\n    error: null,\n    errorInfo: null,\n  }\n\n  componentDidCatch(error, errorInfo) {\n    console.log(error, errorInfo)\n    this.setState({\n      error: error,\n      errorInfo: errorInfo,\n    })\n  }\n\n  componentDidMount() {\n    // First trigger synchronous actions that should happen before any map render\n    // At the end of this, set a flag to allow map rendering\n\n    if (this.props.viewport !== undefined) {\n      updateViewportFromIncomingProps(this.props.viewport)\n    }\n\n    // TODO\n    if (this.props.glyphsPath !== null) {\n      store.dispatch(\n        initStyle({\n          glyphsPath: this.props.glyphsPath,\n          // TODO apply URL updates here\n        })\n      )\n    }\n\n    if (this.props.onAttributionsChange !== undefined) {\n      this.props.onAttributionsChange(store.getState().map.style.attributions)\n    }\n\n    if (store && store.getState().map.module.token === undefined) {\n      store.dispatch(\n        initModule({\n          token: this.props.token,\n          autoClusterZoom: this.props.autoClusterZoom,\n          isCluster: this.props.isCluster,\n          onViewportChange: this.props.onViewportChange,\n          onHover: this.props.onHover,\n          onClick: this.props.onClick,\n          onLoad: this.props.onLoad,\n          onLoadStart: this.props.onLoadStart,\n          onLoadComplete: this.props.onLoadComplete,\n          onClosePopup: this.props.onClosePopup,\n          onAttributionsChange: this.props.onAttributionsChange,\n        })\n      )\n    }\n\n    if (this.props.highlightTemporalExtent !== null && this.props.highlightTemporalExtent.length) {\n      store.dispatch(setHighlightTemporalExtent(this.props.highlightTemporalExtent))\n    }\n\n    if (\n      (this.props.basemapLayers !== null && this.props.basemapLayers.length) ||\n      (this.props.staticLayers !== null && this.props.staticLayers.length)\n    ) {\n      store.dispatch(\n        commitStyleUpdates(this.props.staticLayers || [], this.props.basemapLayers || [])\n      )\n    }\n\n    if (this.props.tracks !== null) {\n      store.dispatch(updateTracks(this.props.tracks))\n    }\n\n    // Now trigger async actions\n\n    if (this.props.temporalExtent !== null && this.props.temporalExtent.length) {\n      throttleApplyTemporalExtent(this.props.temporalExtent)\n    }\n\n    // eslint-disable-next-line react/no-did-mount-set-state\n    this.setState({\n      initialized: true,\n    })\n\n    // heatmap layers\n    if (this.props.heatmapLayers !== null) {\n      store.dispatch(updateHeatmapLayers(this.props.heatmapLayers, this.props.loadTemporalExtent))\n    }\n  }\n\n  componentDidUpdate(prevProps) {\n    // tracks\n    if (this.props.tracks !== prevProps.tracks) {\n      store.dispatch(updateTracks(this.props.tracks))\n    }\n\n    // heatmap layers\n    if (this.props.heatmapLayers !== prevProps.heatmapLayers) {\n      store.dispatch(updateHeatmapLayers(this.props.heatmapLayers, this.props.loadTemporalExtent))\n    }\n\n    // basemap / static layers\n    if (\n      (this.props.basemapLayers !== null && this.props.basemapLayers.length) ||\n      (this.props.staticLayers !== null && this.props.staticLayers.length)\n    ) {\n      if (\n        this.props.basemapLayers !== prevProps.basemapLayers ||\n        this.props.staticLayers !== prevProps.staticLayers\n      ) {\n        store.dispatch(\n          commitStyleUpdates(this.props.staticLayers || [], this.props.basemapLayers || [])\n        )\n      }\n    }\n\n    // loadTemporalExtent\n    if (this.props.loadTemporalExtent !== null && this.props.loadTemporalExtent.length) {\n      if (\n        prevProps.loadTemporalExtent === null ||\n        !prevProps.loadTemporalExtent.length ||\n        this.props.loadTemporalExtent[0].getTime() !== prevProps.loadTemporalExtent[0].getTime() ||\n        this.props.loadTemporalExtent[1].getTime() !== prevProps.loadTemporalExtent[1].getTime()\n      ) {\n        store.dispatch(updateLayerLoadTemporalExtents(this.props.loadTemporalExtent))\n      }\n    }\n    // temporalExtent\n    if (this.props.temporalExtent !== null && this.props.temporalExtent.length) {\n      if (\n        prevProps.temporalExtent === null ||\n        !prevProps.temporalExtent.length ||\n        this.props.temporalExtent[0].getTime() !== prevProps.temporalExtent[0].getTime() ||\n        this.props.temporalExtent[1].getTime() !== prevProps.temporalExtent[1].getTime()\n      ) {\n        throttleApplyTemporalExtent(this.props.temporalExtent)\n      }\n    }\n\n    // highlightTemporalExtent\n    if (this.props.highlightTemporalExtent !== null && this.props.highlightTemporalExtent.length) {\n      if (\n        prevProps.highlightTemporalExtent === null ||\n        !prevProps.highlightTemporalExtent.length ||\n        this.props.highlightTemporalExtent[0].getTime() !==\n          prevProps.highlightTemporalExtent[0].getTime() ||\n        this.props.highlightTemporalExtent[1].getTime() !==\n          prevProps.highlightTemporalExtent[1].getTime()\n      ) {\n        store.dispatch(setHighlightTemporalExtent(this.props.highlightTemporalExtent))\n      }\n    } else {\n      if (this.props.highlightTemporalExtent !== prevProps.highlightTemporalExtent) {\n        store.dispatch(setHighlightTemporalExtent(this.props.highlightTemporalExtent))\n      }\n    }\n\n    // viewport - since viewport will be updated internally to the module,\n    // we have to compare incoming props to existing viewport in store, ie:\n    // update viewport from incoming props ONLY if zoom or center is different\n    // from the internally stored one\n    // TODO FFS incoming lat lon should be an object, not an array\n    const currentViewport = store.getState().map.viewport.viewport\n    // stop propagating updates from outside when zooming in\n    if (\n      this.props.viewport !== undefined &&\n      store.getState().map.viewport.currentTransition === null\n    ) {\n      if (\n        currentViewport.latitude !== this.props.viewport.center[0] ||\n        currentViewport.longitude !== this.props.viewport.center[1] ||\n        currentViewport.zoom !== this.props.viewport.zoom\n      ) {\n        // if zoom delta is precisely === 1, zoom with a transition\n        if (Math.abs(currentViewport.zoom - this.props.viewport.zoom) === 1) {\n          store.dispatch(transitionToZoom(this.props.viewport))\n        } else {\n          updateViewportFromIncomingProps(this.props.viewport)\n        }\n      }\n    }\n\n    if (this.props.cursor !== prevProps.cursor) {\n      store.dispatch(setCursor(this.props.cursor))\n    }\n  }\n  render() {\n    if (this.state.error !== null) {\n      console.log(this.state.error)\n      return (\n        <div>\n          <h2>Map component crashed!</h2>\n          <p className=\"red\">{this.state.error && this.state.error.toString()}</p>\n          <div>Component Stack Error Details:</div>\n          <p className=\"red\">{this.state.errorInfo.componentStack}</p>\n        </div>\n      )\n    }\n    // won't render anything before actions in componentDidMount have been triggered\n    return this.state.initialized !== true ? null : (\n      <Provider store={store}>\n        <Map {...this.props} />\n      </Provider>\n    )\n  }\n}\n\nMapModule.propTypes = {\n  token: PropTypes.string,\n  viewport: PropTypes.shape(viewportTypes).isRequired,\n  autoClusterZoom: PropTypes.bool,\n  isCluster: PropTypes.func,\n  tracks: PropTypes.arrayOf(PropTypes.exact(trackTypes)),\n  heatmapLayers: PropTypes.arrayOf(PropTypes.shape(heatmapLayerTypes)),\n  temporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  highlightTemporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  loadTemporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  basemapLayers: PropTypes.arrayOf(PropTypes.shape(basemapLayerTypes)),\n  staticLayers: PropTypes.arrayOf(PropTypes.shape(staticLayerTypes)),\n  cursor: PropTypes.string,\n  // customLayers\n  hoverPopup: PropTypes.shape(popupTypes),\n  clickPopup: PropTypes.shape(popupTypes),\n  glyphsPath: PropTypes.string,\n  onViewportChange: PropTypes.func,\n  onLoad: PropTypes.func,\n  onLoadStart: PropTypes.func,\n  onLoadComplete: PropTypes.func,\n  onClick: PropTypes.func,\n  onHover: PropTypes.func,\n  onAttributionsChange: PropTypes.func,\n  onClosePopup: PropTypes.func,\n}\n\nMapModule.defaultProps = {\n  token: null,\n  glyphsPath: null,\n  autoClusterZoom: true,\n  isCluster: (event) => event.isCluster === true,\n  highlightTemporalExtent: null,\n  tracks: null,\n  hoverPopup: null,\n  clickPopup: null,\n  heatmapLayers: null,\n  temporalExtent: null,\n  loadTemporalExtent: null,\n  basemapLayers: null,\n  staticLayers: null,\n  cursor: null,\n  onViewportChange: () => {},\n  onLoad: () => {},\n  onLoadStart: () => {},\n  onLoadComplete: () => {},\n  onClick: () => {},\n  onHover: () => {},\n  onAttributionsChange: () => {},\n  onClosePopup: () => {},\n}\n\nexport default MapModule\n","import GL_STYLE from '../glmap/gl-styles/style.json'\n\nconst AVAILABLE_BASEMAPS = GL_STYLE.metadata['gfw:basemap-layers']\n\nexport default AVAILABLE_BASEMAPS\n","\nimport React from 'react'\nimport { mdx } from '@mdx-js/react'\n\n/* @jsx mdx */\nimport { Playground, PropsTable } from 'docz'\nimport Map from './index.js'\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n    <h1 {...{\n      \"id\": \"map\"\n    }}>{`Map`}</h1>\n    <h2 {...{\n      \"id\": \"description\"\n    }}>{`Description`}</h2>\n    <p>{`This component displays and load fishing activity and fishing-related layers on a map, used in various GFW projects:`}</p>\n    <ul>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://github.com/GlobalFishingWatch/map-client/blob/9c5179358d4870c0fd4c2c0742917e72e6025c59/app/src/map/components/MapWrapper.jsx#L5\"\n        }}>{`Map client`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://github.com/GlobalFishingWatch/vessel-profiles/blob/aa0e17395f6a4947bb3fdf3106cb9d0a744ba64f/src/profile/components/MapWrapper.js#L3\"\n        }}>{`Vessel profiles`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://github.com/GlobalFishingWatch/data-portal/blob/96b1e24efcff58ade672a67229da0610d9d241ab/src/map/MapWrapper.jsx#L2\"\n        }}>{`Data portal`}</a></li>\n    </ul>\n    <h2 {...{\n      \"id\": \"available-properties\"\n    }}>{`Available properties`}</h2>\n    <p>{`TODO: fix crash on PropsTable docz component`}</p>\n    <h2 {...{\n      \"id\": \"basic-usage\"\n    }}>{`Basic usage`}</h2>\n    <Playground __position={0} __code={'<Map viewport={{ center: [0.026, 123.61], zoom: 5 }} />'} __scope={{\n      props: this ? this.props : props,\n      Playground,\n      PropsTable,\n      Map\n    }} __codesandbox={`N4IgZglgNgpgziAXKCA7AJjAHgOgBYAuAtlEqAMYD2qBMNSIAPOhAG4AEE6AvADogAnSpQL8AfIwD0LVmJABfADQg0mXACsEyEFRp0CDSQCojvVO3YAVPBDjsAwpUwBlAIYYARpSzs8rux4wdOyuAK4ElESuBBDkrlBQAJ7sAOZ0MALRMOjsoXBoKWYWAAZUmHDu6F5YGcU47ACSYOyJlKEA5AIw7OShAhBtdniUAO7sBH4Evq4ADjPp6IotbT3uRT14MOQA1uxtU20C7OiU5EMZMIi-BAQzcIiSkikQE6EeOFREkmXwldXfTl-nm8GTM6yay1C7Gw836dHI3XcyTgBAEoRSKVgdhGLzw4xsdgqwKwSxmsH83UytkR5lscFCMHW1FSuLe9UQAEozEZJGYIEQZpQBFMAEowVzkKZgIREdidcWS9oAbj5AqFooVBAAIgB5ACy7GlkTlXQlBAAtCciMrVYLhQ5IoLUPpDTK5ThJNhXALYDbUGYxWbdXqcF0MBkABTrZhsMTrCyMPAAZjEjjVzponDVwuy7BxEx6gKJVRBAkQUmTcfMFnYjBmYgjDSmUWSztzrnQLBi1Hi7BmQju40oqRgUxe7DDmH6qBSeZgCQ5Unr8draadLskVYT0ljijMJ16RH0ODSBAAorAjzQAEKJBroCOdYQEdpc1AcpUKZRen0wHCaMgdGoWh6EQFRsymYB2AABSgVxEhSIRQgwJZoIHOBLFcDxYHYeRXWNdoDwALz9fk7SmPVZnw2V2g9OABHISQohmSRVGwf84FIiD2EDSVqJNTV2jBVBdBRY5TiI5wCESLF2G4dhgHWKIBGeVArnaAAGdgkxmLB2j3asZg7FgZ3UgAWXT2AANl0_T1jAYCADFvWgRJ1P4ZxDgRB1MBgoR-CWIhqEoOAjIROzqwcmhnAgIjLnYABGMyDPkYTRKmABBOY5PYCMoPIGwoHQMNcI5OSxFy6MZHYFEZJgbhgGIqS6rgeQtxrYACugYrggAMl68ZEnmShmi6oqSu4Sa5TAZDJQGVB2nYAB-DZurDCMyquMaetQVLqykGQqzfMwYXVY4YDAMIoCmDbysq_asuXasE14ggcEczIUivAh2prWtKJmdhWAgGARnIhr8v0DIrgAbQ0nANIAJispYEsRpMcCshKAF0liI4QiCuABWXC8M3FcpFe97Pu-9qpEeo6zC_EB6MY5jWPDDQtAoYD9AYU77SgzBLtCa7cP42imNmITnSwciFMNF5LEoa82gwOAlgIVwVNHAGADV4DgedxaNGi6IiLoZYFyDzpFsX_HYDK9YyhoABkMuvV2zwAfWvDLnDPPUMug5wTbdSWPApZjOKZpQWYYqWWOYjjAN0ECDDAsizteiXTUVW0zrQygZksIb4Al_ti_NaT5hj1As8FwsiA8NAYDFdBQgRAQ7Dw02BI7vSC8bovganMOCLzi0ugHmWG6mCYhBuHC-_aKAnH8PBJAXkQCF9IebdRCVtlL2vx7NyRK5mGv4C3zIdjrueFc2aJmNd-CMhP-Alkjo3X_fgRP4axqlrGI5A36JA_mXHuEsPSX2vnASQcEIHd1ntxKCwNQbkUAaSYuoQS5QLPu6C-A54GSDgH4aeMt97sABjAp4UB2YAw-MBVwrcBCoPlopasaAXh6icKLGABkLBGwIJYGA2Z4hniwOnIRNVRwAAkIApDwFAJRhAxESKgFImR6wRH2D6HAIUKU6FBQ7rAJi_DYA4DNPNB-aDcgzHQFkPWIMwbqk1pkVA-RuyoGVgALQJoQyWmJ2YYLccKaxc1qB2M4ZweuBBmqwCWJ8IgLxEkwAAKqOKyEA2YZJEgaLtJI6RLpe7hw9CE2YZDpJWJsdEjhZ0oJ4KcbQSwd9tjQJXh6Q-99b5HzgJEnxMTGkOJaTAeR4piCzHARkIBzSsgzIEK7SgHZClCmKenTp5TJDPymSxXZyc6leKofXbiKIhTdC6dUi5DT7TMXbp3WZdDzldEkNPR5KC0rRObLMB5XccqfBbs6P5sy8pKVmFce52QPkazMPIY6XiLZ_i6GSCUbdoVdwjFCjuXcEXpXxIvXeMBHpJDWZkLRJTMzyW3kvGAEYIy0E0do_QZVuAVS4cIpFOAWChWiAVCMeTSXiKKRS9ODLhXrNFSyt8nKLnctsEZAg_KRFko2focVTLKUEA5G-JQiUrJ4u-aM5xrjyIfUiA0ESkQChF0HPJCMaBPgFBcZg9UrL2W6K5TyxV_KVzzNoC68JBAwXPRrHBGIBBQiYCuI661M5A3kQ-FDAQcNcYrgsGvGcLwo3xVjak-Npr1RJr0CmnGsi_r40iDGq1-aUgJqLZWog5bSrrF1WlOCcA7AAz4WY7o2AQLoDsFTNc1AXQcuAVkHK46LA8JiPEWK2QriXSgEbZtGQhBlnYKgUWUA10CA3ZahyVxt0JFkXtdYnx1w0C1FwewfK8ARnXUY6E-6hSHsoGVadhYvGUCsWvFIj7X0CCWE-gQ76ZU1gmLYHAIipJZBDX9CwoGrigebUhoD76UMYdQA5Zt8L1jnurJe0d16uB8OQsGz9K5HjsEchAbu89-gYgyDVRIIk8BCFQIMEIUSvH4miDVYYosch-DmMEQIDkughFQMkZiE46BTmo5IR289NjQgwHsZoUGgEiJCIaOCs4IghASKMdgcnJwZAKMJP6EBmgMoJDgS-AywnywAIRTWQsLVu6AqOhosP6mA9bhTmqIJap1M5bVwHs9BpzOAXNupXIRv6NHLA6l1CuWzuVtOOfQieJIMw8BwGgtEPE7n5InqgL5xDwC5XevvVGPzNZZ3pIQ9VmsmIhqFeKxMK42XYsdYK0VkraHEMpbSzqEIcwkjsAySKV2xraDnC6Omms-HGsQYsElprdm-u5eoBlG4_QPDhFsfYPwM5uhldyOGSAzofMKRW7t4uAz9uHYgMdoZZ33BpAjC8v8p44O0A2jgZOtValvY-7YjbuFrPbdyn99g_UatdBPKOQHdKOQg9mCDyxf4IjbGCJNeSnmLreaq4hv78reVKofStmd8Se0CNa21ocBO1L4hi7l_HdARt_TCBEewUA8i0AEAEqtHOBmxf55QQXwuMhi6bXTprcBZcomhhLnLz2cC2FVyL3nNZqBBYIF9i7vWHOxcN4W4UJu0j64sNQeRlBWDq6e3cHADuncZDt3sVAgvYjbDN5zrX1A_c7G99QZZHZA-S726gSPiwlf27jys9AcHhTR8127iPKe08EHD8njsa5YC0Azxbgv6Ai-jkEYnn3guQowGgrgmYpfY916No3mYeD88HdRO9k70SbfxVdy91APejv968YP_Xa3qvQ62zOnb5vcs2GUao5RoiJXkuZZmK7FXEcDWH_gNRa_1Gb7VTQHAsAZwTHJ39SndWae_YUcftRG_NVisPyvlRr_VVSpoDqxLWHBfe6araLGPLXH-cRaZf-OwXfHdffDXWLSAv-ZBAZK_FIG_dgAAHywJWzAMzwGRRGiFiEWVgKmj3yR0PyINAVIMvzoAwLwGh1vxrHvwVXqyVxSTSRqUyWyUW3wNi2oJIJgOwKwPYBhlxkQNy2QOgNQJELEOxmhwsDnyAM4EXyDzdx6Q6XYDgIXAe0a1YOp35QCzaX6X4K53aTgAANDXn3YBowADlTNe9mMjh_A2NyAeMhkVDMszCtdGURVt8pgdCoAEDD8_DJUAi6Dr9GC9DqsaUiUSUCkz8_9g1QikiAjlD_RQ0aN4BVEaBLRbAsJYBzRZYLRcjKRNRJAuN8j0BzQgoKNzQREGiQFGRQ1stYNmjmcmt4kIB504p0Bes0Rq9rCEVktlMDkqIkFZkMs1DwC3dxiZhSDtDyCd1mDZUUcH8jDeDxlJkUDQVP8diZDZlNYl8tc15Vk0itUrC_o9pNtYdiMMxtQuAskxkIx-wYBWBItmCaNNC4BpissTiNCLClj5I3iPjzD-lVjkc_wNiH1jCLCfDASISMilNfADjAZJju4_iESBl5jFirtQTIt8A0TSDISDCfVYStiJkX5Dju5sSiTqSFiYDjj1C0CU9f90jkSsjlNpDAZlNBD3CMTfjQ1vC8DD8eS8TliEgQiASBlxSYDIiGCyocDRSZSYMQEhDZCgjpSWS1TiCwF5T0Cb8VxISRTGsLAxSo4aSyCQSugwSIDLTGTZDlSzTJCtd-SJSbT3jCT3SYCVtIS1joS2DH8a9OCEluDnick6SfSnTRDxDmTZjZSHTFicD5DFCaw0ybjVsVCaMzj0B2StUsTD9cz8z05gSt14DKDVTiyLj04FTMCv1gCGsWcCTctqz38XQidyypTnSWdXMWzTi2SazjxDS8Qey2sizBz2yaBU1UdRF-QMcyz-y3c2z_CtUZzTxLB5zboxzYiqzJzVz04YYcZZzNyjxbp8TbTCSVzwi1zjyNyty0z_SoSqdySIwAtFl48Sz9AosJzzipztUMzACuTxghyaBCzVSwit8tUyyKCD8ILQK3oRyTS7MlclyBlILz8phOy98dzEM-zLyucEK6zRzcCXTUj_z1zRxTyFyLyvTCKKKNJsYTyHyRCldyKDz9AjymL7yzyypaK7SNCEKuLmLeK_SYjxyOMd5YAEivyaA6SMLkjALrDsyxiX919ZLRBhSZiCCj9V8f8EKYKKy4KdSv8T838OKL8kLxKbMUKXS0LdLv91KDLsL4DcK_p8K6KtdTL9L_ziLWKyLVTvKnKGLuKqKWKysa97KgrT8QqRKFy3LINAq1KYqLKCBhKeKaLJpIqCKvLkrzKbzDy7ywrRL1trKKcvUgzlVn89LgrUq6Tor8qoL04rjENMzNtoQV1ugGzVD_iTK8qNLFycq5j-qEKnyyT6sRFFEaqUqCr1VP8Rr_yWrrigKUT4t7RzQapHVug1qpgcQpTAgFtcw0ARdUB4hpsjMJhuhTEBFm0aMRhug_Bnchwm4jIpM80Cg-x0JnrsBbAYgZwgYrcxxzA_slgQZEAUSAsAbXV7Q-53r_qnN2AdQ7DXYABNHqxtPYI4BEEtTgOwFgMAMAC4MC4CvuS6uJE6s65EJFHIUdFE1LXUWjRyUOOG2ccNdgTNQTNoIqdgA69wPYDwdQLYPPLdEQaTEIfdeCFcfFXofdfQI3HKSnAHDozHZOHauLQGlE85QGS-VwFIYg_6gLOwPufYfIXyEYTYcwRtD6tALEx7VUnassknW7XMfqFbRWtHZWrHGYdW6Gt6GWsMURTxbxeaOSSUqAY0sqxsjgvoAOo3S_YgyNXyK7Q_NW7GkXVNfylnf2uWwGy_agZ4ROy7KaFO3OtOjILizOtrbOmgOOjG5O-23OxtMS7qiwGjTLDGzAa6VwXGz6rYakabTshKPGQJfMPEbuw-LxF4eaJXbwyiCYaxDwKLauggWuwJDaku32nARtVlKaBKJ8gMl8-rCe4O6gfxAmOknapa1qjqo2SOxDALI3ELMLONFISLC-wGtM24xrNqmHTImy3qhMj4AxIUQazyt3GWwxAQUkiqwwh9PRYBgQOkiBoUK-zMzMizRB5g7wto5onAUDQy3Q7q0SX9P8f9fA6gv8UDNMroSNAQcwJstrGMWQGvRMRGMQWhe4l0cgTIchbIVzCsNhlhwGcgDtOAOw70eqfgaecQYAHBrIPBoDbUwg3B0DHACIKSacADDkeQJcX6Rhw6EdB49gODHYdgM8RRrUUcVhFdcsHcZhl0hMYR0R8Ro8PgQQbIGRuR2gBRg9HDSgZhdMfQEx7YHRi-PRv6A6WMP0oC0YvMagdoKYDB6TRIKDf6iTC5Dw2xOJF6kjR49AcjTMR67oQIYIJwtIaR0NGhvocwLxv8WdHo1RPoss1EBkZaLs4Iq4BhiJkeLgFjP7BqP7NqJXRgWhYAHAcZ4fMmcJ2sSQHpqcPRiDPaQjbtXHTPQBKddYbndnW1QBNUzR2RHaq4HZqBGDUTOlHawBTHWwMUAAR1CHo2yFkWl113lwJiOYHF2a8F_VkR1yFzV03WOdrhwBmhElkR-PeeLl2e1kyESB1DAAjEBfgDwawDNAZXaUuY5FkVxJgIhfwSBehfgjhYRY-ZOfIVmDpWxeQQxbBYQtxahYlthfhcRYGTQCIJEhgCJa1CyB1SxYWtSrpZOYJcZeJchZOdZa1nZc5e5cxfWGvKav0AFfxYZaJeZe10RXcARCldoB5fWDlNQMVaRaFZVZJaBbJfmAjD1cgVrh1erGjNmQNYGSNaZZNaRbNbpTtYASgRtYsGQYBZdeUf2fWBo16HOSIFIPWGGGdwEA7zwQddOfJdeKb0udkREf9xjebz8lFdNbOcTc7zxfgBlerAGy6xKzjZREDerEt19sHzjZBfIFkWzyj0zfzYGTrYbfL1z1rdmnbfj0rxL2bd2bbaZF91UR2C7dBeHcdyjfHfreHbHz70-3OzSBnfbbbwbybxXbhWEhWd7W5QuiugIEiw2erC2ePR3VkWLaGx63aaefCBlz-ZFwVwGIZB-ZVwffV0fWd3_zuneOPF-blyOE7JaaGIsAao0rPdPU2YsIg93Qjc92jY3ZvYvVHe2HTZg6xeJJxaQ5Pdpew4zX3NmpoHQ91aTKw4q1kQ9fuDw56AQeI8rdQCNxrdyndQUiUGHfj06ZY-ADY_o_j07eY7um457ZTz7filujZVY9XZQ848E546TynY_a47k593nchwHyXbE6U6k_rzQ4E4k6E63cyOtltgPZoVmEZ1gFjmUFZkTmuVeTYi5lTl5lAnAliWI1XR6FNFoCkguSWEFUSD1C4HQFgBGG1m6DKQnmhUHlOXlleFQF2BXneSwGrjwGQm2BOUfigksBFAyjsOcAaEsAaCRu9i1FmwykK6RqCXGfoVCVzveS7luRtkgFERVjVkHRCCNqVla88zgAyl4w8XcBPtQDPA0wi7NgqQYSqTVqOTrjMGLxyaNhG_Oy7jsHknc5aNNIsFeKEARE7TwdQFYBwCDmgm9hFDPFK4AA1TvA4dRLAfYtQzxrwMkABxOQyuXbgZOgQ7s7jKewSwb2YOE74767y767vUW7-7x7l7sqV2wyHbw2fbw7uwtLH2M8OwvWUO-SQiX9teGYb6GWcnaWx0evAAdVxEsdYGVl_VW_kzuYecfC6CCloHNCS8tHeIiGp9fACcFCNjJ4mAp6p5XQvWJ8W9QGW6eTW5F5gD57wAF-EBXU6NOqPHUloWut9GbVNGunnOfZA5rGGBRCV_ilXlOHiH15fGbXIiuAAA4NJbfm0ogsAMpl3tINJm0KG3Bui4pN1ftmiWO8p2BxndTaBAoIUFZA-KGvalh5j1Jkf_uA4RQGgMpXYGg_FzvFo8J4Uz021Mj8UEc1uvOYAfOuh6UtPJOFuYAluNXQV_PAvOwQuwv7M0udUEVjP8UtYdYCB9ZDZjZ7UuAuPhfEVxh2kFauUlb4MVbscfjuVohXBgXVB6VtU7o3ouBMfOB0A1HKANGCgNoINxrH9mvlZVYeu-ufE0Wj5Uduv1YrD1gqm6Gh_z-Ygjwyij_1ZDPW-jUD_L_2v7UvAev-_bWYGr5T_i_0HQn95oFrNrpYV37FUYA-wEvoJxRJthMAOQB2GTWPpT1mQCmHulximCBAPqcQBILmGZCQAGMisFriALsBlNQQWleHKPw9rj8vaPtINEA1lo0ATCk9HxAQ0qx309-_KdAT4hG4PhUGBGJYNl1y75cKudhErmV0kHsAAA1IlGz4nQ5YZ0YWKZz-xWd44bMKpDyQQQOcU42gNOHzEzjcRnursb2M4EsAo0vYMCCbuzExBNEWo1SOqBxHiZfJB-TsF2O7E9g-w_YAcY7qHHkhmCLBVgr2CDisYtJXAMMdoCkDAAjBEAPJc0IKXaDYxhIxnNQaLEyjOw3YHsL2L7H9iBxg4zgTQTZ3ZhwIoEfSe-AYJ5h6AXOj8ZlhXAHDVwoEJyd_oP00LrN5I46LgGW17wzhtccAW5vc2niyI-gUAXoRWwsCRC42lAAWkLRTa_ohQEwgoGCzLgzDnQRLaIWkEoCaB4mSwdoPMAMwhR9I12LzHdgUKyIMSGlKjqqydYisW21iZVs6yzZItt0zcDIN6zIEUCdQ5eONl81g67QShCcMoSQgqGClqhQEWoRnFc6Fx_WjQquPAlaEqD7Q-KSlla3LhdD1gPQgdqSz6EpABhQwh5gnhPbQB4Ao4e8MsJnAUc3g18SkSkAOa2B3ssAP4fLyxYMg42bwwIMBiZBhQXgbkHEUC05Fe57I0AEXDcP9aPCYWRLFcKqzdadFW6YxVpvB36DlB2a_8XwK00ywiIVsqXeKKqyFHcjGsNGSANdAyB6x4gDIOwLYD0wsBeM2sZIGgDzA2ACo0ICUHiAJwOi7A3dE0SLkKKXIQYRUEbDRkqBAwLR5ca0XzSFaaZjMwRHnvkGwjbUwxdgCMDqBFCKxTRUDFbG3Xig-izRSYq4PlCyApAhQ_ImGETCWBWRsYv9arLmIEDmihc8AGYXMMlB4YIMhbUDuKCnBlsc2X6BTIKGOriiXhL2ZsXnilrU9bwLjPURKNmGC0WxK4BSgEUHEPC7htwp4fcN2YGjPh5pBCnAFdiGwWR3zAjFc0GEwA6eIwrESWhsTO4DxAIwjG0LEiWtPWp8TEdwn6ICjXWeIhkfGOZHvjZSrIwzsoPli591S-pKlgQhfEzo3xsovEQSNPHDDHmQbZTPTQmzHcaEaWDJDYIaCUDJgW6IIMgOkw5AtRw4c2okHWDAxvxU4ocTgH-EUd5wQtRdL-Oon_jbWdEyUNkEciTI-gjYxiXKK_SQB5wUEiUeWxWErhWA-YxiSuKEl4j2xpUXltNVoCCSqJNEiNkojMrsTOJXQJcbs14krh-JRUOkc2jEkNitJgrNcdBM0YyTM-PIiUHyI5GhB3hhon1osL9ZUThJVI3RMMBGBvxAgNjRicpO4SXi5o14vycxIsC1iTJSrKUc8OXFmSpJFkmSTrmFzi5VW_k4RDSLWGMTR0mwp2t5n2HbDdhC0fYTwxFwpCZJYwgyesGmGZSRxF7cYdVNnGjjARqAZmKUKqTlDa4ZCChNkAhFGC6h3EBoSvEvjNDa4SIoCUakFB5tOh4lXqQQA5GAhLhCdHNHZIcmwSzxCE6sJmgLpLTGJBo1afBOJF3jkRUwfFBc3AniVG0y0rkSm2TRxtJJVEzcSlCBHaCWIlSFiEwjTisJnQAgHqc52hGZdv0zoPiGNwEhmgWeUXRrgrG4aTJC-rEi2EEk0mwyIZUEU2AAClQ4wM9oPyCIDhA_RSMqwDl3sAABpZwN7Hdgo0zwIob2A0CkGOQRQSNf7jqEcjexnudMjJNBCq4ehdAkAFIHjJEY6cm8HMixL2iFkCJBktiDiHjI3IWF0kWyAiNVx-KVCOkMGWGUKAGSaA8ZzES1L6N4xVcOY2snxGLOiQSzqEUEERBQKWAiIjcA3DgfNEEG6zpuvGNWcMntC0IrkAME5PijH40FhC9qChixwj6g5uCQfDUlMStSD9TwVJPZIsV9m-87oAc7HPMXpJRzfSYcsSKeC1kZBTqUAfRN3BAYxzuWcc3BsnGOoZAjkLAyBmYE9m6xccOcyBjlB94FyJO8c72mrz_C-t3BYkPwHAEjm7Fu4AKAvs4BVmIN1gMMCOZh1QJppqwEYNEd3H_5_Rb-5gHUCOJwAeiosM8ywn5QqgaQCMZgN8FXIIAZy74MQZ3IsnvA08oZWQQebAElBCgGGo8-gd7InmyJ7CIgeKJsCkz3UOu9II8PximAYlGgWoOwJXFHi5hR6ZmXHGZnvT4hugZgtUbIQmACZyEXNdAIhJ5rdAS5R8tgN0BAY4DQa3QGuLEEprQL0xwRf-Zlm7pwQfJcCljNaLeJGxiaW3SjnPJrALyJ0j82ZKGAxR0oBU5AettQqgYIDGs3hVzBiTVb6ysFchERf_HVoUSyorCiUOQCzHKYSeiIFdMOCQHPUCoWwXYM6DVw5BBS5NUuUFL5FOjggIbCILKExD8KvRUmYBb0xQVCK7MoiqxVdhyl3YnyziqAPHVQLAshQZ4N0fSkxCLJQanMZhSzhzIGl6CBYQej3TyC5gjMdAekB_Itp9gwumYMhXYGUgE4UBVowKcfO6CfyimQ4GvDRiKUCZyQYkUdIYswVPV6Q2Ef-McTMWbAdguYcUHiCqWqA2AXAUIJTRrybcWcYaaRZiG8UcKRyq_BKJXQGW5Qgl0io8FrEiGO0bs3mBAjMuQThD5lM_LYXEMQAYKrxMAFIav2A6f10yd9arJ7KgCnycg8kVZRkG1w5AUyDndgFvLabFAAAJMAFEVcB5A5od5Q53kDFB2AVwT5Q4qmUWAFFjmPIA-huVgYfMNeH-tcQzI30uqSucFZ3nIQRhgVSlarPIt4WJYlg4hRZrvI7lTBTwAMGWfXL9mFz5GgclwcxHSSVyjUpK2YOkn7nQyr5QtW-SPKZUzAZZSwKWf0hlmTytudK7gkAk0IyywlPVCMK5nFWiq5Fo4appAp5WiqVC0tGOvoEWTPckIdqJVTLJWwb80ZG0fVeCNrH0puBEnLxXMo7Az9FlZw7IGmS9pmqWOlqiIZsvaDMRqgiARCG0BmClSxx7Q9pKQUtRqAAU6qmgJqu1VoF_AB8zmESzEFEySZZMimVTJpl0y7CDMpmSzJ1BsyyoCghKCoXm63Z4gZK0VTlBFUtRwhOsS1BGGiGGI-gu3FIQNx2AyyYMXkAtiuHm7lqsQ0c3VaKtnKPhkh0OWVRWpNV-KAlZ_HYMEs4CSqLAXa-AD2rnW7j5SrLDICkUDUwFg12AeQZwCWCoznAE67YIslQbQ4i1UAEtS1Byinrz1WIZWcGlXgwEThi6kkiuFYVXrmVKq6sHtENThzRwtcvOZ5zZVDy756cktFnL_XAYRwnfGuQgyFW5QMFYGhBoFGg25yBF-nLEq3PA1cDISrCjDQgxiYsKFVd_eDfEHA07z3wDKwfiKqyDKwj2-c7VndFayHM2Ff4VWrnR2qyIHeT7ZjYwLVqcaCYHGtAFxublMDE0-aBXMJybbCbW57ucvCm1o6QbwNDc7VmC0oBs4rgUm1Zlsw43vq6oVwblS1j9lYt_APcq0lcC7kmbHSoKQzRePEUnz_4Z8vTeSLyVYLLlUWazbtG_ViRmIN6WBjRq-r2oYSfvcdJbMBqdN2N1So5OjklUwkn8K9QGhGHC27LeMUWxZrRIIAUDOmv_K_oIr-gxazZkAiAX_1S3goZgh8o5J02vhLBw0VW_Oruo0lfweg77CDZiGe5o4210Wyqg-k1nObqADKMuFVuiA1aqRhoerUAhEYAc-VUAVrQkna3FaT2QdDAcNwwAyc0NoaGLfwNtkYAd-Ig4dmu107icPUa2zrRGD5nt4m822z9SlBb5HSTOmQgGULQYZUbWklASLNppmA-bySfm57LvIjAAw3wLU4EVUlbkizakjsn6VCP5g3b8U1Mgrt7HB6lcbBWPGHf93h0YSzwVsKHUagDj_c7ueoaCKmKT7ewzwF3O7umpyjtBsd3sXHfjpy7mDidpOywBjrGmD9Kd8iBoM93kTJ8OdOOwODTsJ3060elgcnazvZ2c7RdPOvHQTrp0k7BdTOs6PiksEZQRQ_3V2DqAygPc0xWPRXcrtJlq6NdculEUansD6hoIXsO7rrvV0UzydxuvHWbp9iq7LdIoA3cdKx1ngUd6EvIfYFmzOBUxwut3XDo90-wvdIoH3U7rSGY7B-s6Czt0HtROY_egWnLccGO1fpaRjQOwrDtR1ewLe8EXMlcCcxZ8AJssZnWJCILCh48LGALZ1otnNEatHYDIPeGYVt95yRBAUDlGdBjAuWQOTHBlSNVEZGV6QTIApPL0wqcouZevTkFcVLK7sLy95WPphXyBvY7yx_vAC1gCh_lgK8YM3tX0zBKpye-cRlO10q69dFM7PTJBTyOavpWQdAMPvvAF7uEdmDTbu0bap52-gRDzFPvtVlVH9os5_bnl71f0LArCuffeEL33iXdv4WgMPvrnAH7sEnCMDCT5UPyYAzCmLSnoyk27Tdbu-3cfpFCn7c97NFPOPrv1OTB-FDHKF7IxwD8xIc-mnt_r_SEHMS9-3KCIoYNoEoleIJHHQb_DP7ROtq0nO4q_1Fzsc0mng46GLyUHP1oBiPZUoY6A1B89cpLT4ii0MaEDkG5Q6tpIMl7mi5BpA__u_RiQCBUASOKY3khcGZNjHDTrDm8KGHjDuwTsm4s_1foF5ZGzQ1MAdqmGhD3tHancTOq2HOiih-aOjmbQXSoazAtWo2mbRl1N0MMNWmrXDTZpMASwWI7nU2kJGYAsGiwFlsHRXA1aWR2FKGjiCoAFclqHI6XXcDFHUAkR8owTB1DhBSjm9QowrlqONS_odRI2G_AIDLJTIoR0TYMBgAdGuj9Io8VIeL1TAVUzlLLKNQY3jpU9lO6nVLqJ0y701siIyGfqbYLitUV28PaMbkQEApqjlGavKypS5QwOUxuAzMYP3-62dHOrnfIgl187pdDOlYznvP2-A-WhHRqWtkAny6jUp29dnm3rnx6q9ah2ORof0NjHtD1y3QxBm8JmGQ8a8M7QCcn12r7sX6OEyO35l5s9DSzbYz8dIO_qEG9c31kFs2aXH3dCOoPd7tTHPG1jb431lsealxxWpL0ybixAdlDJwd6cBgP9Oa7my-wEAGoCumVgk8hQ3NDGTtVqIZA4gFsc0JXAal4yAsFmzcliBCzy0MZ1XeYjsjRLKnDWjsvGVWyDTyH1THoYHdJpm54z7ArsDJJYOTWWmGgRM72H4h1D6gU19gM7nqEF2CyuZSiRaGNgZqoTM9Z4XE4bpZ3-7rw2auwlqECFyhKd4ZjJJGecDO7wTxjf3XrAaBngSeNOoXVrtTPpnMzqYxnd8ZDNiQ2ZWocrj7DTMZmsz5O0s-We9iVn8zyupMwrv91OmXT1Mt04HE9M5n_ubZvUK6fdOy6izLu0M-7utP27yuuuuwq9x7MB7xzpMyc6runPNmjUYgvLgVyK5SC0eWocnWuYkGbmidkZlc6Oe9h2FyuDQPWBWbzPVnZzZ5wrpefrPXmCzo0vEyXtHAUD65eRkkyezJO-wIzUZmk_gbyMMnhzyZkLb7XrmJaetqAdQxVHgOdaUDe-1or-YbNZm8Drx9jcMerAxbFT2p0kXAFVPxaWqMWg0-REHwOpoLKWkY6-amAP1AakFwGhGXo1wGE9YJ1A_vvmBXBaz5u1CwWfQtNsdqTF3XjPiT2wM3ylJPCyqZlBG4LtCo9gA4SmBID2wdgQw8QpsNHw8wuIYhRUB_lGTLRqCki7IerYacLthGNvgtp8TKwFDIkRnvoAG0Roc0be89gQazSF0nLp6dgBjXKwrEVDCFxPexeQucWUzvZ50_2Y7ODnljK4VY_ge6qOpbLNAEbPEcLqJX86aRkbBEbxVYWphx23CwyR1MEXpLRFiDIZYsPfYMcSgovTRfv42zT6lABXAxd9pAnYGiFsSxttqsRhyOPRotFEdTRJHS6yaLin1c3rb0KrYB6q0Nztn2omr5JFq6-TQNBW9zG54rtueIOiXXyuVvZPlcIu-1ZLa1-rKRfVDkWrCh0nY42i1mUADYnaecPYGTTQHFpiRly1tIeteX2m01-9LNaPoWX5oysCMJaetN3dKZdph032YHNdnljaohyw9dSPJXPLBMY68GZHNiRgBkAz85ALes05EDYZRuYdtcPMadDWNrvVQbcOAx5IvJgrV-jyOwwYYeRkHGgFdjDaab-aDoxIWpuQCscWAem_SJ5ps2HezNjI5pfQDXthNyRzejiEFt4Bm0mwV_Ops8Miai0atKW-vmz2dgCgxMV3llb2uP42rviSgB1ecusBvaSVnNEkcNupWYbBtrenDdGvSGpg1scRvkvlr2pTqDtj-r5eauJ62-xcPcWAEPY-B5IcMJYIxSJvc2bgkQEUK_mgh-2xCztrBXHTFsTAlgMd53HHUVuEBUhf9WwspkvThBugsAH2wRInCv5NMYAERJQOHCYBewYC9wMvpVE9FaQnaBkMHYiALELoBAEUwIG5ogkBT84DCJQHbtFQGUXt1u5HcTvEFk7udGYN3agAZJUAcpoWvNDnr9AsAEGfFF4FDtEBw76-fu1cv5OCne729iAevc3uEAR7W6Me4FgntT2Z7c93jIvYFMr2jUedtu6KdTwEDcw1KIez7e3sZ1lMSdi-5vTgBv3g7TGQgNvecBv2d7a9ixcfefsd30AP9s-y7YAdAOM7ESggIgmZBUA6GTySTGZh4SYhZhLRXG1xmFB4AVFYkcrOfbjrIQb7KRT-77YfukH9geAfxRQ8Qex3c6NDoQA1MPvQOI7y94O3kePZ_QSH17UR2Q5X2DWVwdaoW8w9YdpUy0K4e6iiGPTqgJHKIXqyuHFAqOaocj6NZo8kMZ2Arf0WY_7rvMXmrzVZvi1FZeNNtuqT9sBxA5GwgPYHRUcB_EHWnVZgLmVz9dnwB3PSauVSMHH-Bm6cnjBMIxuHuqCRYycZCYiGboCjZShw4AAAQIeRwoAkAchAUFC405E45oBJ6uohnIQIANzCWGvCcTkJJAxTm5hDLiLLxw45TjeFvEkq0o8ZmwLAMrBFApAPAgsk7CujydUA14nyGLiMkV2Fd7AC58mSHu9j2AldqWQ81qHx3UzLASwMZ_acmcUySZsz5XTqCp1uwzwJM7c0s7J3GmAQOGH0ybIcD_WXTSa6Z84AyTXgrB0EA50sGCF7noISuz06c_SjV3nZUwYIZYOsFng6EDg4JwgmCeuCFolzkRIsnSSWM7YBAWWefAhf1dbl6s6hEyrQCtbIgn8WwVU5iD9PMXqAbF0QE_gvnizUwZHXDuDghCgX5Oql8D0BdexjzYkSnYy9CHAvZz7LoFyy4ohK7CZMzuZ7s9uckz_YKaxXXYXsCJ87uO5rHkHBFACvtn8zkVwDxJnUyJXUr8s1qF5fBWQh55iZyK791x9LA-rjZyHp1exmChwPQ17Ob8GFCTuIrj2UahETwuD2BsG-QAnwtEmw1M2-tYInkxgBFkGSDu8wusM-vPIfrtRmXDLLtBncHr18GVVYXL0I3DEIh9WOTMEuMRNHVgb69TdqN8LwDi6EG47s08uggb_-MG-CL2GP9OQFaOIQ30wwy3xbqAOneDvt78rckecV6-RP8GXaB-fC5vPYBaQVo1TmtYHybcVuS3SwQPpm7gAKEN9E75BJW6FKAHCN5gL9IH2Tdtrm0s749KDHytnpqLFLuJFwTqj1yoIl7brHiHhTTHSTQVhlzS6ZdnhALrxr9Je-Gw7aPNxK3Y9epj20C6o3580r-e5dZ71g0V148E5AupyxjHtOqANUr2wNMbQRkCv-T85TYCklAawISlgA73l0RsRvc68hMgmGBNKyzhtNHDAIz3Hh6lTprI-43k33BEfi4IiCGrGHaci5T7OzcB10kIyxg7Kwo-l6sKZneekhC20bHDyjFOKrdGUwJRbeGkCDPNywHyQ56eAUMG1w1SpV0qMA6T4lDk8jFM7VgXnQTpFAo0lgjPT3BDZYzr0ki1ivsJQAHGc1hM0wJ6uPS33egZg8ZHurAD1rkBSJ1YHMpQGeDuFcH3niUMkHhBqwxR_C3-T7mmxlK5Qy-zddF1xuCekvAKagIk9nJwsS7VePMvOQOxoQ-6-QXreJ84qSee9LVfFApjS-S8Duq6rLwTRETZBqKBXroOQEZElehKRVOcrxX0-4OMVFHiADlA0hKhOAtYVIBx58UjlRvEAOQXIOYLnLFk5Byb7MhhgQB07_9CMNCvWXWqtYq_Bw_ctELberVkQrZfEIUoHLk6gxSEmnDQCN3lKGdqOo1gFToflYWHqSu_eLqDEVlK376Sd7dWxDzvSRRAHU-yCXevvDIJUqRVAL-c3vLTolFcqmh4fugSOY766q1hneQfwP0H-gAOVAdrvEdIhsBDu9puv6KJTLBkpQ8io_O6YkXGZmFzGZQuiQAIN0DoUUfmQZNCFwVP5oNSUSgQOIHEtdEuj_5hR5z4iCT0E0ia88ecorAEnPUDqtYjxgUd-M-u6MGYpj1YhA01r71qBE4RAH2G1jSpBq_ddDjDc5u1fdPlyoQztpCAxg7esxkBkfC1j6fD41nwjIODA0g53P3BwpX4XqRJtiyO5ZyVibzGcuJnsz-Igs_horPVPyVLZ_7E0BCQQmbmvF-X0t6PPEuLzzAB89-fYm_6WIIaBAahffP6mKgBRieT_yEFHvuL64Bc8Jf5ySXmWH9HxS2A9xOf5b4H_-97fUfv3nb6d5iHbKFKdGASXj6mgJMG_nMJvzWGXoW_y6OMGGIjCrHyRW_2fsL201S-cwN9gnqWqr9FHl1F_C_pf7jTb9r-Vo1XzfyhgwDSPGPHhlwSImrXRDkhoNA33v_YQSE91J23fxmJaqZk8tusWj-6zcE8NjnxGosPghTvetKDvag-9KKoYUGmsGcY42uxukgaU8Foh7EewfLH5HGwtEcpwoSwGZC2812jsZgB_5PXKle37CxbAmFBswrtEcHghSoB5JEh416mAZhQQYxAalQQBCPvQH3ojAVkDwBi1IXr4o_nIshSIdCsV58YMcnVAR-5bsgjJIPrs9y_eAfvZqhKievNzt6LKrf50eyZgx5UelHlYgseJvsHaYguLmtxyBvftfDB2GQtdDkqJgTm48eXflEID-8QmC4pCwdvYGhqObvIGd-6Pq4DrASoLWqwyYPvsINUYPkxSSY_ivyg-8cHmXCSqNGKeByI18gpIcS0QFxJ2AIDMEHoASQbQzwA_qkjajaOUIu7l0bysADBOn8PICZBKQcUAbe0_kagFBAgOoEjayQZpIIEhNI0EfiZ7itAtBWQcox1Qo8lACfwVYgWI_0qIv4DlBTQaTZ5BWpEjidBKQXwbO0OQFMGjacWEmKDu28sr6D8_nMgGUAGUAkCjBWbrUEwwJQWXCtuawWJCWBYZDoFnBMsgcHcE_Qb0H9BchNxw5Bf8v_DqBeBG4FI49gZj7OBVYh8HeBXwaKopC1wVEHzA87imSPBJwVMBnUxWMdS2oq6iDA08UEIHyXB3BNO7jMGJOkiohnCtIEZALKjYTeES8g1IryMAMz4CoCQNCE0AsIcKDwhmOFZTdUsQcODbw6IHiAKgY9FNiEKCYhN6pKx1J9TFwq6rn6IYBIULREhJIVCGfSh7AOBwhBbL4oCA4QQ-hbeUAOSHihvIcKCJAM6tUH4mCQdkD1irTPJCihMIRKFUh8AL0GKhlIdJDYwqaBwQf8vhkfDahf7nqEUhBoTEBGhmICaGOhiQOaE4wloYPxGQx1DqBLI8EPsA5Q0QrEDUADRAugnCmMroDmg_ILrT7KTFI6hC45QPKGuhyodJDHKFgCtA6--wFP4s46kD6E0AOYYhjzcLoWKF0YWcraEz0tlFMpdyuwatxI-8QLfSw8UyhsE3BWwTsETBEPij69QNeC2FwebYVAC1hZZMj5K4-9AZ7BO8mLpjm0wQFxgNBXQbT40KeNFsBwQ08AXbOguIAuGTY-SNsHh0DjMmZCgSiGgDxAsLjf7sAALhy68erbPPwYqzqncqr8y9J4HSKffCoTVY3hPuGqQR4S8GMePbnMGjhclrg7u-VwCcAi0iTDAD5hu1FpZnBugQUopK_8g7Dd05isaBRAjooM4gMl8HyE14T3qCrT-pgV4EbK3ft2G7hzfjhGzKfwY4GIASEb7jOSKYbCDSQo_tcoKhYoaaH8hUyr-HtYDEcdRlh8QLaHuWO4VhF4QPdsiqERbEYqGcRUANxHyQb4YeG_e6SDDBgRfoeAj7A5oSWH6hqYe6EYR6bizj8RnVKcqjYymNpiaWUpKJjzA5gFOHmAM4eOE_UYkI6Jk0kkVnK2w9TMyAOo3QAhGyggpOmE1gbdDUwEgqwLfS6YykTQCiR3EUZh74IYvdSrwwROoAM-cANsAQAgMP5xWYQkcGIyY8QfRLoAOyHlS5g44T77eRGJOpH-RBAIFFhiPEXCpK4WkbfTeEvYbADKw24YOH4-rTCmSVRMANVHthrQXWGk2DYcgY6RFgPlGFRDYjlCNRzUQOF5BdUd0ArQRsJqHoA3EUujWhOwBWEukZUYJFTK83BiSOAQzl04eAW_P9RY8hYS-F2YtQcwhDOXAggT7RKEUcDfhZOF1Hqh1Bv_CrRQoOtE5Q7Tp07dOEYCdHOS7kRmg3RzkutGbRs4PJBFBK0V9HdOoYEoCz6n0WtFAxKQCDEfKYMXdFAxHgP8olRu4T1FSR4kWITqR7qvegRQWEVsKjgJwtMGaSc_AJL82LOPjFIsell_DqR18CNApRbEpNFFRV2O0BuSPMupEZhNMQpJzRWERYDqaAQXTENinCqigIgj4K8pncjkLc4zOOoKrqUyIoM9zXgJwgDHgxG0dJLe4QHsNDNAy6EYY2h9MWP5MxO0QModBM0dsAcxnMdNEJAthraH8xcEILHtAwsWeCixGUFM7ixksadwyxcsTDECA30UrE14VQdVg2Em3sjHlhWscTg1uP3iJEoxgca9aXRagSeFRxd_k5pdMAyo_4PqigcghJepIGKHyRAYeECTa1EXyHExbWP7FcRYYjXjHK8Ki2gPem2BBisKMcWR5mWRqBEAYgsAIsguI8YtAAmKEgUkgBuU6tCpJeBHoPzkS72K3HSQ-QUW7SK_cRyEjRbTLG6MicThvrtAXGM6BT-rChC73-qANr5P-E3qfKcw-wkgjZh-wmPGDxiQI2oA0LcaohphAgUagBYZgkt7tx_rt3GLAncf_C9xBhuG4nhELvoF6GaqrYHcEPatoF_oKchmgUe1cX-7BOdxIyq_eNXlx5BM38fKS3Y6AEl5Oqd0F4or8nZHfFseJKr97uB3HtAk-KsCQgkWqt4SgngJsKqg7KY-8afH8hQCTlD1xmIP0b_wzcQPHkJHVqDAYhD8TIEbxSgWoD6e3hPtG2A14A6SHK13om5ruuEiMD0qhjoW7YhAgDqC8iQ8fJD7RxcDZKyJ7-iiZtMEylcDyJMiX56oKp0ZIAKJ7XtJC6I-YC6LyhgftfALeFINNDQAUAO0AFiK2JQnlYzCdwRK4t6g_46-syCcLdxW8XKBgREYSaJQA5oHol8iR8bUHSJiiaqHOJK8WvFJx7CSnFeJBwmKG-JViQEnhAZRPk7OSwSSPFrKp0ccouJq8YnG6-ycfXpxJPiS_4JAaSUM5Hxbzjlx5cHzmdzpqaZB4Cmg2wPho-sFiavCtwNiXfRE8h0XImZJtyqdFyEJidIpgRP3oH5gRj_q3DlJQoH6qNY9iSIliJLOLklRJBSTElFJagPsIlJcoKkmBJtERIQhJmiTkmRJ-Se4mFJYGMUkJJ28ZMmnRR8dkkrYjSeKDNJ5cdP5tJcAIkDNwv6J0mxWdmGj54R3dD364Ru3g4GA-Oykuo-SdEUPyQ-OkfiivUGqvZpwA9CePE14QCbOSuJ68Z4nrJWyZnHm8coGQlBJ87p2RTxFErrG42lCj3YIpB8Z267hMKeGpwpCKThBI4-0UgpeSWED3YCJrTJmFjxvoLPHzx-ykrhzJyKZEk14xySginJqcZimtA4QBGG4puyd7ikpK6OSnkJI4ZWG5QjKZ5LeSrKVd6QpLdDWD3JrgI8maRK2KXH8pjibHExqyyScmrJZyRinxJx1BGG0A0iAEmaJGSZImhJ-ieEmPecOC9F9J30gMnnRAhtqnGpoiUHJHJbiSKmWpYqTakFh-wvakWg1yXsnepB0SgyGpdyU0ktJBnmeBfszwbIQhiLkbZ5gKCfiSqwCsoPAhS0bSe14MQvoLYmzJJqThAOJQaXVARJcccKmcQoqecm2p-wuWkiMMAI6lhJzqYsiupfIoclNpoaS2nhpbaVGlygnaUUTlsqmt2k7Jh8fGkupByc-FSqr0YdF-pjhl6EGGVEYxFuhlKVMrQqoySRG_JR6WsqfBZERRG3R0bLumqRLgUJErQPyYCmY-l6TukqRNEQunqR6kFOndp1yXyk1pf7gKlxxQqSOkeJ4CeOnYpp0TnEqhecfPIJpp0Uqnf0KaQ8lppcQLfSdA0ahkCfJdif-lt6_6UslK4zaaBmbx1qZsnoZ_zD2lupjakrj7JYSdEyNYuqfqlZka2vuyZCVaV46ppTyVthzJQgf_AiBmkmIFRYQCVIFdxCgWOmcJsOFXH_p58esGdg-iKGxXx6or7LpS8wANopx98WMJLAkQujYFQPAcxaIBwEpOhQmBNhIYAJEJjoHCaELnOrB2v8cAlBy78fp7BinYLo5-uPVOOAnA8AAtC22WAL9QtAo4FiJ2YNma2p-ucADDAYk94Ev7KJvbqiZPBzmam5Tog0EFZ1K18BpFSqSWdG6dkXupYI3O9sZs4WCDzk84HOF_AVKkkbatPx7e8kJEKJYSKqlnKZMelNCZZqWP2Yqu9zo84o0zzs4ChgGGQIrdUdanm6zuQYWMLexLBKVmZuMUHFA5QiMETBWQaaeOEaBf4CGm9ZDaqpnj67_jKCGqi2cgaEqGdmb5YJLgiapXh0KixzbeyCVNBhZsBpFk_hZVOcrGBNULVmr8DWdllTOJMi1kFZHWflKGI5gA-n_-WLkWmfw8BjPybQt2R4DmBEIZamXqa2fuqxWb4mdkjYG2UCr2axIrEQZSRgf1orYO8XUaScK2GBGDBrYjFlhZm_nwD6Ed2RlnXOTWTll3O-WW1mFZxUtQIs4K0G3TNANORBqd4kIUDQhq1MR2iJMXWdF7YACIFfBqiPkiu4DKgWeCJjK5oDXgTK4ubuEi5_8aCpz8GYngkVQSCRPpj-cqZxDvRAfLaSzIJmXLmwJ8CdeGIJUbvMCr8ZGSVLHKW0C_F7ZkSlETsAG1Pmqhos2VBG3qA6tEkQup4C7m6-mOKFCjsdKPjkYprvJak_-sOH_6d8AAZEGwAwARRpiQAWO3YdIYUDAAKZshPagjAQoHHlooiebMjaZEtugGdRYJgZm0A-Nujh6G83I7kWZQclZkZ2KeQIBp5CIBnndw0obKH0oVeTXkJ5rsEeqJ6uNlBBcAk2uLDyQzebyi15bef_AxZp6im7eQphqOCuumQu64Ww-VvKFBZqbksD958eXXk4AYwtDil5wacOkbZo6VwCrZkQIaqj5s2qqpGolkX9QpArmhr6k-NYP2ogZDqvZn6qzEIrns0QfnjkwE1UU5n0RF4fLki4Zqg0pxInCR3lXRWaePqj6j4Yd4AFW6s8orQRQV8o_KwAH8oAqMaCCqIYrCq5hn5BQK5pqs42kmFnZc-NDiCkH-evxhB46lcJbBnYCEqAFYJrEzuZcAJ5khATmd3T0gkAD4DWRamCQJiQdEt9ABA4QJwDgRUpNlGXIv6GvA4g_1KOhC5f0MtH_wRBfeBgFVLOQXr8K_A8qb-0BewCwF6AN8q_KnMOvrIFK2PihnBD4cggK0o4MeF1QU-ddBRYZBRlCdg-ns35gJ18TpFIhLGddCGFwoi6TYiVhZ2C36SuHDlr8I2L7FjhAnm2pJC6ohtRnBZdrFneQXACtjeEwyhtlG5dWVjxxuFsAm7apufG2rXxNeJ4XwOjMcEUYk4KQd5tMK_PDnyF1hTkUbZIRcgh3pLONCq1qeRf_B4-kRbQnIIyaR6l_hqgIWCy0fEERDRhnMHoWn53mSiCYFnHm7mjgHue4lpk-KO3oRqPqh37HpT6RjEzAnqt6p4I1RYhhTFoMMRlbq8kBgUzgtBLAlvwKIPrnmqiAdirCJ0xf_BaqsxZ2ReK9mX35uqHqt4Beq2qmsUIqbtK_Fb5d6uvG7FF-fKTe5sQHSgXFsSf7m7qEOUMnIIzfIliLM-niHm_u4eZtm76YlmwEfGSmixrCGmmqNQVW-8nejCglAJvFss7XlkBFwqSLfT2opsm2q36TRTiXqMAAIrzYN7nnlGozEI4DnOv0QrCCksMF3lviG2ZSXFwQyAWI1QNzHVIbZ1JZvx0l4sPIBVimZPijMl1ANzKzY82DsVWomALNj2mxPA8QRgaMkjR7MBQLZiJAWKLMAsl3MpV6_G2sBEAZQ88W8mDAAMJW45Qazga7k5WzkK4LOxzpYAWxaKELHHcxunYSOQ7Oo-qGlcpUogKl-npJljAxJdSD0omkr-jO4kqoTSP4cQLiUWl1AFaV5ANpSG76ql1KvFeplhEAWbeBMdQR5ATyvJD4B8npdHEMViKFx0MEYMUC5kH1Bznqil0KSI5A7yjyUaFxQO5HhlRsJwo8O7kVXE7opUdRnCJBMQVJ6GbxY1hqMFtDAEA5uZQRqGIUAM7jyiRYf_ArFk9m-KRCvHiuXd5NeK2XT4GZA6rSmEQeuhqhmhiQw4AlZavFHlhqdCXSZVkeqwiQPRLQCilPahiowEWebpm55iAcY6QYGUvK6KuzpSq5iu6ria6Su0rudz8W0OfKRP5L5RCWIJ0iq2WWSaCasC4lpBJ2VZu4IlBUYkR2b-pmleJUoEElD5Q3gygEZZhWIVCZREAoVRFUbBFYlFX-6oV1iAkAnaOFRRXWoVFY6qvELHN7QHlcoR-XQgkJURhMVMBKhXUVLFdfkTldAPSjisGrARUV4AlagRqhJeSeEUGwOKR5olyqg2mNYn8btm1pTuQ_lCKd5YSUKST5TAljqEQWRW4VMFdQXrFdcfhYKldpSa7jOZrk6U7Oezl7CHOkZq6XulgsTXjWxtzlmpsyDQNq7e4ZlYH4Ykm5SgWz4K6XJYoolsd0BWKG2ZpYFg3dPb7xVVfrkC30_WXYr4SHgMkCil0mMmVtGSqnYDBwDQFumKWzCRSU72RQcFVwVFVd8qSV95VfrFAPhR8Wmp1asBk75JwmoEVVMGTWAf-2qSY4ZSsbhyrsIysZvpYgsMLO4KlPVRXEIZzVeZlByndFXiuJHVckiyVtyq2UKEkVQZ4FQZVk0XZMZ1LZ6pVYXGlXW0N0GkCX6CQMkCCgSQMWLmACgmrnHKMuTgkmVcodCqtpVBacVtYsRb37xVnZNVVrK8FZdGco81a1V5JIGe9XYA-whtlHxXVX64N66kZvmg15qWGnopkNXKD2BEYcClcANyWtXfS8FepH4otQXIUcKuCQbn4JPCYj5rcuNQvkIgDeliGLICNSeGXxQ-cgjwlpyXcrCZj8YjGaRe5SumwlYecE7HqK4B8D1YgGKhqfVJ5RWXawF5fuj4FR7ojbgGqSOcGwAQljTxKaIct3DfwpHHJVu2DATnnMKNGEXzi-VADMDJA1MfyQF2PJNYr1A1gNaLWiOAmlW5gLAG167wyQNlWoKZNBwzqlLoObSxA7SqgDTYSAl6K90MKTkDjhM4kLSIlc1hxbxQlOvaWOV4FTLZ6kpBKtZflKsbHVhmVrjS4iuidTzTa1RxFhbB2Biv7bh8IEinUB84zI-IDIUFdhBBaFddRK7ouNHwm_wofMBylQHIMcH0ecga7Bj5WbkpUT83tJZkABxvsDg75sOMGzCFQtLZ6YAIjGFyESJkankD5xTLwUO1jorZG9gcVU4l96g_Mvnp5LNRLzW1pqtBUfCsFWsouKF2WThWGdmLvWD5tBLSEokZRdhKxVpCsIS60n0tkyoZ-CmpjxVEYscBsYLkO4TvZzIBtkrgOFlsSx5S9XXlRYN9a3kkkW2agr1VBlc5FJSrkcISZYSligVqqobD2r7ZCuSuDH14tfwoDCcmRYpspXYZAk0AZgr3UhZwKhFlBxKJq2j-ZuUC5F317Bgt4oN-xS9V_5FlRLWa2_KMZAkNkQHXkENMGLVnLZ30t3lENGmUQ1aZcteInb1WhoZk55yldjggJ5HmZnaVzcgslaBluZo12ZlAKx6GBv3ufK6NpDLLnnK1DZglQJd_m2pCk1mbjW92lqPhVKN4hOPXKYkNPFWmRuEtkBK-nKMnXGVMoeOq1BkqukVw1O9hTVYk94T3W2NBwd1WzByygykJpnKYkUQpnUV8kqpCaQsobp0WS6SI1ViAtm2NJwjuVygkQkfEf--0bI2tFu0Rk2SJa-R3bxN_qaVXzJbasYXagzhSvTDVc-VE3UNsTWE2LpgfuvlzVejUjV1FwWUU3dVoJQfn7qsNam5X0ABkxkzVGdv17zcQ3vJAjeY3owCWpbBlEQzec3gt72FimVs1reQ2aE2pushfRGB-IDaDmYgvdct49NG1W_lqZ9co-lZNF9dPr_J8xf35Y1uPqCGiErZSfmD8RNfJD7ZW2mTVK5BCadkI5thaunep-3jW7IU0ymYHRuDMbYYrFGAKkVK4E9T-hS1VZTEIv1RhbQXAR0IIMWIu2TDA1EZj8SqCIZGlcT7bo1-TYTBszSrsAU-6otaJGwAgM7g5AfcKKVL5zoniBHgg3HODeNOQEZiINBFXwWKwDGHTTjY7AE9zPcW0Ey09UlPqvX6VD5dTKvcHPDFkilOFc4Dil9Eb3X3Fe3tk0_eBreenApZlQ0RClrxalltqopbq3zYV2Mj4IE2rbiX2tDTZulGiymNQDTYLLUYXWiyTQXZdyRLSUy0gqrVfq-ZmlGcqmlyFXhUSsSDTvYR8_1bMhONcbdJVqsagESyA1FUOaD251TfHGwZtTQG0TxTYW1iuYSbWcnONCkvvhK4ZbQ43KwKbVJXyMpNScUv5rZavz41pVGkV1tlAA20NV3jGioPo5JWE0WytrTq10lnNUYUiWy1DS00AJPitQO5TNVsTCNkHpakc1rCR8JkaTDYxUxtqBPW1ht3jPfVHaYlmK1ZARlagTbt5Fe_k9t-7QiXyN2VmJYiIcJYLV-OTJoDosQCslPyhOAEIYK_S3JtxAEAHgNUASwyTrQxgAkgIB3eAeMu3zcql1uNGCyf2BlxoI6wPeSwAQlRey_q5IAxzDVGUAyz5G3Udqqd6rgE8ydgJhPfCN4A4mKDhgmjIR3odgdP0iwQ8ELYY0dcKHi59OCCPMQ6mhHXjKCew-skhiGVeFAanOppqszmmCNsmbq6WoFToEyhMuToSdUnb9yEyOrtxY-w8ajJ1Y8ynfJ1EyOru6Y6gD5qp3k6OnXp3SdTrj-p0dOwIR3FY3cO_bTKsAsVke21lT_JdCE6OniNA5zvEiJAIGMtpDu6brEW2dH2Ssp-d1AMCyjazBEA2oAwXa1EN546qTFqhwwRhDN6-6W1ikxmeJKF2AJbTWL1aKXYaEDIVAEKAmQRJY6Hwh1bS6TJdaEdl3MIeXYeG0ApofCH5uR4Gl0ERJMZl1ldToTl3CAAgPl3VdhXUixp-KwTEV2YXctRQ5l2qaV3ddbXZV3O2hFamG1dvXSQURBYyMvrHlnqQt0y-mzcvq6kwoKxHrdgnjlArdR4HCrVZ3hHt3dAFUOt0KYW3fOT7cO9sd3c1bWFO0LNq2FtmrutDOu4rgYXTu7zkz_JAITVl3YJ6awl3QpiwaOJiAGmdpHdsAfm9qGF1PxuAijbUoEHVgBbegXeRrVgrCl-hM20QFcB5GMMEmD82TNt0ZY9jFPbyuAHNhj3c2PXFI6hovNvj2QCh_oe5NSZgDRiWMbxNKbxKQJJJhRAUwK9T5AM4FHmFpBADqBFQYPRQKOQQoBz31ykQn5ydg2XrpjtRnVND2b6jnYIZmlVwIeizoHnVo5ed6toY6422wsI41g6PbNKudt2HyJE9JPYb3mgqve5328dNt0aW9JvSuBU9KQFcAW9bnfb3a9hfkcADeY4MN5Va7Brt0z8ZWaOCXd03hs3s07Brs3zeV2UajHd_vVrCB9y-sc1YkMfWt2_dr-pCTbdr-rH1B9-3dYSHddmDH2ndAPRgDp9Rfdd1ZAy-vO12Fg_GzQVZAfUbaYAifTQIvlUwJs3bCtNnHjRAkJG30G9YBZG2rYefblBs0FUN33E9HRl32wC7Nh0a99lfWGgUeUAFtHHAdfWbY5ojfZt7GQ0vRR4jRCLRir_UmzaWXap8_bOByC8kEmBWQqwT7Fpp3hIf3je3fTb0pA4_f4x49bJYf1VZAkVKrX9w_RP2O9D_ZP0L9L_ZxluN9_KYzcMIUFRXEK1dvOS12awEwaI9j_aP3_UG1Lf1x4_1BVBJgRMFpBI46_Y16b99YXL1CJL3ZBoC9eZO0jC9ovdED_ZWsB4iQ-m7Sj3CJKetrxiEGfWaX_dR4Fd3822wnT2EYdbJwLFk7SAerk4rClwEY2-tUAX4oXJUsDSNlWl8KQCPwvHjiN1wnx1DOmmTap4Q1KO0hatRHv3VYkwmlPzrlpNYvwScy_JTVr8OqHfTOGD3jFngeHYHr02YiOffQd2I2JVr9FSgythk2PXLIMp4eGDFmaE8iP4CEdVCe0hlZ3dMa2UEgQ683eWCQN4PtIvg3AC2lxOPU0hDA0GMJHRSOMkMMxhYdgzRDfg9OXdUVg-vwLKtfVrBY5tjuvzbCEPZBpC9BWlplppqBglnxQcnap1pxtJmXGFkWQ3AD-DKZDKptDlbthpruM_SSkMGAVSPxmlw-kIM6ZzGqb47YyLWP5hdGLZ63sATPW17htPxB71i9-fu4RGYB1ItVVthiD_JOIzEcAWs4hONxrJw0mlswrp0KTRU08KHVN0kl8AG-QODRw5Ub8K1wtC0WAdFWdTbcIldXWzA9KDMAcVItY_iPoLHJtmY4mZZGWuAIwJx3TlllVX0GGmHf4NGZguOKBYdHrjh0wsUWJkBQjpIoR1vDnqWW0IjdfWw2XR5gwakukhNZCNg9iI6kAEdM_CdqEjlA2jG7h96pDb7K3uMbyuWOaFjEDKhEOX3zk3IyziMxlmPAACjbWO0D3Ur-KKPVYjMUohRAUozWCbVbRYcPJFQoOiPwQ_USR0WE5HYn6UdU4AUCEdL0ZSPtIuI001CORmUQOVDPXCL0CAHPYaNQjxowDlbVadeOQZSGnY0ORUJQ2xmgqW5UJFVS_KmR1IITHXSMqjAgGqOqho1WUPfdZPerAX8o1cvpfdPXJj1s2y-t7jKcPsccoxal6OIajDwBlqBzNZcdcTVZ3VHGVGE6ZS6RiVWZZpJLdjZPmUgIhZWIDFlBAQSimY9vuYwbo2ZUHx5AYiNIi9lQ5UiwjlJcTkngjFA64DVjyZhe5I9LA_OCtwH5qoMVDDo1rCWdRsA-DVD0uf3pf81w1RQkDVQ46O7hzoyzip6bo9J2jVeQ16NYRPo5zGL9WsI5o7CH2aNXdRsAubIsxCvdOPOgT40JFpjd3e5HeEbg-rAeDHYFt3awMHd3xQADqMQlTKpcYs2LJXFfShHld0OWV_g55WLX5jFgHPxZySQPAIScmY_x2QGDBhiqDDeY8IKGOtcYC2R-zuGD2kB7SA3q3uP5kFaGdKnceNgeno2VSaE3hZdpwohAVVZwk_SPXLtuQJP7b4pcFrAFIG8vaCRg9m48ZkqN3tLoMz8qCsZAF2kNIKRbtfExCRlUKk1UJzdcoepPbAsXXXFUTO9tpN3K_Rd6G2kFE56SU8FhGhMPgDKCxxGDAiUfDw1jirlBiTw_NW4omT5DFq8DR8Ewn2jR8PmMLRUqi5Pn8vqeQT7ugQ9kk6R-44hiHj0EGWbm67o1SnMT_VU1hvihkxeOgqp0Xu6-TOwImmOSAyp-NjlF_cMQ0Dcll2l80eCNdhxKIrRYRgepk5ZOaTfw3VN-TQBcIraTdgJ0NtTVkwvy2TELeZNg9QfpCQxa5nuRN8DQUzlN98GRIs17Q_jrZyamicl-3cwkIlyYmC8sPjSE0YYN5ArwjTpU5rTRNOFDUI1TmU7rwlTtU5FO9cDcy3gR0xU6bw1TreBIyyHWFSodVw7R3Ij7gDPmqjuHRey0jlAw9NzkqHYGNHwzHSxIJBsHT3YHYxiF0gegbHVqZ5WOIzPway2sMfCkiGULuKEGOQOqYwzm1gO6idIzo3A8dDBnx0QG_RgwaCywnbuw4zoFvihyd8iGeDlc1ruTmydWoJJ00zdM9nXk5SnbFN1mLM5YD0zDsU-41mnM-brczvM8mpPuOrnJ0ixFMmjz2AKnfs6MzknZLN1JMsy5Xo6lM0ajXGYutzr1mBzgHA915OhrO3G_3JebOAus4mZqzg_FS7CzbM09n0u6ev9xWzDro6XadN3A-YOzZrgZ0uzPsG7O3OHM3FNeztMzzPWzyaqH786SxpYCJqx-pJ3UyWoPaYHOiXe0Aad3s-TlU6RnrTqLGDOhHOW6Uc5GaxzZs5VbHuicwHPA8hXIjpyghc6zMncJc6rP5zCtTxBngXsAULewbs1XPRm7QGdwNzAcE3NFzNLi3O-zdZg7oPcknS3MCzfsxbqDzKs3nNjWBs-LozOyfETLnc2sybP1z-s6LqGzs8_aaEyC88bO6zOrpaa0zlMtPNazQNpvOSd288vNY8e80rpNzq8zPPHzW8zrP1zJyMYCmA5gEYAVDO4nSkwAwagCV2AG1GuBhclAvOSRwRwPsAsY_aD7VaWvvuAuJ-vdPQoe-xCv_LPwimK_PsAyTq9TegFgMABCseEHKyYUDgD64vjwC3sA52RwNAuRtb82gvawGCwpDYLLwzuJWANnmQuwLLoBz5qY-RecB16nvZGIMs0YkwtCslhEUAULqPbQuXjiGN_O7c0YmTTsLzAcERkL2EogrJ-OQAdTJNgi7yA4Ys0JwIbkH89PGwA4i_cO4LyRPIM7ihPCr45uARLnij6BHFgGUUPXjrmaV-gAESTWBBn-Sae3XtRQfxRqJ0oSLAk7KzSFO4lF0RBZAcLQOcITXXEIUFi9ShCUQdqDlBLTi0EtcUhZAhR2yDYxQ3ngWqBYuUE4S5n2MANgQHSOLxfXfReLSLAO0UW4mZxmVxwiUUtCkhGM_OCLzi9frSFpIrbn1LXouYDzEY1X-CCLdS5QuZAsoApBMxOCwjmXjZCiCoUL6C30vAAEdZKB4Qmbo4ATdOSLERNLuXR11Vd5cH3Blue0_gqki3S-MuYLAy08OiLxCnErsIZdmzg7LVCxMu0LQS3AB6L2IHy2SLamFAtaoRtG6AyLi4o57c0B1GPqjLqC7sv9LeInhBjCdgIcuZu6mOgAFpQCkIAgKSi8kBILtOWMsXLmC1cv0L1WAdXUxUiw0UcLY8E8ubI5y70uYL_wjMs7ie4p2gmO33hVnxMjGMkBGYuZBL7rTLoP1mQENNOYDL0L48S3pw3S6j2oVeEIct84mbHcMxee1MEQHUUZfOWgKKSqCvWi3y6otmA3AyHS5kiyDqYMMMOZsykicyysuTdeHU8M0s_5DcsYAP87IhNIjw9ct8BqVLuKGwv9OThYtc5aQyBeA6iniKrpIq7FqZ_3bADqrnXQ1rXLtyzCZ2YyQ25NRZzBNvB2-oMA77tjCc3NiegGABCs8-U9fbWi0tftYx-iPuJn6zuo4FiuYZT3cmaHCutCFBCV-NjqZCVDw43Vaaby88tLA9A26vtdHq1qvbiuq7cs7uxK4bCrWggQkCLIea_JAfDDFdmvFiwlXcMCLGdvihXCpIqhW4ZYZTRWRl8ANGU8VX6GdRtrVwxWMQj2I7AC4jM5aKsLlB_WjOXKJRUQbUZlI3DM_T39HI2LNN_MIlDrT0yJWF6tSygtc9zRR_BNLG1DeutLqJAyQdLz1N3SooiQLYZgyHYMkDs90QDgBdLKCz0vULwAIKHTLE4HuvLrNqgMpk0WI6-sS99S60rrhRwKTRqY3ayFCNaIMJmAgMcETQh6wlgLMzXgjkEDDDVHS3isgbtC4M5wAE4hIxYRhvKkFaYamIM72SfGGz6ZgbBZSCQjHS_ItlV8SsOAHUCYTmjz1xCqep9gAM6YyVZQG38uTLI4jMtqrVa6svArJjkssKbmq_xAbLG01st0eCK_is0LDLHhAEk4m9sD-DiGBGB8l80PEBlQyERYm7DWyz_JMLoXF6JQApoOgDJA3yx70prpImh7GRIrQyHeRkm-wBCLdA2BsEAPK7ys1gH61-subsmBkBpAOQAFs8gsqxosh0N646uwAdo9COMjVGzRtHgrqzADurim6SCXkRmyuvjo83JJvWZmHe9OhjuHfjavTqIxbBhjmI5BswAJo9hY2q1yt9OuA9IyiPVbTW0sAhbwoUvTjiiQJOItU-IcvKryI4zSF-9nZPv0vqwia413tWayVsdbFQ8OurbWsCOOKD1G6NsSMeWwVuarRW16Sbbo4yesEDkW4DOyT9PagBXrgW-tuyQG1LmTB1x2OxjRi7S7O7kbly_pv8KZ8ryuqIlSs0D_yf26lUaKmw7nZozHm9pjNOZItxtfbSKz9sab8IE1FeuS0T5nUxSO-yzcbWWE0sLKXQHrQddWIAxv8KZUKDt4S8vhDt16Py8BsTLUy6FsiJ1wsrDx4uUOZs9g3At3S2iN0Gdk90ZNB6JlQ6K4wvPLdS1UsxeSCk5680YmOGC-bxLb9QfUCW2otyrzIDcOWFCOUAiY7CIAe4M7O4kzsp4OUAd4CDwiWMPZ5VAaIOEeSjVoOg5uY8MNl6eE6oYUM4jWfL_g9nqvHtA5oK-DQ4ntmzjDD3jKcOaas6R6moi48gfXCaicuvLeD-FreAOF4IZIWq7AS3KF98M5bO6R7_8Gt7oAR_jDCB868qntMUs7kNn3dLawqFXDQYZ3WDKama2xcNBDdROwjyZjPJUkY8PJBZ7Z2UxRwrAgMZNiQUECaulrmyCStjaI25OK95YfOMy17nYixilx-KH6vPrycsgh17tyn2LO7iLvm5YgK6erso7N6g1Nep9K-yw6mS3Yy3aKPVKCuEtDtfEDRbMu0jb0YKIErjzcoK9SgR7iQIsihZCOaEFXhBg6d1r5J2b0mb7Gu6SJv74E19V2YMqqSKjh1q6eVkM7QBfIF5oKycIr7Opj_vuR1-0DW5A2ItAff79zHYNTKXq_qu7c5em-Jxkt3QeO379-03sQq6Kpm4lxRYyUpZ20SCAd2r7QA5CeYHS1AcXQmyzAeoHJcVtX4odzMKN5kO4rcuJdLOO27a7eJbrv-rcwepErQje4_syKTIk1E8HmB9kFCRWU4ztCHHYA_tqZJe1G3tCsh7aLwAOu9YMVZtmJ_t0oNeJwdwg3B3WtyHNa-OTf7GB9oeozVO7NXkj1leesCrwLQ6uNL6W1kUI53uMgd6B8m_MuLY3uFpo14Nhz_O6HaB21jJT_mA4OUxO4nGONrnaKmMOHLOFCHzrJS5m6oVeI-aTDrNFQuv-83y5cpmeLW_4MMlvDcpt6BWhz_PYHeu-dP5tVh-UfmHth9gfMIIkOQMhHu3GEfuRcB9_sFDqSlZ1pbRh0JFYjmW0R0E1fe_tvqRPh3jh-HGqzkhxj3R9dssRW1fe3R1QkTFOjzzc_s4njSU8-NnZQKputeHz45m6jVBU61SDjV5VCUqEna6BMpH3w2COTlB2nfTYTRMzmMET-YzFpZKOpijPYHG-8wcDuUFaQdL8KBxNNHrv9DUsmAdSzcPNLttV6I6y1ouIgvAVbV41JVIa5Kt2AJhyDBctboEZCoA9cGIVHAVtP9Rk0zEHUvQnBkaQq67rnsvA4bUpMvTTYAbe0tKTr8_DsKQdO3hCTHemCvuvrH0jwj_UWAIkBEQhYHl2tLOQKgcyrNc4aDJbSu49N0okxwbsEDRu--UdaYlt1Sp6Es7bFSzkrrLOgejWKeMBuvx0kgXHoOck0WaPav3WMCoe0HuMGcI24Y6L2xAyRBq3_IjSTbxIVFjGnlpxvKmqeBAnsScbp_acwE2e1IfjxnYcaReEdmL6dT7ybYOjEUg08drK7CWracmnG6oOj4qkxwoSTToJ8JB3bb810AVKq--XAbUpJ0cg908JzcDirwQHzQ_Fr69aLDTuYH3DYnuJ7OAgMBJ4ZhqYxJ1JuIremzCyArXAIAs4QZbogftcRmDmfaORDolvinhNXRIUgHbvaioHOZecZ3u8UO3O0zncxseuVL7k2yznUHmNbvkaM9Od6ccFhcZBWGnQPMLzLc1B7fETGOUxln5gBQqstXop2BECRwLphGYKi-osiQPAynjbhW1kKCLIlezk3PdiqgqciDllTRiiLrKxiR-cUpJyefboOZMcSTReQPVJyycHBegNsZ9KdRYqhytlSB-pwWxbZJ1lVbGQiZ0YX2oEF_UsaUWefL1XC9C8C3SKLe2ow7iUdfVjzW9Q0zNdzFc2a6513VIHwQXSiie5zol1SEA3Abok6J-1Dy_gqC7myAAU_z4tNtS2nCVXiD1MvYKAsyhBZI1jJN1wrcuOajVJhTwptp7cu1H-HC4sfG-uFRe6rfpHhh36W7aIpFtnYcwSeTn5wkDfn_oazWYqeF2J0TnQUM7hEXFenBqwGQk35ZsWSFgNV0Tns2xeBzjs1M6cXMReEfKca2GCcvz92--T_wn5PQsbUXjcpdsrTCztUXYY2ky1WizQEFBSY_WUHUU7iGz8vZVL1NrAfUNkSQtsrniGkDyXxCkEvGYJ--5uYCwl6IrMnWCz9sGLARPgs5um4eaBi2faNBTorXrmTt8b9SyBhyw_Gb41vzcETec8L6KynlXj8h4FtqLxnIrvmASV8ggpXuq_hNGXWAXKeAXwk8ZmhLpBpoPQmMWevLe7qlUhcJy7pzFlVLRBcnvEXrHCoSDbU2-vKY46-3gUzlge36dvXEh2odt788NReT7vcvSRTg9F2ZcztlSkVCfzGlxYcPRlp4GdVRFR7tyg3IiYjcY3fdVRTaLFEvpeX7Vi5hT641y3RlY3VS2UXWdu05psGX2N7adI3th_ri_ok0Yze43EhemQXDnixYdignlzTcGHmy_Tes3ONw0cGrf6SMCi3Zq7csU3Tk6Us_z1N-vxjKyhbYd83nuErfEj2qY5k5A9vu5si7RmAyestzQIKjshmgdVhRTwV_FDlz4V2a4pzkumnMC66apnPjz0c7nPe4up5Ee_b4R_wegwUtx8Z6rzN-pFVLat5y2pju5VU2IY3hFTcPnGt1ERPkz1woWvX5dE3s5Q0d8gIR3x68BTK7jVyLtrTjzePpwAMvLctEFOUJ9cun8t-0eJ3d-1zVN9Z2YXe4gxdwoXRnjx8dpK4cZ3XdF3Fh0QXV6NHt7SJycF5QWhHVd0ep0Z07V_TxXdS2KAvdKlk1qpBRwM7hXWK6FePeiboJScwANJQyACAufjpsYLMmw1J4QZBuvRqYJt9KYh0FDPDvFBAKx0sb3GQMkBH36CjTTG3ENxMTD5QG6j2snCsLYBngAoNJCg0b7BNq405GEbAvMEGnQcYAoMyugO798amsHy6M2Kf4o3sCYeJAFmhSpMBmbjfdb3pqx8ZJeBbPZ3V9IxbLYWngN6HIper-hAlBLODyFnRLuNuf4hqkS_-SUPCSwo0gF3cBA808S2-sBl3JIW5Fx73DePrnX10W9eCkmFzCpDZV_aPFyXmqWk0rYpIw9242UIaAPSH-VreCFehh1QmkiGD4kA_7PwzMD0orB-VBo50irO5dTDKIAeAnViKgf7eT4aGge7oAWJLQAfonucKPnaEo-37qj5ss_5kYKKRmPhg00uJDHS0EPut4VewDQt9iwFGv-NPKIrhSWJAmsOPCYvlbN3RPoPyBAKIDqb9R9j5QpVR-FhaGNYgpGw_EHg7ZfsNKSuAvfjRVHONFC0bDwdgWsK-jAcIb6D5vcedznTGoYptD2jUz-ETzJKFTD3V8bMP1imw9ig9IBYXE1rDyBOXheDaGgENbD86p0JYz3FhzPYylvKMNJCXwWMxemONr_MaCgL6301MbrSIQq_pwKsL3QOy1Rsm1JgD8eY4P_f_MCDaS3wRTWls9hAOz0cDYyWvGSDbUYz6cIsYbRmm4rNcAEA_5bTWhc-40391fD8hUhcggDP8AJkJAvYD5NFjPV9YP0wEkL0M8L7YynNtYMcACC-yJqTQRgD9BDfCljPgz5kLbNDBE8qKCZVAznQKUmMdXRr8HPT6vPOEIKR8dk9NiveRdzwBxwa3QCcD0FFTy2Kw2xoOKydiSwCAzcvCTG8byS0ON8Tvy-yk-u85oEZwKZYpT8bC8vnAtyd8YFZ1ajl-EGo6K-1Lop_UStQq-MB6pbvgMD9ABicKRXPlvji-fq5B8BR5PhL1C_DPYu9zRqvemNz00JE4dC-hoGJMi93aNF6gS-vFhTk8okn8qL5xBLzzEBvPdng55gK-QKkjLhciHCDCnfhWS33Ln9SG_HPii0PyTIMXrhv0gvCobAzQwREq_BESD4nbxrjWgBwxZJb5E-zPi9yeIov8z_W-hnuUDW9-U6L4UuYvP98kBqD93oWNv9dIcphrwqmg4gebSILhJ60-SlaLtc9IwBypBXkcc8ZApz6bTIGWNxs8i4WoR8_yQbb0fWsALHIdwr8e_WmTWGTWpu_1viTzPSWvPl8ByGptryTFtcbD9UclOt4AlpjPSwAlr7vyskm_HKtgP88gPl6g-8LPfvRVC5trVPhpbYg64c0-vDryi9wtKiStDccG-tB_1vRL9dC8eEmXQPAv3b3_cgPf93-9Nau6oB_1v4jRmdGcN2lteNa4oAID7GaknC_1vt0OOio9MdVcCHzdxovOmzUV0IpdvoLzrwjYqbDsB-iIDybGroPjuPdidFHw1QQPIWBZqmPsAJo9YPWAZQ_HXd_EBcm7llfnl_uFu9afsl_-V_fYfuNLh-APfRoZ-wvj73OOIPjTzJ_vFvAY9gaPjT44MIUlDyGcep_SjZhXvgHJ2GTKpe7cor8xrQlQh7aJA5S0f-T9ztXYwKoT5Y3GJMVjNDhOSzj_yIh95g14K0BVg14Z496MQVayulNYRMDxSJENOX97cDKaWUFaiKRX7rxYRLe9uvfSLe8ccrYFt3UMsfN81rNnzPdfrge3nh8giVf0X7mTe4en6C9BVKHIJ9NaMaO59kNchL-_Gf9zyNHe4DVIN8Acw3_-9SP3uKZ9vvpUf4Vz4d74hiZj5INR8ZRdH2U-7W8zcD3mzncnlSh42ShA8KG98X9fzntE_FCsf_3HfOnzD867Drnb4l-hZfXt2ehbnNtpR_awNH6_jZAZ32e9wdU1jRPp1VwJfMHzjX2x-Pf7H_XPffOxhta9yatUCVHEqS3tepUfvIxcY2v0-ji7yiet4So_fclb7cCX6AhNnl0tVGAgAdhCGsGKjokj9WkqwPQUHUKXyADQ4sj9KXjStpKQQ3ofEEZkIX5p4F9h7Kz_JMhiik7LlE_5e4E0RBRPwI8sP5zSImB-0RaDmgkDhar8wEvP2lRN7WJOr_EXbzR63VYwB_QYAY7QMZAFAzq_w-1fx2oReWnPk1OrL0GPx8aoMG35t66_tygG274mxRI8USCBET9o3KTUcqRTx2rmRfn-FtaO_neBViqR3VYW1hu_30h7-hTzKWsoBtCVBYBx_-AK0ye_Sf7cq6iXn39Dp_86TBRe_ayoX-p_vdKwCB-4UkX_Z_30lX9l_6fwEZPUWf0r_OazuM3SYtlB9i22rJv_6jm_UD_sKNXZCbRGJ2xf-7-2nGY0Fcwbro4LP-z7F2LFPu7t9sdCR2In78ffLOMk1ZTgfsk2jVuopv-0XL7OpHzpe_yX-aJo1eFLH_tyuFKjVjf_FCr_rf2V93d4d9S1j3LQ_55Z2mHaO_IQVU9YqcPzpySFx_7Q1iA2qF4e23HeIlyklUrU1H-9eWbaN4Xf25f3ABMZzEsNZ28uiDDj-DenTOcVyektnD-wbyC4U9eW_aNQmWmEThtggKFbgIKD7kGMiS4iHXlg0enIBeLjJmoslRc7CGoQ4kzoBkM0VkCCCn4TAIhkFmjYB5SA9Ac00C-3AOoQSpnwsfALlkAgLRImM2YgCT2EBuMymARuHEB43ECcbJjq4eAIhk6SCUB7oDsEQTiDkcgMfgZWl4wWgNogOgJYgARiC6cgN56SqjoBkvGbgZALwBUWHHQrciuAtALwBYLGg4VgAsI5AIw4DJBY-aJG8BEbEks3ElEBWIACBAAl00xjG4IYQIsATGkUBbgJs0Rih8QKvWgsYQN6e6Qnaa1gLwBWAPsErJkkAatCYBYTj6k8sEcgpKGvaIuGuq0QBAYiXE1AtRFmA5oExAO4BRAnoDgAXwGhm2tjyBgNHNAYACSA1cEoAvRXKBv6EqBzAPkBCsBHO-iBbg7hAxk6ACTA5oBHOeMj1A1MkdMoVlJkZ4EvML3xoQGUCu4INi9gawK9MgZWZiIwKy41SX3MxXAKyewLvKiLnum1YFjM_5mcAsiEp0vFmV0siA06jwJWc6wEp0INnCsYNjeB1wP904PHnM7sCP005lkQi1kkECznuBZjnPMD5leBEM22Q7JlsQ5LlrmoIIPMpXBy4sgnkg6A1WCVgIe4jkAygGEhx0xwKWsdhD162ti1AfQGII1ACuAyIOK4qIPPMSNHcBg3EW0h8gqBFsCymtGFKBzIMGBFsA2gDIJqsw3H8AqtldEwDzeAsQEekIPVvKU9HiA6OD16TGi_Q9fXigWvUkKy_WjQQ7mCMbzG0gzaECAVV26MioIi2LwAKgVwF1BFgHjseACuAsnjt4K4FTshvRt4RoOjG2Rkxy7E2rAfGnFwQcC2BywJ2B8PyUggmnVBCwKkE2wNWBnoLh47xC40SYDk0ObnYEQ3Do4-F3tAkES2uqJVTu3RClBTASOQ5ODgARiTxAPCgNkZiSuyFiQeBT5mV0aXwAud_G1SpdRs-LpCY0ZcjyG-uEaMBMBKMmTCC6eQ0tsxoE2a8ciwA4mg4I1RkiAzRiuAlYJKGTYNlAFUADk3oMiArX1tIQmlwY4Rn40Gd1_opaVvoNwPjMUZkLB8mAIGJYPGY9uyVwlNnrB4XSrB04JsI-rxeB-YMsAS4JOk9Fic6pYO8Y4WkD4vYOaGpcSY-5YzXBNehKegNFHBwYPVBk4JHBu4NVUuYNbMywK-BHpnTUx4NMWAdHqs1HgvBjdAJgWNxesKnnb69N1bB7YJdI14NzI_YLkIy9HqsCgkQhKeGwK8Vj76f0EmKRqHcMjhQfB8jEws94JwAOILxBrsAJB4giJB-uAysLpHlB4NF3CGEI7A8dFZGq_D3wY0QnBKRnus3QB7BvGEcwfYPlBJl2VBlwB7C_EMbB0NkcsJP3X8XEM3okkN8gfEINkEkJEh_hRkedA2cSREOD4T4N9o1YM7BoWHZwGNBbBQhjbBU4PJGekO7B_LwHBJw2HBiuDsoY4PVBEfHfBtkKzoPrgjBi2ipBhILBBBWRwAfZlUhFgwKM34LHMnc0BBU5nlaZg0w-54P9c3zwGM-dEUh80AEhN4P6GPkW6A1IK3MkZiXBqPXrq9u1SWbkKSB7TBSye4MChp5ihBljkbMR4PChK4KyhTASvB4kJKGBUJUIZwUYhZxQIG592Im2QKqQr0noQjgixAzgisQBUic4EOjAg46H4AUbDEC_AGt4siH4Al7HGh7AH4AhAFuA9wEeAWIxPArIGOw7LRmkATEkA8gVmE8QDowWThnAJPHvQeTgcEl7Clg_zEkA3sH2ALOUkAwACigiLi1gOwHkAN0PquMAHkAjmA8AYACWgWI24AN7xAAk0JZg_YBeAjICQAs0JAA80LuADwDeQkIxWhrwDWhUpl-km0O2h6Tj2hNgAOhR0OYg9QP8SoUDNeN8CiA50P2AZCEBhi2ACg6wH4A9gRmhX6DJhswGWKkagphK2H4AiQlRaonhQUIMKgg_AEN4M0IZhDpHNATMLa4_AFwgI2H4A_JAphoMI5hIMKFhIEn5hJx34AClBFh7MIkYnMJAAssJAAAsPphSsJqmrMNFhCsPFh6sP6QUsMFhIAESEkmGz8zMLlhIADFhVwC5hLdRmAXQIuQaLRZhBUObQU0O2UiQiUmIMJhgK2DZhKgBZhlsJZgWQASAQMICgoMLlSisLcAtAADhtAH1hnsNBh0RR1h4jiaI2sCDh_ABDhOsIcIpDkiBicJVhJxy9hscN9hauSThKgDgA0iR8QM0Lbq2cJjhPsNBhiED1IAiF-If0JjhRcKvg09BBhZcJGwOcMrhXMImAbyVHAW9wLhtgGLhzcJ14KWX5szsKcCKqlZhasJVeHjAnhLpH4AfiTphu4TnhSSXgy7sKkY3Tm62NsTtiDsWN0TsWli14EDsOACJgXIHrha8MjgEYFd4F8MUA8nn4AQ2WuI-uH4A36QXhUygfh9GC7STRCEABOCGuXAAmAM0IX8B8KJg01VBh36Xfhs6SmSre1XhggHXh58KvhMCOvhJ8MgRZ8MvhF8OPhgCJfhFaW7SmQBYAeQF_hCUHLEQ7lvhcj1WwBsPSCT8LawaCK7SpCJZw5COnSqIFARK8Nhg_AAAAxATQwAAXDGEXJ4b4QOVn_j09_oWPUZ4X9AhYf7DT4sDClwTLCC3KvDZ4WDCbgBDDHgBgR8LJaARAENcX7F0DbAKjCUgOaAreIjAAAOzWIOYChQEQCbQ1gAJQLeD4WUcBkIaIAmI2ABLQLAANQLADyAXqCJABqCJAexFEQBqBEQVKAgAFbB5xGWFlwRWFM5EmGNYMRGwAMbIiI9gCTZFGBqw6IC94NTj-gHWG0IBZQAASsRgGkASgVvFPCwgBoSSwCSRKSLSRZ5mcAGUCWA1MjPAz3AaAognXQrgD1APcNiAdgAAA7bWBu6BxgLoNwB2gODDFoZIARgB0iTwBkirEJ8A9ZFABI1uaAZYt7BrTFqYoAO-0MgEQA4AN7Bo4PgBiANYkxAGIgbRsTsMkEbApAK4AJAI0k4wJ4jrCE7DzYWo4E4eAjREUrDxEQwjJEa0jIYXIisQAoiLQFXkioCoj9oeojNEToi8kPoi_aJEA8gcYiYHpUROAaSJrEbYj7EY4jgAM4jeoK4jgAO4j-AF4iDYeYEdYf4i_oWrDRsgugZoeEjRPjWBk4SykhePwjEMEEjsghIiqEVIiFoRcjZ3NcilEXA57kWoiNEdojdEXcBBQG8ivgEYjLEWSJ0HF4g1cgyi_kcAA7EQ4inES4i3ER4jIUfCjfETCiusgEjqsNiiQkUiipsiiiLAFNDB9LEBa4ZQjUUSAByYZiiRUSABzWjhVLWuHQdYSq97tn3Bq4aAha4aYopMIA4PHJ4htgNwAzIBCjv6FCiBUb7CQxpai74SuBO4XgBu4aiBSJMqiFUUqilwVKjVUdsoLWnAAhSqHD65meA_uPdtaZPqA86l3C5lFvdMaGPAKrpgAr4HgB7Ua1RrUfMBFYXajtkQ6jQ0GTDsTqIB3Ud6jPUTpFR4YgA_UQGitUbDJQ0XTIDQCMBwVq4BvYFxhvYFrACcNMijIHXD74T6j4hBNI8EHXDTkVMp24YrCxYarDdwn2idYdWifQizClgGiifJIrCSeIs4MoAAoo4UOiK4YrCIAJ3BUAN7BpTAXCU4b7CGgBkh7AMSC70LQBixL3Cs4d7hh0b7DygEohvYPQRN0eijFYZYx8gCkAY7NQAF0b2il0TCjQIt7AwuD4ET0TXgz0aLDKAA2jjXi-iBlH-iJYckE64YOjX0fwBc4aDCCylMjEgOAjIMSBi30b7DixKwAG0QKikMSzhQMYqjvsJ-jwgImif0YujoMR3CQAFGxbMMBjsMShiG4ZQAkwFLClcAQjpYUrCbUaDD00ZKjQYQKBtYKEB5UfmjvAjxiFUWqjcShqjA0V7AQ0W_Mw0VWia0d7BNJL3haYt7A4lM2j_AMKiyEe2jEAJ2i7gL_Df0dRj5Yft0iMVBjvYYrDR0awhx0cHDb0TrCZ0R8550XpjkMSRjl0auj10dEAb0VOidYTui90Q4AixCWJKMREdtMSAAL0SkAr0Tz14EVujQYfeilEE-jYkVhjvMbZj30TMBP0aaAvMdVgcMfWjG0cDDIsYlifMXBiEsYhgcMXBjvYAhissX9AcMWhiMMamjrMVRjosb7CogDOB8MT_CysVFiDMTrDyMawi6seliKsTRi6MVnCGMYakU0aEiRocNUk0ZthdkUEAiIPxiyYXxi80QJjfUeqj_UZqjfYbrNg0ULozKlUBvYJI1LqN7BthE2hoFOtii0t7B7qB4AjwAxAhgYgYewD_IHYIbx9hMNjEAItAUyEQAVICvwHYPjt5oCtj74tsJDeB1x5MORACgHWj9tnKBLsddjRCLdjngDkoPseqAvsSvwJMdCAYACNi4UZIjgUupju0WIQksdrDcIIxiesWmj-sTDiVUVEjx8CXCdYWeAzwH4gqOMpA2ENn5xZEKBCgBmiiEY6iwYWogjYEpiJsWNjfkvxjvUYJiIgMJidYfNixMTVp7qIgxHsdQAE9g9jScdQBnsbRhK0eK9CsNo5lMSqi4cU3gEcTDAcMXzj64A7C9UDhj8dKjRnuMVwAKj9wpYajj-UaVjbURjj2MfwBK4LQBaYqihnQLmijkQWjtUkWiS0bNjQYZzihdG_M6zovBUoubi_MpjiVMTLi82HLitMW1idMaliTjoVifMUZjY4ROiQAMFj-ABZi50QFUCsR1AfMSujyAGuiN0UFizMdujd0fuiPMcei0sdlifMX5iAsRTjw8ZHiQAKFjH0RSCIsUHj48f7j3GLFiv0XHjMFj5jksUBiWsbnjq8ZliW8cHi28XWN4MYhjK8Q3jq8cVjoUTnjO8Q1jKsXhj-cIRjh8VXjR8axjLMM1ip8f3iZ8dBjDEB1iUsn9BdcYEjmMfrjZ8R64pcQqjscQuxB4aDC8dCjMrgB0iRgJrhTcQpJ3cW9ALcQNjIsVIwwAEFBRsYqjxsV6iq4VNihMTNiRMQtitsRtjGlNtjIgLtiYAPtipTEdikKhEBlsZI1OgE_jKAFdi5CAIAwAD05BcZ9jqsdATECUFB4CSmRECcgS7AIrjnsWZ4kCe9iUUKDjqsediJwEQSIcRgTKAHviBEapj4cb_CFcUgT9YQrBq8WriUaBripBFrjaZjrjusXrjesWRjDcTsjqceQBYsdQSX8dbilcLbjpsaWi5sUGiQ0Wtj_8X_idsXtiDsdKZn0EtiPAAQSU3vdi8CZQSxcQmU4QAIBvYORB4gNJjYCd7AbANJicUW2jvcV2jGCT5icCSwTVcRLEOCZrjHSgDxtcVnCN8SqjoUQbjd8ZTjBsdTjsIAyBbsOYTn8QzjX8UziJsSzjP8Wzjv8Rzj5CULpFCUWkACRtjgCaATDsRbBVqriUoCTkAIcSET-DOESaCYESqcZvi_CTviLYPfjPxvwBpspETJCbDi4iX0CEib7DtUc7i3QNsBtgGIShcV4haCZNiO0bLiHCdXileN-iBYawSl8SAB2CZwTHKp4SeCd4S-CeUSWMX1iAiUbjwAPEBtgHBB1YOujokEu9y8RIS38YWjVMXbif8WJjRceGjl0BsTKgFMjRILsTccbYTtlAwT3YThii3lABvsbpixiThj8YM6BnCT5iv0d7B_UdsAiALwSrUfwT0cSsThCVmiQABF4tXlMjWEAjjuqD4jt8csSqiZ7i6CZ9t3YXnshsZmkpkZk41ES_iKiciShQH0TsUb7izkdIi2kb-xE_LoiIAHuxDuGk54gLiTsnPeh3cCpBpADPxS7BzBuXvAAeiJ6BsSZIBGSTOAGUQggwUUoB2UaKTnEffiLAJiTqcZSTEXAFiy_CWh8SUsTBCQESoUScimRnijzkY8BZSY6xJ7LSS8sDtCMnKoimSTTgWSSkA2SVrAOSaoBxCjySdSZGsFSSLghSTdD3EYoAxSa6SJSaUSpSQbCGiXii7CRpiniT5jZSc9jgSUVNM0XQSdSetjZgEqSkSSqSUSWqSl9riiVMVqTeSd-RqSfqT6SUaSHkTk4CoGaSLSRSBEXJySbSa4AUyYn4ngFUhZ3M6TRSXYj3SbyjGsN4ioiYClmcR_iBiT7ihiRMSgybHCUcbuCsSd-QTCeqBoyQIT00fGScUT2ikyeSTIYTqS0yZgA6SWvB0nAKSUgNmTVPOTi8yVaSMAEWSSyQWTyIE6SRSa6TqyUCjaydVh6yT6SvcQ8TBiQGTq8R2TlcYxjViRGToSSWhvYCW8ByYrCwusSSdAIC8W4YMQDYeu8MgJRATIZEAZobJ4DYZVkYiaDCCSSABdgqtEEgs3C20aTE5cdeSISeGTsSZGTYsY-TIiWBSXyaiSFUd-TDkak0vyU1pfyQrgAKbaDvUcBT38YiSBCRBTJ6rxg-id6jYKb_D4KWGSFURGTyIA-SQJk-SdYRhS8KVW8PyQf9N8dhSCKRBCQYYBS1YaRTDiWBTKKYQJqKZhS6CXRSMSd2TqcWiBYAJiQ0KcqTOKSJTZJiBTyKYrCJKVBTn0dJSFUbJTYYAxSyiXQTFKbMhZTPPt4SaCSOKUj1XyaJSbcVviKKfVpIKfPY9KTBTRtPRTPwY6DvUW7DRyZgs1YTBiuYTsB7Ya-TjySqjHilgBnij6pFYYzCj4CFTPSTnitKTrDeYZ5hXyejlLcYcTpUm6jbUbadJSYlSQAGBEmyUFTtgPbCwEYrD2ESkizIKf08qT_RPxgiSJiRUBw4cIjQqQcSHKRFSoqXggYqdzCUqVf4EqUxiwKbCiDYSA0tUUIjA4fpS0URKkMqQ5SsqWmjcqX1T2MfVTAqXsjSHAciWqdESyKbhilik8UVyl1TrYTzC4qabC-qWjjBUdc9xqSzA21P2j9kaXpqic2hFqaRjI4JGie4W6jvSa1SpCZtSaYdFTkqd1SDqXzCjqdZTfYfPCzqcNTfYQ9TnUVGjnqZPD6ii0UvqY9TXUa-TCqZpTwAMvDnJJpjF4SzBaADvp9KX9APYaqiPceHj40bVjUESABGEQlAYAEmAzIFZBFFFjSawOaDiKVijiaQlBXAIjAwAFZAOsd7hkkRaC0aSTSzIMjAiYETAaKTWAkwHJ5vcEwjZPAlAwAGZBv0d7gSynTS6Cewj0AAlAPAFVSBaRYBMQbLSFUewjXAAlBWaR4AVadZBhaTXgmERpAsYAlAkwIjA9aVoiDaVzSNIELT0AIjApaTXgbQerTvUewjZPFbxSaXlSvSW9S_Eskld4FckUaTrDCsHBBoEUO4AAKSowW3jh0odzHwmClJJedKaYlQAloFkHAw_FTJw1uCZwlmz8AJuggACQihg1UHsAZKCJQYylBE0NB3UxWGcYsChnUsKn009qk7UrVGSwv6mLEmMmA0oakXUnWEV03NGt0v1yVFUEDt0nNE3UlcBl0vunV2EIqC5NamNkxGlY1UFLzgUuGfkt6m107VSKw4WGN03wnKk15LvJTVFd01Nzl0_ulA0qGm90yrG70g2HpUoqlKw_tAqIgSSKw4ACG8DxFtomNK2wyukMIkAAigWYQiAYcB8IGcKuwV_A3wu-nn0_IBxQIinyU0ukBU0jGcYtEDj0-ynz06mHbUxen10vUg1U46kA0qxKvk4GkcY16jcYvend03KLD08BmlEuqkgMnelcY0ek92CBkaUjalT09VL244DhtohemfU1okN0hYmr0mMnr0rwCb0yGl-uQhm4MrekIgHuk4U7NFcYtKlYpU-n30vSSkY6-kSMW-lvUkRnAQBOkv0tezv04KDsAL-nr4H-lSMv-mIooSnn9MD4IUjqAEMnWHDY0hlFDRGm0MzqlwM0BAIM_6mgwlunsM7en6MqHEoM_el8MqEn2MvBm3UvRm-w4bHEMjFEvU9amHEihlp43ClQMramRUuun0M-Bkr0-mlgUlhm_oBxkcMuxnQ47hndpbBkeMlxnH0oRmI0kRkBiMRk30gWkyw8-l3Q2Rmv0ozAf04cDKMwgCqMyRH30_-mhI2TxAMwrHuM0GFf4OnGtotWHV0ugkmMzGlhM8xkRMtEnKk6xmb41BlzQ2nGS4zBmpuXhmKwppkjMhakNMoZnKIZpleMlpmb4tpn9EkFKUM2em8UvFEdMpekMMkElN0gQnRMthkDMtum-wyZn04xJnjMwOnDMs5lqwk-kZM_JlZMq-mK4r5S5Ms-kOpApkQIuRlv0mhCKMspm5onqp5Mh1LVMwBncIkun1MzfFLU8QlV016mSIrZlmM2IAWMvZmKw_pkqowZmCAWAmxMsZnJM0GGQs6Zngs0jGiE4omGM79EbU2FldM-Fk9MhVFgU5Fn001FkEsyFnnMrFkPwsQnos1xmD0mZmGwhsRhE-lmtM6FmbM6BkhM2BlksqmmMMyJl9M5BmjMhEAxUzlloAQlkSspJnD5ZKnSstdE4snRn-UvFl-I2AkLMolmn0_xnOY3j5BMj6mmMoVkIsphn7Mt5KsMjFmSsmFEsshlkKs32HcszfG3MjamZMy-k6w4AAkEqkJkEiRkvM6RmP0tGLP0opkKMz-nf0nOm_0wFkaMs0FaMl_6gs3RnqsnWF1EnxkT0kln8sjqmdM2DE7Mn2KIMqxnisxJmKwhNk2MnhmMskAB1E3FkqopalWQLVlQs3xkOU3Vkz0nikP_dpkps0Jnps8Jkis3pnMM81kxMuVl5sy1nys6Gm-w_NmOs9JnOs-5mus32HiMqICSMypn5MmRkfMwNnfM4NkqM0NlqM8NkAMzRl1M2Nlls0jEm4t3GbEvGk8s6tkGsmBl0MltndMttmUssVmRDbtk6wndlm4vdmd0gtl9sg-mgw29nX4-9kD04Blxs32Gvs7IA34ytmJsyBmNE-ISt-AJnUMo9kCsk9lgYs9m7M01lL0ztmHMlFnHMl9mu4u9nuAfdlHMrBl2s5DmvyVDl34s6lOssSmjsoqBX0nJnU0gFkWgd5lP0z5nFMn5khs_5mvMi0BAs9dkgsyLFD0gGnrEzYmDobYleIW4nQUg9lJsw4mks09nks89neoqlk5sx9lIsjjlXE7jknPPYlysi5nscqACXErYk3Ejlryc0tn00pakXEzjnXEnYnqcnxD_s_jmAc30nbKEDl6swJkwsptmCs4TnCsmDmisjtkb03tlSc5Tm6c2Tm8ctymPsxTlWM6Tmqc_TliSO4k3M4dmEct5kPMt1kvEt4mvQn1kzsv1k406jlBs0pl0csNmMciNm6eDdlqsrdmKwiMnzk7VmT0wfxJEdZkNsj1HWcyDln0zRAmshzkCEx-HXsjxlIUnLkKcotlnBeGlihU-nAIzBErohHGhgt6nAI-hGgwxhGOQM8Du0x7gvM4BEzpT-EmgmaHwwcsTdc1-E0Ij-E_pAOm-wiqlyebeTzU1Vl30C8lIUu8ki4XLnkM_Lnlc-tk0MkrlGs0CkFcillic5UnVc3Nn6MrbmavRUkNcrDn8AJrlnUhGkbUtrkdgDrkzQrrmSInrmLcvrlngKbJmQLRFagEbmzc7tJjc7tITckGFTcttGjc2hGfw3rlG0lbmrc9Lkbc9sl3csUSfo2wCvksClXcyTn6MjHmzILHmLMxDmYc_tkvsyym7cvxn7ckVCFc-4lA-TRDD-Yjk6wxLx9FMjnvU49kncvJkHc0TkvslrmI037lDOcqkwAQHlaI8dEzc9BEs8D7nYIkGHfcvFHAI-OnQ8nAAAATlh5YPJARn8MV5hoNR5bHNBh23KJ5cJMuhKSVbgOPMu5YPOc5BPIdJBvOx5D3PJ5xuMp5VbIE5NbJp5kqDp5b1OBSQ_jC5vsNZ5agBeZwKRfSQzigyBiR1hcPPm5ZVPZ5QnO55tPPO5fPOOorXPV5iPLBhcAGDpAeQ0gUdLT5gdhjpEvLfhEPPD5S3JF5VkCB54vJ-56vNz5UPLNBavMl57XJl5VwGmyLHPwZX7L15SFL1omNKzZ1CJTp-PNq5vZJb5vbO85T3PaaVPOd5DPOj5-rKs5wTNTZisOVhvPONx_PLe56vOr5nXMr5b8MT5_XIG5WiIygq3KX5c3NAR5fKHch8K354PPh5C3KF5OsOW5HCLW5jFIy5WnNIxzFP7JZ1Nx55vJq5TfN7J5EF75jXIH5jvJM5J5OH5rvMO54HIn5LPLO50_IKps_MOJ73KwRi_Oz5RRBX5ZkDMgGUASg14GV5oPMl5ZfO_hhGMNB-_KgFh_LD5K_OR5KPPr5bjMb5_AFvJhPOMJqFOu5XfMT88pMi8GQFYpi91N5jnItZn_LIZgnOO5abKj5v_Pp5iADBcTZO9RJCJApdBJDCqAGjCUQDSACdP15xhIaoBcIkFnCN3CkEzXx-VII5DlKEFIgtjCWXNIFLzJUFZ1FGAASSjYcEDTZN7wIFbLKIFUJNu5VvLIFIEzrR9ki5EFvMoFcpIkFdAvGiDArNZTnOYFRjOTZ4_ObZHAvJQFXJkpr_gTpXcgLhBaW2JFGAqZKqKUFK7Io5XvNBhwAGCFDpM_RgHVtI0lSnZeKN9ZGVLi587MqRWCKBJy7OnZq7JqZiMGS55oA1YwwCcZUDkiASQlbs0XIdSI0By86QvhgVvCWA5oHhgi_mAFr3JC5FoD8Aa8Dz5jTOT5IdIz5unjT5WfLyFnQviAfQN355tKMFn7My5N3O75swEcFdbIoFz_KoFLfIWFCHMq5cHNcFAHJYFbVLYFk_LO5XAp4FAgsaZu314FCqJUFMYTEFECNWFUgvgRPfJzpeB20ZmbKC5k1NPpFwtEFAhPuFbaK0FJmBGAugoyA-gsK5OvPZZEZNWFJbysFDklsFywrlJYIrYp9_LXp8HMH5__K8FZXOj5wAtrEAQrOZFPOOoIQsrp9ZIiFIwovpzPPHZcQsi8CQvuSwMCv0KQpUxaQsKZ8jJoQ2QBXROQvo5VTNS5aMCKFJQqJJyVJ3gFQqfs1QotAtQu1E7sIaFTQpaFPhPpp7Qocp99K6FfQMT5QdP6FUdPNBodOGFqQvPpMoq_h4tiRRwIpMFt_OFAawqhFxAqQpLFPIFljKFhiIrcFxLNYFngps53gviAfvO2URwvfxfAtOFxwu9R7wrUFECJYptwvDxr_IeFcgq4RzwqHZrwsRp7oquF37Lv53wqjC2gr-F8HEBF9bO1FMwrsFUyONFlgoNEBotMFL_PVA-ovhFjAq7Z2wvcFVosNZ7AtRFv_PRF_gogRgQvgRpItCFuQvCFwXKlFRHLEZ1YpoA5IqSFVIv5FD9PSF_AHi5DIuyFYQppF6jLXZZoMKFkQuKF7GC5FINJ5FRAEqFPtg7Fgoo9xsMBFFtuTFFbQtAFDYodS6orlFfQtT5iosjpKooHFG4rGFGotqxVwEmFoZJMpm7Ov5z5JlRvQCuRZRBJ5NdN5ZKmMj5hsO5hxsPipwArApZRHTFeqNlRCZNtZdvNVRN4rlRZ1IxFECKyo8CNeU0KPDxX9OdAP0X7FdBMlFb1NSSK_ISgWiPwCVvAtR7PO2SmiTOFVsJqZItPRp32ndhAdj35WiJZsjQrIlLNlV5e_MX8BCJjZ4QsmSu_Km5CYqvFHFOAld4vRRD4vaZT4vCpewq-pe1PfFh1M_FCIq2FnfKrhHEpsJXnKLZv4tvFUks3xYEqfpEEvDxUEoFRMEtbg8EtrF9NIJFqotC5Y7JiFmAH2e8AHkAAAC6OxZRz_WT2KshUyLGgFrBR2AhKaWfBzZTDFVvoIrDvxezyDmQ0ReRIFinRaDDICABTCJVrQ5cdj0lgJiCKJRHTbeNjB6JVPjyOWGEhxZdF8JQFLDaURL_SVTY86eRL8VFojUYHRLVvqOLi8CLgvJTZIfJbRLVxXHy7mQ6ktxaBMdxRFLlRR2L1RcxLMBYSLj6NH5f4Tm1UYCyK1RUeLKpd1tqpdZAreOnycAGZBlefuLfCefSteQlLXxUbAkpWjSgpb_DSJWWgxCJRKFpTDAaJYxRopaXFaqYQLExaZix6RaLT6S-KjYXbDhJfZz22QITBqeJLJ0SQzWWdMK2JfayBEMpSlhVIx7pdxKL2TGT3JfmLLRbsLrRaVyOeBijSpX6yHKaklrpkKxf4YUKi6W2jUkrvycaem964TjTlJf6zTwH3CxGKDAf6ak0JCAlB9-UXTWJYILSMWZSBAEZyMObYy7pUpSXpRdzcxesK6CTpKDxVEL9JfwBoYj5JqRSiynJQLFxEPoA3JSbz2effToxf8KO7FGS_-YSL5xfULRRTgAreB1K3mbOy_KSpiYZd7g4ZW4xU6bjTO6Q3CafiMBUZcBxAETjThET4LYZd2LMhYyL7JDfD1ZWnTfRJvTLJZkLaOUuyopQxiihUxyn6dLL_WfDKcaYjL4EbYBlZarLBiOjK86WjBxRTxLD2WPyixZPz5eHXDsZecLcZc9KLKQOJ0xXjK4AOHLE_M4LFYXjzN8UhKS-VXzpeb7idABSAg4bLLM5VNC8aUrKUZaGy0ZRWIlgDj0D-RRk-RNNL5eaXyj-WXLg-drz6-esB07NNNX2gE5vTPiICAUtNwnDRgSUIQpOBCIhz8kKQxrIVwPTMnw7CD7AbTOzJ5IIjAzIPdsz-jPKtIG_NaaQZ4JlPsNjvhRBFgbTIMoB6YVgdOZLAPIg4dNGYh5fXMikSEIzwOzIaMMvLJaJkQaMDW95MFR0EosaI3QPpEMaLABncMEQQxFhBPcBH4qOidV_qN-koInEg1cNYNqYvMRV5ewBmviTIcuDHNCdCzJ1dOmZ01LS48hCDZd5WdxnAPIgJYrK5rIAz09ImphICBBsIBaDRjpHzRvWm7VjnhA5xICMBzABVdYNqnLDQGaAQGAQJbxeG0jnsvdtROOcjUOAr8hJ3NIFTujozFbwsFdkx2liu07VEMBTMO0AQifuhD4npgC0mScCDKpp6gPsYfLkTseaELhW9mwrB-Bwq3Zp7BZsN7BcQX9xfdGs0cALgj3LkahfuPeYCuCjRr5jcYZ5vIgMkJy5tIGjBjFeornviTI3ZjHM9QL6DnuADxXYNBB5EHOiDFfzSyPjsZVOiTJdQOHMEFT7AkFfIgUFWgrXYBgrJhaArXQRYJoIAnw7uCTJnnJTJbnBNlkeZmdlMOYCr5cpgF-dGIb5cO9tgBVNHRJPY97AZBsxL4BTMMuEGrmTR-Ptkp5MM8BgGlm8FfCAxBNiZBZwDW9QFc1915g6ZUsF7BqksrNoIBdwcoLUzAlVVY_rDaZAbHPMBXJ8DJXBFZszIlBHFWJBfQUsCbnAGDFSisrbtu412Wkz9LIaO8LqN5EBTi_L5wN_BeCm5lKAB5kxXikAelJ4haAIiAMnlhAKUmNcl9moq1lZsCNlU1ktleMqLUfkrl7vwqv6UrVX1rWV_qLg4rxCYoDFBVNjldaJTlTjwANrsrZWsSFqAFd87zsAgrEmtZJiEoteCmAoqANrBb6AspUNhDsecYcqzlTuExrKYqLzOYqZiYkr_QWsCVZmPN1WuMqsQUirB5KS1zaAotkFGgpiFDygoZAXln5TjxnqLStZ3JM1ZQElVQwnyqaGC0Rr5fRYMaOTEBkLRgOlfpV_XN3QFVdGIpuTIraVgKckwI1c1VRrQkVQKdqYojBmGjABW4mIVmgCaqFBFNy3wFK9rREG0Odg8w-IGRAzQMmsyaAaJoxNGtvUNiq3Va2dZgMcRCykc9-FbCA_1ljt0Vsfc5gIirB5fs5nbt8rvYIzImaG7phvIfDVlVMB46iq4lXLs4jnDqBlnPHNkyWZUDSXOTjSTOBFybmTjlpIAOwPmgK1ZPYPkYnAloK3LuAK8ovSkjRfSs9wLXPZV1nBmrnSi3MXSjmqydLF85QPmqcKoWqGScWqFycyTlyeWrK1WgBq1RABa1ezBXlL5VWZNBAAqpWSboXYiboc4iQcKwAXwKmr8ZAp1E1MnN15WmoM1MzJl1eToLvHuqe1QqVTzPjiY5tOYAeBkhd5YLp7THSDiQVjwTgDcjlEfOSZYDNN2YB-1LJiq9VZIUC_pPYhwDjDIEgiAxKAWSIEgpLJ8bqh5INP99aqB8ZSZrjgQdPNkh5LNwPlXz1xJtSNUSv7JZbDJMihthrINNi4CpOJNWVJfIgNL9NcNTPxZEAeo5zqd16pq_5upkvwEiiblZhm-A3wGNZTwGRqPsqwDOxD28ANFRrINcPIi2KOA-NafQLCPRqfiLZNmNQrkbJmxrwhp88fwkSpxQc2BYtoXxS1DfEh6FBFEYIB4milRxEQg-C6oBjKd8piFgnIjAaauXBlOByUxCKXVTNReELNdwQrNYKRJ5L098ULWJJNagBbwNRQXoc81JxgrA_umCtSoAT9_9mF1JFGF0Iul0F5VAQMUvn09YKbP4VwlCZbxkF1YKZwocUNwpFfBkFRtHVpWgnL9pgPF16unwdeqs10xusV0Muq0Esuq10KujMcuutN1y4Ol1StVVqWurV1llh6sauj10Euk1qwpGVqGteN06tVN0aIjN1m9H10m-oN1m9Dd4P-K_5rOsl0NsU9TatdWsMtY8h6bhGBstYdtZjoKdBtZQVsAGOMm9EeANtQXlxgi1qxuotrVlp1r0KM3o1vJzBopbjZbAJahqKGUR1HgdrVNpOgUljt1KCPORDtd0AclmCs-lHZh7tb4hPuq3BWIutrXtYtgztZqsCnidpwdau8hImDr_Dl1r6utDrl9N9r3IvIKiweYAEdYNrObpfzc8e1rFNkZSpxlRx63KXFj3v_tstZDqckM3dX1DNqcta1FuboPxstbsEbBohhA-KTF9cPNrXUb5L2dZl0udZg8QyLDqqOJTqCdUdtcpXZD-tTzrxmKN1-tUFVYdRdrfJVkd6ukug6dXV0KYnILp8H5CaxHTrawtDrmdfVp0zpjr5wtPBawiIJUyIYEkeklrrOhu5xmO91dJKNol0KNordXYN0GMIkwus7qbynz1HIDuhxJtYFhNd5xqNdWB75NpdDFqRqkegJqf1rBoNPMZcgBh0gCtYN0JjM1dMlr5RFnkO5rrv4AKNWoMeJqEN-kGNrNvK5gE9SQFOhoN0LCLFrFVPFrw9gdjdqhBJyqMr0u9mV5QqLYseQStgFML1guvI3r3Fl08UssBIL1FnqqhKi5ajjwo-FJoQlusIpNCEEMy9XfwFFOwdnXC00_okvpAhl8owek1VHDhdcdAslMd8orqxCBtlsYFvrwfnKBZhveNl7irqMxN5rfNZAMyrAeoghlOMXoV3rNImHd2vvawNSaCpPbpBIrgEUFx9V8pYJfABigEfqNskfrU9O0kF4kfrscggc_oEAbIeWgLOkkPRnxhYAIDWAjOkuPrTokfq-8ReLe0c-NsRB_rF9RoVtRoi5f9c-N_9YcdBqt-l5RiTFX_LDAMYjTgThDjFIgE9ThpHGF8VO0AIwrgaj4tQzaFZ1RAEfn8xQnvqawGAd5-anLOkslBYDZOkE-ekkBiMFNnJCgbjjt7geqvIKcNJpqZZEPrq9AB5eeUO1U3EZq9UHZrSdc59YMi1CP1F_RPNHz0kNYQBmvO0g_deBr2VB65gNNVQDjCHqAiJjZvNRHrXNlHrTjAhrZNabtB-IXrUqA9F3jFgEECK4bUqHnrDhiXqeJn3qtCDnqqhKnqo2VKoC9RnqDKMXqM9aXrlweXr-ygHsHOqXILsKzq_Gi50AjR8YbFp3qRsK3rxcWZQNKFp4m9V3qhgoR5e9bHqBkAPq8CAoom1DpMZyo2QuhufwtMskap9biolRil459WoUF9efwvlMYaFJMvqmmo7kN9bY0t9b01U3LvqwDfV8D9Uj1SDW1gqpF5qkeufqq9Rdgr9fU8L9Rdg79Y_84VLKksOB7ChIq_q1-O_r-jeNMNCkMbsgN_q4APgahIsIht3EQagrBAbFjdVhQDSca4DZDKoDRXzhDfAbrkupBmEQTRXjcmj1IqgbZDYOUCBgdi0gIoaGjVBEMyG3DDNTjlrFEZSUsuz9hEjwLDHJxNj3P6MOkOYaB5IHqLAMHrvdY5dpZKKpMbFcbiBkfBBVDJqzDWSbijQD9KTc2o5VC1N_9ukEwehKoOjTUxaTS1AFtpCaFDaKoD1Lyp6TevhTDVSa5VGRp_tM3LbOJ1C8lYbIvECBq_2vLAv0cB1QOhWrTQHjIpie4SnsrMS50d85vkL85eZNt8KTWw9kkEabdvkD89vsbBTnIICGSHKa_nArAzrDQALrCBMbrDjQMZvCD6kHurKdPjpoIGzIjXN7AfTWzJd5g3NKZIGaJ5XKBIfgGadQL6boIBa4_gTS5g9KHp_TcDxEzamITOmnJRwDh1xQITIiACarIekNF8tXg8xIF-jASXmbdPIFs35uaArIPdsv0fKFdghfxwaYhU_1qWcd7CWbczRvxlkG_Yfoo-A6AOaBrTCcIoIA7x-QPZIPoEcgb0AXQqOFpARLK-oyBi2bPdZBomeY6c6zfVoR2i5kIhi21uhA_o59WHQ5CL9V9fv-cPIp38bVhT9cWo4BhMJmBYEntUvGiUqPqLg5RGcTt8iquazmr_sIPtNqBJO0N-DItoSta5h4qimR4im4EEvtPo_zaVkzWqeSfcQUUa3Ctg63AQj1NCBbSIn6TOICXtLhv1rlvPWbWtfIdUFL7Vw4T5lMsGRF4cYtAz8qDRmgA7V5FJEMEtVky4AITIXTqXc__lFhMQGhaxuj9cWNfg0mjRJx7zfC4HIuF00XlNAtICmR2LZ-aDZKTUwAH5dDQIoVjBk0bsmss9g7PebL1BRaqLcz42KqIz5LQVryYrJaBJPJbV-JqauCR4TPnHOivsgQAsza4AczYjBlzYWa89GN0YYEpbiQic1o-hdA1LUVAPzcb1BLVeFhLSxxhLb1NZfEVBlLQ8FKjfg8qFBVkLoPHQqFHxasmfJbeTYqoocirr1LcSFErOiiRsOTFHBi8AfxP9F0UfIArgO8pyYv8oRsK340AAHhbYAMJYJdsBsrX89PpIBFArb-9PpF4NfHKAlKNJ9JFzSVr7zSY8wAG5aBhJRBHRFv0vPo1ahLS1a4AXPEJGAm5cKF1aXLT1bjBpjJcfFD5dJBRbg3jAMKIvVbsmswRZrVkzWre_Ve3mm5XdQQN7zfObTwP-98zbsFJtNNpe6vL1sKQr96LX1rhtUixsKcGS-nm216IvWarmjr0oALc16Igda21L9gKqohVK4C4cREvysIytmUp1hH4GpJKobmqVltrU1oRAoyDqAArhZ3v8xKSmLVdNdvQZysDbI3KDaAOHuJa_PcNjrffFleatL33uugwZdtAwwKPq7MOugJlCmQ8baOEugD2UAxVXRfjIVAdoLVFVoONA6AGxVtoO6ga8KeBdgido6bZNp6zcCpJtIdaEMizg11nShkpnRCplATa6ALWEn_umNDTlBNOTTyE7hltbRwCzrdrSubPvk0V5eqTFWdehaqOKdaTtbLqXDMmYZLUZlFzXRaCzVkEnzQiAIMMl1jbZ5bB0IANptOApqDBAACcNNgtbRGhNAjKU6rVkz7LVGdurXdAwAMtb2rbZd7IJl0PbX-5FrXL5ALbmAVoNztIUN7aBJEsEGxBh8NrfVp5asmZutOIpmQL3xoLJ_B7LGlZHrAXa9bV0F9rW1o_XFj9sLFXpcfs0R8fmCYo7rnb0smP5GlXMNctMdoypjt95JID8UOMD95wLtZXzYPwbMoXlPaCpUvaDx5dKsHZZSazqhIR2oVIfbrWokTqSpgZ4XKXxAQxCQ4ogI0xLkHkFmQMX5YVmiRrMj64T_L54LNNSMzTsnBQ9rt82HkC8d7RZpdggi9P_Dm5D7cg80SIR0BhFi9kgFI99mkzqiPmU8StT6wD7av4j7c_aA-st963nB8oskrhoLUrgLcg_aAHU_aGSC_aQHWU9LBuVrSbN_ae7O28eLW0x63Eug0HSugcntp9_2Js9clhqpYHcfaA-o0rZvkQ7gzqDkHSb_aDPpN9PPkjgHfqQ6gHXH0ZvgmIdrbgMppS6QVoDm0oHYX5PMCF92DB2oWHQyQVbZ29cPv0UKMLFaOvjpFsRMw6c_GQ64-nza27tqp1INfa0SPKMTjjraqrX9BZSdFqUgtDqNHWI6DdYvaUsNGihzlUjf2AfqzObj4bOpfpETikoT2ufkHAEK5ovEZg2fBy1sFExgpIk7lufNY85LJagnbYQqwBuOAU8vQVCLbo52DcKsNLEZgf6pg1-9ATYNaveAQsPIFxHaZasgmzbJnsXauJLx5DWsEN9zT95ebZ80AfLY7SpF58cnSjgSvhdSVnsvb0ErOEUgpVsAOO2t5CMHYzqGk7hohN5BwimQltmCoEgB07IuuvtKndOt87iPp-fmXUEcqk7zbVxIMnVxJbHkw41zaksePDvkRHuFkR8vVosjX745HRl8d1i6QVynpppnVU6SnfhEunZl1RFOekOmVRkTpTflbdcrb6tLM6ugP38NbVVasSMM7qtW1qGHatbISAF5VNBVNcHNhS13k1oR1kiMmtA87b4lNoy7bM1cjthSlusl1sKQChAXiV1MurQ61uE1oPgHTawwLrqRyOccNKkC7UjpCpobSLgMjq4NMuoQ6rXoYL-3tpFixqS6RvrL1uHdGzoQJmkDHQTESljF1C6tWArjoS6MgEJU7juJUHjl-gUsGphzaCQxdjNGJYKT3RRIL0wVwuy9rnsBRyFMlEtbb_VsKcK8jgJdQ3qJkoMmAgpzAFUpSYlo4mXWS6K9C3qmXelrU9aTbRCPo70tbZt6UDF0A7TS7OHV86VKGH12_IbdZCKL5EgD7bsKdiAtLOVN4uFxgKFeWQHJGK7ctdMAMADhB9ItK8moZ6ljHXsgWdf49o3cxB6zSi6poDm1ISPo6UXbblQPu1QB3ka7jwOm6LXYsEB9TDrpHQ06ugEt1C1M5TIvJepkXZW6UyJm7UCsIlaHQoJSYmeaGFMmjo6UlDvCGm7K3YPRU3ca6NnTsU-3a1F8HUxkUSCTwUlM8wmtPVY2WhR4LqJ-ShWudhguN0AMaNK8YshO6AOCBDlGohczTHewQHiBDqHSiQzsHvtMsPC68gPgIUGrFAk1ga7MGKsBTYkfAUSBCAHarphhbYSAyIOdRhwJ-wWUD-x9XbS7qHdp9sKdeAYAI9RTXkPaSPOiVd2Fe6P3f_g9XX-xaXZW9_mAB6gPUSSXPnZg13f8wFcNv08lcYEm7ShxFoEjh9HVe6yGh5M27WabO7ZaaFeChMtApO7AkAO7jwLBSZyPC68PYO6ugvR60XU3QXSDFpHTREAIHq6bf8kJDC7TDZsKeh6o_mT5vXhR5fWDlB83ZF0xlJmEC0phkN9PFrNvPh6f3V86ukoSYseI2heioWEbCFFNTHCjoEzVSZcDMUNaTNA7IGLjk0jQPaDYnQ7MPY3aseM3a2mKfawPT_oR2P7gN9A56W5KswPcFGwW3oxVb3aYx5rV0kDYpB7tUOB8X2tZw32ioDJAEwh25TNJFTdnBNQLnBBINQgBpOHAhpIiJqEADAzBOWsYIE3glgJRBq8qPsEvaDIMYZiAIZIsVqgJjDGgeg4IqZjCPgJ2g8ZNeq5sLerzuOq1H1c-r01K-rZBHqbWShDIwBMDBpIIsR2AZCrpIJIBevXyJaCGq80XPaawXCYhscGcAsNfih02CTxMgGJhAOM5N0IPL0oIHx75If64Jbc8M_jNeBwgBEBnhvCZ68APsnMOdtALhTB02IY9WRg1B5QaXFtvXd6RIWPsETDAADvaHZUAA1B9vYd7qAKXETvUbAGoP96ouY1hORQIA3GOUKchSthBZcrAZgA1Ac2hpBS4pG8QkQ1AzIC9768D8Izvg1BkfD_RpmJ1AMXXQAf6FIB02O1AKrIt7lvbCA1mGdIytjxDLpD58TxGtI7Btt7afRI16fftIU2Pj7tmBKIuMJgA9pESIU2K973vUd6bxLz7zxPRw12JuwbtmT68kLcozgrRpxKED6VtOygeOGZZRGGZxAYNAt2uMOhvapmBx0OlA0QFYa49F_o8EJGA49POIHMGQYa9a0Y-jDqBp2JZyGXdlhpkQGUaAJ9IMgGKBmgOubF7ZwxSMPkxIvAx8zfdBh8tD1xsTKAlAmN76hLH77WiOb73zAVp4GrxxhDvucyqNgxVSM_ognun1k_eXh8CKeAKBAd903FthA_erBATB4aHxLD0NcFn6Y_ViQhHJMFjKIAx8_e1x_PSqdVSLX6osF-ZwPrDgy_T1xC_ZZUx9Q5hMQH9p5bRXrQclBA60f65_iWMA5xtlhe_djh2_erBRyvLbuqOI4rgMP7WIbDlmHIv60wcv6VsMo5DeqP7L8O5JGsNo5t_c6Bd_UMYABgOttfW3YrEjPY6iHJQsGNpRuOVrA2EIM8F0EvITnifUG_dBh7_S773YtyS4oC_6l3jL7bALoBAZJRhW_RnZcyH_6vHat7XCCJAE_e987MG3Mf_RyxF6P_72EGS1rSWMBOyMj4ptZRoIFLqFQuOOA54AzxEAwElkA5AGLKUkA_Eq-BN_egGcAE_7f_aQHTnvJBpNHQGkA6_6jgDdjVmE1ynkuaQHMJ_7H_YgGIA4wHvrSwHBA5GBssAu7YACIGGAxu1I_R_6Jvd_7qmaIHvpLMJX_fgRHfTMAWSg_6vpG77Y_aBxKgJIGBA9IHVvY-gaAN-8i_TbATQVHwzVevgB9voAk3vR7fpGKBJQDFl0EM-DdjGqYqEjKRvPSaCyyGrQfAymQrQb4Hc6FaDSSKOAZLKuC5bMKB9cJYGlcFaC1vqAHh2KVZMjfagoLFnaYLKCZPqsha7gI7ZXSG7hvDE30scuhA46PKCgg3JCeIXn8eQtkGUjCJDSg8wJtvRUGnMKvRjQFdgnIQ0Gig7nQtQZoxag4mhOgx9QEqI0HL7DThug0WhJ7DTgIvo1gqCGEH4tKkHEgYEZfeAkH6OADBDAZwJ7ULKTNYNEEgCofhM7bMHetI9hUcvv6mXYf0OjBT1qsPo6jg9EADHKcGmPSkFHBj36IXbm5JWTY9F7Z56fLkF7JVNlhqAEsHoLEF6ggvBwqA8tt4TC57Vg5ml3gw5hPg7MBlg-AI1g5OkcPboHING7765GW4IAXtE7LUEQ0_dBhJ_STYA3LOQAYLP6eAxiH7g09bS_Weop_ZC6EQNRJ5-BP6SQ_8MFgw-NjcGp7coF3l2hp9BVILOASjlH1B-PlBCTOP6vA031xPST9ehgQNbAFqAWQx9RMwtXDAOub9Z4hKGtPeFa7-O3JltsfR2ekMIV9PXJpGlGU_XJ_ACtR3t_dgPth8IWRdQ1X6Jwm2osPVjwdTLh6khh3YscI_gGveYJR5c16H1XiC2veM431aYNuqHeCWcOVJcgNEcXSC3sjNY7ACMfuEiIOXj1IAB6wuEcBFoAoItmDnjaqYvaMGBH7tPt1QSIdVhnQc5DEMGJpTIbEQvrNQBBBCNg51CNggfemw-PihwiwzqJ4OKWHGsOZp3TnmHEZgXU9KrZpb1jCpLDjyGWSCoRBBitgmGDPQeAFTDMaRwRnGBIwBmH2pmIHIamkcAAN9mOMHfbKVnffwH3fQG5SovILPg30Y0bc7gGoPy7gjlH7JJoObrfbb6nWvd1riAuHUAP88RuCLhVwxOGNw0Xktw3EobfS7hvvHuHVsKXFpmAmAMva7Bf0YHwdqBjqA3A1AJ_aOA3fR-GlQ6L0VQyiAvww5h_wzaNAI6Fsa8FJrGQQIIMAF-Hsw0toNCpBHy8MBHoMM_oPwy8GwfbIwwQ6gAFOAIB0I856dgChGR8Gd8Pw9taEGERHZyOBoPw3OoGoHOpqI8T0FcLRGGIwTBqIzZDaIzZD8I0kG0gBRGDrNbgNOB-Gb_q5oGoIJHVdh-HGlSKBU5Sj75BY-GOoFWHiHn3JHWh1EECIwBRvf17hCJuAPw51ASwwLJ_Ho0r02CkMBoPTdumE3glvdL7VFcMseIV97tI3mxWIWkYPw0qDORpgArI2mwm8HnRHI8D7Lxt96Pvc-MgfYD6MTIiY8EPZGnlM-MtIy5GbIzNIgo0T6TI-T6MgDJGlCJpHamDjgrw4wHGHQNBI2Ny6dI4U6kcOlGEOEiYdzUjgjIzWBGAFL6VvTsdLI8AAco-mxbI4XQgo_hx3Iw1BKo65HtvbVHGtPXhBfdQAsfR1Ego3FHssY1Hwo79JIo7Mxoo2ZGeo9oxf0VkonkFX71IhNH68lEaKtaCoZozo96UDNHQaBXbLxiMxaw0cAPRMJHBlrd7gADNHqozmgcFiJCmI_l7vpM1Geo4liDoxFHnxlIA8vQTgBAJdGQnmNGXSHdHZgGYIZI0wxGtP4AxGAOHL7hWpixIF5G4oF5KAFMwOw3YwFmGRplmNjhL4FNIZjP7sKpNWAmNKqw6diL7PHL2oIgSjHl5Ncw4JHz7kOGFHY2PVJ5hHBwo2LpwsYw1JtNH-TCYDtJrBXT7CRKL7Z1DZDmfWjG7BuBYg0DOwWY2loMtIxIh2E6CIQ9BYJfUngOODzHu2LtpXvWTGJRLzHzSPBHBBILHs3JAxEY3oHu5O6dhfTjGGfdpozoxFJDWGuIZREJIexDd60jMzG1Y2z60ciJCjY6z68YzO104HNJEjLLaQnj8x7_q5pbpLFJXJJ7EbtkwhZff5pxKKexqOHpHEOORwSYxlG82HRxZ1PzG0g4r6HQULHXjPy7lOIWHEODHHeQRNYvOgnGL0PJoA43zHNYyHGItEFJGww5pqOE36rgAd4xQaBZIIgDB2ofsgpARx1sZmDpovb-0VpmdBM3FQBTnivBknBFSGUWkko2JyTsABDJMAFlpNpg05jppvBe42rB9pocCYILMh5gDnHKkVkShQB4GV4BKY1CUMDZTNw4haHjIqVWmYrBLSqvlfSr65oyqB5uq1RBDGqx5nGqE1djpzgdzIrgXSGdTLIhhzlOd8LHJJbDVJ8ZQBZpRhFsRsDge4WOlch5pnqYvTf7pg9HUlLAKjRHzPlwfBBPN_Tf_HBdEAm0zCAm8hL3NQFZToIE-mogEyech5jGrwE7NgAE8gnI5hPM4zQ98ME5AmLFc4ASeIDxTzvs5hkQFVW5ggn8E0gnCE8QnoIM85UE3kIMkBQmdXL-UJ5uQmozKq4x5udxydGwnr1RQmuEygnnZh3MfYL-VSE65UOE63Mlzo3MxE4wmDnJImn5gUqV9P0A-II3G6XkZgmCgUAcIIKrX5fwqy_J8tkGqGwF0NLtaVkoqQGIVcuXlYwmynDtoPA9stgPBxgVS8A1ajtR0PSoEKPFBCSsEmhoAPGdfaGhCrAEfGB5ifHHIImrLAAp4Z3fhYMoM8rx4ta9GyBjQKoOvGaVSq46Ve6CtlXvG9dOq1mCC9YEk5vGkk9vGUkwyqq5kyrpzF24sQJEnE1tEnhwu70PQ_r0ZWSEYxbfr1iet7A6k5mHIMBEmokwac2oepr9MJCpOnJOcjYHucHjqp8RJkWaITObsrrn09l6GEcdTBkgezrddBfrDMb1JMnlDnl4Vaj2dtElQdjfo-AO3E_ZhVa8YThEsnPyKSIZk4OgPwIAMO3MdVb48uNYvMkAkTlKQ2cSKqvXEUpjerwx9FCngEonJZ9ItaIElF4guJDVAgoCIA8QORIelMERtbCz4CAPdRggDomSGTAMy2q5Dlk9Mmezhe8aHa5D8LL0nczscnaDIQ8ggTl04U2KBczgin7bcBRyfqAcZwhYnsdjStPBvJgKlB9R9kyimsQGimRzhinTk0e1XyJcm8zkvQ6UzodKAHinGUz2cr6Dp6MpNInO5rIn2E8wmALHbGjviRqPjsjM7DvhJ7UJm4mU7rV3rP5ZJ_vvq-E0fGxU6K5nbmBUbHMZ6OlhinVrEb9u_rJ9MkD2cggujbFYPXAXk_UtzfsynljvVhugT0nuU30n2U6ZZv3I6nyEDqZpQfahJMAiB48AUBtwojcvXHS6eKkMmzriMm8bOM7x-Pvac3EGnZIKBC7rlXHFkz64402tcw-tL56U8sni9k3ZUU86n0U7MmfFttk7ML6niZh9yZwIGnGbsGnbLixNc08ztiHTXRK0-8qs3VS6Ysg79dzsGmThg9cFkxdaD7e2n3lTv5Y042mkWOvt1Lj49eGjtkNVH2nh08_seppY9OyKOmLHt6d9zU-RZ3GEdodQum4deeLM7kREH7VOmpfo3kDrsgJt9jOUJ0w2mKJAk99BrOm4Ad8sWDkun6GgGsdIqum807ymoziUsb00Cdf9gy6RLP3axIE-n48Bin1Hpmn48GxUX9uMBYDusmu_nnQTfiWmbU6ZA8YkKA_U28ny0wkBU0_2tSphsnjU4SlpDrSnB0-em_jr8MsKK_tWDhBgjU1Bn7Vh2AThH-mU8EymIM8ebQDmynKM7mmeUxSAaM2_99DNQcTfuaAuM27t9PFRmWIevsATpZUYtDcMTUz_5irKqm5jVQmRQJgmLFSgmJ5rnVl6KhnLLpXblTsx9dXIgnAE7QmSE3InJE5x9FlkBnqM2anbPpmnmM0bADUyijenvanH8DucqdnPliLMdoPU3gAGU3fGsQG6muk97Bh47NB2JH8w8AN6ncoKxZPyg5mfM16nlaNnx9CiASR495nIVH5nPM-ywIwB5mIs15mMgj5nkPJiCsTbXMGfiXAw_oVYILD6mEM6WmulRWm8M_Gn2Dfh4GNNj8dMtXasgLXbEApS9rIvBGLZDFF0SEhnzSZcn3kwZ4BIqgonJJJTIQncmvXI6J8g3JZhEBanLqMWlhwEwDoHbHQh00LlKXg7VmzkugfM1mAjwCwB_YfyFQLj1QS0_6nkM2JFbTn0EC3Gxm_oHEF-sn3BFM9Nmus0ipzs3SHsdidmU02dmDsw0mCcOdAu6I1c207Zn9s0Nn2sOEnZIH3BO6FrA5BJdmqUyOdrs26Bfs64Apch9mKgE9RLHZlrN0Kdnis_mcKoK9mj0-9mDPO3QCYIKDYswiAuWotmNE6wB7PDkBsUTVAjIJD6-nsxAcg257Ig330TwblmlVHHR8gwZZ1FPGtfhckxX1pDQO4F0HQU8w0fXNNhiFZZCSM8ph8A1KAQGGTQsBOGr8FPBHdkyO8BMA7QQxLSsOel1BCTijnhFH4G0BZIoFbNYHCAHIQyc6XRXIRLm0Q_gNqmGY7clTe09MA7REGvgphwHEFw0Bg4sdW6BAHF0BSmMXAw-j7ZuSFOLC7DYG8jII5IBDkH7fNBAJ4_PZncNPH1CXWJpgx_Qvcx37_bCuA8jNQ5Z7CvHJQDWpU-RcIo897nOHLHmdhA9oYjLnRLA11YIkFaCk89WAkLUagYYBQqQMHO4coJ7m-nsXmLZCBhE7OnsKFb1ZoQCFkFpUaFCenmBUAFxQqgqvZIBI3gbqgPghddmmz_dX1-QE4n81qSIm4xkBHE4i4fE8wJt6FZdh8wvtZ3GUm4nrWkuHeQ1Nsy1mis649ZIB_aDc3QxF7Z26yXqkjeLaIQxgJs0c2jbwviMpgK7MEQwFGTQIBgdiuAHXZNqJGhy8TzRkQGSAETtVccFSjZrqghBmQMdQGQitdf87dVObvigRgBModiofmbeG0wxgGfjt1Kf1ojVV4IC4lBoCxtR4YLbw63WAWyzefnEC6fkyzSd0UC8O5oQM0sECxvpr8nkYe83_nJ8ELrodTDA6C-AXa8_ioYALprUACzZmCxbIWbAwWaoJwWWC1FLFRn9AKC7-gqCyrgaCyUs6C8XmwZawWmC5IW2C2DK53PioRgHIXOCzIWopYswXfnaCisEIWQC99rJcAS7xCyMBGC2IR_XFIWjCxwWFC2YWxCAYWt0HwW4Q1XJjQJb65je0A9QJkIIAJQXbqqKNRdTkgkxj1w3C33nEdVqstsDRhT3Yrnr5PBxMbOwA-TgKdQVu1qvRNiB5wG_K0Tj0p0AB6JICjUBkxIbwRTivxGQsohwBnMBEKhcx8LO6saeGomo2Ivt7hkoTVEErU0M8mYCi1iBKHoBn7E6UWHOOUXUiezR589UWTwfDn2HiXtai_AAiiyACYi6tHzAwOccoL0WA7tgAjQut4Ysi9YYi4f4sSHEnJ5ZCQN07oX0VNqlZlkLrfJZFSttYOhLgwMp-RLMXFHLuEQjLMXF_JrqlcKgd4g-Utg8hJndPTM5qE5pngEw0BQE2eddU_gZli8pm7tX88-jGO6ggFAAFcB9QmA7MA46KCR6rC0HwIf-Si03Bovi3Eofi_OB_i1tFV83Zcgsz0nSREXl182WmUgJvn4nvhYf_OoXMc1FnyEEXlAtFDG91Ug8LNI-97UIMX69TQAlPkqnhBmp9as3sqtNo0WWMEZg4gpyqM090A7mB2APRFU4V-AzD5wPnQIMccrWfPPsLdfYWWJoNUWDZEYNi2IQYi25GnrDt6q1lGpWRkD1g7C9YKcyLYZ8xBCVnnEFuS8kXiQlDsmlgJhWVlCnG6h9hjMIYhcJGohf-F0GzS1qtPIslDUlmSqhVf1kg2g7UQ2mVcI2sHZZzkGEIjIcq7csPRjQHmohsmxUiIFhU_piyWlkO0WIwOGXocGxVKi04nbJmPn4OOm0Ji3RbWi4mXEXFfQ2Ks0XGNakWW84qNg7Eg9WdZu5lS82hNzkbn2M5smkHnam-Gg-hJPiBNpPmiQIwGW9qSy090y8AE_1VUhoZhjDTok7IBoUQD8UHvDqXGMrJ5XzSrATYrRE5sCcoAgWrAc4A9YKOWWVayqxrBorbFWq5Fld8CSZHYQMkAaAT-hMoaMKQXlMGuX5E3-DBdNuXdy80sJlB8scgM8A6_MzCA3TYKSNSeWNy52Z_wcsqjy7lAXy6DZ3yxeWDQHbkEUDRhH7dHge6LznpXh5tL0MQQW4OQlGrm8RagcEyeaJ4gXRDA0B5T98d4amIm5uuW9eushTcKqCwPCyFTxSOLqwBAhfhbXzdQUZL2cFbxpudWBGkq_gtVEEB2cElBqKxmhX8NeAGxGaDNEbIhCiaeLT-isY-gG89TxZhKVjLlargEmB2RZetlML6ULuB6ZIFNXliWh_n9EvOBkgA7Ad7fUBD3aYwDqnkBYwgMhQFaeB5LbeBUYmZsBaEkYwxMwp5uJpI_Xu0xf_oSE7A_CEjK-oAfrhXs7A6qEWTblBnKxXR506ZXPXmLAlSq6jh3dOa-xii9L1uCcUFiyVEnE-s94YWBDoqpajMPIgFy2pWMvLMgQ6Oz1RYD4EUFtaor4LWc3QODCJyeF0cQE1nGRbPxlyflW51XFXFy6dF_ifHlEVfdsUZt_Jy4M1o_OBphkCVJgJvcJtOfBR5SJZNkAEQRI6lgvIhgNXmC7BwAONqK75pUxRANvdsadjWA7CLTGjgBOA2sNYByiDkABkuTFmTvJYZq91F5q2pgKK1FWQGCtX2zrps1q4G6eaJtXimH1Flq0XE37sIlHYDwsplAtX2AGVWPsQjJnfSXDX5htcfvipAPAMrB5EHAAOAPahpMUsB1sQDWPAPL1VvdJjbCGEiJy3082Sutjwa11XBHDlBvYD05lMHDXB815piejlBoIQ7wXonypv4IhV80BjXPE_mhsa6kBca0C9E0X09fq5AosADVbTgmWp0axtR80MHYaeA7xV-EQWtIIBFwaw7w77SzXOyPmhmCHiA1mgZ43RDKB4GTa9s3Q7l0wblAHeDd4LEmWBYg881mlsDXwazkAFBFt5xvD04VoNWbDQccoGMnoULEk715az_xmlgIor89uozxW1hdaxpULEh4BI3dVgBayqlmlvf1la9up_lSzhLa-bd2mrbXEMPbXojTYQ8QJIB5IHXyRPUbqYYNnkgEKwBG5Tkrv0OFWNRP65GqeSCfEFVp7JIeEsdhonzAB9WY1s4GSNYVhKeNynunPXI8AN7ALZEXWgYN7B5evbX6UIXX2AKHT7q7YrRy2VBlMDesSgSshg0FOX662VA35kHWwLArRvYKvwFy0uWVoGol4cL3Wa6_3XXQQ3XejkbBm6-QMx65sD8i6MXe652RZ62MrB6xvoEtCPXjGIuXx6-DWm62cRg0MvX9PC34Ca_PRuge11p5E2aHos0sIAMHYsQxwA35hGBJcjVBEKqU5t3vdsH680tmgG_MOi3XFRi2_XH6-_WNqM1b7tt_WcAzvYhvDXWu64TUgwqwAlgDcxSQPA3xgEkZzQqYhO84yogwsLQYG0DBYGwg2ZgMg2nAKg3knkGEM_Bn4MG0kZYG3g209inaIrROAXAZ4nmYS9F7tiOXx63ypaGyJ51PLOA35kw2569_BWG6p56Gz05OG0Mjt65KmaMH1WxaBnWmYo1dIIvHWZUcyBZc8nXTqFjsFVVYDdRE9EPAOYVSWvahdRCxwc62o3p5C-x2AOgMIpelma9gyA1Gz9EC65ClGSoC186w3szG3nX1G-0015NQNaBgQNigB9WIwO8oPq8DElgF42IYnqg_G-8B4YhyAV9dGDa5h9Wvq9gALG_agPq8khO0PL1y2EGFOgJjUIwh4BrWizbzsM6AoAGNt_rrTb3AFk3UYh9WYYNlcsm5OICEfNwSm_OANGAChMm_OBzYuow8RA_WDUP11mGrU2xIkVFNmtrSnyJU3HraiAcoMUANIO8oemxowEYixyjdcM3UQHbHUJuoBndo-B_g7jY3iCwUAUKSsJ4pmFGEYtB1IBpBkvPLaigos2BTPIAWyqiBRm2E3TG01EHGxMgsANE2TjAY25vSDXbG7HW1Gxo3nG5un5bRE3KABc3uzbE2egPE35zX8YUQNNXA3U7YZq2GM-VCsgTiusADRGGNltYLFQAZg3_aH7xoIVhAOU_uhHa2C2yoJs1EW4vRYW6i3LNm0x_aBvpQSNfxs6_Y212CiAr0pY2RnTANc_tHaICtS2w6JPrtrpBaJk85J5EAyBbQjTwuHlFh0KwfN1ywPV6UHzs7oNy3MKwc4YYB6J-C5R768CiBWW3-4_mwQAAW1yIYdUM5pW-y2o-C42jdXpXiQgZWwxL9YJYhhWpy3cDWo1RU9jC42Tm4HsOnA42C67tqI0xZWfK7YQAAHqMIpaA1qMHOsI3gBp7YACIweFDOtroG8AN1vYwD1tetmGAut31vutz1scgV5SsQZFhbAaeS7ai7138G1s4QtpjapTdA3rLWTZlTISDWfVC7G7qJ56AlVfzOSgJt2npZt_XA21yev5t4NCFtkuXFt6cEwcec1vN9aKuAK5svRbpzCvA5J3QdxtQIwJs-N9gBdtyGK-N91lwxAJuTLTRLwoFfWgK1RsONxtt4iCluttsJJ3Nnpx2Ns5vrRJ5v6Nl5usKetvrwz5sttvYDLpG7ZjWR6KTty1skgHdtzt61v3Ng9vrRGNsCOVxuKqDduRwLdseAWdtupa2w7GXURhYbCFfVnULXN_NtQyb6A6NhkDvt1mWZgN-bfls8vpqPdUTt6VuAd76AUtrJ0WAaCH0N1dvg1hAsd1r8vOK4VuvlpZV_lq8tEtsawjAZb3St2Dt3QXP411ucuTK49y6iP0JXpSJtYAcluUlyQ2x10NwDdTP7Lp3fNtLexvrRD5uNN3URUDF5tbYJNwo0pqTdlliA_OKkm1xwaFQkn75VJcQS1JbswmgKBFIIq-EcgREHJmVKFU6KnJ69PszqQPswRQU1tGoaWYRmAGytzEbjmCrDVjWa8Aiga0x7yupIa6Fr38zGvXI8EUBBwV2CGg2RBPcNvIBwcmSni4uMkaiztWduNU2dimR2djlx69bhXQK7hWC6VzvrAKVwigPeY_Gvds_fLS0zE3S3k6JLvcEjKAqd_FAPZMnLaml7JU5aMzjoMLrqQQ_U38LrLqQJnK6d8uMRelFx4AhU31xyJwQ5aJxEAbGRawOJwHTc6ZXTJpynTahBnhOlxXIUFyiqXqF_gAqSXx3VwgeZ9zrANhOZq5LsbljVygVLUCyIB9wncBf7vA_3Tpqx0oQg_7h2uEWYh6WEFyyIbt2m9M2s5aJET4GnijuaytChKba9dsIQ75eMtQVDbLeWiTjXds8DWakLIPd6y3WICHAT4eMtH1DbL-yFprzWtTWgKmFyfhMwpONu6w8NcSjiPNZTpUsB2XZOUHSKWHtdCNBhWXYZJihOHsXRBHtrKEZLI9w23Q925QAW1jtY9gnveBKdAo9tjOKXDe1srZ3w--ecgqIjMRJrRk6Nkc53wWl3nkocFKB_Mn5hLRnk-2gdUx7M9Ks9n_nkoRc0QWhho8O-vz1dbfTEpJD7HOoFJs93aFZM61pRPV_xJNs6jUG9oBiASjNJERc2B2FmztARgBa9nnsCSJYDY203tm903uWy5bb49v7ykRS510NFTWY9jtSy96IR29i9VJEKfyBFvkgUeA6oGKYKKi0ANpyvfnIGKGECjsIGHTYCaPA4gNrwGDIE8kH1aIvGHtYpQM4UpBmLJNFu3efc6OJ9rKnk6HlIe9uNvmAXKI3bXPiweZdbg9m-LUBIOSjqaX5yhTCpAFEHvIIOFxONghrXlG9t38NRokTCUH8XPzNOAgAJLoMEo0BEvsIuKLDPdz4TltPVaVtBiS4HAAT-NfVjyELiv51buAL26sAH4mJH5GE5uxgyU6rxC318XBpjIeFMHiUNMH6gjMFlybMFk_CxJLd8JWAQwfjt6X9xzJudRLJLYT5YQrBHxZiGlDR_tXsRghqQyqGRQkPhqVH8TX9gAL1QgKFzg-M3LdjlwZQiKGaQqKE99rcEJQ2laxhoAfdAOOodqh0pPZcAdf9yAc93dhQL9mAd5DQAfN-IqHbdoOYh6NAfUN7_t51a2GkEOKENguqHwD_Ae30Kbv_lHS2zd4CqauGVyX9gwwONXtrxtIMKRQkWo7tZNo3te-I1QpSElDAhGZQsgej9rgfSVPAc1gRqGf9xVStQsT6MmML0BOaGZEuElyfwOrsgAQV3WiPpxQq4QBaEATDYuLUrEg8V0hiMRtk0N4hWgFOuFpWg2uouobfuV7JBhdYAXuOqQvG47EmDig3f6n6IRhZwta8bwd4iA5TKcVwfqQSgMeDn3R2ECg2-FwqRygPwcxAaIdBDw1YTeL9Jg8jxKwCTwdiEdoDSl2IcuFlg1SlAyDHBdIEIuGzoGNCIcG1Sg49ZmMQjgUoeVcDbF1DIXIF7YwcRDqaTbCEwfMupFhQVG13qfdcaygY7VZBBs1PU151FpDHuNNRrB9lMi0Mu1hQbYhIrsu9DOVDj1XUxfnVFdCq6wKOoclpPp5vCW8BmCG7KvZEDMbByyqqBeyTDeFcDtO9IfNDk5hDOs4f0yfYfjpqYbzAC_htDhzhEsVofnD-YBlQbNp70HSJvCOby7gtE2VQzEC9YMuB5YROxHDtBgOZZTBxBd20EIW_NqYL_AsYB0lAvFHLG5LHiUBxEd9BMuC_k44fVgTYeJAbYdAjgTPIhrLA4AN4RkvJEcwAX8ld9dEfIjsDOYgFbBkjzEfUoYkf6yq4sZ2KYdUjlohNylQe2caGZJp1rYB9cTtEAx-Cd4AQoDx66YXwHdBnTEpyddk6bnTCGTfyS6ZbTQeNkIeyR3TS5znBlrjb2IJALxsAkymWhzxORKsw0FJwZk-cmLkgZwGj3dUjA47DdQQQTSKq5BWjoqA2j-fYQyP3NHCN9hYbJJwSAxBDvYC-DzgHNZuj_QBPzEKv3bVrQOO8uBk0BUoRFWlYlvWPXL3Md5kbJk77V3e77LGB62lXcjMl3TC4KhUoX3ZFa6rGsAHVGB4yLdlbfkC-4f3cZZKbFnDr0aY7VrECv9ZaIv952Mv8aCItLAVUL1AMnhSkSCJGYJBF1LcLaiLazxi3XbjqJZRNAA56iXUdKr0LKpacrNdx2AYABhjMLaXjbhYwsaMQRjqHbeRTNzwPRJ2_4aZNzYNWpjCQpDR-BT46XNOK9LBELsh3X0XxEtwD53wLR6rALtTWMgVYBQggAshY7a5ezDFsYSWdb0AnjrEhMLI0NljmG5mrHvbNMQRLdUN8cXLZRhmlaigNAH3SjrBYbwYMhapoMEY9tH3TdmtMggT48dXdCCdQTutIwToHBwTnGAITyCc6gZCeX9OzC_j9Yv-FyEioTj8c4AKOykTqseKbaicrYSieTInABCa2ieVrfwssTxicd2d8fMTgU4gkUCdlFnQv9gpKHj7epryQe0foAR0fHUItZ7j3gLehhiLHj6FqufCLYCT65YATieIJUPsiqTjm4NB7Sf9jpFhPD-FghLMl58Omx530IFbQ6wZosjo3VArYKsJXN-aDyWKrwakVBbj12A6V16u6V6U4tOk1MiIStyawf3YHj5IhAIMsdk90SZF7QtO42IFb5rJIiuTn8imIggB-T9svBT0CfW2kBhe9eScQJAPJoveSckvCYCjeMYRpeTZoh9AqecwPZplUT63UgFYsPoX3O-jntZ-4dVCY4WYRaBpVZArGGAlTtQASELZhB5VkfCJCqdUVdO3YlKrbYdWrYxNoo4wjdqBDHfdaz8Xd7DTmFj7vWafqjNEOZnIMdvzFGaxjw16fAdBTmACN6xRHCD8LXKATKWECOwFdXsAJB6SACBDawcgeEKS6qYsaBStgcnbg7MzCaakTAXAcas73WUBlTBrYfTDEZi0KMTUxOnYqWFhA8nWcDd0aesEAM2lhjDzYshEjaL3Xo4YLZvpDaJfIa5t6DjMGVDvTqKssbJ-rsAVeTPUSeymMZhUhjJraIvYWiZoJGev4EDBKoNGeoLMRtEKkcTfoLQMfUUGd71iGc8LXBzQz4qrXcSwCzYUeWSdTeZo0BGcuWMmdK2aECUzsU48arrZEmIadojT6YYzogBeIeXo9HcEJN2EQBcRBafM-PcQ25Uwwqj_UqfTvrYyzgVAscWfjbe6M401qUB061aKYz9LxC4OWfjPX_KKtljaEjnrZvTNWdUPH4IDQXWcuz1NDFN39Asbe3v67LpIYZk82rxUoA-zuWc9tzqChz3aA90NjZA0fhQz7H1JjHH-QWllVrwbGfjtleQd38SpOTD4RIUu1_5hSc2eRz_dPjqAVtCZzZRit6CdgzlmcwsQex2SvWcYjDWeKkWYfpp1JZhjIF6HgVKsKSDfqaNtPWo1yEKS7XmKWieuQlzz6qneMVvO5ZehhjUVvWW2QIvPK_Rdz6otbYZZqDeAnL507Kcez6WcYjYigzeTfxFT8PqpFsqdk_H1yQz1F29bT2cOcIbJg662fymhqbS-8B5JiD3b2SDufZAeefyCetMGWhlgKltIzEUQ22sKSTYT3UKvmjuwDVba6uLjhZRGYBjqfrDSzNmgux_YK0R_yE3iXVaqtvzO6sLKctidwLII90BcfqjZoswrPTDL6a7AvAPBRuvdnzNAaNa_saNErylBaknN4jvcQ2AfUNXBxRX4VAKIza4zpBB_J58AqIZStYzwGSGwe0TR1pKvRIAuyoLlpiSgX5O6YTqkoLa0Rckn3DeQAVA-2VktNLINqel75Zoz-HZgL7-otNBZTpMN6icwD6hxo-CCNVzOsjmBmc89FBbNLNVWkbCMCVzxGBhjMqBsz4S4t7NZ7MbMOfDV_V7UxF0d-jmxP3bcxeLXRcfUxaNbchBpUWJdxdEbLxfoz7LZ7bH-QNKwufMLbDYLvFhWjgTTJV4G0bLKKhXxT59ZTgFdzozsic46psctAPGDw7QzaMdK7Z7eIhVNwtnbl_AYB5AabDubdI6nbcWiLjiMBInFWyK5n-S36sWc_fG4YQLoMblZfzN0aqKu7bScQHbIXXHbD4inbeXp1L4pfmdNbZFLyBfTL8rKFO6C0Et4rZTL4zbXbdUvUejpZCTtj242RtDOQD1wSRiAXpeOrwRIU8AK4fZcWwQ5cdchseRARCp7LuhXuxVOW6jSzAzgHtAyt80ezkc5cPLq5d5AZ5eaMN5c3LogB3LgmAXLoUADpbF4FOU5ejgL5ceucFf6lWfMrPBHAHVWJ6ZPZyIxLh2B07bGcunazIxL3HvMtq-e9cFFvyQTluKtwZcSMB-wEr9EYDF0JYEr4ptH-XOeWZ7aoxL0KB90fiS4LxBYj7LGiFzoF5_YCvC4r-QjNHaUz2zm2fojOPvCr-U0PoqICEeqEh8rglfQ69DIQC-ZtSqZxfymiUY2Bjq28ri2c2z-VfzpJVfWGQuefztywdWtEzU0LVfymkpbijF-wXcJVcBkWVeYz-Ve3I9AAo0JVeZkfVdyruAGc96_wXIO1fari1fsteEIurwAbWoNwxJiQVaYqg6igR5bNoKY2FoKehfU0VherL2MdORCGy25CqCOrlGj8565M9UGwAPndnBt1boG60Hui6YZkAt7XwKJxVkYRhbb0RhY7opCAYu_oR2cRLycTezltwjD3MApkRtcSMZtfN7ILiE4atO5DHdA-8b1dmr3vaVYEL1yTKABM-IBTwESVfd0UKLIzsDwDrzVeFzqGqyjVwARhNVeEAJVdLrgldPvG5iDr6eDDrw-tGoN4S4GmnjrleUHfz3uciJUc3FavFe42H3nplgfNhSNKcrNFedZT2bYBu09fbzkNS7znZr7zyPpygijzSKu9fVBSlf7oalczlAtJ0r2PpRCcgDmhc-eGnSvX5tuh6yz-U0Pr6muNYFaAFpNXVJeFbBbQD5engLufNefLzihIrzgCbDfHdaFo0YKSsemECvOvHW6i0LYZVKLxp-h86Cz1D-RWryQBo0DagxGlVcDIR1cXcT-1iQYvNWrpfIv2FGhH-dUfCmF-w1qbDfbenBDHUQ6OYAdGXQ4bDcCbnKACbqKzz7M8ribjTfib7z18bmDCrryEjYbwpW1eTLwzrzpypy-m7Ybmde0QkFffLp5cKYF5cpAN5f2byICgrx5cQC0e6EIt1f2rjdeL8XIbabwv7mb-rwBb5WBwrxNiKbgLdBlogCebuFeG65VcGrhPZBbxTf-rrNzYb5X7TtLEiuYdvQ3ro0Lob-dwqnCfxqAYpYEu9Dd4QpnW9LP9zR7cqhDrg1fr7FVewu6rfNr32dEN-fatbuWeW9mW3VpEYD5bkLKFb8HIKwq2NztbgNG26rejrfrcwwQrderg9cNbivZNbmcrSgTtcqrpiglLKDerbkE6e9y1OU0Pjqm1b63Lb4rUilvYBRsfMcbbVZf-DOnaoKQ7flwUEhVL5PnheElofUcCuGvA6jwcfDsInOgCqrI8CUPEAEVbzYPnbuZdrLjHyDbutJTbmbfVWlvs1MQHc9LtKt6dmTKMmjpCnrv5f6jNbbTbfywB9GsJjqp9fL3HTdwOMcutO9rZx9dNeXjyKAvr5ecob99eaz3HcBbreepF8bwh9BzgHzmLIib_HdibuBwSb0fR7FaIDSbuBw1qc9ciQ67UdT5QbKOniFC77ABRS1GDQ4dcoCb8XdYAI_yabtbQB9dNdy7hXf6bpXdsOkYJjq1Xcwbs8rIznXdLPKpPCJP-fLT-yeOwTag-gWzAYnEjbdwEOiLDryf1Ln3w1TABcnL0lrALyGdgL4cDdLqBezmlnYqQdwDGJt_OL9ZnxlQEMSwLiVprwQwzb3X5aIrQmc8LTnyaLm1TaLradqAPRfJAShfrXTydmdJHf1LlINqz0Sa57wnf2Qcnds5bYqrzj9dx7mFhfvWrqM7nedh9P9dM7gDcxZGPrbvNWfx9eciq7pDcQJSFdvQQjfYDYY0kbwrzteMQIUDbPpw6nLeXbeZdRCQrfYBpGwTbhwt_QATewwSvfwQPHdFQC7iq7nqrpr5fdt7lXfnznqrpbknUr7rR6H7zff64LHcPInfcbz1fcX7tRFn76cFp_U7bTbkrcS7obc59DQ5_UPt6EIzzXz7sTYXbzZQQ7v6A3btffoAC7jrp3fdWr1XcnqarcgHlGjgH6_daPPfc3a6A8SMavdlb9FTH7tA8hZc-coH1ga37goDwHxrYfz_A8zgKA8_z3qenbAaf4QkCZhw2wD8SAiwRPeuQ3b58e7qV_zsthJvEEOAD0HpLUct2i1ratg_3zvBhRsfUr8HgSSOzm7eWWrJl-z-Fp30O1WdcOXxxrSELtJ7BReRKVbSKKwDeRUXxGRYICOiCs7oABq76vcoDcMd7C-NXSKokLoBmaccmyI1aGIw2ckK9h5GHQ3Jx9l1RD6AViAN2G-BWQLGCMIukAMgFJD6Ac0BJgcmlDSwvlWQJAVjD4RJZzwhG06jMTstyQ9ExNMtYAIlgSH0Rnwb5A8mT0D4BVlqGcH7g8RPec0lvWg9cH-EI1RRg8-p6rcsH43X5ls8ekGbI9FHnYIlHio_C1I-pANti0CQ0lYf24WpWu_g_f-O6D5Hmo_wAHg9raso-pF1g8ZiTx51ie-cVLLI8xAQo_wAYo8ZiapZ7qlV5VPITwmpmjrX3ez7NPMVJtPY9sdPeY_y9G-WFp4OxQQATfs7oqCmeIcBKUqvg_LvVbb2Gewj58f12fW-6w4JedSga3YdlrACjeZoCbNbY-fH5neg5G7cNFwjqWWsR7Fp-fesd27x0tXSQl7sbxrNGbzjeYA8CbunezeJvdw3XahR2BE-QHqYuonvMBCajE8c7xvotN1bWwp83wRPPygpkXo_TH-g9zHsUSDHn7H6-VJY8H0wY9amsAjAHwApLdTfr0EhhIVtuCpyy1C3H-JANdJXCsn2sB95K1fbqCICXH9ljXHvk8v2O4-ktZk_Gg5IDsn3TecnyU8IgaU-oAfk8j5hU84nkU9xMDnfinrk9XH3k-an2U8Cn9v6r6sSDRjvFdK4Elc3bxytV9_lvEhMcYlvKefuhN_cwAN0_wb9aXHKEt44bleesI8sFzPEpYlvYT25-vPswzpB03bYwBZ7xRDnIauG9DnHZYgIrbFwfvZY8ALcJuMEzlbNbYwXP6BjHk1PmPZFCCau7sEZppa-PKxABbNnVP5AE9sWlreXwMps6oKlpTCNbYFr0s6oASxigRabZNnqVTnrzW4xZIFBnrjGAEgeuK9LYHALweADDABy3wGDGDjnpBRuOKgA3ADkBdnmLJR2aYEwYN-zf67WDA4K0CfSBPOaZDGBY1gc-aZO6Cx3RUgPjl6F7nwxuMUOsuS1PHB-iC1issfM9AoO6BAoaM5sVIFC6TZJ5oAQLjmACrIHntAAPn98AdmhBdaazRj-8Ic3YyOLeYKagDjmpxOni0qDdn7T5AoBkfHAA8_E9QC8ITzs0eObs2Dm4nrDmqC9jmg8KIueC_woRC8EaFcG7rXCvU2b89oAb-Dfn4npMUGZsAX9oCAAYz_XwCW2CVVcAwxr9o6G-p4Eeq-ekKDqgndsxfAABGk7F75S9kkx6aAEvXPsTIv8KDrLSzCpaY52E76GvQ10Lcm9g5fCc9QjhEg0iaEaXpGBo9HIB6zHYB0M0MveAMAQo3YZcgek27dtweM6c0F0Nl_u-tl4WMjtx-BFgEP03CcM91YAwMduk8vNl8DMdxZD01Jk_j2yDNMP8a6TlPa77srFYMWcZ9jRcc2YuHBhg9vk70dKASgyvMtpt0-Sv4_Fg0uRqwCWcd9YWcd4jxuA04hcZrc7bFwjpV5RMUnH9wlV6iyEmjfE8V7j9HYH44jV6jjheBwm8UFavteHFjiHC6vr2BO7i7DKstV7mCPnZlKuOBsBtAiUakV-TBvGGoCktczB8UJP7s4O6AVl4pMJA-LBGkKD4RXNQm4zBf7WupHdCA91cIc0eMkXYqhEVs2v64LIouHD2vXlOWvuricvx1_svAELOvG19Ihl15ZwuV8woVA-3BJQ32vwdeeSc4JNcOuhPOIoHYH8C84WmKfkYNBiOidbl4HNBgGChO-qwNBmh1L_eoYEA62vtekyXgA7uvPl6wMnl7BviG2J-9msgHedAhvBCMHWgwxXnyN71ynMGfyVbimgqN9NjEN5gwCld9ylN4xSe9Azn67iqhck-hv8A7uvbLkD0gV9D061-5vEg_k0L_exvzGQRcXtaN1ig9I-VgNbkcMeivEN-djUUnXEJzAekmzARjPEk_ECV__Iat8JY0Ul2Y5ua1Ym2XbYXEcokDwiljPuAqvIsYnYYvuk49t9nYTV8Uk1t9Fjrt_44qrBtvohiJmcsbjjwcedv7bFU4p3aY43t49va_YyBZl5hzgCEfArckfUuOEuYWKHGveAMlNXI__VFhA4B6l--kAo60v_Uh0vKXr0vLQkucHQgIQpznakN8B-IEMmjvHyGMv_APxc0AAQQNd67gFl-Eg_0gaGx4xmwM_006hMiWA9Ex7vusk_a4V6sB016Ua46Cqkk_fb7jGH6QE1_jBy_kTBvTbkne_bBMB_aGDC16C6S18OvHd4U6BN56OGexJvCGxf7Yg_Rv2UIWU_N8OvR4x3vAc4DUJS-7ouoVqhtJixuPRwj465X-O7SCJtWWGwNgE9vvQfnltmhAhN5193CM7naQ3uGAft9-nwOLuahpA4wHsY_PvdA-6A_d9U6BN5rOiO4V-L_bUY-kyfva2xfvwDpY1_AyX4X96uwKD7B6jkygfxYJ5vGATPvSULkH4R70N1Wc6TVgJ-Iyt6J3rgENvwrF1jVEi9A8ea4uEzHRYUCBGwVUnJjxMYmDwOrfGUY1XEMLBGwkY0TGjEi4fwaG1SBvWZ9-uCf6Sj6VwvNlJ6-ohmryj_gGTvRpjDkjW-ZnqUIPnaKHpnGbv6IiiwCTAsIlGYsISd5-I5ALTvWglmmlcaEBtXdzvRQNUEgt0020o6Hjnj-R2ll7tmYVx27dwPWA1tx27zl4duYc21T2cxjmMs2Cf1YGpm3cwiuJ-hCf3d6TmfMw5csiH7vaT-Sf8T9Yuis2lmWpwm71YFCfPc02O6wCFTs_xtuLxerATl_AVzwO7vcmeqfFgCcvsP2a-siEjNLT7mV98yXmL3xCv-3e_jQyCO72_aTBY97kmSej4gwCrRItngjAKRbUPfrV_22RGEuarzl2_S8kG98ePiSjw5ugQPkjGhufkfJCRQemAB2BwC0wXrlpOyQADaw1bbOHyf14iICkwPC87QfC-aXXSr0wut3VERmG2AfrpEuLomKuD0_42lO3TutA0MO-VkX7oHAvtYzwFKvX2kgQ8OU46QQtNEDyjBYnXX7753AEW_dHvGAT37wWnmvx_Y2Dp_dvols0SfjlVFvTp0JCP0bCxeUD1Q2UKgg68m-vsA91293UKht9BKfST8pkj19cvUT5TUMT4OcBN5uuCafuulmitO3tfdOQbYfvSEKIO6lx0nfPcQw6D_b0ftxvHMtyVGwYjUU8mE8u1tGRuo9EdE0M7XH8wzN-_1CkXVSlcA8i9Vdii7gioi6IU0q0rDQr_QfRB2MeAmbHTj6esOHNyqO-h0l8dN2CODr_0nsqfRjyRxFfmEODuZE1MPEVUPWXN8H2GN-fu_L57gIk4sSCT7n-5OW5f7pxotJL5cej6PJfmA7_A68nLWBGXQfe-V8lu7ln7NeGEH8UJ3B80UuLZD8Xky8lJfyb6E4zGiy9N13pfX4MZfqT4Jf8_zAH197EgRP36iPr47AkX0Oaxmq2vfL9IISV6gBdygkIgfHbfY-yNQPL5DfEfHTf0diHf2b-i8t4JPvTAVrfkb9voWT6bfsb9bfUwEnfg2wrfq8Srf07_dOaZG2GD1Etfnb7Etx94IGu76Tf-74pfTASpf8b7rfAeyjfeT_VOSs0KfRL-vfD6Nvfqb6y9cF1hgvA4HuOA9EHBYwOv8D67v6xwJfVcwJv3O3vvIg9pMvHhAM2J_bcZZ-A_CH61fGh0EePl17fh752fqzrT2CgvBed6xKz-97ydueyxumbggSZ62nTGAH1yoGbegc6cT-t6c_TnqUo_BOWTdnw4P67h3QP1U_3cgB1ve4tbi-3H_Ye-b7RCwn5gwPuRDpbH84S3uBQ_HSamU3F3E_yfIBKJqbS8eamzb7AGLp6fbKLtbypYKOe0-k75w_uDBnf-H5mN_8kXf6A9DfK7_8h4H4qfgT9KfrlQJvvpbg_hb5KGK6VEb_r68XVlXweZewTfl3fLuuH4jOs8ixuhn4ofab8ffhjzL2IAOu-pRyzW3Px7f9dWBuK2QUF_mERTtr9WTIluSmE51zOKyeQ3Ze_T-Nr9UAdH7tfmbh_2hyiOTAToGU3CRdTuX7S8Hw9YipGfozfSb7-6toVTffDIvzZHi_aymMe_xUFibKdq_XiU5v_ovmivNQVfSif5uepy8fuZ6LCFHjguPA5JvcFwIRs5z-3FX8y_TTX6_bvp1MECTguVk2K_EeULPZX6A4q35_eKIZy_m39JEdX4zdFNqYOmmz3ORxqwi47hu_yOwSeyn8FiAeQ2_F0C2_oSlGqj36BfA7le_Mpxq_5390Wm_nU_MhuptY5WDfRn7knM77m_cD4Bv3QGPO2CZbmBN_b0KAIRCYX_7fwhAs_0D6s_KsZES6P6lv4H9qfzis_f5b5vfKb-rfT8DBf9bxpfuA6ffd186fG826fusyJf0P4wCsL-7tZHrp_NA9Xf3QA6f0Pwe-XT6e-PT7Z_YX6j45pq5_8L_yh8P6mEnteDf8t-B6Kl5tNWMxvUBQLcfoGvlgh00VHYo-67hwNW7eCekzBCceLzxZjVNl40zWCazm8mYN_gV5kzFgjoTDCcZVmqdkQ6qYkTmqcETkc0yfQaJkT_LnET8ied_fT_PgvI8dYw99sTaL5q3qcdwzW-e4kk_b_tu6bez41TzfRGDhThyYy_JOtg0SydMzeZwxTi_cjvxQ7jBqL4Xvu_dmv-_axf_EM3v4H6kzdv-gTTxdgTMaoJvcOej_3RcFX5A0ZvtD9x_2UMb_2Jdkgsv6dLVf-N_jT_r_W7_R-e6eL2Lf-DQbf9LfU76YCSOeI3Pf75_6mfuLQCaIT2mad_FCYb_Kf7ZIq37O7NR2aq8jAOTW_7T_4__XvP1_Q_tacMzJyZ83f7txTLqYJTO_5KcsENwYmf9v_2_-P_6D6fTWf9Yzgb8N-7_xRGuyesG_WRvKmGOOEglXI9O_X5Y3O248KY2VAWmOUJQAUf-npwukCamxyYscM_--Kav_oZOSAF3phm6V_7kXh3-M_6b_qsg2_6KHHAB8AAGprABWf53_kT-CP4bAgq4oqYCJmK4KCYb_uGCJAEAZry-B_6EAWn-FH7b_vdG2QBfHJDsLn7UDo_eyH6gwDnIAdBTJtv-VjRsCCwBaX7MWogBbX4iWvIBJVr5eugAfAFU7AkeRLDyATvQ8kCmTt_-9bqWfp3-BAG5fjn-IiSiAfoA4gFp_lQBrSRrvt7-wqa-_nImJMiapmL-4t7MARQBRAHyEJYBt2jXQLLe8tqK_oZwKl4ymtBY2d5aDn6YKEjBwGhIFJjKvhZ4wrp9nFkCY8ZsuPp6QV5piBjMspoUzGH-Rf5EeLr68mgHCEIA-zx1esY-N2hIvrxgc97DPove6L4l_pi-h_a5QNi-bw45gsAOenoncKmaoN4vXmLeMD4FXmh-cA41DPL-7f6t9jXanSYqXgwC-TSYaloOPGrOTihqdGg8VGYYQSx7qhHIvhp4LOMBBGq93Djgu7CfXskQVXZDeokAI3rGKGpGPijyBloO_0hABlPU0GqgyFQClzgWGkPI8MgwaqvG1CA97sB0xo5jqqaOfZbmjnjIdthUOPRYpzidQh6axyCXOFosCGozAfJIA1BCdGhq0mhAasM4j8CqRtXcshBXIOCBpBB4yGSWaJBmfHi4Kv4yAtXGgz6XOOsqG8pbyl7AO8p7ynqA6Mh4uK3KQz5jyDs-qDzY2J2mfdxC_I9cXSZEgUF-vXCErouO-fCAaKJq1hp7GO6cLhpHvsMWd97Evv5-JITfXLmWIlqLlJnsQr575K2IkrxHmhxmBs5yhjecEprfuDiaatSUqE3IhGqWTBVstiaygTLw1IxnAUyBXKhbjP0gUeruGt0ON973wGqBOZ7O7tVg-Z6KaoYM7GoMxJxq-qhH1PR-gTyA9pUwOc4WEEaBxGoGGjKBowGKfJzAWbgagcNUzIEaULqBCAQchoo0woBDdNvoVCRRLB3qD5AxZApgoYHueMfWqnhY1o9g7epSeLsa8SzleNp4uag0IMeqm8r26Gjwz3C7yvvKOhqHDBv4KG497g14dQrEbkeArXhkbr1ognixgQKA8zqcFLR-K85lgX3uFYF5eFWBpG7D7lCGGAD1gTSGjoEEDNcEZpRbHs2BHU7SgVSBNholGo58XoHnyPiamoFB6n8Bthr-gfRqKwHpEK5WtRyrgdBQNLYVBpuBpZDSQppOu4HDkMI6Zk7uhucUqRoMugZkIYFueK3oDeyzAckQ-RpRgaDkMYHXgViGh4HTkG4sj4HafCWBZe6tgaOARG4dgcSgXYEdeJv2r-h9gY2BttijgT-BBG5_gf3ulYGAQUPuwEEmBgBB6fh_DoqoQ4HCgCOBcCQ3auOBit7vqNRoL2hexvhqYPzCmiYaZHrlPFimtprpBCaaKkikenC-IExJ1D7sXaZ7IEF8DJp0QYvcDIi-0AxBd1xaluRAsiAhGMLYbGjglmmG1L6Iau6cKMzcXu5o0sb9IFpc4kwugd1skkHO5q44r9geONyUsthxGK3YjjgqQTfGr-CaQTh4XEE8aHVwOkEv2O44OHg6rKlQlDwyQdOBpW5uaL7wD8ZTgQw8M4FaXEMaGlCUPPhqUHhe2u9onWhfaDqoQFyjAKgAnxDEQXCBDJBsPJ0wVJYUPDOBSpyvkEFBeyBsPDDqQpyBTgEQSnxzaEhgR0j22Bw4nEGtvK7YQmbHaC8BSDhBoNPm5EA_-Aj8qggZAgcB8eYlaOjg3kFarN5oXkEEQd9o74ARgNCBr5RVdp1CycBzeppeLnBe0OJQEPqGgt2eVoKRsmny3Z5P2L1BYHghQO5CIQCL0D7OtADdni44I0EnsMXAc0HGgmgKA0Gh0t2ePRQOcMTAVLSEYF6odh7BEF7Q1QAOCJKAHdhJCCDG4lDeqvBAqjjOgFtBy07ZegCYY5xmADtBhpIB8BFSDgjqYmkkUIjdQT9SnmCXQZdgc8DV2N2eRkAtLro-WkCuYH9BNADXQZkQj0HpOM9B_LKvQU3gY4oFQEKAPMJu5vtB3gBwwXmw1cCxRAZAUMG9gKjBWADowXggCMGlCsjB69gs8EXYeMEEwTbCkbzYwRmSMMHBMpTBRMFIwRD6M4pTABTB_iRvQZG83UF5dBkAvQI2wplM7ACMIojAStJgAMryuqqgwRBA_0GF6DjBe0EvQezB8MGg-rzBdMEHQXLBGMHUwQ9BtMFswRZSGMEKwc3YZME2BprBHMFYwerBu0FKwWjBKsGEwTrBVcA7JgbB8MGcweOgXgAddDzBzMH8wYLBwsGiwdoQYMEEABDBxsFPQTbB2sHjivjK1sGywVrBhMF2wbqw3MH4yi44YCJXAK7BZkAiwWLBnsHewWpAGsHBwW9BCsEuOKbB-MHmwVTBsURcwY7BgcGt2NHBAsFCwXHB7sHiwaYS4MFSwSnBsMHZwfk4r3o8wj96r3TVgOtBnMBmgjNB0tgZulbwukDdns3Yp4rdwSRwwVLMwkXBgJpgAN2eDsFTgFLyEApq2KtBkf4KxtG8JaDdnudB_IhoAKkk2ECnANsAfUHIzqeKGkD9wYZAY0F5Qki2U0EwAD3BQdDs9OIazKLwYOaA6AxR0lfBQwrdniaC28G7wd1mSwjFwcrysAo28ADBOr7qIj1BYSJPwW0WzoDmgP1BQ7jdnndCcUrxQNrSu8HbQdXB9MG1wX8YDcEfeogAOUafQYPBbXDDwSwiScHSwZnBDMFwIR9gQvoOQCGw8vrG8s6AP0FJwcYAJ27roL0wavpAdLAoaMj_yhomE67wQEn4pmCQVnxA44RjnJghmsFHQf4ky_biUIDBXSq8wX3BPgDlweqAksGGQF_BJMEWKIIhHsESwZXBGcaqQIaCuniWQLJ4SiE7wUIhicGjQZGCVKbn2J_BQMF6wYQAp4oWQGohMiFewQPBJVJDwS7BLCLSIRXBJiE0VhHBk8EdcqJWSiGIwE4hlkA6QB8eZEjTxAfEZmg9rqgAa0G9FGoAVwCm9hgh0CHKwfk4qIDcIRDgiCF0vOOgWVKlGBRIwSEmwZwh4SHFCpEhiAAGvnT4VR7WxnKAfoBx_nPBsnoCAADB-8HzQD2Ck0FC4NNB4cHr2ItB7ub6IcAhpiGlUpcKnV4d2I-A0wgNIWQgrAApAHIIWAAkAEqAO1RWdAQA3ADhAGAAGiKKAKHSSYD2AD9WKQCh0skiYSCqwFgAoyFagFMhltJTIZHSySLJIsshayHaIsshXSHz9HAA8yGLIeDCoyEZQFMhjkDHIefiZ5QYwOTixyEc0mnyiMCOQBMhiyGjIWeAodIaQAshGkBHIRpAyvKjIfYAiqB4AMshfiR7IZsh6MCBHsChSYAPIckiPtJmUgChWiKUkk4A6ABgoRpAcKFJgAsh2iJ6gGZAUyH2ALJ4rgBWQOih2KEc0sshCUDooTchKSKIwIShWKE4ocshRKEEoYjA9gBEoTm0JKHUoUSheoCfIdShWiJa0uihVKErISkihKHrIaShVKEYoRSh-KHcocki5oD0oTShyyFMoeyhGkBsodShHKGUoeyhPKEMoVAANyH2AEmA0qH8oXihySJ8oRyhIqFCoVoiyyHHIY8hzyGvIUchYyHHIfchSYDo6HWWPVI1EPzBH1bdbF1WSwAOoRDWeCI2qvfBy0FhIoYhm8EdwVPKf8Hlev_SgoLjwU7B3gDdnrEhGz4JiGPBdiEL8sOKkCHCQK3GhVY1QFDI5ZwaYFigaADHiqaC7ABaIlZAXcEvjuOgHCHBwVwhKSHRIrIgeaE1wWEhx0HL9ogAaSGGvmVQS8EkIbYQb8yC-Mv2E-BiXIX4r8hHAGOcSg5mAF0iQMbEzMWIvCFFIZSCE0FzlDnYQ0Gt2MTAvqFTiuOh7iHVgA_B1kA2QNOhHYjeofOh3Z5tAfkhY8FfQRgAqgrO8GMIj4DJkjMiKQD8kJtCzEAmiDfAswAQAAEerEAfCggggMY0JGZAlhLgrDSSMwAzgK-A66EoIZ5gYCH4blGwEMEqXtDMEk5SThfgGv6xevaAfhDR-N4-W8DCoNH4tTgQYVRqNwAFAC8sBEDbTJvAIGEwYf3KKnaQRDJO0GEYBExOlR763qigAeqwYTOALLBJ0lyCf7g3QmOGHsK8AL8QvADOANjAcghLQNowT0KFAH08u46YYflsjoDWJvQ8eGF0oCxhPoDcsBGePGFcYWuATZRFrDxO_aycjo4-7MCqIB4APo6ujvVOAGGLTDF6YEBkITkQx1D5EBUAHIT3QSMCxWCmMFcg2mHpcO2gP0bjxrJhLh46-kTY-vrcgoGsDmBBwCUiEzjG6DqAhMjpmBeqRAAEANs2W2BNTp9ILU7GrP7szBChlD9aRsC1HHGCwtoA2kLQK6YOYF0AnBxsOAp6f-xZYGXA1MTSVq7A8iDSIuBGSxBygAd4afYHjGFhcEiqhlhO8WGJYbcA4EZ4hv30gn4wbJJQYwDtALlhSWFZYVZEeNAFEAmIuPgQ_tFMmWFzlE9QvSTNYdfkJjiZYQ1Iw8S8-AFQ0GDhYZaIb0C8hC7sz3Bu6CcIkgwE-O4UO2DeYZdE2WD9YSvot6jgRvHOj4AZQIGG_QDBhj4gJwjFAGGGXQBHAEvo_uz_KGwcvWG1GlVhb0CaSE6A_SbpZHKAQrDHYC6-0vazYSdhMmi0rNSgDmASBnyOcfRAoA-A2mDHKPdhEWGDYV9IG6CeBtBgr2Ev2h9hYBDfYZlhv2HKyFtoFWAZkBSGYngEgEwQi9rA4XSMzBBiSE-c84CzhtpgOW4_YQNhgoaG5mNuSfrQYFQwzQExJmB-rH4Q4QNhnCg_rN6mxZTfOm_MdxiWAOzIHrKktPm8H3B6qmEitvBsKHkANtTsFE0sJuKnADEyZpDM4YSAncBs4WAoXvD-MPdWlgCM4ZyadgAS4e9iTBTd4nTgPwAebJJgLcC5rp5woAziQBREtPADYe5ObWDJktOSgpYU-kFAREBWJEVWrJIjcJIAKyJfYhVh-WEnYZnualyXTqzhFqzPYX1hD2FwYqHQHOHH5gAwAwhq-Jkg_QBKMJwokOGe4Txa5OrMGC7h8TaPpk1hU6x62AuAAD575vXKyHrMGDjh82FnYTsSeOGJ4Qy6aOH17qS8buHHYZDh6eE8ctRIKTD9GMeBf0A54UXhpJQa4HNhKICcKPoiPHKiSJdOkQiBoNBOhHSBoNmU52Hj7rXcfvSbNNPKCghmQJnhHqQ_0LCYGOFQ3BPmva4RxEmGl065dDFEtFTn8EKwB3ouvsrAnzbwAF3hEn4qfgHkg-Hh4XFBc-EpYdlg1mHrOHZhDmFngKFh7uE8ON5UZ5rc0A7UtKyRhpTEDmDJDP9mQkSLQB3AFuZxIFg4LtTpiEIUNoz_rA6Aqmhg0JkO8gj34dBgs-EgwEARz-HYwNL2xyiyPNlu-hBj4S3sGs4wboGgKKQ0AGbSEYCF0jgESozjRIHagso5QP3hBdLEToP0veHxBDgR_e7bqNgR4-FLIHQAQ-GEEdKoFBEt7FhI2ByhBhk4lBE5QG0ON6z03HphkojwQEvh60wr4Y02VeHzZJJ-FBGCyhbIY-G4EQoI9BGcrhrO-YxpkBQRtviIEWs0btDwEZyuB0Rkror0tW5AHmlOOeGDOFwAUdjrNLoR6AA-AC2CKhGcLGoRdO6GEVgAfx7r_DPhv6DGFCwRdFxUbM2uehHRSoM4dyhR2JYRPhSmEdDcHa5HgM2uxI4SMEf4gziWhLcUUCCTxjlAXBHXwMnA2VSG8P4R18DqHNH8zDS_oCDgLhYf5ixg7mAO9u807s7JEfjWGRH-zll-ORHtWlFW7fT3bG4RO05pEeZGd3TKpIq27uBkEXkRwcRMOoUR5gD1Ee5MZZRNEVbOJREKCG4RgsoNYZt4ZRGpES4eZ0T3pnMECBBlEejWLREPpgURlqjo1pLw0xE-AG_M_REMvCDAlRFbpokRNRG4ERMRIxGNEXMRKWH5EYLqOxGzEezY26jdEf3uXCJeESwRChHBAMf0xRHwIJPGRm4AMmM2JBG1EXUKr85PEQgRX25jfo7ATmSWDl_Bz1DOgAAsUwBmQDzCpeHIwZ5g9ojKESwREhH2oNPKG1BP4A4R0hHBADXW2-HV1gQRWBHeEfXonr5QBIMQhJ5SEWYR-4T6AK_mGRFPgB0i1IAWhm8RqhH4kc9WIdBEkSquOIBGwOlhFOBj4aBgW2YAYMlMlJHqkIOhuJHQ3OyR5eKBHJvweIhLoBv2CYagqO2G9xoRmtyqN-G67HfhYpHZYI_hz4wv4a0wRmDIQPSAcwDqgLWcTSw8kQbIiNBwgFSRg6HSkZeMHwY6kRyRd1TykfUAzgB4IORAj5zujuXiVHC2-HSRSpZXzvaROADS9rhC-xqlRNARToFf7rARP_5mMN28HSzV6E7mXPQEHoSeP5pj4ZcR74A6RBQRs6xozIVhRuq5zl-m2gzokcoGRpGv5mP4dpGkkUsWl04JtmT2rgxpTqN4IhFkEZIRYZGjAIgRv2oh9PIRowB6EdYRbWCV4aZgIG41iNoRthGqIEYRw3ijeJYR43hckf0k1PAWEb-gVZEonlMoOhF2ERPk8JFmEU4RlhG3aqGI89y9gIUMrgCBoHERYRFbALOQIuDYwHCRpBF1Crx2vZSjAP4RhvBH-EZI25TiEYWRhxG3EYuRQLLzRB38TxEKETGRtvjMpoOUKLzbkYER-QSjAA_uqWTFkWLYftjDkYHadFyHtOEoXvYsEdGRVOwbQB1-iVDu4W1h6bbXQIioxWE-kRQRD1IFQN8cN56EIgFMo-EjkdyRKZErBrZ6kc72kQyRMQJNkey2xURO4UcA2ZH1kVG6wHwfkc8RumBFkchRtyhjKF_Wr5EyETpE_XiDkc2R-hFtkb2RLZEmEZRRCc4roD2RTFHVkTYRXK5VuOSRo5HU8M4RRhEJEVG07TbGSNBOn7DxADURx5HkANwRqoRLnhMca-E7EhvhgsQFkeuRTxESETcRC5HyUdUywDZJkSbOu4TuRBpR5FGkUV-RfvQLEckRclH3ES0QNeCFtm4RO5FWzuy2ZxEukDRgUZGtrDGR8FEdYSBRseEJth6RBAzxkQhRJJbkdlMAkEQeLnVOJmGaUD-hBLhN3riARl4nMIBh9XZTAMl6BECpesXeXSZmPtGwcIhO2D9isMZQIOA4mwBRAH7wTAJMdmt6pwAI8F9wOADI8A9wh5gY8ASkRuG48PjwPmGG7NlCy968NBOcsHy9JDDmqJR-cLNeK2CqsFooOwDMsF8MLbCFUVAQEfgovEVI6gKj2EeAeIzrto68ibbk9kbqTALp2pBEWVHMsGsBWwEbAU1BPihJUcQCPECagFl6o5pfQKUghXr5wCMC81x2ACuqF3ANABXAApg0kui4WmEF3mlRRd4jSJc4zdRsYaYGdhFHAZKA8FaYwnjIUm592C_YWo6dAovGuo5x5haOmXARsD9WajZsiEu23Tg_RPDR0HZmAe82GzJ5gAR26NGgdpuWv5anmLuWe3bKAr2WdQL9lqN2HCp2uKdwsCrWmLIgGioEvloqlMi6KqlgXl4WANkmFipOXlOW1NHodq4qDQDuKi16SfA-KgUi6wAcKmF25ggwKjHMgujhKnGqyCoHODEqC3aC0c98_SoCuIMqFMi5cCMqF3AE0doCZzgXxiIClpyIgVICKAIQyOJMS3jsAgrIhtENFN-49G4rIjyeK2ZTaO1y1jTaVICuLHCGQmAq6HbC0WeqsCri0U-4ktFRKtLR6CpR1hJOwdQxpGIuRMITnkEAxi6fSPfKymD33GG-_8qGjNbRNIwfciyg_CpR0X_K44SpVLoOVyYCYHCO-JyBIOSqQpA0YFHRYio7oEbAECCLQOOE3_xszqQKedHKYA7A91BSkLhsCw7NALqIRtAgMNDOuh5hIjuYiEBcAIiqgro84FmuaAj9oL8mAJ5YoBOeM2B6wDmU1oimIFbuTtSgRApgdZTxLmaWVSrG5jGiLGAO1AbcI2bjZlsABfBE5jjCQpD7yBA83YwYLqNO-CrKKn0Anm4TLmSAd6AHcA7AFKyHgLm6BfAXgEB2d6iFGGJI6uRN2BfRLmFUJBfR7gAv0ZRGvMDSII-AiMDjWhYEPRBzKD5chSpvzObW-KA7lv2YT7jRmHRiJ7Bf0VfR_G6q5vocEjB0-G_M0DHhKqHAqtaYMbAxOHYGeDgxu5ZYMTh2vWBoAGbUZBGBAOCmDFZhIq6AEjBC5LcA2cjf0f4ARJBF2KgxoDHtoc7RPT4uKuuWP5bnlnjRBoAKCNjRb5Z8MdAxzx7Qnm-2NliP0a2RsdYo0ZmAmzRCMVh2_DGjeBIxv7b6ALxRyZhCaitm7DH3bCox2ELbqLoxj9ExZIkAPHo-XMkACggL8o66gipb1JIUFHhR2BYx1zS20ccYDDH2AC5hHwAF8Fcu8QBaqAnRclArYCSAK2DGMcmgzjg0Km_M4iqebiNgfjGNYAExJaBBMd5uTwag5NS2MjGSMd9An7YUsAB2STGJ0bBciNHTtou25jbcdmq27WCOMW9AAjTOSD5wujzvflkxFkgAtGJAH1bNGD5cujYONk0umNGpMd0ACghC0rdONvDGNm90hTHWILJkJTHN2A_WSwAdtmfCgTa1Md9IeEb9tjUxJCwngEO2kzEi4NRIeqDyeOnOHqTOMa4xfiT1BNXCLABsyq0Q79G4AH4kTgbBoAHkTTxaMckummQgMckuVG5Z2GDyUEQrgD4A1xHHMXT4eagGeH9Q5DEvEZQxEKbmACaqN26c3CsxuACBAKpAV7iz-j8xjwjkABGAx7ZRMXrgeCodcoHYjqH3bNBCK6q7qB1EQ6g7MfLkvTY6BB9W8ErbMdnIqzFWJL3ofPhF0cSExzzWMTWAtzFsMcku26h1ukCxfzFoAACxSLFYsbgA2sAgsWCxJjEQaOAxe_KF0gHkJqpvzHCxpSKlZi825pDIsWsxJ4TosXiI84gCsTixtLEuMb8xpOL-QSVggLHIsQyxoLHNjsyxhRxHLm_M8MDK8i6hMLFcsZ4m8LG8sRKxrjFlEGTw4tjjKqKxdLF7MLOk9QTCsZowprGSseaxBODB-j1OgVGIMS_RAgSq-rtRTyAa-nYAn1GaBkIAwRDBaBkBUVgPUYGArmzCfMJYIfpXoHkwBTCUYCxMvAYSToCx54YdELkMQbGCaqPy3TyvmqH6F_oJAFf6vvqWYR_65QC0IvqUthbn-m2OUABOBmaqzuBv0CUQAUEp6KqQuUHpQflBDvpGCNIglOZKTjH8Ijj9oISQKubGsfXQOpBdsQWACVBVsblg6uZF2D2xgDDDsSoyJ4F20B_6dFi-0CEiTCTSIJ2xWeZoCiP8C7FDscEGyM4YArDgiNb3MAPYQm4WBsuxqJBF2C2GY7EGqv76kuAPUdBON1ENADgA3cqn3L1o3VAxBha-5M6PYEHQ1KSG9GByIPqztPOg_gCpsY90KhD3YVR017zm4A9RnCiAcSsRGuDP0dfRiBAgcWEgZ7Ei1EgxapAuCDzwX5pY8IfBZSG8pMsxDmC7AbfOFeB02vgQkHH9rHBxRBANXPnhjmAgccRxdlGg5JAQB9FcSJfRL9H42PvRA9HF8GTRjczcKlTRnDGmzPZ-J3B00ToqpiqpiEOoDmDUcUxxtFQNALdROAA0cSjgpsB0cf4AFrBTnMJx0nGEcbIGOJBokHBgJHHfWlexOACaBl_68bEB-lrAaQA9Mbhx3UD4EPMQqnHd4T5R57HeZPm4LSjfSMZAagan0P7gcIYJZjOkhbExsTFgIHH5sUIAhbGL2vJiWxBG4HOxO1BGsQnYOeYsga_gubHHYWBx9eELoAVB6oCBcdnkO1ATIKFxi9rUJLAAx9pYyNvwLABAron62lAmcXpxKTR7Ed0Bw-FJ9PyA0q7v-spxYjoYlkE6IaZppOIGKnG5cfRUBWCcgRlxo3wrQDTR7FxuKh4qXir80RvoGR6w4LVYncC-Zpn0wIaful36_-z6OhEA_XFIsN-RegH44fb6DmBIPEUWQXob8BNxrs4fAFFRatGMuseA43FaKCtxqbD6ABmuzwaHhn0YfCAtYW5WIIabBnNxjTwLcWm6a3EgYEy6u3E0APtxy2zzccqWirEtAJfmedTQAD1QB1Quuk8gx1TPnIzmwgo3_OBQJlDunEIet9x03mIoswZN_LZcNBE2focMrgYQWMexOAD3-v2gLO7ybhDYaRi7kanmtDg1qGCxRZaiertQMUbX6DUGrhzuRliQ-HbS-sTx7kZQFvNsjWAU8WJgVPGKlrbkJ_Rn9K_02kTeEPTx8wCM8WkY43g4FpCQnPHXGjUG1xFkdt6Rhwys7uvupx5OrpJu3O4ajjJuxeZE8YMYBdrygipuVTHzwEaeUp4mnlqe3c59KsfMVOgSxMrRmpwBmmMqpCS50MaiZHhwcbFg0UFk5mM8tRwbrO5GZ-IK8bPa9EI8QtEGom5CnuJuZNzq8eqemvFmnk4m_hS3BjqQ4UHWQUWBW2CXQkDqJhiwBsDxZXExuhVxv56pRhrgOXGxhPVxfgDjeJx-U7EDIJYSaJDOQJgAaABSQJ2em7EZ2P8Sr-g32nXoAF5hcXy-2fEFAJVxpOH4htHxCbql8ekG4E4vgdUcYvb_Xpnx5XE58ekG-fFZcb7h8xDZ8WaqjfFXgZL2cYE0tuiGdfGzAP3xufGgQc3x8kApXsSOowCz-r5av6bzkBeAswBXJvagc_F-urdAR9xA4VnxDfG54GBB4Na00iI6vWYNcYDh4_HKqEnx8QBn8arWj9Y1cQyQpnHJ8aOM92zL6KvxdwABvlKo1_Ep8SksafEg-mMiKfHyQHW6tfEV8bHxl6gdRNVxL2G1cVfx__GcgV_xaVb_XtRuonEyVhN-RmDyBktA6wDbYnsYeVAGjFRBb7wkQYZUUv4gTFYGOz57sbHWOUAs0ZYqmsxsfFOWJ_H4CYsg1IyRWnKA3sCUCWvM3sDyjBv8dvqIYEf8iUAjYLv8jsB_cNSqm8Zs0bYqujqz9Nu-eVA8HqTum3g6iDT-P9qJDDIJpHohfOqI8gmVhrIJ6DqIOhqkWUaNdN7WaglcUZC-79q_uicoSTwl6BkUhzTryCY8LbTK5KvwuAnnvJioCgm2GvQJa2xUvnlQjgmMjOHwpgmTtPYJZlCSCbeBiglzPBoJXFFQVKGexEF21ujR2uoxHuJIG-rCjEfuIExYHrIaa3zrfG_03hCc_v7gPdrBEPrmxgljGB4JdTGg8TAChuRwAikJLShkenk6lX5_QA1Qrgmcgc4J8kgVCRZq2QlHAKXEDVA-Cc_qiWI14Dx2NeC1iOy2W-qH7rDAhQnnfLEJwoFukcW-XiJppNUmZQkuCf_AQMx21hIJETyiCZmQ1hJUdMKRneQrYPUmZQnVhkmBDkHWQbwJd4GJQTOBWwl-CcR8XgmsQYQJ7EEvsf0giVgaQcZBTjgyPEZBcDgmQV6-eoa8homGwXEPCXIGf9GJtmIMu9gQAMGxyQBI8a1CGgzDgSvOQfHplsO6NDyQQVHYQIlpFkw82nxxKB4xNtHeMcrUwCSKLJbRsIleMZsx0UDcEA7R3no2CWU8r9p-kTvmpXEb8A3Edpx7IDegzXbb8JgRDLrJCboJLLDcfEokq1ohEJZM3FprNGPxyPGCeCXxnfGL8VHxoHFTgCxglZDu4RFxVih8ieFxPInfSMMop4BtjCAw9fpY3Oug5_HciRcAooleKOKJjvg74TKJV2CllMSmdqyXlHDxneR0CRMJ_S6NCYweSPGYCUMaBoyHCSKaZEF7CbYaXdqpCWR6vAmUga6RHqSikdVgnYYukGW4q4ZIhs0awFFtdNOGX0jDxIGemkTyCsE4EMB2eJohpvylITnY6fAHhv88x3H1QFhGqEaHcXEoMYkHhsrA_XG54DxGOtipia_oD4ZK4LEKybE_rKN8BUYsMCdRtMDqRBVGoPEYVI_E5WZikYwAKALCGttG0MSZfIhGYpEfRMggd3r_wC1G-c7zHm2Jayh1_LGQ2MAdicFxDUDvhsIa34E2IpfcAIlqAAOJ2x4NQNseA4lCcdIgXEgURvOJWQQDiUIAIgCmcRRGifFpAAOJMIkfcp4xhTHpIA1Au4nW0aiJ7o7pIAOJLkQo7jOAh4nAANxwA4k7UN7Y_SEfKBcJtwkQOPeJgNAwOA1ALji6QdkALUbkwEJEOqBBRnGJYE4NXP48hUYRMLWJzYlYro4iszJWiSzCwhoYkA1G4wnIIIR0A4nhSEhJ8kg8Hu-JvtBDiYDQA4mjiYOGE4nYAFOJYIkziWCJc4lycQuJXQBLiZRJK4nCGmuJWNjcRsBJfL6mcTuJRsAoiQeJ3BBHiexJe4lwiWiJCIkXiSg0V4kpADeJQsDtNHCuFfKeAQkgC6BmgqTAwhoPia3Yd3ovifOeKkHYSUGgn4nusjcJKkk4eH-JT0YvRlhEzEkUcUE8CBDgSUVGptEtFFBJPxBwRv0gakngwMAAw4lQSY2gbiIsRiOJZDycwIRJGEHaFMIa04nAALOJwhpvge8e8AAYSUuBVkHplquJz4AbiYZJuXG6SepE-kkDKFIAxYn6ADJGcUkRMBDGIfGF6O6x9eT5Uc-I50jqgpo--j7bPjSBbD5mQdg8jkESSAywdkE-UOZBZUkSPgYuNEFwSSFBRMZziNWAvQlpCU2IFMZQcNJB5UmSPusAVvFAluC-Qd7rAHWx49gZQeHeDt4AJF_YlwkqQao-KPRaScpBekF6PldIGUnbUeN6bwnMPjECoWhNSZ8YiL4ZAplJQpAqXlJhszDn8PtRymHKfnkQPKBJrGOcOeExEbRsNeozJjQAVvBpfNUyXFjHUFbwULbXgCjQqSoBmsmoQaLvls2gQrDqQNYuYYyijKeAIuDFdqOA90kEAFbwoox9yurgQowJTq9J3IzKcFrIj0lf6DJJrnRQye9Jn0nyJukqROhewH9JJw4MsIDJzM42LgywIMmjgGDJ8xoIyQ9JMMkUyXDJvk6IyV98IT7HUNrST0noyZDJ2tJYyV9JuMm_SQ5ehMkwsMTJLdZVzvBA5MmlnJugMQgQySzJVkC0yWLJ6kAMyTQA2tJIyYt2CslWQGzJcUDJAgQAnMkfzh9J3Mk_SfjJfMmhoADJcoBAyWTJzaCgyXDJIGiaydLJbvB0yeLJK8RWyUrJzMmoEYjAaslW3MdQwslaPDrJOMl6yd8C_0lEycbJJMnAyWbJtsngydTJ4M6IwDLJlMnwyZDJZtKOydWAWshm0q7JGskeyTgAXslpKj7JBMmGyf7J7QAmyTCwoslRyZbJsck2ybLJcoD2yUXJn7gWANYuScnsgkLJpMlV7mnJ30mUyLzJkVhZyQLJAcm1yUHJb3QhyVTJ1i6RyfTJytokyXHJlcl71oXy1clgzoXyXMneyU3J-sktyXzg2cnjyXAKpsldySXJEskFRCPJZkB9yXbJA8kt1oXyccmEYDnhH27ecHiI1UQMsLwRPlwF_qiAPdxRBmCsFypgALfJgnjk4J26GmBE9hr0CbSogDJePnQP6INxwxGO9gu0ZpRYjvM03hA3YTt0L8mhoMApg3HNPIbaDFGXTqs0zTxwnt8eGAAR9MwQN2FreM0sO3QKCOApZpRH-OWw6LrawI4AmADVPBAAMPBDuFgABNAhUWYAOeFMxCfJMLBnyat6F8kQaMFq53TiUJQpGOHn8XfaSng_yaMOejrPycAg50bl4Z_Jk172gKApd-AQKVoymZCV4Vm49viQyVbwguDueLwBDLBIQWgpafTrAIfJoF4FANQpPBGhAC6-PvAMKa_onnT3xJpImfIRngTEN2HrTIXoOeGL4VopfBH8kV0GpNhCkTdhynzmAD9EwLAygF9gAgD4KSE46Hhx4Y3UUimvSdxeDikVWDnhYUB2GBKcyL4leLpRJlYNiFVoCJywALPR7gDk4BYpPCxYTmGMtCl9aLXAdxHVMhBgWV5awB3hQrAcgNNuulG3qMuRIdIJWm0WtKBxKcj0RuqWKcvhNinb8Hkp5imXTnphJIJlwMxAaXw3Scrwb-bnYlHmiQBGyQZw3lKpKGOwAylFWusA1SnWKT9EPYKnyVYpH8C1KXv6nKCaMBopiQC0KTLY8ylbBJMpLr6yIKopP0QLKUspGNFAwlspqyk0KVMphoh7QNApRwBvYo6IkREtKdjg7SnSPEjGzuHhER2sD_BXKd7QNylJXoERuiB3EW9ilDjv7jBATynzANERPSkMsAcEdxFCsNgpk8ZrURkCemFVdpqYKAJ7AdxAOcDVAmaAzo4vUTRA6VHvUSMC2v6ijl12so7UIFdRMECicXdRg0ggcU9R_0iOrjRoU9hIuDikYNE6jkjBeo4fUZZ2qCrXcJGYQXYPqgv8srQMqXvKINiBdgnwrKkhdl16bLCXApc4FJ50HvCEkgmnODyOQQJcdNrRD_FvAEbR2yAWaOaRHgCLIIomGh521MHUl0CbPKNCdu7NAGSpL2gUqTF4wa5AKIf2i9EF2GFiFyB2AOqqxKqQKL3gPgBHVC1W0SC_UPoAA9A9zrnw4ypH8Smqtia6qdBAFKkxQL-A9chgsYFAmtpR2HYA99ZEABnQb8y3MWZgMMBmQFWIb8xmMVGpXspNmkJqIalS1mWIsaktANuoYamm0uK2rCiWWse2YABqRIX2qvooAkWOBfpa-hmx00jn-jegPvoUYIsJGuDbsUZxRbEZsSWx2bG1qeXxTnEFsQ6xwvAZsdWp4frtqdPAWIxdqX3ozalWJGWxWCiVsR2x63o98fOxSoRu4MeJDTCniXbRRdCkcbFg86n7ifCJ6SAsiWbIaIDkIArgwkktYIOxWuBrqXxJZ4lABLSG7AANqbuxQYE2wKRcDEmmcRIMPEkniZxJkgQ0cKGw-6mMeEjx53pKcaI0SqmceJoRNeHObpowrwS5PLRcnK4IEKIodFwYMGKGRDSQaYBpH1AW5G-pcGnXiVvURHHvmDupeADvqXVA-BBQachpd_hnqd-p26mQqHupSGkiSRiJx6mLqeiJKhqYcbpxsYSXsQSpmnFAzl9IuLGVMBFJdXECNHhxcjBpAHCGhGnkIJhp6WyO5H52jKncqcF2QLjVUamIzna3-jFhqsT_ygSkOsQsiY0kkKh8aX-4gmnWdtuYLKmeKk-4QIR6BJQAWSCwgHeg_mEd1Gzxt9AEiQppvGkkafUEajSzcR_6PGkYaeZp3BDwJNxpaGlEaQTASmlvkI-pC6nPqft-NbHQYKZpeADEaXfKuGm1pIxO7mnrqfxJ6gSGCdVgK0AqaQF2amk8qRpp54Su0aLRcCqWAPw60WlcqbFpImlhCDF2e8xwcf8STmlmaQFppGl1QA5p3nE2aUppDmkUvF60AdTJAI52znaIVpCoUEQi4aqRMYK-PpmAGNAYmn-6lPH-aXqMgWkx6Onx1EjoaUppq_DRacJpvKmiabVpSfBtMNlgvmndaS5uLKh1ytp8QCTkPIJxg2l2aWe4XRFdaS5pa2lm3FKoS2nsfqRxOGlFaSD-gBSngS90EAn8iT1pR2l5flHYe2m-8qGgg2wKquQwsqmvlCACdSjt5NXsb2lwVD-G22nXadhpP2k9xBKmW7EDqZCMdakfCVf85A4yHFRJ_rjmfrKJX6m20CBpevzrmhUG8XyFOglQoij9ZNuBaOne_NIcq_CRHkoQd9CcaX-ARbS8sVzeSUKE6f78AQxekRrgFHFP8SM87uC4SuZ6y_ElZujp-n7JmGcEhHb-vDn8VOkF7NK2vdh_LnQ6Vfz-POFIH8mRaQ0eiUSN1oZh07pq8ak0Qe5eatqoYAiCLl40PKQtoVX8m1ri6dkwZNDO-CuURa4WkWqRuC4YrEYUfobqRGaBzR4VQIHaLaLWkKk0GuSKWn7wn5E6hIsucoAaQBs2hoAZ_HjgMylaMBR6sMDs6QyAG_DITjZaA9rc5okAltHoALzpfn6SgENsT2m_qXJUjrpxBN9xlojCvNzQq9ooyqDkZ1Ch6UHED_6p6ZaIvSZUdMf-Zz7B6bzpRLZaEZ70KzTSMUN4mzSZ6ZNxe87InrPu275fthXp2B4EIhVECQC86dnp0NwYAdo2q_ApujpENGAO1MyA9vhN0WVa4hhA5AX2GWF5scomlACJAIqpv5xtEM9pqBCh1gyA4rYe1kPpM-lR6at4uoiuEbS0VOnzNH0Rgen56ZaI6gHwsB3pnZBd6Vrcv9ii0MyArNyx1lRw4GrD6a_co-mEELPpa-kL6bKJ66IDyG8AGJCycf0mwnHxkHKJQGn2aV4k2jbPkSvpA77r6atxVHzOAMHRb9DB-PiM9emt6VRRxIwwEdxsK377ftXsDvqwYI_p3cAQGTjCkWDWjEqs2qRVSKV-EvQSXnFuETwn6mKIxFD64N7pRXL0vtC0sBnOpjnp6-wTtn8uaoTAGf6cTBmAaUxQ8YZbblux6Bmr6ZgZkBnoQLgZpIj-8Ahsbwg8HkkuCLiEdje4cAbMGO0ap2kzcWThOomjifopYqThaODpCkk-2ENY6klHsbDp6EAqEC8eL4wQJKOJo3jobuN4Px6GGaVO_ZHefnPut0nL3M_uP27YQUqMwij2nvTOo265kcXpFO5l7lTuHp4gHmAete4_rvXu367YAOoxNjG16e1hnqRV_JjpohCuYMLpU3EfXl-2VBm9Eb1U0J6QANIxqRmbNGIZETyfHtXpbRFM6ir2pNgRPJIeE5HeEMKpMx4MHvMetJ65bMMexupjHuwerEQJMbWIrunqRO7W-UyuUT-RItDG6qkoV1hUcJHA0ADVEXS2nCkG_MLkm-nhGf9ePpH08fqe6-6mKOYA0iogDN0Z4AyztA_mK2a3bGMg34puUQLmINHRrH2hfcBaQEZgRMBowDzhFwDYCMRI6oxGYJgAIuD5oOgoOqlintaIzCr8APh2-dD8wiu855Fi5tJgNdiP5nzQkUQPiG5sBg6MzmOApLSqWk0uL25aWNbmHNChvHzQcbz5ILIquwACYOaAkgDzeOeRC1ZluBkwobyOgMdU44DHbjtQazw7JiAwGcFZGPaISS4-bHPRTogCYNaIZz7nkTLCamAZwc8ZKsKvGffmlmDLGZfsFHjqbqTYMB6y7ghuk2GZQb7Qj4lkvBgMA0Dqbps0GhmBbhQckxmgHj3QApaowg7CQpm8tKJcArR8YAQGdgD8AMwqLjj8wnSZixkMmXXYNeDqbtcR-xnm1j7EeLxCmeN4fJmimWMqFUA7UDA4o4QcnhiCDipnkd0aYFgQOATu6m5vzGrQZvGjGfaZKkFo0KyZqB5IHh1O92wumSg4WdBMlB_R27yX2IKYRcANSAvY0QBL2DPqg_AwwHjxdDoV4YMGLohzbGIcopnkqXvYvqlvPL9gDpkWyBA45x7OYde2WERn4i_Y6Zk92DWorpmgHrmZHpkSEAWZmRxSqGyeGbrGmcYRwXFnlKrmeajGmUqejZkIEMkAgpnrsUXY7ZmjhKwZc-mgGQO0WBlAwm_Q6kQRMVhE6vTw6jAehfwdBHOZmiQ67hngh2k8eGcEcK5n_DAehSoLmageC_LLmQBphWlrme00YqLGUUkZtA4zgtWAr-lsqO_p_8Cf6ZDpFtq3ypdp6SBipB3pXPakGBgZ0E4KqRgZtRzLiVxIzjj_aVvEOohhCV6JA2mKaT9pw2kcqUyptnZjaWEI7nY91GeA5MhFgcAJNOnsaUZxn2kA1LlxqEGt9hgZ3nEecRPpdakPaUmIkekkkLw8Dvp4WZPpGBlw4Z9hCOECcTRp-nHkWf7wu3rQvuBBCsB3qblxLwkJkC-orGlJ8TWcZ2BGcYTpjnHkWVPpt5noWW_6RHF1cbxZeHGiWXjUmFnSOJRZDFlwhlwZbHZWVgw-OEao3NlJWbjU-rI6Qj7NSYAY3FnO8DpZLRjBce1Jwj7ZGu8eM0lIYGCJFlkVHsVJJHBf6VDpJlm6WY7UHEkbqdwQN4hyaIhph5luWVtJHEFBoI-J1lnmmR3B-UlLSQl2q0wZApBJKl4m0RYQgfgnSW_MtMFXsY7hj8AHCMSp9poIqeHAk8DIqUOI8IhUwRlRpKklmXqpe9ig0b7QkpgzxvjKdKljxsEqJXC3cM9kHLhe0dEq6Crnxhc4OfCq-uZJYCyUoJr6moAMaRWpZ449qWRgObGucRnxcbFNqRGxvalbEHWpDvrA6SMAQ6kWAJepQgjXqaxZ-lnhcLoZ9UHmcbqQanG-5vRpXjEFYNUiOnEgSX-Af9g3GpTp1-RsWVfxsmQcaeb6slnLbO3a41kXWUnx11mOcZNZoOlGoB3s0mqWQlfJ7x4qGQAZ2wlaoPUWn6l6GdRpOXTbfLP6Y-qMiX2eBXEiTkag8HCWoJagvomSvqC-_wGhSWkW7ELngW1gI7hMtrmEzQkDKJjW6F7KGfgJLkEzgfBOo1SY1gBe2x4S_gjZGwnAiXhO4P6g5PBwfVwSRFGw0Nk4nLyJA0BQ2agAMNlz-FWIG1Cs2ezZKaCMULyZbTDc2UzZRwDDXol8HqSqBMN4HWZnSRaAF0kJiEkIrcAi0OaAX_zLjOaAaOF2NKDkxUCQjCjCBQD2AGDyNPBxJvuqCahVWWEqntGRKvVZsSoj5GOqOtnoIoMINCqACduogK5QnNJ0ISrVWRLRptk-0bEqqHYsSurZWIzXhgAgrkzkISpcpZD-PLTZa5B82c8oSOAh2YVQVYiG7vOI9UwV7CPqM5R3VKRxHmZDHHwM-Bkz8OIaOUxEGbk0bknrJErgpNlK4BrZfW6W2brZ-uDzklbZXaQ22fgqIREvwQM2WADnGtsAuUw_qeWwD9baMHcacXytwLbUOwC6KFRwMBr0Qq3AEkk8CTi6vFwihlxsZNANUAHZTVzD8F40ZNDHLDUqo0KT2WTQ1FDALISeRdm-2WZMfa58pK8RZFmp2d5MyUwEGWEMdGrblLnZ2ADeIeTZ1UnWQbsWLODbHmfZIUkU2ZCJhxZTKEXZWtkzgBXZyZ7tCSXZ1tnXHnLqQzibNlgAwSYAOY5AwJplEF3ZHz77iGEisqQD2Zok8XY81L8OjroaiQBg74DdnoEWQY4WAG_Mo9kjAMHU7rxhusPwGKjy2QoIEKwbYAlcaDkx7visYC7D8F6qNqiOiAcILC7s9ItAya7k4gHuTTD6LiHu8YDozkwsT47ZMPsMUlyY3M9A6M64EZiuyz66vn4wE0GBhA0qBCzeID0ohzyMbFdQVEDhaN_8qAmOgDnYCaEO5iysypZsOaQ5GCzP2Z_ZldmmKGq6z1BF2YrADyI9ALrZmNDARBo5k1bl2brZ1x6QsYGqMjlGOWoiJjnW2RY5uyzwZHw5mjmuRJ3ZzohgOZ2gLjmIrGUQcK5-Ofisjq5dzsXY_3GO1NMZeC7D8HMZYAxk0KsZ8tnJrrqZb6yMFHIgugA5AI6uI45UmYlxfDlqLDNZRdlg9J0Q2dkiKURJU5k1gAXZa2hYjC_ZKQBv2erqQB46OaECqcoyli4M3rxeOf7gPdnNoAE5p_xKOC_YoTlrNFnw81kI8UGgHFkEEAWogCQAKWIJ5fyDyEm8tAmgkNvYF3AzObaQ29go0KrxTjldpKeumzpbFrH-iGCliPzYDLRDvPLZUGDd2RasdtSPot6u2TB_2OAovkBIgJOu1VYgWTTpZRAtYCA53jntOTtWEGidOXO2ozlhUXggo7BZAJqOVXEepAYZphnUeJ5JagAmGS_uzZnmGehuIRnjbrYZp3gQ7iGRLhkQnvd47hlEEd70fTn17j4Zh-5IngzudABIKVCkQEJBMNEJmLnRCQSeLpCoAD8OdplgFmKeXpmsDOyZVYgKCCE5pxGWnrtQum40uYhM4m6kuYGZsZnxmaKecDilmQrwQqROmS2ZrpmS8WjQzpmm8W_YgCJq0BUq84Dhma5Sh4ZRmQKYSRzRYbC2UzlFdFdgybjRCYOZt1n6cfzcP1hgsYdh55Fkplq6emAAAL2imdGIPKBxtMUwo4DvMeMAQBaWUv3IijyEnGpg8TnfEpyZsLZzOQgQmLbQNGKeD6yLOVau7w4Q1gagl0R3UD05ZBFzbKmumfhfJrzhpAj4Lvk5w_BkmWdQH_F5tIy5LxEdvJ7c7lHe9vpgha6oCQdUCbkaWG_Uuh6qYH2gGmCvGcO8O-i-jN85PcrS8CDRq1qIxCKZcQRo0J4WBeRThEVcibkloEbAkoBeugWAbrlumfI82oD-wq3ASzk5QLM5um6q1iTu_rnvEEs5E9bxKruEd1CbAPo5KwwxOeXAfbn8QFv631DRqILqkeiF3LU8lADyOHpu-O7NLGO5R7l79EscyZgCbk4sabnkUblASTloFgjAK3JDfuLaRqACbhEsopldzue5sQQUeGMqLbmluc8-AmB9udu5xZqDudhazoCCCF65y_i7uak8-7nRqDAWVq52yMWZ-O654J-5EI7fudsWqyzNPH8Zq1xrGc-56wQgea-MWmpmlBB5uNDkOC1wB7krQK-5mfSIeevuggjnufigcZm6aokAOMCHuYL0BVllmepEQbb4eWUQ4HlinuK5yDgeOH5wXHnDubpufHnMCK6ZnBotmTK5hezp5rfYirkYboscu4Tk6SA5uthYAIx5T7nDGdy5YMqJAIv4LHl5kGx5ArlCRJx5KV4POa_oXrmieYmgIrmCXMZ5wnkGnuZ5RaDieaNU0rlT2HK5snk2qcXE64Z0WSxonuD6uVp5-mptGRJQnnmX4J3ZKnnNjnWZR3SVOfU5jWoDQMAeJB4pAMc0JXEhkGDyp67UTtDqhZnC5El5llIsTtDq7qRkjKhQAblHuby56-55edO5rLmimcs5dkLvEGq53oHhuNEJt15N9No5DyI1OcN0_Wn3ORpKGInXwhMGOrl_gFSxqABq-KBMyBqKCCi56U6wKQHk36TmrNTu36TJebgAjO7jeGN5Dc55TpwA0LnIWXVxRdk1OSdoGXkDiNROxzTJIBt5VJKJANt5Djna2dY5qcphnst5SfEKYH15nInJ4fAY1bks9H85m9mNYH4EV8HsioY2XsogAoLKS3Q72UaMe9lameG5dQpXAKIRNeBFOYV8J9mlOdfZYIne4A15aiJNeUt8kXlV2VCx-xFGIFkUrTlHOQkcyPkbCF05I36QPlEe5xRxhoBpdanjDrxECt6-INFZwyQ5UblJyUhc-lo-N_CLWY5ZRlnIxtOINUieoCU51lk32YtJbhTw2XfZF9nplrZZ82hdSbVJM5l5_qZwrVmqKsr-etEqcZRZsVkTeE9BCVljnElZFSqPUfaaVL72NlB26TEJWBxx9czcMaeWONEiMZeW4qmxUWaOQzhK-Rr5PdScKj7AbHEGtokqzgDJKgVwU8nuzF16WtGhUVJJ30akrF-ZfBmVqYig5mG3yL-ZjzqPmXNp_-kYpDx2jtRpwuvabFYKYG8uYAl4DAK62CqeeXRpYnFacWwggFEokGTQlnSgIJWsPokbhN6I3ORaqRfp9jkJWdjCQML0zl_64lm0aVhOGnGvUGn5SLCp-bEA6flaBpGAVvk2-brJGSrk5Bm--hBv2L-xfOAwCR35EWwDoXmuc9KNYKEArABUcB-x3TyNkHEoIfnxAGH5GAAR-ZgGiLEE6V15DdTh-YCAERH0aT4IkZgB6A9wHWTOAJ2YaPBk6eb6wdGaFkORRe6g5JT2EnEwAPlucfnXsfsx32AeHI1gdNJ00ixxXCqU0aHAEDEjYI_55vnP-fdsepkhPHBxFESMcVDpl_niccJxd5ln-SEokoJ9BMJx-W60WRnx4xhQ6fluXqReWcVpABkuNnBx7dpjmfVqdwDTWb98dQQCGc9gN1kB-gf5cvrdUFsW9vi5yfBAv2hfKtb5KSp2-bc4uxr8iKQFgckKKQ351AXpyc35Uzi7Gqw-31pkBfqUzAW2-awFZri7GlRwDAUdyUwFlAWN-TQF5OQVGkRxhAXoQC26QnhiKbDgo5m4BZgFAakhABbI5fEF-YtghJBYANNu-_k70ZFgcgVH-PJ5dzkyBVrg-3ltEKYFdwCGBTlABwwWBfoFuWDT7noFQMLCVFYFkXhH-PAJJgX2BW6QugUEBV4FrgUUYNgp0gV-BSIWFGAUuf9eIiDlabTeq5kB-Va23mkwBfjccAXVbggFT5kxBWl5W2AKWQNZLN76BfLweFGrWTTpDFn5QBz6zFlmOqg592yq1MQoOuGB0VJgAJ64EXE6nkh0rFL49WnkII1pgbT6WO45qsCJVCpANijYKOUuWchEWj7g6CipBErUCkijLvduoYh9ROnRAb4ULDlxZ7j_CHo578jPUIL4VjFnuCAwc5Qr8CnRRLETVrn8Hqq5_KpabzHUMVpAIYgi8Wg5uTkXqbAFWQTwBdEFSAUobp1YCTEw4fNZVQXn-b_u2WB_-SBMZ_kuKagefMjOgMxpeZQAWSGoGQm8XFUo9zEsYFGGZDFhORR4-wXBAJ8x1W646iBQiQWoHlHY7_kU0THM1phf-fdsVwXHaVuo5jF_BdgAHbrMdsupU-Fo5BR4BjEwdjkxaNE_tthCq7Y74SSFHZBTQAoxW5b8Mfgx2qQ0hccY0Rrb6ZBgkAUwHkJqLIVTACB26Hbk0Rb5X_mEnjyFvJkrppyFqB5mMYu2sjGJtuyFNhAvBZ9I__n9DjWecIUXBdVuv_kKhW8FwnFr5GNZiln4-aQJJ65exnYFzgUGBZF4cHGaSAug6AXwAI3gv6A_BckZHhloucAhofQGhc9geLmZCdvRhfmkcTTpu3qr9NYZYxiyiZoFVoW5YA3pbtDB0beoEYLs9OQwlgUDIDoF63g_6QGFLgUDIPt5sYU1QOoFIYU4wrTpnoVRhdYgPoVjGcmYbwiWhcUWC_m7eiLpHmzDeU5YRACRYPApAboFha6FWNwBhf6FdXHehVie1WABhdROOUDw-r7WePnVMgWF1oWgTPqF9khy-kaFWgWyBaaFKvy2kAC2BYUNhXdZHPolheFmz2beWBWFX1BTuawAE4UH-SiQCDmwtquFO9H7COaAmvYgjouFz2AD_KDmV2JJLl3QN5H1efOAe3hn5kNK2NrfOnyQwdHCtBEUIqz-vuvwCwx-bAJglcC5AfkAr8rJAAaUPgDmgqTsw4C1-PjmM2B3UZHujGTafBEAIdx_uMTZq8Tmgk0KoOZpkI1-NBzDTDSm_k7QRd5RpYUl6bCeofRQRf6-tYVHYWtZRZ783HxZRUDVPB15qxF4hPn0l4Xd0FvINelDgGUU8YHs2BGAatKnhVrASEVigZsmpvxAwXKA_k5lFJhFDvrGQAWFg9j8Reepn6KdgMJFbwjMEAYZI3lVhW8IBEWYfm4YIEyABZaF-BCvBYvcZ_lpkH6eoPpthf4qK2DaRQHBLE7JqgEqPpHV-ZXZCfm-iYfsotAqkfLA_vwjtEK0XxnNgBZ4nPgPhYGErxmDZohgfp5R2B2FvFx-ngmI0_nL-R2sq_lYgZJ08OiFZNv5Z3Bo8EBR18qxCehJhJobWWJxwulsVqfRLGqAUrJ4hmmdeYF5qFkD2KGeoAbiYcEpSfH9Qj-0EnbDQubC2sK-wj8AxYDVADzBP4BvPMpifWK27npSvsLoFgjA9UW-YvAAxh69BYrCc6KQmThAtUU4QPGia8AQICKc7rzyYKDIlUV_AKWAbUUURMuinMAcQG1F8aLObveUI5JlUE9yEkCKwvDAptI4AFoie-JSMJqAisJ2ttrSIsqYwLtFBVJvUStF_ACHRUTAmMA4AObSmFJ7RQPAB0VmQAjAhiqnRZPAYMiPRTrCdrbXRRjK-aj3RRHig8ZPRYYqOiKm0m9FUXApcGlwB0VWahjAm_IKUpH4zPCs8NOSv0oI4pdFU3KGKoOyplKXAc4GX0XPRegWp0UxOK12lnA4xS9FGkAs8PJRDir_RdqOpVnLxjJ5GVKXRVZAhiqvRf9FqTi7QSaO6MLE0eaOz5KrQogASML2Hmoijh4FQGaOru6nRSB0fQBgdPD0B0UMxZtFYMVFenUCtI7Exb9Fp0XTArMCGcpfRRjKLErMxaqadeJfRVLFTMW7ItV68sW-wna2U3IYwH9FuyKtxvyy7cbj5k4ydrYwxbdFp0UK-fNFxMUgxTLFf1FWgAdFR0VW8CdFlOJLMC1Ik0W4AK3KkLgdQdCIikCoii1KSAAPwgXw36x_UXkg_ADyAAoA8gDyAEAAA`} mdxType=\"Playground\">\n  <Map viewport={{\n        center: [0.026, 123.61],\n        zoom: 5\n      }} mdxType=\"Map\" />\n    </Playground>\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"],"sourceRoot":""}