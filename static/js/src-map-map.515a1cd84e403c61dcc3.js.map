{"version":3,"sources":["webpack:///./src/map/glmap/map.css","webpack:///./src/map/lib/Pack.js","webpack:///./src/map/lib/pelagosClient.js","webpack:///./src/map/proptypes/tracks.js","webpack:///./src/map/proptypes/layers.js","webpack:///./src/map/proptypes/shared.js","webpack:///./src/map/config.js","webpack:///./src/map/module/module.actions.js","webpack:///./src/map/module/module.selectors.js","webpack:///./src/map/tracks/tracks.selectors.js","webpack:///./src/map/constants.js","webpack:///./src/map/utils/heatmapTileData.js","webpack:///./src/map/utils/buildEndpoint.js","webpack:///./src/map/heatmap/heatmapTiles.actions.js","webpack:///./src/map/heatmap/heatmap.actions.js","webpack:///./src/map/glmap/viewport.actions.js","webpack:///./src/map/glmap/interaction.actions.js","webpack:///./src/map/utils/map-colors.js","webpack:///./src/map/heatmap/HeatmapSubLayer.js","webpack:///./src/map/heatmap/HeatmapLayer.js","webpack:///./src/map/tracks/TracksLayer.js","webpack:///./src/map/activity/ActivityLayers.js","webpack:///./src/map/activity/ActivityLayers.container.js","webpack:///./src/map/glmap/Map.js","webpack:///./src/map/glmap/Map.container.js","webpack:///./src/map/glmap/style.reducer.js","webpack:///./src/map/utils/getMainGeomType.js","webpack:///./src/map/glmap/style.actions.js","webpack:///./src/map/glmap/viewport.reducer.js","webpack:///./src/map/store/index.js","webpack:///./src/map/tracks/tracks.actions.js","webpack:///./src/map/utils/withReducerTypes.js","webpack:///./src/map/module/module.reducer.js","webpack:///./src/map/tracks/tracks.reducer.js","webpack:///./src/map/heatmap/heatmap.reducer.js","webpack:///./src/map/heatmap/heatmapTiles.reducer.js","webpack:///./src/map/glmap/interaction.reducer.js","webpack:///./src/map/store/reducers.js","webpack:///./src/map/map.js","webpack:///./src/map/basemaps/index.js","webpack:///./src/map/map.mdx"],"names":["module","exports","map","googleLogo","byname","Uint8","size","Uint8Array","BYTES_PER_ELEMENT","array","getter","setter","Int8","Int8Array","Uint16","Uint16Array","Int16","Int16Array","Uint32","Uint32Array","Int32","Int32Array","Float32","Float32Array","Float64","Float64Array","writeStringToArrayBuffer","str","start","end","buf","bufstart","undefined","length","i","charCodeAt","arrayBufferToString","String","fromCharCode","apply","Pack","typemap","byarray","pack","typespec","value","littleendian","ArrayBuffer","DataView","stringToArrayBuffer","res","Uint8ClampedArray","buffer","name","spec","PelagosClient","_classCallCheck","this","MAGIC_COOKIE","url","token","Promise","resolve","reject","request","XMLHttpRequest","open","setRequestHeader","concat","responseType","onload","handleData","bind","onerror","send","self","error","readyState","success","status","isFileUri","response","byteLength","dataView","headerLen","cookie","slice","getInt32","offset","headerIsLoaded","header","JSON","parse","rowLen","colsByName","colidx","cols","col","idx","type","multiplier","min","max","orientation","errorLoading","toString","allLoaded","result","rowidx","row","val","colValues","eval","trackTypes","id","PropTypes","string","isRequired","data","object","color","oneOf","layerTemporalExtents","arrayOf","number","fitBoundsOnLoad","bool","shape","hue","filterValues","endpoints","temporalExtents","temporalExtentsLess","field","values","node","VESSELS_BASE_RADIUS","MAX_SPRITES_PER_LAYER","TILES_URL_NEEDING_AUTHENTICATION","startLoader","dispatch","state","loaderId","timestamp","Date","getTime","payload","onLoadStart","completeLoader","getState","loaders","onLoadComplete","onViewportChange","interactionState","callback","viewport","zoom","center","latitude","longitude","bounds","canZoomIn","canZoomOut","mouseLatLong","setHighlightTemporalExtent","highlightTemporalExtent","getTemporalExtent","temporalExtent","getHighlightTemporalExtent","getGeojsonTracks","createSelector","tracks","filter","t","getGeojsonTracksReady","mergeStyles","style1","style2","sources","_objectSpread","layers","_toConsumableArray","filterGeojsonByTimerange","geojson","_ref","features","featuresFiltered","reduce","filteredFeatures","feature","properties","coordinateProperties","times","filtered","geometry","coordinates","filteredCoordinates","coordinate","index","timeCoordinate","push","filteredFeature","getFullTracksStyles","hasTemporalExtent","hasTracks","timerange","acc","track","source","style","_defineProperty","paint","line-width","line-color","circle-radius","circle-color","getHighlightedTrackStyles","getTracksStyles","trackStyles","highlightedTrackStyles","TRANSITION_TYPE","BRUSH_RENDERING_STYLE","NORMAL","BULLSEYE","BRUSH_ZOOM_RENDERING_STYLE","CUSTOM_LAYERS_SUBTYPES","getTemporalTileURLs","urlTemplate","params","arguments","urls","forEach","extent","urlParams","startTimeISO","toISOString","endTimeISO","tileCoordinates","x","y","z","templateSettings","interpolate","template","urlTemplateCompiled","buildEndpoint","temporalExtentsIndices","indexOf","getTilePromises","tilesetUrl","promises","urlIndex","obtainTile","getCleanVectorArrays","rawTileData","vectorArray","groupData","cleanVectorArrays","columns","currentArray","totalVectorArraysLength","sumBy","a","filteredColumns","column","console","warn","key","cumulatedOffsets","appendValues","set","getTilePlaybackData","prevPlaybackData","tilePlaybackData","zoomFactorRadius","convert","getZoomFactorRadius","zoomFactorRadiusRenderingMode","getZoomFactorRadiusRenderingMode","zoomFactorOpacity","getZoomFactorOpacity","columnsArr","Object","keys","c","storedColumns","sigma","weight","hidden","pull","uniq","numPoints","newFrames","timeIndexes","_loop","point","timeIndex","getOffsetedTimeAtPrecision","datetime","_lngLatToWorld2","_slicedToArray","lngLatToWorld","worldX","worldY","radius","sigmaToRadius","opacity","weightToOpacity","series","frame","addTracksPointsRenderingData","hasFishing","_lngLatToWorld4","getTracksPlaybackData","playbackData","vesselSatisfiesFilters","every","selectVesselsAt","tileData","tileQuery","startIndex","endIndex","currentFilters","vessels","toleranceRadiusInWorldUnits","_loop2","f","_loop3","wx","wy","filters","pass","some","vesselSatisfiesAllFilters","vessel","getTilecoverLimits","viewportZoom","Math","ceil","tilesAvailable","min_zoom","max_zoom","flushToReleaseTiles","heatmapTiles","currentToLoadTileUids","currentTilesToReleaseUids","currentToReleaseTileUids","releaseTiles","markTileAsLoaded","tileUids","flushTileState","forceLoadingAllVisibleTiles","currentVisibleTiles","tilesToLoad","tilesToReleaseUids","currentLoadedTiles","visibleTile","find","uid","loadedTile","tilesToLoadUids","tile","referenceTile","ADD_REFERENCE_TILE","visibleHeatmapLayers","heatmap","heatmapLayers","visibleHeatmapLayersIds","visible","getTiles","updateLoadedTiles","debouncedFlushState","debounce","updateHeatmapTilesFromViewport","mapViewport","width","height","currentTransition","boundsViewport","PerspectiveMercatorViewport","unproject","wn","es","w","s","e","n","boundsPolygonsCoordinates","limits","w1","e2","geom","viewportTilesCoords","tilecover","tiles","viewportTilesIndexes","indexes","visibleTiles","coords","prevZoom","queryHeatmapVessels","temporalExtentIndexes","uids","_queryHeatmap2","_queryHeatmap","layer","isEmpty","isCluster","isMouseCluster","foundVessels","highlightedVessels","layerId","layerPayload","tilesetId","subtype","HIGHLIGHT_VESSELS","clickableCluster","highlightableCluster","clearHighlightedVessels","highlightVesselFromHeatmap","heatmapTiles_actions_objectSpread","UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES","UPDATE_HEATMAP_TILE","getTemporalExtentsVisibleIndices","loadTemporalExtent","currentExtentStart","currentExtentEnd","indices","temporalExtentStart","layerIds","referenceTiles","newTemporalExtentsToLoad","loaderID","join","tilesByLayer","heatmap_actions_toConsumableArray","allPromises","heatmapLayerHeader","_heatmapLayerHeader","heatmap_actions_objectSpread","temporalExtentsIndicesLoaded","queriedTemporalExtentsIndices","visibleTemporalExtentsIndices","temporalExtentsIndicesToLoad","difference","tilePromise","Error","pelagosPromises","allLayerPromises","all","then","loadedLayerId","loadLayerTile","_ref2","parseLayerTile","loadAllTilesForLayer","layersVessels","availableTiles","bestTile","layerVesselsResult","layersVesselsResults","layerVessels","v","uniqBy","updateHeatmapLayers","newLayers","currentLoadTemporalExtent","prevLayersDict","newLayer","prevLayer","interactive","prevLayerId","l","transitionTo","increment","transitionEnd","fitToBounds","vp","fitBounds","minLng","minLat","maxLng","maxLat","padding","getFields","glFeature","fieldsDefinition","metadata","fields","k","fd","fieldKey","pow","area","toLocaleString","maximumFractionDigits","getAreaKm2","def","label","title","isLink","isMain","mainField","getFeature","mapInteraction","interactionType","glFeatures","glGetSource","legacyHeatmapFeature","currentStyle","mapStyle","toJS","event","currentLegacyHeatmapData","count","group","clusterPromises","getStaticLayerIdFromGlFeature","interaction_actions_objectSpread","cluster","clusterPromise","clusterId","cluster_id","glSource","getClusterExpansionZoom","err1","getClusterLeaves","err2","children","childrenFeatures","child","getCluster","autoClusterZoom","clusterBehavior","clusterZoom","zoomIntoVesselCenter","cursor","onClick","onHover","hsvToRgb","h_","s_","v_","h","parseFloat","floor","p","q","mod","r","g","b","round","hueToRgbDefaults","hueToRgbString","rgb","hexToRgb","hex","exec","parseInt","hueIncrementToHue","hueIncrement","wrapHue","HeatmapSubLayer","baseTexture","renderingStyleIndex","useNormalBlendMode","stage","PIXI","particles","ParticleContainer","scale","alpha","position","uvs","blendMode","BLEND_MODES","SCREEN","spritesPool","initialTextureFrame","Rectangle","mainVesselTexture","Texture","_setTextureFrame","clearSpriteProps","spritesProps","spritesPropsCount","destroy","textureFrame","clone","hueToHueIncrement","VESSELS_HUES_INCREMENTS_NUM","update","numProps","resizeSpritesPool","sprite","setTransform","numSprites","delta","toRemove","removeChildAt","toAdd","_addSprites","num","Sprite","anchor","addChild","worldToPixelsSimple","m","HeatmapLayer","React","Component","_build","_destroy","_redraw","nextProps","useRadialGradientStyle","props","setBrushZoomRenderingStyle","_this$props","rootStage","customRenderingStyle","subLayers","renderingStyle","rendering","setBrushRenderingStyle","brushRenderingStyle","toUpperCase","_setBrushRenderingStyleIndex","brushZoomRenderingStyle","_this","cappedZoomRenderingStyle","newStyleIndex","subLayer","setRenderingStyleIndex","_this2","_this$props2","defaultHue","allHuesToRender","currentlyUsedHues","allHues","_createSublayer","_destroySubLayer","_setSubLayersSpritePropsForTile","numFilters","hueToRender","render","_this$props3","viewportLeft","viewportRight","len","fi","scaledX","scaledY","mtx","pixelProjectionMatrix","_ref3","HeatmapLayer_slicedToArray","pitch","worldToPixels","pushSpriteProps","defaultOpacity","defaultSize","removeChild","TracksLayer","Graphics","nativeLines","clear","highlightTemporalExtentIndexes","overInInner","overExtent","drawFishingCircles","fishingCirclesRadius","drawOverTrack","_drawTrack","substr","lineThickness","lineOpacity","prevSeries","prevWorldX","prevWorldY","_ref$worldOffset","worldOffset","circlePoints","lineStyle","duplicateWorld","currentSeries","_worldToPixels2","TracksLayer_slicedToArray","moveTo","abs","atDatelineWorldY","isWestToEast","worldXEnd","atDatelineEndWorldX","atDatelineStartWorldX","_worldToPixels4","x1","y1","lineTo","_worldToPixels6","x2","y2","beginFill","circlesLength","drawCircle","endFill","ActivityLayers","pixiReady","touches","queryCoords","clientX","clientY","heatmapFadingIn","heatmapStage","_heatmapFadeinStep","BaseControl","setState","exportNativeViewport","_context","_updateViewportSize","_this$props$viewport","pixi","transparent","antialias","renderer","canvas","view","container","appendChild","baseTextureCanvas","blurFactor","tplCanvas","document","createElement","tplCtx","getContext","diameter","yCenter","gradient","createRadialGradient","rgbString","addColorStop","rgbOuter","fillStyle","fillRect","beginPath","arc","PI","fill","lineWidth","strokeStyle","stroke","getVesselTexture","fromCanvas","ticker","add","_onTick","viewportWidth","viewportHeight","resize","dim","_viewport$unproject2","ActivityLayers_slicedToArray","wrappedLongitude","heatmapFadeinStartTimestamp","now","timeElapsed","highlightedClickedVessel","highlightLayerData","highlightFilters","ActivityLayers_objectSpread","leftWorldScaled","rightWorldScaled","shouldUseRadialGradientStyle","toggleHeatmapDimming","_startHeatmapFadein","gl","getError","err","log","_this$_getHighlightDa","_getHighlightData","react_default","ref","onMouseMove","onTouchStart","react","heatmap_HeatmapLayer","tracks_TracksLayer","propTypes","func","contextTypes","getHeatmapLayersAsArray","ActivityLayers_container_objectSpread","getTracksWithData","getTemporalExtentIndexes","startTimestamp","endTimestamp","getHighlightTemporalExtentIndexes","connect","ownProps","nativeViewport","topLeftPx","bottomRightPx","topLeftWorld","pixelsToWorld","pixelUnprojectionMatrix","bottomRightWorld","northWest","southEast","north","south","west","east","PopupWrapper","closeButton","onClose","esm","offsetTop","tipSize","closeOnClick","defaultProps","Map","Map_classCallCheck","Map_getPrototypeOf","call","Map_defineProperty","Map_assertThisInitialized","_asyncToGenerator","regenerator_default","mark","_callee","wrap","prev","next","window","__webpack_require__","sent","ResizeObserver","default","_containerResizeObserver","handleResizeObserver","observe","_mapContainerRef","stop","entries","_entries$0$contentRec","contentRect","setViewport","Map_objectSpread","propsViewport","bearing","lngLat","onMapInteraction","glMap","getMap","getSource","isDragging","resourceType","match","headers","Authorization","mouseOver","loadObserver","setBounds","_this$glMap$getBounds","getBounds","_ne","_sw","lat","lng","disconnect","maxZoom","minZoom","onClosePopup","clickPopup","hoverPopup","hasHeatmapLayers","markers","interactiveLayerIds","className","styles","onMouseLeave","onMouseEnter","assign","getRef","transformRequest","onTransitionEnd","getCursor","clickRadius","ActivityLayers_container","Map_PopupWrapper","content","marker","getInteractiveLayerIds","staticLayers","glLayer","glLayerId","getMapStyle","mapStyles","trackLayersIndex","lastIndexOf","finalMapStyles","mergeIn","mapStylesLayers","get","trackLayer","insert","fromJS","interaction","internalCursor","moduleCursor","long","attributions","GL_STYLE","sourceKey","attribution","setLayerStyleDefaults","layout","temporalField","visibility","initialState","cartoLayersInstanciated","basemapLayers","TYPES","geoJSON","INIT_MAP_STYLE","SET_MAP_STYLE","MARK_CARTO_LAYERS_AS_INSTANCIATED","SET_STATIC_LAYERS","SET_BASEMAP_LAYERS","setDefaultVectorTiles","currentSource","refLayerUrl","refLayerUrls","style_actions_objectSpread","style_actions_toConsumableArray","setMapStyle","setStyleTemporalExtent","applyToThrottled","glLayers","currentFilter","getIn","isLegacy","setIn","applyTemporalExtentThrottled","throttle","applyTemporalExtent","updateGLLayer","refLayer","currentStyleLayers","newStyle","glLayerIndex","findIndex","toggleLayerVisibility","isBasemap","refLayerOpacity","labelsVisibility","showLabels","colorPaintProperty","currentGlLayer","glType","defaultStyles","styleType","refLayerStyle","hasFeatures","applyStyleToAllFeatures","allPaintProperties","glPaintProperty","glPaintFinalValue","selectedValue","fallbackValue","paintOrLayout","includes","originalLayerStyle","layerColorRgbString","layerColorRgb","replace","applyLayerExpressions","addCustomGLLayer","tileSize","allGeoJSONTypes","numByGLType","geoJSONType","glTypeMax","getMainGeomType","layerIndex","reverse","splice","instanciateCartoLayers","sourceId","cartoLayersPromises","sourceCartoSQL","mapConfig","options","sql","mapConfigURL","encodeURIComponent","stringify","cartoAnonymousMapUrl","fetch","json","layergroupid","catch","instanciatedCartoLayers","cartoLayer","tilesURL","newSourceId","deleteIn","commitStyleUpdates","bl","currentGLSources","workspaceGLLayers","workspaceGLLayer","finalSource","existingLayerIds","layerToAdd","layerToAddId","sourceLayer","existingLayers","newLayerGroup","newLayerIndex","findLastIndex","updateWorkspaceGLLayers","customLayers","isCustom","glSources","cartoLayersToInstanciate","newSource","cartoLayerInstanciated","DEFAULT_TRANSITION","transitionDuration","transitionInterpolator","FlyToInterpolator","transitionEasing","easeCubic","composeEnhancers","compose","process","MAP_REDUX_REMOTE_DEBUG","REACT_APP_MAP_REDUX_REMOTE_DEBUG","store","createStore","applyMiddleware","thunk","targetMapVessel","fitToBoundsAction","geoBounds","timelineBounds","ADD_TRACK","UPDATE_TRACK","getTrackDataParsed","time","Infinity","getTrackBounds","tbbox","getOldTrackBoundsFormat","addOffset","geo","updateTracks","newTracks","prevTracks","newTrack","trackId","prevTrack","trackHasData","trackHasUrl","cleanData","rawTrackData","statusText","_getTrackDataParsed","finally","withReducerPropTypes","propTypesSchema","reducer","onAttributionsChange","withReducerTypes","instanceOf","action","module_reducer_objectSpread","module_reducer_toConsumableArray","loaderIndex","exact","tracks_reducer_objectSpread","tracks_reducer_toConsumableArray","trackData","removedTrackId","mapReducer","combineReducers","ModuleReducer","TracksReducer","newVisibleTemporalExtentsIndices","indicesRemoved","heatmap_reducer_objectSpread","heatmap_reducer_defineProperty","heatmap_reducer_toConsumableArray","newTile","layerTiles","tileIndex","tileUid","releasedTileIndex","releasedRefTileIndex","newHeatmapLayers","heatmapTiles_reducer_objectSpread","tileUidsMarkedAsLoaded","newMapStyle","glyphsPath","style_reducer_objectSpread","style_reducer_toConsumableArray","viewport_reducer_objectSpread","currentZoom","interaction_reducer_objectSpread","mapReducers","replaceReducer","throttleApplyTemporalExtent","setTemporalExtent","updateViewportFromIncomingProps","incomingViewport","viewportUpdate","MapModule","initialized","errorInfo","prevProps","indicesToAddByLayer","heatmapLayer","oldVisibleTemporalExtentsIndices","indicesAdded","layerIdsWithIndicesToAdd","currentViewport","componentStack","react_redux_es","Map_container","MDXContent","map_map_classCallCheck","map_map_possibleConstructorReturn","map_map_getPrototypeOf","components","_objectWithoutProperties","dist","parentName","href","index_m","__codesandbox","__position","__code","__scope","map_map"],"mappings":"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","file":"static/js/src-map-map.0c715882.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"map\":\"map_map__1CWd_\",\"googleLogo\":\"map_googleLogo__2KshJ\"};","/* eslint-disable */\nvar byname = {\n  Uint8: {\n    size: Uint8Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint8',\n    setter: 'setUint8',\n  },\n  Int8: {\n    size: Int8Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint8',\n    setter: 'setUint8',\n  },\n  Uint16: {\n    size: Uint16Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint16',\n    setter: 'setUint16',\n  },\n  Int16: {\n    size: Int16Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getInt16',\n    setter: 'setInt16',\n  },\n  Uint32: {\n    size: Uint32Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint32',\n    setter: 'setUint32',\n  },\n  Int32: {\n    size: Int32Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getInt32',\n    setter: 'setInt32',\n  },\n  Float32: {\n    size: Float32Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getFloat32',\n    setter: 'setFloat32',\n  },\n  Float64: {\n    size: Float64Array.BYTES_PER_ELEMENT,\n    array: 'Float64Array',\n    getter: 'getFloat64',\n    setter: 'setFloat64',\n  },\n}\n\nvar writeStringToArrayBuffer = function(str, start, end, buf, bufstart) {\n  if (end == undefined) {\n    end = str.length\n  }\n  if (start == undefined) {\n    start = 0\n  }\n  if (bufstart == undefined) {\n    bufstart = start\n  }\n  for (var i = start; i < end; i++) {\n    buf[i - start + bufstart] = str.charCodeAt(i) & 0xff\n  }\n}\n\nvar stringToArrayBuffer = function(str, start, end) {\n  var self = this\n\n  if (end == undefined) {\n    end = str.length\n  }\n  if (start == undefined) {\n    start = 0\n  }\n  var res = new Uint8ClampedArray(end - start)\n  writeStringToArrayBuffer(str, start, end, res, 0)\n  return res.buffer\n}\n\nvar arrayBufferToString = function(buf) {\n  return String.fromCharCode.apply(null, new Uint8Array(buf))\n}\n\nvar pack = function(typespec, value, littleendian) {\n  var array = new ArrayBuffer(typespec.size)\n  new DataView(array)[typespec.setter](0, value, littleendian)\n  return arrayBufferToString(array)\n}\n\nvar Pack = {\n  typemap: {\n    byname: byname,\n    byarray: {},\n  },\n  pack: pack,\n  arrayBufferToString: arrayBufferToString,\n  stringToArrayBuffer: stringToArrayBuffer,\n  writeStringToArrayBuffer: writeStringToArrayBuffer,\n}\nfor (var name in Pack.typemap.byname) {\n  var spec = Pack.typemap.byname[name]\n  spec.name = name\n  Pack.typemap.byarray[spec.array] = spec\n}\n\nexport default Pack\n","/* eslint-disable */\n\nimport Pack from './Pack'\n\nclass PelagosClient {\n  constructor() {\n    this.MAGIC_COOKIE = 'tmtx'\n  }\n\n  obtainTile(url, token) {\n    return new Promise(\n      function(resolve, reject) {\n        this.request = null\n        if (typeof XMLHttpRequest != 'undefined') {\n          this.request = new XMLHttpRequest()\n        } else {\n          throw 'XMLHttpRequest is disabled'\n        }\n        this.resolve = resolve\n        this.reject = reject\n        this.request.open('GET', url, true)\n        if (token) {\n          this.request.setRequestHeader('Authorization', `Bearer ${token}`)\n        }\n        this.request.responseType = 'arraybuffer'\n        this.request.onload = this.handleData.bind(this)\n        this.request.onerror = this.handleData.bind(this)\n        this.request.send(null)\n      }.bind(this)\n    )\n  }\n\n  handleData() {\n    var self = this\n    if (!this.request) {\n      return\n    }\n    if (this.error) {\n      return true\n    }\n\n    if (this.request.readyState == 4) {\n      /* HTTP reports success with a 200 status. The file protocol\n       reports success with zero. HTTP returns zero as a status\n       code for forbidden cross domain requests.\n       https://developer.mozilla.org/En/Using_XMLHttpRequest */\n      var success = this.request.status == 200 || (this.isFileUri && this.request.status == 0)\n      if (!success) {\n        this.resolve(null)\n        return\n      }\n    }\n\n    if (!this.request.response) {\n      return\n    }\n    var length = this.request.response.byteLength\n    var response = this.request.response\n    var dataView = new DataView(response)\n\n    if (length < 4 + 4) {\n      return\n    }\n    if (self.headerLen == null) {\n      var cookie = Pack.arrayBufferToString(response.slice(0, 4))\n      if (cookie != this.MAGIC_COOKIE) {\n        this.reject(\n          'Could not load ' +\n            this.url +\n            ' due to incorrect file format. Cookie: [' +\n            this.cookie +\n            ']'\n        )\n        return\n      }\n\n      self.headerLen = dataView.getInt32(4, true)\n\n      self.offset = 4 + 4\n    }\n    if (length < self.offset + self.headerLen) {\n      return\n    }\n    if (!self.headerIsLoaded) {\n      self.header = JSON.parse(\n        Pack.arrayBufferToString(response.slice(self.offset, self.offset + self.headerLen))\n      )\n      self.rowLen = 0\n      self.header.colsByName = {}\n      for (var colidx = 0; colidx < self.header.cols.length; colidx++) {\n        var col = self.header.cols[colidx]\n        col.idx = colidx\n        self.header.colsByName[col.name] = col\n        col.typespec = Pack.typemap.byname[col.type]\n\n        if (col.multiplier != undefined && col.min != undefined) {\n          col.min = col.min * col.multiplier\n        }\n        if (col.offset != undefined && col.min != undefined) {\n          col.min = col.min + col.offset\n        }\n        if (col.multiplier != undefined && col.max != undefined) {\n          col.max = col.max * col.multiplier\n        }\n        if (col.offset != undefined && col.max != undefined) {\n          col.max = col.max + col.offset\n        }\n\n        self.rowLen += col.typespec.size\n      }\n      self.offset += self.headerLen\n\n      // Add the padding to nearest 4-byte-boundary\n      self.offset += (4 - (self.headerLen % 4)) % 4\n\n      self.headerIsLoaded = true\n      if (self.header.orientation != 'rowwise' && self.header.orientation != 'columnwise') {\n        self.errorLoading({\n          orientation: self.header.orientation,\n          toString: function() {\n            return (\n              'Could not load ' +\n              this.url +\n              ' due to unsupported file orientation. Orientation: ' +\n              this.orientation +\n              '. Supported orientations: rowwise, columnwise.'\n            )\n          },\n        })\n        return true\n      }\n\n      // Empty tile, stop parsing.\n      if (!self.rowLen) {\n        self.allLoaded()\n        return true\n      }\n    }\n    if (self.header.orientation == 'rowwise') {\n      var result = {}\n      for (; self.offset + self.rowLen <= length; self.rowidx++) {\n        var row = {}\n        for (var colidx = 0; colidx < self.header.cols.length; colidx++) {\n          var col = self.header.cols[colidx]\n          var val = dataView[col.typespec.getter](self.offset, true)\n          row[col.name] = val\n          self.offset += col.typespec.size\n        }\n        // self.rowLoaded(row);\n\n        result[col.name] = row\n      }\n      if (self.rowidx == self.header.length) {\n        // self.allLoaded();\n        this.resolve(result)\n      } else {\n        // self.batchLoaded();\n      }\n    } else if (self.header.orientation == 'columnwise') {\n      var colValues = null\n      var result = {}\n      if (length >= self.offset + self.header.length * self.rowLen) {\n        for (var colidx = 0; colidx < self.header.cols.length; colidx++) {\n          var col = self.header.cols[colidx]\n\n          colValues = new (eval(col.typespec.array))(\n            response.slice(self.offset, self.offset + col.typespec.size * self.header.length)\n          )\n          self.offset += self.header.length * col.typespec.size\n\n          result[col.name] = colValues\n        }\n\n        // self.allLoaded();\n        this.resolve(result)\n        return true\n      }\n    }\n  }\n}\n\nexport default PelagosClient\n","import PropTypes from 'prop-types'\n\nexport const trackTypes = {\n  id: PropTypes.string.isRequired,\n  url: PropTypes.string,\n  data: PropTypes.object,\n  color: PropTypes.string,\n  type: PropTypes.oneOf(['geojson', 'pelagos', undefined]),\n  layerTemporalExtents: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.number)),\n  fitBoundsOnLoad: PropTypes.bool,\n}\n","import PropTypes from 'prop-types'\n\nexport const heatmapLayerTypes = {\n  id: PropTypes.string.isRequired,\n  tilesetId: PropTypes.string,\n  subtype: PropTypes.string,\n  visible: PropTypes.bool,\n  hue: PropTypes.number,\n  opacity: PropTypes.number,\n  filters: PropTypes.arrayOf(\n    PropTypes.shape({\n      // hue overrides layer hue if set\n      hue: PropTypes.number,\n      // filterValues is a dictionary in which each key is a filterable field,\n      // and values is an array of all possible values (OR filter)\n      // ie: filterValues: { category: [5, 6] }\n      filterValues: PropTypes.object,\n    })\n  ),\n  header: PropTypes.shape({\n    endpoints: PropTypes.object,\n    colsByName: PropTypes.object,\n    temporalExtents: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.number)),\n    temporalExtentsLess: PropTypes.bool,\n  }).isRequired,\n  interactive: PropTypes.bool,\n}\n\nexport const basemapLayerTypes = {\n  id: PropTypes.string,\n  visible: PropTypes.bool,\n}\n\nexport const staticLayerTypes = {\n  id: PropTypes.string.isRequired,\n  // TODO MAP MODULE Is that needed and if so why\n  visible: PropTypes.bool,\n  selected: PropTypes.bool,\n  selectedFeatures: PropTypes.shape({\n    field: PropTypes.string,\n    values: PropTypes.arrayOf(PropTypes.string),\n  }),\n  highlighted: PropTypes.bool,\n  higlightedFeatures: PropTypes.shape({\n    field: PropTypes.string,\n    values: PropTypes.arrayOf(PropTypes.string),\n  }),\n  opacity: PropTypes.number,\n  color: PropTypes.string,\n  showLabels: PropTypes.bool,\n  interactive: PropTypes.bool,\n  filters: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.string)),\n  isCustom: PropTypes.bool,\n  subtype: PropTypes.oneOf([undefined, 'geojson', 'raster']),\n  url: PropTypes.string,\n  data: PropTypes.object,\n  gl: PropTypes.object,\n}\n","import PropTypes from 'prop-types'\n\nexport const popupTypes = {\n  content: PropTypes.node,\n  latitude: PropTypes.number.isRequired,\n  longitude: PropTypes.number.isRequired,\n}\n\nexport const viewportTypes = {\n  zoom: PropTypes.number,\n  center: PropTypes.arrayOf(PropTypes.number),\n}\n","// Application settings\nexport const TIMELINE_STEP = 24 * 60 * 60 * 1000 // 1 day\nexport const MIN_FRAME_LENGTH_MS = TIMELINE_STEP // 1 day\n\n// vessels rendering\n// from this zoom level and above, render using circle style instead of heatmap\nexport const VESSELS_RADIAL_GRADIENT_STYLE_ZOOM_THRESHOLD = 6\n// the base radius, it can only be scaled down by the radius factor calculated on the dataset\nexport const VESSELS_BASE_RADIUS = 8\n// in heatmap style, defines how 'blurry' a point will look. Higher = less blur\nexport const VESSELS_HEATMAP_BLUR_FACTOR = 0.15\n\nexport const ACTIVITY_HIGHLIGHT_HUE = 312\n\nexport const VESSELS_HEATMAP_DIMMING_ALPHA = 0.5\n\nexport const TRACKS_DOTS_STYLE_ZOOM_THRESHOLD = 2\n\nexport const MAX_SPRITES_PER_LAYER = 200000\n\n// interaction\n// radius of vessels lookup in pixels,\n// ie how large the clicked region should be for including vessels\nexport const VESSEL_CLICK_TOLERANCE_PX = 10\n\nexport const CLUSTER_CLICK_ZOOM_INCREMENT = 1\n\nexport const MIN_ZOOM_LEVEL = 1\n// user can zoom up to this z level, but it doesn't guarantee availability of tiles\nexport const MAX_ZOOM_LEVEL = 14\n\n// data\n// Limit tile loading for activity layers up to this z level.\n// Beyond, layer is still displayed but with coarse data from the lower zoom level\nexport const ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING = 10\n\n// Sets what should be the discrete zoom level to load tiles, from a non-discrete\n// viewport zoom values. For instance, a values of 0.5 will load z 3 with a viewport\n// z of 2 (ceiling of 2 + 0.5)\n// this has a direct impact on the number of points displayed on the map, thus on the\n// performance of the app.\nexport const TILES_LOAD_ZOOM_OFFSET = 0.5\n\nexport const STATIC_LAYERS_CARTO_ENDPOINT =\n  'https://carto.globalfishingwatch.org/user/admin/api/v1/map?config=$MAPCONFIG'\nexport const STATIC_LAYERS_CARTO_TILES_ENDPOINT =\n  'https://carto.globalfishingwatch.org/user/admin/api/v1/map/$LAYERGROUPID/{z}/{x}/{y}.mvt'\n\nexport const TRACKS_LAYER_IN_FRONT_OF_GROUP = 'temporal'\n\nexport const TILES_URL_NEEDING_AUTHENTICATION = 'dot-world-fishing'\n","export const INIT_MODULE = 'INIT_MODULE'\nexport const SET_TEMPORAL_EXTENT = 'SET_TEMPORAL_EXTENT'\nexport const SET_HIGHLIGHT_TEMPORAL_EXTENT = 'SET_HIGHLIGHT_TEMPORAL_EXTENT'\nexport const START_LOADER = 'START_LOADER'\nexport const COMPLETE_LOADER = 'COMPLETE_LOADER'\nexport const SET_MODULE_CURSOR = 'SET_MODULE_CURSOR'\n\nexport const initModule = (props) => (dispatch) => {\n  dispatch({\n    type: INIT_MODULE,\n    payload: props,\n  })\n}\n\nexport const startLoader = (dispatch, state, loaderId) => {\n  const timestamp = new Date().getTime()\n  const generatedLoaderId = loaderId !== undefined ? `${loaderId}_${timestamp}` : timestamp\n  dispatch({\n    type: START_LOADER,\n    payload: generatedLoaderId,\n  })\n  if (state.map.module.onLoadStart !== undefined) {\n    state.map.module.onLoadStart()\n  }\n  return loaderId\n}\n\nexport const completeLoader = (loaderId) => (dispatch, getState) => {\n  dispatch({\n    type: COMPLETE_LOADER,\n    payload: loaderId,\n  })\n  const state = getState()\n  const loaders = state.map.module.loaders\n  if (!loaders.length && state.map.module.onLoadComplete !== undefined) {\n    state.map.module.onLoadComplete()\n  }\n}\n\nexport const onViewportChange = (interactionState) => (dispatch, getState) => {\n  const state = getState()\n  const callback = state.map.module.onViewportChange\n\n  if (callback === undefined) {\n    return\n  }\n  const viewport = state.map.viewport\n\n  callback({\n    interactionState,\n    zoom: viewport.viewport.zoom,\n    center: [viewport.viewport.latitude, viewport.viewport.longitude],\n    bounds: viewport.bounds,\n    canZoomIn: viewport.canZoomIn,\n    canZoomOut: viewport.canZoomOut,\n    mouseLatLong: viewport.mouseLatLong,\n  })\n}\n\nexport const setTemporalExtent = (temporalExtent) => ({\n  type: SET_TEMPORAL_EXTENT,\n  payload: temporalExtent,\n})\n\nexport const setHighlightTemporalExtent = (highlightTemporalExtent) => ({\n  type: SET_HIGHLIGHT_TEMPORAL_EXTENT,\n  payload: highlightTemporalExtent,\n})\n\nexport const closePopup = () => (dispatch, getState) => {\n  const state = getState()\n  if (state.map.module.onClosePopup !== undefined) {\n    state.map.module.onClosePopup()\n  }\n}\n\nexport const setCursor = (cursor) => ({\n  type: SET_MODULE_CURSOR,\n  payload: cursor,\n})\n","export const getTemporalExtent = (state) => state.map.module.temporalExtent\n\nexport const getHighlightTemporalExtent = (state) => state.map.module.highlightTemporalExtent\n","import { createSelector } from 'reselect'\nimport { getTemporalExtent, getHighlightTemporalExtent } from '../module/module.selectors'\n\nexport const getTracksData = (state) => state.map.tracks.data\nexport const getGeojsonTracks = createSelector(\n  getTracksData,\n  (tracks) => tracks.filter((t) => t.type === 'geojson')\n)\nexport const getGeojsonTracksReady = createSelector(\n  getGeojsonTracks,\n  (tracks) => tracks.filter((t) => t.data !== undefined)\n)\n\nconst mergeStyles = (style1, style2) => ({\n  sources: { ...style1.sources, ...style2.sources },\n  layers: [...style1.layers, ...style2.layers],\n})\n\nconst filterGeojsonByTimerange = (geojson, { start, end }) => {\n  if (!geojson || !geojson.features) return null\n  const featuresFiltered = geojson.features.reduce((filteredFeatures, feature) => {\n    const hasTimes =\n      feature.properties &&\n      feature.properties.coordinateProperties &&\n      feature.properties.coordinateProperties.times &&\n      feature.properties.coordinateProperties.times.length > 0\n    if (hasTimes) {\n      const filtered = feature.geometry.coordinates.reduce(\n        (filteredCoordinates, coordinate, index) => {\n          const timeCoordinate = feature.properties.coordinateProperties.times[index]\n          const isInTimeline = timeCoordinate >= start && timeCoordinate <= end\n          if (isInTimeline) {\n            filteredCoordinates.coordinates.push(coordinate)\n            filteredCoordinates.times.push(timeCoordinate)\n          }\n          return filteredCoordinates\n        },\n        { coordinates: [], times: [] }\n      )\n      if (!filtered.coordinates.length) return filteredFeatures\n\n      const filteredFeature = {\n        ...feature,\n        geometry: {\n          ...feature.geometry,\n          coordinates: filtered.coordinates,\n        },\n        properties: {\n          ...feature.properties,\n          coordinateProperties: {\n            times: filtered.times,\n          },\n        },\n      }\n      filteredFeatures.push(filteredFeature)\n    }\n    return filteredFeatures\n  }, [])\n  const geojsonFiltered = {\n    ...geojson,\n    features: featuresFiltered,\n  }\n  return geojsonFiltered\n}\n\nconst getFullTracksStyles = createSelector(\n  [getTemporalExtent, getGeojsonTracksReady],\n  (temporalExtent, tracks) => {\n    const hasTemporalExtent = temporalExtent && temporalExtent.length > 0\n    const hasTracks = tracks && tracks.length > 0\n    if (!hasTemporalExtent || !hasTracks) return null\n\n    const timerange = {\n      start: temporalExtent[0].getTime(),\n      end: temporalExtent[1].getTime(),\n    }\n    const styles = tracks.reduce(\n      (acc, track) => {\n        if (!track.data) return acc\n\n        const source = `${track.id}Track`\n        const style = {\n          sources: {\n            [source]: {\n              type: 'geojson',\n              data: filterGeojsonByTimerange(track.data, timerange),\n            },\n          },\n          layers: [\n            {\n              id: `${track.id}Lines`,\n              source,\n              type: 'line',\n              paint: {\n                'line-width': 1,\n                'line-color': track.color,\n              },\n            },\n            {\n              id: `${track.id}Points`,\n              source,\n              type: 'circle',\n              filter: ['match', ['geometry-type'], ['', 'Point'], true, false],\n              paint: {\n                'circle-radius': 4,\n                'circle-color': track.color,\n              },\n            },\n          ],\n        }\n        return mergeStyles(acc, style)\n      },\n      { sources: {}, layers: [] }\n    )\n    return styles\n  }\n)\n\nconst getHighlightedTrackStyles = createSelector(\n  [getHighlightTemporalExtent, getGeojsonTracksReady],\n  (highlightTemporalExtent, tracks) => {\n    const hasTemporalExtent = highlightTemporalExtent && highlightTemporalExtent.length > 0\n    const hasTracks = tracks && tracks.length > 0\n    if (!hasTemporalExtent || !hasTracks) return null\n\n    const timerange = {\n      start: highlightTemporalExtent[0].getTime(),\n      end: highlightTemporalExtent[1].getTime(),\n    }\n    const styles = tracks.reduce(\n      (acc, track) => {\n        if (!track.data) return acc\n\n        const source = `${track.id}HighlightedTrack`\n        const style = {\n          sources: {\n            [source]: {\n              type: 'geojson',\n              data: filterGeojsonByTimerange(track.data, timerange),\n            },\n          },\n          layers: [\n            {\n              id: `${track.id}HighlightedLines`,\n              source,\n              type: 'line',\n              paint: {\n                'line-width': 1,\n                'line-color': '#fff',\n              },\n            },\n          ],\n        }\n        return mergeStyles(acc, style)\n      },\n      { sources: {}, layers: [] }\n    )\n    return styles\n  }\n)\n\nexport const getTracksStyles = createSelector(\n  [getFullTracksStyles, getHighlightedTrackStyles],\n  (trackStyles, highlightedTrackStyles) => {\n    if (!highlightedTrackStyles) return trackStyles\n    return mergeStyles(trackStyles, highlightedTrackStyles)\n  }\n)\n","export const GL_TRANSPARENT = 'rgba(0,0,0,0)'\n\nexport const TRANSITION_TYPE = {\n  ZOOM: 'ZOOM',\n}\n\nexport const ENCOUNTERS = 'Encounters'\n\nexport const BRUSH_RENDERING_STYLE = {\n  NORMAL: 0,\n  BULLSEYE: 2,\n}\n\nexport const BRUSH_ZOOM_RENDERING_STYLE = {\n  RADIAL_GRADIENT: 0,\n  CIRCLE: 1,\n}\n\nexport const POLYGON_LAYERS_AREA = 'POLYGON_LAYERS_AREA'\n\nexport const CUSTOM_LAYERS_SUBTYPES = {\n  geojson: 'geojson',\n  raster: 'raster',\n}\n","import pull from 'lodash/pull'\nimport uniq from 'lodash/uniq'\nimport sumBy from 'lodash/sumBy'\nimport { lngLatToWorld } from 'viewport-mercator-project'\nimport convert from '@globalfishingwatch/map-convert'\nimport buildEndpoint from './buildEndpoint'\nimport PelagosClient from '../lib/pelagosClient'\n\n/**\n * Generates the URLs to load vessel track data for a tile\n *\n * @param {string} tilesetUrl       the tileset base URL\n * @param {array} temporalExtents   all tileset temporal extents\n * @param {object} params           - tileCoordinates: this tiles tile coordinates (zoom, x, y). Will default to 0,0,0\n *                                  - temporalExtentsIndices: restrict to these temporalExtents indices\n * @returns {Array}                 an array of URLs for this tile\n */\nconst getTemporalTileURLs = (urlTemplate, temporalExtents, params = {}) => {\n  const urls = []\n\n  ;(temporalExtents || [null]).forEach((extent, index) => {\n    const urlParams = {}\n    if (extent !== null && params.temporalExtentsLess !== true) {\n      urlParams.startTimeISO = new Date(extent[0]).toISOString()\n      urlParams.endTimeISO = new Date(extent[1]).toISOString()\n    }\n    if (params.tileCoordinates) {\n      urlParams.x = params.tileCoordinates.x\n      urlParams.y = params.tileCoordinates.y\n      urlParams.z = params.tileCoordinates.zoom\n    }\n\n    const url = buildEndpoint(urlTemplate, urlParams)\n\n    if (\n      params.temporalExtentsLess === true ||\n      !params.temporalExtentsIndices ||\n      params.temporalExtentsIndices.indexOf(index) > -1\n    ) {\n      urls.push(url)\n    }\n  })\n  return urls\n}\n\n/**\n * See getTemporalTileURLs.\n */\nexport const getTilePromises = (tilesetUrl, token, temporalExtents, params = {}) => {\n  const promises = []\n  const urls = getTemporalTileURLs(tilesetUrl, temporalExtents, params)\n  for (let urlIndex = 0, length = urls.length; urlIndex < length; urlIndex++) {\n    promises.push(new PelagosClient().obtainTile(urls[urlIndex], token))\n  }\n\n  return promises\n}\n\nexport const getCleanVectorArrays = (rawTileData) =>\n  rawTileData.filter((vectorArray) => vectorArray !== null)\n\n/**\n * As data will come in multiple arrays (1 per API query/year basically), they need to be merged here\n *\n * @param cleanVectorArrays an array of objects containing a Float32Array for each vessel param (lat, lon, weight...)\n * @param columns the keys to pick on the vectorArrays (lat, lon, weight, etc)\n * @returns an object containing a Float32Array for each API_RETURNED_KEY (lat, lon, weight, etc)\n */\nexport const groupData = (cleanVectorArrays, columns) => {\n  const data = {}\n\n  const totalVectorArraysLength = sumBy(cleanVectorArrays, (a) => a.longitude.length)\n\n  const filteredColumns = columns.filter((column) => {\n    if (cleanVectorArrays[0] && cleanVectorArrays[0][column] === undefined) {\n      console.warn(`column ${column} is present in layerHeader.colsByName but not in tile data`)\n      return false\n    }\n    return true\n  })\n\n  filteredColumns.forEach((key) => {\n    data[key] = new Float32Array(totalVectorArraysLength)\n  })\n\n  let currentArray\n  let cumulatedOffsets = 0\n\n  const appendValues = (key) => {\n    data[key].set(currentArray[key], cumulatedOffsets)\n  }\n\n  for (let index = 0, length = cleanVectorArrays.length; index < length; index++) {\n    currentArray = cleanVectorArrays[index]\n    filteredColumns.forEach(appendValues)\n    cumulatedOffsets += currentArray.longitude.length\n  }\n  return data\n}\n\n/**\n * Converts Vector Array data to Playback format and stores it locally.\n * The data structure is an array indexed by a time unit, ie a set of points every day\n * This preprocessing step allows playback to play smoothly as the necessary conversions and data structure set up\n * is done once (after tile has been loaded)\n *\n * @param data the source data before indexing by day, an object containing\n *  - a vector (Float32Array) for each header's column in the case of Pelagos tiles\n *  - an array of points int the case of PBF tiles\n * @param colsByName the columns present on the dataset, determined by tileset headers\n * @param tileCoordinates x, y, z\n * @param prevPlaybackData an optional previously loaded tilePlaybackData array (when adding time range)\n */\nexport const getTilePlaybackData = (data, colsByName, tileCoordinates, prevPlaybackData) => {\n  const tilePlaybackData = prevPlaybackData === undefined ? [] : prevPlaybackData\n\n  const zoom = tileCoordinates.zoom\n  const zoomFactorRadius = convert.getZoomFactorRadius(zoom)\n  const zoomFactorRadiusRenderingMode = convert.getZoomFactorRadiusRenderingMode(zoom)\n  const zoomFactorOpacity = convert.getZoomFactorOpacity(zoom)\n\n  // store all available columns as object keys\n  const columns = {}\n  const columnsArr = Object.keys(colsByName)\n  columnsArr.forEach((c) => {\n    columns[c] = true\n  })\n\n  // columns specified by layer header columns\n  let storedColumns = [].concat(columnsArr)\n  if (columns.sigma === true) storedColumns.push('radius')\n  if (columns.weight === true) storedColumns.push('opacity')\n  if (columns.longitude === true) {\n    storedColumns.push('worldX')\n    storedColumns.push('worldY')\n  }\n  if (columns.id === true) {\n    storedColumns.push('series')\n  }\n\n  // omit values that will be transformed before being stored to playback data (ie lat -> worldY)\n  // only if hidden: true flag is set on header\n  ;['latitude', 'longitude', 'datetime'].forEach((col) => {\n    if (colsByName[col] === undefined || colsByName[col].hidden === true) {\n      pull(storedColumns, col)\n    }\n  })\n  // always pull sigma and weight\n  pull(storedColumns, 'sigma', 'weight')\n  storedColumns = uniq(storedColumns)\n\n  const numPoints = data.latitude.length\n\n  const newFrames = {}\n  const timeIndexes = []\n  for (let index = 0, length = numPoints; index < length; index++) {\n    let point = {}\n    columnsArr.forEach((c) => {\n      point[c] = data[c][index]\n    })\n\n    const timeIndex = columns.timeIndex\n      ? point.timeIndex\n      : convert.getOffsetedTimeAtPrecision(point.datetime)\n\n    // FIXME: this should not be done when headers declare worldX/Y -  if (!columns.worldX) {\n    const [worldX, worldY] = lngLatToWorld([point.longitude, point.latitude], 1)\n    point.worldX = worldX\n    point.worldY = worldY\n\n    if (columns.sigma) {\n      point.radius = convert.sigmaToRadius(\n        point.sigma,\n        zoomFactorRadiusRenderingMode,\n        zoomFactorRadius\n      )\n    }\n    if (columns.weight) {\n      point.opacity = convert.weightToOpacity(point.weight, zoomFactorOpacity)\n    }\n    if (columns.id) {\n      point.series = point.id\n    }\n\n    if (!newFrames[timeIndex]) {\n      timeIndexes.push(timeIndex)\n      const frame = {}\n      storedColumns.forEach((column) => {\n        frame[column] = [point[column]]\n      })\n      newFrames[timeIndex] = frame\n      continue\n    }\n    const frame = newFrames[timeIndex]\n    storedColumns.forEach((column) => {\n      frame[column].push(point[column])\n    })\n  }\n\n  // finally, copy new frames to the overall tilePlaybackData object\n  // frames previously existing here will be overwritten\n  timeIndexes.forEach((timeIndex) => {\n    tilePlaybackData[timeIndex] = newFrames[timeIndex]\n  })\n  return tilePlaybackData\n}\n\nexport const addTracksPointsRenderingData = (data) => {\n  data.hasFishing = []\n  data.worldX = []\n  data.worldY = []\n\n  for (let index = 0, length = data.weight.length; index < length; index++) {\n    const [worldX, worldY] = lngLatToWorld([data.longitude[index], data.latitude[index]], 1)\n    data.worldX[index] = worldX\n    data.worldY[index] = worldY\n    data.hasFishing[index] = data.weight[index] > 0\n  }\n  return data\n}\n\n/**\n * A simplified version of getTilePlaybackData for tracks\n * Converts Vector Array data to Playback format (organized by days) and stores it locally\n * @param vectorArray the source data before indexing by day\n */\nexport const getTracksPlaybackData = (vectorArray) => {\n  const playbackData = []\n\n  for (let index = 0, length = vectorArray.series.length; index < length; index++) {\n    const datetime = vectorArray.datetime[index]\n    const timeIndex = convert.getOffsetedTimeAtPrecision(datetime)\n\n    if (!playbackData[timeIndex]) {\n      const frame = {\n        worldX: [vectorArray.worldX[index]],\n        worldY: [vectorArray.worldY[index]],\n        series: [vectorArray.series[index]],\n        hasFishing: [vectorArray.hasFishing[index]],\n      }\n      playbackData[timeIndex] = frame\n      continue\n    }\n    const frame = playbackData[timeIndex]\n    frame.worldX.push(vectorArray.worldX[index])\n    frame.worldY.push(vectorArray.worldY[index])\n    frame.series.push(vectorArray.series[index])\n    frame.hasFishing.push(vectorArray.hasFishing[index])\n  }\n  return playbackData\n}\n\nexport const vesselSatisfiesFilters = (frame, index, filterValues) => {\n  const satisfiesFilters = Object.keys(filterValues).every((field) => {\n    if (frame[field] === undefined) {\n      // this field is not available on this layer. This can happen in an edge case described\n      // here: https://github.com/GlobalFishingWatch/map-client/issues/661#issuecomment-334496469\n      return false\n    }\n    return filterValues[field].indexOf(frame[field][index]) > -1\n  })\n  return satisfiesFilters\n}\n\nconst vesselSatisfiesAllFilters = (frame, index, filters) => {\n  const satisfiesAllFilters = filters\n    .filter((f) => f.pass !== true)\n    .some((filter) => vesselSatisfiesFilters(frame, index, filter.filterValues))\n  return satisfiesAllFilters\n}\n\nexport const selectVesselsAt = (tileData, tileQuery, startIndex, endIndex, currentFilters) => {\n  const vessels = []\n\n  const { worldX, worldY, toleranceRadiusInWorldUnits } = tileQuery\n\n  for (let f = startIndex; f < endIndex; f++) {\n    const frame = tileData[f]\n    if (frame === undefined) continue\n    for (let i = 0; i < frame.worldX.length; i++) {\n      const wx = frame.worldX[i]\n      const wy = frame.worldY[i]\n\n      if (\n        (!currentFilters.length || vesselSatisfiesAllFilters(frame, i, currentFilters)) &&\n        wx >= worldX - toleranceRadiusInWorldUnits &&\n        wx <= worldX + toleranceRadiusInWorldUnits &&\n        wy >= worldY - toleranceRadiusInWorldUnits &&\n        wy <= worldY + toleranceRadiusInWorldUnits\n      ) {\n        const vessel = {}\n\n        Object.keys(frame).forEach((key) => {\n          vessel[key] = frame[key][i]\n        })\n        vessel.timeIndex = f\n        vessels.push(vessel)\n      }\n    }\n  }\n  return vessels\n}\n\n/*\nexport const getHistogram = (tiles, propName = 'weight') => {\n  let data = tiles\n    .filter(tile => tile.ready)\n    .map(tile => tile.data\n      .map(frame => frame[propName]));\n  data = flattenDeep(data);\n  if (data.length) {\n    const bins = d3.histogram().thresholds(d3.thresholdScott)(data);\n    const x = d3.scaleLinear().domain([0, d3.max(bins, d => d.length)]).range([0, 50]);\n    console.table(bins.filter(bin => bin.length).map((bin) => {\n      const binMin = d3.min(bin).toLocaleString({ maximumFractionDigits: 2 });\n      const binMax = d3.max(bin).toLocaleString({ maximumFractionDigits: 2 });\n      return {\n        range: [binMin, binMax].join(''),\n        bars: Array(Math.round(x(bin.length))).join(''),\n        num: bin.length\n      };\n    }));\n  }\n};\n*/\n","import template from 'lodash/template'\nimport templateSettings from 'lodash/templateSettings'\n\nexport default (urlTemplate, urlParams) => {\n  templateSettings.interpolate = /{{([\\s\\S]+?)}}/g\n  const urlTemplateCompiled = template(urlTemplate)\n  return urlTemplateCompiled(urlParams)\n}\n","import tilecover from '@mapbox/tile-cover/index'\nimport debounce from 'lodash/debounce'\nimport { PerspectiveMercatorViewport } from 'viewport-mercator-project'\nimport { ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING, TILES_LOAD_ZOOM_OFFSET } from '../config'\nimport {\n  getTile,\n  releaseTiles,\n  highlightVesselFromHeatmap,\n  updateLoadedTiles,\n} from './heatmap.actions'\n\nexport const SET_CURRENTLY_VISIBLE_TILES = 'SET_CURRENTLY_VISIBLE_TILES'\nexport const SET_CURRENTLY_LOADED_TILES = 'SET_CURRENTLY_LOADED_TILES'\nexport const SET_CURRENTLY_SWAPPED_TILE_UIDS = 'SET_CURRENTLY_SWAPPED_TILE_UIDS'\nexport const MARK_TILES_UIDS_AS_LOADED = 'MARK_TILES_UIDS_AS_LOADED'\nexport const RELEASE_MARKED_TILES_UIDS = 'RELEASE_MARKED_TILES_UIDS'\n\n// restrict tilecover to a single zoom level\n// could be customized to load less or more detailed tiles\nconst getTilecoverLimits = (viewportZoom) => {\n  let zoom = Math.ceil(viewportZoom + TILES_LOAD_ZOOM_OFFSET)\n  let tilesAvailable = true\n  if (zoom > ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING) {\n    zoom = ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING\n    tilesAvailable = false\n  }\n  return {\n    min_zoom: zoom,\n    max_zoom: zoom,\n    tilesAvailable,\n  }\n}\n\nconst flushToReleaseTiles = () => (dispatch, getState) => {\n  const state = getState()\n  const currentToLoadTileUids = state.map.heatmapTiles.currentToLoadTileUids\n  // console.log('Tiles left to load: ', currentToLoadTileUids);\n\n  // Tiles are released only when all to-load tiles have finished loading\n  // this is to ensure smooth visual transitions between zoom levels\n  if (!currentToLoadTileUids.length) {\n    const currentTilesToReleaseUids = state.map.heatmapTiles.currentToReleaseTileUids\n    // console.log('no more tiles to load, releasing ', currentTilesToReleaseUids);\n    dispatch(releaseTiles(currentTilesToReleaseUids))\n    dispatch({\n      type: RELEASE_MARKED_TILES_UIDS,\n    })\n  }\n}\n\nexport const markTileAsLoaded = (tileUids) => (dispatch) => {\n  dispatch({\n    type: MARK_TILES_UIDS_AS_LOADED,\n    payload: tileUids,\n  })\n  // console.log(tileUids, 'have finished loading');\n  dispatch(flushToReleaseTiles())\n}\n\nconst flushTileState = (forceLoadingAllVisibleTiles = false) => (dispatch, getState) => {\n  const state = getState()\n  const currentVisibleTiles = state.map.heatmapTiles.currentVisibleTiles\n  let tilesToLoad = []\n  const tilesToReleaseUids = []\n\n  if (forceLoadingAllVisibleTiles === true) {\n    tilesToLoad = currentVisibleTiles\n  } else {\n    const currentLoadedTiles = state.map.heatmapTiles.currentLoadedTiles\n\n    currentVisibleTiles.forEach((visibleTile) => {\n      if (currentLoadedTiles.find((t) => t.uid === visibleTile.uid) === undefined) {\n        tilesToLoad.push(visibleTile)\n      }\n    })\n\n    currentLoadedTiles.forEach((loadedTile) => {\n      if (currentVisibleTiles.find((t) => t.uid === loadedTile.uid) === undefined) {\n        tilesToReleaseUids.push(loadedTile.uid)\n      }\n    })\n  }\n\n  const tilesToLoadUids = tilesToLoad.map((t) => t.uid)\n  // console.log('force loading:', forceLoadingAllVisibleTiles)\n  // console.log('visible', currentVisibleTiles.map(t => t.uid))\n  // console.log('load', tilesToLoadUids)\n  // console.log('release', tilesToReleaseUids)\n  // console.log('----')\n\n  tilesToLoad.forEach((tile) => {\n    dispatch(getTile(tile))\n  })\n  dispatch({\n    type: SET_CURRENTLY_LOADED_TILES,\n    payload: currentVisibleTiles,\n  })\n\n  dispatch({\n    type: SET_CURRENTLY_SWAPPED_TILE_UIDS,\n    payload: {\n      tilesToLoadUids,\n      tilesToReleaseUids,\n    },\n  })\n\n  dispatch(updateLoadedTiles())\n  dispatch(flushToReleaseTiles())\n}\n\nconst _debouncedFlushState = (dispatch) => {\n  dispatch(flushTileState())\n}\nconst debouncedFlushState = debounce(_debouncedFlushState, 500)\n\nexport const updateHeatmapTilesFromViewport = (forceLoadingAllVisibleTiles = false) => (\n  dispatch,\n  getState\n) => {\n  // if in transition, skip loading/releasing\n  // else\n  //   collect all tiles in viewport\n  //   save them to reducer: currentVisibleTiles\n  // if not zooming: flush immediately\n  //   if forceLoadingAllVisiblelTiles\n  //     get tiles from currentVisibleTiles\n  //   else\n  //     get tiles from currentVisibleTiles\n  //     make delta with currentLoadedTiles\n  //     get tiles from delta+\n  //     release tiles from delta-\n  //   save to reducer: currentVisibleTiles -> currentLoadedTiles\n  // if zooming: debounced flush to avoid \"tile spam\"\n  const mapViewport = getState().map.viewport\n  const viewport = mapViewport.viewport\n\n  // do not allow any tile update during transitions (currently only zoom)\n  // wait for the end of the transition to look at viewport and load matching tiles\n  if (!viewport.width || !viewport.height || mapViewport.currentTransition !== null) {\n    return\n  }\n\n  // instanciate a viewport instance to get lat/lon from screen top left/ bottom right bounds\n  const boundsViewport = new PerspectiveMercatorViewport(viewport)\n  const bounds = [\n    boundsViewport.unproject([0, 0]),\n    boundsViewport.unproject([viewport.width, viewport.height]),\n  ]\n\n  const [wn, es] = bounds\n  const [w, s, e, n] = [wn[0], es[1], es[0], wn[1]]\n  const boundsPolygonsCoordinates = []\n\n  const limits = getTilecoverLimits(viewport.zoom)\n  if (limits.tilesAvailable === false && forceLoadingAllVisibleTiles !== true) {\n    return\n  }\n\n  if (e > 180 || w < -180) {\n    // deal with the antimeridian situation by splitting the bounds polygon into two polygons\n    const w1 = e > 180 ? w : w + 360\n    const e1 = 180 - 0.001\n    const w2 = -180\n    const e2 = e > 180 ? e - 360 : e\n    boundsPolygonsCoordinates.push([[[w1, n], [e1, n], [e1, s], [w1, s], [w1, n]]])\n    boundsPolygonsCoordinates.push([[[w2, n], [e2, n], [e2, s], [w2, s], [w2, n]]])\n  } else {\n    boundsPolygonsCoordinates.push([[[w, n], [e, n], [e, s], [w, s], [w, n]]])\n  }\n\n  const geom = {\n    type: 'MultiPolygon',\n    coordinates: boundsPolygonsCoordinates,\n  }\n\n  // using tilecover, get xyz tile coords as well as quadkey indexes (named uid through the app)\n  const viewportTilesCoords = tilecover.tiles(geom, limits)\n  const viewportTilesIndexes = tilecover.indexes(geom, limits)\n  const visibleTiles = []\n\n  viewportTilesCoords.forEach((coords, i) => {\n    const uid = viewportTilesIndexes[i]\n    const zoom = coords[2]\n    if (zoom >= 2) {\n      visibleTiles.push({\n        tileCoordinates: {\n          x: coords[0],\n          y: coords[1],\n          zoom: coords[2],\n        },\n        uid,\n      })\n    }\n  })\n\n  dispatch({\n    type: SET_CURRENTLY_VISIBLE_TILES,\n    payload: visibleTiles,\n  })\n\n  const isMouseWheelZooming = mapViewport.prevZoom !== viewport.zoom\n\n  if (isMouseWheelZooming === false) {\n    dispatch(flushTileState(forceLoadingAllVisibleTiles))\n  } else {\n    debouncedFlushState(dispatch)\n  }\n}\n\nexport const queryHeatmapVessels = (coords, temporalExtentIndexes) => (dispatch, getState) => {\n  // use tilecover to get what tile quadkey/uid \"belongs\" to the point\n  const geom = {\n    type: 'Point',\n    coordinates: [coords.longitude, coords.latitude],\n  }\n  const zoom = getState().map.viewport.viewport.zoom\n\n  // get quadkey for tile at current zoom level, but also neighbouring zoom levels,\n  // in case current zoom level tiles has not been loaded yet\n  const uids = [zoom, zoom - 1, zoom + 1]\n    .map((z) => getTilecoverLimits(z))\n    .map((limits) => tilecover.indexes(geom, limits))\n    .map((indexes) => indexes[0])\n\n  const query = {\n    ...coords,\n    uids,\n  }\n\n  // console.log(query);\n  dispatch(highlightVesselFromHeatmap(query, temporalExtentIndexes))\n}\n","import difference from 'lodash/difference'\nimport uniq from 'lodash/uniq'\nimport uniqBy from 'lodash/uniqBy'\nimport {\n  getTilePromises,\n  getCleanVectorArrays,\n  groupData,\n  getTilePlaybackData,\n  selectVesselsAt,\n} from '../utils/heatmapTileData'\nimport { markTileAsLoaded } from './heatmapTiles.actions'\nimport { startLoader, completeLoader } from '../module/module.actions'\n\nexport const ADD_HEATMAP_LAYER = 'ADD_HEATMAP_LAYER'\nexport const UPDATE_HEATMAP_LAYER_STYLE = 'UPDATE_HEATMAP_LAYER_STYLE'\nexport const ADD_REFERENCE_TILE = 'ADD_REFERENCE_TILE'\nexport const HIGHLIGHT_VESSELS = 'HIGHLIGHT_VESSELS'\nexport const INIT_HEATMAP_LAYERS = 'INIT_HEATMAP_LAYERS'\nexport const REMOVE_HEATMAP_LAYER = 'REMOVE_HEATMAP_LAYER'\nexport const UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES =\n  'UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES'\nexport const UPDATE_HEATMAP_TILE = 'UPDATE_HEATMAP_TILE'\nexport const RELEASE_HEATMAP_TILES = 'RELEASE_HEATMAP_TILES'\nexport const UPDATE_LOADED_TILES = 'UPDATE_LOADED_TILES'\nexport const HIGHLIGHT_CLICKED_VESSEL = 'HIGHLIGHT_CLICKED_VESSEL'\nexport const CLEAR_HIGHLIGHT_CLICKED_VESSEL = 'CLEAR_HIGHLIGHT_CLICKED_VESSEL'\n\n/**\n * getTemporalExtentsVisibleIndices - Compares timebar outer extent with temporal extents present on the layer header\n * @param  {array} loadTemporalExtent Current timebar outer extent\n * @param  {array} layerTemporalExtents Temporal extent present on the layer's header (an array of extent arrays)\n * @return {array}                    Indices of the layer's temporal extents that should be visible\n */\nfunction getTemporalExtentsVisibleIndices(loadTemporalExtent, layerTemporalExtents) {\n  const currentExtentStart = loadTemporalExtent[0].getTime()\n  const currentExtentEnd = loadTemporalExtent[1].getTime()\n  const indices = []\n  layerTemporalExtents.forEach((temporalExtent, index) => {\n    const temporalExtentStart = temporalExtent[0]\n    const temporalExtentEnd = temporalExtent[1]\n    if (temporalExtentEnd >= currentExtentStart && temporalExtentStart <= currentExtentEnd) {\n      indices.push(index)\n    }\n  })\n  return indices\n}\n\n/**\n * loadLayerTile - loads an heatmap tile.\n *\n * @param  {string} layerId              layer id\n * @param  {object} tileCoordinates      tile coordinates from reference tile\n * @param  {string} token                the user's token\n * @param  {array} temporalExtentsIndices which of the temporal extents from  temporalExtents should be loaded\n * @param  {string} urls                 tile endpoints provided by header\n * @param  {array} temporalExtents       all of the layer's header temporal extents\n * @param  {bool} temporalExtentsLess    true = don't try to load different tiles based on current time extent\n * @return {Promise}                     a Promise that will be resolved when tile is loaded\n */\nfunction loadLayerTile(\n  layerId,\n  tileCoordinates,\n  token,\n  temporalExtentsIndices,\n  { url, temporalExtents, temporalExtentsLess }\n) {\n  // console.log('loadLayerTile', layerId, tileCoordinates, temporalExtentsIndices)\n  if (url === undefined) {\n    throw new Error('URL/endpoints object is not available on this tilesets header')\n  }\n  const pelagosPromises = getTilePromises(url, token, temporalExtents, {\n    tileCoordinates,\n    temporalExtentsIndices,\n    temporalExtentsLess,\n  })\n  const allLayerPromises = Promise.all(pelagosPromises)\n\n  const layerTilePromise = new Promise((resolve) => {\n    allLayerPromises.then((rawTileData) => {\n      resolve({\n        loadedLayerId: layerId,\n        rawTileData,\n      })\n    })\n  })\n\n  return layerTilePromise\n}\n\n/**\n * parseLayerTile - parses an heatmap tile to a playback-ready format.\n *\n * @param  {Object} rawTileData          the raw tile data, loaded either from the pelagos client or as a MVT/PBF vector tile\n * @param  {array} colsByName            names of the columns present in the raw tiles that need to be included in the final playback data\n * @param  {object} tileCoordinates      tile coordinates from reference tile\n * @param  {array} prevPlaybackData      (optional) in case some time extent was already loaded for this tile, append to this data\n * @return {Object}                      playback-ready merged data\n */\nfunction parseLayerTile(rawTileData, colsByName, tileCoordinates, prevPlaybackData) {\n  let data\n\n  const cleanVectorArrays = getCleanVectorArrays(rawTileData)\n  data = groupData(cleanVectorArrays, Object.keys(colsByName))\n  if (Object.keys(data).length === 0) {\n    return []\n  }\n\n  const playbackData = getTilePlaybackData(data, colsByName, tileCoordinates, prevPlaybackData)\n  return playbackData\n}\n\n/**\n * getTiles - loads a bunch of heatmap tiles\n * @param  {array} layerIds                 list of layer Ids that need to be loaded for this/these tiles\n * @param  {array} referenceTiles           list of reference tiles (tile data regardless of layer) that need to be loaded\n * @param  {object} newTemporalExtentsToLoad (optional) a dict (layerId is the key) of temporal extents\n * indices that should be appended to existing data\n */\nfunction getTiles(layerIds, referenceTiles, newTemporalExtentsToLoad = undefined) {\n  return (dispatch, getState) => {\n    const state = getState()\n    const loaderID = startLoader(dispatch, state, layerIds.join('-'))\n    const token = state.map.module.token\n    const heatmapLayers = state.map.heatmap.heatmapLayers\n    const tilesByLayer = {}\n    layerIds.forEach((id) => {\n      tilesByLayer[id] = [...heatmapLayers[id].tiles]\n    })\n    const allPromises = []\n\n    layerIds.forEach((layerId) => {\n      const heatmapLayerHeader = heatmapLayers[layerId].header\n      const { temporalExtents, temporalExtentsLess, colsByName } = { ...heatmapLayerHeader }\n      const url = heatmapLayerHeader.endpoints.tiles\n\n      referenceTiles.forEach((referenceTile) => {\n        // check if tile does not already exist first\n        let tile = tilesByLayer[layerId].find((t) => t.uid === referenceTile.uid)\n        if (!tile) {\n          // console.log('create tile ', referenceTile.uid)\n          tile = {\n            uid: referenceTile.uid,\n            temporalExtentsIndicesLoaded: [],\n          }\n          tilesByLayer[layerId].push(tile)\n        } else {\n          // console.log('found tile', referenceTile.uid)\n        }\n\n        const queriedTemporalExtentsIndices =\n          newTemporalExtentsToLoad === undefined\n            ? heatmapLayers[layerId].visibleTemporalExtentsIndices\n            : newTemporalExtentsToLoad[layerId]\n\n        const temporalExtentsIndicesToLoad = difference(\n          queriedTemporalExtentsIndices,\n          tile.temporalExtentsIndicesLoaded\n        )\n\n        const tilePromise = loadLayerTile(\n          layerId,\n          referenceTile.tileCoordinates,\n          token,\n          temporalExtentsIndicesToLoad,\n          {\n            url,\n            temporalExtents,\n            temporalExtentsLess,\n          }\n        )\n\n        allPromises.push(tilePromise)\n\n        tilePromise.then(({ loadedLayerId, rawTileData }) => {\n          tile.temporalExtentsIndicesLoaded = uniq(\n            tile.temporalExtentsIndicesLoaded.concat(temporalExtentsIndicesToLoad)\n          )\n          tile.data = parseLayerTile(\n            rawTileData,\n            colsByName,\n            referenceTile.tileCoordinates,\n            tile.data\n          )\n\n          dispatch({\n            type: UPDATE_HEATMAP_TILE,\n            payload: {\n              layerId: loadedLayerId,\n              tile,\n            },\n          })\n        })\n      })\n    })\n\n    Promise.all(allPromises).then(() => {\n      dispatch(completeLoader(loaderID))\n      dispatch(markTileAsLoaded(referenceTiles.map((tile) => tile.uid)))\n    })\n  }\n}\n\n/**\n * getTile - This action is emitted when a new tile is queried from panning or zooming the map\n * This will load a tile for all currently visible heatmap layers\n *\n * @param  {object} referenceTile a reference tile containing xyz coords and uid\n */\nexport function getTile(referenceTile) {\n  return (dispatch, getState) => {\n    dispatch({\n      type: ADD_REFERENCE_TILE,\n      payload: referenceTile,\n    })\n    const visibleHeatmapLayers = getState().map.heatmap.heatmapLayers\n    const visibleHeatmapLayersIds = Object.keys(visibleHeatmapLayers).filter(\n      (id) => visibleHeatmapLayers[id].visible === true\n    )\n\n    if (visibleHeatmapLayersIds.length) {\n      dispatch(getTiles(visibleHeatmapLayersIds, [referenceTile]))\n    }\n  }\n}\n\n/**\n * releaseTiles - This action is emitted when an existing tile is removed from panning or zooming the map\n * @param  {array} uids tile ref uids to release\n */\nexport const releaseTiles = (uids) => ({\n  type: RELEASE_HEATMAP_TILES,\n  payload: uids,\n})\n\nexport const updateLoadedTiles = () => ({\n  type: UPDATE_LOADED_TILES,\n})\n\n// triggered when a layer is added or set to visible\nfunction loadAllTilesForLayer(layerId) {\n  return (dispatch, getState) => {\n    //                current layer, all reference tiles\n    const referenceTiles = getState().map.heatmap.referenceTiles\n    dispatch(getTiles([layerId], referenceTiles))\n  }\n}\n\nexport const addHeatmapLayer = (layer, loadTemporalExtent) => (dispatch) => {\n  const layerTemporalExtents = layer.header.temporalExtents\n  dispatch({\n    type: ADD_HEATMAP_LAYER,\n    payload: {\n      ...layer,\n      // initially attach which of the temporal extents indices are visible with initial outerExtent\n      visibleTemporalExtentsIndices: getTemporalExtentsVisibleIndices(\n        loadTemporalExtent,\n        layerTemporalExtents\n      ),\n    },\n  })\n\n  if (layer.visible === true) {\n    dispatch(loadAllTilesForLayer(layer.id))\n  }\n}\n\nexport const removeHeatmapLayer = (id) => (dispatch) => {\n  dispatch({\n    type: REMOVE_HEATMAP_LAYER,\n    payload: {\n      id,\n    },\n  })\n}\n\n/**\n * updateLayerLoadTemporalExtents - when outer time extent changes, checks if more tiles needs to be loaded\n * by comparing the outer time range with the temporalExtent already loaded on each layer.\n * @param  {array} loadTemporalExtent Current app-wide extent of tiles that need to load, expressed\n * as an array of two dates\n */\nexport function updateLayerLoadTemporalExtents(loadTemporalExtent) {\n  return (dispatch, getState) => {\n    const state = getState()\n    const heatmapLayers = state.map.heatmap.heatmapLayers\n    const indicesToAddByLayer = {}\n\n    Object.keys(heatmapLayers).forEach((layerId) => {\n      const heatmapLayer = heatmapLayers[layerId]\n      const temporalExtents = heatmapLayer.header.temporalExtents\n      const oldVisibleTemporalExtentsIndices = heatmapLayer.visibleTemporalExtentsIndices\n      const newVisibleTemporalExtentsIndices = getTemporalExtentsVisibleIndices(\n        loadTemporalExtent,\n        temporalExtents\n      )\n\n      const indicesAdded = difference(\n        newVisibleTemporalExtentsIndices,\n        oldVisibleTemporalExtentsIndices\n      )\n\n      const indicesRemoved = difference(\n        oldVisibleTemporalExtentsIndices,\n        newVisibleTemporalExtentsIndices\n      )\n\n      if (indicesAdded.length || indicesRemoved.length) {\n        // add new loaded indices to heatmap layer if applicable\n        dispatch({\n          type: UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES,\n          payload: {\n            layerId,\n            newVisibleTemporalExtentsIndices,\n            indicesRemoved,\n          },\n        })\n      }\n      if (indicesAdded.length) {\n        indicesToAddByLayer[layerId] = indicesAdded\n      }\n    })\n\n    // getTiles with indices diff\n    const layerIdsWithIndicesToAdd = Object.keys(indicesToAddByLayer)\n    if (layerIdsWithIndicesToAdd.length) {\n      dispatch(\n        getTiles(layerIdsWithIndicesToAdd, state.map.heatmap.referenceTiles, indicesToAddByLayer)\n      )\n    }\n  }\n}\n\n/**\n * Returns clusters or vessels data from a tileQuery\n * @param {object} state - the application state\n * @param {string} tileQuery - the id of a heatmap layer\n * @return {object} { isEmpty, isCluster, isMouseCluster, foundVessels, layerId, tilesetId }\n */\nconst _queryHeatmap = (state, tileQuery, temporalExtentIndexes) => {\n  const layers = state.map.heatmap.heatmapLayers\n  const startIndex = temporalExtentIndexes[0]\n  const endIndex = temporalExtentIndexes[1]\n  const layersVessels = []\n\n  Object.keys(layers).forEach((layerId) => {\n    const layer = layers[layerId]\n    if (layer.visible !== true) {\n      return\n    }\n    const allPossibleTilesByPreference = tileQuery.uids.map((uid) =>\n      layer.tiles.find((tile) => tile.uid === uid)\n    )\n    const availableTiles = allPossibleTilesByPreference.filter(\n      (tile) => tile !== undefined && tile.data !== undefined\n    )\n\n    const currentFilters = layer.filters\n    if (availableTiles.length) {\n      const bestTile = availableTiles[0]\n      layersVessels.push({\n        layer,\n        vessels: selectVesselsAt(bestTile.data, tileQuery, startIndex, endIndex, currentFilters),\n      })\n    }\n  })\n\n  const layersVesselsResults = layersVessels.filter(\n    (layerVessels) => layerVessels.vessels.length > 0\n  )\n\n  // it's a cluster because of aggregation on the server side\n  let isCluster\n  // its a cluster because or multiple vessels under mouse\n  let isMouseCluster\n  let isEmpty\n  let layerVesselsResult\n  let foundVessels\n\n  if (layersVesselsResults.length === 0) {\n    isEmpty = true\n  } else if (layersVesselsResults.length > 1) {\n    // if there are points over multiple layers, consider this a cluster (ie don't select, zoom instead, or don't highlight)\n    // there's an exception if vessel selection contains an encounter, in which case it will take priority\n    isCluster = true\n  } else {\n    // layersVesselsResults should contain a single result\n    layerVesselsResult = layersVesselsResults[0]\n\n    // we can get multiple points with similar series and id, in which case\n    // we should treat that as a successful vessel query, not a cluster\n    const vessels = layerVesselsResult.vessels\n\n    if (vessels.length === 0) {\n      isEmpty = true\n    } else {\n      // look up for any negatives ids (clusters on the server side)\n      const clusteredVessels = vessels.filter((v) => v.id < 0)\n      if (clusteredVessels.length) {\n        isCluster = true\n      } else {\n        foundVessels = uniqBy(vessels, (v) => v.series)\n        isMouseCluster = foundVessels.length > 1\n      }\n    }\n  }\n\n  const layer = layerVesselsResult === undefined ? {} : layerVesselsResult.layer\n\n  return { isEmpty, isCluster, isMouseCluster, foundVessels, layer }\n}\n\nexport function clearHighlightedVessels() {\n  return {\n    type: HIGHLIGHT_VESSELS,\n    payload: {\n      isEmpty: true,\n      clickableCluster: false,\n    },\n  }\n}\n\nexport function highlightVesselFromHeatmap(tileQuery, temporalExtentIndexes) {\n  return (dispatch, getState) => {\n    const state = getState()\n    const { layer, isEmpty, isCluster, isMouseCluster, foundVessels } = _queryHeatmap(\n      state,\n      tileQuery,\n      temporalExtentIndexes\n    )\n\n    if (\n      isCluster === true ||\n      layer.id !== undefined ||\n      state.map.heatmap.highlightedVessels.layerId !== layer.id\n    ) {\n      const layerPayload =\n        layer === undefined\n          ? null\n          : {\n              id: layer.id,\n              tilesetId: layer.tilesetId,\n              subtype: layer.subtype,\n              header: layer.header,\n            }\n      dispatch({\n        type: HIGHLIGHT_VESSELS,\n        payload: {\n          layer: layerPayload,\n          isEmpty,\n          clickableCluster: isCluster === true || isMouseCluster === true,\n          highlightableCluster: isCluster !== true,\n          foundVessels,\n        },\n      })\n    } else {\n      dispatch(clearHighlightedVessels())\n    }\n  }\n}\n\nexport const highlightClickedVessel = (id, layerId) => ({\n  type: HIGHLIGHT_CLICKED_VESSEL,\n  payload: {\n    id,\n    layerId,\n  },\n})\n\nexport const clearHighlightedClickedVessel = () => ({\n  type: CLEAR_HIGHLIGHT_CLICKED_VESSEL,\n})\n\nexport const updateHeatmapLayers = (newLayers, currentLoadTemporalExtent) => (\n  dispatch,\n  getState\n) => {\n  if (newLayers === null) {\n    console.warn(\"New layers in updateHeatmapLayers can't be null\")\n    return\n  }\n  const prevLayersDict = getState().map.heatmap.heatmapLayers\n\n  // add and update layers\n  newLayers.forEach((newLayer) => {\n    const layerId = newLayer.id\n    const prevLayer = prevLayersDict[layerId]\n    if (prevLayer === undefined) {\n      // console.log('adding', layerId)\n      dispatch(addHeatmapLayer(newLayer, currentLoadTemporalExtent))\n    } else {\n      if (prevLayer.visible !== newLayer.visible && newLayer.visible === true) {\n        dispatch(loadAllTilesForLayer(layerId))\n      }\n      if (\n        prevLayer.visible !== newLayer.visible ||\n        prevLayer.hue !== newLayer.hue ||\n        prevLayer.opacity !== newLayer.opacity ||\n        prevLayer.filters !== newLayer.filters ||\n        prevLayer.interactive !== newLayer.interactive\n      ) {\n        // console.log('updating', layerId, ' with visibilty', newLayer.visible)\n        dispatch({\n          type: UPDATE_HEATMAP_LAYER_STYLE,\n          payload: {\n            id: newLayer.id,\n            visible: newLayer.visible,\n            hue: newLayer.hue,\n            opacity: newLayer.opacity,\n            filters: newLayer.filters,\n            interactive: newLayer.interactive,\n          },\n        })\n      }\n    }\n  })\n\n  // clean up unused layers\n  Object.keys(prevLayersDict).forEach((prevLayerId) => {\n    if (!newLayers.find((l) => l.id === prevLayerId)) {\n      dispatch(removeHeatmapLayer(prevLayerId))\n    }\n  })\n}\n","import { fitBounds, pixelsToWorld } from 'viewport-mercator-project'\nimport { updateHeatmapTilesFromViewport } from '../heatmap/heatmapTiles.actions'\nimport { onViewportChange } from '../module/module.actions'\nimport { CLUSTER_CLICK_ZOOM_INCREMENT } from '../config' // TODO MAP MODULE\n\nexport const SET_BOUNDS = 'SET_BOUNDS'\nexport const SET_VIEWPORT = 'SET_VIEWPORT'\nexport const UPDATE_VIEWPORT = 'UPDATE_VIEWPORT'\nexport const SET_ZOOM_INCREMENT = 'SET_ZOOM_INCREMENT'\nexport const SET_MOUSE_LAT_LONG = 'SET_MOUSE_LAT_LONG'\nexport const TRANSITION_END = 'TRANSITION_END'\nexport const SET_NATIVE_VIEWPORT = 'SET_NATIVE_VIEWPORT'\n\nexport const setBounds = (bounds) => ({\n  type: SET_BOUNDS,\n  payload: bounds,\n})\n\nexport const setViewport = (viewport, interactionState) => (dispatch) => {\n  dispatch({\n    type: SET_VIEWPORT,\n    payload: viewport,\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  dispatch(onViewportChange(interactionState))\n}\n\nexport const updateViewport = (viewportUpdate) => (dispatch) => {\n  dispatch({\n    type: UPDATE_VIEWPORT,\n    payload: viewportUpdate,\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  // Not needed as call the callback with the same values\n  // dispatch(onViewportChange())\n}\n\nconst transitionTo = (increment, latitude = null, longitude = null, zoom = null) => (dispatch) => {\n  dispatch({\n    type: SET_ZOOM_INCREMENT,\n    payload: {\n      increment,\n      latitude,\n      longitude,\n      zoom,\n    },\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  dispatch(onViewportChange())\n}\n\nexport const transitionToZoom = (viewport) => (dispatch) => {\n  dispatch(transitionTo(null, viewport.center[0], viewport.center[1], viewport.zoom))\n}\n\nexport const transitionEnd = () => (dispatch) => {\n  dispatch({\n    type: TRANSITION_END,\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  dispatch(onViewportChange())\n}\n\nexport const zoomIntoVesselCenter = (latitude, longitude, zoom = null) => (dispatch) => {\n  dispatch(transitionTo(CLUSTER_CLICK_ZOOM_INCREMENT, latitude, longitude, zoom))\n}\n\nexport const fitToBounds = (bounds) => (dispatch, getState) => {\n  const state = getState()\n  const vp = fitBounds({\n    bounds: [[bounds.minLng, bounds.minLat], [bounds.maxLng, bounds.maxLat]],\n    width: state.map.viewport.viewport.width,\n    height: state.map.viewport.viewport.height,\n    padding: 50,\n  })\n  dispatch(transitionTo(null, vp.latitude, vp.longitude, vp.zoom))\n}\n\nexport const exportNativeViewport = (nativeViewport) => (dispatch) => {\n  const topLeftPx = [0, 0]\n  const bottomRightPx = [nativeViewport.width, nativeViewport.height]\n\n  // compute left and right offsets to deal with antimeridian issue\n  const topLeftWorld = pixelsToWorld(topLeftPx, nativeViewport.pixelUnprojectionMatrix)\n  const bottomRightWorld = pixelsToWorld(bottomRightPx, nativeViewport.pixelUnprojectionMatrix)\n  const leftWorldScaled = topLeftWorld[0] / nativeViewport.scale\n  const rightWorldScaled = bottomRightWorld[0] / nativeViewport.scale\n\n  // lat/lon corners for miniglobe\n  const northWest = nativeViewport.unproject(topLeftPx)\n  const southEast = nativeViewport.unproject(bottomRightPx)\n  const bounds = {\n    north: northWest[1],\n    south: southEast[1],\n    west: northWest[0],\n    east: southEast[0],\n  }\n\n  dispatch({\n    type: SET_NATIVE_VIEWPORT,\n    payload: {\n      leftWorldScaled,\n      rightWorldScaled,\n      bounds,\n    },\n  })\n}\n","import area from '@turf/area'\nimport { POLYGON_LAYERS_AREA } from '../constants'\nimport { clearHighlightedVessels, clearHighlightedClickedVessel } from '../heatmap/heatmap.actions'\nimport { zoomIntoVesselCenter } from './viewport.actions'\n\nexport const SET_POPUP = 'SET_POPUP'\nexport const CLEAR_POPUP = 'CLEAR_POPUP'\nexport const SET_MAP_CURSOR = 'SET_MAP_CURSOR'\n\nconst getAreaKm2 = (glFeature) => {\n  const areakm2 = 10 ** -6 * area(glFeature.geometry)\n  const formatted = areakm2.toLocaleString('en-US', { maximumFractionDigits: 0 })\n  return formatted\n}\n\nconst getFields = (glFeature, source = null) => {\n  if (source === null || source === undefined) {\n    // console.warn('Couldnt find source when looking for fields of layer', sourceId)\n  }\n\n  const fieldsDefinition =\n    !source || source.metadata === undefined || source.metadata['gfw:popups'] === undefined\n      ? []\n      : source.metadata['gfw:popups']\n\n  const properties = glFeature.properties\n\n  // whitelist if 'gfw:popups' exist, if not return all\n  const fieldsKeys = Object.keys(glFeature.properties).filter(\n    (k) => fieldsDefinition.length === 0 || fieldsDefinition.find((fd) => fd.id === k) !== undefined\n  )\n\n  const fields = fieldsKeys.map((fieldKey) => {\n    const value = fieldKey === POLYGON_LAYERS_AREA ? getAreaKm2(glFeature) : properties[fieldKey]\n    const def = fieldsDefinition.find((fd) => fd.id === fieldKey) || {}\n    const label = def.label || fieldKey\n    return {\n      id: fieldKey,\n      label,\n      value,\n      title: `${label}: ${value}`,\n      isLink: def.isLink,\n      isMain: def.isMain,\n    }\n  })\n\n  const mainField =\n    fields.find((f) => f.isMain === true) ||\n    fields.find((f) => f.id === 'name') ||\n    fields.find((f) => f.id === 'id') ||\n    fields[0]\n\n  if (mainField !== undefined) {\n    mainField.isMain = true\n  }\n  return fields\n}\n\nconst getCluster = (glFeature, glGetSource) => {\n  const clusterId = glFeature.properties.cluster_id\n  const sourceId = glFeature.source\n  const glSource = glGetSource(sourceId)\n  const promise = new Promise((resolve, reject) => {\n    glSource.getClusterExpansionZoom(clusterId, (err1, zoom) => {\n      glSource.getClusterLeaves(clusterId, 99, 0, (err2, children) => {\n        if (err1 || err2) {\n          reject()\n        }\n        const childrenFeatures = children.map((child) =>\n          getFeature(child, glFeature.layer.id, glSource)\n        )\n        resolve({\n          zoom,\n          childrenFeatures,\n        })\n      })\n    })\n  })\n  return promise\n}\n\nconst getFeature = (glFeature, layerId, source) => {\n  const feature = {\n    properties: glFeature.properties,\n  }\n  const fields = getFields(glFeature, source)\n  feature.fields = fields\n\n  // Get most likely feature title\n  const mainField = fields.find((f) => f.isMain === true)\n  feature.title = mainField === undefined ? layerId : mainField.value\n\n  return feature\n}\n\nexport const mapInteraction = (interactionType, latitude, longitude, glFeatures, glGetSource) => (\n  dispatch,\n  getState\n) => {\n  if (interactionType === 'click') {\n    dispatch(clearHighlightedClickedVessel())\n  }\n\n  const currentStyle = getState().map.style.mapStyle.toJS()\n\n  const event = {\n    latitude,\n    longitude,\n    features: [],\n  }\n\n  // Collect and normalize features on legacy heatmap\n  const currentLegacyHeatmapData = getState().map.heatmap.highlightedVessels\n  let legacyHeatmapFeature\n\n  if (currentLegacyHeatmapData.isEmpty !== true) {\n    const foundVessels =\n      currentLegacyHeatmapData.foundVessels === undefined\n        ? []\n        : currentLegacyHeatmapData.foundVessels\n    const properties = foundVessels.length === 0 ? [] : foundVessels[0]\n    const isCluster = currentLegacyHeatmapData.clickableCluster === true\n    const count =\n      isCluster === true && currentLegacyHeatmapData.highlightableCluster === false\n        ? -1\n        : foundVessels.length\n    legacyHeatmapFeature = {\n      isCluster,\n      count,\n      layer: {\n        id: currentLegacyHeatmapData.layer.id,\n        group: 'legacyHeatmap',\n      },\n      properties,\n    }\n    event.features.push(legacyHeatmapFeature)\n  }\n\n  // Try to retrieve 'gfw:id' (generated when instanciating CARTO layer to preserve original style.json id)\n  // In most cases it won't exist, so fall back to source id\n  const getStaticLayerIdFromGlFeature = (glFeature) =>\n    (glFeature.layer.metadata !== undefined && glFeature.layer.metadata['gfw:id']) ||\n    glFeature.layer.source\n\n  // Collect gl features\n  const clusterPromises = []\n  const allGlFeatures = glFeatures || []\n  allGlFeatures.forEach((glFeature) => {\n    const layerId = getStaticLayerIdFromGlFeature(glFeature)\n    const source = currentStyle.sources[layerId]\n    const feature = {\n      layer: {\n        id: layerId,\n        group: glFeature.layer.metadata && glFeature.layer.metadata['mapbox:group'],\n      },\n      ...getFeature(glFeature, layerId, source),\n    }\n\n    if (glFeature.properties.cluster === true) {\n      // lookup for cluster\n      const clusterPromise = getCluster(glFeature, glGetSource).then((cluster) => {\n        feature.cluster = cluster\n        feature.count = cluster.childrenFeatures.length\n      })\n      clusterPromises.push(clusterPromise)\n      feature.isCluster = true\n    } else {\n      feature.isCluster = false\n    }\n    event.features.push(feature)\n  })\n\n  Promise.all(clusterPromises).then(() => {\n    // The whole set of features is considered a cluster\n    // if any feature is a cluster, or there is more than one feature\n    event.isCluster =\n      event.features.length > 1 || event.features.some((feature) => feature.isCluster === true)\n\n    // legacy heatmap layers can yield clusters with an unknown number of features, handle this here:\n    if (legacyHeatmapFeature !== undefined && legacyHeatmapFeature.count === -1) {\n      event.count = -1\n    } else {\n      event.count = event.features.reduce((count, feature) => {\n        let featureCount = feature.count || 1\n        return count + featureCount\n      }, 0)\n    }\n\n    if (event.count === 1) {\n      event.feature = event.features[0]\n    }\n\n    // When autoClusterZoom is set to true, we handle zoom here\n    const autoClusterZoom = getState().map.module.autoClusterZoom === true\n\n    // Check if cluster using customizable isCluster() callback\n    // If not set resolves simply to (event) => event.isCluster === true\n    const clusterBehavior = getState().map.module.isCluster(event)\n    event.isCluster = clusterBehavior\n\n    if (autoClusterZoom) {\n      if (interactionType === 'click' && event.isCluster === true) {\n        dispatch(clearHighlightedVessels())\n        const clusterZoom = event.features[0].cluster && event.features[0].cluster.zoom\n        dispatch(zoomIntoVesselCenter(latitude, longitude, clusterZoom))\n      }\n    }\n\n    let cursor = event.features.length ? 'pointer' : null\n    if (event.isCluster === true) {\n      cursor = 'zoom-in'\n    }\n\n    dispatch({\n      type: SET_MAP_CURSOR,\n      payload: cursor,\n    })\n\n    const callback =\n      interactionType === 'click' ? getState().map.module.onClick : getState().map.module.onHover\n\n    if (callback !== undefined) {\n      callback(event)\n    }\n  })\n}\n","const RGB_MAX = 255\nconst HUE_MAX = 360\nconst SV_MAX = 100\n\nexport const VESSELS_HUES_INCREMENTS_NUM = 31 // 360 / VESSELS_HUES_INCREMENTS_NUM - 1  should give a round number\nexport const VESSELS_HUES_INCREMENT = 360 / (VESSELS_HUES_INCREMENTS_NUM - 1)\n\n// Legacy: this is only here for compatibility with pre-mapbox branch workspaces\nexport const COLOR_HUES = {\n  orange: 0,\n  peach: 22,\n  yellow: 60,\n  green: 85,\n  brightGreen: 145,\n  lightBlue: 182,\n  blue: 236,\n  purple: 284,\n  pink: 312,\n}\n\n// FIXME mark explicitely as legacy. Check all usages.\nexport const getKeyByValue = (obj, value) => {\n  let result = null\n  Object.entries(obj).forEach((entry) => {\n    if (entry[1] === value) result = entry[0]\n  })\n  return result\n}\n\n/**\n * Converts an RGB color value to HSV. Conversion formula\n * adapted from http://en.wikipedia.org/wiki/HSV_color_space.\n * Assumes r, g, and b are contained in the set [0, 255] and\n * returns h, s, and v in the set [0, 1].\n *\n * @param   Number  r       The red color value\n * @param   Number  g       The green color value\n * @param   Number  b       The blue color value\n * @return  Array           The HSV representation\n */\nexport const rgbToHsv = (_r, _g, _b) => {\n  const r = _r / 255\n  const g = _g / 255\n  const b = _b / 255\n\n  const max = Math.max(r, g, b)\n  const min = Math.min(r, g, b)\n  let h\n  const v = max\n\n  const d = max - min\n  const s = max === 0 ? 0 : d / max\n\n  if (max === min) {\n    h = 0 // achromatic\n  } else {\n    switch (max) {\n      case r:\n        h = (g - b) / d + (g < b ? 6 : 0)\n        break\n      case g:\n        h = (b - r) / d + 2\n        break\n      case b:\n        h = (r - g) / d + 4\n        break\n      default:\n        h = 0\n    }\n\n    h /= 6\n  }\n\n  return [h, s, v]\n}\n\n// converts hue, saturation, luminance to an rgb object\nexport const hsvToRgb = (h_, s_, v_) => {\n  const h = ((h_ % HUE_MAX) / parseFloat(HUE_MAX)) * 6\n  const s = s_ === SV_MAX ? 1 : (s_ % SV_MAX) / parseFloat(SV_MAX)\n  const v = v_ === SV_MAX ? 1 : (v_ % SV_MAX) / parseFloat(SV_MAX)\n\n  const i = Math.floor(h)\n  const f = h - i\n  const p = v * (1 - s)\n  const q = v * (1 - f * s)\n  const t = v * (1 - (1 - f) * s)\n  const mod = i % 6\n  const r = [v, q, p, p, t, v][mod]\n  const g = [t, v, v, q, p, p][mod]\n  const b = [p, p, t, v, v, q][mod]\n\n  return { r: Math.round(r * RGB_MAX), g: Math.round(g * RGB_MAX), b: Math.round(b * RGB_MAX) }\n}\n\n// returns an rgb string with default saturation and luminance values\nconst hueToRgbDefaults = (hue) => hsvToRgb(hue, 50, 100)\n\nexport const hueToRgbString = (hue) => {\n  const rgb = hueToRgbDefaults(hue)\n  return `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`\n}\n\nexport const rgbToHexString = (rgb, css) => {\n  const str = ['r', 'g', 'b']\n    .map((channelName) => {\n      const channelValue = rgb[channelName]\n      let channelStr = channelValue.toString(16)\n      if (channelValue < 16) {\n        channelStr = `0${channelStr}`\n      }\n      return channelStr\n    })\n    .join('')\n  const prefix = css === true ? '#' : '0x'\n  return `${prefix}${str}`\n}\n\nexport const hueToRgbHexString = (hue, css) => {\n  const rgb = hueToRgbDefaults(hue)\n  return rgbToHexString(rgb, css)\n}\n\nconst closestNumber = (numberArray, goal) =>\n  numberArray.reduce((prev, curr) => (Math.abs(curr - goal) < Math.abs(prev - goal) ? curr : prev))\n\nexport const hueToClosestColor = (hue) => {\n  if (hue === undefined || hue === null) return undefined\n  const colorHueValues = Object.keys(COLOR_HUES).map((key) => COLOR_HUES[key])\n  const closestHue = closestNumber(colorHueValues, hue)\n  return getKeyByValue(COLOR_HUES, closestHue)\n}\n\nexport const hexToRgb = (hex) => {\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex)\n  return result\n    ? {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16),\n      }\n    : null\n}\n\nconst rgbToRgbaString = (rgb, opacity) => `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`\n\nexport const hueToRgbaString = (hue, opacity) => {\n  const rgb = hueToRgbDefaults(hue)\n  return rgbToRgbaString(rgb, opacity)\n}\n\nexport const hexToRgba = (hex, opacity) => {\n  const rgb = hexToRgb(hex)\n  return rgbToRgbaString(rgb, opacity)\n}\n\nexport const hueIncrementToHue = (hueIncrement) => hueIncrement * VESSELS_HUES_INCREMENT\n\nexport const hueToHueIncrement = (hue) =>\n  Math.round((hue / 360) * (VESSELS_HUES_INCREMENTS_NUM - 1))\n\nexport const wrapHue = (hue) => hue % 360\n\nexport const hueOrColorToHexColor = (color, hue) => {\n  if (hue !== undefined) {\n    return hueToRgbHexString(hue, true)\n  }\n\n  return color\n}\n","/* global PIXI */\nimport 'pixi.js'\nimport { hueToHueIncrement, VESSELS_HUES_INCREMENTS_NUM } from '../utils/map-colors'\nimport { VESSELS_BASE_RADIUS, MAX_SPRITES_PER_LAYER } from '../config'\n\nexport default class HeatmapSubLayer {\n  constructor(baseTexture, renderingStyleIndex, hue, useNormalBlendMode = false) {\n    // this.stage = new PIXI.Container();\n    // the ParticleContainer is a faster version of the PIXI sprite container\n    this.stage = new PIXI.particles.ParticleContainer(MAX_SPRITES_PER_LAYER, {\n      scale: true,\n      alpha: true,\n      position: true,\n      uvs: true,\n    })\n    if (useNormalBlendMode === false) {\n      this.stage.blendMode = PIXI.BLEND_MODES.SCREEN\n    }\n\n    this.spritesPool = []\n\n    const initialTextureFrame = new PIXI.Rectangle(\n      0,\n      0,\n      VESSELS_BASE_RADIUS * 2,\n      VESSELS_BASE_RADIUS * 2\n    )\n    this.mainVesselTexture = new PIXI.Texture(baseTexture, initialTextureFrame)\n    this._setTextureFrame(renderingStyleIndex, hue)\n\n    this.clearSpriteProps()\n  }\n\n  clearSpriteProps() {\n    this.spritesProps = {\n      x: new Float32Array(MAX_SPRITES_PER_LAYER),\n      y: new Float32Array(MAX_SPRITES_PER_LAYER),\n      a: new Float32Array(MAX_SPRITES_PER_LAYER),\n      s: new Float32Array(MAX_SPRITES_PER_LAYER),\n    }\n    this.spritesPropsCount = 0\n  }\n\n  pushSpriteProps(x, y, a, s) {\n    this.spritesProps.x[this.spritesPropsCount] = x\n    this.spritesProps.y[this.spritesPropsCount] = y\n    this.spritesProps.a[this.spritesPropsCount] = a\n    this.spritesProps.s[this.spritesPropsCount] = s\n    this.spritesPropsCount++\n  }\n\n  setRenderingStyleIndex(renderingStyleIndex) {\n    this._setTextureFrame(renderingStyleIndex)\n  }\n\n  destroy() {\n    this.spritesPool = null\n    this.stage.destroy({ children: true })\n  }\n\n  /**\n   * Updates the main texture frame offset to show different brush styles and hues\n   * Both args are optional, if one is omitted, previous value is used\n   * @heatmapStyle bool whether to use heatmap style or solid circle style\n   * @hue number hue value between 0 and 360\n   */\n  _setTextureFrame(renderingStyleIndex = null, hue = null) {\n    const textureFrame = this.mainVesselTexture.frame.clone()\n\n    if (renderingStyleIndex !== null) {\n      // one diameter + tiny offset between 2 frames\n      textureFrame.x = VESSELS_BASE_RADIUS * 2 * renderingStyleIndex + renderingStyleIndex\n    }\n\n    if (hue !== null) {\n      let hueIncrement = hueToHueIncrement(hue)\n      if (hueIncrement === VESSELS_HUES_INCREMENTS_NUM - 1) {\n        hueIncrement = 0\n      }\n      textureFrame.y = hueIncrement * VESSELS_BASE_RADIUS * 2\n      if (hueIncrement > 0) {\n        textureFrame.y += hueIncrement\n      }\n    }\n\n    this.mainVesselTexture.frame = textureFrame\n    this.mainVesselTexture.update()\n  }\n\n  render() {\n    const numProps = this.spritesPropsCount\n    this.resizeSpritesPool()\n\n    for (let i = 0; i < numProps; i++) {\n      const sprite = this.stage.children[i]\n      const s = this.spritesProps.s[i]\n      sprite.setTransform(this.spritesProps.x[i], this.spritesProps.y[i], s, s)\n      sprite.alpha = this.spritesProps.a[i]\n    }\n\n    const numSprites = this.stage.children.length\n    for (let i = numProps; i < numSprites; i++) {\n      const sprite = this.stage.children[i]\n      sprite.x = -100\n    }\n  }\n\n  resizeSpritesPool() {\n    const numProps = this.spritesPropsCount\n    const prevNumSprites = this.stage.children.length\n    const delta = numProps - prevNumSprites\n    // console.log(prevNumSprites, '->', numProps, ' delta:', delta);\n\n    if (delta < -4999) {\n      // sprite needs to be removed. Do that progressively (max 100) to avoid UI lock\n      const toRemove = Math.min(100, -delta)\n      // console.log('removing ', toRemove);\n      for (let i = 0; i < toRemove; i++) {\n        this.stage.removeChildAt(0)\n      }\n    }\n\n    if (delta > 0) {\n      const toAdd = Math.max(5000, delta)\n      // console.log('adding ', toAdd);\n      this._addSprites(toAdd)\n    }\n  }\n\n  _addSprites(num) {\n    for (let i = 0; i < num; i++) {\n      const vessel = new PIXI.Sprite(this.mainVesselTexture)\n      vessel.anchor.x = 0.5\n      vessel.anchor.y = 0.5\n      // ParticlesContainer does not support .visible, so we just move the sprite out of the viewport\n      vessel.x = -100\n      // vessel.blendMode = PIXI.BLEND_MODES.SCREEN;\n      // vessel.filters=  [new PIXI.filters.BlurFilter(10,10)]\n      this.stage.addChild(vessel)\n    }\n  }\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport uniq from 'lodash/uniq'\nimport * as PIXI from 'pixi.js'\nimport { worldToPixels } from 'viewport-mercator-project'\nimport { BRUSH_RENDERING_STYLE, BRUSH_ZOOM_RENDERING_STYLE } from '../constants'\nimport { vesselSatisfiesFilters } from '../utils/heatmapTileData'\nimport HeatmapSubLayer from './HeatmapSubLayer'\n\n// This is a faster version of worldToPixels that omits pitch,\n// and ignores values from the matrix that are consistently = 0\nconst s = 1 / 1.5\nconst worldToPixelsSimple = (x, y, m) => {\n  const fx = s * (m[0] * x + m[4] * y + m[12])\n  const fy = s * (m[5] * y + m[13])\n  return [fx, fy]\n}\n\nclass HeatmapLayer extends React.Component {\n  componentDidMount() {\n    this._build()\n  }\n\n  componentWillUnmount() {\n    this._destroy()\n  }\n\n  componentDidUpdate() {\n    this._redraw()\n  }\n\n  componentWillReceiveProps(nextProps) {\n    if (nextProps.useRadialGradientStyle !== this.props.useRadialGradientStyle) {\n      this.setBrushZoomRenderingStyle(nextProps.useRadialGradientStyle)\n    }\n  }\n\n  _build() {\n    const { layer, rootStage, useRadialGradientStyle, customRenderingStyle } = this.props\n    this.subLayers = {}\n    this.renderingStyle =\n      layer.header && layer.header.rendering ? layer.header.rendering : customRenderingStyle\n\n    this.setBrushRenderingStyle(this.renderingStyle.style)\n    this.setBrushZoomRenderingStyle(useRadialGradientStyle)\n\n    this.stage = new PIXI.Container()\n\n    rootStage.addChild(this.stage)\n  }\n\n  setBrushRenderingStyle(style = BRUSH_RENDERING_STYLE.NORMAL) {\n    if (typeof style === 'string') {\n      this.brushRenderingStyle = BRUSH_RENDERING_STYLE[style.toUpperCase()]\n    } else {\n      this.brushRenderingStyle = style\n    }\n    this._setBrushRenderingStyleIndex()\n  }\n\n  setBrushZoomRenderingStyle(useRadialGradientStyle) {\n    this.brushZoomRenderingStyle =\n      useRadialGradientStyle === true\n        ? BRUSH_ZOOM_RENDERING_STYLE.RADIAL_GRADIENT\n        : BRUSH_ZOOM_RENDERING_STYLE.CIRCLE\n    this._setBrushRenderingStyleIndex()\n  }\n\n  _setBrushRenderingStyleIndex() {\n    // only NORMAL brush styles support different zoom styles\n    const cappedZoomRenderingStyle =\n      this.brushRenderingStyle === BRUSH_RENDERING_STYLE.NORMAL ? this.brushZoomRenderingStyle : 0\n    const newStyleIndex = this.brushRenderingStyle + cappedZoomRenderingStyle\n    if (newStyleIndex === this.renderingStyleIndex) {\n      return\n    }\n    this.renderingStyleIndex = newStyleIndex\n    Object.values(this.subLayers).forEach((subLayer) => {\n      subLayer.setRenderingStyleIndex(this.renderingStyleIndex)\n    })\n  }\n\n  _redraw() {\n    const { filters, baseTexture, layer } = this.props\n\n    if (\n      layer === null ||\n      layer === undefined ||\n      layer.tiles === undefined ||\n      layer.visible === false\n    ) {\n      this.stage.visible = false\n      return\n    }\n\n    this.stage.visible = true\n    this.stage.alpha = layer.opacity\n\n    const tiles = layer.tiles\n    const defaultHue = layer.hue\n    const allHuesToRender =\n      filters !== undefined && filters.length\n        ? filters\n            // pass is set to true by filterGroupActions when none of the filters fields\n            // in the filter group is supported by the layer headers\n            .filter((f) => f.pass !== true)\n            .map((f) => (f.hue === undefined ? '0' : f.hue.toString()))\n        : [defaultHue.toString()]\n    const currentlyUsedHues = Object.keys(this.subLayers)\n\n    // get all hues, old and new\n    const allHues = uniq(allHuesToRender.concat(currentlyUsedHues))\n\n    for (let i = 0; i < allHues.length; i++) {\n      const hue = allHues[i]\n      if (allHuesToRender.indexOf(hue) === -1) {\n        // not on new hues: delete sublayer\n        this._destroySubLayer(this.subLayers[hue])\n        delete this.subLayers[hue]\n        continue\n      }\n      if (currentlyUsedHues.indexOf(hue) === -1) {\n        // not on old hues: create sublayer\n        this.subLayers[hue] = this._createSublayer(baseTexture, this.renderingStyleIndex, hue)\n      }\n      this.subLayers[hue].clearSpriteProps()\n    }\n\n    if (!allHuesToRender.length) return\n    tiles.forEach((tile) => {\n      this._setSubLayersSpritePropsForTile({\n        data: tile.data,\n        numFilters: filters.length,\n        defaultHue,\n      })\n    })\n\n    allHuesToRender.forEach((hueToRender) => {\n      this.subLayers[hueToRender].render()\n    })\n  }\n\n  _setSubLayersSpritePropsForTile({ data, numFilters, defaultHue }) {\n    if (!data) {\n      return\n    }\n\n    const { startIndex, endIndex, viewport, filters, viewportLeft, viewportRight } = this.props\n\n    for (let timeIndex = startIndex; timeIndex < endIndex; timeIndex++) {\n      const frame = data[timeIndex]\n\n      if (!frame) continue\n\n      for (let index = 0, len = frame.worldX.length; index < len; index++) {\n        let hue\n        if (filters === undefined || !filters.length) {\n          hue = defaultHue\n        }\n        for (let fi = 0; fi < numFilters; fi++) {\n          const filter = filters[fi]\n          if (vesselSatisfiesFilters(frame, index, filter.filterValues)) {\n            hue = filter.hue\n            break\n          }\n        }\n\n        // no filter passes: bail\n        if (hue === undefined) {\n          continue\n        }\n\n        // wrap worldX when point crosses the antimeridian/dateline\n        // world points go from 0 to 512. There is no way to determine if worldX is on the \"wrong\" side\n        // of the antimeridian just by looking at its value (where with lat/lon we can simply look at -/+)\n        // Therefore we compare it to the viewport's left or right boundary, depending on what is currently\n        // \"the right side\" of the antimeridian\n        let worldX = frame.worldX[index]\n        if (viewportLeft > 0 && worldX < viewportLeft) {\n          // worldX is \"behind\" viewportLeft, which means it is \"on the right\" of the antimeridian\n          worldX += 512\n        } else if (viewportLeft < 0 && worldX > viewportRight) {\n          worldX -= 512\n        }\n\n        const scaledX = worldX * viewport.scale\n        const scaledY = frame.worldY[index] * viewport.scale\n        const mtx = viewport.pixelProjectionMatrix\n\n        const [x, y] =\n          viewport.pitch === 0\n            ? worldToPixelsSimple(scaledX, scaledY, mtx)\n            : worldToPixels([scaledX, scaledY], mtx)\n\n        if (x > -10 && x < viewport.width + 10 && y > -10 && y < viewport.height + 10) {\n          this.subLayers[hue].pushSpriteProps(\n            x,\n            y,\n            frame.opacity ? frame.opacity[index] : this.renderingStyle.defaultOpacity,\n            frame.radius ? frame.radius[index] : this.renderingStyle.defaultSize\n          )\n        }\n      }\n    }\n  }\n\n  _createSublayer(baseTexture, renderingStyleIndex, hue) {\n    const subLayer = new HeatmapSubLayer(\n      baseTexture,\n      renderingStyleIndex,\n      hue,\n      this.brushRenderingStyle === BRUSH_RENDERING_STYLE.BULLSEYE\n    )\n    this.stage.addChild(subLayer.stage)\n    return subLayer\n  }\n\n  _destroy() {\n    Object.values(this.subLayers).forEach(this._destroySubLayer.bind(this))\n    this.stage.destroy({ children: true })\n    const { rootStage } = this.props\n    rootStage.removeChild(this.stage)\n  }\n\n  _destroySubLayer(subLayer) {\n    this.stage.removeChild(subLayer.stage)\n    subLayer.destroy()\n  }\n\n  render() {\n    return null\n  }\n}\n\nHeatmapLayer.propTypes = {\n  layer: PropTypes.object,\n  rootStage: PropTypes.object,\n  viewport: PropTypes.object,\n  startIndex: PropTypes.number,\n  endIndex: PropTypes.number,\n  filters: PropTypes.array,\n  baseTexture: PropTypes.object,\n  useRadialGradientStyle: PropTypes.bool,\n  customRenderingStyle: PropTypes.object,\n  viewportLeft: PropTypes.number,\n  viewportRight: PropTypes.number,\n}\n\nexport default HeatmapLayer\n","/* global PIXI */\nimport 'pixi.js'\nimport React from 'react'\nimport PropTypes from 'prop-types'\nimport { worldToPixels } from 'viewport-mercator-project'\nimport { TRACKS_DOTS_STYLE_ZOOM_THRESHOLD } from '../config'\n\nclass TracksLayer extends React.Component {\n  componentDidMount() {\n    this._build()\n  }\n\n  componentDidUpdate() {\n    this._redraw()\n  }\n\n  _build() {\n    const { rootStage } = this.props\n    this.stage = new PIXI.Graphics()\n    this.stage.nativeLines = true\n    rootStage.addChild(this.stage)\n  }\n\n  clear() {\n    this.stage.clear()\n  }\n\n  _redraw() {\n    const { tracks, zoom, startIndex, endIndex, highlightTemporalExtentIndexes } = this.props\n\n    this.clear()\n    if (!tracks.length) {\n      return\n    }\n\n    const overInInner =\n      highlightTemporalExtentIndexes === null\n        ? undefined\n        : [\n            Math.max(startIndex, highlightTemporalExtentIndexes[0]),\n            Math.min(endIndex, highlightTemporalExtentIndexes[1]),\n          ]\n    const overExtent = overInInner && overInInner[1] - overInInner[0] > 0 ? overInInner : undefined\n\n    let n = 0 // eslint-disable-line no-unused-vars\n\n    const drawFishingCircles = zoom > TRACKS_DOTS_STYLE_ZOOM_THRESHOLD\n    const fishingCirclesRadius = 1 + (zoom - TRACKS_DOTS_STYLE_ZOOM_THRESHOLD) * 0.5\n    const drawOverTrack = overExtent !== undefined && overExtent[0] > 0 && overExtent[1] > 0\n\n    tracks.forEach((track) => {\n      n += this._drawTrack({\n        data: track.data,\n        startIndex,\n        endIndex,\n        drawFishingCircles,\n        fishingCirclesRadius,\n        color: `0x${track.color.substr(1)}`,\n        lineThickness: 1,\n        lineOpacity: 1,\n      })\n\n      // Draw the highlight over the track when the user hovers over the Timebar\n      if (drawOverTrack === true) {\n        n += this._drawTrack({\n          data: track.data,\n          startIndex: highlightTemporalExtentIndexes[0],\n          endIndex: highlightTemporalExtentIndexes[1],\n          drawFishingCircles,\n          fishingCirclesRadius,\n          color: '0xFFFFFF',\n          lineThickness: 2,\n          lineOpacity: 1,\n        })\n      }\n    })\n\n    // console.log(n);\n  }\n\n  /**\n   * Draws a single track (line + points)\n   *\n   * @param data track points data in 'playback form' (ie organized by days)\n   * @param extent extent, in day indices\n   * @param offset object containing info about the current situation of the map viewport, used to compute screen coords\n   * @param drawFishingCircles whether to draw fishing circles or not\n   * @param fishingCirclesRadius radius of the fishing circles\n   * @param color\n   * @param lineThickness\n   * @param lineOpacity\n   * @param worldOffset offset to use when a track crosses the dateline (ie 512 to add a second world to the right)\n   */\n  _drawTrack({\n    data,\n    startIndex,\n    endIndex,\n    drawFishingCircles,\n    fishingCirclesRadius,\n    color,\n    lineThickness,\n    lineOpacity,\n    worldOffset = 0,\n  }) {\n    const { viewport } = this.props\n\n    let n = 0\n    let prevSeries\n    let prevWorldX\n    let prevWorldY\n\n    const circlePoints = {\n      x: [],\n      y: [],\n    }\n\n    // line thickness is ignored in native mode anyways.\n    this.stage.lineStyle(lineThickness, color, lineOpacity)\n\n    let duplicateWorld = false\n\n    for (let timeIndex = startIndex; timeIndex < endIndex; timeIndex++) {\n      const frame = data[timeIndex]\n\n      if (!frame) continue\n\n      for (let i = 0, len = frame.series.length; i < len; i++) {\n        const currentSeries = frame.series[i]\n\n        n++\n\n        const worldX = frame.worldX[i] + worldOffset\n        const worldY = frame.worldY[i]\n\n        const [x, y] = worldToPixels(\n          [worldX * viewport.scale, worldY * viewport.scale],\n          viewport.pixelProjectionMatrix\n        )\n\n        if (prevSeries !== currentSeries) {\n          this.stage.moveTo(x, y)\n        }\n\n        // more than a  world of distance between two points = crossing the dateline\n        if (prevWorldX && Math.abs(worldX - prevWorldX) > 256) {\n          // worldOffset === 0 -> this is the first time drawTrack is called\n          if (worldOffset === 0) {\n            // set a flag to call drawTrack again at the end of the loop\n            duplicateWorld = true\n          }\n\n          // get Y coordinate where track intersects with dateline\n          const atDatelineWorldY = prevWorldY + (worldY - prevWorldY) / 2\n\n          // whether tracks crosses dateline from west to east\n          const isWestToEast = worldX - prevWorldX < 0\n\n          const worldXEnd = worldOffset + (512 - 0.000001)\n          const worldXStart = worldOffset\n\n          // get X coordinate ending at dateline\n          const atDatelineEndWorldX = isWestToEast ? worldXEnd : worldXStart\n\n          // get X coordinate starting at dateline\n          const atDatelineStartWorldX = isWestToEast ? worldXStart : worldXEnd\n\n          const [x1, y1] = worldToPixels(\n            [atDatelineEndWorldX * viewport.scale, atDatelineWorldY * viewport.scale],\n            viewport.pixelProjectionMatrix\n          )\n          this.stage.lineTo(x1, y1)\n          const [x2, y2] = worldToPixels(\n            [atDatelineStartWorldX * viewport.scale, atDatelineWorldY * viewport.scale],\n            viewport.pixelProjectionMatrix\n          )\n          this.stage.moveTo(x2, y2)\n        }\n\n        this.stage.lineTo(x, y)\n\n        if (drawFishingCircles && frame.hasFishing[i] === true) {\n          circlePoints.x.push(x)\n          circlePoints.y.push(y)\n        }\n\n        prevWorldX = worldX\n        prevWorldY = worldY\n        prevSeries = currentSeries\n      }\n    }\n\n    if (drawFishingCircles) {\n      this.stage.lineStyle(0)\n      this.stage.beginFill(color, 1)\n      for (let i = 0, circlesLength = circlePoints.x.length; i < circlesLength; i++) {\n        this.stage.drawCircle(circlePoints.x[i], circlePoints.y[i], fishingCirclesRadius)\n      }\n      this.stage.endFill()\n    }\n\n    if (duplicateWorld === true) {\n      ;[-512, 512].forEach((offset) => {\n        this._drawTrack({\n          worldOffset: offset,\n          data,\n          startIndex,\n          endIndex,\n          drawFishingCircles,\n          fishingCirclesRadius,\n          color,\n          lineThickness,\n          lineOpacity,\n        })\n      })\n    }\n    return n\n  }\n\n  render() {\n    return null\n  }\n}\n\nTracksLayer.propTypes = {\n  zoom: PropTypes.number,\n  rootStage: PropTypes.object,\n  viewport: PropTypes.object,\n  startIndex: PropTypes.number,\n  endIndex: PropTypes.number,\n  highlightTemporalExtentIndexes: PropTypes.array,\n  tracks: PropTypes.array,\n}\n\nexport default TracksLayer\n","import React, { Fragment } from 'react'\nimport * as PIXI from 'pixi.js'\nimport PropTypes from 'prop-types'\nimport { BaseControl } from 'react-map-gl'\nimport { lngLatToWorld } from 'viewport-mercator-project'\nimport {\n  hsvToRgb,\n  hueToRgbString,\n  hueIncrementToHue,\n  wrapHue,\n  VESSELS_HUES_INCREMENTS_NUM,\n} from '../utils/map-colors'\nimport {\n  VESSELS_BASE_RADIUS,\n  VESSELS_HEATMAP_BLUR_FACTOR,\n  ACTIVITY_HIGHLIGHT_HUE,\n  VESSELS_HEATMAP_DIMMING_ALPHA,\n  VESSELS_RADIAL_GRADIENT_STYLE_ZOOM_THRESHOLD,\n  VESSEL_CLICK_TOLERANCE_PX,\n} from '../config'\nimport HeatmapLayer from '../heatmap/HeatmapLayer'\nimport TracksLayer from '../tracks/TracksLayer'\n\nconst shouldUseRadialGradientStyle = (zoom) => zoom < VESSELS_RADIAL_GRADIENT_STYLE_ZOOM_THRESHOLD\n\n// builds a texture spritesheet containing\n// - the heatmap style (radial gradient)\n// - the circle style that is used at higher zoom levels\n// - the 'bullseye' style used for encounters\n// as well as a number of hues for each in a 2D grid.\n// Then, only the texture frame (mesh UVs) is modified depending on the zoom level,\n// in order not to have to recreate sprites\nconst getVesselTexture = (radius, blurFactor) => {\n  const tplCanvas = document.createElement('canvas')\n  const tplCtx = tplCanvas.getContext('2d')\n  const diameter = radius * 2\n  const NUM_STYLES = 3\n  tplCanvas.width = diameter * NUM_STYLES + (NUM_STYLES - 1) // + (NUM_STYLES - 1): tiny offset between 2 frames\n  tplCanvas.height = diameter * VESSELS_HUES_INCREMENTS_NUM + VESSELS_HUES_INCREMENTS_NUM\n\n  for (let hueIncrement = 0; hueIncrement < VESSELS_HUES_INCREMENTS_NUM; hueIncrement++) {\n    const y = diameter * hueIncrement + hueIncrement\n    const yCenter = y + radius\n\n    // heatmap style\n    let x = radius\n    const gradient = tplCtx.createRadialGradient(\n      x,\n      yCenter,\n      radius * blurFactor,\n      x,\n      yCenter,\n      radius\n    )\n    const hue = hueIncrementToHue(hueIncrement)\n    const rgbString = hueToRgbString(hue)\n    gradient.addColorStop(0, rgbString)\n\n    const rgbOuter = hsvToRgb(wrapHue(hue + 30), 80, 100)\n    gradient.addColorStop(1, `rgba(${rgbOuter.r}, ${rgbOuter.g}, ${rgbOuter.b}, 0)`)\n\n    tplCtx.fillStyle = gradient\n    tplCtx.fillRect(0, y, diameter, diameter)\n\n    // circle style\n    x += diameter + 1 // tiny offset between 2 frames\n    tplCtx.beginPath()\n    tplCtx.arc(x, yCenter, radius, 0, 2 * Math.PI, false)\n    tplCtx.fillStyle = rgbString\n    tplCtx.fill()\n\n    // bullseye style\n    x += diameter + 1\n    tplCtx.beginPath()\n    tplCtx.arc(x, yCenter, radius * 0.4, 0, 2 * Math.PI, false)\n    tplCtx.fillStyle = rgbString\n    tplCtx.fill()\n    tplCtx.beginPath()\n    tplCtx.arc(x, yCenter, radius * 0.95, 0, 2 * Math.PI, false)\n    tplCtx.lineWidth = 1\n    tplCtx.strokeStyle = rgbString\n    tplCtx.stroke()\n  }\n\n  return tplCanvas\n}\n\nclass ActivityLayers extends BaseControl {\n  state = {\n    pixiReady: false,\n  }\n\n  componentDidMount() {\n    this._build()\n    this.setState({\n      pixiReady: true,\n    })\n  }\n\n  componentWillUnmount() {\n    this._destroy()\n  }\n\n  componentWillReceiveProps(nextProps) {\n    this.props.exportNativeViewport(this._context.viewport)\n\n    if (\n      nextProps.viewport.width !== this.props.viewport.width ||\n      nextProps.viewport.height !== this.props.viewport.height\n    ) {\n      this._updateViewportSize(nextProps.viewport.width, nextProps.viewport.height)\n    }\n  }\n\n  _build() {\n    const { width, height } = this.props.viewport\n\n    this.pixi = new PIXI.Application({\n      width,\n      height,\n      transparent: true,\n      antialias: true,\n    })\n\n    this.renderer = this.pixi.renderer\n    this.canvas = this.pixi.view\n    this.canvas.style.position = 'absolute'\n\n    this.container.appendChild(this.canvas)\n\n    this.stage = this.pixi.stage\n\n    const baseTextureCanvas = getVesselTexture(VESSELS_BASE_RADIUS, VESSELS_HEATMAP_BLUR_FACTOR)\n    this.baseTexture = PIXI.Texture.fromCanvas(baseTextureCanvas)\n\n    this.heatmapStage = new PIXI.Container()\n    this.stage.addChild(this.heatmapStage)\n\n    this.pixi.ticker.add(this._onTick)\n  }\n\n  _destroy() {\n    this.pixi.destroy()\n  }\n\n  _updateViewportSize(viewportWidth, viewportHeight) {\n    this.renderer.resize(viewportWidth, viewportHeight)\n  }\n\n  toggleHeatmapDimming(dim) {\n    if (this.heatmapStage === undefined) {\n      return\n    }\n    if (dim === true) {\n      this.heatmapFadingIn = false\n    }\n    this.heatmapStage.alpha = dim === true ? VESSELS_HEATMAP_DIMMING_ALPHA : 1\n  }\n\n  onTouchStart = (event) => {\n    if (!event.touches.length) {\n      return\n    }\n    this.queryCoords(event.touches[0].clientX, event.touches[0].clientY)\n  }\n\n  onMouseMove = (event) => {\n    this.queryCoords(event.clientX, event.clientY)\n  }\n\n  queryCoords(x, y) {\n    // bail if all heatmap layers are set to non-interactive\n    if (this.props.heatmapLayers.every((l) => l.interactive !== true)) {\n      return\n    }\n\n    const { viewport } = this._context\n    const [longitude, latitude] = viewport.unproject([x, y])\n\n    let wrappedLongitude = longitude\n    if (wrappedLongitude > 180) {\n      wrappedLongitude -= 360\n    } else if (wrappedLongitude < -180) {\n      wrappedLongitude += 360\n    }\n\n    const [worldX, worldY] = lngLatToWorld([wrappedLongitude, latitude], 1)\n\n    const toleranceRadiusInWorldUnits = VESSEL_CLICK_TOLERANCE_PX / viewport.scale\n\n    this.props.queryHeatmapVessels(\n      {\n        longitude: wrappedLongitude,\n        latitude,\n        worldX,\n        worldY,\n        toleranceRadiusInWorldUnits,\n      },\n      this.props.temporalExtentIndexes\n    )\n  }\n\n  _onTick = () => {\n    if (this.heatmapFadingIn === true && this.heatmapStage.alpha < 1) {\n      this._heatmapFadeinStep()\n    }\n  }\n\n  _startHeatmapFadein() {\n    this.heatmapFadingIn = true\n    this.heatmapFadeinStartTimestamp = undefined\n  }\n\n  _heatmapFadeinStep() {\n    if (this.heatmapFadeinStartTimestamp === undefined) {\n      this.heatmapFadeinStartTimestamp = Date.now()\n    }\n    const timeElapsed = (Date.now() - this.heatmapFadeinStartTimestamp) / 1000\n    let alpha = this.heatmapStage.alpha + (1 - this.heatmapStage.alpha) * timeElapsed\n    if (alpha >= 1) {\n      alpha = 1\n      this.heatmapFadingIn = false\n    }\n    this.heatmapStage.alpha = alpha\n  }\n\n  // FIXME move to container?\n  _getHighlightData(highlightedVessels, highlightedClickedVessel, heatmapLayers) {\n    const hue = ACTIVITY_HIGHLIGHT_HUE\n    let highlightLayerData = {\n      id: '__HIGHLIGHT__',\n      visible: true,\n      opacity: 1,\n      hue: ACTIVITY_HIGHLIGHT_HUE,\n    }\n    let highlightFilters = []\n\n    if (\n      highlightedVessels !== undefined &&\n      highlightedVessels.layer !== undefined &&\n      highlightedVessels.foundVessels !== undefined &&\n      highlightedVessels.isEmpty !== true\n    ) {\n      const sourceLayer = heatmapLayers.find((l) => l.id === highlightedVessels.layer.id)\n      highlightLayerData = { highlightLayerData, ...sourceLayer }\n      highlightFilters = highlightedVessels.foundVessels.map((vessel) => ({\n        hue,\n        filterValues: {\n          series: [vessel.series],\n        },\n      }))\n    } else if (highlightedClickedVessel !== null) {\n      const sourceLayer = heatmapLayers.find((l) => l.id === highlightedClickedVessel.layer.id)\n      highlightLayerData = { highlightLayerData, ...sourceLayer }\n      highlightFilters = [\n        {\n          hue,\n          filterValues: {\n            series: [highlightedClickedVessel.id],\n          },\n        },\n      ]\n    }\n    return {\n      highlightLayerData,\n      highlightFilters,\n    }\n  }\n  _render() {\n    const {\n      zoom,\n      heatmapLayers,\n      temporalExtentIndexes,\n      highlightTemporalExtentIndexes,\n      highlightedVessels,\n      highlightedClickedVessel,\n      tracks,\n      leftWorldScaled,\n      rightWorldScaled,\n    } = this.props\n    const { viewport } = this._context\n    const { pixiReady } = this.state\n\n    const startIndex = temporalExtentIndexes[0]\n    const endIndex = temporalExtentIndexes[1]\n    const useRadialGradientStyle = shouldUseRadialGradientStyle(zoom)\n\n    if (highlightedVessels.isEmpty !== true) {\n      this.toggleHeatmapDimming(true)\n    }\n    if (highlightedVessels.isEmpty === true && tracks.length === 0) {\n      this._startHeatmapFadein()\n    }\n    if (this.renderer && this.renderer.gl && this.renderer.gl.getError !== undefined) {\n      const err = this.renderer.gl.getError()\n      if (err !== 0) console.log(err)\n    }\n\n    const { highlightLayerData, highlightFilters } = this._getHighlightData(\n      highlightedVessels,\n      highlightedClickedVessel,\n      heatmapLayers\n    )\n\n    return (\n      <div\n        ref={(ref) => {\n          this.container = ref\n        }}\n        style={{ position: 'absolute' }}\n        onMouseMove={this.onMouseMove}\n        onTouchStart={this.onTouchStart}\n      >\n        {pixiReady === true && (\n          <Fragment>\n            {heatmapLayers.map((layer) => (\n              <HeatmapLayer\n                key={layer.id}\n                layer={layer}\n                filters={layer.filters || []}\n                viewport={viewport}\n                startIndex={startIndex}\n                endIndex={endIndex}\n                baseTexture={this.baseTexture}\n                rootStage={this.heatmapStage}\n                useRadialGradientStyle={useRadialGradientStyle}\n                customRenderingStyle={{}}\n                viewportLeft={leftWorldScaled}\n                viewportRight={rightWorldScaled}\n              />\n            ))}\n            {this.stage !== undefined && (\n              <HeatmapLayer\n                key=\"highlighted\"\n                layer={highlightLayerData}\n                filters={highlightFilters}\n                viewport={viewport}\n                startIndex={startIndex}\n                endIndex={endIndex}\n                baseTexture={this.baseTexture}\n                rootStage={this.heatmapStage}\n                useRadialGradientStyle={useRadialGradientStyle}\n                customRenderingStyle={{ defaultOpacity: 1, defaultSize: 1 }}\n                viewportLeft={leftWorldScaled}\n                viewportRight={rightWorldScaled}\n              />\n            )}\n            {this.stage !== undefined && (\n              <TracksLayer\n                tracks={tracks}\n                viewport={viewport}\n                zoom={zoom}\n                startIndex={startIndex}\n                endIndex={endIndex}\n                highlightTemporalExtentIndexes={highlightTemporalExtentIndexes}\n                rootStage={this.stage}\n              />\n            )}\n          </Fragment>\n        )}\n      </div>\n    )\n  }\n}\n\nActivityLayers.propTypes = {\n  zoom: PropTypes.number,\n  heatmapLayers: PropTypes.array,\n  temporalExtentIndexes: PropTypes.array,\n  highlightTemporalExtentIndexes: PropTypes.array,\n  highlightedVessels: PropTypes.object,\n  highlightedClickedVessel: PropTypes.object,\n  tracks: PropTypes.array,\n  queryHeatmapVessels: PropTypes.func,\n  exportNativeViewport: PropTypes.func,\n  leftWorldScaled: PropTypes.number,\n  rightWorldScaled: PropTypes.number,\n}\n\nActivityLayers.contextTypes = {\n  viewport: PropTypes.object,\n}\n\nexport default ActivityLayers\n","import { connect } from 'react-redux'\nimport { createSelector } from 'reselect'\nimport convert from '@globalfishingwatch/map-convert'\nimport { exportNativeViewport } from '../glmap/viewport.actions'\nimport { getTemporalExtent, getHighlightTemporalExtent } from '../module/module.selectors'\nimport ActivityLayers from './ActivityLayers'\nimport { queryHeatmapVessels } from '../heatmap/heatmapTiles.actions'\nimport { MIN_FRAME_LENGTH_MS } from '../config'\n\nconst getHeatmapLayers = (state) => state.map.heatmap.heatmapLayers\n\nconst getHeatmapLayersAsArray = createSelector(\n  [getHeatmapLayers],\n  (heatmapLayers) => {\n    const a = Object.keys(heatmapLayers).map((id) => ({\n      ...heatmapLayers[id],\n    }))\n    // console.log(a)\n    return a\n  }\n)\n\nconst getTracks = (state) => state.map.tracks.data\n\nconst getTracksWithData = createSelector(\n  [getTracks],\n  (tracks) => {\n    const tracksWithData = tracks\n      .filter((t) => t.type !== 'geojson')\n      .filter((t) => t.data !== undefined)\n    return tracksWithData\n  }\n)\n\nconst getTemporalExtentIndexes = createSelector(\n  [getTemporalExtent],\n  (temporalExtent) => {\n    const startTimestamp = temporalExtent[0].getTime()\n    const endTimestamp = Math.max(\n      temporalExtent[1].getTime(),\n      temporalExtent[0].getTime() + MIN_FRAME_LENGTH_MS\n    )\n    const startIndex = convert.getOffsetedTimeAtPrecision(startTimestamp)\n    const endIndex = convert.getOffsetedTimeAtPrecision(endTimestamp)\n    return [startIndex, endIndex]\n  }\n)\n\nconst getHighlightTemporalExtentIndexes = createSelector(\n  [getHighlightTemporalExtent],\n  (highlightTemporalExtent) => {\n    if (\n      highlightTemporalExtent === undefined ||\n      highlightTemporalExtent === null ||\n      !highlightTemporalExtent.length\n    ) {\n      return null\n    }\n    const startTimestamp = highlightTemporalExtent[0].getTime()\n    const endTimestamp = highlightTemporalExtent[1].getTime()\n    const startIndex = convert.getOffsetedTimeAtPrecision(startTimestamp)\n    const endIndex = convert.getOffsetedTimeAtPrecision(endTimestamp)\n    return [startIndex, endIndex]\n  }\n)\n\nconst mapStateToProps = (state) => ({\n  highlightedVessels: state.map.heatmap.highlightedVessels,\n  highlightedClickedVessel: state.map.heatmap.highlightedClickedVessel,\n  viewport: state.map.viewport.viewport,\n  zoom: state.map.viewport.viewport.zoom,\n  heatmapLayers: getHeatmapLayersAsArray(state),\n  tracks: getTracksWithData(state),\n  leftWorldScaled: state.map.viewport.leftWorldScaled,\n  rightWorldScaled: state.map.viewport.rightWorldScaled,\n  temporalExtentIndexes: getTemporalExtentIndexes(state),\n  highlightTemporalExtentIndexes: getHighlightTemporalExtentIndexes(state),\n})\n\nconst mapDispatchToProps = (dispatch, ownProps) => ({\n  queryHeatmapVessels: (coords, temporalExtentIndexes) => {\n    dispatch(queryHeatmapVessels(coords, temporalExtentIndexes))\n  },\n  exportNativeViewport: (viewport) => {\n    dispatch(exportNativeViewport(viewport))\n  },\n})\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(ActivityLayers)\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport MapGL, { Popup, Marker } from 'react-map-gl'\nimport 'mapbox-gl/dist/mapbox-gl.css'\nimport { TILES_URL_NEEDING_AUTHENTICATION } from '../config'\nimport ActivityLayers from '../activity/ActivityLayers.container.js'\nimport styles from './map.css'\n\nconst PopupWrapper = (props) => {\n  const { latitude, longitude, children, closeButton, onClose } = props\n  return (\n    <Popup\n      latitude={latitude}\n      longitude={longitude}\n      closeButton={closeButton}\n      onClose={onClose}\n      anchor=\"bottom\"\n      offsetTop={-10}\n      tipSize={4}\n      closeOnClick={false}\n    >\n      {children}\n    </Popup>\n  )\n}\n\nPopupWrapper.propTypes = {\n  latitude: PropTypes.number.isRequired,\n  longitude: PropTypes.number.isRequired,\n  children: PropTypes.node.isRequired,\n  closeButton: PropTypes.bool.isRequired,\n  onClose: PropTypes.func,\n}\n\nPopupWrapper.defaultProps = {\n  onClose: () => {},\n}\n\nclass Map extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      mouseOver: true,\n    }\n    this._mapContainerRef = null\n  }\n\n  componentDidMount() {\n    if (this._mapContainerRef !== null) {\n      this.loadObserver()\n    }\n    if (this.glMap && this.props.setBounds !== undefined) {\n      const { _ne, _sw } = this.glMap.getBounds()\n      this.props.setBounds({\n        north: _ne.lat,\n        south: _sw.lat,\n        west: _sw.lng,\n        east: _ne.lng,\n      })\n    }\n  }\n\n  componentWillUnmount() {\n    if (this._containerResizeObserver) {\n      this._containerResizeObserver.disconnect()\n    }\n  }\n\n  loadObserver = async () => {\n    if ('ResizeObserver' in window === false) {\n      const module = await import('resize-observer-polyfill')\n      window.ResizeObserver = module.ResizeObserver || module.default\n    }\n    this._containerResizeObserver = new ResizeObserver(this.handleResizeObserver)\n    this._containerResizeObserver.observe(this._mapContainerRef)\n  }\n\n  handleResizeObserver = (entries) => {\n    const { width, height } = entries[0].contentRect\n    const { viewport, setViewport } = this.props\n\n    if (width !== viewport.width || height !== viewport.height) {\n      setViewport({\n        ...viewport,\n        width,\n        height,\n      })\n    }\n  }\n\n  onViewportChange = (viewport, interactionState) => {\n    const propsViewport = this.props.viewport\n    if (\n      propsViewport.latitude !== viewport.latitude ||\n      propsViewport.longitude !== viewport.longitude ||\n      propsViewport.zoom !== viewport.zoom ||\n      propsViewport.bearing !== viewport.bearing ||\n      propsViewport.pitch !== viewport.pitch\n    ) {\n      this.props.setViewport(viewport, interactionState)\n    }\n  }\n\n  onMapInteraction = (event, type) => {\n    this.props.mapInteraction(\n      type,\n      event.lngLat[1],\n      event.lngLat[0],\n      event.features,\n      this.glGetSource\n    )\n  }\n\n  onHover = (event) => {\n    this.onMapInteraction(event, 'hover')\n  }\n\n  onClick = (event) => {\n    this.onMapInteraction(event, 'click')\n  }\n\n  getRef = (ref) => {\n    if (ref !== null) {\n      this.glMap = ref.getMap()\n      this.glGetSource = this.glMap.getSource.bind(this.glMap)\n    }\n  }\n\n  getCursor = ({ isDragging }) => {\n    const { cursor } = this.props\n    if (cursor === null) {\n      return isDragging ? 'grabbing' : 'grab'\n    }\n    return cursor\n  }\n\n  transformRequest = (url, resourceType) => {\n    const { token } = this.props\n    if (token !== null && resourceType === 'Tile' && url.match(TILES_URL_NEEDING_AUTHENTICATION)) {\n      return {\n        url: url,\n        headers: { Authorization: 'Bearer ' + token },\n      }\n    }\n  }\n\n  render() {\n    const {\n      viewport,\n      maxZoom,\n      minZoom,\n      transitionEnd,\n      mapStyle,\n      onClosePopup,\n      clickPopup,\n      hoverPopup,\n      hasHeatmapLayers,\n      markers,\n      interactiveLayerIds,\n    } = this.props\n\n    return (\n      <div\n        id=\"map\"\n        className={styles.map}\n        ref={(ref) => {\n          this._mapContainerRef = ref\n        }}\n        onMouseLeave={() => {\n          this.setState({ mouseOver: false })\n        }}\n        onMouseEnter={() => {\n          this.setState({ mouseOver: true })\n        }}\n      >\n        <MapGL\n          {...viewport}\n          ref={this.getRef}\n          transformRequest={this.transformRequest}\n          onTransitionEnd={transitionEnd}\n          onHover={this.onHover}\n          onClick={this.onClick}\n          getCursor={this.getCursor}\n          mapStyle={mapStyle}\n          maxZoom={maxZoom}\n          minZoom={minZoom}\n          onViewportChange={this.onViewportChange}\n          interactiveLayerIds={interactiveLayerIds}\n          clickRadius={4}\n        >\n          {hasHeatmapLayers !== false && <ActivityLayers />}\n          {clickPopup !== undefined && clickPopup !== null && (\n            <PopupWrapper\n              latitude={clickPopup.latitude}\n              longitude={clickPopup.longitude}\n              closeButton\n              onClose={onClosePopup}\n            >\n              {clickPopup.content}\n            </PopupWrapper>\n          )}\n          {this.state.mouseOver === true && hoverPopup !== undefined && hoverPopup !== null && (\n            <PopupWrapper\n              latitude={hoverPopup.latitude}\n              longitude={hoverPopup.longitude}\n              closeButton={false}\n            >\n              {hoverPopup.content}\n            </PopupWrapper>\n          )}\n          {markers !== null &&\n            markers.length > 0 &&\n            markers.map((marker, i) => (\n              <Marker key={i} latitude={marker.latitude} longitude={marker.longitude}>\n                {marker.content}\n              </Marker>\n            ))}\n        </MapGL>\n        <div className={styles.googleLogo} />\n      </div>\n    )\n  }\n}\n\nMap.propTypes = {\n  token: PropTypes.string,\n  viewport: PropTypes.object.isRequired,\n  mapStyle: PropTypes.object.isRequired,\n  clickPopup: PropTypes.object,\n  hoverPopup: PropTypes.object,\n  maxZoom: PropTypes.number.isRequired,\n  minZoom: PropTypes.number.isRequired,\n  setViewport: PropTypes.func.isRequired,\n  setBounds: PropTypes.func,\n  mapInteraction: PropTypes.func,\n  onClosePopup: PropTypes.func,\n  transitionEnd: PropTypes.func,\n  cursor: PropTypes.string,\n  hasHeatmapLayers: PropTypes.bool.isRequired,\n  markers: PropTypes.arrayOf(\n    PropTypes.shape({\n      latitude: PropTypes.number.isRequired,\n      longitude: PropTypes.number.isRequired,\n      content: PropTypes.node,\n    })\n  ),\n  interactiveLayerIds: PropTypes.arrayOf(PropTypes.string),\n}\n\nMap.defaultProps = {\n  token: null,\n  clickPopup: null,\n  hoverPopup: null,\n  mapInteraction: () => {},\n  onClosePopup: () => {},\n  transitionEnd: () => {},\n  cursor: null,\n  markers: null,\n  interactiveLayerIds: null,\n  setBounds: undefined,\n}\n\nexport default Map\n","import { connect } from 'react-redux'\nimport { createSelector } from 'reselect'\nimport { fromJS } from 'immutable'\nimport { TRACKS_LAYER_IN_FRONT_OF_GROUP } from '../config'\nimport { closePopup } from '../module/module.actions.js'\nimport { getTracksStyles } from '../tracks/tracks.selectors.js'\nimport { mapInteraction } from './interaction.actions.js'\nimport { setBounds, setViewport, transitionEnd } from './viewport.actions.js'\nimport Map from './Map'\n\nconst getStaticLayers = (state) => state.map.style.staticLayers\nconst getHeatmapLayers = (state) => state.map.heatmap.heatmapLayers\nconst getInternalCursor = (state) => state.map.interaction.cursor\nconst getModuleCursor = (state) => state.map.module.cursor\n\nconst hasHeatmapLayers = createSelector(\n  [getHeatmapLayers],\n  (heatmapLayers) => {\n    return Object.keys(heatmapLayers).length > 0\n  }\n)\nconst getInteractiveLayerIds = createSelector(\n  [getStaticLayers],\n  // Note: here we assume that layer IDs provided with module match the GL layers that should\n  // be interactive or not, ie typically the fill layer if a label layer is present\n  (staticLayers) => {\n    return staticLayers.reduce((acc, layer) => {\n      if (!layer.interactive || !layer.visible) return acc\n      // We also need to check nested layers interactivity when custom gl layers are provided\n      if (layer.gl !== undefined) {\n        layer.gl.layers.forEach((glLayer, index) => {\n          // layers.length === 1 is used to ensure when parent layer is marked as interactive we have to\n          // have at least one interactive sublayer, then checked eah one individually\n          if (\n            layer.gl.layers.length === 1 ||\n            (glLayer.metadata !== undefined && glLayer.metadata['gfw:interactive'] === true)\n          ) {\n            const glLayerId = glLayer.id || index > 0 ? `${layer.id}-${index}` : layer.id\n            acc.push(glLayerId)\n          }\n        })\n      } else {\n        acc.push(layer.id)\n      }\n      return acc\n    }, [])\n  }\n)\n\nconst getMapStyles = (state) => state.map.style.mapStyle\nconst getMapStyle = createSelector(\n  [getMapStyles, getTracksStyles],\n  (mapStyles, trackStyles) => {\n    if (!trackStyles) return mapStyles\n\n    const currentLayerGroups = mapStyles\n      .toJS()\n      .layers.filter((l) => l.metadata !== undefined)\n      .map((l) => l.metadata['mapbox:group'])\n    const trackLayersIndex = currentLayerGroups.lastIndexOf(TRACKS_LAYER_IN_FRONT_OF_GROUP) + 1\n\n    let finalMapStyles = mapStyles.mergeIn(['sources'], trackStyles.sources)\n    let mapStylesLayers = mapStyles.get('layers')\n    trackStyles.layers.forEach((trackLayer, i) => {\n      mapStylesLayers = mapStylesLayers.insert(trackLayersIndex + i, fromJS(trackLayer))\n    })\n    finalMapStyles = finalMapStyles.set('layers', mapStylesLayers)\n    return finalMapStyles\n  }\n)\n\nconst getCursor = createSelector(\n  [getInternalCursor, getModuleCursor],\n  (internalCursor, moduleCursor) => {\n    if (moduleCursor !== null) {\n      return moduleCursor\n    }\n    return internalCursor\n  }\n)\nconst mapStateToProps = (state, ownProps) => ({\n  viewport: state.map.viewport.viewport,\n  maxZoom: state.map.viewport.maxZoom,\n  minZoom: state.map.viewport.minZoom,\n  cursor: getCursor(state),\n  token: state.map.module.token,\n  mapStyle: getMapStyle(state),\n  hasHeatmapLayers: hasHeatmapLayers(state),\n  interactiveLayerIds: getInteractiveLayerIds(state),\n})\n\nconst mapDispatchToProps = (dispatch) => ({\n  setViewport: (viewport, interactionState) => {\n    dispatch(setViewport(viewport, interactionState))\n  },\n  setBounds: (bounds) => {\n    dispatch(setBounds(bounds))\n  },\n  mapInteraction: (type, lat, long, features, cluster, glGetSource) => {\n    dispatch(mapInteraction(type, lat, long, features, cluster, glGetSource))\n  },\n  transitionEnd: () => {\n    dispatch(transitionEnd())\n  },\n  onClosePopup: () => {\n    dispatch(closePopup())\n  },\n})\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(Map)\n","import { fromJS } from 'immutable'\nimport uniq from 'lodash/uniq'\nimport GL_STYLE from './gl-styles/style.json'\nimport {\n  SET_MAP_STYLE,\n  MARK_CARTO_LAYERS_AS_INSTANCIATED,\n  INIT_MAP_STYLE,\n  SET_STATIC_LAYERS,\n  SET_BASEMAP_LAYERS,\n} from './style.actions'\n\nconst attributions = uniq(\n  Object.keys(GL_STYLE.sources)\n    .map((sourceKey) => GL_STYLE.sources[sourceKey].attribution)\n    .filter((source) => source !== undefined)\n)\n\nexport const setLayerStyleDefaults = (layer) => {\n  if (layer.layout === undefined) {\n    layer.layout = {}\n  }\n  if (layer.paint === undefined) {\n    layer.paint = {}\n  }\n  if (layer.metadata === undefined) {\n    layer.metadata = {}\n  }\n  // initialize time filter for time-filterable layers\n  if (layer.metadata['gfw:temporal'] === true) {\n    const temporalField =\n      layer.metadata['gfw:temporalField'] === undefined\n        ? 'timestamp'\n        : layer.metadata['gfw:temporalField']\n    layer.filter = ['all', ['>', temporalField, 0], ['<', temporalField, 999999999999]]\n  }\n\n  if (layer.metadata['mapbox:group'] === undefined) {\n    layer.metadata['mapbox:group'] = 'temporal'\n  }\n\n  // set all layers to not visible except layers explicitely marked as visible (default basemap)\n  if (layer.layout.visibility !== 'visible') {\n    layer.layout.visibility = 'none'\n  }\n  return layer\n}\n\nconst setStyleDefaults = (style) => {\n  style.layers.forEach((layer) => {\n    setLayerStyleDefaults(layer)\n  })\n  return style\n}\n\nconst initialState = {\n  mapStyle: fromJS(setStyleDefaults(GL_STYLE)),\n  cartoLayersInstanciated: [],\n  staticLayers: [],\n  basemapLayers: [],\n  attributions,\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case INIT_MAP_STYLE: {\n      const newMapStyle = state.mapStyle.setIn(['glyphs'], action.payload.glyphsPath)\n      return { ...state, mapStyle: newMapStyle }\n    }\n    case SET_MAP_STYLE: {\n      return { ...state, mapStyle: action.payload }\n    }\n    case SET_STATIC_LAYERS: {\n      return { ...state, staticLayers: action.payload }\n    }\n    case SET_BASEMAP_LAYERS: {\n      return { ...state, basemapLayers: action.payload }\n    }\n    case MARK_CARTO_LAYERS_AS_INSTANCIATED: {\n      const cartoLayersInstanciated = [...state.cartoLayersInstanciated, ...action.payload]\n      return { ...state, cartoLayersInstanciated }\n    }\n    default:\n      return state\n  }\n}\n","// This utility looks at GeoJSON features and returns the predominant geometry type\n\nconst TYPES = [\n  { gl: 'line', geoJSON: ['LineString', 'MultiLineString'] },\n  { gl: 'fill', geoJSON: ['Polygon', 'MultiPolygon'] },\n  { gl: 'circle', geoJSON: ['Point', 'MultiPoint'] },\n]\n\nexport default (geoJSON) => {\n  // collect all geoJSON geom types\n  const allGeoJSONTypes = geoJSON.features.map((feature) => {\n    const geom = feature.geometry\n    if (geom === undefined) {\n      return null\n    }\n    return geom.type\n  })\n\n  // collect number of geometries by GL geom types\n  const numByGLType = TYPES.map((type) => {\n    let num = 0\n    allGeoJSONTypes.forEach((geoJSONType) => {\n      if (type.geoJSON.indexOf(geoJSONType) > -1) {\n        num++\n      }\n    })\n    return { gl: type.gl, num }\n  })\n\n  // get feature types with the higher count\n  let glType = 'fill'\n  let glTypeMax = 0\n  numByGLType.forEach((t) => {\n    if (t.num > glTypeMax) {\n      glType = t.gl\n      glTypeMax = t.num\n    }\n  })\n\n  return glType\n}\n","import { fromJS } from 'immutable'\nimport convert from '@globalfishingwatch/map-convert'\nimport uniq from 'lodash/uniq'\nimport throttle from 'lodash/throttle'\nimport { hexToRgb } from '../utils/map-colors'\nimport { STATIC_LAYERS_CARTO_ENDPOINT, STATIC_LAYERS_CARTO_TILES_ENDPOINT } from '../config'\nimport { CUSTOM_LAYERS_SUBTYPES, GL_TRANSPARENT } from '../constants'\nimport GL_STYLE from './gl-styles/style.json'\nimport { setLayerStyleDefaults } from './style.reducer.js'\nimport getMainGeomType from '../utils/getMainGeomType'\n\nexport const INIT_MAP_STYLE = 'INIT_MAP_STYLE'\nexport const SET_MAP_STYLE = 'SET_MAP_STYLE'\nexport const MARK_CARTO_LAYERS_AS_INSTANCIATED = 'MARK_CARTO_LAYERS_AS_INSTANCIATED'\nexport const SET_STATIC_LAYERS = 'SET_STATIC_LAYERS'\nexport const SET_BASEMAP_LAYERS = 'SET_BASEMAP_LAYERS'\n\nconst setDefaultVectorTiles = (currentSource, refLayerUrl) => {\n  if (currentSource.type !== 'vector') {\n    return currentSource\n  }\n  const tiles = currentSource.tiles\n  const refLayerUrls = refLayerUrl === undefined ? [] : [refLayerUrl]\n\n  const newTiles =\n    tiles !== undefined && tiles.length > 0 ? uniq([...refLayerUrls, ...tiles]) : refLayerUrls\n  return {\n    ...currentSource,\n    tiles: newTiles,\n  }\n}\n\nexport const initStyle = ({ glyphsPath }) => ({\n  type: INIT_MAP_STYLE,\n  payload: {\n    glyphsPath,\n  },\n})\n\nconst setMapStyle = (style) => ({\n  type: SET_MAP_STYLE,\n  payload: style,\n})\n\nconst setStyleTemporalExtent = (dispatch, getState, temporalExtent, applyToThrottled = false) => {\n  const state = getState().map.style\n  let style = state.mapStyle\n  const currentStyle = style.toJS()\n  const glLayers = currentStyle.layers\n\n  let start = Math.round(temporalExtent[0].getTime() / 1000)\n  let end = Math.round(temporalExtent[1].getTime() / 1000)\n\n  // TEMPORARY, remove later - temporal layers points should have a timestamp, this is legacy\n  // logic for legacy encounters layer that only have a 'timeIndex'\n  const startIndex = convert.getOffsetedTimeAtPrecision(temporalExtent[0].getTime())\n  const endIndex = convert.getOffsetedTimeAtPrecision(temporalExtent[1].getTime())\n\n  for (let i = 0; i < glLayers.length; i++) {\n    const glLayer = glLayers[i]\n    if (glLayer.metadata === undefined || glLayer.metadata['gfw:temporal'] !== true) {\n      continue\n    }\n\n    if (\n      (applyToThrottled === true && glLayer.metadata['gfw:temporal:throttled'] !== true) ||\n      (applyToThrottled === false && glLayer.metadata['gfw:temporal:throttled'] === true)\n    ) {\n      continue\n    }\n\n    // if layer is temporal, a filter must always be preset on the style.json object\n    // because each layer can have a different time field to be filtered\n    const currentFilter = style.getIn(['layers', i, 'filter']).toJS()\n    if (currentFilter === null) {\n      throw new Error('filter must be preset on style.json for temporal layer: ', glLayer.id)\n    }\n\n    // TEMPORARY, remove later - temporal layers points should have a timestamp, this is legacy\n    // logic for legacy encounters layer that only have a 'timeIndex'\n    const isLegacy = glLayer.metadata && glLayer.metadata['gfw:temporalField'] === 'timeIndex'\n    currentFilter[1][2] = isLegacy ? startIndex : start\n    currentFilter[2][2] = isLegacy ? endIndex : end\n    style = style.setIn(['layers', i, 'filter'], fromJS(currentFilter))\n  }\n  dispatch(setMapStyle(style))\n}\n\nconst applyTemporalExtentThrottled = throttle((dispatch, getState, temporalExtent) => {\n  setStyleTemporalExtent(dispatch, getState, temporalExtent, true)\n}, 400)\n\nexport const applyTemporalExtent = (temporalExtent) => (dispatch, getState) => {\n  setStyleTemporalExtent(dispatch, getState, temporalExtent)\n  applyTemporalExtentThrottled(dispatch, getState, temporalExtent)\n}\n\nconst applyLayerExpressions = (style, refLayer, currentGlLayer, glLayerIndex) => {\n  let newStyle = style\n  const currentStyle = style.toJS()\n  const glType = currentGlLayer.type\n  const defaultStyles = currentStyle.metadata['gfw:styles']\n  const metadata = currentGlLayer.metadata\n  ;['selected', 'highlighted'].forEach((styleType) => {\n    // get selectedFeatures or highlightedFeatures\n    const features = refLayer[`${styleType}Features`]\n    const refLayerStyle = features && features.style ? features.style[glType] : {}\n    const hasFeatures = features !== null && features !== undefined && features.values.length > 0\n    const applyStyleToAllFeatures = refLayer[styleType]\n\n    const defaultStyle = defaultStyles[styleType][glType] || {}\n    const layerStyle =\n      (metadata && metadata['gfw:styles'] && metadata['gfw:styles'][styleType]) || {}\n    const allPaintProperties = { ...defaultStyle, ...layerStyle, ...refLayerStyle }\n\n    if (Object.keys(allPaintProperties).length) {\n      // go through each applicable gl paint property\n      Object.keys(allPaintProperties).forEach((glPaintProperty) => {\n        const selectedValue = allPaintProperties[glPaintProperty][0]\n        const fallbackValue = allPaintProperties[glPaintProperty][1]\n        const paintOrLayout = ['icon-size', 'icon-image'].includes(glPaintProperty)\n          ? 'layout'\n          : 'paint'\n        let glPaintFinalValue\n        if (\n          hasFeatures === false &&\n          applyStyleToAllFeatures !== true &&\n          applyStyleToAllFeatures !== false\n        ) {\n          // style reset when no features filter is declared and neither is applyAll\n          const originalLayerStyle = GL_STYLE.layers.find((l) => l.id === currentGlLayer.id)\n\n          if (originalLayerStyle !== undefined) {\n            // for reset: do not repaint with default style when layer as a custom main color property\n            if (\n              currentGlLayer.metadata &&\n              currentGlLayer.metadata['gfw:mainColorPaintProperty'] === glPaintProperty\n            ) {\n              glPaintFinalValue = null\n            } else {\n              glPaintFinalValue = originalLayerStyle[paintOrLayout][glPaintProperty]\n            }\n          } else {\n            // this will happen when no style exist in the original definition (ie custom layers)\n            // in this case set glPaintFinalValue to null and we'll just skip applying\n            // any selected/highlighted style for this layer\n            glPaintFinalValue = null\n          }\n        } else if (applyStyleToAllFeatures === true || applyStyleToAllFeatures === false) {\n          glPaintFinalValue = applyStyleToAllFeatures === true ? selectedValue : fallbackValue\n        } else {\n          let layerColorRgbString = ''\n          if (refLayer.color !== null && refLayer.color !== undefined) {\n            const layerColorRgb = hexToRgb(refLayer.color)\n            layerColorRgbString = `${layerColorRgb.r},${layerColorRgb.g},${layerColorRgb.b}`\n          }\n          glPaintFinalValue = [\n            'match',\n            ['get', features.field],\n            features.values,\n            typeof selectedValue !== 'string'\n              ? selectedValue\n              : selectedValue.replace('$REFLAYER_COLOR_RGB', layerColorRgbString),\n            typeof fallbackValue !== 'string'\n              ? fallbackValue\n              : fallbackValue.replace('$REFLAYER_COLOR_RGB', layerColorRgbString),\n          ]\n        }\n\n        if (glPaintFinalValue !== undefined && glPaintFinalValue !== null) {\n          newStyle = newStyle.setIn(\n            ['layers', glLayerIndex, paintOrLayout, glPaintProperty],\n            glPaintFinalValue\n          )\n        }\n      })\n    }\n  })\n  return newStyle\n}\n\nconst toggleLayerVisibility = (style, refLayer, glLayerIndex) => {\n  const visibility = refLayer.visible === true ? 'visible' : 'none'\n  return style.setIn(['layers', glLayerIndex, 'layout', 'visibility'], visibility)\n}\n\nconst updateGLLayer = (style, glLayerId, refLayer) => {\n  const currentStyle = style.toJS()\n  const currentStyleLayers = currentStyle.layers\n  let newStyle = style\n\n  const glLayerIndex = currentStyleLayers.findIndex((l) => l.id === glLayerId)\n  const glLayer = currentStyleLayers.find((l) => l.id === glLayerId)\n\n  // visibility\n  newStyle = toggleLayerVisibility(newStyle, refLayer, glLayerIndex)\n\n  if (refLayer.isBasemap === true) {\n    return newStyle\n  }\n\n  const refLayerOpacity = refLayer.opacity === undefined ? 1 : refLayer.opacity\n\n  // color/opacity\n  switch (glLayer.type) {\n    case 'fill': {\n      newStyle = newStyle\n        .setIn(['layers', glLayerIndex, 'paint', 'fill-opacity'], refLayerOpacity)\n        .setIn(['layers', glLayerIndex, 'paint', 'fill-outline-color'], refLayer.color)\n        .setIn(['layers', glLayerIndex, 'paint', 'fill-color'], GL_TRANSPARENT)\n      break\n    }\n    case 'line': {\n      const color = refLayer.color || (glLayer.paint && glLayer.paint['line-color'])\n      newStyle = newStyle\n        .setIn(['layers', glLayerIndex, 'paint', 'line-opacity'], refLayerOpacity)\n        .setIn(['layers', glLayerIndex, 'paint', 'line-color'], color)\n      break\n    }\n    case 'symbol': {\n      if (glLayer.metadata && glLayer.metadata['gfw:isLabel'] === true) {\n        const parentLayerIsVisible =\n          newStyle.getIn(['layers', glLayerIndex, 'layout', 'visibility']) === 'visible'\n        const labelsVisibility =\n          parentLayerIsVisible && refLayer.showLabels === true ? 'visible' : 'none'\n        newStyle = newStyle.setIn(\n          ['layers', glLayerIndex, 'layout', 'visibility'],\n          labelsVisibility\n        )\n        if (refLayer.showLabels !== true) {\n          break\n        }\n      }\n      newStyle = newStyle.setIn(['layers', glLayerIndex, 'paint', 'text-opacity'], refLayerOpacity)\n\n      if (refLayer.color !== undefined) {\n        newStyle = newStyle.setIn(['layers', glLayerIndex, 'paint', 'text-color'], refLayer.color)\n      }\n      break\n    }\n    // Event layers and custom layers with point geom types\n    case 'circle': {\n      newStyle = newStyle\n        .setIn(['layers', glLayerIndex, 'paint', 'circle-opacity'], refLayerOpacity)\n        .setIn(['layers', glLayerIndex, 'paint', 'circle-stroke-opacity'], refLayerOpacity)\n\n      if (refLayer.color !== undefined) {\n        const colorPaintProperty =\n          glLayer && glLayer.metadata && glLayer.metadata['gfw:mainColorPaintProperty']\n            ? glLayer.metadata['gfw:mainColorPaintProperty']\n            : 'circle-color'\n        newStyle = newStyle.setIn(\n          ['layers', glLayerIndex, 'paint', colorPaintProperty],\n          refLayer.color\n        )\n      }\n      break\n    }\n    case 'raster': {\n      newStyle = newStyle.setIn(\n        ['layers', glLayerIndex, 'paint', 'raster-opacity'],\n        refLayerOpacity\n      )\n      break\n    }\n    default: {\n      break\n    }\n  }\n\n  newStyle = applyLayerExpressions(newStyle, refLayer, glLayer, glLayerIndex)\n\n  return newStyle\n}\n\nconst addCustomGLLayer = (subtype, layerId, url, data) => (dispatch, getState) => {\n  const state = getState()\n  let style = state.map.style.mapStyle\n  const currentStyle = style.toJS()\n\n  // add source if it doesn't exist yet\n  if (currentStyle.sources[layerId] === undefined) {\n    const source = { type: subtype }\n    if (subtype === CUSTOM_LAYERS_SUBTYPES.geojson) {\n      source.data = data\n    } else if (subtype === CUSTOM_LAYERS_SUBTYPES.raster) {\n      source.tiles = [url]\n      source.tileSize = 256\n    }\n    style = style.setIn(['sources', layerId], fromJS(source))\n  }\n\n  if (currentStyle.layers.find((glLayer) => glLayer.id === layerId) === undefined) {\n    const glType = subtype === CUSTOM_LAYERS_SUBTYPES.geojson ? getMainGeomType(data) : subtype\n    const glLayer = fromJS({\n      id: layerId,\n      source: layerId,\n      type: glType,\n      layout: {},\n      paint: {},\n    })\n    const layerIndex =\n      subtype === CUSTOM_LAYERS_SUBTYPES.raster\n        ? // if raster, put at index of last raster layer except labels\n          currentStyle.layers.length -\n          1 -\n          currentStyle.layers\n            .filter((l) => l.id !== 'labels')\n            .reverse()\n            .findIndex((l) => l.type === 'raster')\n        : currentStyle.layers.length - 1\n    style = style.set('layers', style.get('layers').splice(layerIndex, 0, glLayer))\n  }\n\n  dispatch(setMapStyle(style))\n}\n\nconst updateWorkspaceGLLayers = (workspaceGLLayers) => (dispatch, getState) => {\n  const state = getState()\n  let style = state.map.style.mapStyle\n\n  workspaceGLLayers.forEach((workspaceGLLayer) => {\n    const { id, gl } = workspaceGLLayer\n    const finalSource = setDefaultVectorTiles(gl.source, workspaceGLLayer.url)\n    style = style.setIn(['sources', id], fromJS(finalSource))\n\n    const existingLayerIds = style\n      .get('layers')\n      .toJS()\n      .map((l) => l.id)\n    const layersToAdd = gl.layers.filter((layer, index) => {\n      const layerId = layer.id || index > 0 ? `${id}-${index}` : id\n      return !existingLayerIds.includes(layerId)\n    })\n    layersToAdd.forEach((layerToAdd, index) => {\n      // doesn't add a sufix in the first elements but it will for the following ones\n      let layerToAddId = layerToAdd.id || index > 0 ? `${id}-${index}` : id\n      const defaultGlLayer = setLayerStyleDefaults(layerToAdd)\n\n      const glLayer = {\n        ...defaultGlLayer,\n        id: layerToAddId,\n        source: id,\n      }\n\n      // set source-layer - defaults to source id\n      if (gl.source.type === 'vector') {\n        const sourceLayer =\n          layerToAdd['source-layer'] === undefined ? id : layerToAdd['source-layer']\n        glLayer['source-layer'] = sourceLayer\n      }\n\n      // find correct z-index\n      const existingLayers = style.get('layers')\n      const newLayerGroup = glLayer.metadata['mapbox:group']\n      const newLayerIndex = existingLayers.findLastIndex((l) => {\n        return newLayerGroup === l.toJS().metadata['mapbox:group']\n      })\n      style = style.set('layers', existingLayers.splice(newLayerIndex, 0, fromJS(glLayer)))\n    })\n  })\n\n  dispatch(setMapStyle(style))\n  dispatch(applyTemporalExtent(state.map.module.temporalExtent))\n}\n\nconst getCartoLayerInstanciatePromise = ({ sourceId, sourceCartoSQL }) => {\n  const mapConfig = { layers: [{ id: sourceId, options: { sql: sourceCartoSQL } }] }\n  const mapConfigURL = encodeURIComponent(JSON.stringify(mapConfig))\n  const cartoAnonymousMapUrl = STATIC_LAYERS_CARTO_ENDPOINT.replace('$MAPCONFIG', mapConfigURL)\n\n  return new Promise((resolve) => {\n    fetch(cartoAnonymousMapUrl)\n      .then((res) => {\n        if (res.status >= 400) {\n          console.warn(`loading of layer failed ${sourceId}`)\n          Promise.reject()\n          return null\n        }\n        return res.json()\n      })\n      .then((data) => {\n        resolve({\n          layergroupid: data.layergroupid,\n          sourceId,\n        })\n      })\n      .catch((err) => {\n        console.warn(err)\n      })\n  })\n}\n\nconst instanciateCartoLayers = (layers) => (dispatch, getState) => {\n  dispatch({\n    type: MARK_CARTO_LAYERS_AS_INSTANCIATED,\n    payload: layers.map((layer) => layer.sourceId),\n  })\n  const cartoLayersPromises = layers.map((layer) => getCartoLayerInstanciatePromise(layer))\n  const cartoLayersPromisesPromise = Promise.all(cartoLayersPromises.map((p) => p.catch((e) => e)))\n  cartoLayersPromisesPromise\n    .then((instanciatedCartoLayers) => {\n      let style = getState().map.style.mapStyle\n      const currentStyle = style.toJS()\n      instanciatedCartoLayers.forEach((cartoLayer) => {\n        const tilesURL = STATIC_LAYERS_CARTO_TILES_ENDPOINT.replace(\n          '$LAYERGROUPID',\n          cartoLayer.layergroupid\n        )\n\n        // replace gl source with a new source that use tiles provided by Carto anonymous maps API\n        const newSourceId = `${cartoLayer.sourceId}-instanciated`\n        style = style.setIn(\n          ['sources', newSourceId],\n          fromJS({\n            type: 'vector',\n            tiles: [tilesURL],\n          })\n        )\n\n        style = style.deleteIn(['sources', cartoLayer.sourceId])\n\n        // change source in all layers that are using it (generally polygon + labels)\n        currentStyle.layers.forEach((glLayer, glLayerIndex) => {\n          if (glLayer.source === cartoLayer.sourceId) {\n            style = style.setIn(['layers', glLayerIndex, 'source'], newSourceId)\n            style = style.setIn(['layers', glLayerIndex, 'metadata', 'gfw:id'], cartoLayer.sourceId)\n            const refLayer = layers.find((l) => l.refLayer.id === cartoLayer.sourceId).refLayer\n            style = updateGLLayer(style, glLayer.id, refLayer)\n          }\n        })\n      })\n\n      dispatch(setMapStyle(style))\n    })\n    .catch((err) => {\n      console.warn(err)\n    })\n}\n\nexport const commitStyleUpdates = (staticLayers, basemapLayers) => (dispatch, getState) => {\n  // Store a copy of static and basemap layers. This is not used directly by\n  // the Map component which only needs a prepared style object\n  dispatch({\n    type: SET_STATIC_LAYERS,\n    payload: staticLayers,\n  })\n  dispatch({\n    type: SET_BASEMAP_LAYERS,\n    payload: basemapLayers,\n  })\n\n  const layers = [...staticLayers, ...basemapLayers.map((bl) => ({ ...bl, isBasemap: true }))]\n\n  const currentGLSources = getState().map.style.mapStyle.toJS().sources\n\n  // collect layers declared in workspace but not in original gl style\n  const workspaceGLLayers = layers.filter((layer) => layer.gl !== undefined)\n\n  if (workspaceGLLayers.length) {\n    // Adds the gl layers again in case the source is a dynamic geojson source\n    dispatch(updateWorkspaceGLLayers(workspaceGLLayers))\n  }\n\n  // instanciate custom layers if needed\n  const customLayers = layers.filter(\n    (layer) => layer.isCustom === true && currentGLSources[layer.id] === undefined\n  )\n  if (customLayers.length) {\n    customLayers.forEach((layer) => {\n      dispatch(addCustomGLLayer(layer.subtype, layer.id, layer.url, layer.data))\n    })\n  }\n\n  const state = getState().map.style\n  let style = state.mapStyle\n  const currentStyle = style.toJS()\n  const glLayers = currentStyle.layers\n  const glSources = currentStyle.sources\n\n  const cartoLayersToInstanciate = []\n\n  // update source when needed\n  staticLayers.forEach((refLayer) => {\n    const sourceId = refLayer.id\n    if (currentGLSources[sourceId] !== undefined && refLayer.visible === true) {\n      if (refLayer.data !== undefined) {\n        style = style.setIn(['sources', sourceId, 'data'], fromJS(refLayer.data))\n      }\n      if (refLayer.url !== undefined) {\n        const newSource = setDefaultVectorTiles(currentGLSources[sourceId], refLayer.url)\n        style = style.setIn(['sources', sourceId], fromJS(newSource))\n      }\n    }\n  })\n\n  for (let i = 0; i < glLayers.length; i++) {\n    const glLayer = glLayers[i]\n    const sourceId = glLayer.source\n    const glSource = glSources[sourceId]\n    const layerId = (glLayer.metadata !== undefined && glLayer.metadata['gfw:id']) || sourceId\n\n    const refLayer = layers.find((l) => l.id === layerId)\n\n    if (refLayer === undefined) {\n      if (glLayer.type !== 'background') {\n        // console.warn('gl layer does not exists in workspace', glLayer);\n      }\n      continue\n    }\n\n    // check if layer is served from Carto, which means we need to instanciate it first\n    // TODO BUG: check if layer is not instanciatING too\n    const sourceCartoSQL = glSource.metadata !== undefined && glSource.metadata['gfw:carto-sql']\n    if (sourceCartoSQL !== false && sourceCartoSQL !== undefined) {\n      // only if layer is visible and has not been instanciated yet\n      const cartoLayerInstanciated = state.cartoLayersInstanciated.indexOf(sourceId) > -1\n      if (\n        refLayer.visible === true &&\n        !cartoLayerInstanciated &&\n        !cartoLayersToInstanciate.find((l) => l.sourceId === sourceId)\n      ) {\n        cartoLayersToInstanciate.push({ sourceId, sourceCartoSQL, refLayer })\n      }\n      continue\n    }\n\n    style = updateGLLayer(style, glLayer.id, refLayer)\n  }\n\n  if (cartoLayersToInstanciate.length) {\n    dispatch(instanciateCartoLayers(cartoLayersToInstanciate))\n  }\n\n  dispatch(setMapStyle(style))\n}\n","import FlyToInterpolator from 'react-map-gl/dist/esm/utils/transition/viewport-fly-to-interpolator'\nimport { easeCubic } from 'd3-ease'\nimport { MIN_ZOOM_LEVEL, MAX_ZOOM_LEVEL } from '../config'\nimport { TRANSITION_TYPE } from '../constants'\nimport {\n  SET_BOUNDS,\n  SET_VIEWPORT,\n  UPDATE_VIEWPORT,\n  SET_ZOOM_INCREMENT,\n  SET_MOUSE_LAT_LONG,\n  TRANSITION_END,\n  SET_NATIVE_VIEWPORT,\n} from './viewport.actions'\n\nexport const TRANSITION_DURATION = 500\n\nconst DEFAULT_TRANSITION = {\n  transitionDuration: TRANSITION_DURATION,\n  transitionInterpolator: new FlyToInterpolator(),\n  transitionEasing: easeCubic,\n}\n\nconst initialState = {\n  viewport: {\n    latitude: 0,\n    longitude: 0,\n    zoom: 3,\n    bearing: 0,\n    pitch: 0,\n    width: 1000,\n    height: 800,\n    bounds: {},\n  },\n  maxZoom: MAX_ZOOM_LEVEL,\n  minZoom: MIN_ZOOM_LEVEL,\n  prevZoom: 3,\n  currentTransition: null,\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case SET_VIEWPORT: {\n      return {\n        ...state,\n        viewport: action.payload,\n        canZoomIn: action.payload.zoom < state.maxZoom,\n        canZoomOut: action.payload.zoom > state.minZoom,\n        prevZoom: state.viewport.zoom,\n      }\n    }\n\n    case SET_BOUNDS: {\n      return {\n        ...state,\n        bounds: action.payload,\n      }\n    }\n\n    case UPDATE_VIEWPORT: {\n      const viewport = { ...state.viewport, ...action.payload }\n      return {\n        ...state,\n        viewport,\n        prevZoom: viewport.zoom,\n      }\n    }\n\n    case SET_ZOOM_INCREMENT: {\n      const currentZoom = state.viewport.zoom\n      const zoom = Math.min(\n        state.maxZoom,\n        action.payload.zoom || currentZoom + action.payload.increment\n      )\n      const viewport = {\n        ...state.viewport,\n        ...DEFAULT_TRANSITION,\n        zoom,\n        latitude:\n          action.payload.latitude === null ? state.viewport.latitude : action.payload.latitude,\n        longitude:\n          action.payload.longitude === null ? state.viewport.longitude : action.payload.longitude,\n      }\n      return {\n        ...state,\n        viewport,\n        canZoomIn: zoom < state.maxZoom,\n        canZoomOut: zoom > state.minZoom,\n        prevZoom: state.viewport.zoom,\n        currentTransition: TRANSITION_TYPE.ZOOM,\n      }\n    }\n\n    case SET_MOUSE_LAT_LONG: {\n      return { ...state, mouseLatLong: action.payload }\n    }\n\n    case TRANSITION_END: {\n      return { ...state, currentTransition: null }\n    }\n\n    case SET_NATIVE_VIEWPORT: {\n      return { ...state, ...action.payload }\n    }\n\n    default:\n      return state\n  }\n}\n","import { compose, createStore, applyMiddleware } from 'redux'\nimport thunk from 'redux-thunk'\n\nimport { TRANSITION_DURATION } from '../glmap/viewport.reducer'\nimport { fitToBounds as fitToBoundsAction, transitionEnd } from '../glmap/viewport.actions'\n\nlet composeEnhancers = compose\nif (\n  (process.env.MAP_REDUX_REMOTE_DEBUG || process.env.REACT_APP_MAP_REDUX_REMOTE_DEBUG) &&\n  process.env.NODE_ENV === 'development'\n) {\n  const composeWithDevTools = require('remote-redux-devtools').composeWithDevTools\n  composeEnhancers = composeWithDevTools({\n    name: 'Map module',\n    realtime: true,\n    hostname: 'localhost',\n    port: 8000,\n    maxAge: 30,\n    stateSanitizer: (state) => ({ ...state, map: { ...state.map, heatmap: 'NOT_SERIALIZED' } }),\n  })\n}\n\nconst store = createStore(() => {}, {}, composeEnhancers(applyMiddleware(thunk)))\n\nexport const targetMapVessel = (id) => {\n  const track = store.getState().map.tracks.data.find((t) => t.id === id.toString())\n  store.dispatch(fitToBoundsAction(track.geoBounds))\n\n  return track.timelineBounds\n}\nexport const fitToBounds = (bounds) => {\n  store.dispatch(fitToBoundsAction(bounds))\n  setTimeout(() => {\n    // needed as the transition end is not being called on first fitToBounds trigger\n    if (store.getState().map.viewport.currentTransition !== null) {\n      store.dispatch(transitionEnd())\n    }\n  }, TRANSITION_DURATION + 1)\n}\n\nexport default store\n","import tbbox from '@turf/bbox'\nimport { targetMapVessel } from '../store'\n\nimport {\n  getTilePromises,\n  getCleanVectorArrays,\n  groupData,\n  addTracksPointsRenderingData,\n  getTracksPlaybackData,\n} from '../utils/heatmapTileData'\nimport { startLoader, completeLoader } from '../module/module.actions'\n\nexport const ADD_TRACK = 'ADD_TRACK'\nexport const UPDATE_TRACK = 'UPDATE_TRACK'\nexport const REMOVE_TRACK = 'REMOVE_TRACK'\n\nconst getTrackDataParsed = (geojson) => {\n  const time = { start: Infinity, end: 0 }\n  if (geojson && geojson.features) {\n    geojson.features.forEach((feature) => {\n      const hasTimes =\n        feature.properties &&\n        feature.properties.coordinateProperties &&\n        feature.properties.coordinateProperties.times &&\n        feature.properties.coordinateProperties.times.length > 0\n      if (hasTimes) {\n        feature.properties.coordinateProperties.times.forEach((datetime) => {\n          if (datetime < time.start) {\n            time.start = datetime\n          } else if (datetime > time.end) {\n            time.end = datetime\n          }\n        })\n      }\n    })\n  }\n  return {\n    geojson,\n    timelineBounds: [time.start, time.end],\n  }\n}\n\nconst getTrackBounds = (geojson) => {\n  const bounds = tbbox(geojson)\n  return {\n    minLat: bounds[3],\n    minLng: bounds[0],\n    maxLat: bounds[1],\n    maxLng: bounds[2],\n  }\n}\n\n// Deprecated tracks format parsing\nconst getOldTrackBoundsFormat = (data, addOffset = false) => {\n  const time = {\n    start: Infinity,\n    end: 0,\n  }\n  const geo = {\n    minLat: Infinity,\n    maxLat: -Infinity,\n    minLng: Infinity,\n    maxLng: -Infinity,\n  }\n  for (let i = 0, length = data.datetime.length; i < length; i++) {\n    const datetime = data.datetime[i]\n    if (datetime < time.start) {\n      time.start = datetime\n    } else if (datetime > time.end) {\n      time.end = datetime\n    }\n\n    const lat = data.latitude[i]\n    if (lat < geo.minLat) {\n      geo.minLat = lat\n    } else if (lat > geo.maxLat) {\n      geo.maxLat = lat\n    }\n\n    let lng = data.longitude[i]\n    if (addOffset === true) {\n      if (lng < 0) {\n        lng += 360\n      }\n    }\n    if (lng < geo.minLng) {\n      geo.minLng = lng\n    } else if (lng > geo.maxLng) {\n      geo.maxLng = lng\n    }\n  }\n\n  // track crosses the antimeridian\n  if (geo.maxLng - geo.minLng > 350 && addOffset === false) {\n    return getOldTrackBoundsFormat(data, true)\n  }\n\n  return {\n    time: [time.start, time.end],\n    geo,\n  }\n}\n\nfunction loadTrack(track) {\n  return (dispatch, getState) => {\n    const { id, url, type, fitBoundsOnLoad, layerTemporalExtents, color, data } = track\n    const state = getState()\n    if (state.map.tracks.data.find((t) => t.id === id)) {\n      return\n    }\n\n    const payload = {\n      id,\n      url,\n      type,\n      color,\n      fitBoundsOnLoad,\n    }\n    const trackHasData = track.data !== undefined && track.data !== null\n    const trackHasUrl = url !== undefined && url !== null && url !== ''\n    if (trackHasData) {\n      payload.data = data\n      payload.geoBounds = getTrackBounds(data)\n    }\n    dispatch({ type: ADD_TRACK, payload })\n\n    if (trackHasData || !trackHasUrl) {\n      return\n    }\n\n    const loaderID = startLoader(dispatch, state)\n    if (type !== 'geojson') {\n      // Deprecated tracks format logic to be deleted some day\n      const token = state.map.module.token\n\n      const promises = getTilePromises(url, token, layerTemporalExtents)\n\n      Promise.all(promises.map((p) => p.catch((e) => e))).then((rawTileData) => {\n        const cleanData = getCleanVectorArrays(rawTileData)\n\n        if (!cleanData.length) {\n          return\n        }\n        const rawTrackData = groupData(cleanData, [\n          'latitude',\n          'longitude',\n          'datetime',\n          'series',\n          'weight',\n          'sigma',\n        ])\n\n        const vectorArray = addTracksPointsRenderingData(rawTrackData)\n        const bounds = getOldTrackBoundsFormat(rawTrackData)\n\n        dispatch({\n          type: UPDATE_TRACK,\n          payload: {\n            id,\n            data: getTracksPlaybackData(vectorArray),\n            geoBounds: bounds.geo,\n            timelineBounds: bounds.time,\n          },\n        })\n        dispatch(completeLoader(loaderID))\n      })\n    } else {\n      fetch(url)\n        .then((res) => {\n          if (res.status >= 400) throw new Error(res.statusText)\n          return res.json()\n        })\n        .then((data) => {\n          const { geojson, timelineBounds } = getTrackDataParsed(data)\n          const geoBounds = getTrackBounds(data)\n          dispatch({\n            type: UPDATE_TRACK,\n            payload: {\n              id,\n              data: geojson,\n              geoBounds,\n              timelineBounds,\n            },\n          })\n          if (fitBoundsOnLoad) {\n            targetMapVessel(id)\n          }\n        })\n        .catch((err) => console.warn(err))\n        .finally(() => dispatch(completeLoader(loaderID)))\n    }\n  }\n}\n\nconst removeTrack = (trackId) => ({\n  type: REMOVE_TRACK,\n  payload: {\n    trackId,\n  },\n})\n\nexport const updateTracks = (newTracks = []) => (dispatch, getState) => {\n  const prevTracks = getState().map.tracks.data\n  // add and update layers\n  if (newTracks) {\n    newTracks.forEach((newTrack) => {\n      const trackId = newTrack.id\n      const prevTrack = prevTracks.find((t) => t.id === trackId)\n      if (prevTrack === undefined) {\n        dispatch(loadTrack(newTrack))\n      } else if (prevTrack.color !== newTrack.color) {\n        dispatch({\n          type: UPDATE_TRACK,\n          payload: {\n            id: newTrack.id,\n            color: newTrack.color,\n          },\n        })\n      }\n    })\n  }\n\n  // clean up unused tracks\n  prevTracks.forEach((prevTrack) => {\n    if (!newTracks || !newTracks.find((t) => t.id === prevTrack.id)) {\n      dispatch(removeTrack(prevTrack.id))\n    }\n  })\n}\n","import PropTypes from 'prop-types'\n\nconst withReducerPropTypes = (name, propTypesSchema) => (reducer) => {\n  if (process.env.NODE_ENV === 'development') {\n    return (state, action) => {\n      const result = reducer(state, action)\n      PropTypes.checkPropTypes(propTypesSchema, result, 'reducer', name)\n\n      return result\n    }\n  }\n  return reducer\n}\n\nexport default withReducerPropTypes\n","import PropTypes from 'prop-types'\nimport withReducerTypes from '../utils/withReducerTypes'\nimport {\n  INIT_MODULE,\n  SET_TEMPORAL_EXTENT,\n  SET_HIGHLIGHT_TEMPORAL_EXTENT,\n  START_LOADER,\n  COMPLETE_LOADER,\n  SET_MODULE_CURSOR,\n} from './module.actions'\n\nconst initialState = {\n  loaders: null,\n  token: undefined,\n  temporalExtent: [new Date(1970), new Date()],\n  highlightTemporalExtent: null,\n  cursor: null,\n  onViewportChange: undefined,\n  onHover: undefined,\n  onClick: undefined,\n  onLoadStart: undefined,\n  onLoadComplete: undefined,\n  onClosePopup: undefined,\n  onAttributionsChange: undefined,\n}\n\nconst moduleReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case INIT_MODULE: {\n      return {\n        ...state,\n        ...action.payload,\n      }\n    }\n\n    case SET_TEMPORAL_EXTENT: {\n      return {\n        ...state,\n        temporalExtent: action.payload,\n      }\n    }\n\n    case SET_HIGHLIGHT_TEMPORAL_EXTENT: {\n      return {\n        ...state,\n        highlightTemporalExtent: action.payload,\n      }\n    }\n\n    case START_LOADER: {\n      const loaders = state.loaders !== null ? [...state.loaders] : []\n      loaders.push(action.payload)\n      return { ...state, loaders }\n    }\n\n    case COMPLETE_LOADER: {\n      const loaders = [...state.loaders]\n      const loaderIndex = loaders.findIndex((l) => l === action.payload)\n      loaders.splice(loaderIndex, 1)\n      return { ...state, loaders }\n    }\n\n    case SET_MODULE_CURSOR: {\n      return { ...state, cursor: action.payload }\n    }\n\n    default:\n      return state\n  }\n}\n\nconst moduleTypes = {\n  loaders: PropTypes.arrayOf(PropTypes.number),\n  token: PropTypes.string,\n  temporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  onViewportChange: PropTypes.func,\n  onHover: PropTypes.func,\n  onClick: PropTypes.func,\n  onLoadStart: PropTypes.func,\n  onLoadComplete: PropTypes.func,\n  onClosePopup: PropTypes.func,\n  onAttributionsChange: PropTypes.func,\n}\n\nexport default withReducerTypes('module', moduleTypes)(moduleReducer)\n","import PropTypes from 'prop-types'\nimport { trackTypes } from '../proptypes/tracks'\nimport withReducerTypes from '../utils/withReducerTypes'\n\nimport { ADD_TRACK, UPDATE_TRACK, REMOVE_TRACK } from './tracks.actions'\n\nconst initialState = {\n  data: [],\n}\n\nconst tracksReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case ADD_TRACK: {\n      const data = [...state.data, action.payload]\n      return { ...state, data }\n    }\n\n    case UPDATE_TRACK: {\n      const trackData = action.payload\n      const data = state.data.map((track) => {\n        if (track.id !== trackData.id) return track\n        return {\n          ...track,\n          ...trackData,\n        }\n      })\n      return { ...state, data }\n    }\n\n    case REMOVE_TRACK: {\n      const removedTrackId = action.payload.trackId\n      const data = state.data.filter((track) => track.id !== removedTrackId)\n      return { ...state, data }\n    }\n\n    default:\n      return state\n  }\n}\n\nconst tracksTypes = {\n  data: PropTypes.arrayOf(\n    PropTypes.exact({\n      ...trackTypes,\n      data: PropTypes.object,\n      timelineBounds: PropTypes.array,\n      geoBounds: PropTypes.exact({\n        minLat: PropTypes.number,\n        minLng: PropTypes.number,\n        maxLat: PropTypes.number,\n        maxLng: PropTypes.number,\n      }),\n    })\n  ),\n}\n\nexport default withReducerTypes('tracks', tracksTypes)(tracksReducer)\n","import difference from 'lodash/difference'\nimport {\n  INIT_HEATMAP_LAYERS,\n  UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES,\n  ADD_HEATMAP_LAYER,\n  UPDATE_HEATMAP_LAYER_STYLE,\n  REMOVE_HEATMAP_LAYER,\n  ADD_REFERENCE_TILE,\n  UPDATE_HEATMAP_TILE,\n  RELEASE_HEATMAP_TILES,\n  HIGHLIGHT_VESSELS,\n  UPDATE_LOADED_TILES,\n  HIGHLIGHT_CLICKED_VESSEL,\n  CLEAR_HIGHLIGHT_CLICKED_VESSEL,\n} from './heatmap.actions'\n\nconst initialState = {\n  // a dict of heatmap layers (key is layer id)\n  // each containing data, url, tiles, visibleTemporalExtentsIndices\n  heatmapLayers: {},\n  // store a list of tiles currently visible in the map\n  // those are necessary when adding a new layer to know which tiles need to be loaded\n  referenceTiles: [],\n  highlightedVessels: { isEmpty: true },\n  highlightedClickedVessel: null,\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case INIT_HEATMAP_LAYERS: {\n      return Object.assign({}, state, { heatmapLayers: action.payload })\n    }\n\n    case UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES: {\n      const heatmapLayers = state.heatmapLayers\n      heatmapLayers[action.payload.layerId].visibleTemporalExtentsIndices =\n        action.payload.newVisibleTemporalExtentsIndices\n\n      // also removing indices within each tile\n      // adding is done after tile has actually loaded\n      heatmapLayers[action.payload.layerId].tiles.forEach((tile) => {\n        tile.temporalExtentsIndicesLoaded = difference(\n          tile.temporalExtentsIndicesLoaded,\n          action.payload.indicesRemoved\n        )\n      })\n      return { ...state, heatmapLayers }\n    }\n\n    case ADD_HEATMAP_LAYER: {\n      const heatmapLayers = Object.assign({}, state.heatmapLayers, {\n        [action.payload.id]: {\n          tiles: [],\n          ...action.payload,\n        },\n      })\n      return Object.assign({}, state, { heatmapLayers })\n    }\n\n    case UPDATE_HEATMAP_LAYER_STYLE: {\n      const newLayer = action.payload\n      const layer = { ...state.heatmapLayers[newLayer.id], ...newLayer }\n      const heatmapLayers = { ...state.heatmapLayers, [newLayer.id]: layer }\n      return { ...state, heatmapLayers }\n    }\n\n    case REMOVE_HEATMAP_LAYER: {\n      const heatmapLayers = Object.assign({}, state.heatmapLayers)\n      delete heatmapLayers[action.payload.id]\n      return Object.assign({}, state, { heatmapLayers })\n    }\n\n    case ADD_REFERENCE_TILE: {\n      return Object.assign({}, state, { referenceTiles: [...state.referenceTiles, action.payload] })\n    }\n\n    case UPDATE_HEATMAP_TILE: {\n      const layerId = action.payload.layerId\n      const newTile = action.payload.tile\n      const layer = { ...state.heatmapLayers[layerId] }\n      let layerTiles = [...layer.tiles]\n      const tileIndex = layerTiles.findIndex((t) => t.uid === newTile.uid)\n      if (tileIndex === -1) {\n        layerTiles.push(newTile)\n      } else {\n        layerTiles = [\n          ...layerTiles.slice(0, tileIndex),\n          newTile,\n          ...layerTiles.slice(tileIndex + 1),\n        ]\n      }\n      layer.tiles = layerTiles\n      const heatmapLayers = { ...state.heatmapLayers, [layerId]: layer }\n      return { ...state, heatmapLayers }\n    }\n\n    case RELEASE_HEATMAP_TILES: {\n      const uids = action.payload\n\n      // remove tiles\n      const layerIds = Object.keys(state.heatmapLayers)\n      const heatmapLayers = { ...state.heatmapLayers }\n      layerIds.forEach((layerId) => {\n        const prevLayer = { ...heatmapLayers[layerId] }\n        uids.forEach((tileUid) => {\n          const releasedTileIndex = prevLayer.tiles.findIndex((tile) => tile.uid === tileUid)\n          if (releasedTileIndex > -1) {\n            // console.log('releasing', layerId, tileUid);\n            prevLayer.tiles.splice(releasedTileIndex, 1)\n          }\n        })\n      })\n\n      // remove reference tiles\n      let referenceTiles = [...state.referenceTiles]\n      uids.forEach((tileUid) => {\n        const releasedRefTileIndex = referenceTiles.findIndex((tile) => tile.uid === tileUid)\n        if (releasedRefTileIndex > -1) {\n          referenceTiles = [\n            ...referenceTiles.slice(0, releasedRefTileIndex),\n            ...referenceTiles.slice(releasedRefTileIndex + 1),\n          ]\n        }\n      })\n\n      return { ...state, heatmapLayers, referenceTiles }\n    }\n\n    case UPDATE_LOADED_TILES: {\n      const newHeatmapLayers = { ...state.heatmapLayers }\n      return { ...state, heatmapLayers: newHeatmapLayers }\n    }\n\n    case HIGHLIGHT_VESSELS: {\n      return Object.assign({}, state, { highlightedVessels: action.payload })\n    }\n\n    case HIGHLIGHT_CLICKED_VESSEL: {\n      return { ...state, highlightedClickedVessel: action.payload }\n    }\n\n    case CLEAR_HIGHLIGHT_CLICKED_VESSEL: {\n      return { ...state, highlightedClickedVessel: null }\n    }\n\n    default:\n      return state\n  }\n}\n","import uniq from 'lodash/uniq'\nimport {\n  SET_CURRENTLY_VISIBLE_TILES,\n  SET_CURRENTLY_LOADED_TILES,\n  SET_CURRENTLY_SWAPPED_TILE_UIDS,\n  MARK_TILES_UIDS_AS_LOADED,\n  RELEASE_MARKED_TILES_UIDS,\n} from './heatmapTiles.actions'\n\nconst initialState = {\n  currentVisibleTiles: [],\n  currentLoadedTiles: [],\n  currentToLoadTileUids: [],\n  currentToReleaseTileUids: [],\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case SET_CURRENTLY_VISIBLE_TILES: {\n      const currentVisibleTiles = [].concat(action.payload)\n      return { ...state, currentVisibleTiles }\n    }\n\n    case SET_CURRENTLY_LOADED_TILES: {\n      const currentLoadedTiles = [].concat(action.payload)\n      return { ...state, currentLoadedTiles }\n    }\n\n    case SET_CURRENTLY_SWAPPED_TILE_UIDS: {\n      const currentToLoadTileUids = uniq(\n        state.currentToLoadTileUids.concat(action.payload.tilesToLoadUids)\n      )\n      const currentToReleaseTileUids = uniq(\n        state.currentToReleaseTileUids.concat(action.payload.tilesToReleaseUids)\n      )\n      // clean to load tiles of tiles that needs to be released\n      const newToLoadTilesUids = currentToLoadTileUids.filter(\n        (tileUid) => currentToReleaseTileUids.indexOf(tileUid) === -1\n      )\n      return { ...state, currentToLoadTileUids: newToLoadTilesUids, currentToReleaseTileUids }\n    }\n\n    case MARK_TILES_UIDS_AS_LOADED: {\n      const currentToLoadTileUids = state.currentToLoadTileUids\n      const tileUidsMarkedAsLoaded = action.payload\n      const newCurrentToLoadTileUids = currentToLoadTileUids.filter(\n        (tileUid) => tileUidsMarkedAsLoaded.indexOf(tileUid) === -1\n      )\n      return { ...state, currentToLoadTileUids: newCurrentToLoadTileUids }\n    }\n\n    case RELEASE_MARKED_TILES_UIDS: {\n      return { ...state, currentToReleaseTileUids: [] }\n    }\n\n    default:\n      return state\n  }\n}\n","// TODO MAP MODULE remove whole reducer\nimport { SET_MAP_CURSOR } from './interaction.actions'\n\nconst initialState = {\n  cursor: 'progress',\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case SET_MAP_CURSOR: {\n      return { ...state, cursor: action.payload }\n    }\n    default:\n      return state\n  }\n}\n","import { combineReducers } from 'redux'\n\nimport ModuleReducer from '../module/module.reducer'\nimport TracksReducer from '../tracks/tracks.reducer'\nimport HeatmapReducer from '../heatmap/heatmap.reducer'\nimport HeatmapTilesReducer from '../heatmap/heatmapTiles.reducer'\nimport ViewportReducer from '../glmap/viewport.reducer'\nimport StyleReducer from '../glmap/style.reducer'\nimport InteractionReducer from '../glmap/interaction.reducer'\n\nconst mapReducer = combineReducers({\n  module: ModuleReducer,\n  tracks: TracksReducer,\n  heatmap: HeatmapReducer,\n  heatmapTiles: HeatmapTilesReducer,\n  style: StyleReducer,\n  viewport: ViewportReducer,\n  interaction: InteractionReducer,\n})\n\nexport default mapReducer\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { combineReducers } from 'redux'\nimport { Provider } from 'react-redux'\nimport throttle from 'lodash/throttle'\nimport { trackTypes } from './proptypes/tracks'\nimport { heatmapLayerTypes, basemapLayerTypes, staticLayerTypes } from './proptypes/layers'\nimport { viewportTypes, popupTypes } from './proptypes/shared'\n\nimport Map from './glmap/Map.container'\nimport {\n  initModule,\n  setTemporalExtent,\n  setHighlightTemporalExtent,\n  setCursor,\n} from './module/module.actions'\nimport { updateViewport, transitionToZoom } from './glmap/viewport.actions'\nimport { initStyle, commitStyleUpdates, applyTemporalExtent } from './glmap/style.actions'\nimport { updateTracks } from './tracks/tracks.actions'\nimport { updateHeatmapLayers, updateLayerLoadTemporalExtents } from './heatmap/heatmap.actions'\n\nimport store from './store'\nimport mapReducers from './store/reducers'\n\nconst mapReducer = combineReducers({\n  map: mapReducers,\n})\n\nstore.replaceReducer(mapReducer)\n\nconst throttleApplyTemporalExtent = throttle((temporalExtent) => {\n  store.dispatch(applyTemporalExtent(temporalExtent))\n  store.dispatch(setTemporalExtent(temporalExtent))\n}, 16)\n\nconst updateViewportFromIncomingProps = (incomingViewport) => {\n  store.dispatch(\n    updateViewport({\n      latitude: incomingViewport.center[0],\n      longitude: incomingViewport.center[1],\n      zoom: incomingViewport.zoom,\n    })\n  )\n}\n\nclass MapModule extends React.Component {\n  state = {\n    initialized: false,\n    error: null,\n    errorInfo: null,\n  }\n\n  componentDidCatch(error, errorInfo) {\n    console.log(error, errorInfo)\n    this.setState({\n      error: error,\n      errorInfo: errorInfo,\n    })\n  }\n\n  componentDidMount() {\n    // First trigger synchronous actions that should happen before any map render\n    // At the end of this, set a flag to allow map rendering\n\n    if (this.props.viewport !== undefined) {\n      updateViewportFromIncomingProps(this.props.viewport)\n    }\n\n    // TODO\n    if (this.props.glyphsPath !== null) {\n      store.dispatch(\n        initStyle({\n          glyphsPath: this.props.glyphsPath,\n          // TODO apply URL updates here\n        })\n      )\n    }\n\n    if (this.props.onAttributionsChange !== undefined) {\n      this.props.onAttributionsChange(store.getState().map.style.attributions)\n    }\n\n    if (store && store.getState().map.module.token === undefined) {\n      store.dispatch(\n        initModule({\n          token: this.props.token,\n          autoClusterZoom: this.props.autoClusterZoom,\n          isCluster: this.props.isCluster,\n          onViewportChange: this.props.onViewportChange,\n          onHover: this.props.onHover,\n          onClick: this.props.onClick,\n          onLoadStart: this.props.onLoadStart,\n          onLoadComplete: this.props.onLoadComplete,\n          onClosePopup: this.props.onClosePopup,\n          onAttributionsChange: this.props.onAttributionsChange,\n        })\n      )\n    }\n\n    if (this.props.highlightTemporalExtent !== null && this.props.highlightTemporalExtent.length) {\n      store.dispatch(setHighlightTemporalExtent(this.props.highlightTemporalExtent))\n    }\n\n    if (\n      (this.props.basemapLayers !== null && this.props.basemapLayers.length) ||\n      (this.props.staticLayers !== null && this.props.staticLayers.length)\n    ) {\n      store.dispatch(\n        commitStyleUpdates(this.props.staticLayers || [], this.props.basemapLayers || [])\n      )\n    }\n\n    if (this.props.tracks !== null) {\n      store.dispatch(updateTracks(this.props.tracks))\n    }\n\n    // Now trigger async actions\n\n    if (this.props.temporalExtent !== null && this.props.temporalExtent.length) {\n      throttleApplyTemporalExtent(this.props.temporalExtent)\n    }\n\n    // eslint-disable-next-line react/no-did-mount-set-state\n    this.setState({\n      initialized: true,\n    })\n\n    // heatmap layers\n    if (this.props.heatmapLayers !== null) {\n      store.dispatch(updateHeatmapLayers(this.props.heatmapLayers, this.props.loadTemporalExtent))\n    }\n  }\n\n  componentDidUpdate(prevProps) {\n    // tracks\n    if (this.props.tracks !== prevProps.tracks) {\n      store.dispatch(updateTracks(this.props.tracks))\n    }\n\n    // heatmap layers\n    if (this.props.heatmapLayers !== prevProps.heatmapLayers) {\n      store.dispatch(updateHeatmapLayers(this.props.heatmapLayers, this.props.loadTemporalExtent))\n    }\n\n    // basemap / static layers\n    if (\n      (this.props.basemapLayers !== null && this.props.basemapLayers.length) ||\n      (this.props.staticLayers !== null && this.props.staticLayers.length)\n    ) {\n      if (\n        this.props.basemapLayers !== prevProps.basemapLayers ||\n        this.props.staticLayers !== prevProps.staticLayers\n      ) {\n        store.dispatch(\n          commitStyleUpdates(this.props.staticLayers || [], this.props.basemapLayers || [])\n        )\n      }\n    }\n\n    // loadTemporalExtent\n    if (this.props.loadTemporalExtent !== null && this.props.loadTemporalExtent.length) {\n      if (\n        prevProps.loadTemporalExtent === null ||\n        !prevProps.loadTemporalExtent.length ||\n        this.props.loadTemporalExtent[0].getTime() !== prevProps.loadTemporalExtent[0].getTime() ||\n        this.props.loadTemporalExtent[1].getTime() !== prevProps.loadTemporalExtent[1].getTime()\n      ) {\n        store.dispatch(updateLayerLoadTemporalExtents(this.props.loadTemporalExtent))\n      }\n    }\n    // temporalExtent\n    if (this.props.temporalExtent !== null && this.props.temporalExtent.length) {\n      if (\n        prevProps.temporalExtent === null ||\n        !prevProps.temporalExtent.length ||\n        this.props.temporalExtent[0].getTime() !== prevProps.temporalExtent[0].getTime() ||\n        this.props.temporalExtent[1].getTime() !== prevProps.temporalExtent[1].getTime()\n      ) {\n        throttleApplyTemporalExtent(this.props.temporalExtent)\n      }\n    }\n\n    // highlightTemporalExtent\n    if (this.props.highlightTemporalExtent !== null && this.props.highlightTemporalExtent.length) {\n      if (\n        prevProps.highlightTemporalExtent === null ||\n        !prevProps.highlightTemporalExtent.length ||\n        this.props.highlightTemporalExtent[0].getTime() !==\n          prevProps.highlightTemporalExtent[0].getTime() ||\n        this.props.highlightTemporalExtent[1].getTime() !==\n          prevProps.highlightTemporalExtent[1].getTime()\n      ) {\n        store.dispatch(setHighlightTemporalExtent(this.props.highlightTemporalExtent))\n      }\n    } else {\n      if (this.props.highlightTemporalExtent !== prevProps.highlightTemporalExtent) {\n        store.dispatch(setHighlightTemporalExtent(this.props.highlightTemporalExtent))\n      }\n    }\n\n    // viewport - since viewport will be updated internally to the module,\n    // we have to compare incoming props to existing viewport in store, ie:\n    // update viewport from incoming props ONLY if zoom or center is different\n    // from the internally stored one\n    // TODO FFS incoming lat lon should be an object, not an array\n    const currentViewport = store.getState().map.viewport.viewport\n    // stop propagating updates from outside when zooming in\n    if (\n      this.props.viewport !== undefined &&\n      store.getState().map.viewport.currentTransition === null\n    ) {\n      if (\n        currentViewport.latitude !== this.props.viewport.center[0] ||\n        currentViewport.longitude !== this.props.viewport.center[1] ||\n        currentViewport.zoom !== this.props.viewport.zoom\n      ) {\n        // if zoom delta is precisely === 1, zoom with a transition\n        if (Math.abs(currentViewport.zoom - this.props.viewport.zoom) === 1) {\n          store.dispatch(transitionToZoom(this.props.viewport))\n        } else {\n          updateViewportFromIncomingProps(this.props.viewport)\n        }\n      }\n    }\n\n    if (this.props.cursor !== prevProps.cursor) {\n      store.dispatch(setCursor(this.props.cursor))\n    }\n  }\n  render() {\n    if (this.state.error !== null) {\n      console.log(this.state.error)\n      return (\n        <div>\n          <h2>Map component crashed!</h2>\n          <p className=\"red\">{this.state.error && this.state.error.toString()}</p>\n          <div>Component Stack Error Details:</div>\n          <p className=\"red\">{this.state.errorInfo.componentStack}</p>\n        </div>\n      )\n    }\n    // won't render anything before actions in componentDidMount have been triggered\n    return this.state.initialized !== true ? null : (\n      <Provider store={store}>\n        <Map {...this.props} />\n      </Provider>\n    )\n  }\n}\n\nMapModule.propTypes = {\n  token: PropTypes.string,\n  viewport: PropTypes.shape(viewportTypes).isRequired,\n  autoClusterZoom: PropTypes.bool,\n  isCluster: PropTypes.func,\n  tracks: PropTypes.arrayOf(PropTypes.exact(trackTypes)),\n  heatmapLayers: PropTypes.arrayOf(PropTypes.shape(heatmapLayerTypes)),\n  temporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  highlightTemporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  loadTemporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  basemapLayers: PropTypes.arrayOf(PropTypes.shape(basemapLayerTypes)),\n  staticLayers: PropTypes.arrayOf(PropTypes.shape(staticLayerTypes)),\n  cursor: PropTypes.string,\n  // customLayers\n  hoverPopup: PropTypes.shape(popupTypes),\n  clickPopup: PropTypes.shape(popupTypes),\n  glyphsPath: PropTypes.string,\n  onViewportChange: PropTypes.func,\n  onLoadStart: PropTypes.func,\n  onLoadComplete: PropTypes.func,\n  onClick: PropTypes.func,\n  onHover: PropTypes.func,\n  onAttributionsChange: PropTypes.func,\n  onClosePopup: PropTypes.func,\n}\n\nMapModule.defaultProps = {\n  token: null,\n  glyphsPath: null,\n  autoClusterZoom: true,\n  isCluster: (event) => event.isCluster === true,\n  highlightTemporalExtent: null,\n  tracks: null,\n  hoverPopup: null,\n  clickPopup: null,\n  heatmapLayers: null,\n  temporalExtent: null,\n  loadTemporalExtent: null,\n  basemapLayers: null,\n  staticLayers: null,\n  cursor: null,\n  onViewportChange: () => {},\n  onLoadStart: () => {},\n  onLoadComplete: () => {},\n  onClick: () => {},\n  onHover: () => {},\n  onAttributionsChange: () => {},\n  onClosePopup: () => {},\n}\n\nexport default MapModule\n","import GL_STYLE from '../glmap/gl-styles/style.json'\n\nconst AVAILABLE_BASEMAPS = GL_STYLE.metadata['gfw:basemap-layers']\n\nexport default AVAILABLE_BASEMAPS\n","\n  import React from 'react'\n  import { MDXTag } from '@mdx-js/tag'\n  import { Playground, PropsTable } from 'docz'\nimport Map from './index.js'\n\nconst layoutProps = {\n  \n};\nexport default class MDXContent extends React.Component {\n  constructor(props) {\n    super(props)\n    this.layout = null\n  }\n  render() {\n    const { components, ...props } = this.props\n\n    return <MDXTag\n             name=\"wrapper\"\n             \n             components={components}>\n<MDXTag name=\"h1\" components={components} props={{\"id\":\"map\"}}>{`Map`}</MDXTag>\n<MDXTag name=\"h2\" components={components} props={{\"id\":\"description\"}}>{`Description`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`This component displays and load fishing activity and fishing-related layers on a map, used in various GFW projects:`}</MDXTag>\n<MDXTag name=\"ul\" components={components}>\n<MDXTag name=\"li\" components={components} parentName=\"ul\"><MDXTag name=\"a\" components={components} parentName=\"li\" props={{\"href\":\"https://github.com/GlobalFishingWatch/map-client/blob/9c5179358d4870c0fd4c2c0742917e72e6025c59/app/src/map/components/MapWrapper.jsx#L5\"}}>{`Map client`}</MDXTag></MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\"><MDXTag name=\"a\" components={components} parentName=\"li\" props={{\"href\":\"https://github.com/GlobalFishingWatch/vessel-profiles/blob/aa0e17395f6a4947bb3fdf3106cb9d0a744ba64f/src/profile/components/MapWrapper.js#L3\"}}>{`Vessel profiles`}</MDXTag></MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\"><MDXTag name=\"a\" components={components} parentName=\"li\" props={{\"href\":\"https://github.com/GlobalFishingWatch/data-portal/blob/96b1e24efcff58ade672a67229da0610d9d241ab/src/map/MapWrapper.jsx#L2\"}}>{`Data portal`}</MDXTag></MDXTag>\n</MDXTag>\n<MDXTag name=\"h2\" components={components} props={{\"id\":\"available-properties\"}}>{`Available properties`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`TODO: fix crash on PropsTable docz component`}</MDXTag>\n<MDXTag name=\"h2\" components={components} props={{\"id\":\"basic-usage\"}}>{`Basic usage`}</MDXTag>\n<Playground __codesandbox={`N4IgZglgNgpgziAXKCA7AJjAHgOgBYAuAtlEqAMYD2qBMNSIAPOhAG4AEE6AvADogAnSpQL8AfIwD0LVmJABfADQg0mXACsEyEFRp0CDSQCojvVO3YAVPBDjsAwpUwBlAIYYARpSzs8rux4wdOyuAK4ElESuBBDkrlBQAJ7sAOZ0MALRMOjsoXBoKWYWAAZUmHDu6F5YGcU47ACSYOyJlKEA5AIw7OShAhBtdniUAO7sBH4Evq4ADjPp6IotbT3uRT14MOQA1uxtU20C7OiU5EMZMIi-BAQzcIiSkikQE6EeOFREkqiUrGiJkjK8Eq1QyZnWTWWoXY2Hm_To5G67mScAIAlCKRSsDsIxeeHGNjsFU83iWM1g_m6mVsSPMtjgoRg62oqTxb3qiAAlGYjJIzBAiDNKAIpgAlGCuchTMBCIjsToSqXtADc_MFwrFioIABEAPIAWXYMsi8q6koIAFoTkQVWqhSKHJEhah9EbZfKcJJsK5BbBbagzOLzXr9TguhgMgAKdbMNhidYWRh4ADMYkc6pdNE46pF2XYuImPScwJJNQEiCkKfj5gs7EYMzEkYaUyiyRdedc6BYMWo8XYMyEd3GlFSMCmL3Y4cw_VQKXzMASnKkDYTdfTztdkmriekccUZhOvSI-hwaQIAFFYMeaAAhRINdCRzrCAjtbmoTnKhTKb2-mA4TQyB0ahaHoRAVBzKZ9VmN0TXaT04AEchJCiGZJFUbAALgf0BXtTVzVguUFXNdo7Q1dhgHYTQfHkQj5QAARgIgRAGVBAWFGBSIDVBdFRY5TgAL2cAhEmxdhuAo9YogEZ5UCudoAAZ2GTGYsHafcaxmTsWFneSABZVPYAA2VT1PWMAQIAMR9aBEnk_hnEORFHUwdgAAUhH4JZmJ-OAtMRMyawsmhnAgATLnYABGPSNPkcEeOoPiAEE5nE9hI0o8gbCgdBw3YeROXEsR0pjGR2FRUSYG4YBDyEkTsXkbda2ALLoFy4IADIOvGRJ5koZpWpyvLuBG-UwFCHie1Qdp2AAfg2Nrw0jQqrkG9rUDimspBkat3zMWFyMwMAwigKZlqKkqtpSlca0TIMpRwSzMhSa8CCa2s62gmZ2D-GARjw6rMv0DIrgAbQUnAFIAJiMpZIqh5McCMyKAF0lgE4QiCuABWfLaK3VcpHughHue16mqka7drMb8QEQ5DUPQiMNC0CgQP0BgDodSijpOqZaONIjPVQriuamSjIAISxKBvNoMDgJYCFcGSxy-gA1eA4AXfK6PgyRUQ40WsDwijjhgY7QlOkI7CStWkoaAAZJKbwd88AH0byS5xz31JK3OcHXBY9SQPEpVDsJppQ6aQlDZljmYsKA3RQIMcDcPI4ndbNJUyIdDzKBmSxevgXWBwLi0RPmCPUHT7miyIDw0BgcV0FCREBDsAX3QVVu1Nz8X3KEP5p0D7vs8tLpe642upgmIQblgXWoCcfw8EkOeRAIP1-9NtFJW2Iuq9HuDPTLmZK_gdfMh2auZ9NzZolQh3XESDJD_gJZQ61p-X7f4uFfKkrGI5Bn6vwEO_TuutT6DgvnASQUBf4d2npBU2v1_oaggWSAuoRC7_2PkLSQZ9YH6z8JPLiO8vpQKeFARmX0PggVcE3AQyCTbAHWGgF4-onCWxgBpCwWspZMXtPEc8WAU58PKmOAAEhAFIeAoCyMIJYIRwoRFiP0BIgR9g-hwGFLFKhzFW6wBQtw2AOBzSsVvigyiOD0BZDVhAP6eFFaZFQPkKa0sABamN8HByxIzNBeFzFSksSw8ilEOEEGEpVJYnwiAvGibAAAqjMOxtAAGzHJIkZROY1Ep18XrfxccKpmIsYlMJddbFZEsNfbYkCg56z3jfK--84DBKmlY1huRUlZCkRKYgsxQEZAAVU2gQyBAO0oJ2HJwioCiJTvU7unoH4DLQis1C7TQnxTvgbLoVDdmcR3qhFubdhn7IiF0SQk9TlIPirxFsswTntzSp8RuLonnDIylJWYVxjnZBuQrMwBV4oHLDDAckkpm7_PbpGP5rd257QSm42eeB55bxgNdJIMzVFzPUVmCSG8F4wEjJGWguTcUp0KtwYqbCaygpYH5aIWVIyZKxSozIFL9CkvZXk_QnJ3z8Iuf-BlWkCDMoEdijl8yuVktmdKmg_KgVwyMoi-53S0kwAcU4jUT1IgNASvE2c-chwSUjGgT4BQtXoJFFSml6x6W2FFcy1cozNWOOtQQL5t1awIJiAQUImArjmsiJa91QTER6AEODNGq4LDL1nC8ANEVg2GpSFa8NwMo2owkR9DGkQg0GtDdqkUOA81EBzflAV7B3ybTMOQBBcA7BfS4UY7o2BQLoDsMTHA65qCulpYKrIaUB21kiRAeIYVshXGOlALWFaMhCHLOwVAlsoDzoEIu_VFkrgroSBI2tNZPgbhoNqLg9gmV4EjAuvRMIN3Ci3ZQQqI6LC8UoGY5eKQr13oEEsa9AgH1VosBMWwOABHCSyF6j6Fg_1XD_RW6D36H2wcQ6gCyFbgU1gPS-p0faT1cC4RNT1T7VyPHYJZCAHdZ79ExBkcqiQeKouoIMEIITEoEmiOVYYlsch-DmMEQIFk9nInYKhScdBpwkckOwJKKK20YD2M0YDACBEhCNAgucEQQgJFGCJmCU4MgFHih9CAzRSWEhwGfNpgTyIAEJRoTSOk3dAxHvUWFdemnVsp9UWqNYOOAZmQOWZwNZm1q4sO1lI5YXUepVwmfSkpizfnTxJBmHgOAbloj4jsxJXdUAXNQcARxHAIqL3Rlc6OmuUT6rEufQV1IKW0sZYmFcBLQWsS9Ua5l-DUHIvRd1CEOYSR2BJNFA7dVWRzhdFjbWDDBXAP5SM6O0zrWkvUBk2iCAHhwiWPsH4Wc3Rsu5AjJAF0znJLlZWwXNpa2bj9C2x03b7g0iRlBWecDtBlo4A2SU_80QNv3csfN8LFg4svaFewLqhWuinjHO94lnIvuzC-6Y_8ERtjBBGhJBz5snP5agw6xlYrL3TZB5VltPDIN1aA5QdHckCSBaS2jug3WPphAiPYKAeRaACG8fm-nbSgts8oBzrnGReflpJ6OuAIvUQg354lq7OBbAy-5yz2s1APMike_tlr5mgsa7DRqbXaQ1cWGoFI34cvLt3BwOby3P7Jdm9QBz2I2xdcM8V9QF3OxTd7FQJMzs4GRTu4F6t_3Uz0BB4IL76gAf0DrlgLQEPCubex4jwnscvDHd-455QLWblsEzGT_r53y98-F5j6gdbd3tuJWNxFa312q-3c27Xtx9e1ezag0DxbIPlt66SzYORCi5GCPJfKqYh3csQ-6o3_AiiR9KJ5ZymgOBYCzgmHjj6BOnWXoETI4fiix9yrxZ6ufQ_5FH8lbyhVPfuLGdM9NgLofFdfyYoMxBdgp-rpn_LoLb-f4wE2l18UhN92AAAfcAp_OfVEaIWIcZL_UaafSHGAoBeAz_NfOgUAvAebLfWsHfUrSXOJBJarFJDVfzVAuAkBT_CA8A9gUGNGP_JLAAj_IA2g-glGebCwO_WLfvD3G3JpOpdgb_Rcc7ArAgonSMV1GpVpZ_FPNpQQuARVb1YHdgUjAAOR0w2xoyOH8Ho3IBYw6V704D4JfwEOXwn2EKQJ_xQIH0V1lRxQn0wI3xwLEKg0JXRUxWyQsNPzkKCwcKlVPx4O9VI3gAURoCtFsFcA8FgAtBdDEQtHCKpC1G-EoEiPQAtGYkIwtAERyKASZG9QSzA3yMp2M0q3HQUXCnQBa3RCzxUMRQ-lI3WRggQSAN4PizsJt2aJmAQKsJy1XTwMFSKxK0kNdT6UflYM-XP36UAOGUVk6OAIj2vxXwIGUI-k2gsHCyPVwx1C4DIIgwHBgFYGNSULcIsFI0UPaL8MZ1qUQIkkOOOJuNaUGKh2FUdVK2kNuOuPsNuLWJm2MKaJmJaM_yuOmImJ6JoMOweJOPwCBIhKAJeIkOZTGLhIQO-K6NRM_3mP4MWOmR8MpWCMaKkxYO-ik1gOAXYFaOGSuOgIWJwBJN6JEKgF_znwZIwJALAMgNpJxNAzQOoLYKZJZLpPJPQKAOcOwNwLOKW0uip1ZLDkmI7j6P7C6EeNf3lPhLOS5PKyA2FL5MZNGmhKSxFP5OpPKxeKGOhxGOdW1NrGIKq0qn2PSXRLaWNN6MgI4OxLMLaTZLYPdIYK4NrADI2P-Pvwiyk2XjxPH1P1BLpIjPQGWMsMFNsJ5LjITNP3FLANqz7xlLq0NMV1TPxNdEx2XR_y1KpxszzJtwLKjJTgzPxDLLqzn2rJPxTmjRhylgFHhyVMrNxPjMLJoDbLPEsE7POgbIKybKWP7IIFBlRnbOHOPHOihJVJhObMcNPxnJRjnJHIDPNNeOK3eNGJ6TGUQTjzTIWWdLX0nJrL5SDLC0k3GCnJjJ5ICJv0n2sISCFOfKnLrJeNB0lx7JwBfJWPEnfOZLHKgwrOXMZ2_I5PrKgJtLnyAon0HLHHnK7KXKOJhKQvXIUk3KHO3NoMl0QqnI3K3IXMKgwtVPMOvIHNnPwvIum13I8NgC8LPJlTpOwspWm2DM2IBKkwv0X2PzXJTifK9Pn0P1HzYqzCTNnzpIEqvxgqwMzOmz_JtIAvkskqnJAv6I_PAo-kgswsHwXwUpopJlgsIoQrkuMs0tMpQo7PIr6Oz3UusqX1stwrIq7L0trHPxcqEsCNbLotQoIuyycqgsVw0tcpbP0FIvovh0YqlO3yFX3MJ3FWkV8qkrPysoksiuEpvO4rCxhFnW6CzJMI6J5Iir8tfO7LCq6PSqnN3KRL3zSuysqpWIvIqoyr-PWLvNDPOKkxCymAtHKnNW6AGvzGgGZMCHG1oByDQG51QHiCG00wmG6EMR4QrVIxGG6D8FYG6E0yPWVm6BTQKGVKu2HBhCwFsBiFnB-kNwdDQFeKWEcUQHvNdVuuLWlHdGOpuss3YF1HUIdgAE1Sqy09gjgI1udOA7AWAwAwALgaB7yg4VrOBI0FqEgUQhUcg-17yos9QyNLIA5vq5xfVKSWQ4AuMcp2Apr3A9gPB1Atho9l0RAQhzBlZMhEhVw1VegN19BNcpgJJXtYcSiEcNkBrgs7rRAQiySIhvoz5XAUg4CbrXU7Ag59h8hXIRhNhzAy0Tq0AaSLs6SxrDtscTs8wupptBaqsIMRakcxbubwwpZXF3FWJtKSyEhVxfzH8bT7beaJa184D_VXJDs587bM1o0LKqcfaaA-bLyE1A6DtRoQ6_aIaMgNyI66so6CAY7Qbg7Da_ay14qSq-qQafFMBTpXAoblStgaQhtizIp0YfECx8QK6943EXhWJJdQdoIJhzEPB_NM7s6fEhqk6PrS1MYqVRpIpdyLS3iUrL1W7nbqAvFMYLyBquqoNaIFwtYEqoN3MJbdUiBvMQ1fMrtV6JaAzeLyseKFterSqLzubdEjhKKYSH7hRESkqrSmqCBtEO5hR76dE3679L6LB9MBBzpatQcij8icA_0lTcsXjX131KBP0oGsgYHv0Ayuh_UBBzAysqdYxZBs8kwoYxBKFtjMwphyBMhybsgbNKwSGiHvp61_A4B1CfQqp-BJ5xBgBUHaB0HF1PyXToG_1ALKBhIZxP1OR5Blx3o6sCG0wcMKH2BwMdh2Bzxv12BtQxxGFZ0KxdxCGbTEwmGG1WH2G-BBBshuHeH_w_0H16EMx9AVHthpHCFZGPpto4xGKeqiT8xqB2gphQGWbEhgMbqBMOJDDLEUb65j1dj0ACMswdruhAhghtC0guHvUsG-hzBrGldyiJ0qilS0RGQ5o3bmSrg8GoNGB85h5aMDlqoDlGpJdGBKFgAcA2nG98Y3G6xJBqmuAMhZGq1NoD1m0UcU8IFh11gmc6djUIFeSJGJEBqrgZn_5QNeNiUBqIEEdbBxQABHUICjbICRIXFXMXTGJZwcWZrwN9CRZXTnWXJdZZquHAcaHiCRRQ85guWZtml-XUMASMR5-AGBrAc0UlWpTZzkCRbohAj53BJ575xIX5_5i5lZ8m2YYlKFxBcFt5qcmFr5jdH5v5gFtpNAWAniGARF7ULIflSFuq0y3FlZ-FxFol3J0lxEClqliF9YVc_y_QeluF_FhFwl5Fp5klpWMl9l2gal9YH04ZPlwFxloVz5lFtZyMGV8Bf-KVulPUz_OVtpBVpFpVp51F-YMHKg8ZLF9YV-h54VwF1EeZ9YUjXoA2IgBA9YYYXagQAvGYHBXV1ZtFyMIUb12F-ATlw9BRHYL1n1weQ121lVwNnBTZiRdrVLdLTLX1u1goCRA3D6-vX1l58gLN8PQPJWYPaN4NtpfNwtuPDPJPMt2Zyt5kUvV3PNiaAtxti3D1lt15xt6vVvB7PbNILtttmsL3MvGASNovOtlZhtjaeKEZ1tYrc2PmE4iZmsKZndVdJNhrVN5rUpo58IYXO57ncXGoxkG56XI9uXK9XahVC6I4k8W50XI4YsopuoiwDqnFvdyZ24jdvdN1-3Cd39tdS18N7YQDr9msDFoAoD7FuliDuNK8qKmgGD6V9U6F-DwBM1nVjDq1lDkd1APm3N9KW1CiJQRtuPKPcpkj4AMj_D6tp0RPCKc6alUjwt73N3Yji6Gjwtjtq96j2jp3XtgHOvAdpj_jtjsd8D5jmlWjg9MWM2C2K2ednhSOZQemeOfWIVJmNQRObQZODmNOaxaJvPXhHoM0WgYSDiJYVlRIfULgdAWAEYQ6gpa5PuGuFBV4VAXYBpVziuPACabYchdzrpSwUUJKdQ5wBoSwBof6t2bUEbJKaL_6gpNp6hAJP265duCpAeSWaWWWBzOwfwI0F4PLuWTtJKVjVAFxdwRe1Ac8eTLuE-T0IpNCMWspNxILxPYzrWervbduOwCSbYrWfkL2iwANoQRERtGB1AVgHAX2NyN2UUc8eLgADUW59l1EsHdm1HPBvCSQAHF2Cy5Ju2k6BZulukp7BLA3Y_YFv5v1vVv1v9RNvtvduDvCpzbNIJvNZpvZv1Dot3Zzx1C1ZXb2hMBdrl4ZhXouI8cuacMtYAB1PELR1gaWN9AbsTPZg5p8LoZiWgC0Xz8HiIdHt8exoURH5Ho4tH2dS1-HmAXr9wfrl5OnpHiYFH6n_zWrBa48eSShNav0CtM0U6Ts09t92sYYVEbniKdoZeOIKACX18CtPCK4AADgUnV4rSiCwCSkHeUgUgrXJJgDcHKPCiXVNclYugynYDad5KyG8h-VNht8N8RxmCWG6Pkn--u-9lFAaCSgdgaE8WW5mlogKn3RrTuUSimAOReXM6N6FRJXE9Y-6_p9QD68-Rs7s67Ec8OrMwC_5URXk7VRLbPHVk1m1lNS4Go9p-RXGFqTSktrh0-w2UUOK2iFcGedUBJVWIuhJi4Fdq4FEfEYKGWirUasjFy5ljK7gAq6mlBf3hh0n4K-UPWEyZwdr_n5iGPCSPy_liBX2mNnIjVQn5387TSlVan6r61eGIPOZWP6n5n9YnP6X9H6CuPH2AT64_vPbEwByCK-RoXvboshxMldH4FMECAnU5esALGuYEgCUZiuUsRfvLFr6yI0mVxBvsLRd7i1R6mdGQm3SmhwMBiO9MfgAKmj1dHw69YMkoCsBhcIuUXGLuoTi4Jcku6hdgAAGooo4fbiPJ15iWwo-QqVTtHAZhxwSScCDCCzCTjswwIEEE2PtwdhuxnAlgQGq7CgTNcaEccLEHkUqhwIfsWEPxhHxr62x7YTsF2O7E9jex5uAcCSLIPkGKDXYX2bRmklcCgx2gKQMACMEQAklEin-doCjHijcCl2vA6THbEdjOxXYHsL2D7D9jOABB6nRmEQn_gtIb4unNmHoCkF3wiWpcQcBXH_hBdC-kfdfjsHGYSQR0XAdNhtlnBK44AuzfZpPAkR9AoAZQ-1jWEcG-tKAdNBmhIioDLxrWMbIRk0KAzFxWhLoRFs4LSCUBNAfjJYO0HmDqY886kI7I5lOycEJEVJcBFOXuBTt-W7NJljaz1YCsdhvQnACugbgZBNWFgSWCfzgC6gi21RTYYCyubAdZ2qAWmLELjjxCq48CDAoBD06SDU40g8iBkIaRnxshVcXIQfwdBqooOf8I-MUPYS3DmWGbCodsxgBY9ahkzaAPADHAPhGhmbe1G8Avg4jZwCzWwJtlgC-sHhkLRkL62OGBAHcI7fyC8Dsh3C2kNIjIBIkgCnRZWzI8xPsL-argERKrEqk0WKb25-g5QSkogl8DFM4sAiabP5wijMtWRdIgrKRg5Hc41Y8QRkHYFsCqYWAlXZWMkAeqa1Yg-IRUPiHRyGjCuxXTkZkBiLdBIAC4RYNNlIyVAfomokuDqJprwsFMWmZkuT3yB2i3RnOEuJGF1CihrR3OAMqRmeoRiMgGo4MRsMyhZAUgwoJkaDGxhLAjIKMG-gVjVFxj3RGw5lm0PppSh0MVaUNu-wlDTh02go1cOJiFBzVCxuw23O0NLGc10ed4Nhjz25HFiOhq4TivoCbGHD9WzLEcc2KVFnDvK6wh2JrHJHCBHhmxLZlUJRE1DDm7CSNBYl2pzjrme_LgeCMob5C1WRQtwqUO5GIiUgxIgMWSO5EUjdx-_E2GqldKYs8EsImsKeIRHlCUglQ6oQcydE1heseNebuwGe7xdlBDQOwBMA4zf8Ow8mGUSOE1oc0awfwK8QqObG3i6UC4BmlOhvHzjNEmEqUNkEsj9I-g8AGsf61qwOicohIi8auFYAFjfWY4w4eeIrGVoaWLVbCcy3QnvtZEglQicRK6BDjy2frE1hRMcRUSzxn4itHRITEMTeRBrIScxLD5ZsGRIkakaEBOHKiiw3Q6iZomGAjBn4gQXRjhJ3FviNxISLccZIXGxiO4sk7YYqyEmMSFJn4yccri5x85OJuEvER4AJE9jhhfzUGCbScxTCxhEw6aFMOobc4fBLE-oTpPWAtCexrY6POsCxCtDEpsUGITHDiEwIEhqLSeMkOAipC_h6Q3YZkPLiwIwRD4_IfG3LartsMhU6kcWBWEB0k0akjSd-JXG_iVh1AZ4PHVam0j2pqItcU8PvGH98hGzF8W4TLR9S2RlrTNLZIJbyTZmE49Kc8KjivC0ILXSQHQmTiMIXQAgfKfpzSFGddALoKUC5y1AE9_kbnO-JlFj7OB8JFyc6VrFgA5xgu4SQiAACkA4jXIiAKCIDhBoi28N6XXFC6XcAA0s4DdhOxAa54UUG7AaAMDLIoof6td11CWQ3Y-3ZGUkjcgpdPQugSACkGy6mx60JnCdrjJMStoKZPCTZIlCwhEzKIQ5W4okhLg_SPQnoRQokLqSgYHpwoNpJoHpm6YZg-qbnO1xS5MwRZlXGmW4jpk7xKIAiS4UsAER81queA1iGQLFltdKufMzpOREoQNJPQX0ILmqjezas2CpqQ3iR2d7fZqstvYBK6yRR8Qzw4xVZL0XNn5FLZ0DDZN0VhLgl7ZxsrEajXiA_1H6Z_C2RdCtlI45qGQdrh8AAYCA60-QkvijmDnChQ57s8OZ7KRz89_wVrfQXxD8BwBnZsxRUoNzuk8ywG6wUGE7MxJAEY0NYSMFCI7iX8Poq_cwLqESk4ALR_mRuUoTrLsBioCkdYJtHfD-yCAws6OeZJgDjIHwGPKhv0iN7lyKmVcoWlh1rkSINCIgCKJsD2RbVrYDIY8OximCrDGg2oOwGXBqY5Am6ImFHLpiJwEhugsgiUWwUglR8Ka6AB1sSSOpmSYgu1MGkzUZqOIeoMwWIItWSDI0ORzJY-XFgroIJDJT82jDqMOJawEa9cp8QiU_4ZMxwWTTDnbIwKZdiULKcgAW3gUCBm5UGUHDZlWG5MJZP87oO6UoWIJxaKEwqK3JYzkBnRUmBHkiFnQjhv-51LKFsF2AuhZcOQVYdqO_lsBGR-YLWj0DclygsQJCwrnsnPl9N355WUHFQoUXG1jsuOHenGkYVYh_aYpQTOeElCXpIwWIcZE9WZhkKqcpGMRX3LrqV08geYTTHQAZA7yZFWkB2iQsrrSR0cv_cRTQrYDdBd5iTYcNniaKuBf5HGCkHxD7Qo1glv8hkDEUQTzFggAinYHmAlD4gElqgSRa3FAXZ5VKVOD6JoqgBGLhkjiyeunVKXpRLFjC48ErEcFKlApp2X_A0rAT2DmlbfUYW4MQBRzr4tCnwa7VfYX1AyeiqDMbKgDTycgEkTpRkCVw5B3SYg_uewCUjzRigAAEmABUKuA8gC0DsrEHyBig7AK4HsrUV1KLAkocgBZjyCXoFl_6ZzNnmvrrEgyhVbekXTYV3LyakYC5beXKysKblYWJYP6SHlmBVUic1WLMGZkY9zeMAD2Wg2tmVQXezMhOTXxL4wrqsMfeefdJekXIl5mKmYLCqWCMzWksKuuWN1QgkqCh2wWFbYrvo2ZBC9KsTNg3MDUrqscAYwlzT6AO1xk-3IQDggx4cqtB02URl9OWhiqHFeYsBn8pI4VKmlnYNvq0p0WnYAyLvElHlgugKqHBvS9oKhGqCIAUggqmYFFPbE19BCCBfVGoBeS8r9A_Kk1cAX8BjzmYiLUGfYAhlQykoMMuGQjLdhIyUZbsNGRjKxluRCo7AyKMYS64nZ4gX0WFWlBFXYh7BKsfVJGGcG6I-gk3HwdVx2CwrQMTkENquC66Jr4ArswWXmrPBPgxFb4fsbUjzXSrhQpi5lHPx2BWLOADKiwCWrgBlqu1CBFlhkDPy1IrVzMNgZwCWCCwJVlqxBBQPmwxqoAcazlWlDnULqtB3Mz1DL28H29iVnKhAvNlYXLqsVoqzDBCrzlTAzwKc59mZ1xWLzK5Z4ceTgyDlxzSVqsZOXHMpXpRBlaNC9d5FfW_1SFGCh_OlGzkXqCBohEqqwuA1xzvGtYVhZ-sfV_rwVH4dFXxA5XVJKAK7N2Xbz2AjBUAJxEjpTkWY4L_wotP2gNQkRa8T2RGzAWLQo2YxyNaASjRHITg0aGNdGy1nHKuDnq458Klieuyo0bJs5ojWnORsPXXiiVzMnjZC38BFyFSGwguTJo1IdxJN64pJVPMQQzzONAc1TbMv8wWzYokKmvqhFPRz1pYGG9KJ_Xw0jolZEtcpmRsSUTypocOBlZ_Rexjg-akYOzYMva5ObBmeEggJcPKZeAl-AG2sC5vllT8n-8sP4gJ0Fn3r2u5TC-EsF9RJbup46_iR_B6CXsf09WfbrDgLXOab-l6VCHFsq6kpi4SW6IClqJFGh0tACetE-1JVQBctUSfLb5u_Y1dABdXDAFRxC0WAXNJAtWRgBH5DyJOpMwvD1pY61YXNJM8vEG2G2YZ9Nfg_cQpz5hFhUAp0z1N8m3VoaTiImmYMZt3yma_MEKyMF9HfAvDMpccbOVTNKRayDpvwzmMtrVQIyoubsECUkmUESR2gL267u9tdhGxKpNfb2Ndy276g3IYYv3m7HPArctu6hSwGlHaDA63YoO8HWFzkHQ7YdlgAHaNKB3nhruUiBoPtykT-8idIOn2Kjsh0Y6ge8Or7UjoJ1E6SdUiMnWDoh3o6Yd1O7HRCPyEKCkoooa7g7F1BJQdu4Y2nZYF5387BdwuznQeJr72ADQbkV2FtyhmS7YZCOuXWDsV3uwBdQu2GdLrW18Qkdf292PYBGzOAwxCOw3dFg-3G7TdYYiqTjr4iRJyci8U1JZnw0WaQtLm2rD5J-1vardrsJXi_DjJXBLMYfO8fEUB18RYCIoOPLRlNSf1FZ-RFLZ2AyAPgyFRfTsrAUFBpQXQYwSlh9gRyxVJVh6KFXtKyDoBY9TytKHGVT05BtFiwvMJsp2U16nl8gN2Dss37wAlYgoE5WcvGCZ7u9MwOKYVtKJAKIoPOvncrp12ihA9okCPJprL0zVK9D4MPW-NMxMbkcC7NPMW2Vhvkscqq7IHgQ32Cbt9keEtkRkQ0gMsFa_FvQ-HD15Ca-R6RjpXrP636zsLHSMAntHBW0Lek24fXPVH0-T1dCuvHVrpV0z7VwWkOfZ2HOUR5a9q-uqVHvyJpQTZ1tavnxBb0Y9j9ozTA-wlMyUK4DHcPuZDmwNb6bhNbBOvvob1nZaspB6mafooPF7L6cnJ7fkOzYep68Z_LzZVyc2W8v9qB3_XahL019DeKBleQXvQOUNFqocVRgLUzkJwT9BHCWvXkWyg5IBMh3YMWTaWH6pSrcy_frqmBjU5DSK22hLUWzqH94o-7g45qT2rgpp71D1FgMcNloK0KdJdKDDFpi1fUiaTAEsE8N-140PUpNO-osBBb5YVwMWmEc7SuH3A4ufVBEeTqxHMY-qGI6gHFy6hwgCR7AUkciAZGkp3qLIlrGfgEBJkukBw0EkKNqaSjqWoeZwJGlc6RDqFLSqagHG3sP9I6HyUjpR2s6od7OuHRIigPB6HyplRbXuMj1R9mql-Gykh35rpQP2plSzZM0GHKM8dbsencTsJ1M7kd5Ono1Tv6PrBBj8-3wLSxmOjH6jMuviDNvHaF4z-7uwrc-p_0IqQtj45A_MvENxU196UOg2YlHZjag2Kq6g0fvkOb76DpeP4zgiYM30WD4xyRN_Tjln8rWixtdssct2gSbdooM3RAc0hB6jjVrUYxdqEEbS1BrXP2u121kSDCpDAG6fAIVn9gIANQWdNLAR7ChKarM9oANUyIZA4gFyC0GXBLGvhZZ01GAApuHLYgD6fNcmd0UkDdFRT8rLWQLPYN4RODbJ1LtdsE1kmBZ9gB2EkgUGwy3YWphoB6rdieJdQBoeGeoXsBLd9Q1O8mfjNkQzQAJ_WICUbqW0wmkdN4XUEknULahLB8od056e9POA9daqJHWrAaDngEeqOmnX6dWNhmIzUZ4M_kOxnahEu7sOM5GbDHRn2gyZ1M27HTMJnzjBhlY9dxNNmmEZlpn2Dadp2rHSz-oc0xWetNw7EzuO37Z6e9heqJd6hQ7tWdbM6mtdiXZXV2ebN8RQZtA5gVDu9MI7RzkXcc0D21DDmpgSO9QolwaBqw0z4ZjM3zot2rHlz0XNc3mY3MFmxjDuiY_5qn5n8ojpxdo0sfmBXB_TXpn0wMZxMwGqaU_M4xHpPOwmJTpqTzRIuoC8GP9Huv_c0JH3e6UTsZw85mdn1DGyNtR__bvikJHlhTcJWU3AHFMS15tfWkfYqaNyiczUf51AD5vv2sGa-e9D6mfwGqOknjgFwrWQq939jljOZpXfmaguQHnztwyi0hYQPHAR9KJcEqhfQsfVMLahKTJoSmDQTAlqwD8sjQsOqMr5yNCoAfOklaiP5PFgAzha1x4XlCB6Ivk7U63SwuDPEXHhoglF-ok0OezdqTTjrmWdKa6dgKDVst3G56dF0CwxdvPFnjTppus-WatPU7oLRxkquamMs0Bus3h-OqFe6k-GxeuaNjSoW4sua-LqyAS7KHc1_EXNGl7-lpbqMfmGjfEAbUvUoDi4KL59Pg7Rc90j78rqAaWJGFyx-Hk6YdXCnVewFh1s05RjUGPUiDaXXTn5yq-rNNROXd8LlgA2BfcvTm6BsXOc_Fd4tIWRTGItCylYwtpXsLShnNlleIswmy0wsygBrEbQLh7AmaV_c1N8NWWgjx1hy6UwGsXohrCFyq9Va1M6mtucMg00adrP1nfL_R0y1Faq2nXTOZaLq8edyvSgSuiA0_qakvOXWicDxgC0IcQN8Ch0bxx45CbVSsBvoEkC4RFtqyXmwYoMS819jQAOxqtuNw1MUcYI42p-iOLAATYvGvmCuFNkmyEfGroBd2G-_w6PVxBM28AFaTYEfiuAs3SNftbm6PkD1dgCgOMfXnBZAsAHbrlAGq5ZZRv-0zLx1-W4Ea-s_QE4f17Kw_r4hiw2GtC78-lAWp62SrNF5y88fyEy0ZxYAAgG5B8ASRwYSwXCpIdfM3BIgooI_DbbSigxDbISmOuzYmBLBvbu1GOoLcIC-DQyjrJ0OEG6CwArbLNHINRkIAKYwAAiCCSOEwB9gr57gTvWKPHR0hG0jIJ2xbfNgEBmTAgSmvcXpNb0mTLJx8EXats22A7cBIO37WAUMmkkqAPkwzVYjd1-gWAKtGqi8Au2iAbt0fKXfLt0mGTcAau2XcfCD2Igw9921gEbtG3R6rdhcO3c7uVce79J_u_kJjsl2a7zgOXnmAJQFxLbB9me-HSkyB23Uo9OAMfadsJ2L7OUI-_EBPvO357I9wgGPfQBX3l0Td2-44fvtv3Fs9i6IPAhZBUAcGZyQTCJg4RYg2hBRWG0zRFB4AuFfEHLAA5joTRN7Z-M-8XZtu72RD-wPAKYowf_2V7jhnB0IH5Pn8h7X96233aduXnaptYH4Kg53Qag0HXejcgbxIe82SHZD6ctmlXBbVUQnD1B-g-nKNW6xzqgR-EFIfOro0-6RbPRcKLgXruu51c-ufjOsXvUhxl8yVX3s_3X7UA7rE_ZMfH2_xBWS8-hlX2bQCTGnTaToLJP3bKThnLpBOu-m6w_pAMu0UTN0AetPqcEeiAg9DhQBIA5NAoE5yJzxwLQgTgdUTImgQAdmS8FeOTUkDJOdmRM5ivaO7jLw7EGT3JwLM2BYBpYooFIB4HJnbZZ0cTrobzIFk87ou9gL1T6shn2BxduoCc9qHB0IzLASwJp4adaewz2nnT5HY7HPCQy5zvTuHbaeoAEzNTD1s09DJGfyCkkN4RQW5EmdLBrB05tyLzptMqm8ZkfLOzrIdDWCFBSg88FQg0E_ZtBNs0KQLIETjJmZWjRTgQEWQnxNOKK_BftP5k7xMVaAXLZEHfgqDMnMQWp4C9QDAuiA78e3YDcaDqFXt93S559vlC-6UXtg88AuY8uYurn2537X7BsFXOcXvsUUGDP1NjOVnGJm7pDIRk86LTvvLbtqAR1kuKXHTvnV0-peQyvY5phl_YCZdB9CzIZ1Y4M5afcuCXNglc-K-9UjOcX7piIfdwlc9nwh5gol9y6Nn5CBEbzvmBrClDChULCJu1SFALVLAugYAcZEkjLtkK1DxrlrZmtRzFwlS7JhmsKDfC6Hr95gTOo5Adf6GM9YkQbna59dIRUcc1x--bEtdl2Me5ryN8yS0MH6cg80Bgn3tBgxvEEVrqAGHadu57DXfAQonNYBM452lKBOa33IHklMsnaam3mm7AQZuAENvCF_AE4J96a3GQOtyv09dSkbe3r01_2Lms7o_oqFlR8NJysXHxwlWZmWfwZnbsms-IAqJbw6PLGMXRL1F-eCfPQHbhtWZNp1n9sjagUBmqPdCu3WVQ05lUJEwMPcuG6V3WL9d0MZ-zvnHxQtSqBlTP78H3jisKctZ0GzZJKA1gNFFAKXXxAtY6erV68e_2N8baCcH7FyzHCAIT3xhvhiWqdvevsVchlFREAlVEPHZMymgoG55ohQbZYixbF12j2zHu6eAMMGV25RuU8Kr_LslJkijq8FIVaLrsAIkjkfKPDmajzMZip0fzoDHpjw0REtWAdjYXUUIDTNdMRLcpl2jMPWXyKL-wlARsZxjaCU1wlLdAfT6Fd785K6sABWuQEQnF0P0sQI0KnL0-ShkgCIOWNzjsDHyX5fuIbOp_lCd7rV2ALiMg9I-ufbba2oJ-2V-bJ3M88ZTsjJg8jV18g1Abj7lQHLuUi9fxNVOJi8_M8ZuA6vz7DQETZA0KIXroOQBJERfWjwj2j_ZXhxCfYHfy2DxADSgKRlQnAOsPVj7WwVqvEAVgawLwLTLxkKBnD0AVBgQAw7gGixZ18WWKqWl8b6g-wUeXdKlVSsPpe4KAojLg6tRBBiBDQAF2VCxhEpVBhZTfvpYf7zeAB5fa1EOlA3_aUN71WuCZvy-RALk_QBzfE6C32pbWE29ZJtvjGIlHMtGgzpt6kOcbyd6m8uD-lQFS7y9_RTXfsx-3xkJKRKrJxlvSDkMveTixQKIJy-aztZJExc4tMTnRIAEG6BILYPLIBSw890TmBexUoe8oEDiAuKYQZi3xXEHMBOeYacNHxZ3uK6OjzqU1GVZY29Q8r8PBAcjDaPr42y71qANNRuqALzCIAUwmVVFPFXOBIT2ZSMJnV5-Q1iy8DHehvDGC561G36J8DKtR98QpqOPg4OYB0GhTTPRwICiQvkiNbxkSywkmGRE8s6xPEnsTMxF_m-pZPwx2ZAp4bE0AiQb86YDEv73Hgs92npTLp5gD6fDPdv4zwYVgfmeDPMIBKIRjOR2fJgDn5IE5_8adkvP7n20vkNsAziI_HX63z94rpfejvE3xwdN8u_L5yMjokZcWUz_Hhs_nNO14r9TqoxQYUMUH1DQL8WeSmnnkdbzfP0t_ufbfqNF387_d_8_4fvv_NAS-D-E_ly_Aqh7g9mIBEqa5wdWqeoS_oAkUxgl4_l-t_d_pwwZvBdKwCIV1sAMHGe-ytqobOGVHb697Si5OSUb7x4x-4WMhbiiz7qcp_vuPgek9D3yi9GaMZSVR2APSHV4C-Eiz4h7_Zo3ix6qUqznoobdOWAt-EJ91gAMqP_yQCAArDXy8q0WANMpH_YHywDd8ZANwD6qcPTv9v3cZFEQkFcLzcRT3WAEk8LXNJVkVuffbiO8rfdTRsUQtLrlz1J3ND1gBkPINxX8dBDDxl8sPM9SgBQXPDwdoOA63wvgnbHgVOh41WQMcYbZEvyr87nHwSdsS_W1XYDy_Ev3WBlQdNQelsgeYXaAKqcwM3ITFMxRJQfsd-AZVSMM8EkR8VPiWiASJOwFTkrA9ACIkPAgSXNU-IOGn8CS4CSFbco0bZWAAHA4uHkA_A7BngBigXr1z8a-cIIECatEILsBIcYIPiChGE93mhsgzwN5JKoKuWkDi4bMSuAaOQIKmAC5OIM8Cl1WrVA1mSLIIaD69ItzNpuoAoIElgsAsTLd1lKoIGwskZmWlgkoBIFqCBJNKHCDQYaIPmAs3Tn3yFlA-0hd0VtXgVhUpg6rHfgUYEoI2D2CSoLmCa-VYQECn8PQMhxNAv73cFtA7MRODdVX7zO9EAC4LWDn3MoMKh3SXYI-g7_BIAyw5qY1AHVHEDHkogbeBYOZklgG3gODqsYELaZUg7FVUJQcduX5NO5GAEx8WUD4N2lrbQcB-CQ2H8h3pnAkcA3gMQU0Sp9WUEBUDEFFLSDmpTqOEBEhpsWEIZp4QxEMWpPgmgG-CRQX4IRxbA5tSxAGQ1EILgB1RIA7Vkgw9zcD0AeMWKYJIekJRCmQmIHgASgzkIlDEgTYMdtvafIRnQoADQ2FDugUUORCvgtEOZCpQjkPFDtQkSE2DUYIgiqkUQ3UAmQX4fYE9t2gWIGoAciSdAsDbQ1AAtABQeWk4hNyc1E5xygfrxlCDQ3kOzx5oEX32Ac_KnHkhSQmgBDCoMLrj1C5qcjDRo1QzulG5SlGoIaDiyD726BPuOpRs4hgygBGCoAMYJLh5vYpkzDSlbMPWDcw0YJaD3vIDxh85sSZWLofsMTBUxNaYIB-B0gnIJR8dRTAGYZJ4OO2XQYAPEAQVCub9zzDs8NVGFBZENAHiAXnFfwucsXSpSIMTsR8DlVtVJZVdpM6eQMYVK-YwgKxQcCcNkhpwxBEndWg02hoNs8YulgcBJMcCuATgf-TExwwqYCvkFg1f1CUZFY-SK4K6J1nntdMB6nqcjgM-B5Dzwu-iAiX0O103CulY4I6gQItgLkDDA64KcEzgxACiA0ARwG6FfQ7kJFBEgev1GgYwxkL9CgI6eigxcInnynCoANUIst3aQxhmwPlYqmgjiIuMPiByIiSH3DSImcOKCHw80NAR9gTYOIjZQpILqVXlDehoj6wu31D9cQD8l4x5gcwBbDzANsMbDsAK6iiZkaFiLRoFOMdBZAzUboC_CTQMRXGUfGB6lD84gbehUx6I0iPIjNMafFdEtqGXmZJ1ANHzgBtgCAG-gbOQzCoji6YTGeksJdAGlNfKPMEbDYHUP1WEgI0yPjD3RCiKgAXlSXE3oiqO-jLDn3CsPzDUw272KZ3SOKIwCEogsIG5qwoqkIiQoxiLCjRQ79xzC8wzKNGUDveaE8iCJIULCjp0aQ33gEwm0mijPlbPC65VhVCOFAKnDwCH4bqL7UjDdw0zHCD6EboUaDf8QaL_DC3U8MIjkHNqLfQOoypzShSncp0qdIwMaNmjSFICJmjuhTqO6i5wCSEiDNouaPeABAJQGb1EEdqIEBOo08BOjdlM6LWjLojwBOVIoqiLyiyIgqPoIgI_VQvRAoK5XoIXBMcHmFOgwFkol0ABmypxAYqzALFfcC9xgB-oVwK8jyIw7HaBzxPqNKUKoswOqjgxaCN5t0YtULBQIURECfAtlJbkshqXfU11ABdOGVFB9uG8HmEDoi6MqcdoliTqUL4WGOVDVQsKMRjkY6CPyC6onYAaifoiwFqiEgdmODE8YhBAJj2gImPPASY2VyetyYsMUW5qY2mNuitohmOclfcfiI3odw6Uh9CUQhiNejgxCaKcxDvTkP1iEY0CkIj-AlfytiUVdfyF8gIzf03U6vbgLUAyQM0ItDWgcIEa10IikLlCoY-rFNizI90WzxxlQSK7xgGStA7c2VfsJGA0VEdyL5kGLEDU0wEBxADFoAKRTdkYkMTBYCwELgLAQvPEDxr5kJTbHTiRICYIjdGFYuMDEwfboEDCq4v0D712gH4BdAc_VhR0E7Y4Xy39nY_OOZgphVomDCphKuNLisIxgiHiFEESFv98hV1FkF2vTOKYDu4-A2zjxkQuMuMRA-DxfDpfJG3yEUPSqDLUd499BBIawPgL-g0g6D1DI2vF2OwB9Ah2mZk-1JcK89NVeVTXDiyR5TT0nbR5Wvj1A3eIwIlwx-NXC--F-KO8348O36oSRRuHHjI_G2KWCIgTEFgBxkVOJLiIEmqxPiwQpeNYDX4mxVUMBoiuK6VbAG8HVIyo8Hw9do4qBJh8tifIXCDdQFSWSAwgnBMWUC4SUAzj7MBNxKZIoFtzoT9pBhJy9KQkBK0lhQSQC4TGRe1ALAsoepXL8L4Vr0pAxoCanaAKg6bFISc9FBMqhJcNdQ38RfYZHmEME12PlAHwiwIgULQQRJEhs1NBLAQqExhIniVEjuMdjRfPONT1e4nRJRC9EiagMTwgJInic1o4xNWjuhcZVUShfaxI0TbE_9HsTphRxJ38EgdxO6FjE3ZxoFnAfZyW44dAMg8AzQbYGg0X0KRJl4m4WRJ3o4eYaNoSc4xZXGj3Sfr2t8Hww7xKSUQzfybgIkt104J5EpRKWDSEyxIDlO4p2K0TsAKYV0S-4qpMMSR45gPGQzE7hP9CbSXxJaSbEheKCTtEkJLmoLAtxL_DjEv8MSTkk1JNWBt6JGMSAG4N9CyTArUzG-94IspMaV4Iqv3z9oiBcGwiCUO7y-U1UbxXtV1NOAAQTq47PFIT2yNRK7i2kpe3lB-48IAsCx4xkSilQeeuMORFQ_YJOTZ0e5OHjxIJykOoaAaeTuSwExeEhxBo8mlGADJLekITa4-UABSZoeSGbjAUqnAUScsepP_AO47PH8SkEQJK88-4y0K-TB4sBOHjs1FqJBTYUtOIgTJccZVBxEUvSRRTZ0QpguTs8JJIlAUkxqPypysfFJjjmZEZNJTsIclOCTOk5z3bQDE6hM8SOEgZMZEhPPry8TU5E8N0UvlUVKeSrE9RLJTxkilIcTpkqYVoAEiOZMYINU9aKvppsflNcBBU7qilo1GG9iPkaCV0W0i5QMRXGpCwb3zPUYYuUFgROadJJy8kIP0DkSRUwlMUTY46rCaSXVUZICSjUmVNCT5QUNPrQYABVPMTekkxIyAVUixOGT9U15KATk001NTSKMdNLyIhAdHEzTBkpVPySBAPNKGSVKbBPrShozVOYTATSZRyThQH2J5CIU56KO99kiCL2Sy_Yv0OTEI5COdw1o3tMwidAtyJKZdknpRuD-lSdPOiZ0oxM1jQwstLDSM0uZMlxdUwlJGSSUg1KlSk0yZNlS_w9dL9js8a1NZThUmxyWTVvTn3SSIpDIC2S6kmNPXi9U5pMlxJUzROLTz0lNM6BnVDIBrTfk0GJg1lU6hK8Zyse1MdSQyD6AWCI0h9IFToNcLFFSbOGgONgBJegP8xSEvpPQTOAs9OwAhPVhUaT44_IW0htEZ1hnjJRc2XxFytEhRX1cgMuyWBHBCGyygyAwQzcIXjeGxwCJDI-Ng9GwhD2I0kcHQSQ9hDVeO59T4m2XEDi9VS20hyoAtVKoJwE4HgBpoKYAUi-IV-Elo5ffeKJSC1OAFBhVhB8FB8O0toLPC9gqPWUzihMfV5sGM-YBzEdYlJQvhXaE3QUFlnWWMhlnAdZ02dJnBflClESAtVb4lYNKEcECqLeiOp19BzPVDRodzKiw6zblzWcNnQGi2dnAMMBAz_1EqgzUQ3QCgLc7beoU3SlMh1zyzYAUKHCg0oKGGxgjIZZOEyN4_VJyys1CrXziQY8dVlAJVRrIRVT_UMltdpMwjx_jO-YpOnULocbwATRoEzPf1zMyaKlJplGQPKgYstzKWdEsrzOSy_M9LJClCfBdOhUgXANPfhP9NvhWh5s7yWLh-gj-LRt2smX0CtbhCbO6xOs85XU1rHdwmWMsQd-FCsqUggAqCYtD6AfDPsssX6CTMkdTzdxCBbOLJ4szzLadVs1LP8zX0-ORtJ5oaMWaAYcskHCAQgcdxtVYYhtACZMs3xWwBEQc-AlFDJLlSoj9MhcOAIlKfEAtBs8NhMpzicteIPi2iedI74bRP-JY4KlPvkRjYFLehrVGclUmGQPjH6I74MAB-JXDWcwCidcG_GHO5yt0knIcVzKIakjVvUOrPbixwKtSdidBStRPTSePyHDZiUAHO0T9ecZOi1VHEfQv9RNYlB-x_rZDSmBXUUuzqR_IGAFoyzZdKBGBhQO3MhRHc4ZA4zObfjOosYbIs1EMEbCDxg8-BdeI31xMs3MWwXcgQDdzEQD3MXDG1OwMjAo8mPIdyHYZeN60izCJEWB6sHWAkhk8xlFjy08xBH6C51YN2cgBaMcB1deBPVwuRULfr3zUHXJYHzz7cuPJwB6hebCVybZBrMMyxfVrM-kZfUvNa1uVfIS0zrqFIB01-fZRPKx2yVXNF91VOTPVVUIFnOKg2c55Ssy3UoAmGCuwDr1Jymc7nE1VWAsQT5C1UCbOr0tw5ZToJVlctyb1gAfZUOVb85mF70g0JfxblO3GzFHyCgHTVyZ6tb0ImygcebDEUt89AGeYE85tVWEgC6xTUA-Q0jDUy4ADTJCBt8iugZBIAHwAMjNgYrjgFMJV6ACAUcicHEjmSAKPQKLIbTFxAbqPtCJyCsVqMxZcwrsAfAz8sBCAK1wlZRHVr89gEiC78o5UfzTlZ_Omw1UBYPAi49WEzYjYAKvNOh_McApoK183gsTlB018SpwAQgIVOgBCzSV3Drs6gqShaCx7PEIC1Z_O6xVCBsKEyC1LwTAR2AIagWDU7YrJDdOAF_J1jDFTrLFzHMhv12p9XZhF3JHxAtVniGUhgskL01IwtWEzkhYQsySmPvnuzvCjQt_skYvwsQQ50qnEeVfCh12MK307v06zxkYVI4ViueTCgdsvKYAEgXQ5mGkKa-D_NnAy1dXJVzNcgMjVRc9B1TaBUbcZIr89VA1W8AjVE1RiKplfISqLL47zyKLx8gbIwBn4VEGFytVVALqwyMv6GqKcEV2gqUF8-ot-9GirAGaKai1oreULaUQK7yyiruO6K-1bXNiBiUDop7j9ctrMiAJVR5Xz4wsQZiE8wtI9wk0LcqtBc0CAmY3hVMBQTTwDJ4jFTHBz0EUEoBp5ZFEZ5x0WgHzh4kbelNQ5ZAtWYzOsj4oiBnAAAEUxsed2GK1UVCEcBUMWRGHRFFMGCzz5HEN2YyC4DpAqDyoHZgaFLCxEAhKxGGEp1h5AbMWDIES2YCRKCZEbDGwJIKz0wARsQ00UYuUL6X-o5mAoBMxEgWFBpL5nWRDi9t43fVzDm49ZMGAvoDNzSgxXYZxpcOXKLG6cZnSwDFjIUQmPm45ddQkshCdeYURKBSlIHpLSMztw18ASmkBJQBJN9F2oGVOGkkI4gT4qSgxSwo0lLrXMVRWohfFaJDYM89VNtYgEPIH7kJICAOY8RIxBn_AnOHBkjBigOMhOoMcyUWOgMRHIB2VOsh8BOU9I6NkBL_wLoFocUysjNXQooyXFYUug0KVl8ZsefK1pX_A7M9LIM3RCgBdqUfUoLEEY1RqLTxRwQXCGynBC4BfcRMq0KN6IMnVVuTZtQXQ-QxAzfQQy5WCF8By7inOLKAvPx-KeIP4pgASSstT-VP8L3K4zfctwjUcPoHyTZdKXTl1lKeXOlwi4xdRl1TNtQfyxfMHFJfKXKwEeVUYVOyliS7wuaEUoQITSrWAx4Ly2YAPzrykbPeKny7gNZY5yl8t1zp1SQNWBPi58tlAaQdLAgqgS1MppBzEBIHl9fyoAkAq2kS8pmASOBOD7LzFNcq6z-7JCuGQUKwCtXBAKUsvwt_y8vQXLlyispI8V_AQ3hxMBcPOPchA8rC58b41YvQ9KATDxUoZynLwor8K-PIEAm1cxVtKIgdPOGKCsf13gB6S6UrF1mnPcp3KFS6Lldgpnb0yVKVSgmOzxJY6l0xlPTNyAaB5zX3BEqvixhVWFWy4BRsKPoNVJ6wpMLoHxjugBRU6yfU5uhjiiSvalT8KfRtzPkh4VRSppkgEkpZpqAcUt9Lw4aTD0qTQmvn4DQSuZTYKdlIyut9Oyg5VFZfi8vWKBJcTvNtif0qiPiKQ3U9MiqHXUzN9wD_L5U3LljF1xcLvoq5U8qwYTyvpKIM5YptIrKxKlDybZMukzw1EzrNPS4q28qirak2-h8YsoJ7G6BHKh6kWoFPez2c48gXWjOg0gMvXRpFPJIBTFzAdgU5zZ0cZRlyf40AvMVHlaVKgKKyvr3G9HK4si6qulO8pEjBUZqoyr40v9J2r2k-UE6zjEvKqxK18n6PSq1_ZpOuriM95P1V4IiwNuCuAeZP4qG8p6pTLkHcIPoKqlX-JFyV8sFFbSxswbkBq7ymGtSL50urOnii8sBGv9540bOzzwglMsEjFxCcu1jLiggEv9zc6rBnViKrCpJQByisuDKcAUMrHKN0f_PWtPzO0mZkqLOFTQU5iKmjQ4qKk21ICfcshVIxLOITCLAZgZIFhjjSPsJJJFFeoGsAdRHUVAFcgLWByAWAbIqGwPASPwuJ0CshjZKswY0VETqAIbG_4rRQ4muScgRsOJ9dMtSwQsRrcfVFdZKoZ25czy24S5qO4Ka2Gs3Le2uu4zBSIQW5natiw3crgNVkBRMMITxPzcPegid5TZbmpt4Q6jVVVYhi4qCt446uyzwT1SUXkrROQWYOQcNwh2DLzQgn3Kb4xMjQLNzN4hHA6rQHKTC6F8VBT27CEEXsKNFXcgvKSYUcpWoeoVIvsAcrY0yTMfDm6lvPRqzkCSGlVj_WVVWEbyrpS0Ups3HCwTnc_uvdzB6og1go8CUjHCKIJdAoUVvU-Wl2komIyLcqhq5TM9FjgejBsgDCDbLJoC1VcASskLW3Jbq48_zGbyF63dW6zVLJKtnKh0T1IU84sCS2EDnWMtRHrmc1cCvLThbVS3DpcORTRTf8POoLqjMi5TMyqDCzPWAq0W1z_r2ScnNa85FO-M2rPykBvErQtEfSoy5FOPOAb9pFzMYyLlZrMWV6hShv2l2M5muPVz40Dz4y6K4uqg8e6uNCEzVikwyYqYfViq_ilgsQM4qJA9-KO9Z5OnP_AiPXuvqwYGz-II9bYwzPMNhSsCs_xpYfVHIraAT2xzrhPN6kcqZI_sOyAOfQdFwVjFbBvdL60hlXcL8q6KsGiuAK4mgbDMqYJ6qjY4t26hBogFLRTPadKEGiWlLVLVVJlV6qJT3qyIoddT0zsqmFHBYxIP9vGg7IBV-orxo4S28su2cadDS5PaKT4mzNhNRCrOlddwEOa0P92A_OocbOyq1ISb28tKvYq3qq6uCacq-YWKbDiogAlVHqxEHXoI4iOIwxzIVOTK9xwSr0a9avR5TJyXCRr2a9WvGQtnjxkozJ69-gzsqL9uq313XzpGjJqxAYGxxqsbNYiOpayz-RdMm8K6XxvaC6i04L-qQfZ4LoJOy4fJSCOE8GsXDBspOspJn48bIeyrK9lIuaRvCzM8ahsrpVczEYjQ1bKMAd1y-UI7NxGHL6a0cqfBN6yUVgK7w0fPEVfGaPJbr_05eNVBbUliqW8V0WsJvp7yTJV2B4fSUR1EtYAQF2ocgIOBJKm8mwFETjwGrnnB9GnIE0w363io0aJwWAVRAcaPrHYA9ufblWhNgVRmxaTCxWuZpaWv4oRlDuYnimaC1EkuhKGShZpKy9A3ZpyAy_AupmKEI24KMqciAkqWK76cEpFLxWpUnTDf8DVs-KtWmVpeJSMI2sNFmgBH1uoUJPsILk7w5JjpAeKucpyAdMgosuN-KtRrFY6W9-2d5jq4ZDdbkqmalyY1ARFlOrioC0AVy4mipgKw3GuFNizzk4sKgibSGzG9agk9RvaDJcRNv4qp7SgF9b36vhkhqbmipWmbiyO8sLoiCDNtUb7WtBm9ZflEEqsbFZUVs1aYSgjJMLw4hDLaKaAaHx6pVwVGqQtiG-9zqL2ynNJtTL6PA3Sgk2zNuzaPWzEKm0R9flqyBKKoAkQrlGzfKzaK2yVhfrJbBC1NyeGzGq6zdxRx0ZgOZFvlcdvhFIRTgqTDzg8BqgXWHohsGMABDhqgAWWL4j3Ha2elyZA5CC4bpZKSCpYAFCqTZ3iikAI4cmpKAFZQ6iwDMr89VwCOYuwGQhvgC8RsXFAIwCRgg6_2x2laQ3IVog0NkOoFDBcanOBBlMMRCDqedz9SvViQGOTPBf0jnG7RgAqOqWWrhhXfISF1tQZHTC4PVBHUY7mO8GRxcmLd2HdUwZBHW46OOj1RxcrTXUH3NeOhHRE6xOljrBlNXN4tQ6dgCDoywO4d-wsUYYwLLNsLVTslRLSPK4C3RIkRIF_RutdZSczQcc-vMAvvNTsJ9nmWrTwIzO6zoyCQCwSsTzAY4_PyEC5NCgG5JcQGJTx0QzIPjawY9LR86dQtpCoBhQHSCyAJQ34JnwvOwLoAjgu-hDC6pw_4oNDfgvLKD9oum0m864uyUJC7hAAQHC7kujCJy60uwFnMoB5ZtLmN_ADzt3IsulLsBZQu_LqS7x2OroUJM9RzqEqyy2gE71BynWI1QmfRgED8iU8_SmjBu23gdAJIPrs7IXlYSNBxJug-WKhO9abksyfoxbrY9jgLIE70noqnBbbWmyOIYar9aOK3dLO6gArRO9bfin5qqzsjG6QAq7vEx31IZlPVv9GDu2BLhTZuO6PwDTr19zzAlEvbvAVTvGFCfKtFYVasYm2iBg6qflBhkwBm2JsyjS82UdVwLXmKNwegrl4cEe1wEptYeiHq79h3A9FIwtGQ4m5NXFW4lN8ogKYG8V8gWcCtzv9XUByhnuy4UshhQUntfc2-azi7B_PFTDRsawleNngtOuQuX9d9XTuRLKsAzrrEjO8W326izMYVYdO1fGzB7GgIXsZFNedHqR7TCvTuF7NefGzKM1exXrR6MelICuALQbXpEhh3c4U6auuCrwkgDc8ygm62-ELLHAruhrxq8Bux3qa8WvGbPmCNu3nvW6lYO3s71uvTWNm7Peg-QG7Fu0jxeJQ-8_TCyg-tFqaios8zWj61lVbowBw-27vkwberrqm6n0_7I4x0-9vjCsk0f3quISaAbrGE8bf3GiAXiUvtB7ZjX1AiyYojRQ4xioKvuV6K-nemb7KbHPtMtO271Faieo73rz7IreOkL7vUUHG0h2e2Dxri3mqABuoBuwMq-Vp-ucFYEJIZMCMhB5JFqdS-vBfr6aYYsvqptK-nfph7doykkp6VCGbtMwt-pvoP7le2cH37KAOmz76F-tDKrraVMzjzxXy--RZps7LgFzsR2_7vv65wIair7NeucGKhkwbGCUhIcMfrS8J-7KOA9iE7BTPAae-MlqR6exnuiB9spWBcRwfRDSjjsFb3RF56CCPt31FYVPtazVwMYRx74ofNnwFUyWpBbVtgPHFYUSAi9FXKLG_ISzylgahrH1x1F4EuFrhOPBoaMqOrTWi2M5VVohzk_eCmawPFhvmxQcDfRb5myyGu74WOXvje8JISvheI9DLPvmaDHaKquzusahumxEtaQu6FusdGwK5-BiPHQx-gwQikR_ACDuf9akELJ2bp6lxtpVnBxoJsHakOwbgApSrHCSaZW3_HqERoyHGCHEYyMMgZvB-wfLKSqXQY8Hc-6bDiGxhV7oRs6eiLXYzlkr3TszpMbUCY7eOt2I3c9u0EiiG4ABwfoVbB_wAzdNBz12763gve0IN9K_n131K9ZgchsiNWQeWwnXRGLM6_m9Ivx7svcvVpUVaNAaPlkGEz00wpqVqpmolMg-TsRI_OoYtUacDHH40s5UZimZtYq5OgrC6_Ch_ath_zC4GpmQQfWFGq2Cq1h4KqAHG4Q0V8oTr0Ki6EwrSsK9BI5cKkiroAzS1wBGBZTCDp66uaADocGEbDnAlBAOlwuA72afzEyAPhgjoOztYuX0Tbfh23uXqRIrQe27wqviHBHnuv4dSATVCDvl84RzAfeiqIjdUVtOIX3Bl5B-pNAqqqcMHmj6KRurCRiDMeABpGCsdoC2oj8RkagwkY2RCiA2RiwF6qURwwyA6BWNKG0hnu9LCU8ffBDunACgbEbRHakL4b5GabJAQRskBtIYK4GegQFJ6Vo94fRGoRvqvwbPaqiJ8kBO_IchSg6s6usL_Y-KTJVYOjDv3hsR5wouQQRl-CZjSlZIYu6FRztAX5_Ys7qbgAtd0da7jwX3C-zuyyXGm0yOsZEIM_lBoe1AWmvbvWJhIkqmtLkSZ0uGTXSs0o9K8G8Nq6DySX0rEB_SyAIJAhAdXz-hNfRdHdKhGDwKnt20LMs7cCywnyLL6q-QtTGMB1wB67kHBmXe6SBrfh9HzzcQae7ZRtviU6Va5sZTL_ZEGwx4rRl7vSGdRupQ3LKqxizcgUzJXWNH503QeQyBY9sugjLRjsboiYYhWWgjvRl0D3H50oMYKwdu8hVMxzB-WEsHOwEbqfaSa2YBfaFwM1GerSlfGtjG6sD4AeGaaljjpqGar9FIUfEudSSAP-FjlDG_wcMZT0wGW_WjGKBRDR0sKEqT12pnus_kEI09BdxvMIoSTp47pO29wCta1feBX093DaCgCYTT4laQz-HN2J67bZt35qWBwWs-6yelUhFGxDRG0g9AKW4mcGFMxAvkw3qSRrl9KJ54ilIBJpITZDzFYSYYHaa821qQ6CglI-GnB2xuRaa-B4mQn7iJiY4mlBkjlUGyogiZfG-vZSbr4Xm6bK-UXNWgcsNxJmMdj676fSfn5xoqfEHcnBhZMmVZx2UnnHFx7CfBlfcVcbNHTxcSaWV_Yv8IHc5JmyZEGXlTvFibiynAf_Fq6gDu6QjsFxWpbbiA4zUnWkdrsTzrJnYAZUKFcSbsB6FbKcFzlw5QYW67m1Sap55J5zBeIXNXHktxnu8blKn5-DQbQzOBfdrjgpTb2WPbWYAqTPaPHQ6BMwGfBEDyc4IAp1XhdwWGnhoAoHeCyc0nQpzXgsnJJxrgdmO8CmnhprJzvB6ZL9o7Jdhq4Y_h1pgEfcAa84UEdHMfJNixGWe9adlN0Ol-Ew7TpjCXxVHx2dBkx9EfWU9BcO6UxQtIRpWAFl_FWUyShu1OAxyAVTV6f4tS3DU0FNSPEjuiZn9Qg3Jk1TUZhBmAbMdxyGmOqRHPBEuJV1li2O3IbWMUZywDRmfVLjoXHczZGdRn1XWWOJc0XbMwJmldImZxmSZn1TJnsXejoMFMZ4mNhkgeewB46JnDGaY6WZ-JPZnxnf7UZm-IdY0Z1ruNc2cBvYfOoR1hZzY1FnJnCWaDNBZqYF91qZ3GZGcEdZWexnVZjE2E6NufcxVnaZ1XS-0sJrGeJn_a2WPxm3Jk2ZpmzZume6M0dXo0x1IZbXR24mOhGW1BDTSZ37SLACmctn9Zm2b1M7ZynT6NLAJ2ZV1XZ70w9mFZ0dyLMBOv2f5nrnL7VjnNZolyUqGZ6ObVQluV2AiErZ-7lTnfTdoEzmUZ9szjm85i2dzNnZ5bnjn85gTorm8hiZyjmtbKYGlnSdfU394PVSubFmJZqWc2MRZ1ucNMwZDublnzwB2BxctTFGbhlm5rY2esB5pjs7nh5tXSzmJ5nuZlm-59udnmh5kefihjAUwHMAjAJ7vWF7k2AGtUdiuwCGp1wQ6gglOyUOCOB9gWjHbRXQeS3k975n3yrpkFQ3w_7j5B-Akxd59gHohvFH0AsBgAeFlohuWKqh_pGfK-eVg9gKOyOBn53TL3m_55WAAWKIYBZIUhBqwCfnT8V-ddA8fdAv8LzgSCfSgvRQUdhi4FkIBA6BUBBeB7UFgWIKxj5ybh9FkafBaACOUC6gWRD5FT24wqaUamjaigXkDMBqBl2iHID56NvoX4ASMcjJTjNBeOGeM7eLtcJ8KPGr1EOYALso0KLeMf15F0_D6tSaSRZUXAqIr3UXHdDABPnNGrlkxZ1hVKebV8vSApIyM8ovinJFFglBIoFQhYbyspybRfy8NyUEncX5MXMZgj9ABRcj6UCBxcj7GANQJoAJ8MgV_JjFybh-VL0I_MancBtfnyVJucPW3m-FnRYr1MWDEVMLMlwrlp84SfvTMQ-FjJcQXMgOUAohzxEBYezaFqBUuUEF_-YqXgAK2tohG3RwES7DbEuHcIclhroK6S4IOHNcxpvagxFSlxpcAWql4cFpxaFnUm6AXFZhFTtacUZaQWml1Bfy84AMRZxBSW3JUUx0C83zgWVad0BYXXyX31U8cgKahr16l3-bGXKlz8Voh6hOwGmWiluTHQA_Uryt-AfKzWt8AqxMEB_myl5BaAWBWVpfWE6sUathimF6IoIWR4PZdPwKChpeWXAFh4SBXTKbtU1hNyg7wm6_GKjDAURwOMh4tRpiBbEg38aAX8WswJnzgXSl4HsAraIR5dZxThtyo4x8C7habCLSvMD0bG3XTz-m-FvkFQxW2GgYjxzWDEQqYbs9EVgB2lxrs6XQOyZeZxJmdYQ2WJEGxFYyjllYgAQ1lmcUbQb6PHABaqyiRuQYq1fleyWBeJjOzy2lvLr6WVV2VZiXC1T4ykIkmwye1T-xRjCLGxgdRlLHszUbC9AMAV5dpp-TEAWZpolHRkBlugXBZ1FPKscEhW307rOQcZheWjzwUKlifOm9hm1bstDhpVYnwAEfAdFXTVprslWgMC1b1FtpwomnFNYbi3eCjvONYkhAK84YDYFwGNagqtppQkUbgUhgoxFAK6NLpW0xqsstKM8xanGQUKl4bdK0R96ZbGKy80urKasSXAuXZlUIvgM8yrUaHW9C-hoJrQyVhXAKW1rYbSWTADJfJ7k4t-ByWhqbdfyWvl8EieXzqCughREgDQ0ulOwZIEExSenABKXfl65eABqQqUFohB1kQuVVSlZGnBGT1xwWT0f-GEEHCjgJGnQLo1lMTsB60RxCzBU5D8OAk1YSwB6YbwSyB-gcmp5aWXylwBdQWuhOAE7F2GH6Kl4vAnZa0i30dSQYCcfLMDQKqQd4aeX16qCSCBqWkcCmpPQpNFmpsmIgtIj-wG0dUZwsx9fhWKIFpaeWxVs1fHIelrNYlW6IQZfDBnIRt3Q3_l1BehIuN7YAcGNvHEtYh4gQqF_CpE3RAPkyVrBac5CuKADNB0AZIAuXTfHT0bcv3KSIY2dPHjfYAqFzt2fXEpalZpXawc9cvWjN5IGPAVYVWrb4uVgRd5WXabdYFWr_d9ZgBkOrSRw3EgLsVM4TVjpYmwyQZckU2vhtwi64eN5DwA79pgQEOnxx_9sBHMt7Lc1GIRj9aVhbi5VXmUTppWBxG8tgUdBGlgF9ZJgu5eXw7Eot9hj-IYQjuUa32M6pUt68CVhQYJIpqNaS2ytp7pbWhtyrb_WIt3DYDHBNsTfi2q6Y4jG2WxpJfMA3N20d82R3dJZ_mdhkuCGo4yK0S2wGMH0W6IaN2TZWXAVo1YeXplhRHiUzWyURnkOFvhQmHo7P6bM2lMdeE2Bt6TytO3MN87ck3-pw1zqVrtg4ERzzYIZZo34sHJZaUugBWny7sQQjZIVCoez0e3GN57ZT1Llv5aaWBNnN3WFpYOPHShVN3sC1UK6PUTOhT8kNfQKLRQqDBXMFhZAyWUlkuHs8kUrhepo-MCMGs3ui_vr82eVyaCEXv28RYmyAEP7bJYh3GOKEHcdiPDShtDZbtZVsFVoc4z6JvBt4yNGwPOFp_sqMaaGY9CMa_1DeGhpnkAIMUafALQN8HmwE4qZZEynitYaWHb6SERrkh6lYYThvZHuRsG5rO8DGbXgn1AeyK2Uxsr4Kyzytd3EEbrxBjPbG3h7lA9zck8rNYlttLXy1jgijVPdyxfMU_8ySZr5G5cYhHgJIUPYmzNyL-Z-WJK9gdTWYVj_xmMUVxtFI7Z0Kbe6Bex_4LaZU975aOBBItVGCGM923YEA09xZXrExRj51Kz4AbWKF3EQVCwT20xvqeF2MRHrsdZOWrFsUxIdygBLgla-IA82LqRSMZbraygtg92VglBd3EgcZGMyHsmwMGzCp8YDby4a7OKGXZTI_d0nzx9KCZVR9kSK1WgWj9CfA55IdHZX5hPvZgAz9_Zgv2RNpYOKrawT_auA39j_Y3H50tZY2XY9W4QYJAx7PD92t9gPaz24l0lFH2oo-MciVq6xKHv3dV9oAsgHMJ5df3QdqTff2MRc_dDjoRosz2Z6RvsmRWNlr2dKVsd5FfF3OwV2il2gI-aEz3d9phVJF39vNZPmgIwKbF2viiPB32WsrRrz2LVbg8m4GD6Kvp8hliNrqxyD-EEoPi9uVegOiD0A8tXfptHbvTdR5B0bdW14ev1Xm1q_y8KZ1qiMAPVDjESE3s133EOHoD8Q_gBJD33F_23MVjKAi1lr0aLXS9rbrqwTh65Q-C9hhA90Othnw6eXK1pscohJ1h7LNc514rYro4Sv3NlJVDuw40OAN_fRSdZDhI7MQ1D_NeSPsgehB4h0BrI5PnJDlMpTLG3eIf7BlYIowNXiUICNC2sO-dOw2K9_2LMPMjiw9m30kL0aIPbN0pWCOsLfUZW7XJwmeTmFuVOf9ivJpw492Ws2AzR3Zlf2KAwMRf2JPHgxxqJ7Kzi4wkrXFqJEKgAUKhHCbG-QsCfJByOiMegmYxlzS-mMRH6fAOzG0_dLdLyxt00miDz_dOL6iOCa3nN1rbb53cl-WsK5KuSuiYgXgaYb0aK6DX3ZWdReQ8cRCW90C0h1tKMqOAdaG6mRpUIDJe-PxqD8lxWNPReFgdRqzOiGx3G47b4md5uzauW-N5pac2T9gg9lNVMN_ZPWdpDhBuosARIAEgiwMLvyWcgT_a535OQRZZBtt644pOb9kdCYG3_aGylJnJ7ymWN2OnmbZmOZgPUSH2LAA_wP_thY7WP5mgFIU0y1GQcwFHdlvYoL-Qww2ja1Tz_Hu2JIerdpD_MVU-1PWQ0evSOP1d_WKhzT32U_ww9jg-rjkotFsebTMe05dlDTj0YRGSqFzW22zT_U-1OZ5UFRaOYATgiAYoTN48JO95roDiVCDsSCGoUT0WR1F_jm4FZWZFGmg53QTuwCqmCWuiGhOa4MgrhPMYE6kRPZgb7ZQXztz_cvnF4c11yAuACwrjOJQYbl3nuVxubEx4z3N3Sgaz892yHC57OZLn653CZfMaz98w7PXUcA-7PpOdKEXd3LGubDmq598wuJqMNJgzPggGBRxbCuLsDzBU5FTE0wAU_zZ52WQOMjzCBLYUHGQSGtCYFPO3OXe9y6KpwKkxplzOhIVrOD8mpOvt-ZrDOct1ic1O4SGGpuPsQK-pH0AztNSz3mAwC5DZus6E0_NtIA05MLTUVYX_XOqRAMGsGJ6ReRXLmn2WnBAKdYTP9JCO2quB2OuOepcXatcY-gQQtJXSKx0UBVRylYURINrtlj_uhX2F-naUUeFy1qvkaL5klvnBK6MnKwAUoQY2XNNVqjTXD5mAA2XrThDl0WeWEKwnXzF5FcYo7HCW1_6qFdxsn6RTkfVPOEgc849iowf5WgvurBFzzPkLB04QubTr3OutSsQi_YBjZki9liyLnemAP1iex2jOMlyc5PJlF2S4-dclvRt4vButhddABq_bDq0J97UWaBmIPZE8qqWiwvOXOVn-c-WDqCRg_7_Lpn1cQ0gJyuYutKefarETNl7aAEqfKhUrOAV9mhAWvLsBbtcBgi0HZs20LBbBWC3JHfo3zqOMl_RsMsvkuWPw1mhIXFMF3O96e9ts8LMuT8wA8uwEU8nWEJFxQ-ADGB286FOUA-I_9zpB94yLKbdsy7t2N9LU9WuO4foLYugC_3fMvdg1cBNPGtnuVZDTGpPYzGizRuQWjtToQ9r0is-xcwvm9za-wvFlNZedaDgHKHEuhL9Q-uvnrwS6SP3rmOK-ukj-NZEWUJSS4nXyrlYjVw3rs0g2Hpy7I_CL37aQ4IOpLoG-jbvr7I7Vw30IUIxuAbuG91G1UNi_FAXfZG96mZDyXBxvgbqg_UO1cXPWpulD9Q5gyKu_C0Rudz4AvMpmC7I5JvLcDm_QbJlF0W3yNfUzbYvzqfE5xbmgQkLiA7REMdcsDRwY6pnhj2Uu2MHfIOcdmp9F2fNN3Z9mecBPJuU7NHhV-dPpu8bmm6xugI4m8QmhpASLCn70y_dZuT5pG75uXCXch2vJCva9Tos9tKDYvHb226XX7yAM8yvRb-n2z6WsuAFZ48ADZaAK0oI64RD_MV2_CL3bodp1iBd8O8jvJCqdumwXNSXFAuU7vEDTvwixPW4afZVZAAu-T7EEgKijt29gPrymDI36oz7iE22iT8UDZUINrLS8CjgXal2tuUlpSDgMTmAChLGQAQEM84VjDdJP-TWiFENh6dAqlu4CMmnyJvtqINuWnlge4yBkgKe6OosaSW6PXVkEhQpWHNgTYiQ4Ac8EFBjeqGhOZstWwAIwtYc-_HUyuO6YAQbsmjaxF_prnbVQ3YeQ8SAFNNOVwCMRFe6Hui94AK890xv3PWa1r4Ew2uvThnI89z9RLycXTKIB6MyXFos3n8bVOB5mMEHrxakaxFe-9MXQyGO8RDdIwfavPbT93qbXBCsRVuunlAPvP7K46Np5SiE8DRqGn01xamB6Qt_s4PULO8FC9h98vOXvB7xIHP3UKj8qkIfd6lGmwqFTyvymu-G_ZUHHj4_aeOPafoP9XoAQNe7O2HxtA4fN97h6GW98qMGgIZHhbpyXAhktzMQfG1wcMbAyM5qkyHaMfzfLGFGVR1O5fZR9gUMA0t19PAbwIFRBKT0ULokVHu0VQto0cR8_x77hA_n6qLm0k7vnpDYUqjsmru-n5PUTx42nhUFnr4fV7wu5FBjUlB9uqFfUeqUIF1xJcYayHjuHvvxQBkDELLmu5LL5Z0XR4rlvUEhvvuJ6uMSqerMZp96C1-7gmf6XgJGNUx6te5m4Xyfbelhj5aY1Rn98BXBaGqMgD1mGpMAYPLPustV-p8vPwrLX6ewgQZ6OB_pYXkOOUNuJ8CL1nwYBh9zeuACvv5y-Z8EzxwI-5PvI_KgpTjmn0p94FZn7A4wB772epIbKnuJ7uexC7rfWU8CWwGPvz4GhNr4VvTYjP70obB9uf4AXgQGbsCNZSnopSBHPvkhMZRU72vAqZ42eYgLZ7EVSOtuihXCQHp-WfNI_iHgKYnhuhNBRWKsSWBU5E4HgKKqebG1qLgbp6zOsAPHPwE4sSJ-1gYnl2lpOGArM8T9I0axWkUTRFZKOpHwianGAHU7H36AJwnhOMwL2J9kcGgXnWEiy4X8MmCfwXsp58umdymi5fVMCnqTimw-5577EEEp4herYYetVf3nk14-dAn2-k2otImmhcC0XpyMXgvVq-XyB4kBuskR4QVk_NGomRi6Ff7yXeU1eEp_pA4XYNhkCIVNYcaGZI2X5kg_uA7P1cy0n2foJje7Hm54tf1X4LGae1vD09afre0aDn6VKC5_-f5XmPpQPysexWEBdgCYqxPUANsFGeQlbUVP4cRp9i8C2NiZ_xbamPpgqLt4rLWyAcHiSBTeanklFYASOWbj75Z-gMjUNe3oUNzf-br5UfY-n2NrRbgXpV6-VHnmd52fUjhad5KU3pYA81R37mS9e2Uo5_2fz7pdTvvZ3lwhhffbpzPISiny5uNf1Xpg5YT5oGjj71VhR994EFwxbGB6oaP59PuF31XChpjnm-9M8HMe-5ob67wa4C3IHCkFb3fIjd6ifwGZbalIfJSedlnxZ4ed1vA6oY0Csi31SUBforW0lA5A18-6Fi50EFVeP4Zo0Bg_afXyjumD6BTUQPYAP-4M6C9lOAQfpr6OLvPWBuxaYbldoupN389pC7_fLnp6llf7mcT5A-stW-_A_mn3PPYB37_h6Y-Viu3iMHf7_h-6x8vBB8Ufb6dbxlez3muPu99FXBLr1zHi_NU_EPJHEd2EPkJ9PzDsC5Q9pskve0QQMsQoaBy6sY-TtXTsAMNKZs8ci6uVTxChv3G5rZ--nX9pUNbHkuyupTIb3LKhVi-iPupRz2l0KhWS_FjzO7luXJ9y3Q-8zDeew-1KfW9_3VhcL7c-Wr4pXw-Re4nJI-7RMj7me5Xoz5WUT3lxUM_XT33AqpSPrLSDQJPyGiLDEvqDHXeIPqKPyfT-1d4y-ADdNOVgD8KY0IA-35p-Es2mlmoRcKqdjlm-u7rg2zzzr5OrnOIoHL-nnB5zD4dgRzzd1iwuyw282Jxz6AMoY4Pqb94l48UDlW_X2_q3QnkTdyzHnedNY2XmW5vb_XmDvi79ImZrbU4omxirEhJXqjGS9fJ8NfC84z1puHAhUQtUHD2Kh6i2NIftV4FrDL-AdQmLHvUh6kSti5CDfcB_GJldyx-APdSYeI4zYaOIECU9DOkVd62j_PwSYu7x_n-xTNdFeJw-IsBEfgSo67kE_SWGzFdlz42bZJ63wUmWH-bbGaHiKn9iBpyLPauIJfujPM-jWtA8BakGT9HaBtIAoGViWsgMjuKuweC6jBOf2JDtcxrhYyBwy38Nrl-uldxrsnefy37ofIcTn-dOXdV093ITJiPDPO5rNUcvO_88Kb69_yFUmt8rfpAmB_bfy1q8oLAC38WV5ROBmD_I_lKPgoqcCP84TqE6P5t_6E5P7D-xf-x9yeU_63wcfjP1zf9-twiRV_lrf4X-L_l36tAFulf1H4f32gUZA1_dd7PJmgr5MeKMSA7GP_2kAU8ZVFPxyBW_dh7LumdXc9b00YmOfJjv78mgIgFMCmA_6Nv9j5Raf8YV5Rf2J6SF_rpR6T_Yhx9X_FlBx_9jrDEJS3_9pPf92pAxm2_X7W29pqinMtQEdimJoeKcUV1gfB_8xE_0oal_TrpzubVE_tCbwaspjv4rZrmp-OP2n_3KmO9Eqmltz1-YDCABsEzDqe7TWkl2jQgByCuQ0KCqUJ7U6mBnH-EdcFeQTcA-QipDZMrnA_aKCGd0UKHhQtGCemVHRo6vziJkIo2wBYLkPaHEwoBO8AU01ANIBrU3_O9AOBkTczem2ICYBSyGWQcJEBmSVlLcbALvgfNG4BTXDS4ccDFoQgJQQzMlEBQsFUEjMB0EUgJNgJWimgsgLZk4gLQge_2oAYKGIBzCEe6cKBuQzPAbgWAKQBSmhHQ2ciuAhAOwBbzB_YVgFuI1gLdYcJCuAjANMBkLE4BpEnYAs1i4BrgPtQ1WDvM1WAcBSEhs07ABEBPgNMkwSmoAgvQiBqAECBF_38E7zkFk2AIykhJg0BkgEkBpgLccXU3QBUwEsgWKBXa3OCFAvqFTkPnAukqEAtAWIF3AqIC9AcAC-AL00qsaQIloFoDAASQArgaREGUhQOiAbrkFMLZ3nKbwBM8bJnQAyYAtAPQIFk-oD9Ur1ldga5kO-wEiSga3AmB54CmBczmRKhMkFMY1nHMfmSWBpLA-ca0xrA95kDMEiFDMkFj50EiAE6LFmOB6wCR0r1h8slZn2MuwNWMz3D7MHZkHM-3AkQawPoE3TgOBO5hXM-5jOB_Tmw6-sgaBo9Dhmis2oE4XBnM7wPi4YXGYEaUHAGa_Sp6O3EsgSUA-0IOhiS41hYEfPUqs2oD6As9zpwbwNi4kIJXM_1BsBHWimg96g6BFyECmZGDyBZILfQnQLAYvGj0spAn8Aotkp819z6Bw7HgmNfG4ucOFYchGlqw-fUDQ6ygrQKtl6kQoLsMZzGUgFaECAysBZB4vW-yLwCygVwDlBtYD9seACuAjHg14q4BDsH2XYAavGVBoRjdG3HCImnanR6lGl9gcwK8sUMgWBw83o0aRglBYwIYE8wKmBAxhVIlGmTAnQjtcuAlq4eHBguDoGfCQ13hUXtzyYUADhw1nEq4eODgAIiXxAhCimgDhSeMtWD3qHll-BAXwO6eAxUSbTB12kuEI0Mcl0GauBp8cRjpwOYPYsHVjlAA3QjkWAHFweYJyMRADyMVwCLBG7hLBayitkrGkiAauAeIjGmgYYtBcMN71UIiYL2BPphTBMuzX4XymjqanxtIWNgiY2gNzBPYO5UUiVOBRwMsAg4ORsEtFRKo4L4Ydmht49YNxWgkWB66YNtkfXwsAsFjUoroIlBXYNisp41qGtpCkSlwMtB1wMbMi4Oc-Gi258RVnN2Z4MiAgN3OsHHkNQaN3LBlYMlwW4IjwjYPdImdCKs7AgAhnYG_ywVhX2lj0UmfECMMkyjXB_4CPB8hTaYCIKRBDsBRBYILRBauG7BNpAFBlwGzw4EI5uR1hjapTH78nYICMJEL70REIVsX1khu1lkDQhEMlkcQxFBNllAo5ELQYXhjJGrkDrBzEOLBrEN8MN71TBw4L3BmYIieEtCrBdoL1QdOFBoZYMzkFYPPBGdGrBtYPssPiGKgzYKkhEuGPBRxA7BnEPzoikIkqnoMZBrECuAeIIYEfmRwAtZj0Kl4LSS29Et0jwKdgnZnZaO9F_eiEJ_ULimKMpRn16k4NQAFmHYsTmWHaz6W3oZkO6cg4NchGYMACOAmMhkQLIh19F7B14K-Be5h0cm5gfBjD0O61vAihWGk3BfEMKGcUOMISGWmwbcXnuDDQccsAJSBm0lucnKm-cZiFCkFJiyBI6H4AHrHoC_AFV4EiH4A27i5USAHYA_AEIAtwHuAjwHBGp4DZAW2Dxah0hJgnwEkAHATaE8QHIwUTlnACPAvQcTg0EHUNjg9zEkAbsH2A3rAIAkgGAAwUA-c9F2cYO0PSuMAHkAFmA8AYAFmg4I24Ar7C8g6wH4AfkH6AtABah3UJAAvULuADwCuQ7wyGhrwBGhXJl-E9jEmhy8HCcs0JsA80MWhZQNucA4BeAl8CiAa0P2A-sChh6SFuhNYH4ARgS6htWFRhswENUZlU6hg4P4Angm-agqgwAz0Mog_ACl4z0Pxh6pAtAhMLK4_AHyg3WHuhfJBJhL0PJhXUMZhVBDphSx34AQFGZhZMPYYFMJAAPMJAA9MOmw3MMSm6MJZh_MLZhgsPFhIsPKwlMO_gswCaBHEB-a78glhfMOPAAsM8EgmHD8RMLVhAULlhH0Hah_Sk8ERHi6hoMGmwpMJUAasKuA90KyACQGhhXkBehK1QFhbgFoADsKehwsKWOVsNsa0sPYcEwDyIysCdh_ABdh0sM0IqDmUYJbE5h3WB9hNsOdhjKWDhKgCuE58A7oXUNfYhsKgwscIFhxqioIPCE6hSwH4AtgCoSU0Geh6cO9hL0N9htsJAAocAmA6yTHAQ90ThRcJTh1AFLhB3mvoDNmNh5wU5UJMNFhdMHRiPcJtI_AAgUA8LqUQ8OcSf4WehFsMEAlTlcAkYCliMsTpmcugpiisRvADthwA2MG5AIAALh08NDgkYH14-8MUAzHn4ARWXO-kuH4AaaSEC6MOzw58PLSsRDtYSw2quXAAmAk8Khga8OxgdVVrAN8J3SlaQfhE8PNhnDBnhe8MPhwCKPhW8JehMkF3hB8P3hm8I_hFgC_hFaUyALADyAk8MigGYnWUJ8INhp8Plhr0IQ-I8Lqw8CMvhg4KNhOgFvhGaXvh1aT_hYMH4AAAGJYaGABE4dQimPMfDcymf82mm1C6YAo0r4d6g7Ye7Dx4kyAuEQVhuYWG5_4YPDXoTcB3oY8BQCHNYrQCIBqrjXYmgbYBQYSkALQCrwoYAAB2cxBzAPyAiAAGGsASKDrwUL7bQioDbQxtyzQLADVQLADyADqCJAaqCJAKxECQaqACQOKAgAabAQZbmEnZaWEw5ZGGCIwWEYicrL8Iq4BVZWGC9wv7A14EuHSwyhAtKAACVUMAUgkUBV47AH24wgCTiSwBiRcSISRy5mcASUCWACMnPA-3AaASwGUQ-LH1A9cNiAdgAAA7XWAK6KihzYNwBLAuIj-oZIARgM0jTwMkizEBNC5qFAAPVhaBqYm7AdTK9MoAGhBucEQA4AG7Bw4PgBiAFAB2gGIAikSMifREkgtYFIBXABIAkkvGAXEXFZVwGTCuHIHD45AIioMEIigLiIiqcD1CGkR9CpEdiAZEZaAo8jlAFEXNDlEaoiNEZkhtEeNDIgGkD9EZF9vgHAhTEeYjgAJYjrEbYj7EY4jnEa4iGYYLCPEVXCvEVvDe4Y25_Ec9CgkZR9uESAAVqrjCd6Acie9kcj8EWIi-oWcjPKpci5ETPZbkUoiVEeojNEXcAhQC8ivgHoiDEdiAxwJ8jkUdSiYAGYiLEVYibEcAA7ER1AHEcAAnEfwAQUdCjwUeAjMst4j9kb4iyspOg4UdVkEUcQic4cAg84XgjiEWjCiES9ClWiKUVWhFFpYTE8iTkHBpUbEA84dIoLgOVBj7K4htgNwA9IDyir6KCjFAtLD7RsKAzUS5dNkdXDMsHXC0QBzQ9kfKj4InKjhUcqjPiqqjXYcPNzwFdwiTgGpDQDXC8AE6ih7mDQR4J8tMAOfA8ALaiN6Baj-UY1CcmnGisEfKjoTqIBXUZ_CQAAqjJlJ3DEAMq04AASUBYRqi95kGj8wC8tXAG7AfgG7AlYOjgxkVpB84WfCQALcFqpCiiLYVREs4X7CpYRnCqcJ2iq4SMAK0b7Dt4aHCq4QjwenElAT5NHDs8H2iK4W3BUAG7BuTInCR0S9CGgEkh7ACwJz0LQAUxA3CvYY4cK4XHD-AOUBZEG7AsCEuiQUgLCtGPkAUgN7YW4bujp0fuiBYbZU3YIdRXAFOiO0Q-i_YZQAa0eK830XUoZ0ezD_UJ1Ce0XVh_0XTAfSqMjEgLsjgMQVhQMSmJWADWiPEdBjM4R-iq4VEBZwM-iFHL-jSlKBiPWCZgsMb2iUMRXDdEMmBOYZLgislzCwUfMABYdajdkZKis0YKBlYKEAPUXAjs0e6jM0VKj-lAWii0dLCJZv6j4dKWjkZIaAB0VpA3YAJINsFVE3YC4p60f4AhUT4iW0YXg20fejC4QeiQAKzCkMR9BQMcJjGEGrDh0eejpYWOj9nJOi70e-jlMQLCIAHOiF0dEAz0YZIBYauj10Q4BkxKmJ8MSBjCMYej4AMejT0WAiQ4Xpiq4ZejZEDeiAwMZi_0a5iLGDMBn0WaBnMTBiQsdWja0fwj1Mc1AQsdmMgMUscNMYljwMW7BIMZFjkMaZjpYXBiEMVRigsdhiQsWhiUgBhjn4YViCMTliq4bhj6ERViXMVViiMZQASMV7CyMdxQE0QVjqscmj1kXajEUUEABIMxiXoTmivlHmiuMWqiq4bxiA0UZUqgG7AB2itQ3YGMJy0PfJ5sQGk3YFtQPAF5tuTDegxhFLxrYP_Zptu0A-sYgAZoO6QiADJA--EVxodqxAZsdnltsXhsLseCgNQAUAq0ewwphIdjjsXQRTsc8BJLLZVHsehi--GWi-sbJjPUf0pW0ZPDQMWpiKSm1i-UR1iXoTRigcSxjQkX2xU4VXDzwOeBPEBsJpIEwhw_JYhbcDJAU0cBieoYogtYDJj2MYNi2MYqiRsSqjC0WNiXoRNj-MSlotqGAxLsdQAfdvdjngNQBrsWRhBMccY5EMTjG0aIj5MUGw20aBjmcTXB9YVQJQMeDogaPtxYuElkDnElBOYeRj2sQEjYcV1i6MSxiy4LQAqohCgXQBmi8Yaxil0q-jScSxivUREAfUTxi_UQGi95kHBNcV5EdcWOB4cVmjBcUKpJ4UpjrYQLCIcXuiGsfwAtMUOj44TZj9MeOijMfFjAFiFjzMeQB50YuivMUiifMSui10RujHMTuiQ8abBvcSAAj0aVjPMbpiA8b5j3MdeicQVljUsanin0S-iC8QljU8TFif0XViosaniksaXjQ8TXj0sZliq8dlj3cbljfgPli4sSliy8a3jUMU9gysbGjm8YXie8arj-gLVjk8aBjbAE1jSMTaQlcdDiVcUmiXCo7j-AIjjhOIFiq4WDofplcBmkSMAFcFriZqPbiSYLrj8cUGNOGGABmIANjUYeTjc0c2jOMVTjuMeNjLcfDo5sQtj0lMtjIgKtiYAOtiuTHSDYkCKVpsQO1OgGfjKAEdj2CAIAwAFU57sXhAnsQASwCcxAQCe6QwCRATcztjiOcQO1ECbtifscyF0MVLwzXOASucQaBJwEATHcSbiQcQpiwcSFjECdHCU8cPj-AFLjAaDLiGBHLiLuIriocdgjLUZ1jF8d1iZsBWhz4WFjYCZQAL8QbjtmgNiSCe4JRsb6jXYAGjn8QGlX8QtiP8V_ikID_jQKhEB_8dnkB2udjczngSy0baV4QAIA3YHhB4gKJigCW7AbAKJj0UWrg80aDjzYSLjwCVQTJceTF6CbLiVsvLiWCeai58dRi1cRsjEUTERGQCdgjCefjScZfjDcSISlUbfjvUdTiJCXxilsS_joiSti1sRtilCVNiPAJziy0T4Si3P4SBCVwSesT4j2CarjOCeriXoTVlAiUITwssbjQiWIS78TTj7oQ9JNUe6BtgNsA-CSgS3EMQTyiYgArCeiVosT6AjcfTDqCZXCXoXQSGCfJUXCV7DZ8WwTE0SAA4cVkSCceAB4gNsAEEPLAF0YlBJnvnjiiUNim0abi0iBESLcZIT-MfgTDQDOg5iZUBRkbxBlieEiLCTfj3BO0T6CKBio3lABnsZrDd0b0SVMRjAXQHYSQsS-i3YIWjtgEQBXCaeNlcR4T8iV4TiEVZ4k_B3Bn0bYBBCbkSF8Rcgl8SKj0UWDBI9jwSQAPewffG7BInEojISeMTJiRajhEVQjREW9DGkSiSu9rMAIAIuxZuGE54gOiTonBehccSkBpAG3wU7NpxyCuOgvQK6k4EFSTZwAyi4EFyilAL8jeSXYj8cTyMCifwAiSaMiQSZGhMSTDjoSTaioUWwTcSfiNjkViiJEayTBxJojSSeDxksNNCInIojqSUThaSfSSlYIyTVAMyTXACqSffB6sqAKCSuSTtCnEYoA-SXaSBSVMSeRqCi1iQLjSCULjyCaniiSddjfiVrEgSVmjRSfNiKzsUSoSRMSusTiTDkXiTFSQSSPoaKS1SWSTNSeE4OSSkAYnFlB9SY4IjSRgATSWaSPnE8A44J5UbSbyTLEQ6TgUeVg3ESUTfNmUTLCWQTrCSFjvSb7D8oORjhSciS2SfoSNQJKT58WGTOCRGT4SQqTMUTGTHgHGSSSQmSKSdqS7kamSKPMKA6SRmSw1kyThFCyTRSYQgNQNaSeSXaTiyWyjSyQVhyya6TFSc7i7gJ6SaCS2T9AD6SRiT2CkSYGTxSdzg3YDG8OydnD3urCTentzhW4Wexe4Y-SMgNBAFIe-CuoYx5QUaUSKcZRjOyQWFUIvipU4ecTwYpPCmyf6SWMYGSFaGFibySGTxiWZ0HyfM804bURQUW-SBAB-TxcM9Cfyb3C_ydfjQyUBS30CBTb0WBTatBBSzyfajAyXhBryVU9byblj7ybKSfERhTnyX19z4VlosKZjAcKfqCs0fhThsQBSBYURSEgF3ZSKU2jwKebDIKdkSs0eiBYAFtcEKVKTm0YxTfyZWT_yYRT0tMBSRKYFiyKRkEKKawjpiTJThkLyZkXvRSq4UhSmKcKi-KU2i1KSEENKZVwWiUPDyKRJSZwQto7oTHi2iBijAFr3C-iZTCdgKrDYSTuTMUXMUFijggtYVTCaYQ5hBSUhj3EQpTwqcTDzKcQjPknrjr8T8lKQlajeFk6SoqSAAHwiESfKdsBVYdUldkVXDGEXEi9ICv1IqXFCK0CVQa8fbC-Ef5Sr8fxSgqWZVQqYrCZgNTD94H5SMqRRjQyZCjQUZ1li0TVTHYfFSs0YlScqRMTaUiyk0qShJyqQUSqqYeT_YXgAdkXVTgiVWTs0VjCmik1TpYQTD2qXrDyqf8TPEYKihqSxi-qZ-jUHItSpiUGNZqd5SHUbXCmlDuiXSfVSm0Y1STVM1T38K1TYqWrDWCTkTxicPDDqS9DjqVXCQ0WGiXUb1SoimAhQqTdT64cDTe4dlSVqfolKEX2TFSbLgh9L9SPoFPCzwInDo0eVjYES9DqEZFAYAMmA9IEZB2FCjTawBqCeKT4jcaa4AoYGAAjIM1jfcLEjNQVREaEdFAYYNjBsYC0SLAMmAmPL7hmaXEiwAHpAjcb7gAyuTThUYwj0AJFAPAKVSOaewBYQSLTiEYwjXAJFBaaR4Bpaav1GaaPCQAIwjkYJFBkwFDBpaWojuadfDNaQpAuaegAoYILTs8HqC5aVmjGEYx4VeHjTIqc6SxKc4l9gLMk1ogLC0sAgggEesoAAKRwwdXh-07572U8AAu06DL_wlQCRockH8I0FQhwpuBBwkACk2fgAF0BOlLAd0FCg8AJwwSSncE1cCXUlTEMYhGi_UoInCElalPUmorFopmGdUvalVwn6kg031zSw_OkZo2ukhuRIqFUwbHpo4_GVUryl509NFeCQnJLU4un_kv6rdqWPGvsc4ml0kKnqoiumfU4VGhkuADrJLwBqopumIgAWEN02EmdZFukr09umF0tyn7AUanmpS0DAxAWHAAKXjOI84n705WEF0qhEgAUUBtCEQAjgLhBthB2BH4Y-Fn0-VL5AcKDcUyineoXOmb0xjH90yymiI8enI0quHGkXanuE6WE103uH_Utul_07enr0oKL107xRMY86md07BFXUhjHogXulb0f-kqU6_FD0rlKsUselrU-YobUkBlT0twljEhSlz0jZKL0qBmX1RBmwMpekZpBBmoYpBmwkkakrU8-mH06WHH09hin0qynypPaGu46-m30zTAP0kcBP00fAv0gRkJEd-kq4xjxf0jTFd0gWGA47ekBUnxFAM8ukcwyungM6ukTUNen0MquGqMphkb06WGqMmanKMsxkwAXIrIonBlKwUan4MkeloUx6nEM4KnAMv6nkMv4m6Mv6nz0t9AGMuulGM6xn-M5uksMl6HGM3uEcM1SmCMsSQqY3hnHgfhmiIrhkgQYRk30wez30pjDsASRmEAaRmJMt-lio78ntPP0lSUzyloMlTEX4PnF2Mo3H_kzRmT07RnT04hGhkyBnYI6BmE43nEtnYJmIgUxlVw8pntMlBk50yxndMonEtnLBk08NRkPUt0nuCY5LZ4wj5EMmYDYw56m1M4BBgMyhmdk6hkL0jpmdknpkk4kxmhM1plpYXpmgoyJkEU6JmOiI-mi4_ZTB0pJmX096IiMtJnASDJlZMjNEfw7mF5Mj-kFMxRnNQAZngIogljM5anVM1xmkMjxl1MihlfUhSlNMnxEtMwQA_MnZnF5TxE_MixmlMgWHkAPgnQs3uHqM4VE1MshnAsrxkrMgWHgs4VGQs5FkZEjZldMl6FEs_gkd0_pmIszanBiPwkUs35kD06_GYsoFlLMnRm4siBn6MuBmGMl6FpEulmos5pmg0sEA0s3wloAYll9M7-lfM0_HMQEZn84jRnjM3cn9KKZkLgQhkuMuZnrUhZlYs1ln1MrNGz03xm0MgVkBM75kBEmFlg0uFnGsiJnvZPeknMnKBnMh7FYE0rEn0y5mCM5Jnh01Jl30-5mP05-kp0mRmWgORmf0vSkXUyVkgAIon3Uv5lMsgFkasllmxAZZmgszsn4s4hGQskNl0MhIq7M4NmUsiVnUsquFGQGVmVMhxmKs4enTM0emqs-Zll0xZnRstlmxs4tF6sjZkCwpNkGskJmwsrNnsMy1mcM61mxM7niuABJmKkq5lJUqeFussRkPMr1nPMwWGvM-RmFMuu6poz5mZsl6G247XHzEh3EMsgBmKk5lkAY8tnasljGNMzllMMgWGzs_fHzsxunJshtmmsquG7s7IAH49NlKM6dn8AU9kvLfdk5sxdm4M_imOMwtnOMwBkRs0tmastdkgsmenjEtZl-MrlmGs69nzwO3H7sklmpsm9nns7elHM_ilcMmJlH0x1kk0l5kJEIRmus0RnpMz1lSM71m5M2Rn5M9UHjs1tqTskpk-Iq6kHE-YmdoRYluIU4mgUtFnyswKnvsiemfs4mnrsl6Gbs92gAckNx4s2Ylkc44lLE_ForEk1lCs6ulcco4kUcvFp0ScJEIs4jkqY0jkick4l8cqaD3s0NmMsp9n5sghmoUl8lvstVkkMyNmrspjnfshpm_s6tnsc5ekQM4TkLEuTnic6jn1szpmpsmTnmc3jmWc0SnYI6Dk-shRGnMnhm3E-4knQp1nIcl1lX0_tnociRlDs1-k4ct5l4cj5lEc4VFXUwMnJk3NkrU24JCw0XizMktkMcljnL4GNk_shSkXw6OmHskzlGM1smxc4znMMxtkvQhYKwkmGn_k7LkE8TsDmYlFHugptFVc-Gk0IyyDnge2m7cYOlVc8hEZpVUHPQiGAZiBrmkIn-EUI92nSw4qlMeQeSdUyTlRclTEXk3l5Pkh9n2M-Ln_edLnqcg8GDY-jnuMl5nkoDLkGcrLmkImtlmM1smXkoVkCc1uluY95zlclEKjUqrmII2rnPQ-rmiIxrkjcoqnngarJ6QNRHagDrmDcrrmPwjmy9c9eHnEzrlogX-HPcnGnjc9XjTUqCmoow8nHcsEmMIWVmZczsnZcg7lGMubnDIcEkI8hNmCss7lZU4ykLcqpl4M5bnbc1bnnEhLk1-ODnSwlzz5FRDmrUrTluMgWFCw5jnXsq7krUp7ndCAWHUImABvctRE6Ygbnfw27nIIrqEPcxUlVcnpL_cgACcgPO-5wPOrSYvK6h-HN26gbKvZyJLR5cPNsAG0NcSTcFhJoZOR5RXJUZqvNGR8PLA5JXOvZePKU5S7MxRZPOJ5SXPWJRPNmQtfhtZlPKz81PNJ5K6V2ka6X1CRXRdRVcKB5VaV3SI3OS56rI_ZaXOJ5TPKypLPMq5g3Ka5r0LgAXtINyCkEDpCfIdsm8Kl538J-50fM553PN55j3Ol5fvN-55WPVBqfIQRNXMF5VwBqyAbNQZUnJUZrZNgp2vPGJuvO3Zh3MHEQZORpp3IFhZXPx5ebPO81vJmZxbKD5qXK25syB25WaIq51-Ju5JfLq5RfNiIGfMsgLXLURSUAm5U_LIRMvO65T8IHxSoIB5fPIrS6fNB5NCPB5E3Ii50POi5rZLwgdfL25O6RR5YTJP57ZKK5pLPO5fMDi5g9Lt5OKBVZmnJS5m3JHZofP05I_Ij5Y_MG5AvMn5W_On5u_M1pekD0gSUEigN4HF5X3LT5K_Pz56_PWUm_Jz5sArz5GfP35kPOKZR_Jm5R3NV5tFK7ul_JFJOAstJkaDwFz0jP5qzKM55vMfZffO05wfMH5L_Jp5twTucIRJYxPgRYFWaKdCLoSiAaQGEZsPJMJvlEThsPOYRVETfGYcUOZLbP_JnAtdCPArMZqvODpnAsWoowAMSHrAQQ7jJuhFfKpZVfKb5qJL4FMbyrR6klpEBAqPJOgtwF8FKrpPjJoZj_PDZdPMBZ9Ao5Qw_JYxMqmEZBckThfqUWJhGByZPiJc52HIPpFPKrhwADcFxAoIAz6MvaKpAdaXbMxRPbJSZaHOAk2QHMxPxKw53bNHZOFNfhrnMZ4wwBx5c9kiAiRGLsPnMtA_UAC8vbIhgKvCWAFoAhgXfjD5o_Jg58qT8Ay8AKpHtNj53tKT5UUADpKfNc5tQrSIPXK6hetI0FGbK0F-XOb5sFNIFyrL152go-cLfOGF-rMrZ6qMoFNHLDZDVI25DPJW5rvK7hoqjKJrAtwR6wo4FugC4FboWEZQwoqoicNr5CdK8OF4O_5LGO8FipKkF3As7JxwvOJCgpIKygoyAqgtYph_J_pYwtGRQwr0FSoiMFMFNmAkwvIFVbMsFnfJLpiwsp5K3LD5TgvDpLgujxgQus8nguFRlwsiFbbKPpcIsIwIQv5SfwHL0EQpyJzrOuZfbJiFJSKQRCQuHZ59L9Z35NSFPgotA6QplJANM3g2Qv3seQoMS0AyKFOABKFphXKFoxJ8RVQvaF8QDSI0fM9pTQsDpGoJ9pbQqpFHQvgFcKLeFQbOopGoABFowoGFqJJopZgu8Z90NmF2CPRZ8qLBFVcKFhKwruC3cK2FezNu-7ApYx1wr2F4dJophwthFN_IwRu3QnZ2dOc5EguvxZopkFJ7Jv59wp2FigpGATwrLswZNF40ouV5sopFAkwv0FGkl-F1_ODFKovZZIDPVFcrPmFNAvp54Iq_5OLJ8RUIqvpMIu3haIoLp5ZKRFuIuQ5fgpehAQs727gpoAGIrCF2IqZFKHP85hIriF6kgRFeYt9ZuHKiglIqSFCRBpFmQvpFRAByFVtiZFBQtlE5sOKFpQs5FlQt_51QoSIEooFFjQvj5wotaFTIolFXQsCRAYv6FSqMyAMqIuRSREx59GNo5GjO1FPLKphOsI6pYfNDJSRCMF2qN6AhyLb5uWNXFOqIvFvcLTFNzJGgicK2UlqO3hT9JdAO0XrFP_Lmoo1Ldp7PNG5kUDUREARV4pqJp5biTl5iqJYxb-BwpPNLAxV2Enh9tkQFaiNJs7IohgSEtBUkvMQFXfgwRXeNjpLoElF8vPXhS4um52cOvF54vgAinLmFynITFtgodRLVOVh0Ox2pFbMR5QIvWZCopXFucNvF1nOK5x7PYla4vMJd4tHqwjMfF0eOfFHiNfFTcA_FiQsRFTorHFvgvc5_gswAIz3gA8gAAAXZWK_OTcyAubELiRY0AlYOGxPxQmy9WbyZxYkxB9AALCTxTTy_2VAAciAyJKeoaLaJfIyYJQbB9yebDIeksBYQchL_aerwUYNhKQuY2KwuSJEFYY5Kjac5K20W5L2AGhL6CGoi4YFhKhvq5zE8NzgbJYwk7JRvyehSmLhUTyKqRZOKLhtOKvJaKK5xXyL8JRvz-uVSKF6G75J4aG1M6X5KLQBOKQBZ7TZ4blLjICrxE-TgA9IOLyxRa2L8hWHSIJXuLhuN-SnJTLQwpQblWrKDB2RSNKMJbhRsJURLiEVdTbGSCL_mTYKdOQ5KygQeLGJUeLxiT1TcuZ2S5pVNyZpSpiDKXJTG-RCieEIdLVRUiitefNLrBe_yGefOJOoSOLvxStS3EtNN4WC_CqpU2i3EguKbmXvUnYVPDhJTHTFKY3SiMZj8RgC_TCPowRIoADyooFnTCOVgLH0SdKKJVxK4ZbJTNxRuzDOcCLxBZ7EkqbJK3OY7z_BStUcRQSyjJXZVXoOZKLpdVKvRT6KXhSTzXOX2KF2WDADcmUK2RaSK8Rb2yjad9KSaRYBfpeYx_pejTo8bYBgZaDLX2NjSp4Xwj7BWAiCRXcyiRfELj4cLLY6SLJF6ZpLCRYOzMOT5KyMdVLyRVfT2Zf9K_pTczeZdvD-ZX9BBZbURwZWnT4YFyKMWduKMWbuLuYbdKMBQ6LL2cuLOGCdK4AEZTGxEYKDpS7LXloCLpYQ3zoaaOKgBRmkABcIytZQ-LuZbrKF2frLWGIbKU6WDLMxKnTh2aLzupVFAl-UNyM0uBK-ggGz1gGHZSoWpw4AexBlgZkC0AavVBsCAp8BAIgx8kTkOztFxrTP7x1CO7BdTDjIJIFDA9IESdV-q3KlIHvMyacJ42EnMMQQQ6D_VGFxrTFaCuzJYApEG9pfTNXLh5rkibBOeAcZKRge5S_At5v1R5PqAxXIqqJ3QKH5QaLAAIeH2FoiJbhJPIh1lahAJSES-EUaLLhGDrDFuiCCC55vnVFuELpfeHIJMZPfLqdPTNPLGaZR5UtxnAFIhyYiy4JIOXy6XjzVt6AAKnqFIYifKgANakNUrHPxAcNL5UP-gAKjQOaBU5HLxzxYMNxnv31ZROnN8hDfLIZL7U75e7MdTGlAVeGYBoxAUtj1n20G9EMAdMO0AfCRugsIqpg_UqidIFJW96gFN9yHqisaFdfK8vjnMiXC7ARsP6pLuFFgRdIgLUEUZcEZgIrVzFFxAaB98GdCvMpEEkgE5spB4YKIqizNgruFQtx3ZvqAHQftwbuA7A3IFIgJ0Zb1CJdR81ULx1IZHqAQ5q_LXrB_LJnN_KHYL_L2AD0K-5bMD5BG5AfeFtxIZFs44ZNS5KsuDyl5fZohlB3Q2IDZUJ-T6IU3qTQacBMUHqGvZZ0BpBoxNtQdMA3UMrjJZ7vvHYmiZwtKaGz5U5MxsdIHOAU3pwqDvqvMKXFFhXYDQI-Zm5AVuGlAFGcYr8hPdZdTE9Y25hS4rgRaZ3rNGYFcn3LxgZaDJgfPMJIArlSMHMtVgNrQfEBMVlqLi8mTtvKFwJ_BcClMBYCvAUUgKEAkFnoAkQL49YFOCl6rkBdMFTXxzQW_LEstaCJWtFA_FTxtSME_T4kDz1F4JGUbqFidzJFIpvUsMqcQqMrKSPewKlMQqpMDeAEQtQANvludAEKK8RUFSQzlijkr5FQBKjt0Ae7hvK8FqMBaMFvLHlSCDxFWGZFBPJUtlU6Dh5vHMNboK1KlXCCglcoww1tIoOMEG8mVsjQGUHPINGpCqd5ZphcVp5V6mqphm4pER77FgwCiKRgxqKDRlLICwyMFkqeKqZwK6Eyr4dn1zGFZkt7LMpBMrhyqzDBiqmTrDEoYKO0BwuEQ5wKKrR1H1z3wNrUdRNa1idgcwzpLhACIGgqlRD6IvVj8rf4MStyziH5_OK2975M8r-wBkBb1ozwg1kRsBgvesNlSOZ65hrdtlUGpZ-cDpKvEYqQQTKUksvKUunNM5dQH04aDvUjsUY8AjKomTKSTqTZwBOT9SXMtJAJ2BDUFGrgFG8j44LNA7TCkBuAFsp1Sv9QtSvtx5XI7UZXBDlPVVXNFSj6rZnB59_VcqSg1aOTkyeGqpyZk48WlGr0ADGqSSfGrGYFsptKqGp9KoWSdoZYidoXYivsKwABTNUqa-KYrlbn6oA1HDpHVSGpdKgjpZvMoqTFXar6Sm7A65ctxBWjdwkkKPLqdIaZCQeiD5QCcArkfIjkyVxBmpkMjbiJzIXSOXJyTD8J3HNkDiZGXJ8VKnJcAZiJ8VALJhFiMZv9Dd8TKDMZoZijgaOjE8GnNOqoVPJ06kBiMeNBnIi7goN1th2czwMC5QpMxNS5Neob1bU8wOqhRbiPUcxuIoRNJupMrTqShNJnGDQeD0N3wO-BwNWOBINYT4qAblccVFkA8VDk0KmBBr3uiKMJEPQMrzAt10NczlMNT3wPBoa0T1NxAEShkA0gKoEvjNVh66C-EoYH2cOqniVo6pVAIZR1VwQkUFYAFDAgagwsYtGIowYGJrYABDLMXhlDpNTABZNWIo65Bf8j-KPUiNdQA7wGhRjoW90Aeid1TYKR5DOv9MbXPgYzOuwQbMHZ1wYiwojSjmUpGuDEx_O_ZHNbVodAacgSUOz5fArVo0tCEE2BinsqupnoaDh9BaukV0ouiWFItbF0Wugl1xVhF0Wuhl1cxPFrotfV12js10Mtf6MS4LFrawFFqKQql1elk11IuoCxO9FC9CwOV0R-qZh3OpnpFvDXx_NfUEQggvxbqQI8StRKsfNRpUbSOPxR6tkBLDhKtSOnFtaADYs-7HtVdToN0BtXxlCtb51EtX0sytblqJmszBbRUWZbAPqg0KEkRn_J2QptRo0_FqR4WSNtqstXWBGSsTCqIqDg1tVVZOyEkQRuv5qdtZlrhtYCwq2pegOtVSwgIrdqstYtqAjodqHtXjUb0p253tQ9rHHvGjJcJlAPtQiTOxh4Dk3IJFJ3vgZ_NXNrs1piF91H1qAtTpTCbkqFkdQWFpelBgbeIDE1cAtjIaT1KcdYF18dc6jDKmDrrJLkcXtR0c4pceCctYTq2mDNrgumTqHtQtqepfMcg_NOhkdSV0c1nVgu8UsdBIv5rMoggdBdelpIzsJCYBBjryKQtoOCCBUzOh5q9BsRU2mGZ0K0ODFp0LVp5dSb0hweYA5dcjqpynJ1LIKugRRrxqn9hZwb1DWBl5KJdT8A8YDNVVZ7Abld31JF5vLjmo6kCFr85FV04Avl4WSIpQr3tVrRfu50qJkMMWSBxMyuhnK-vDZh3OlpR6FP7rBJtmVKIs7svNoNUsdYOhS2J4sYvHx5nRtBgjOp4t9FmotnRtfQXjFoJHBilN8FNadCFMQpBCD10KFIIRnBs5ro4sCptDv7kMmpEFq9fspnuqlUgUkgZ14r_sRNWaMVmiG4UYGzqxTu5Y_omZqwpJuM2-JzqbRDbqjNZ2RjofQNnBhDrjoRnredSf9jDjZIEadhjoIqeJm9WVN5AG-KEgnMdXKofqfJBkkW4ofqfsmaMPoKfrV-RzYskvXRoIt7NfxW64aiMFNTBtBEu8ZgLe0VvrbhDvr6pugB5AHB0ffMUBD9Z1lj9aVVsudyM6sDKowYJ9EicPMJRhAGlIaSCJ3QqCp2gBYFADa-BGCKPSEFUVRsad9kUQoPqr9ePykEdhArgDFAH9dukK0nMkX9TsA20ioUrlB_r7ZaUoP4W-MINNxq4-FoIy9Ynoz3Mxya2jlVfsmiUOCAbDSftHFmBQw0D3P6kCAK-rR8Bl461IuoYNeRqzdZzKnZCcZgAtbqaNXbrr1g7r5jFItUNXx9QtZWNTKAtFVDd5df8DobgAm09-gtHqb4EXqbDSgRg9eTk1lPhyKFBHqjDVHqqur8QtdX59rdubZZ9Ynq-eolQBejzjpvpbrWyGnqDFsvrxMFcBzDd5dePBEbrBvM07nLYauZCXqn8DcpndZXr8DNXr2Ml4b69fKNDqjFUeGLvrpDTN9kBvvB29ZHRQPF3rs8D3qJjn3rEQAPrL9dkMR9Y85D9fFIZVNPrskH4b9sPPqJttnZBqsvr0pdt1fcIpqN9V_r50iDgf9R3pijQh999XABgDdBFQDfuNSqkkRIDQVgL9RMcr9R9K1-XfrD9Y_qqktQb5QLQjYaGsbgdceMNYp3g8yp24vNjxrOVFwaXwkGQY4a5VExFQJRjVDrdPq_lRDd3DxDb-q5Okbr5DVepFDXBrCVGOADdTpcmZJyoHjCUaZqM90KVHRrmVJCbgjbd9YTZypMpvgYfAiiatBLXrsFAiaj1J8bsFDcaODdiB6BjSoMTXIasTYhpztGVCnHMSZxZA5pWILR1C5UdITYC-jr2re0o1WaABZAMSnCRDl5cZsCxWNsDBTBN94PuxJEPlvRYkNd8EPit8xTcyRKOiwCGfnDNqTJtYaANtYqnvtZI0BrJSTPKZfjQbpVjODo3INjJJXPqbsZKPNF5m7BjTY3L5QG984ZBab5XPcCiXCboMTOboVXPdxHTZiZZOo7IxwMB0JQGDIiAGKrTUFiACwtz1yFgKk_TWiq7NnvMLQEZAiTi-j-vAWFWtZDSQKmar0ztFUX0d8TZNaJVTgG_Ydok-A6ABaAdTPMJKIFrwBQOpInoO1xT0D1INhEpAu8PuoRhjNQ9dZ6aSIo6I4VIGb0tHW0HXOFEbNV8YbMuxD3SIdUFfsq99dEC0_xu0BHANxgswEuFXKnqjzAMvAacCdRYHMDF4dv4V2zcDUBtkWZFzW851IuYAPPhYAbMI5U-zcFk9At588wAeapWuOk9ydhB4GoEVTwtNgk3EVlMSoiAFWlX5W0XOknbNl0ouvMpEoi1r3zf1dVLMaJ3YYpE4sIhEXzYvtUQE9RmgErUgVJRFkHIuawZLHdo7h1tY7nGb0tUVqMQjKpZDpGAJJixwNzUW5OtF88lIO6QcLSdg8LZDUwACQ8yLcVN2ABJMZWkg1G1kEEYmRjxYLbHcE6sDE4LbyF9DXBC3oqxaEQq7RuTYwTnCRdwtsgQBvTa4BfTVDBkLcFq-9D-ajMtxa5Qv0EjoEuoGLZubyiNoDSLeRbgCsftZLcc1SONn04FBN1zYP7Q4FIRaYmWxbVwLuD1FLcJZLW9lDJN1gmVVp8XgNeJ9oiCl5AFcAdlEyqTlN1h8_GgAOOEdBKhG-LtgJ5ajnrtIbwgZbL7rtIEjX7cpGpOkHeXMpVwIuapHuPwSOGABKhNBAHqBpdwKPFbSLUlbKLU3F2GO64MrQxaErWABsrcfsbQtd5jmnFaGLda9f-tFaYmck1pdiaC0ADFaUrTvUl3voYkdc2aGzZIbDPmIkCwo1pmtAXVgzRhSZJvVh4zdJaPgFlofSVI1C2qNbAun1SpGks1Fmk1o8tA64XsFFUQKmXA0ym2tAKh2sWVpJ5-TAypFrSVlz1FlpaAh1pqAOLhm3vcxmMv-MBNX9YKykdbcsidan2DOJolOIthrdnlxeRNK93guhX4QtAhoHQBMjelAF0Gwl3SL9bCIhmUGaPWMCOW21LjNlB1oKVFBuPDbwwAnU1oLahs8GeACwvL54bY1p4zRQ1JWiG5xlOMpR1jWVf9rhC6lGtBwwJlFT_qeNF1u-NWFJtaaQF1bv9JjqAzV-b4go38Vzc010LoDEsddJbONOzaSJEF0cuprq9Nc2aWJjFb_MK2aQglzaEVOZBAuoubFLZ1beEs1pr5BgYIAOjghsLza_UMxVkHLVaWfGjZCrVlaLoMlawrWlbnfvLaWtTrb1Qj-FUADFbn3qN55oKflfkLtJmrUyqf3v9r0tIt8EZsVoCLIZZoga9lPrOFYTrKrZpbTkF-rStbCbZbwofpzYYfsVCuzfhYA7eLlRoO0BINjsBeht6hptJKbRTdKa7psJY73tY9-GjbaNTsiozECWpy6nRbNMq6ksdfhDhQdxCiPqrqPSGubSMLZTWHvJh2HFEBKiPaIGgiecZ_PH4r5VI1M6L34DPApoMRiXbrPv-cfAs88zng8qI_ApoCwi88h7X3bP7nCQIOpUJ_3skBeviM1GtRe9N3rwUjfsvbR7bb0BvvJ9jzRZVawHebJcKtAD7XPbV7cfbd7VE9-gtJbz3nJ84nvhaSmMm5p0A_at6Na9RfoB9BCkvbb7eCQ17WnbtgB196vq6d-gkEKItVLgWvku8oGjfaLPEfafeu18avss80wjWFJcPNBQ2lfawPk89L3tgQi1Ifa4SKzanLt18ZpMi1CMG9kwEIqjTxIA6kHXfafesF8bSGZV5IHH4V7eCQ2RksdpLRFbawEST7OjkEEDuw757aLrm7VJgakNitWVPCBf5IhF_qvUp0gKuL1zna11GidRPVb4pNMDj4O3mDRJwqpFjfJtltwpf99UGrapDO_08CpitQLYzRdEDgbJqPvBzqMNUl_KPJ3sKKRa9AfQOAqQ6JLfEF0bXU8w7ULaqFNK1zPod48bQclDcUckjmvd4fHdDh4vpfVeEq3ac8uBTB7VloY9v1spGotQ3HamFZrRkF2CMk7fDk1pBbV0FRJiSgInWuUEwQL9a9CxMnHSaQnlK468ncSginUJ9iHB2bwlosEDMiE1KHqZkS8ulok9Rb5JlEF9IjtncTVALagncOlDcYE7Aun47x0kAz6UucL1NZjb0tB46SJJzbXKnnrs3r1aULbNqMKR40sQuGRK3tW8kFac9RDpcZEnVsMWJufd5nV0AI7fa5Cbf2sSUBhSeut50NnYNx9nVAbAutA7HnU-wPgMja6AELrYKITUWKkc761ggcMKYBUAyN51_7Zep1BXGNRvuVhQXeQ7L1OmFlkvw7wYsLrRHdADQyBscEKkC69hrsdSKo-crAOgVNaMOVYTD6JwYpXReIH0xewks8k3s6loFLW92wiRJK6JS7JPn_IVqHsgdRJFd6VmAru7SEE6xK6lKhIZ9psIi7vNSHrQbXQRBXQ51tNgQoXOibbAumC6PGnxRZ7X35xbmwQafC0A6rRhScQHiAWaEdhtgD8AYFRqrWYoFrpgBgBF4KH5t5ARCataC9iHeCRMdcY9uoMI6SHS87rPK7RQ2i8R-Ha87TCmG1qIlC6CsG66nXYyVeXUi6S9U1sqHXS6ugD11o1OpS_XaG6c5E673SJ67I2p25oHewJAYmOaUFH8Sg6doM-vL67CMK7RYXiVQxXfEE0oAW7PAr_bYfM6kEeJmcD2OfcirLi019jiE0KZS09sA5xugKDQzXUo8q3VloXwYJ8LdguxjmJ26fEDXF5XbthBFKVQNnZNUbqJ6kwoIGs6vvcxzoLJZ4MsXRIQErUVMCTaS4G68skOdRr2Hyg72Ly7ZXYO75mhhTXlTtQBgJepx7QoZRmGC6t3QqgeXQ-xYXS8gstEe7olCe6VnSygO3U-xxcG80tAVVZk7V9pQHTNBIcPw693c78nJiPphTdCaHvlvR5vrDarvu-6B3TCAA3bVo2yBs6APQh6Mgkh6stCWDZbgAZlTREA7puqb98rXaQ7cHaMKR-6ffui0e-rB4rWEW7UPYI7zKIGE_Um-k-9MT8LXVe7e-He6NLpD54TF9oy0HkVIwqoQe_tkMr3Atw3TWGJusF5M8TMqcoHbzFNDNxUk7Y4UU7X-6hLRB4e3aCZ2OH3oz3SCYfjKgBeOLDk7GtJ76rQgxpPax7Izhhgc5YIIaTbQgkcCgCxoee0TYJnASgSRAd4ICJu4MCJypBQhZgLIIlgJRAJ2EsBoINHlaMHerzQJkQlYViAiZJ9EtOeUCukQyhtoXMVIvR8BG0ALI85n0jRsPOrUce7MuzMurV1XDp11dCDKOkmqiZA_w_gCJBeiKQDNxIyJJAIV7GRH2ouXosp_nOwCXwgcsvnBsgzgHR0HZFMAJ2AjxMgHxhL1JcM7gMGbwjiRDvrKrZKbczhMtCZwbwOEAIgFVwc8GOwFPpZgUPrIcqmIXggnkSNqoPhDBIgJCqoLsp67Q3sx2BN6XbKgBqoFcZ9vVN7BIr8YtYNVBzvd5zysO2LzGFkKEhdNhaZQgIZgNVBQ2gpBBIui9_EdVA9ILt6TONcJ2ONVB0wtfQumC1BPnU8J3GD0xC8E1BsrB16uvXCAxmBNIR0PhDppIf9lxINJHspt6UfQNJVxI9kRvdMxxxMWBsfZ1IQOON7JvTFCPJG-gifWiJ8OLngtYEOwVpGYBYfZkhFlAsEzNCOgrvRNoZOAz6eICYxgJDBBn5qfxu0L2glGCOh7kOiAXCr17TiLQYcEFGA3dA6sQMAHkd6JUZdQJ2xe-cw9vKOZgxkfyUaALtIMgOKBmgLZY1zeQx9AKeg4mNZ5kPix6EsFr6ZgEiUlYEwh9fY0Fw-uZg4yO3IxOVGAxdXfQEsFiBKEMmQxKOFoCuAZ7HwXxBKIFWjTOJ8SxgL2MvffOokcGeBLhNDaYCGOA4_TqkuHFcBQ_QrY1cBmpd2OH70_ZLgxHDqDs_Qv01cC2d8_S6A18ESJfnXXdyEg4waAEjwEgO3YsiDQALfX14rfTV6Lou5jwoK77JniA0SqC36GEPb72_eSw-6F37aGrYATpFDaTPcR4I8J36O3peo9CDxBOON_9TMAXMB_dP6PWDNAjRMaSxgBg6cokH6WwDfJRQk5wJwDPAceAP6DEkP6Z_UZSkgBAopclBhSCicAd8aU9J0Kv7BCoJpH_R37z_VM8TsaMwyuer6dSCBgKOXb69pG_7B_W77L1Br5gA8_6wGAlgm3bAAIAx_7ThPL62kAAHdfW365GZAGWxG765CNb7bfSgH9feu132JUBYAyv74Az179AEe8OLQPBVQW7wBwqPgFPmQHfgkh7fhOKASfPM1KIHZprNORZI_QsQX3aqClSGLReA-6RtQXwGBbDQHCAIiQ3NBhYRwW0xkIXVgqA5LhtQcN9K_YtgMrJwYfzBJD_Fd5o5rij9GJldh9bCPQPUPrR1jX5gY6PhDhA6PRTA15RLMCYH67WYHHDJt78_lYH9ISaBDsG-C5QJYHjA37RpQclcXA54GJQMld3A7oGW7AqCssKNAxaMAoicE58e_cKQJA0JZfzNECnNE_1QyNQAvoCoCXaKagiSYrBi4Ayo58L7bogdadjBuVh-HQv1ijKj1Cg7y7ig9EB4emUGTwODEtPuZgsQANbonZZU1zXbgpnukHXUtkHzMMkHZgKkGIvBkH5QO6wI1i0Gm2LIZgbR0GM8glhug0LICLKx6phH-78A9_oHfaahzXGib4ms0AmSE76QMN76YIHkl2yF9B4_fUHlrZc7eHlH66EG9hgsm8ha7IcGztIkGdplx7ZzlDRtQM9BZIHOA4jtoHiZPCYuAziQ7Glx7kfmlDsFLYAng8M8TqIGEc4Ze0Nfo3EwQ3x6zLYm6oNAw12tG4hb1tUIu9GfwuBuaUHXI4EKA7vArdgp9G8KCQcQzJRmVhiGf3fKBZTP-7uoPUJEcJIQkvXOqF1el7tFUiCsvc04N1fygXIQ5tJcDFIWMlZICsMl9ExNJgFHBOEBIDiD5IK8rDqEcAZoOwIpmEhi8ofCGawKAwm_RNqSqDIGPoLRpWwdNhDUH-CLsNFCutNF9y1GCFHvWCZZtDghusKA6fPXKIAOBXg5RNJptTt1h_FHMRZPfSbdqDpp0MM_5uA7fQmBtNgCGJ3QeAJjDkaUQQTGNFt6mJyoXeKwbakcAAzGq2N5cNgG-_UAHzYOXF6EY1E3xskH9nq9bdqNVAZzr_siiEtcizfs8VfXLgdWmeNNiEmHUAMc96uNzh0w5GGsw4jYcwy4o8w0ugy4aHFBIl0xEwF9BZBNOibeANQ3xlfowANVAvfWOB9fV2H1-IiHGesiHUQL2HzMAvQkQyuIu9IOGl6NqGyBL2H5wxgBZw9p77cOOGQMK0GMgCuGAfTwwugyMHnGBjb3inHJ1w20guNH-pBwyWpqoCWoLw6aDMYFeHbw5EALwy2CiAFeHnwyuHCOKJwTw7bgVrBwZROIOGj_jusnlHABqoABGdNIOHQHaKAJ-d963xs2HmoPJpAfodgdWpDhGAJV7ivTQQtwIOGWoKBwyZLa7MtK7gcI-xDIcGjd3GEz7uvdBF8IUd7sI4XhaIfHRBw2Up67ZRH8I9RHNvXRHiPqT6DvdBErvZd7DQ9cYg2KxHYIzBjTQ9RGxoaxGpAKRG4QAJHq0JhGcmMr62g66czDRaH_jLhHBg56wbjISHiI7WAlvUGxOvcz7YcrUsSIdVAVIxOwaI0mhWIwhwGIVt6jI8xGdvdBFjvWT7DvbtCawvxHoIsAArI0Gw8jinBRI5D7tI3D7-mCHFMI3aHFSDJQgIoFHKtfiBy3PlqqcKFGE6oFGnqJD8JjZ9BlYOjgjgBaIQI9UtVvcABAoyZHMAGVcLI_eH_PftIWI5JGYMVlGRI9BEpAH57ko8VHq0FIwmmFtIPPQ7BYIwQxMtCwxAw4vdV1CmJkGHAlkGJQBOmJ6H9GAMwqPmYA6EGfBjxB0YrdrFIggR9RUpHCFkROj69tMzIZozSE5ozj7OhFRGg2EtG2xJBxFI1GwixGlJvkJ-SsYNyIlRFT6rbnA5NIVj6Vo8T6MJFnRggcyx82KdHHsv77wjNyIZ2CaDpg9ED6fY2xafbxHdo82I3o0OHauGQIvo4egONBJJ-hNMBC5NqdtxGzk0fatHvkAVHBJHiw7JLIcBRORIVvVFZLo3DHro5QV67VjGfxNT7RDinAGpIJCXjjWAWJKBHPdvNJBWItIUWOrFw9HQhWfX5hWHHxparCBwmIxtGMOG5Go2GzGawLkH6TTFCMwzForvVJxxOAiGgY0Z0hYx6C_1HhwTQYjHZYxoHJ5DpoFY89HO0FcApdtz74gatovoMkCNOPKaBAUmp2pnVC0AXfBG3FQApng0h6IHMUGUe4kPWNpw3PDvBMAGEZnIA0ghphk4nY3LBxpvV7vPcMh5gJPISkYoSLkBKY2TByYEiTyZcHALIYVZIr4Vc4rEVXIJU5iiquzIUi7Vc7MHVWjICaHjolgQs5ZZGdMlTnKHMJJSAh3G6x6PlU9GPnCQ6hEhYpznNZHpksh-ARshgQTarFzKsZHTfElLAEDQDzJFwTBFXNJXC3HqdO3GwzJ3GwhKXM3Vc3GRsK3H247XNu4yq5e43DoJ44udh443GPLDPG241IrnAAjxbuJXME40kh9KvnMkdMvH242vGN43XMwhNvGfTKS5edEUrZ1TvHaXBrdluKy4L4_mrT4_uVb4_OYQQQOd2zGy5N41fGfTBJ0_UdnNP48fHJnH0id40FxSMGJj-gGdIzY_bhT1sNRZwIvBiVcqyMVZaSMlVpE5FJOhrNris4dn_J2XWbA7fQB5PzqPJZTObGMgMcqXgHCoBqB-7eArB5PwZlgPgBKqPNBLRQIVYAU45Lo0406q8dCx419nNYkoMsrp3W1brVqDRioFHG4VUlkEVZ0rdlcirnZoK08COdZhE1IrRE7HHxE1MDJE5LpBWn25sQDwmA1tXEcDa2cI4uZaVQ6Kz7DOTbawFrw3YEYmDITRtNE348mAkNG2vWph7lOU4C41rBpziuUFdiA9-PsXalriBUcBAIdpkBiIkkI2cmhlZ8Hdu4CQup6DfE0F5kkI2dVLHTVa_oa597M1cjjPMIfE6eR_E42dPwM_1DXM5xmzpSBoBENggTtJY0iGSqC3OEpiLTQxRFBHhXIsXRQ_CGsRwO4p6XTUCXwPiBkJPMrmSJVYsfAQAtqMEAEEzTxrVom1wk6kmokz6c53lA7PQXNZHE_GcAk6DZ7doz9ZgAPsfE-KAuzmknO0Bi10Dir8nwG2EcE9FdSVVYNOzi2cTqMkmxk9iAJkz0Cpk0oREWohkR9DknnE3k0cBOMnKAIsnTk-kn5sAJ6fJO_H3YAAnH4zvG_siVCdTQ8ho8t9McjtFVmPjAAzk5ZdyrP0ch9RFBtyjSHr47y5a5o5dG3GcnuLHft1k0inGzlMJSkxwhyk5ksNfhkmN2qVhmgQ4mHk04mEzuItLcnYmiU-TRZTDyDTUIJhEQHHgCgHmEvrvlkdE2uUePm4nZFiIZFrqxNhAtz4WUwG4Zk_h0k1APQMbmG4Z7Z5VJDrg8dDvcnHk5SAzk7g9f-vSmp5JUnZwMymxUwG5gPRmt7DhEnZGrdGUJKhYh5Gb8JtUPa_pt2d1rqEnY5Nz4q4-sqR_A7QBU0DFTGoJcDHk5dTMKam0dgPsNJqxrP9q7RnU2Ygnjg7bXmpMpJUxEmEDn6m5bQGyrKu6mf-J6mzrmamXU9slR2na4HU3_8htCxqVBuftJivGn_U6I8BzV8oQ03KmtYGcmhHdmn_wAo9I00b7fDccmIkwqmN9tWm48AnUD9iTBy08XRYk5gdlU7indIADFhQAynVUykB1Uwam5rFWhUUzqtVfpilDfvymNU4Cwl8vzQipk8dh09X8MDqr84yPMIQ03HgwUzEm1k6OmT_fGdV07KnSUxunL_m2nVfhaBT00bshPGunAIQU6QUwVoADDyd7jpOUCUwRcvaneZR46KBx4_In548OccPriZk01OnJVhf8-jrbUX00vGx433HV4-vG3IFs5AE8AnHzD-nDHOp960xHhkU4hmdU4WnQUxim6MYBmbah8RK46Wn_MEtYADFSm8ACcnC43k0KU2_cPY62xCJHcw8ALSnzNGVZhii5piMzSnhaJwI-Cp_jPYzRn7lPRmqM2SxIwG7A-M4iBfArRnQwTLTIAn8mhTF4D4AIJYPUGfxlU4ym1UwkAU04B4d_R_oY7Sh1Yfh91hivC8DItqHFZI5FvoOcq6Sdcmqk8J5IsqpZsMMJSzpKNVorg9QBqJZnyoG9b75IGkRwL85r7ZOnB0-sri6N_VmaPCdvIcRnswMeAWAPbCtak-dSqApm-0wOnODtIFxU8XQPoC4ForkHBRU15n-rvFmaIo5mENacr-lu6AUs5o9vM8J4VQ-K8zYOXRMrtGmMvHFnCs7WBEswW4g4GXQlYKwJMs3smpEkln3QPVnXADTl0sxUBf5Jph3M6D8VMxaBioOVnIk2lnhPHFh_MyFbnY3mBAs5pholEp4cgGijyoFpAHvVFaHxiuDafgXpqNEKrkHPBDUIDHQHM7wlbwnPsSCkEwT1m9RW4Mld2k0mnufENgTWqpDOrH-bGENKBU5MjRgBGCtdltqHEkzThUcm1YHQK6JcVqT1WoAidKsxQp-A2vz7NWLQhAydi1s9gIjISSCXaBsH4BjgwxHWfL3WnOVVMGNRaWntQRwC4FfUBA4YBO6AaVUEBsmAXAHlVbZiSJ2LJwEfg_Rsw4p-PrZjSr7Gu7LtQA45tiBAO5o16LTmA_XbZVwJeZsHB3YaHFDaEJbhRnRrzm_aNQ5xhILmwcxzYmrI4ZtQcsIs5ZXb6CDhpf0HABu_JeYnbKDARgIrJf0AHZu_JrnUAMo4YQEZlWrFKFGrPmADc6jAkggPYp-AXgFqnXgPtYqmsHgKAyE_GsMRMQmJkM7mPnAwnR6H9ZVLp7nWuhoneEy6dOejFEsgj2mVUzVylM2RF_0_Q94wTCG2VGubQcN0BioPEiCLXQQxgAN1Q2mrwV6lJh07MyR5LNPd22l5tv-jTR3EPMr8BJ8ttijcAyzugUWHIUDEgItVElDiFervXnFqkDq1UCMA2EoyUYXmrwSmGMAt8aOoV-vhz4vF3mooL3mhqBDB1ePG6izCMB_TR661eP0FNNUW6e8xsoYQLksh833o0WpeZbcw3n7c4DqEDqDBD853ndc6CoYAAJrUAKTYz84rJSbMfnyoDfnz8z5Leqh9Bt82-hd8-3gPtQfmj839aL86fnv85fm_rarnQVLPnr80AW_8z5LBmMamDQQVwd823m7tQLh7lGmoj8yfn6CKZwf8ygWQC0rmMC5rndc-AXK028UTQAEbmjfqBeBBAAYC5MJ2xIDrkevLAyC-_nAdcO5VLOO6NMG7n7cA8Z2AAycmTuyteloVwcQAuBmSEVw9mJ2ALRCjQ1ACGIpeGyc--LiE5EB_1MkCBUNmHNYhNhjwoEx6xu9lLaZCZSR_c7IWJaKhYEHltqXpPbgA2tgBxFjESFECcqG1lI1w0xjxknesA5C9iAFC0Q8uC3FGsQz6mB3loW5rBg9JmvM1zrFwXJ_FcRBE03KXiBYXQnkRQ2jpQWRIvMVmTvl1EHtjSmRN4WRHFRF7DN4XsejTqqcJ_tFA-f8Lipl8oU6-nruPvGpFQPGGgF3G85o5cLC6vonbJfd9nhW6ggFABxcCdQJIHtmW7CeDnA6EGnAz8SesqZhyiy4pKiwuAaiz1FYBnHnM7SPoWM34iSiJFnI8_2nlM_-notJAWzYFNmRMzxmSiBZpbEx2cP7gpp-3qO1TVuat4HszBgHgxnsAg-cQtH0rPtswWpnppgXAprQOMOysBC-gALRJk4--PjCFwN1IgMSMrsfJ3t34gGksdSfqMDTSMqdZDquC7HQfrENrIi9lHwzqLb8hOdYNPazZnDFxTeEi4Eri0IWAojksOMC-cek5MrWHjwp-wooggtMlcek5KsSFUK9QfvdmvUo8rwdta0lara1MlnmAnWlI0azp7YXDISXclndafEBGpNYgnUBICRxttu7nSE17m2S_NgE6iYWyEw8c9C8oWxBEYW1C_yWPnOvQE6iKWGNcIXDC1EXw6vkIP7ljru3BsWK0GOcUc8enIwB_d8U0BnSsBVQGPrKAmPnG92PvoBOPk1NqTYzAXpmUC_wmerT2mgCM5r0jzQZVk2aVT05FR8nZgWlAh81T1nAGrA3tB6WelRDz-1XxBVFW6WDyg2ZqdJDJ1CEkhDQMv02EqRgN81JgQy_Iqwyy0rIy9GWGS_wg_fM8AA_HrCSyGGLF40mWgE3eCqzMpA25VJhIwIWWUyzcCLFVGXDQPLlEUEcrl7SHhK6HdmzXWZsDqDEBwElIor5IcRgvVpyqaK4gGLvPVUlovGl4QrFQy6w5VEDrgxQZpAzRIEiWxS0BeC6MAy-cqClJXTgVeCVLQjE_YBVMTn1QXpBNy-oXR8DeBgxOqDVERIg0iYEiV-gMY-gIcdAkcBKBjN5argMmB4YNz7SMFqUVuNaZdMNHkLqOSBYgNDChsEVx2HfUBh3aoxRqnkA3Qm0gQQWeA2LXeAmIvjs6aH4Z3RGQouuAJJAhIb6awCad6A-ItixG_9ufmQH2LYv7gbTQAh7mnRiyEyrnNU-8Ttc6jS3TWaaxpa8N1jGdHQMl4RQIesqYjeA-Eh3cwoppgpED6XgK9QAmoS7Rb1pbBX0T_MlVOfBps-6A3obGTfIbiBDM3EL2-FWrZKxABJADxXfS3-FPifblrVUScfpvvIS4NlpqbK6IICXsgavaxsP-ipgEJVVl34XHYMlq3IhgNrm-whwBKNkS6EJbOQH1kScMdrWB1CAYLaMJOA6sNYBkiDkBxou7beNhhsLAF5WNJGB0_KxvUugBko1okGIgXiPdkFuwBwq7SJQjFFWkmIbEgq8HFflqwppMIKM6lP5XPAT6X7wleEdfSXCBrovGIEdLApEHAAOAKahRMUsB5sY1WPAMGbL1KJi1CA4qXSwta0oPNiOq5ZXmHD1WqnFJh-q4U8UNOj00oF-D0eitFSVJ_AQKoagJq7QnvwfpXZq7M9Y0eYWE1Oj1Fc9FUteLktDUE7ZhVONXiyKvmlIDeEOq1rwXnjtXiyIag8CPiBLesJ4zFLKAOYZhhpi5GDgg0Bp0eoZ6gFS9QbSLdX6lLksWqx1WcgOwILFLV4qnPNBozUqDxlHBleClIl9evIGLzLkt_1LnnR1GlK6sNDWWKlIkPAN9WqcL9WVorksUgIVBka-wJTUeODH0gVgCoT9XKvDZDfAGoQ_5Wua-tt7kAEKwBs5X4qEnCxWpRKZxjEdiCpoElp1JFOEyWKetzABAjvVgzQQQWlhUeA8n5oqag8AG7BFZLLWfoG7BgzbjWG5G7B2AD7TPAfIq_SytxCaxUdlOrkCpkJ6g3S1rXWQ3vNy-R556-KrXiyD6Wta6wk-9C9hVa-rXra-aCda9ut9a-gMna7MDZC2lB4Ma7QPaxUr5oGwlbNA7XlGL6Xnax1XXaxGRPUH7WFS1yCFqz3RmgXl0G5EmaForksIAG-bva0SdIwNTlyoCBVUnAO9M69nXmgHvMzCzocM63vMs67ksK60NRirUScS60WZDEF7c1a8ZBH7J7ZWAEsAdmGSBO6-MA_DJsFDEFbnE5J7ZGaG3WfoO3Wu6zMBe604B-6zXwqnHbZtPCH4_DAvX2ADswJ6yDEPbelCl0Bx49YXjW95mxXja6SpLAbQmt63OAd646XPa5_AD6z3Qt61U4T6zeBja1B8MVbZWtXcLXzxJldnwlzXrxSyB_s3zWFqALXOVVT15REtEPAFk04VPKISOOLXAGw3Iz2OJmvJSRNPzAA3Ja11FPxGfxQG-hdhaxntGQIA3gG5A2I0-Lq2ChAi54cAAIEWGAqBDsoiGykASG4Q3KnPSQCoO3rfQQjMqq5QA-kFgAdomfwIEbEhG0MGa7WNaFmEMFILAh4A1Wqja9sC6AoANFtXOo_ohGwuA4KxAjQYMFdhG9Fsisl1xZGwuBxGC8gJGwbFGQIPxPxFnWVUCzclG-o3ugAN0laW4U1Gyo29ogpBYqiY20QI9E9Kbg29G-IxlThRd1AAbs0DRtbzXPSYXkOqsjPoGFqEVil5QApA3OLg3IgocQUCvIAEylY3aG5Jn4G51EmGyw3pa1A2Wva1WpaxzXMG4oUvc6A2UPgw2Ym1o22Gz0AOG8zarjKiAUq4IVZbBpJDpqSopkEnV1gEqJDpl1qCFA8QJ0_-oP9Bx5oiP3ReVPjWKm4VABus02-6LVMOAIAMOmyUx7aFJaVSMvxF4_A2fo6iBzosg2iEsMVQcFH8z7ewR5m8j9WFMwdB7WtEpEIyA1QhjxH_pGAxyxPNky5B4SUJTsLoHs21jMmXQYBaIn80WYCm1IaRQmN7XygQAim2Aw_whs3NUJDEOa0D1O3NBWEQrBX3RLs35Yvs3tnPc2u9K83NbJd8vlmU4EG8g3bFvCUEJpRW1CAAA9ahGzQNNQdZ-hG8AEGLAAKGAFQVFtNA3gAYtlGBYtnFugwNFv4tzFvYtzkBbKdCBAsLYANyEjIZN-iveoV955lEPRAq4WRljXgS8OKKAqoPHWst5Trst1CunQSfzKoQY1U0PltawAVuWvSHrgynls3vIDjM2hhudRVwCxNrxqVOCl7UJEjjFACBGzw0htUN46JLAXVvvAchsGtyhvvAB6ImtnpI0NyJsYNhBvKtpBtxN0zg9JRJsz15JsINrBvpN_OPRxRVszwnM05Np1ve2y67YAQBsV0aWu3VJ1uoNpJuLRBBt0tphyet7BTet0OC-ttVt7ADVsBtyESMgbzBQQ6qt3N7BuZt0yVtGYqDyiPNuvQIk6Vlt6zVl61vv7RhsZtoyz5t2YzYNrx0WATetUebBsdVofOFQcutlt4stw6NMt1ljgSwNhFwjALr2vN6ZtrlKP7q1r0tBl6oKMgc0LnRaqvYAKZumoP8Ju8GZt-5OZvFMQ1pI52nw2t6JvYAHM1L_Qj4LB1hQTwp4QHq_OVbA20uoAqQQdnaJJgguJIllzoCAIqBGHwzkDwuBGYhQjYF89WszyQWsyBQOhtFmNmYBmR6z5zerhBCjRKSZm8CigHUxjy-JLC6JdWruVhz_cUUC-wB2BKgiRB7cNPLewGGSBIzWPgtyDvQdh1Wwd2GTwdrFysOMLjuzSHRPy92bU6NDvrAAVyigMeaF8tNv5CPi1DEwS1faVjtMElGZvtosxg5ZbIQ5HzIpZNLKsOMzryQHoYSIGHLyQSXIrSM9vOOG2S_OJk1FSIzheOApC-OJWD-OCabzTJaYZOWaY7wOcL4uAEGVQrQTVQ_8CPOHON3AwlwLcIf7rAbcp5quXEHlflyCuU8oQgJFyWd-mafAr3jZqvcoed1Vx-1bzv_A2uMuObU2cayjIt4VfEY8StwP_RC2IhfTt2CDqq8ly8qdZNi0kcWLvngOTVShJLsIhTcgr4tvC8l9C1rWh1yWyZTLsapDRTtoQpHharDANw6xflWZs0PLpSJUwNNGTItQmVd7LDoSgSqXRhSlJM-14EKhRddnS0S9BvrDO7ZqNd-1aGvIbvDefrsRxEhXt0fJjDLA-Q6-BEvHgBRE2iad18TO-jjOkJ2IRWbxXmsZTvBoCj22nc2THQbznm5_kcoGK0BFVZtU4QMIVawfQoxQWIkKJ81bd8nl1-TWJUKHXx22NX4JAeA3TI1dPPdnKAO2UmztARgC_d8lAxWpYBfWiHuQ9iHuqy2UNy-DbvbNZwSTOq81S7HrvBOhHvhe9_n1-OVLkoHPzhYUjAqYUarepCyLM0dxq45cFAb5M5CwgcNj_lzzZJRjsB2Adxqf6VJuAK16nINOruLKRKnOncFKIxTFKo9-rvvZLnsQJBHQ4pXHsofIKIUZRozNOqrtzxYp2-AlFQNqd_6J7Pn7zXZ5wVdyqBYN8eoS2XBtnxTkFGLGbshgsDzmAs3LToC7KuaKXupN_zCpdycRjtCdoOtcHW-A1eRciSA6ocFqnocZ3s1gHLsdIXDsmwf0G0fQMHqDYMFiZ9rgRgqMFELSWQSJGbJSJZdxWdrFxLgtJojAUmpBJ0TI8NCVIuCbdjGJGiEdQ2dyYMBzbqanXZ6hyqCBTRPsyht4IJQtzuruMKG59tyEF968REQg2H56svtSuOSrcuSvvpQ6vtu1DYR19kvtXguyGrGX2pazZwCt9vAZ59wAIh1XiGxg3Qb194NLb0WztUuZwkOdo8oCuE8px9x_QZtW3uDDO2yIQz8ZLtH1qrtQ5jqaoiFFZcKH7g3_E79juDr96Ybd9vrSpN7GtQYIqFZAKj5ntl6ZQuGFzvwRTuGAcR24vGpzXKyt6FcKYDAuDkosCEl2uiR-vI0Q4jWgfmv-pSICQ0sfSPdNbKe2dYDTuNh2ZJZ9RCNf6gwG_fU7RCwLEF4XiYDz8QjKGLRID6RJfd1AeADmA00F7AckFigeUleVb1YeSAQG0gdm6dQjkDzvaUD4XhfFmgdmAWYJaxwIT_dQAdC1NA7WZtEvMkMYSAD0cAmgINIpOhIAADpgfHiUQdMDgR2FBS8pSu_n74FuUBo2YnWIG51FXEBbEjdvxr_BtfjMe-0WsKBbFxglS5Hp4ikM0PMupV2GIk6r16wKx-S6DyQfIOY4R3gWQRzZNbKNprIMZ5PgLqSKmveoVJ0wxQAf1sUxryDlGTeDi66QMYuAL8QAcGFrACIsMIdw6bwchtPN37pdSTNeHsEiG4fspSMfTJYAOx-DygRCeZwKwebW14IAvPbURRC0YIIWzPF7Li5YgdTImoelBeYAfk_wcc_dSRuDjCHRD69MH7CBjLYI4R-DpvpNDmAAfkyvpDD5_zJYabC1D5oeHVw_bHCAp4ofKYcFEMz3rScFzQAPDruAte3Weh7TdTB0DesD8iux9JxrwPYcND-r2TTA4fTTTJzzTImT7yRabnD4aY3DrCKCmCoMICH-wFIUOPf48OMC516R3wNmvBOIiChOIGEhq8cngwpWG_DomRbYNqBkCBhUAgiEc5QKEesDpz01rcDYu4V0CkAhRAeAQhBIjvPAojiMJuXH-a5aRfQM7dAr0lCwq4rGN4v9Hu4wbNDa7zBe4TLSL5Slcci7LQxEs94bCjYBe6rLYFY5Op-6zwGnaDiBe4CbRpaXbKnDD0EItJa9JDNl7ZOibQHXpQOkvvJXkL1AWv3MkZ8KaYKBEZLFzbTLOTym3E-bynDNiQJu5WYiE0svzNi573Fu4UQQ6bObWhbELdmjzI0bDDDM3y4vGTYVVwhPL4WUwkj1ENl2GZBu-AB7eXABCCjtrvBm-5aO5iwDKgR3XHLLJ25YTghEPOBaja13XW5MuxKdH0B_Ba-hJ5rBaEhwUe4XZFZqrO4iHtnej1CBMcjI67poUBoBm6Ntb56YlBwLaNC7HLNpm6HM0BkPMfLLU7gYAIsclj2SaaMCDAVj1GBVj4se6gWsfLJUHDpj2LZijj0olUesflLNpDeeAceijs1Y4ALADTYUceJjnAAAvSceZrffPzDP_bxjhseloNKDLj-cof5guiZuibVN7Kmj7MOEeerTvZJrT0dYaeccjI9045kfA1jjjMfF7LMeQNLygVkTceFHBhaWB98dJHOIeIsI_JrKHB3eoF4j3LBA5lNdX20V6OL3LBisZLe6T2VJozkoV0e2jrSv8LRePbbGPYgpgRAZuRWBW7b0fHLN2Jjj_0foXRm3v9aiZO2QMepDF0f-J20cYTscBYTw0cfOfCeJjqtCleLrj1CWB7p063pchsKPVeNicjqZ3rk5Hidl2LzzDNKUjETx7UIFhnOzCC9hQbIjAtiQAOymJNZGZXidqALA1W7I3LLrTtxiTonL_t0eS7TIEYOjEDqsN6I5hbcspiPOUPGTte35dmjGHTUd41bF-CO-vEfaV6GjKqRlafAL-So-TZ6LweFh2ACutwgUKoNAJev8PSQCvwKBZfwEBTo0CFj3yOt6uKFHYiYdg08YC4BuVxKtygCb76Tg6aGTq0f2T2GJW1CDYxhk6gV0N2sEAXWmHTMzZmibZ6vtMZZLlRmjxoJvKiBkmBtMShbEnDDZdCUjbr1boBdyc6jAKVRhoK6yeGTqqdVaWqdH4X9BioRqf0QR-s00K2praQAP5TqkEG14qeCjWBxlTv2ANAdbiWAEbB1ypjoDzYGj9TqyyDToWwwgEaccncFvgdYbZVbPaZ2To6ZaSVqfBmibsHXKRoRAPSX5bEDoziK94C0doe8lVKdPT2rZELEjgD9CyM_kRXPvaznBEABgKDcEjYgzv_7Malqcgz1YNnTtKdZbEDrh0SHCfTi6dRFmRvgzi_N6DlJrOtYc0gtUoAYz9gCxVDGe0QRBSlV8dwkKNvb7SRo4tbA-T3YO8IGRSHZt8YoA596OLwu3_1eGiF1FDIKDI61CKtToh7HNvBqV-S5ttrQqfzT9mikoEQCMRVGcvTiUjmDjhqUMO1yHTWZ5HgYSszUcfo-XS3qK55n1PPAsRn8AWfzXIWdZdtdT5NB2iHTC5tZdw34bPcvTqzuuvhYFifleQHIcTxw2PO6rbAjEDp1kRrx8Th5WDNWUtYAEScJgxWeCjF2fnTt2egjbrzLayq02ifrUYzr3aK9x7ziYLZsm7dSSqz7IA2ztgRNOmpubeusjtWztw8bXHrvHIk5IlIJx2ATLZ5V60ctKTTAXTC9a2O5M19hA5DaiUYaQCAR7IndAotKO1htwQt2eiLq7WjkUtnLZIAaeA-TJOABRIgIl2wxL1b3scNG9yn-YonM2rfcDR43UJGm-iUYBnyRTadT1ojlQZiAiAeRD9ztqf9hE7gGiHzzDISJiuiNudFMKUANJ2DwhUn-ZdhBJTUAZyAsoK2y0YdlbWtcksXLShbfbCufoFRyotKMJisu5mAnUKNEvwazhE-RKRTT3aRVJvea5LDlWobSMCizqGA2T0qdU-ZL7dPaGd2tD_qJg2GJuQLEe1nNLOQLoaiZTiWrNAL1ZkhGSxSJTBdIbE7YhVgBbUz6LboLmOfYLaDZtvdBVjgNjKZ4dUbGxT5aRfI9bTgWFZNTgBaDj4TZyj9GDfbBTaXTNbahZCafNw1SIPEAYB5AIbCmbXQ6LbchbWjpPKZnEWzA5g-RL6o6cwmNCdKL-PQpPGhcvYmbZ0F-bZVzq6YlbdC6KLsRcKdYbaiL6uc2L0LILNu83DNzCiLbRXPnWARcI6_cfIOMtDWQFwqQRkg1JeXzxngcXB-Li5ABL2rmRgX3NSNXxeIKi6IT8iUYGYWcAtoG22_D9sihLuJcRLvICJLiRgpLqJfj0J2yxLlwqNpIJcpeEJeYwMJfCgRtL5Lh7O8JaPijVZx7Tu1BfcFkWtnSLuTIeehfFCKkrbxGOcgjBC1whRraGL48C72YGduIEEb2FtgajLozLkAbvycz7DMR2KZdLZ6ugOiPue-KZL5XTiGezPA5Dx4TpccEPI7cmJrZTLkEZs99YtTL0DCcjENvAe7Ze8ziGcIHYDIkGm_1qGGOf01OqebO65fPLp7VPgHpKPLt1PPL-wMcertqY0G5fSyT5fMjGuwrcG_0z0HZdnL0FfXI9ACA0G_3BkJ5dnL4_a7d2gxArj5cIFukZevRFfP9ENCGGXWf2eRlZTUScOM9PMC_zpJgDhBeeY0NefWL3YAtKAl4k0QbMwtHKCA0BdNp-Uqg2AHc504dOHNA-WiV0FTAsgZL7GBR2JEjGZL12iwJzdd0L2Ft9CwzoZcwAdGeZuLGcX5SbY0zhVddCbPb2cDHBapxIaroMHAcQaFetTsvYme9lfxADHxnyH_BXoqIB9hFkZSMzSB6r95dTLqYRWr1wAWBW1eEAG_2Or1qeS7eab6ryeDArswvZudSQYGjHjNlfCHZz0aviWP6Blm9LpdLwuzO8kQuWFpIL2ztHJXxS3pJaZ2d5lkNeezm1T8Tn2diCf2dEOsnqd7NrvtiI5cboCZcVlP1IyN7vyV-GZfhzlSeSe-ZpU81B4bL6WQtr7AC3mxTxzUErpeeabCrQfitlLscDqzirPHgLLxheR_h-pX3qdkKypvlhoAfl88DNl3FVkl4FUJKPRq8hs2A9hUJTgryQDA0IaiMqZpf01cFfb2viCa58FdN5GuyA0bvzPD6ew5QNNRTrzb1YIHtf4Q8GXzYKddwripV55cFeQGTvZHrmezA0L9f_rl92Hrl1cvEKdfwKsGfMVkmAur8pwT8tG5Trl1c4QipeZLhJfiYJJcpAFJdIbyICVL-JckG2u4w25Fd8z91fd8WIa_rnpKlLktDEb6WDVL99d1Tkl5EAHDeNpD32Eb25c-7Ujc9rvFofm7ter4EX5lusPW56GNdShDtdYAZtw9-hNdylr7VN-TBKwQz6h4bONflYL1e3L69OoLu53lLdVcYzvXPVr1Bcw92m0fpQTdGZYTfd-GUD8wxSbXUBV67dI_hqb6NL6b0GCGbwFcGrgNcyr0Zd8hYzfHgRVekbTcifLrTcabum149qTBATNj5UAcWouVVzcM7fUd7AD1i2Z0bZ0rhwZW1VSyhbrypHEWRex8yzyXUVEAnUNsvEroNYesIdsAnOgDoiKTeJroh7Cb7IPRb-xdKbXpSGb6zdqbgzfibkTda9jmdlb8xciVnSeUZaDq3EENc5LqUanTnI1MZ23o1BUNVH9bJ399P9c5QT9ex7ZoS29OFcAbibcdNI4BdNX2eVeDNevTkbfEbj2eLbvNfYEHNfYAQtfzNM9cz2FbgXr_9fXr4orRAW9ePgUGBhr-u0Nr7ACMEMNckQm7cib19dX1Kbfgrx7fd-D9cvbn3rTb97dpQabdfb9vgDbu5G_b3PovLo_C_b33VOZVhR5zxyd7zCdHruhRArLlDYdwF2i2DvnZmL8RcV0AKKJTH-ZFzgdQlz1DYlTiucjgDHeqMWueRgKcnuAdBOwKuYanEV0T1zzgCNzopRULuUC9T60cKWZTI_z82DhMMQQAL5IBTzuzbtnY6eIatDp6L9KBs7p0ZETsXdWFoKBm9B2etrq3qZriXcCPTjeldAScbb72dbb32e7b0X5Sr72sXT6ddubsQRrNXw2FbtNeHzktCIDFkWjrjFCohCdcReKVe3jyMAVkRba2bureibwG6hbrp0WAD9dgwZXejb9AArcd7cfw6bd-7g3c_b43cfw1XcbCDwwG76PfB7tXBA7pRFh70OcvwfAD-AEGEFABPdCQzjYxbyrfu7pdRqbgopmbmPol5Kzf3EV3d2b71ChbgPcrcMNPh7t7fG72dRqbgPeA0evep7gR4R75bXN79hiHvVLqfL_3fx7pvdxWlvdJ7goDt7gyfs0dPdoWQbfvbyNZeG1bYOLlreSZmN5uw2wAOiGfc2iOFShb0bU8DG0SJz9C7GI9fe_BWx79LmkKNbGVSJzmBgesXkq9ax0Swz0LegwYGLI9hNyK_HTzAxX1asPIPOLwYNa2eRhR4unUQquySLBAEarmAbIAZXRMHlAKhibYCx4-MM13RG05GSI4aEAwqaHAwwbcLQ2JzWlhRD6AdCD52S-BGQZGDUI-kCMgOJD6AC0DJgAmltSoyCE06AWAqf7WYO9mdI6_fcFiJ_cxMj0KuqP5iP75_dz7gCeeuiCfYKI_dwADfe2PZm2r7uAhCH34IlRbP50ptTe776yQyl0X1aucQ8b7qQ9b7xS1b74ir5dmuvYWvyHqrLe3EVCV1-a0eq2Tru5r7iQ8yZ3J7j8WQ--zvffc4Gp6Jzz5uiG5Q-SH0YK5PZjuNGW6bNPGTAoTedapPf-6YcDJ72JLJ7vJHJ5b74M1hK0ieRr02Afro7esr7CeyU81VZL9ZaoAH-zt2F3OR-jT6r3RbApro0Aa7F1RqAarzNAAbrBHwo867ibVe7utMmTqbxgAah7pQCo8DmqHyotOK1y77pqW9XpoDdGvcfr9beu9BrV8QEYDeeTo-N7-675CEYAAvQY__r4fos3SXDO70I82ePuTukMQ8xAcw_T8Vw9b7qw9GL8Xyg_Wx6shyKMqgnwB-LD9e5LCIAJHslhJH_VCpHyrB-dXP0-AMJYsrwPejqY4_RyU48T884812NI8-XXY8-75IAHHy9dHH4cqDl5uAvHlI9vHy4-pa2QPJAW4_Tbh4__HxI9Ani49kJktod6_kZrfeTeS4HZuhb3CuJ5fWciRGN7mzuUKF79hh4nzYIeF7brjKGN69rx2cJhqnCDvAfdVPMj3tduNtr8PJUbbHeYEaqQ1XUZBgYbFozVx8kK0Lr7TEb91zDFVLbDbT84UXdC3r7Qx5mIDzYJdj8oSnp5acTafJL5Co_FQR_dnweRv8oC5P99JdS-oUCBaMcFDDjTU-B9Jh0jJ-ZpvIUNeIwQkAwJcpafYOeDwAYYA5QfzCDAkioCSe0-R4KgA3ATkAGn_oLeeJ0_AOOBJx0-kHFYSIC7SNNQG5J09a8VVgksNjIXQJ24SkSMdz6hCXgDTgianocqZHQNaRn6WToWt5AXQN5A_kBOpvIMRt6-NAB2cbc3HARGDfggs-iMSZDH2HM1Fm9HolmhjcBK6gAVmshOBIytApnibVvIFocTdcs9TVys-Zmms9aNus-XUf6SNn8s2ThD5xtngqAdn3BtfKY6FgwLs9oAT-DFn9HqbkJxtoAJ8CAAYz-3wGrhr5hsJDpqdpD61R4sABmefyPyh9dhuf2gIAAI0h3PaQ6OjuZ5-dV9A7PBUB1LUJkRaKE7PbMMwXYCna2HF6uKkvQlKkrVLc99Xqbo2APGYpAJemoF9MBECB2BFgAxc_ujXcFwNWMgczZ0mOh87OXxQvDsz8sFwLF0k-grmWJgsAwBk10t8YIvuLgQv-plt0WJgBm6pmC7VPW5Bhva5YhBg2EvMepwtOHVjCblg4MxjBgGvjLHWdfF5BtMinPF-to76hiNr5AVjuHAw4KgdE47F-oMPHHtwMl4syEnGbY15qCk5HAjwlHBUvp2CrY6eDDGEUA1j30ck442k0vZ0Zuw_2Dbw0uGkvxl7_Euvb39raGoBmGgE-9F6w0wfa_8ofZjBDJoj7CYKj7rnb90aJiH7IkOGSmUJG1e4KIh1kIPHtkO6AXRlE8atxo7bIcO6okNsMCFE_YoV-cp0_civqxgwv0V9QvsV4MH5gCkDJ_fkDJhrEvPkL8hG7jCvTqTSvyjFwvEumn0K_YwMTF6T7l5Egm2Y-nwSbi37mBnKCE29xjzV4QOREJZnw_er7mBin71uykSRF9AMJF7qvow2avweyCvOq2avwx_2CDQ0dnmBnymgxXlUrtD6v4jyYvoGF_LBMVv09iSnohUKr7s1__WZyBlDlV9RM1ugovTptFA_l7yvI_aw0El6771NYprCbq-ND_d-TIXcM0KODGjjF-av1MYOEQkmWkkzAmj4MdxEa7E_Yo4jkkzLCxzErC6yhbA_Dg1RBjTuB09yN5m9yl_ujrbG0vO-lLYmN-7YdHB0v4E1QkhwgBjIsaMveN-HYgnDC75l6I4FN-97h0GZ7UF90BECCfA2ch1KP141YsKBRw2AKpNucpSBtAOL1GQN_PWQP_PNUiBEWQmAv1JkEI4zEo67wkvgihCJkTN5uQ4F54Bqw9qcSt_bgMF-2QRnHY6-Q2GwlM3cmHqiWAxs3E6AMyPatF7sTTl4E-I6Hik7vZsvQw3svfGr4yVt_ZV4YNcvb1fcv2gM8vlV91v0nUmvWp837s14X1JV90GR_eOvJ_a1P516Ch3QCNGft939tKgxGREMBuE3ed4zZTuOtSCBt8-vZyt3kx3Nvg5ntSCuN8V6oiDblqQvuBLvmO8uNV9H6vw4IevI2sjv1NcTBJt7jvkPgQmpNzKNOwBGtNENQm59r4Kw21Tvx9ow1Fep74ZUyVIJl3bv2wGASb14GvJ1_rv4V-WCp0Fv7-JrX4hvFsTullaQv18m3SsABvfIm9QzLG9AUoFrK6mulv_8G6w8Uj2j_JnstXY0PGboyhv7NG6wrowK4vrH3vnqC-U1fRR9auEP6798lwiPTl6iom8r9BqKzevS_vVd5-T3BHpvfoMZveIDAv_8CfACt-d1U9k5vihB5vuscZg-sY2QP546mNnp2H0yvJuBB207a8BRu_U1gviLle0A_xGcJwINvaiuVumF72MFisnjbs0jmEiGIuSt1Iu6wCTmps2Vu1nZrAdlxYfDl3WAEp2lirMwtM0p0QvNYHYf1s3jmEiHeTVD6KL6wBy-2Coofls0njsj5rAu3waV-3wlmEiGtN0io2MX33UfP300fAXa-cbUwtvRN0D7DF8v-SqrOkl8sKW3qUwtPFp1EdS3ZXZU65eJ1Am2Bwx5P_1y1HI5crEm1xeN68mlo4TBgUikTWVJcBxOyQHcaTlaROl_wmAJnBDNe881gB86BO6i7nAwJyx-kok0wOrp0wfr2iuyOyZWFyw7cPDzJTMe5Evtn2aeeJV-elz0zqMWh8CudqqePoOUVvvePOQvkV9Lt7DBU0BD7Ht5jk3t-jvJD_x0vD7acd17-oHchYY_mIygVAnz7lEB7k4_YZNk_Zba8UO3o4j61mKtwp02V57bL8a1ukc39vPckavTu3Kwoexoh8By8fjN2yOMDtZwOULjIRwj-gDN2ACyR-yO2sRdE6JbzOutB-uTdAeoZU8dHKoikw6vxuoN85dAIQEfnZvhyWiqvPntFwKf-z5uuhz_YOkj26HCaeCLmRySO4BzCyuD_6mGkbKOH49LUf019wNEItubd60Oum7oPbfZnvOz6jvpfe3ozD44f1Lm2fgP2NOIz40e16PGfhdz4YPci89v6RxfIMR6lVVSbtxd7aYKV8aiaRaXvbcjpfV6KF83HCI0Xnu3ueP3fGgULJfMd8ofZD7hkFffjvnPyFGFz4jwgNy8-jvCDvoewd-XAEYINvBVfDezc6NL61f-4NmTimgAQXtnH-er_C-mCK8N1ewjvJL4bvUiR4flL9li1L78fZ-4egoz4ZfYr-d4J10zumEg0aBz7VfEEL1fR1-jiJpx9for4mfgASmfgP3mfs4PJfzM0EfvMxEfQz6jf9L5jfTL9M4lEG_OSmqDv353afsz_YslJVt8EV_1vvsyVuqc39vp-VFCob-IhLWUBuObhyW9b4n7xYM-f0Ht8UtmS37bB2EOdr-ueu60FToMEouHzTmsC17ysGInYnq6yTU98WZgXfCw1zhaD-RWzLTBjvDajblgeo0Bddkyhnf4k9-ULb9gA7ym9dnn2qOlhezwo76HftrB1y3tI3fNil9wB77W5FgAvfuTSTUsfJ2KIKcS8EalFb0MqO7EX1ZTu76B1yDh2fPb-1fNofoIWe1tfO4PDv-fadfc98bvf8eLm1b_rm_t5pLbb5LfG7gefNlUtulC4OdFPaAjXr4a2SFv9fFp0BuwH9NfxH89fG3vj216c2-XaSqkhf32u6mr7fd1ztfbmEbOxW-WTkYbVQ1yYqzR80dnifxULq1_nfN6Z74cjzUGTyymTKZSea8ZxGziXhSHI3RHTl5FV-pmdnAmv0Xi6KecwM59zIDH9eupbm2KBMR4_sn4Ovv2pWOvzvSKJl3JO_Uxw_UYVg835xmvZr-_ORWRrOHH6GT3wwQmMn_19spnYn35yE_agGkeh79E_OafE_Gn7ZS2CQ8_5sC8_LBQ9dENoVOI-2HfQEWrcsX_72en-vfBuUM_nn6nfd74S_EISS_xT9Aw17_S_EX8y_Nqi_fGsRYRBL4jf098dfYH7s_pL577cr6UfX6eUq_t9z04AL-Ctd__AsH6nvNd-r70z5jibX-GvlV_kfeXwzfwr7Gffr7jfSJqPwEHqMkXffLf-JbUf_cw0fw8yGfDr5g_UppSVd0xmfU4P8hdX4rf2j8W_a81y-B31W_HX7d4G39dwM36A4g38ztN_cq_y9-KhzBhQfLUz4BwqcBYGD-NjzJvIgZw_ychw8uHKTmIfe8bAzs8byLxY4KLQ8e_TFneuvH6Y2fKj4sAQP_fT4GfkEkGegzyKqfjEiBhT38efjCKfWA0j8-TsKbgzG0CoQb371Ypj-nK-vfozovr_TqWZKf0sb5U-Gft7oMe58kh1dHjZ0Z_oEWZ_JKaWTQydp_AbaafpWlaf5j-cvbt6s0bl-6f3g68vvfZyLwP5XjHcfB_Ij8H78d7yz_j1ZTDBH2X6A02vhL6q_-feV_rjzEge3_xLCP5h_yj-Q_Sv6N--Gc0a6v89Qmv-6_91-r7w2cNcBv77Bb6Zh_h8agzX8ZPjO8f9vKSaWIyyYi7vq_KaaDB9_fiZ5_Vv89vvkLiGl6c7Ah6bmwgNwWTpKdZ_0yci7NpC9a4SfQzif9y6-R2t_Db5ULpGaLT6Sfw3_VRimOycYO0V1CftGyjX2QFiuyRBk_zb8HcESdQstadB-LP79_Q72mPIX4ug8f-5_GGY9GYgkRYHf-LIgE9j_Wv56_M9-D_I2bOTfBwb_c1mRTzf65_PQIz_N39lfMwPJcXyZ9MN8drm3v4GTvv55_jV_H_Gf8BuGn6Ct_nvQAlxxe2aH52_GH5k3McXAW-gBb_u_6ad9_57_kM_3y7f84_gX-f_lUeyAZ_7R2v47-YA_63fafMOnhH_O38x_23_EP9n_0CmW_8aACf_BVMnfxdfBD93S3JcD38gEyfjU797fzT_BP8_fwRJJf9QtDu_EACiNEf7C0t1BFpNL91amz-cTB9thxAAR0wZgRxkI3RnfGk8Al06zlMBQUwhPWuvTEwxZDIAhuMzHwp_Cx8Of0foMMIhABGeBL1wH2mVZnsAwUF_XgDhfw6fNwhXqzvkcP84wUkSKX8_S2E9Si90ALAAmWMQ712_TIZ8ANt_QgDPr0_PT9VBNG_VIgxhbzQBNk8X3AcvNcpvjFRwR8gyuxUNFqhLAKdvbjIbAPEoEI0MqGe_NCAyvREgCr0rlTQjMUhW_Xf7bB9iZGoADbRzpCC9PAEhTWvVVDY71RieAJxB1wdAS2Ny1UG3Cck6nASAvtVqTB1sLBwVwUo6TaRNZA6QR9V4JykWBwD3AK0oSjovz2pkEwCznCmAVCNq7hgcWuNagIQIAWQVizhIHB45TVe_S1NFTSM4fuUkZCSgIeVXYBHlMeV9QG8cUgF8vUe6auRPXysAxFRgk3Nfc197ZCp6CYDIHmGQH6YSpwUNU3VgTVvUaRBtTm0NC04sQxDbYZ8BlyQtE64pSxIeQ-8Q9huuPV8yxFpeRdN1kyW2TBQ69UpNcYCRdxsNKYDgNRmA0DV7GS-vRs0RRnDuDEYTdQXkDYDzdQnGQAt1gHo1WMchhl-AkU8cdwKwId500yKmT5oU7Vw1MVR8uybTNjUFfnjzHE1biEhAz4DL6AkNfeYti0TXMjV1gMo1TYDQjX0AB3U8AixDUjwPOkH0Z_xnFkK8XPVF8ybHTTxs9HY8RaspqyMGEigc9W3ILT56QI8oc6B2BB6AweUtdCB4fbhR5XHlD40JtQH8Vtc0lyt3QoUbd3HXHLx6AlNYEUAaQK08ep1tbCFyR2dZQOHXa3cgvDHXO3clQMf4cTA1QMFALIc1-DWCXfRMni1AxtcfjS-AyQ1oTQyoHQs1gIBAkkCgQMmMQSgMqG0NIq8ViFhnOUQfQMsIBZsvKFEvYChlfFLIeP4IKBDApwhHz0sqOK9sFCMHGG1eMlVAlkDaiijAnCgGQO3IJkD9QK70LTxjDUcArkCMwIYoRI0YHm1A9IDUvHlA7MDFQNy8Fp9z9FNA9CoswPYnHUCCABHXSsDDQOrAq9BmQKD8QfRzQPMAS0DAj20SYI8kgmHkfQEsVB20ZmNXgOvMSDgynzieIfwi7hs-UU1BvinAnO1Nv3qfIVNJ7Qu_LJQZTWJEaaMZk0hLZxB1gHsMPmxR6FcDNwE_HxEuNr8VgIFYZTQ12FsBYEDsQNnhPTQYPCtsSxw37FdqYEwvDGLsF8CzHBX4I_AvwOwkI8DHDAscQ-wrHE4vQB5tiw2EJ9V0HnAg68DuJHzAgkC5S3PAgMDT8AQea8DdNXyEIzRCtCO0M6h49H_8UYBcND8wPs4WgPBIe-5ymAcLeidOPgzyFzQiINWQe-4mthZOXCcViDNLY0Efyw1AXWwfbGCBb3MPUFvTBCwsgMocPCBOILwgaLQ_vgZvBIEx_QPvLbQ4cCwgu4A9tAO0C9ApIKJyT09GgOXKTwDUgWa9RtBPvz-EF3g3CHu9JUFNT21BPDkE-U1PfexdIIOMPPBOtDrBPugSNloATU8n7BMgtdgC4Dsgn3c1-QMgn2lNT1yKMQQcYERaA9AjVEBHZkgXeGqADQQpQDLsRIgeo3XKR1BWiE4cF0AvILeOdyAbjBQnMwAfIK1Ja3g5ig0EaqR3EkKkbSDtqTK4SKCDsBngLOxNTy0gFJ8lQWEIPKCaAGig7iBEoPCcZKDiGVSgwvBqRQYwYUBqYUpzfyDvAFqgoNgK4CciDSBKoL7AFqCsADagnBB6oKygRqD7vQJ4anNeoP6goC9OoISg0clqoK05CaDBoIyFJqCh7G7FKYBxoOslNKD0Xm0gsLpQMhloAqkrgGoRKGBJaTAAcXlkwBKgyCB8oPD0bqC_IJSg9aC6oPbFVoFvoDWgoyl2oPReLqCZoKegtKD7oN2gp-xZoICg26CXoKmguSB3oJug56CBoK-g8uAEkw-guqDNoJHQLwB8ulAyEaCApnYAA6CjoJOgs6CDCTKgy6DgYJqg_6CwYIaggQAVoN-g1qDcYMmg76BYYO2ggmCn7D2g5GDDoL0gY6DToJswUqCCAHKg6aDfIKJgvqCSYIWgxqCfoKhggGCyYOlYCmCVoOpglGC6YLRgxmDzoMxgkdwroPZg-aCrjGpheyNJpDyKNQB1QRsgnmx581UgTU8ZaECRDWDUOF8pPWFhYLoRTU84YOnAarkSDTFsVyD2NE0Ahj0BAE1PbVUmRDQANxIYiFOAbYA9ILqnQJEFIB1gzSAzIKmgCyCqyijsTWCnaFvWF_U3EDd8SMALQHAGQOlw4IT5V89VQXdgz2CrM2FAfaCoYHF5MAU1eAKgn59lER0ghxV44PULPCV9IPWUTU89oXtCcKB1QRMgLAAWYKBgtmDeYIGguWD7sCm9RAAVI0ygvWCyuANg2GgK4Olg6uDWqVrg-yNEAAsgJ1g3CFdpJuAcoIrg4wAItwXQPpg-fX7LR-QvpFPlWbMoAHNXFTwxgAOoM6RGwhQnDuCQYKCg6yUV8TcIQqCclQeg7WCfAHFgjGDmYIOMDOCloPnsA-D0YI1AC6C-Y2VgWSBioMY8QyBH4J8AZ-Cr4JFAG-Dw_m9gkyFOzgAcdOCUn1Gg0fBAkQMgQ-CmYKNgrKCHMFbg9YNQEIFg-GDKYIn5J8sn4KhgRBDDIBUgcuDrC3GpRkRojS1XVAA3IKVg7AArgAh7duDsYLmg6yVN4OpFMLsG4OgTEdAUqSZEAFIiEKrgjeC0QC3gihDEAFcAQF8uU2JjeUB_QH4AxODuN25wAqCv4JihFpsrIJgAI2DOxUcgqnNAEILg3WC8qX1g6QU9LzLsJ8AWhHkQ_WBWABSAVgQsABIAZUABqmU6AgBuAHCAMAAVEUUAH2lkwHsAWqsUgB9pWJE0EFlgLAATEO1ASxCDaUsQgOlYkViRJxDXEPURJxDNEOn6OAA7EIcQt6ETEKSgSxDLICCQ7fF6akRgKckgkIZpBPkoYEsgcxCHEJMQ88AfaQUgexCFIECQhSBxeRMQ-wBRUDwAJxCIFF8QjxCEYAoPIpDkwHiQ2JF9EgMpfJC1ERRJJwB0AFKQhSBakOTAexD1EX1APSBLEPsARjxXACMgNpCukIZpJxDIoDaQ6JC4kShgAZDOkO6QpxDBkP6QqGB7AEGQ0NphkKmQwZD9QAyQqZC1EUVpNpDJkOcQuJEBkLcQkZDJkPaQ8ZC-kK2Q2JELQDmQ6ZCnEMWQtZCFIFWQqZD1kImQtZDtkPmQqABokPsAZMArkL2Q3pDYkV2Q9ZDjkMOQtREnEKCQhJCkkJSQwJDTEKCQuJDkwGxcV893qWpg7VtIwEsrJYA4UM6rNBFZVU1PWOCHFWAQ12C1YOblHODqgGLglkFjYIRg7wBNTxoQhIwUJDEQ2BDTYNq5dUEkELQQkdwrY3krA1EYq1ZoeTBYUDQAeAUrgDURIyAVeFUgPHB14Jxg-JwmEPIQ_7AJEF5QkhD-UOCglfFEAFYQ9hDp2m1yF-Bh4LUIPeYKfE97VHdLVQsgTeQjgBQnJ79uIFaRLqMVUxTEHeDBEMLBSyDOcGsgp8CdQWxgbFDxEJlpHODUUIIPHOD84JhgHOCJL2tgsBDm4IgQ-RD1Y0UQktVGkXGRFIBjSABhVCAOREvgEklyD3QgG4U4EE6jJOI9IBMJF5ZSSRmAVT9IUPAQjABi4Iigd3NyoKf7CFw4EFhHdAB4Rx7XMwCvvwdAWVA3fHwfdeAhEDd8HJwy0MUNavNZwEa9IiA3YzXgItCq0IrlHjtnwgvHStC672vHBQ8ZVl9AJtCCgGJYSOlaQQE-HaFwwwthXgAuVF4AZwAUYFYEWaApGHkAJ4AyJw9HdtDdx0FAOMo6QJ7Qj7B6hEvHSVgUPk3QpdD1wDjKJNZ8xzMLZYc85XRHTEcpJxxHEmB80L-EUeCwiDmoalVp3Xig-r0MsDJ3WuMX0MC4O5BefSwXC9DsDyzARQ9kUHF9AlQ8CASwX2B8kRacOXRdQDBkcMxJ1SIAAgAAm3I9M3BvJF2kBScDhjUnLdsXKh2tabAAwVXdfa0GaCYoczAugHIOchwEwPXfYuBYYg_LB2ApEHERUcM3yHlAKXYM7WZiAjDpw2Iw4sYKMKow24AaMOhtFd4YokzDR1Z5QDYw6jDmMPOeNSxA1mu8cr9GyCYwztYbbVXdIigmMJ9WWhJ-TFkwkDBCMK1EEmBuQiF8doB9uDx0eYQDhgW8RMJ4sDQw3jDlMKEwtdQaMMpnJ8AkoAFDfoAhQymgeYRigFFDLoAjgA70K3ZkynEwxkdjMKIwkmABJGdAZxM6hzV-AVgtsHxWO7t5cBUwrvRvw1xWAlBzMBgDKo92-EuDZ_BxlASwULDUQG_DWBhIsJAwaLC17TiwpTAEsKYwzzDuZCG0eBhuKHpITvhssMlA8LAMsLb4BUNDwSgWZ6QDfX5wK4gmVFyw1TDqhgTzdmdIGHMwP9AWsMxA8zcEMJ1iRLCTMI82WlN_SiNaPeYmdEsAHGRMCQ1eNuATuAFVBxV1eBwUPIA5anY2Z1554FOAPxltSEmwokBpsNRWK-RTeDv6TwFLAHGwrXU7AD2w3bEkCnAxEnAgQDM2QTBG4G5XV_p1VmtAHeoksK72EnAByWkAR5UMImRwASAJqAUrGSBJAHq4SQAFkSexATCOMKEwwXdpsDokI4Bw3hmwtLC2kGew22RfSlGgBml2CDkIWwBefFBTfoBBGDBQPLCksRAoDN1w2j3NbbCOG2DTSTCWVllsRcBC7yyYVK8WPUawjzDVMLBQbRFKOS6w5HN2Z0hwzXdCwFhw7HD6cO8wpYl6SGCYKeRyclokKBYecMo5V0M6cLCwkXDdE1rANnDHBCtQUsc2-CtQMsYfMIjTIvpHDQG6FuVia2Zw2-hkx3X0BcBkrWS-F6c8cJV8JUMoFlC6RyIbbXfQnkR2aAm9fFZpYF9beABlcPy_d98Dcj0gGMYnlznNBOh5cFAwoZwIMKgw88B8MOMw2hxNKjHNSmglalxWCUNXDnMwYIZGs3nSGaBW4GxzFGgsiisHINCSemiAPisPcJgNNgRI8JAwM3DAFBjwn6IfBGCw4m0yfj9JC2g9cJeuCZBlhllw91BnkhoAXWlIwBigQ9ttYlqw23AWRTSgDXDwAj7Hc_o1cNcCZK0nvVHUFvCDcMBtOMCWcPtFChRB8Lr2cCRwDnEDCJwK8LSgWIdt1jRuS3D4WBtwhnw7cOybB3DecLffAmIW8Ke9RWRy8P7w9gQJ8MgmF6cYxgDIFvDCxkNwzWcFN3Lw5L4hoki2Pk9Ju36-Tpo2cK6ELgBvPCq8LSR38Nq8Y_CcLmw2dbc38PQAP2c3ei-UV_C30Hr4W_C69nvwxVd38IwRLoQllG88QAjZxxT_SAjIJnvwivZFVyOEdhhu_C6EE0Ipin_gP2M0oEtwi-ANkE1qKXhMCIvgEQ47bngIx15fy1owOzArLygaSn15qwYIlHsgymYItK0tJDL6Ik4aCJILOgi9I151fTDDl1bwwoUrCEYI5GcOCPMAVgjX93YIhVROCJoIh6h2BHgIp703MOoI5gi-COwPJ-gEGlPCJgiFVHGraQjO0l_2GgiZh2MInwA95l4IzydHEAEIs4UqcGRXEQiVMAMIoIoJCL0Iw-DtCNG7Cm1mCJMIzwifACUIyn0VCKFSBvUL8ORSYIAl-i4I2BA_Y3OXD-kbG17w-wjYPFCI3_CSE3y3XUZV6m3yMAcM4POoF0AL5imAPSBqYX5wpqCHMANEMvDZ8MPw01AW5SGoVzRZ8KHw8wB1a1dwwqAaiObw1AjpwCnw8_9CPhZuBIjOEnhAMqsEcy-0QsZcQC1gckMYiLvwicJ9ABxBMQjU7QxnPojOIAaocvC_0EUzT9Bf9mGIroiYoXaI3HEZJxxBaw4xGE_EadA_exG6D0MEo1HNU5Y7wnDwrPCEowSwaPDoIjjw4phNMAmgBkA5gA1AabMclkWItAhtAT-oTojniLpwCPDTiK6DN4jRiPzwgWJ4IGUYHBA8IF3OH4jcSknAUYBJiLL2UjZJiJwAYLDmgxEFGm0Rik7cTmcKr3LeKTAN7SeWRPRSc3J6cfcWbj3NcvDL8OHwr5QW8J7WP6YuMPzvHrDFeTQERoj6ElBItIMeiIhImkAGMKgwNnDBW1mMd3ZItU6aarxd8Lbwo_CCSOCI8wBbj0d6IIj2bGAI3chWSJ0weTcwYhfw03C30G_wto8v8KAIn_CaSKpndHgACLlIoAiyj2pPWUi43EGIqAjsNhgIoAiVtTZw6SQo-iVgK1AKCIIIrYB2yG5wFGAKiL7wlkUsBhwbUpRCxkwIqXhu_GkkGo0D8N5IsGd8CKrgCIi_WQCIuxQySH5I_SQySMLGfFMrjXVeN0jsCImCUYAc9zkGUMj5SIrySoioCPceG0h8e3Lw0ki0dmWgLT8__Thw-AAycLZIo98eMMlwTMjZ8JrhLKArjlfPe0VLJkTI1Mi0CKeI0YiFPQmIpkiAix1IrZtwoghw4XDLXlLXdRRu8J91FMiHSNEIvkiGyJwucyhi61DI0_DJlFK8MAiFECVIhUikCOVIsciCkjVIx3okCK1IurA5yIgIlcjVSNnQQ0j6twb1KzNOyNbHa9h4gGEI8IjrSPhYflANIyv0RnCzhm3w83JvSMKFffDiiN5IsIirSNuUORla6xVIgGcqIhTKHkiRyKHIivC-5HMIyn1LyK_IsVEjyP1eIVt4CPdI5nh9G0A_Pjc6sHLI5K1syJ_4XMilMILIqTCOW1OgYvDo4hRImG0GT3_bZ8Jv0NrWS9CVIMgvKB9oLxWYa9DbPQBEEqRxbzKkHIRHug1vDIAMhFNQHAlyQggQI-xNgCiAfDRfnATtY7gfuDO4HAB_uB24CcwQeAb8cHgHiyh4fQBmSNwbeFRi32oAQs8AmF7I2hJdASUonyEAyGZYTFoiWF69HiiBFCiASTx1XnCkUwF5hCl4E4Z8ykZbJQNGTyFrFgCR3B4HK2A2KM9YXYQVIO8AgEAlILFIOijggOJgCV8yzRegV0BAvW-HFBA95iK4PSoVuACnIER6TFJJOr1RbxVvOCBXPRYo72NWWkpAW30hAFlNLOBSgRC9E4dqTBvXSgBXhxDjRoEw40agiONzO3fYWqtAG0pEKtttokkkN1ga2znkV6Bs2zF4IdtZgFebCRAu22aVaste2xrjMQErS1BHNaJqgLcIVRVcFXI7VdF8vgsAEMslbl4VOGREQSu4UT1-Hyu4CRU4VRy-N0sOqK4VOOYNFS0VHRU9FWyRdYBVFTGoyjsxqJflVdwHVWsVL-Uf5XWogpVp5mR0cmJYZHC4MpVDtyMfOQF85Wzjer1wATBcKUxwAUoBW4h2vFIBDmQRRnGQD01X5FOWBZFATxCzJrRbuSLtM_h7rRY4WSEQgS4VQ6jH5WOo0dVTqKsVKRBP5VsVT7kG7mJIE8dT-BbodtAGk0RhO08ggBl0aacT-lIwde5JXxggRsJNRghozEYauT5QY1UqaOy5WeDU_B1EO_4OMAvwCFUfEHGVXpNKaI_6ahVV0C1gV-AZoEbCO_5FpwN5Y1UiuC2oD8hYNn1dZoB5RDtHSnxREhGqBxUWXGNUAfhjVX8rab07s3_4Qmi9kC93WFA7T2GwNWBTiDZdJwATMAhOM2ArNijKJhcUS2NVDupYELvCTTBwlF6zLYBY-CWzR6F-rlHkO6ZlEDEQel1lgwn5T-BOcAEAHDdgzVuAKABz0Bm4IrgMViPAE8B_gMvAOttH9ncAOiRsIBAqSOj7ADgw5_xyQGjotOj2yFt9dtAnwChgcq0lAnHQJpRBCngVPeZUazVQWst6Zl9MEjE12Fzo1Oj_AHpqcHMJunLothciTjro1dwA4GBrHuisXADgesthPH7o6Mt66IZLTkAWsH-AJOwVMECATpNicwcVN0B2GB1OTOiW6LaQIQMO6PYYSGg95k6o8Mt1n1rLUdRd6NTLedVoy2yPFo8Oa2LbIsgC4Ivo2tsS2wG6I-juqJPo_UBqvCLbW-j9AE3ItVAAXhCzCuiNUJvoxqjXQHYEV-j_6LTdCbVEgHw9QQpkgHYEIOUbXn4oQpYz4jKUWDxvPGgY0X4c4RYAK-jM6Lgwj4BY-AiXeIABVEZoxv1psCXsabAwGMzQcxwQlT3mGhUcN26wIhjysBIYvl5CoQn5SUCgPzubIBis22rbdFgGqKghDUCAmDViZK50Gxqo3hjh-A9bBLMoaNXwKjI1oks4GYBvaQgRRmIrHh4YjwA8jEEKcBto21aomYBXm1bbdgQuaUinNXgYG3IGURiSYHEY7oRJGKzrJYAtW0ARQ1tFGP2kfVtCZ1NbSxirohNbCBE7GPNbb55mZ2MIDBjcAAgUNIJUGJknfsRc6MwYiBRmA09QA3I2Pm_othc2Mk7oyMR5XVZo-BjawB8Izeif6NHUOMspMGuoQhdRCLnorpNzADFVBLdfGKjozBjAgFkgWdwiyncYnkRyAEjAOUdwGOy0YBV06TFVPeYOPD0qcdQuehyYrOiPGImoNIIZGM_EJpj_GImoeTJnUi2wBIARaKGqdhpYmPTnHiwt6NowCNROmNwAfJi0AEKY-bBimOVgUpjymNIYycByGMQFRvCDchqYvn0e6HqYtlM5mL8YlpiEgDaYwRiT-k3KfZimcguGPZjcmKmY7HFcNEywIpizmIWYspilgDoYoD4q6MQFcXkkUPhQok46mIKRXZjJmLXwJuAkeA5sSpV_mK65I5jEGwkYUFiV-UhMcLBWFFXomOjtJ0_QlhhpMD8AuoDFSAF9OwB8EmvuECAMqNkAvgDXNhiooMBjNnI-MXgq_RiYU314mCIwVD5NfWzQopjzMGKICDBYhkJY3K4beTJjGV9jOAoYRUd6_XN9YDDNfXKAYHleSgWDY30a_QmoZgMBwl2oE4hkEjEQPDRqWJ5IXiD2IKEsXv09ADEQJwxBIJfdOpJpWKSwKXNCwFzoHkhtWLgoDViuQhtwSHNXl11YsSgTWOfpICdVfE19MiwPUH8RKVijWKswP2gqA37CTVjFcAtY0fAJ_VDIN2BaWJPXSgM1-WoDanMvg3NYoVVEAwswGKjtrXnXBoAcAExQUuVH-BKoOQMIXyGnIwYnaGuSZDg1fQKwLOwKiHHQDYQi2TJjMNjQGEEKVrAYqLBQRDpc9g19HPC16LFwgXAS2LQQMNiafHzonQRyeE60BHRhEJNQwFJ62JjDRZRtZ3jweG05CAbY_wArKlQYDK5OcNbsUklYCB4FHw1p60LjA2j5yirYhGw_aNnYissuFVGo--UdTCWAKaiOHxmo_hV5qNFAOZjzMDfwf2jC3QrWKNicACPYoW1BYDzo_wBVWBnYgOiugCvYwNdCiCiwuEhwMBHYjDDT2JwDJhA6WIV9JWA0gHMQLsBdsDagOQhuiFfYlXCn2MCwEtjgEGSjf9irg3_9JehXcAWDQTMu9CEAQVjZWJrYy6hF2HvhQVi1zUkxJCw-aHtYgaggWP9sX7MpDTqnXljjMLLYqxiB_QEgjUAiOO9yAag-kCPwBYMYEiTiUe0_pGH4FgAiAB-eUwhzX1A45VctcK7whjN1Bx1XA2h0sJIdMYsjHRDzKXDdumgDF9jf2N-wQZE_AGRfYTj4HXmgTdiJHy2opdU_eF2ovvQ-D2UDKqw2gCygRxYxg23dQitnd34dCIA24A-2DO4QAOWSBLAP7gULVj1RGCs403NNyEg2fQBDt3g9E8BLOIEUKIsJrRknNldhg2OeLhBf5HaDUzj5rns4_h5HOLddX9CCAE84mLiAuIWDBziNiyeYloAc8x5qaABSqFGqJV0zkGc4fc5eFDtCACNRKHkIOYCMCAnnW_d82moUR0NKDEPbATi4P3z2Mahg2JwAAAN20H6CYzJ67Qq0IkYPSLFzfnMJcwPvUGA5R15GCj1Hwl8jCvQbA30OCyMriFUY-YAxuIsjFfMXiGm47IAvISisUwpl-lX6Ovpt6FBwRbjZuJ-sWrws8wLecrBtuOW4-OgRmMnbVEjRfn23MbdYj3hXE7ceiheHGuw01CO4jrig7WCMOGAo03NsGE9njxINV48Z7HePDHgb5UKVW6iSlQeo92BylQ6rMWg_TwKIMNigsGogvbM5vktheiEfrC3xUbjjuKTQNXBa7Vz9c9dMeP_XGG5PuMRAM49gT1-4y489CjqDL8h4IJqAIHVEOPg40YMMw2K47ohrIByVSTj5I199Xjj5OPgqVLAK6EMbTYMkA3p4lPQ0AGEgfU8vWPWAT4lz9HntPnihfHI49ejxOMZ40s9CKNk4611xeKjwOsCfV2oMHDjeeMwAfnjaACkY7jiyqCl4hXiNeMIsWsCUwP4461ixOP14qlcleON4iSAyxyOEUYAiynz1U3d6eFUFFWoz-Bt43V1zoCnuM3jVkAZ4i3ijeK7A9UCOqzJpItctMA546tjWeLdCdnilOOBrbOt5eNWQUDjI-OHWPeZO9EvAWYAVaiuIeIBQ-L8WVIcbvUU4_YCgAPlwdXiCgEk4tlM7OOfY8Eh4-Iz4pTiNQg54lHN3y0_LUm5-FC7YgQBZoGF4koDBKGxGKe1mnnO_ZcDLvy3A6miLXz9Yjms0oDkTHR9e5jdLYPiKqHGQDEYrsnkgN2BR-JXmN2A2Rin-DNioMBX-ZOU5RCpEaTAlqNhVKRVVqPkVXh15Zym_UfBT90iPQwMoME74nZ5bXX9AhcDc3klEK_j9n2nAqJ4QClftKJ56rTBPD6AL-Kf4yp9i3l6-SINAbhSKOjJ--Lvif_5_4nE_T_it6AXCG3xr-JCNKfjhtimfXyhYBLxGJ3gPCklEQSIKqBP4o_jSjRCeE-037UvKGN4-zh5DDTkwYlHqLZsepWj3MPcu7j73JtxO8AXWU34lXjmbDcCAlDumR3147wAE8y4e5AStSrjj9lqfFcDKBP-UaATBKEQE_YD4BJaoIQSpNTYEgL0BBKPwDAT20XGNJL4iBNKUS_d6JDNGcgT6CB4E3vi7piWUbGk-dW6wSPYMQICvHkMEBMQQZDVz-N8oWx5eHWDIMwlEOiqwzPJpsGMTD_ibQ05A8niC1kMEuCCoIMTXbrBwBJiVKQSZDTu-DQSqni0-W4hQrE_A4CDXwPMcX8DQhO_A0_pR2OO0VgMSONxDTX19ODEQfoJKIDHYoljkgCa4le8p2KQMK0DHZ20-cCDS3WQcYI810PcEuUtMHlF-FxQcGMho_BjmnXr4N-QwaKqEvBi0GLkaK_xolyuILwTiWAq-WPNueNEYWBJTLlWQU9AiAFTQUFhsBjaw2rVH-IgE7_iy4iM-ew0UpjzeHrZTeKQDUjwxeIN4-3jiuMLYo4AWeI2E5LAscO2EwxQzwBdWdtI3CP0HQG4F0DD4vYSKlAOErXwYdWBtDdAlSEDKTUtxynq4mvgRBJgE4wSUnnQE7P4muOWxdk8WqGxGHwSsBK74gESZqDqfLu5PBO1OXT59BNwYT0MZACuNHsNwwxWDcbV8yI8jFAN4wyiiN8YfsEBgRTxvQXlANtio7GD4YsNguMtwL8NkwxcUELjrvSpwAqwrOKjwEkSDOOpE8_QmwxB1NITSNRmE7qANI0YAAKjyYCAiVyNtTj5LZXs7xyuURgBwAQoNVKMbolM-MyNf3zW9RBAJRPOEXJ4pRK6UPP4_SBRgGUSSOOqgTsMKDWlA7AAgw1yEtQAVROCPaqBgjxVEw9jZ2K_DY0S72IpE6ZYhABEAUDivwxA4-TiVRMqEmrlcGP0Y5mRqoEdEiGimhJknZmQVRM9SLrdZwFdE4AAaOBVEgahz7DW9EISZ7FMcbIBgxIloBhxqoCAgiMSrHAlEgmB50n5QViNdwx_Yt0I3-KIjcqNhRISjCwBUoyNFab8PqTzEkhRDIyMEsBAIOhVEhx4yxJaoWx5oxI-oNUSJaBVEzUSfkRbEvUSbQK1E4ABDRIoNM0T4glNE29j4ghVEq0SraDSAW0S5OLdCB0StYEaEl0TqsDdEqcSnROqE5oTmnR9EuRQ_RJSAAMSeYFSbRtJC-XnvKJBJ0HVBPGAKDRDE4uwwxOfAyISoxKPEmMSj8DjEiISExNfApMTqo1qjedJ0xPLGDK5cI1vIzSNAaOLyEsTFCEXDVpB6xI9QRsSPqBVEstBHEUxgZsSSwLUAbUT-wOwAdsT0AC88A0SOxMsRCg00wI4-cCCaxNKA5wS4ACHEl8AbRJfE23g0gAfEgiJBwykATkT9AFgjJ8SCsA8YAxh4SK1QswAvKKqUUaNEfQPAiUE_7w0kU8ClgPX1W-8gF27Q0oSKeOpjNiRMJL4kjwFuJMq-WCCQjRm_JGMVmCtqQSTbvlBE56RNo3yMIDBbAVEkiRBYeIfGcp9XoyxvdYB5WObsHcC6bzNQv8D4RHHEf-8JO1vEl-wrHGAfA9AGJKIMJISpYGYkqaMPUEUk0QDdxJRYn-QqvUPiM9sz0MtwnyjqAL3mO9CIiAZQR9DuVjZwsgi5NzcIAJMaABV4AL45GSuASKSCABV4GpsbwEBodxVzTT1MP1F7wQrQeFh5IDgXQ6YaRjPAbnAxO1onOagVeBpGcuU5cDpGAgB4pNKk_dAJEGFkaKSpSFik-XoEpKSklKSgE08VKHRXYEyk1cBspPlAXKSBWHykscBCpPlAM8BqpLKkoaSKpMwnEqSKqhi0eKSlaRik_cThsDmoJWlWpNSkjqSMpOwvAIcBWBykyOsxZxfgQaT0ziXQP6IqpOWkoyBxpMOk-SAppJoAJWkZpLqk66SjIAWkkuDmpJWkgVgcAGSktaT0pK6kzaTWcG2kvqTdpPgXAaSK0AKkiqTBfAIAG6SDeAmko6S7YjBks6TapLYfOahdaUekiKB4pL2kgR53pPakz6Tqyyyk36T2gH6k9mgDpOGk46SUZKhgc6TCZKukoqcSZLhkmsBhZERkxqTFpJpkgGSp93RkjxVMZO6kraT2aB2kuadGZP2koGTIZKKkl1QKZNJkyaStNF1pW6T1gDgXJGSrgDxktPdmZLSkuGQNpNuBH6SOZL-krmS8pN5ki6SRpNBNf6ShZKhkrWSuZLFkmsBCp2oPSWTZp2iAag9VpIxk-WSvpMVk2sBepNxkyOtzZMBk8gY-ZM1knnwHZL0gHWTLpL1ks2SPZKpkg9A2cNy3CzhPxGGCAVhV8MEKCQC0QHSeRmhxMEmVMABY5LD6E8RTMDY8Y4TsZ29QNbo7WAjXCOI5Bkj6PNNAV130VocTOlMwQLD9tVzk71Bi5JzkgI9ramDIWcioFgt6SuT2j0X8IZoQCJ5zUIAwAG68XJZ9tXYEcuTd9GSKNEAPnWVgRwBMABkwM1APuHWULABYaFsTNnDzxBDk63DW5IZ8JdQ_eztYKOSrNTxwKeS9cOrYl55k5KsvPAh05L7kmMDC5KdvcboU5IatSuSC5ODIVkjC6g18aqSOcC08b_8rwOAEIagw-nWAQOS4-AkYGeSX4DDksBgl5MrkqzUTKOT5BltvSDnkn5Z_ZKgWFfCgFPAQTYi-GJo-Zp9VWFbkrj5sFB2iZ5hZQEewAQBB5N-wb9xycLssK-SSpIPPQLCKUzZw_yBNDGgU0rQIKMQrYMQktABOWABxMFzsVeTQFKDnFypDpk_ksrR_SOtIuRkq0CEvc0j3UBZQAVhOQFs3T8i11FtI72k7LXULIlBqFPcARw9sFDAU23DIFOH4a8jw9DZw99CWY2LgVCAAvjCk7sQ1FKI-TWpepKNBFylsTB2AVlsfcHWAKRS18JkUsoxjFLfgUxSaJC1YN-TcwlDk8BSh_BsUxhTwFIkQF-SdonfkxIBP5OR46GE3FNsU2eT8VhWkGuSjgB2xB6hiCOUUpHANFNoUqHDCCIrWDfgwlITgDRSvbGwI-1AIiJ2xTBxNYRrAUJT5gFIIxIB4WCmCCIj4WGSKP2M-f2Z7d9CVIK-olvYggMvVez0x4C1AImRnPUSoiW9kqLvgH79Bpj-_XTt6vTCouwAIqKiolz0S2Lioozg4V1M0SuxuUiKoj6hOTEDjUqivhwyAozh8Oy_ldbhvTGI7DL0h_lZaKDs5lNesIjsfeCWU0js8vROcH3wBZEWPY_cLDzUPSjoXpje_QjoGARfYt4A_qNrjBTRnACuU6Io_FRROI-pjoD6eASsWQFhiQZT0NGGUiv89gFMLOkxIbGlo2CRr0Q4gBntdZxA2VahogF7sUN5jK0SgK6h9AFroDOVHxEqVQPijFQ7zGuwhlMnsUKA_wDP4IRcRMGDNMABvPDsAcusiAHDoPeYfCJEwUGA9IGzEPeZIGIpUs2UkzQBeIlSgNHTEalSWgFHUElSdaSubPrYCVPHUOS144l59D6iMWNsuLUAe0D1qcWBaeGr9WJhKWJsEq31fWMrTSVSuWNQABv0qWO90PljkOMoAbDjYew5Yk309iCQsGVTNfUngcEYYWMUaBVTRWK2AcVjstTuAB1iZWN6HA2x20BhId0SKiE9E6GizWJK4x1TnRJqE5mQehPlkdEByaHFwNcSJNHiIR1i28nnEj0SZxJ4NcCdFsB9YvGibBLVQAb1c4nBI60T5OM4GUNSnVPDU-eJfRLQ3CRhJ3Ca4-b1wOJdIe5Sncg5IkLCs1IKAQ4JysFS-OvZf8ErUtAjV5RuoJ21F_igIutS5wGvtZ1gA1J7qMNifVPuUdtTKoDkIZtTxUgtyTtTE_V9UvAB_VNLU_0TqsCkIVNSPVKXEr1S3GPpY-TjI2Mio0VSdfS_YqyphxIr4gDi-2OHY50jwsC7U8mge1Kv8OrJZlJg7OcxFlO0VVdwxKLDEFDsdeOYUmGJmgGEyFO1kYh6EpJJu1PHU9cSV_BPU-ZS4Oy2Uq5wHgkyOSgAUkDhAc9AtYGWgSPZpi2RE19SD1PfUmTIp8ntFK3191LwAQ9SJLnnfBYNENLHUxDoy1MnU91TFxK9E8mo0OPpIEdSMNMlGCdT4PDnHadTcNOho_d0ruxWUgjt1lLPUzZSL1PnCJGiQ1GflOHRcHS_U-jSFlMY0-mYe0AaABjtXYDDYz4lh1LfUzDTSNL4_Pz9EOMQ05DSH4nS4u7MkOxQ7Act7lAa9ebI7iL9BFF8swFBoMQ1RfjiAPjB0AGI09Ddy1Pcw70gR1OQ012gv1I2UkjsrnCvU5Ds_eBKYBLAoNNHUzGAzNKVBfoJSEnYnBzTTNJg07FQlCOZ9fTTnNO80uDSdYnc0wHJE6CYwsTSP1MqgAuIR8O1wgtjAtIk083cQtLUAQ64O5E5VOQgUlF3UIh4MtP5E7LJC1MWUARAZNPnffrCItOZkAuIHG16wswlcoHeGWNT89h3-Fntz2POdXxRc1NiEs_iylHl-Wyx8_i8-AJ0vKAkefLJutIjAtrSQ_k4OV2g2Z1jAqIMMxL_Y9S4S-Ns4ue8d1Md-G205eIXUiPjK-P2AqhQxeWyE7LNU3l0_ArNkHAWCEdszXi6UeUQlHgSAV5tM2hyXM595DyzEjoJcnkzkurB8gjcPedJSMAbRbUQiQDrdQj5YFQ6NE1QH-DYwPRocUkYWZbCbPGZ8B08gIjxLcBRR6kxGGooBVyBI-4jVl3BWEwpeQwS_LQ9srWe07oSEv2UHfDR9cJFCAJ1AwgUgXxtMdNRwSxSR-HGUMGA9tI0bSEotG2zqUZMbs0SAMGj0AFO0gj9TTnS0vLSm5HldFwJsuK1ECl5KaFdEXPRjtKgAenSt3i2OU7THE0Q6MP9wn1p007TRm05I-bdzeh6aJ3pfRFO07o9NyOYYm21FqFO04fpw2lV0rURhdJwuPv8_mBQbQf9s-ODIu8IWQA18JWiQrUY4I7Jxe1lINVSsOLuUjwBLziKIZnSjMnlEK5tyayDfNyoFfSd00GAXdPCqEvcEyLdTO1wkgHF0rUQ__wbbZ11DdJQo6-xmaHeUtTwtRFWgT2iUlCt0iTDPdPt0x04XdLD4hdE7pDeAVYQb2OcTWdjPSFLYkjTItIS095JhGKKZdwh6WK90l3SJrT8DZwBiaMlY-b8KFE10tDMs1MR1EvD5jlnfUxp7jl92TX0wMCd0uvTvaJOINUYFJ2MmCfV5Tz_WO89bHkn1OY9YKDVwUnS-vnmfKypm9LO01vTr0yibLNS-Qkd01PSuvHX0xDpNyHlDXzco1L707fThkAH06GEh9INcQVYeYBSeY4RzBN3Ekdt53FtU53ccjVyvBu989hbEqzVjUjs0OrTjxKtsGXM8IAYcBITvg1voHI9hNzyPLzxqvDAM4o8kJMgMurcldPXNcvd--jd3M3dDyLxIjE8ppw7aXUYcj1WUdNdvZwJPY8Ba926PL2d18G23MUid31g8I7SbSFBwPP4gwLoIGzAHHhs4-QSbbXn01QipdMtdIGxZdMgAWrxb9NyeQo8ej3YIxrVwdMNtLfdWDxW1UHADlOWPWx51j2m2MQRbD23-EgSCxFZDCY55m2skfABKSLRrMmtXxhYRMsio9JR8Z7SPAVDgaAAhCKWbY-TCIkaPdQz2WK-ffMAuvTuPCpU9GgYVKhg3-iJHWkAv-hCzNiANUBPFDMipMDhXPhC7AH1QoOAlIE0wbGB4YCWw_VFeWnzAeydNMEwAYZEm4FKoQ48dRDQVH3EhADslaZ4K_mLod7MXDNn1EvNzADsiPXw8rjnNG6gOMBdzJlVncky3TV08c3jQSloVXQR3fIzdgA4wC0BJABa8HQy8XQuAHWEqjKdAZzgJwGeLEjjungSTVOQfoKiMA0RWF1tosgppInZoiDZA9LXHHxhuYXQKH6D1aDixDIzP-iyMtwyJ1lg8Q49zsl73D9d3tyEI3_SpgAijbqBDjwG6XYzCIk2ocFdK6HuLUGF9YV2MklpBXnJaBgIj_TsAfgA0FSfsOmFFjKzY4vMVjKoiQ49QiOCM1GtTxhBeGjiY9GLsWrwIBgOMs4y7TivEz1iRIkOPC0AJIF-M7QykTwNRV8Dxt0OPPeYIeIfsREzIePhXfAyQykvXX7c0TL9oSHj5Rlgw7zwwg2GU_OB-TG7sSFT6TFIONVABuOeY0Hxs8DJMu-QjqxYOO48MVK3oLFTDjhewKxxPOKxMp3wSTJBqPvRPlLcgb5S01CxMvkyrHCvXbyA4MOCOUHB9jw9dUEy2C1q8fVjEmKVM749FTN_wCE8SONhIanMI1AO4xjCU9IQIb3TGQE83HjN69L8wD8SaGJ-iMSSrlBr3cjd8ghb3HpJft2TwftSWqi3E6hIN_hb3eBVHTN73AAUXTJLUkrT3TPecWFF_yNYM4a92WMz03FRs9MQQXPSuDnNEg-Ui9NK0-xIUGxKdEQxmdLbWW5TmdOtOXsSFnSOvIMyotN7iDfi-vk800TSkzNQ8UaALNIY0qzS7BAw7fOpzwBhkJhj5cAnY37At1KA47LSTqnk4nsCjsmRqSMz-WJQ4mwSTTjS0rfTMtIKdK31-zI1Uu3TrfCywwkB16Dm0iczeSkygMH1qn24Y02AN1MXU5rS4JQyYXCS2eJMuQDi71x3UxDiFzKnM2MyOzO79TtTdzMtufczHwDPM0houzK7aZnTMOIFY41SNJ2sE3rYXNWgte-twAQR9GEQUtkQQZySV-B3Mt0IALMck5XgEpAvvB3sYJPCLNiTaRAkQYI9gH1lErfcBJJd7eMz4ghAstzAKNOdUloTibyEkLiRZFDbU-LScLNmYGST0EI-oc-wELJI4hhwrJMafZntcxLPbAGjfqMYUXyTR4Jmg7pTwcPq9aYQ-lKGo6pS4IHHgOpTGKJc9RpTQREFMEUzvlLeHYqiPh0mUvrjplJC4aTozFU24bzIsXDOojGibFR_lLON7TCRY9VYvxJMKIVShfTFU2RZJVIpYnliCNOjUoDihWLFU030qLH1U__1DVOq0xDjfWPeDPN8gLIyuTcz9yXzUgiSbbWNKU9i8GNSwMpFv2NfE_8Ab7DmNEt4zLWcs1sze2KA4w8yjfTg-ayyArJr05WAXzOF42yyRgBq0l4Shhno3KOTrQPgklMykILQkwkDXLKJyetiYrI6GK_YW-HTI23839Jr4e3B9UH1QPaQLtNQk00twINdoEjCoMHmgS7s6sCjJK5RJqxPPD_TMBLJAmgAMHmFzf2IvwQ3PYI9u-KEksCDE1w3IUVshSXmae3BAwLHgoJJarNowSHBqrNQAZays0GzEIag1rI2s8OhWCh2s9bRaMAUvG81b6D4CSrxzMzffQKSoiDtERIhYjJ-AC0Bb_hVqC0BIcMKs-ZoqtJGATPdZwHsAUhEMeEETUEEPVHksixU0aMtBc6isaJLyQbdvrJ3SKoQQlR6VUdQalzlAJM45LLi4BSzLFRBslSyLqLsVDttEBXZpN6zwRjrDFSZFrMTIAJ1VrI9YZChcKCcNX_B5rPXIVGAnDTcY9SYu9IzvCsolqk5wwTMZRksMUfSt73cGCfSU_0gk9pJJcDGskMZwRk-slIBIbPTSHnVItQhsn6ykjzzBNaIrgGKAfxtpjVf1YUBQMDeAO1gs6ykYBY08ISbgeWodgGEUDYR79S1s4YRqEiY7Ku9MP00YH9ZkaAqoRazmLjr4NlZ0Cn6VFSMUXifndAo0KGvmFm53rPxsgyYROLxSEZjxzLZsnYBD70QyMfTsjWumGL5ebPCLBqyBrIKEmRwqIngsvqynQIKEuIsZxiFsyWyobMKqVOyxbOlsscJZbL8bLABZ-XzsyyBTjSSIHWydXVnEBxURjSbgbcT1-NM_CtMYGKHNdZMPwE1PPHsC5wsAPeYgQxGAK0RdXhNdOvg_lFiM9gRXlkAwQk5W7L4XOUAK5zr4LVVlVAeoaYRV51vWGaACXkp3GuACmEAXTHxB7JHswK4swGjHKJg5hmELHg5boGSnGejcfFAXVx9fn1QwEcA95RRyGSxKrjLzUYjFjNEwOzQ7_n2oSOwNGiJzWKsWTgTAfez3rOFs0WyxIBbCFl1zqHes4rg7kR6AH6y_5FAEd-y17OTJb-z4ACSPFZjAl0WM5MlgHKhs8ByPKxPbWsB97OLs0lpS7MbQZByxliSIRtIcHPhWOFd1ZwPs2eARwAp8IE4X-kcM3axd5w8M2IyCXl-M09ZECkkQXQBL5Brsc6hv1iY49-zuVgsAVmytRjoGKbRQ7P56KCz50CQkitBP7Izs8u5KrTuRKBzobJINVwwQph76bWzMHL1s4UFK7M9M0Rwa7GIc9NdajEcs-ISCrKjUWDxSz3w5LrgHiHukL15g-IeIH-wVuAsclUgf7EBoORjEHPTSENcunXCLd3sCsDTEBmxVCHsUWIzgMF1s1FYFamBUxupZIgAca-RXIGRAc1ctKwrYuKykiAk0DBzXcBUcjisKFKNsrNIrKlS2HBBw2CyAV4cpOKh46vdz6LAM4wwoLNgMlAzavBKPQbphJ2bk6_8KjyQMqvc0DLU3QqBzDJyc3MRz6LrkxXdSzxr3aPduj1q8EgzOAHgM3Oog3HpGRi0W9yH3KgiPoFQADIcG9TRUg7ccTNr3f3pR1CIclkV5RihPDYyCDIj3EZyJtXpMloAPt3RUr5TJ7A0jS7j7jwJMu-xj7Gu44GhDnKAcY-xsaTJMhkwKTM0pbexkCKpwOUzTMFMcgZylSG9cAZzCIjm00m5qrDlHEg4G9VIwLZM9sFUwAABeu48fRGi9c1VuFnnolJgW82ReGPh2HgROVud7YS15KgynnNscs4zIcG6bB-ozjP3WNFyDt0KgYqAgkROM7wzNHLbwo6tTCgW6XF5ydntECjBJ31mGf2ysWnx-YSlz7T68eZzRCKOrBT8QyNYeNTB-V32oUap3rOQmbeoRqlkwRfx_tOe2AuAgIlbgXa9MnLYc_hMBIlIOYugXAmBoH4s9USiuOvhBlC1gKUANXULAWhzXiWJyULsyxySIOxztx1xc1lc4bKhPHFyjiDscnWtHFSoiTahNgD_sxQh7sPf6HVyBpjlAPP1zqGL9bOyuQTDuLvRpYCEcP7dsXPm2KxyQTPlcmfNwV20WVlyVMGBrBhyJ80hgcblDrz1cmvgP12M4yNyHcWgo4ocpgAqVZVzqFMKM6ZUkXN1cjwia-GiAA1ym4DIEYNz1Bh9crx5KAH9c-aAP13VkLfFwVyjwUNyM3PYALNyjtVI8fKc83IAtAtzSlDv8HUB83Lj4XfRy3KhoKRw_XOdUPvNG3Mj6BtyDtzIEUNy6TKwAATVEgBpswDdaeh2cyD0HYmLcgdyy3LOMs5ygkEh46zh-3O7cmAAjXN3c9qxIeLwNHUzolRucrexqTPucno5oDiW0v9ji7JlsBdznmITcwtzT1ywAP61EgC78ANyZ7A5M2dAPxJJbQ9yFwAklc_Rg3NPcktB93NRyEtyXQBPcnUzz3P9iK5yFwGvcqaA7nJDiB9yJtOI0aqYX3O_coTUETOt0rDyAWJdAb5znmMec8zQU7OkckBysglH3DPdZ9x68TZ0jCNIRENcZxwQOWNsKbWY85F5FxwQOIZJkRgb1SxyzjJXcwPc_fktc348hPPsc7SFWADMcrjc3nPMczOU9PlMwcRyqPKhs71S2eJicydSj4VE4uKzpmLttbpjl2w4ELDDmnKW3RxzsQBlnDnCTPOuMRsRWPJd6WrxsuRRWfNdenObMtnj3rKgc-XxOPKs8rAB_eliQdzyffEXHLzzAHKURGRykjzI9ZESWzKW6XnwLmOprWbp0nNLlY9yZXO9sqDATAnDgl8sZaTNlIh4nvR66P2y-HPZs7PBU3J1BPfDs8G5ssOydRL5s2OzRHMK8yjzAvJ-s9OzlPMzs4Ojs7Lf1KiI4nL8czw4mvLUcrNJESIbGGG0yMnprLNSbBNj1CKJPrzMAbSzFlCYk38yR0HsMGCyKHRAYMKz0LJI4ubyWxIosuOypvM0kSOz8jwQg7kR4WGJBG-BkLMco5bRnwhG82HIz23KU8vjHzOYsveZWLKjY9iy74E4sjDj-lK6QeBtXm0vokKwEaIO-SGRQy3Lbe8Fe22qcTNC0gO6EIajKIBGo7OYxqPXYmYE1uFiSNxVLZNlKdSyVgWo-Z8JmGHVWLMyT9KOAf9D25wl9XMzGtLdMwsztEgPbFxRw4U7tY8txMBSXVTM4BlqweVUArKXU6NjP2L2kTCjnUmRoJTpgEEzWVdS6rOeU7HI3lKJ8S1U2LIehaGEwFyYQC8zMxNbHbpS_IWZCMWycAAZ82IAmfMADKMAtlQh8qLgofNIuIgRj7FZYzNjc-OV8qDBm2J9glfiPoFCAVgBc2NfZLry5fDx8tAYoAEJ8jABifO39UnyjBkfc_8A7RDN84sAiCNPYkwRvTF8vfzJnAArMIHhqayKIYmjRRnAI0_j5mm4uBrSYAEE3SnycAECYp7AjDnKwEWkRaSB89swQfIDgaujusBj892A4_KJOP4zq0DDYydJF2PNEkPzA_LjMwPzrFH17QPzBN33Y__0JUFnYwTd3SgLMkvSV2zA4zcpzMGFNM_TCuitUoVi4Pkb8y1SCMwI07nz0kDZ9QhjKQWlk3koZfNcVOXyWZK8VWWJl9SZEDXx-_NO0ZxVZfI-k0fyfVGX1VwA-_P-kg89B_Mh8kfzZSmX1Zi9ixin8tfzh_LlkzfyD-ObM73yTiFTdWYxCmXCwJ7U2_MlY3FTIOhzrTvyT_KSwTzyvfO9outY7gDP87vw73NC8x_zFcESAWzd6WJ_89_zrPG78NccX_OhhN_y9WH_8hX1AAulwYAKhRk7UmALQMCgCl0gYAo_8-vgEAtf80_zrPHGc9liCtMIsh-IsfJL0yXjmuLL880SK_MIClDSoCjXNBczYrJ2vTAL5xC7I9yywvJoCpczFoDoAFczm7Rbsok4Oag_6SdIHyGz8r3d-8M0wJFIxgEIfLMBHNJU010QlaPAc2WBCwDvg9i4U2ymgeIBwLT9wI6gvAhOVGagEtiS3ZjASjI5otPi97N_mO0ST3AeEPVEHXLIc7ehjtktqKHCNSIs8l8JkHKj-DVUo_hKM9JiF6KUgV0QzuNbs7hzFPlIC-IJyAvwCx2darCH4xyw9u3L8xAyEsEz8qp5A_KQU3vcSZBdAHpivSir8ygKr4kRzIUQpMASUUJjIaElDaej-8JcC4IAsmJq3TkCyApb3bzwk_LwVcajU_KJOCgLP3zEwRIK-1znvddsauONw8R4KDM4YutsFohtbJ7y36Mb9MvS-vFYYtoLiyAfor7yn6InoyZQ-gpLba_CbCPcIUILe9wBeMYLXQB3oldjgfLXY-PyHFRZuOYKswAHkJihpgoIMyBj-GOe86CEqSNvocILdpCz8-IJogoPkJxYigpM3OvyQMAiCru4ogtdQRKz84zfM94NjhDM0MALu_L8wM_y4tLkZNvyffMi8kAyjPIVIirwBujeCvzAm5N6PKPhiaLD4sLy8fXV0rt9FCwACzAKjSHhC7fBiaLXUL0Fb1nS0xALPPJ68AvSu_PgAGEg__LxC8qBFZHPw9EKVtJhCxAKnBBJPZCiXB3UkP4KYQrZ4vH1btNN6aXTyvAssIgATiAbk44Q_gohC1gToQs5w2EKwfVRC_Ah0Qu88N718OQZPDtxfgpP8-cRUrL4gMELsIOP85EKrsG-CnQYVSHCrRkKhQuZCsH1WQqLMdrNOQpXYC1zWAC1C73zVk2V-bdMHiDNC1_yphEGzCyjg1z8wKYQSsy3veYR2s0jIlj1DQszzNqUvrTf3AkKYrlZ8ZIg273qAbUA7lQ4wMuBhAPyACHhkgD5KF-D8xlmzVgB5s2GwAKdZeAXdCbUIgB5uULitmIo8b8ENQVKFd0L0ik1LBUAXfAOTbCdMwoRULT9sDNl0kELhwHLC_kL802t8sFBSbmvM4eTNPMmCywy76ENCzYL47wiAcIo46xzCqatZaVYXcugoxBuA7dM1fhSfeUBsJ3CKGsionOa47SA_golnGcLbgxrAZ9EuwEXC44Q8CCrC4ELuDPUkesLAbnJHQXzT2Lb8uQg7guekQPyAyHJPdsUZxxdVHGyCsCvC_GDFx1vC9IpxfLFs6nzaMAhaZd1odIdAebS62kpaXIy9_R6zL-doQqtCRYyDs3vCqp4bwokgSUL0inJPW3yzfVcgE9jl1Kd8pjoQJFd893z1CC0_elVIIurEzmUvLOXUhgzjyz6AMfws6314RjxKdK08jyyYOOvMjzQ6T0SDMz1CFIj42qFz1XqhVylWYR95YsBiQCqAbwBQMl_AQ44hUSTRFHdb0SrhSfNIYAEitPF4AGgPKRcBYXh3XCBF4D4ixeBo0WXgV-A2Tl1eMTAgvSBALiLQQF2RdhFJ0jMxZmAsIHEi6NE0N1nKXskMYQsYc0ABYQRbJWk2RSRgIHEgOWYoquArItQRJGAcAD1pIalOGCukKyK9IEhgHABI1A8iiyKpQEukXuArIuxgPyK_IvsipFFDh28ivyKNER1pSKLfOE84FJJpYQRbWTVEYEX5e1Eqpnx4QngjiGJ4UZkq4QRbPrk_IrrZYhErwnxUGKLJ80iitTtA1gqiyGACeFuUJRUAoveHCZSCYNwcKyKjIHCi_yKkSQBHLUkK1RBHLuD0gOzhYaFEAFQPGaF0D36i9KCgnEiim9o-gDvaX7pZxxSijqKIYC6izKLsqNapLEAYoohlFaLEUUGBYYFKQGci3yL2aQCimaKwCQ5NCUB2ot8i7aKtRQi9DaKUor65RGAroqzRK2NiGRtjd3MrIvSityLIorHYwyKUop8iuKKEoouka0BnIo6ilXg7Iq4JIZgXhBBAbwA8jgJkXQRnhBYitAE2EE_5CFBPYReoHQBY-CvWIKLMkH4AeQAFAHkAeQAgAA`} __position={0} __code={'<Map viewport={{ center: [0.026, 123.61], zoom: 5 }} />'} __scope={{props: this ? this.props : props,Map}}>\n  <Map viewport={{ center: [0.026, 123.61], zoom: 5, }} />\n</Playground>\n           </MDXTag>\n  }\n}\n  "],"sourceRoot":""}