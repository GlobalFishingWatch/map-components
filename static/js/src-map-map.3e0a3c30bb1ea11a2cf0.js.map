{"version":3,"sources":["/Users/joseangel/Workspace/map-components/src/map/glmap/map.css","/Users/joseangel/Workspace/map-components/src/map/lib/Pack.js","/Users/joseangel/Workspace/map-components/src/map/lib/pelagosClient.js","/Users/joseangel/Workspace/map-components/src/map/proptypes/tracks.js","/Users/joseangel/Workspace/map-components/src/map/proptypes/layers.js","/Users/joseangel/Workspace/map-components/src/map/proptypes/shared.js","/Users/joseangel/Workspace/map-components/src/map/config.js","/Users/joseangel/Workspace/map-components/src/map/module/module.actions.js","/Users/joseangel/Workspace/map-components/src/map/module/module.selectors.js","/Users/joseangel/Workspace/map-components/src/map/tracks/tracks.selectors.js","/Users/joseangel/Workspace/map-components/src/map/constants.js","/Users/joseangel/Workspace/map-components/src/map/utils/buildEndpoint.js","/Users/joseangel/Workspace/map-components/src/map/utils/heatmapTileData.js","/Users/joseangel/Workspace/map-components/src/map/heatmap/heatmapTiles.actions.js","/Users/joseangel/Workspace/map-components/src/map/heatmap/heatmap.actions.js","/Users/joseangel/Workspace/map-components/src/map/glmap/viewport.actions.js","/Users/joseangel/Workspace/map-components/src/map/glmap/interaction.actions.js","/Users/joseangel/Workspace/map-components/src/map/utils/map-colors.js","/Users/joseangel/Workspace/map-components/src/map/heatmap/HeatmapSubLayer.js","/Users/joseangel/Workspace/map-components/src/map/heatmap/HeatmapLayer.js","/Users/joseangel/Workspace/map-components/src/map/activity/ActivityLayers.js","/Users/joseangel/Workspace/map-components/src/map/activity/ActivityLayers.container.js","/Users/joseangel/Workspace/map-components/src/map/glmap/Map.js","/Users/joseangel/Workspace/map-components/src/map/glmap/Map.container.js","/Users/joseangel/Workspace/map-components/src/map/glmap/style.reducer.js","/Users/joseangel/Workspace/map-components/src/map/utils/getMainGeomType.js","/Users/joseangel/Workspace/map-components/src/map/glmap/style.actions.js","/Users/joseangel/Workspace/map-components/src/map/glmap/viewport.reducer.js","/Users/joseangel/Workspace/map-components/src/map/store/index.js","/Users/joseangel/Workspace/map-components/src/map/utils/getTrackBounds.js","/Users/joseangel/Workspace/map-components/src/map/tracks/tracks.actions.js","/Users/joseangel/Workspace/map-components/src/map/utils/withReducerTypes.js","/Users/joseangel/Workspace/map-components/src/map/module/module.reducer.js","/Users/joseangel/Workspace/map-components/src/map/tracks/tracks.reducer.js","/Users/joseangel/Workspace/map-components/src/map/heatmap/heatmap.reducer.js","/Users/joseangel/Workspace/map-components/src/map/heatmap/heatmapTiles.reducer.js","/Users/joseangel/Workspace/map-components/src/map/glmap/interaction.reducer.js","/Users/joseangel/Workspace/map-components/src/map/store/reducers.js","/Users/joseangel/Workspace/map-components/src/map/map.js","/Users/joseangel/Workspace/map-components/src/map/basemaps/index.js","/Users/joseangel/Workspace/map-components/src/map/map.mdx"],"names":["module","exports","byname","Uint8","size","Uint8Array","BYTES_PER_ELEMENT","array","getter","setter","Int8","Int8Array","Uint16","Uint16Array","Int16","Int16Array","Uint32","Uint32Array","Int32","Int32Array","Float32","Float32Array","Float64","Float64Array","writeStringToArrayBuffer","str","start","end","buf","bufstart","undefined","length","i","charCodeAt","arrayBufferToString","String","fromCharCode","apply","Pack","typemap","byarray","pack","typespec","value","littleendian","ArrayBuffer","DataView","stringToArrayBuffer","res","Uint8ClampedArray","buffer","name","spec","PelagosClient","this","MAGIC_COOKIE","url","token","Promise","resolve","reject","request","XMLHttpRequest","open","setRequestHeader","responseType","onload","handleData","bind","onerror","send","self","error","readyState","success","status","isFileUri","response","byteLength","dataView","headerLen","cookie","slice","getInt32","offset","headerIsLoaded","header","JSON","parse","rowLen","colsByName","colidx","cols","col","idx","type","multiplier","min","max","orientation","errorLoading","toString","allLoaded","result","rowidx","row","val","colValues","eval","trackTypes","id","PropTypes","string","isRequired","data","object","color","oneOf","layerTemporalExtents","arrayOf","number","fitBoundsOnLoad","bool","heatmapLayerTypes","tilesetId","subtype","visible","hue","opacity","filters","shape","filterValues","endpoints","temporalExtents","temporalExtentsLess","interactive","basemapLayerTypes","staticLayerTypes","selected","selectedFeatures","field","values","highlighted","higlightedFeatures","showLabels","isCustom","gl","popupTypes","content","node","latitude","longitude","viewportTypes","zoom","center","STATIC_LAYERS_CARTO_ENDPOINT","STATIC_LAYERS_CARTO_TILES_ENDPOINT","initModule","props","dispatch","payload","startLoader","state","loaderId","timestamp","Date","getTime","map","onLoadStart","completeLoader","getState","loaders","onLoadComplete","onViewportChange","interactionState","callback","viewport","bounds","canZoomIn","canZoomOut","mouseLatLong","setTemporalExtent","temporalExtent","setHighlightTemporalExtent","highlightTemporalExtent","closePopup","onClosePopup","setCursor","cursor","getTemporalExtent","getHighlightTemporalExtent","getTracksData","tracks","getGeojsonTracksReady","createSelector","filter","t","mergeStyles","style1","style2","sources","layers","filterGeojsonByTimerange","geojson","features","featuresFiltered","reduce","filteredFeatures","feature","properties","coordinateProperties","times","filtered","geometry","coordinates","filteredCoordinates","coordinate","index","timeCoordinate","push","filteredFeature","getFullTracksStyles","hasTemporalExtent","hasTracks","timerange","acc","track","source","style","paint","getHighlightedTrackStyles","getTracksStyles","trackStyles","highlightedTrackStyles","TRANSITION_TYPE","ZOOM","BRUSH_RENDERING_STYLE","NORMAL","BULLSEYE","BRUSH_ZOOM_RENDERING_STYLE","RADIAL_GRADIENT","CIRCLE","CUSTOM_LAYERS_SUBTYPES","raster","urlTemplate","urlParams","templateSettings","interpolate","template","urlTemplateCompiled","getTemporalTileURLs","params","urls","forEach","extent","startTimeISO","toISOString","endTimeISO","tileCoordinates","x","y","z","buildEndpoint","temporalExtentsIndices","indexOf","getTilePromises","tilesetUrl","promises","urlIndex","obtainTile","getCleanVectorArrays","rawTileData","vectorArray","groupData","cleanVectorArrays","columns","currentArray","totalVectorArraysLength","sumBy","a","filteredColumns","column","console","warn","key","cumulatedOffsets","appendValues","set","getTilePlaybackData","prevPlaybackData","tilePlaybackData","zoomFactorRadius","convert","getZoomFactorRadius","zoomFactorRadiusRenderingMode","getZoomFactorRadiusRenderingMode","zoomFactorOpacity","getZoomFactorOpacity","columnsArr","Object","keys","c","storedColumns","concat","sigma","weight","hidden","pull","uniq","numPoints","newFrames","timeIndexes","point","timeIndex","getOffsetedTimeAtPrecision","datetime","lngLatToWorld","worldX","worldY","radius","sigmaToRadius","weightToOpacity","series","frame","vesselSatisfiesFilters","every","selectVesselsAt","tileData","tileQuery","startIndex","endIndex","currentFilters","vessels","toleranceRadiusInWorldUnits","f","wx","wy","pass","some","vesselSatisfiesAllFilters","vessel","currentTilesLoadZoomOffset","highDefMode","document","addEventListener","event","keyCode","log","getTilecoverLimits","viewportZoom","Math","ceil","tilesAvailable","min_zoom","max_zoom","flushToReleaseTiles","heatmapTiles","currentToLoadTileUids","currentTilesToReleaseUids","currentToReleaseTileUids","releaseTiles","markTileAsLoaded","tileUids","flushTileState","forceLoadingAllVisibleTiles","currentVisibleTiles","tilesToLoad","tilesToReleaseUids","currentLoadedTiles","visibleTile","find","uid","loadedTile","tilesToLoadUids","tile","getTile","updateLoadedTiles","debouncedFlushState","debounce","updateHeatmapTilesFromViewport","mapViewport","width","height","currentTransition","boundsViewport","PerspectiveMercatorViewport","unproject","wn","es","w","s","e","n","boundsPolygonsCoordinates","limits","w1","e2","geom","viewportTilesCoords","tilecover","tiles","viewportTilesIndexes","indexes","visibleTiles","coords","prevZoom","queryHeatmapVessels","temporalExtentIndexes","uids","highlightVesselFromHeatmap","getTemporalExtentsVisibleIndices","loadTemporalExtent","currentExtentStart","currentExtentEnd","indices","temporalExtentStart","loadLayerTile","layerId","Error","pelagosPromises","allLayerPromises","all","then","loadedLayerId","parseLayerTile","getTiles","layerIds","referenceTiles","newTemporalExtentsToLoad","loaderID","join","heatmapLayers","heatmap","tilesByLayer","allPromises","heatmapLayerHeader","referenceTile","temporalExtentsIndicesLoaded","queriedTemporalExtentsIndices","visibleTemporalExtentsIndices","temporalExtentsIndicesToLoad","difference","tilePromise","visibleHeatmapLayers","visibleHeatmapLayersIds","loadAllTilesForLayer","addHeatmapLayer","layer","removeHeatmapLayer","updateLayerLoadTemporalExtents","indicesToAddByLayer","heatmapLayer","oldVisibleTemporalExtentsIndices","newVisibleTemporalExtentsIndices","indicesAdded","indicesRemoved","layerIdsWithIndicesToAdd","clearHighlightedVessels","isEmpty","clickableCluster","layersVessels","availableTiles","bestTile","isCluster","isMouseCluster","layerVesselsResult","foundVessels","layersVesselsResults","layerVessels","v","seriesgroup","uniqBy","_queryHeatmap","highlightedVessels","highlightableCluster","highlightClickedVessel","clearHighlightedClickedVessel","updateHeatmapLayers","newLayers","currentLoadTemporalExtent","prevLayersDict","newLayer","prevLayer","prevLayerId","l","setBounds","setViewport","updateViewport","viewportUpdate","transitionTo","increment","transitionToZoom","transitionEnd","zoomIntoVesselCenter","fitToBounds","vp","fitBounds","minLng","minLat","maxLng","maxLat","padding","exportNativeViewport","nativeViewport","topLeftPx","bottomRightPx","topLeftWorld","pixelsToWorld","pixelUnprojectionMatrix","bottomRightWorld","leftWorldScaled","scale","rightWorldScaled","northWest","southEast","north","south","west","east","getAreaKm2","glFeature","area","toLocaleString","maximumFractionDigits","getFeature","fields","fieldsDefinition","metadata","fieldsKeys","k","fd","fieldKey","def","label","title","isLink","isMain","mainField","getFields","mapInteraction","interactionType","glFeatures","glGetSource","legacyHeatmapFeature","currentStyle","mapStyle","toJS","currentLegacyHeatmapData","count","group","clusterPromises","getStaticLayerIdFromGlFeature","cluster","clusterPromise","clusterId","cluster_id","glSource","getClusterExpansionZoom","err1","getClusterLeaves","err2","children","childrenFeatures","child","getCluster","autoClusterZoom","clusterBehavior","clusterZoom","onClick","onHover","COLOR_HUES","orange","peach","yellow","green","brightGreen","lightBlue","blue","purple","pink","getKeyByValue","obj","entries","entry","rgbToHsv","_r","_g","_b","h","r","g","b","d","hsvToRgb","h_","s_","v_","parseFloat","floor","p","q","mod","round","hueToRgbDefaults","hueToRgbString","rgb","rgbToHexString","css","channelName","channelValue","channelStr","hueToRgbHexString","hueToClosestColor","goal","colorHueValues","closestHue","prev","curr","abs","hexToRgb","hex","exec","parseInt","rgbToRgbaString","hueToRgbaString","hexToRgba","hueIncrementToHue","hueIncrement","hueToHueIncrement","wrapHue","hueOrColorToHexColor","HeatmapSubLayer","baseTexture","renderingStyleIndex","useNormalBlendMode","stage","PIXI","particles","ParticleContainer","alpha","position","uvs","blendMode","BLEND_MODES","SCREEN","spritesPool","initialTextureFrame","Rectangle","VESSELS_BASE_RADIUS","mainVesselTexture","Texture","_setTextureFrame","clearSpriteProps","spritesProps","spritesPropsCount","destroy","textureFrame","clone","VESSELS_HUES_INCREMENTS_NUM","update","numProps","resizeSpritesPool","sprite","setTransform","numSprites","delta","toRemove","removeChildAt","toAdd","_addSprites","num","Sprite","anchor","addChild","worldToPixelsSimple","m","HeatmapLayer","_build","_destroy","_redraw","nextProps","useRadialGradientStyle","setBrushZoomRenderingStyle","rootStage","customRenderingStyle","subLayers","renderingStyle","rendering","setBrushRenderingStyle","brushRenderingStyle","toUpperCase","_setBrushRenderingStyleIndex","brushZoomRenderingStyle","cappedZoomRenderingStyle","newStyleIndex","subLayer","setRenderingStyleIndex","defaultHue","allHuesToRender","currentlyUsedHues","allHues","_createSublayer","_destroySubLayer","_setSubLayersSpritePropsForTile","numFilters","hueToRender","render","viewportLeft","viewportRight","len","fi","scaledX","scaledY","mtx","pixelProjectionMatrix","pitch","worldToPixels","pushSpriteProps","defaultOpacity","defaultSize","removeChild","React","Component","ActivityLayers","pixiReady","onTouchStart","touches","queryCoords","clientX","clientY","onMouseMove","_onTick","heatmapFadingIn","heatmapStage","_heatmapFadeinStep","setState","_context","_updateViewportSize","pixi","transparent","antialias","renderer","canvas","view","container","appendChild","baseTextureCanvas","blurFactor","tplCanvas","createElement","tplCtx","getContext","diameter","yCenter","gradient","createRadialGradient","rgbString","addColorStop","rgbOuter","fillStyle","fillRect","beginPath","arc","PI","fill","lineWidth","strokeStyle","stroke","getVesselTexture","fromCanvas","ticker","add","viewportWidth","viewportHeight","resize","dim","wrappedLongitude","heatmapFadeinStartTimestamp","now","timeElapsed","highlightedClickedVessel","highlightLayerData","highlightFilters","sourceLayer","shouldUseRadialGradientStyle","toggleHeatmapDimming","_startHeatmapFadein","getError","err","_getHighlightData","ref","BaseControl","propTypes","func","contextTypes","getHeatmapLayersAsArray","getTemporalExtentIndexes","startTimestamp","endTimestamp","connect","ownProps","PopupWrapper","closeButton","onClose","offsetTop","tipSize","closeOnClick","defaultProps","Map","onLoad","getBounds","glMap","_ne","_sw","lat","lng","loadObserver","window","ResizeObserver","default","_containerResizeObserver","handleResizeObserver","observe","_mapContainerRef","contentRect","propsViewport","bearing","onMapInteraction","lngLat","getRef","getMap","getSource","getCursor","isDragging","transformRequest","resourceType","match","headers","Authorization","mouseOver","disconnect","maxZoom","minZoom","clickPopup","hoverPopup","hasHeatmapLayers","markers","interactiveLayerIds","className","styles","onMouseLeave","onMouseEnter","onTransitionEnd","clickRadius","disableTokenWarning","marker","googleLogo","getInteractiveLayerIds","staticLayers","glLayer","glLayerId","getMapStyle","mapStyles","trackLayersIndex","lastIndexOf","finalMapStyles","mergeIn","mapStylesLayers","get","trackLayer","insert","fromJS","interaction","internalCursor","moduleCursor","long","attributions","GL_STYLE","sourceKey","attribution","setLayerStyleDefaults","layout","temporalField","visibility","initialState","cartoLayersInstanciated","basemapLayers","TYPES","geoJSON","INIT_MAP_STYLE","SET_MAP_STYLE","MARK_CARTO_LAYERS_AS_INSTANCIATED","SET_STATIC_LAYERS","SET_BASEMAP_LAYERS","setDefaultVectorTiles","currentSource","refLayerUrl","refLayerUrls","newTiles","initStyle","glyphsPath","setMapStyle","setStyleTemporalExtent","applyToThrottled","glLayers","currentFilter","getIn","isLegacy","setIn","applyTemporalExtentThrottled","throttle","applyTemporalExtent","updateGLLayer","refLayer","currentStyleLayers","newStyle","glLayerIndex","findIndex","toggleLayerVisibility","isBasemap","refLayerOpacity","labelsVisibility","colorPaintProperty","currentGlLayer","glType","defaultStyles","styleType","refLayerStyle","hasFeatures","applyStyleToAllFeatures","defaultStyle","layerStyle","allPaintProperties","glPaintProperty","glPaintFinalValue","selectedValue","fallbackValue","paintOrLayout","includes","originalLayerStyle","layerColorRgbString","layerColorRgb","replace","applyLayerExpressions","addCustomGLLayer","tileSize","allGeoJSONTypes","numByGLType","geoJSONType","glTypeMax","getMainGeomType","layerIndex","reverse","splice","instanciateCartoLayers","sourceId","cartoLayersPromises","sourceCartoSQL","mapConfig","options","sql","mapConfigURL","encodeURIComponent","stringify","cartoAnonymousMapUrl","fetch","json","layergroupid","catch","instanciatedCartoLayers","cartoLayer","tilesURL","newSourceId","deleteIn","commitStyleUpdates","bl","currentGLSources","workspaceGLLayers","workspaceGLLayer","finalSource","existingLayerIds","layerToAdd","layerToAddId","defaultGlLayer","existingLayers","newLayerGroup","newLayerIndex","findLastIndex","updateWorkspaceGLLayers","customLayers","glSources","cartoLayersToInstanciate","newSource","cartoLayerInstanciated","DEFAULT_TRANSITION","transitionDuration","transitionInterpolator","FlyToInterpolator","transitionEasing","easeCubic","composeEnhancers","compose","store","createStore","applyMiddleware","thunk","targetMapVessel","fitToBoundsAction","geoBounds","timelineBounds","setTimeout","TRANSITION_DURATION","getTrackTimeBounds","time","Infinity","getTrackBounds","tbbox","loadTrack","trackHasData","trackHasUrl","cleanData","vectorArrays","currentLng","createFeature","segId","geomType","currentSeries","currentFeature","fishingPoints","lngOffset","ll","convertLegacyTrackToGeoJSON","statusText","finally","removeTrack","trackId","updateTracks","newTracks","prevTracks","newTrack","prevTrack","withReducerPropTypes","propTypesSchema","reducer","onAttributionsChange","withReducerTypes","instanceOf","action","loaderIndex","exact","trackData","removedTrackId","mapReducer","combineReducers","ModuleReducer","TracksReducer","assign","newTile","layerTiles","tileIndex","tileUid","releasedTileIndex","releasedRefTileIndex","newHeatmapLayers","newToLoadTilesUids","tileUidsMarkedAsLoaded","newCurrentToLoadTileUids","newMapStyle","currentZoom","mapReducers","replaceReducer","throttleApplyTemporalExtent","updateViewportFromIncomingProps","incomingViewport","MapModule","initialized","errorInfo","prevProps","currentViewport","componentStack","AVAILABLE_BASEMAPS","layoutProps","MDXContent","components","mdxType","parentName","__position","__code","__scope","Playground","Props","__codesandbox","isMDXComponent"],"mappings":"ygdACAA,EAAOC,QAAU,CAAC,IAAM,iBAAiB,WAAa,0B,qDCAtD,IAAIC,EAAS,CACXC,MAAO,CACLC,KAAMC,WAAWC,kBACjBC,MAAO,eACPC,OAAQ,WACRC,OAAQ,YAEVC,KAAM,CACJN,KAAMO,UAAUL,kBAChBC,MAAO,eACPC,OAAQ,WACRC,OAAQ,YAEVG,OAAQ,CACNR,KAAMS,YAAYP,kBAClBC,MAAO,eACPC,OAAQ,YACRC,OAAQ,aAEVK,MAAO,CACLV,KAAMW,WAAWT,kBACjBC,MAAO,eACPC,OAAQ,WACRC,OAAQ,YAEVO,OAAQ,CACNZ,KAAMa,YAAYX,kBAClBC,MAAO,eACPC,OAAQ,YACRC,OAAQ,aAEVS,MAAO,CACLd,KAAMe,WAAWb,kBACjBC,MAAO,eACPC,OAAQ,WACRC,OAAQ,YAEVW,QAAS,CACPhB,KAAMiB,aAAaf,kBACnBC,MAAO,eACPC,OAAQ,aACRC,OAAQ,cAEVa,QAAS,CACPlB,KAAMmB,aAAajB,kBACnBC,MAAO,eACPC,OAAQ,aACRC,OAAQ,eAIRe,EAA2B,SAASC,EAAKC,EAAOC,EAAKC,EAAKC,QACjDC,GAAPH,IACFA,EAAMF,EAAIM,aAECD,GAATJ,IACFA,EAAQ,QAEMI,GAAZD,IACFA,EAAWH,GAEb,IAAK,IAAIM,EAAIN,EAAOM,EAAIL,EAAKK,IAC3BJ,EAAII,EAAIN,EAAQG,GAAgC,IAApBJ,EAAIQ,WAAWD,IAkB3CE,EAAsB,SAASN,GACjC,OAAOO,OAAOC,aAAaC,MAAM,KAAM,IAAIhC,WAAWuB,KASpDU,EAAO,CACTC,QAAS,CACPrC,OAAQA,EACRsC,QAAS,IAEXC,KAXS,SAASC,EAAUC,EAAOC,GACnC,IAAIrC,EAAQ,IAAIsC,YAAYH,EAAStC,MAErC,OADA,IAAI0C,SAASvC,GAAOmC,EAASjC,QAAQ,EAAGkC,EAAOC,GACxCV,EAAoB3B,IAS3B2B,oBAAqBA,EACrBa,oBA/BwB,SAAStB,EAAKC,EAAOC,QAGlCG,GAAPH,IACFA,EAAMF,EAAIM,aAECD,GAATJ,IACFA,EAAQ,GAEV,IAAIsB,EAAM,IAAIC,kBAAkBtB,EAAMD,GAEtC,OADAF,EAAyBC,EAAKC,EAAOC,EAAKqB,EAAK,GACxCA,EAAIE,QAqBX1B,yBAA0BA,GAE5B,IAAK,IAAI2B,KAAQb,EAAKC,QAAQrC,OAAQ,CACpC,IAAIkD,EAAOd,EAAKC,QAAQrC,OAAOiD,GAC/BC,EAAKD,KAAOA,EACZb,EAAKC,QAAQC,QAAQY,EAAK7C,OAAS6C,EAGtBd,M,i6BCvGTe,c,WACJ,yBAAe,+LACbC,KAAKC,aAAe,O,+NAGXC,EAAKC,GACd,OAAO,IAAIC,QACT,SAASC,EAASC,GAEhB,GADAN,KAAKO,QAAU,KACc,oBAAlBC,eAGT,KAAM,6BAFNR,KAAKO,QAAU,IAAIC,eAIrBR,KAAKK,QAAUA,EACfL,KAAKM,OAASA,EACdN,KAAKO,QAAQE,KAAK,MAAOP,GAAK,GAC1BC,GACFH,KAAKO,QAAQG,iBAAiB,gBAA9B,iBAAyDP,IAE3DH,KAAKO,QAAQI,aAAe,cAC5BX,KAAKO,QAAQK,OAASZ,KAAKa,WAAWC,KAAKd,MAC3CA,KAAKO,QAAQQ,QAAUf,KAAKa,WAAWC,KAAKd,MAC5CA,KAAKO,QAAQS,KAAK,OAClBF,KAAKd,S,8CAKT,IAAIiB,KAAOjB,KACX,GAAKA,KAAKO,QAAV,CAGA,GAAIP,KAAKkB,MACP,OAAO,EAGT,GAA+B,GAA3BlB,KAAKO,QAAQY,WAAiB,CAKhC,IAAIC,QAAiC,KAAvBpB,KAAKO,QAAQc,QAAkBrB,KAAKsB,WAAoC,GAAvBtB,KAAKO,QAAQc,OAC5E,IAAKD,QAEH,YADApB,KAAKK,QAAQ,MAKjB,GAAKL,KAAKO,QAAQgB,SAAlB,CAGA,IAAI9C,OAASuB,KAAKO,QAAQgB,SAASC,WAC/BD,SAAWvB,KAAKO,QAAQgB,SACxBE,SAAW,IAAIjC,SAAS+B,UAE5B,KAAI9C,OAAS,GAAb,CAGA,GAAsB,MAAlBwC,KAAKS,UAAmB,CAC1B,IAAIC,OAAS3C,qCAAKJ,oBAAoB2C,SAASK,MAAM,EAAG,IACxD,GAAID,QAAU3B,KAAKC,aAQjB,YAPAD,KAAKM,OACH,kBACEN,KAAKE,IACL,2CACAF,KAAK2B,OACL,KAKNV,KAAKS,UAAYD,SAASI,SAAS,GAAG,GAEtCZ,KAAKa,OAAS,EAEhB,KAAIrD,OAASwC,KAAKa,OAASb,KAAKS,WAAhC,CAGA,IAAKT,KAAKc,eAAgB,CACxBd,KAAKe,OAASC,KAAKC,MACjBlD,qCAAKJ,oBAAoB2C,SAASK,MAAMX,KAAKa,OAAQb,KAAKa,OAASb,KAAKS,aAE1ET,KAAKkB,OAAS,EACdlB,KAAKe,OAAOI,WAAa,GACzB,IAAK,IAAIC,OAAS,EAAGA,OAASpB,KAAKe,OAAOM,KAAK7D,OAAQ4D,SAAU,CAC/D,IAAIE,IAAMtB,KAAKe,OAAOM,KAAKD,QAC3BE,IAAIC,IAAMH,OACVpB,KAAKe,OAAOI,WAAWG,IAAI1C,MAAQ0C,IACnCA,IAAInD,SAAWJ,qCAAKC,QAAQrC,OAAO2F,IAAIE,WAEjBjE,GAAlB+D,IAAIG,iBAAsClE,GAAX+D,IAAII,MACrCJ,IAAII,IAAMJ,IAAII,IAAMJ,IAAIG,iBAERlE,GAAd+D,IAAIT,aAAkCtD,GAAX+D,IAAII,MACjCJ,IAAII,IAAMJ,IAAII,IAAMJ,IAAIT,aAEJtD,GAAlB+D,IAAIG,iBAAsClE,GAAX+D,IAAIK,MACrCL,IAAIK,IAAML,IAAIK,IAAML,IAAIG,iBAERlE,GAAd+D,IAAIT,aAAkCtD,GAAX+D,IAAIK,MACjCL,IAAIK,IAAML,IAAIK,IAAML,IAAIT,QAG1Bb,KAAKkB,QAAUI,IAAInD,SAAStC,KAQ9B,GANAmE,KAAKa,QAAUb,KAAKS,UAGpBT,KAAKa,SAAW,EAAKb,KAAKS,UAAY,GAAM,EAE5CT,KAAKc,gBAAiB,EACS,WAA3Bd,KAAKe,OAAOa,aAAuD,cAA3B5B,KAAKe,OAAOa,YAatD,OAZA5B,KAAK6B,aAAa,CAChBD,YAAa5B,KAAKe,OAAOa,YACzBE,SAAU,WACR,MACE,kBACA/C,KAAKE,IACL,sDACAF,KAAK6C,YACL,qDAIC,EAIT,IAAK5B,KAAKkB,OAER,OADAlB,KAAK+B,aACE,EAGX,GAA+B,WAA3B/B,KAAKe,OAAOa,YAA0B,CAExC,IADA,IAAII,OAAS,GACNhC,KAAKa,OAASb,KAAKkB,QAAU1D,OAAQwC,KAAKiC,SAAU,CAEzD,IADA,IAAIC,IAAM,GACDd,OAAS,EAAGA,OAASpB,KAAKe,OAAOM,KAAK7D,OAAQ4D,SAAU,CAC/D,IAAIE,IAAMtB,KAAKe,OAAOM,KAAKD,QACvBe,IAAM3B,SAASc,IAAInD,SAASlC,QAAQ+D,KAAKa,QAAQ,GACrDqB,IAAIZ,IAAI1C,MAAQuD,IAChBnC,KAAKa,QAAUS,IAAInD,SAAStC,KAI9BmG,OAAOV,IAAI1C,MAAQsD,IAEjBlC,KAAKiC,QAAUjC,KAAKe,OAAOvD,QAE7BuB,KAAKK,QAAQ4C,aAIV,GAA+B,cAA3BhC,KAAKe,OAAOa,YAA6B,CAClD,IAAIQ,UAAY,KACZJ,OAAS,GACb,GAAIxE,QAAUwC,KAAKa,OAASb,KAAKe,OAAOvD,OAASwC,KAAKkB,OAAQ,CAC5D,IAAK,IAAIE,OAAS,EAAGA,OAASpB,KAAKe,OAAOM,KAAK7D,OAAQ4D,SAAU,CAC/D,IAAIE,IAAMtB,KAAKe,OAAOM,KAAKD,QAE3BgB,UAAY,IAAKC,KAAKf,IAAInD,SAASnC,OAAvB,CACVsE,SAASK,MAAMX,KAAKa,OAAQb,KAAKa,OAASS,IAAInD,SAAStC,KAAOmE,KAAKe,OAAOvD,SAE5EwC,KAAKa,QAAUb,KAAKe,OAAOvD,OAAS8D,IAAInD,SAAStC,KAEjDmG,OAAOV,IAAI1C,MAAQwD,UAKrB,OADArD,KAAKK,QAAQ4C,SACN,Y,iBAMAlD,oC,iyCCnLFwD,EAAa,CACxBC,GAAIC,IAAUC,OAAOC,WACrBzD,IAAKuD,IAAUC,OACfE,KAAMH,IAAUI,OAChBC,MAAOL,IAAUC,OACjBjB,KAAMgB,IAAUM,MAAM,CAAC,UAAW,eAAWvF,IAC7CwF,qBAAsBP,IAAUQ,QAAQR,IAAUQ,QAAQR,IAAUS,SACpEC,gBAAiBV,IAAUW,M,yMCPtB,IAAMC,EAAoB,CAC/Bb,GAAIC,IAAUC,OAAOC,WACrBW,UAAWb,IAAUC,OACrBa,QAASd,IAAUC,OACnBc,QAASf,IAAUW,KACnBK,IAAKhB,IAAUS,OACfQ,QAASjB,IAAUS,OACnBS,QAASlB,IAAUQ,QACjBR,IAAUmB,MAAM,CAEdH,IAAKhB,IAAUS,OAIfW,aAAcpB,IAAUI,UAG5B7B,OAAQyB,IAAUmB,MAAM,CACtBE,UAAWrB,IAAUI,OACrBzB,WAAYqB,IAAUI,OACtBkB,gBAAiBtB,IAAUQ,QAAQR,IAAUQ,QAAQR,IAAUS,SAC/Dc,oBAAqBvB,IAAUW,OAC9BT,WACHsB,YAAaxB,IAAUW,M,gNAGlB,IAAMc,EAAoB,CAC/B1B,GAAIC,IAAUC,OACdc,QAASf,IAAUW,M,gNAGd,IAAMe,EAAmB,CAC9B3B,GAAIC,IAAUC,OAAOC,WAErBa,QAASf,IAAUW,KACnBgB,SAAU3B,IAAUW,KACpBiB,iBAAkB5B,IAAUmB,MAAM,CAChCU,MAAO7B,IAAUC,OACjB6B,OAAQ9B,IAAUQ,QAAQR,IAAUC,UAEtC8B,YAAa/B,IAAUW,KACvBqB,mBAAoBhC,IAAUmB,MAAM,CAClCU,MAAO7B,IAAUC,OACjB6B,OAAQ9B,IAAUQ,QAAQR,IAAUC,UAEtCgB,QAASjB,IAAUS,OACnBJ,MAAOL,IAAUC,OACjBgC,WAAYjC,IAAUW,KACtBa,YAAaxB,IAAUW,KACvBO,QAASlB,IAAUQ,QAAQR,IAAUQ,QAAQR,IAAUC,SACvDiC,SAAUlC,IAAUW,KACpBG,QAASd,IAAUM,MAAM,MAACvF,EAAW,UAAW,WAChD0B,IAAKuD,IAAUC,OACfE,KAAMH,IAAUI,OAChB+B,GAAInC,IAAUI,Q,+MCtDT,IAAMgC,EAAa,CACxBC,QAASrC,IAAUsC,KACnBC,SAAUvC,IAAUS,OAAOP,WAC3BsC,UAAWxC,IAAUS,OAAOP,Y,yMAGvB,IAAMuC,EAAgB,CAC3BC,KAAM1C,IAAUS,OAChBkC,OAAQ3C,IAAUQ,QAAQR,IAAUS,S,gTCTT,Q,OAAA,Q,oBAAA,Q,sBAAA,M,wGAAA,Q,OAAA,Q,oBAAA,Q,sBAAA,M,8GAK+B,I,OAAA,I,oBAAA,I,sBAAA,E,uIAEzB,I,OAAA,I,oBAAA,I,sBAAA,E,8GAEQ,M,OAAA,M,oBAAA,M,sBAAA,I,sHAEL,M,OAAA,M,oBAAA,M,sBAAA,I,iHAEO,K,OAAA,K,oBAAA,K,sBAAA,G,wHAER,M,OAAA,M,oBAAA,M,sBAAA,I,gHAKI,K,OAAA,K,oBAAA,K,sBAAA,G,oHAEG,I,OAAA,I,oBAAA,I,sBAAA,E,uHAEd,I,OAAA,I,oBAAA,I,sBAAA,E,yGAEA,K,OAAA,K,oBAAA,K,sBAAA,G,yGAK6B,K,OAAA,K,oBAAA,K,sBAAA,G,uIAOrB,I,QAAA,I,qBAAA,I,uBAAA,E,iHACO,K,OAAA,K,oBAAA,K,sBAAA,G,wHAEtC,IAAMmC,EACX,+E,sLACK,IAAMC,EACX,2F,4LAE4C,a,OAAA,a,oBAAA,a,sBAAA,W,yHAEE,gB,OAAA,gB,oBAAA,gB,sBAAA,c,2HCjDrB,gB,OAAA,gB,oBAAA,gB,sBAAA,c,qHACQ,wB,OAAA,wB,oBAAA,wB,sBAAA,sB,6HACU,kC,OAAA,kC,oBAAA,kC,sBAAA,gC,uIACjB,iB,OAAA,iB,oBAAA,iB,sBAAA,e,sHACG,oB,OAAA,oB,oBAAA,oB,sBAAA,kB,yHACE,sB,OAAA,sB,oBAAA,sB,sBAAA,oB,2HAE1B,IAAMC,EAAa,SAACC,GAAD,OAAW,SAACC,GACpCA,EAAS,CACPhE,KATuB,cAUvBiE,QAASF,M,sLAIN,IAAMG,EAAc,SAACF,EAAUG,EAAOC,GAC3C,IAAMC,GAAY,IAAIC,MAAOC,UAS7B,OAPAP,EAAS,CACPhE,KAfwB,eAgBxBiE,aAHqClI,IAAbqI,EAAA,UAA4BA,EAA5B,YAAwCC,GAAcA,SAK3CtI,IAAjCoI,EAAMK,IAAIvK,OAAOwK,aACnBN,EAAMK,IAAIvK,OAAOwK,cAEZL,G,uLAGF,IAAMM,EAAiB,SAACN,GAAD,OAAc,SAACJ,EAAUW,GACrDX,EAAS,CACPhE,KAzB2B,kBA0B3BiE,QAASG,IAEX,IAAMD,EAAQQ,IACER,EAAMK,IAAIvK,OAAO2K,QACpB5I,aAA8CD,IAApCoI,EAAMK,IAAIvK,OAAO4K,gBACtCV,EAAMK,IAAIvK,OAAO4K,mB,0LAId,IAAMC,EAAmB,SAACC,GAAD,OAAsB,SAACf,EAAUW,GAC/D,IAAMR,EAAQQ,IACRK,EAAWb,EAAMK,IAAIvK,OAAO6K,iBAElC,QAAiB/I,IAAbiJ,EAAJ,CAGA,IAAMC,EAAWd,EAAMK,IAAIS,SAE3BD,EAAS,CACPD,mBACArB,KAAMuB,EAASA,SAASvB,KACxBC,OAAQ,CAACsB,EAASA,SAAS1B,SAAU0B,EAASA,SAASzB,WACvD0B,OAAQD,EAASC,OACjBC,UAAWF,EAASE,UACpBC,WAAYH,EAASG,WACrBC,aAAcJ,EAASI,kB,4LAIpB,IAAMC,EAAoB,SAACC,GAAD,MAAqB,CACpDvF,KA3DiC,sBA4DjCiE,QAASsB,I,6LAGJ,IAAMC,EAA6B,SAACC,GAAD,MAA8B,CACtEzF,KA/D2C,gCAgE3CiE,QAASwB,I,sMAGJ,IAAMC,EAAa,kBAAM,SAAC1B,EAAUW,GACzC,IAAMR,EAAQQ,SACwB5I,IAAlCoI,EAAMK,IAAIvK,OAAO0L,cACnBxB,EAAMK,IAAIvK,OAAO0L,iB,sLAId,IAAMC,EAAY,SAACC,GAAD,MAAa,CACpC7F,KAxE+B,oBAyE/BiE,QAAS4B,I,gfC9EEC,EAAoB,SAAC3B,GAAD,OAAWA,EAAMK,IAAIvK,OAAOsL,gB,+LAEtD,IAAMQ,EAA6B,SAAC5B,GAAD,OAAWA,EAAMK,IAAIvK,OAAOwL,yB,wMCC/D,IAAMO,EAAgB,SAAC7B,GAAD,OAAWA,EAAMK,IAAIyB,OAAO9E,M,2LAElD,IAAM+E,EAAwBC,YACnCH,GACA,SAACC,GAAD,OAAYA,EAAOG,QAAO,SAACC,GAAD,YAAkBtK,IAAXsK,EAAElF,W,2NAGrC,IAAMmF,EAAc,SAACC,EAAQC,GAAT,MAAqB,CACvCC,QAAQ,eAAMF,EAAOE,QAAd,GAA0BD,EAAOC,SACxCC,OAAO,GAAD,mBAAMH,EAAOG,QAAb,YAAwBF,EAAOE,WAGjCC,EAA2B,SAACC,EAAD,GAA8B,IAAlBjL,EAAiB,EAAjBA,MAAOC,EAAU,EAAVA,IAClD,IAAKgL,IAAYA,EAAQC,SAAU,OAAO,KAC1C,IAAMC,EAAmBF,EAAQC,SAASE,QAAO,SAACC,EAAkBC,GAMlE,GAJEA,EAAQC,YACRD,EAAQC,WAAWC,sBACnBF,EAAQC,WAAWC,qBAAqBC,OACxCH,EAAQC,WAAWC,qBAAqBC,MAAMpL,OAAS,EAC3C,CACZ,IAAMqL,EAAWJ,EAAQK,SAASC,YAAYR,QAC5C,SAACS,EAAqBC,EAAYC,GAChC,IAAMC,EAAiBV,EAAQC,WAAWC,qBAAqBC,MAAMM,GAMrE,OALqBC,GAAkBhM,GAASgM,GAAkB/L,IAEhE4L,EAAoBD,YAAYK,KAAKH,GACrCD,EAAoBJ,MAAMQ,KAAKD,IAE1BH,IAET,CAAED,YAAa,GAAIH,MAAO,KAE5B,IAAKC,EAASE,YAAYvL,OAAQ,OAAOgL,EAEzC,IAAMa,EAAe,eAChBZ,EADgB,CAEnBK,SAAS,eACJL,EAAQK,SADL,CAENC,YAAaF,EAASE,cAExBL,WAAW,eACND,EAAQC,WADH,CAERC,qBAAsB,CACpBC,MAAOC,EAASD,WAItBJ,EAAiBY,KAAKC,GAExB,OAAOb,IACN,IAKH,OAJqB,eAChBJ,EADgB,CAEnBC,SAAUC,KAKRgB,EAAsB3B,YAC1B,CAACL,EAAmBI,IACpB,SAACX,EAAgBU,GACf,IAAM8B,EAAoBxC,GAAkBA,EAAevJ,OAAS,EAC9DgM,EAAY/B,GAAUA,EAAOjK,OAAS,EAC5C,IAAK+L,IAAsBC,EAAW,OAAO,KAE7C,IAAMC,EAAY,CAChBtM,MAAO4J,EAAe,GAAGhB,UACzB3I,IAAK2J,EAAe,GAAGhB,WAwCzB,OAtCe0B,EAAOc,QACpB,SAACmB,EAAKC,GACJ,IAAKA,EAAMhH,KAAM,OAAO+G,EAExB,IAAME,EAAM,UAAMD,EAAMpH,GAAZ,SACNsH,EAAQ,CACZ5B,QAAQ,eACL2B,EAAS,CACRpI,KAAM,UACNmB,KAAMwF,EAAyBwB,EAAMhH,KAAM8G,KAG/CvB,OAAQ,CACN,CACE3F,GAAG,GAAD,OAAKoH,EAAMpH,GAAX,SACFqH,SACApI,KAAM,OACNsI,MAAO,CACL,aAAc,EACd,aAAcH,EAAM9G,QAGxB,CACEN,GAAG,GAAD,OAAKoH,EAAMpH,GAAX,UACFqH,SACApI,KAAM,SACNoG,OAAQ,CAAC,QAAS,CAAC,iBAAkB,CAAC,GAAI,UAAU,GAAM,GAC1DkC,MAAO,CACL,gBAAiB,EACjB,eAAgBH,EAAM9G,UAK9B,OAAOiF,EAAY4B,EAAKG,KAE1B,CAAE5B,QAAS,GAAIC,OAAQ,QAMvB6B,EAA4BpC,YAChC,CAACJ,EAA4BG,IAC7B,SAACT,EAAyBQ,GACxB,IAAM8B,EAAoBtC,GAA2BA,EAAwBzJ,OAAS,EAChFgM,EAAY/B,GAAUA,EAAOjK,OAAS,EAC5C,IAAK+L,IAAsBC,EAAW,OAAO,KAE7C,IAAMC,EAAY,CAChBtM,MAAO8J,EAAwB,GAAGlB,UAClC3I,IAAK6J,EAAwB,GAAGlB,WA8BlC,OA5Be0B,EAAOc,QACpB,SAACmB,EAAKC,GACJ,IAAKA,EAAMhH,KAAM,OAAO+G,EAExB,IAAME,EAAM,UAAMD,EAAMpH,GAAZ,oBACNsH,EAAQ,CACZ5B,QAAQ,eACL2B,EAAS,CACRpI,KAAM,UACNmB,KAAMwF,EAAyBwB,EAAMhH,KAAM8G,KAG/CvB,OAAQ,CACN,CACE3F,GAAG,GAAD,OAAKoH,EAAMpH,GAAX,oBACFqH,SACApI,KAAM,OACNsI,MAAO,CACL,aAAc,EACd,aAAc,WAKtB,OAAOhC,EAAY4B,EAAKG,KAE1B,CAAE5B,QAAS,GAAIC,OAAQ,QAMhB8B,EAAkBrC,YAC7B,CAAC2B,EAAqBS,IACtB,SAACE,EAAaC,GACZ,OAAKA,EACEpC,EAAYmC,EAAaC,GADID,K,4QCjKV,kB,OAAA,kB,oBAAA,kB,sBAAA,gB,4GAEvB,IAAME,EAAkB,CAC7BC,KAAM,Q,uMAGkB,e,OAAA,e,oBAAA,e,sBAAA,a,wGAEnB,IAAMC,EAAwB,CACnCC,OAAQ,EACRC,SAAU,G,6MAGL,IAAMC,EAA6B,CACxCC,gBAAiB,EACjBC,OAAQ,G,kNAGyB,wB,OAAA,wB,oBAAA,wB,sBAAA,sB,iHAE5B,IAAMC,GAAyB,CACpCvC,QAAS,UACTwC,OAAQ,U,00BCnBK,YAACC,EAAaC,GAG3B,OAFAC,KAAiBC,YAAc,kBACHC,KAASJ,EAC9BK,CAAoBJ,I,uCCWvBK,GAAsB,SAACN,EAAa/G,GAAkC,IAAjBsH,EAAgB,uDAAP,GAC5DC,EAAO,GAwBb,OAtBEvH,GAAmB,CAAC,OAAOwH,SAAQ,SAACC,EAAQrC,GAC5C,IAAM4B,EAAY,GACH,OAAXS,IAAkD,IAA/BH,EAAOrH,sBAC5B+G,EAAUU,aAAe,IAAI1F,KAAKyF,EAAO,IAAIE,cAC7CX,EAAUY,WAAa,IAAI5F,KAAKyF,EAAO,IAAIE,eAEzCL,EAAOO,kBACTb,EAAUc,EAAIR,EAAOO,gBAAgBC,EACrCd,EAAUe,EAAIT,EAAOO,gBAAgBE,EACrCf,EAAUgB,EAAIV,EAAOO,gBAAgBzG,MAGvC,IAAMjG,EAAM8M,GAAclB,EAAaC,KAGN,IAA/BM,EAAOrH,sBACNqH,EAAOY,wBACRZ,EAAOY,uBAAuBC,QAAQ/C,IAAU,IAEhDmC,EAAKjC,KAAKnK,MAGPoM,GAMIa,GAAkB,SAACC,EAAYjN,EAAO4E,GAGjD,IAHmF,IAAjBsH,EAAgB,uDAAP,GACrEgB,EAAW,GACXf,EAAOF,GAAoBgB,EAAYrI,EAAiBsH,GACrDiB,EAAW,EAAG7O,EAAS6N,EAAK7N,OAAQ6O,EAAW7O,EAAQ6O,IAC9DD,EAAShD,MAAK,IAAItK,MAAgBwN,WAAWjB,EAAKgB,GAAWnN,IAG/D,OAAOkN,G,gMAGF,IAAMG,GAAuB,SAACC,GAAD,OAClCA,EAAY5E,QAAO,SAAC6E,GAAD,OAAiC,OAAhBA,M,qMAS/B,IAAMC,GAAY,SAACC,EAAmBC,GAC3C,IAgBIC,EAhBElK,EAAO,GAEPmK,EAA0BC,KAAMJ,GAAmB,SAACK,GAAD,OAAOA,EAAEhI,UAAUxH,UAEtEyP,EAAkBL,EAAQhF,QAAO,SAACsF,GACtC,OAAIP,EAAkB,SAAuCpP,IAAjCoP,EAAkB,GAAGO,KAC/CC,QAAQC,KAAR,iBAAuBF,EAAvB,gEACO,MAKXD,EAAgB3B,SAAQ,SAAC+B,GACvB1K,EAAK0K,GAAO,IAAIvQ,aAAagQ,MAU/B,IANA,IAAIQ,EAAmB,EAEjBC,EAAe,SAACF,GACpB1K,EAAK0K,GAAKG,IAAIX,EAAaQ,GAAMC,IAG1BpE,EAAQ,EAAG1L,EAASmP,EAAkBnP,OAAQ0L,EAAQ1L,EAAQ0L,IACrE2D,EAAeF,EAAkBzD,GACjC+D,EAAgB3B,QAAQiC,GACxBD,GAAoBT,EAAa7H,UAAUxH,OAE7C,OAAOmF,G,0LAgBF,IAAM8K,GAAsB,SAAC9K,EAAMxB,EAAYwK,EAAiB+B,GACrE,IAAMC,OAAwCpQ,IAArBmQ,EAAiC,GAAKA,EAEzDxI,EAAOyG,EAAgBzG,KACvB0I,EAAmBC,KAAQC,oBAAoB5I,GAC/C6I,EAAgCF,KAAQG,iCAAiC9I,GACzE+I,EAAoBJ,KAAQK,qBAAqBhJ,GAGjD0H,EAAU,GACVuB,EAAaC,OAAOC,KAAKlN,GAC/BgN,EAAW7C,SAAQ,SAACgD,GAClB1B,EAAQ0B,IAAK,KAIf,IAAIC,EAAgB,GAAGC,OAAOL,IACR,IAAlBvB,EAAQ6B,OAAgBF,EAAcnF,KAAK,WACxB,IAAnBwD,EAAQ8B,QAAiBH,EAAcnF,KAAK,YACtB,IAAtBwD,EAAQ5H,YACVuJ,EAAcnF,KAAK,UACnBmF,EAAcnF,KAAK,YAEF,IAAfwD,EAAQrK,IACVgM,EAAcnF,KAAK,UAKpB,CAAC,WAAY,YAAa,YAAYkC,SAAQ,SAAChK,QACtB/D,IAApB4D,EAAWG,KAAiD,IAA3BH,EAAWG,GAAKqN,QACnDC,KAAKL,EAAejN,MAIxBsN,KAAKL,EAAe,QAAS,UAC7BA,EAAgBM,KAAKN,GAMrB,IAJA,IAAMO,EAAYnM,EAAKoC,SAASvH,OAE1BuR,EAAY,GACZC,EAAc,GAzCsE,WA0CjF9F,EAAW1L,GAClB,IAAIyR,EAAQ,GACZd,EAAW7C,SAAQ,SAACgD,GAClBW,EAAMX,GAAK3L,EAAK2L,GAAGpF,MAGrB,IAAMgG,EAAYtC,EAAQsC,UACtBD,EAAMC,UACNrB,KAAQsB,2BAA2BF,EAAMG,UAlD2C,EAqD/DC,aAAc,CAACJ,EAAMjK,UAAWiK,EAAMlK,UAAW,GArDc,oBAqDjFuK,EArDiF,KAqDzEC,EArDyE,KAuExF,GAjBAN,EAAMK,OAASA,EACfL,EAAMM,OAASA,EAEX3C,EAAQ6B,QACVQ,EAAMO,OAAS3B,KAAQ4B,cACrBR,EAAMR,MACNV,EACAH,IAGAhB,EAAQ8B,SACVO,EAAMxL,QAAUoK,KAAQ6B,gBAAgBT,EAAMP,OAAQT,IAEpDrB,EAAQrK,KACV0M,EAAMU,OAASV,EAAM1M,KAGlBwM,EAAUG,GAAY,CACzBF,EAAY5F,KAAK8F,GACjB,IAAMU,EAAQ,GAKd,OAJArB,EAAcjD,SAAQ,SAAC4B,GACrB0C,EAAM1C,GAAU,CAAC+B,EAAM/B,OAEzB6B,EAAUG,GAAaU,EACvB,WAEF,IAAMA,EAAQb,EAAUG,GACxBX,EAAcjD,SAAQ,SAAC4B,GACrB0C,EAAM1C,GAAQ9D,KAAK6F,EAAM/B,QAxCpBhE,EAAQ,EAAG1L,EAASsR,EAAW5F,EAAQ1L,EAAQ0L,IAAS,EAAxDA,GAiDT,OAHA8F,EAAY1D,SAAQ,SAAC4D,GACnBvB,EAAiBuB,GAAaH,EAAUG,MAEnCvB,G,oMAGF,IAAMkC,GAAyB,SAACD,EAAO1G,EAAOtF,GASnD,OARyBwK,OAAOC,KAAKzK,GAAckM,OAAM,SAACzL,GACxD,YAAqB9G,IAAjBqS,EAAMvL,IAKHT,EAAaS,GAAO4H,QAAQ2D,EAAMvL,GAAO6E,KAAW,M,uMAK/D,IAOa6G,GAAkB,SAACC,EAAUC,EAAWC,EAAYC,EAAUC,GAKzE,IAJA,IAAMC,EAAU,GAERf,EAAgDW,EAAhDX,OAAQC,EAAwCU,EAAxCV,OAAQe,EAAgCL,EAAhCK,4BAHoE,WAKnFC,GACP,IAAMX,EAAQI,EAASO,GACvB,QAAchT,IAAVqS,EAAqB,iBACzB,IAR0F,eAQjFnS,GACP,IAAM+S,EAAKZ,EAAMN,OAAO7R,GAClBgT,EAAKb,EAAML,OAAO9R,GAExB,KACI2S,EAAe5S,QApBS,SAACoS,EAAO1G,EAAOxF,GAI/C,OAH4BA,EACzBkE,QAAO,SAAC2I,GAAD,OAAkB,IAAXA,EAAEG,QAChBC,MAAK,SAAC/I,GAAD,OAAYiI,GAAuBD,EAAO1G,EAAOtB,EAAOhE,iBAiB/BgN,CAA0BhB,EAAOnS,EAAG2S,KAC/DI,GAAMlB,EAASgB,GACfE,GAAMlB,EAASgB,GACfG,GAAMlB,EAASe,GACfG,GAAMlB,EAASe,EACf,CACA,IAAMO,EAAS,GAEfzC,OAAOC,KAAKuB,GAAOtE,SAAQ,SAAC+B,GAC1BwD,EAAOxD,GAAOuC,EAAMvC,GAAK5P,MAE3BoT,EAAO3B,UAAYqB,EACnBF,EAAQjH,KAAKyH,KAjBRpT,EAAI,EAAGA,EAAImS,EAAMN,OAAO9R,OAAQC,IAAM,EAAtCA,IAHF8S,EAAIL,EAAYK,EAAIJ,EAAUI,IAAK,EAAnCA,GAwBT,OAAOF,G,0YChPkC,gC,OAAA,gC,oBAAA,gC,sBAAA,8B,4IACD,+B,OAAA,+B,oBAAA,+B,sBAAA,6B,2IACK,oC,OAAA,oC,oBAAA,oC,sBAAA,kC,gJACN,8B,OAAA,8B,oBAAA,8B,sBAAA,4B,0IACA,8B,OAAA,8B,oBAAA,8B,sBAAA,4B,0IAEzC,IAAIS,IPkBkC,EOjBlCC,IAAc,EAElBC,SAASC,iBAAiB,WAAW,SAASC,GAC9B,KACVA,EAAMC,UAERL,IADAC,IAAeA,IPa0B,IADP,EORlC5D,QAAQiE,IAAR,mBAAwBL,GAAc,OAAS,MAA/C,kBAMJ,IAAMM,GAAqB,SAACC,GAC1B,IAAIpM,EAAOqM,KAAKC,KAAKF,EAAeR,IAChCW,GAAiB,EAKrB,OAJIvM,EPRqD,KOSvDA,EPTuD,GOUvDuM,GAAiB,GAEZ,CACLC,SAAUxM,EACVyM,SAAUzM,EACVuM,mBAIEG,GAAsB,kBAAM,SAACpM,EAAUW,GAC3C,IAAMR,EAAQQ,IAMd,IAL8BR,EAAMK,IAAI6L,aAAaC,sBAK1BtU,OAAQ,CACjC,IAAMuU,EAA4BpM,EAAMK,IAAI6L,aAAaG,yBAEzDxM,EAASyM,GAAaF,IACtBvM,EAAS,CACPhE,KA5CmC,iCAiD5B0Q,GAAmB,SAACC,GAAD,OAAc,SAAC3M,GAC7CA,EAAS,CACPhE,KApDqC,4BAqDrCiE,QAAS0M,IAGX3M,EAASoM,Q,wMAGX,IAAMQ,GAAiB,eAACC,EAAD,+DAAyC,SAAC7M,EAAUW,GACzE,IAAMR,EAAQQ,IACRmM,EAAsB3M,EAAMK,IAAI6L,aAAaS,oBAC/CC,EAAc,GACZC,EAAqB,GAE3B,IAAoC,IAAhCH,EACFE,EAAcD,MACT,CACL,IAAMG,EAAqB9M,EAAMK,IAAI6L,aAAaY,mBAElDH,EAAoBhH,SAAQ,SAACoH,QACuCnV,IAA9DkV,EAAmBE,MAAK,SAAC9K,GAAD,OAAOA,EAAE+K,MAAQF,EAAYE,QACvDL,EAAYnJ,KAAKsJ,MAIrBD,EAAmBnH,SAAQ,SAACuH,QACwCtV,IAA9D+U,EAAoBK,MAAK,SAAC9K,GAAD,OAAOA,EAAE+K,MAAQC,EAAWD,QACvDJ,EAAmBpJ,KAAKyJ,EAAWD,QAKzC,IAAME,EAAkBP,EAAYvM,KAAI,SAAC6B,GAAD,OAAOA,EAAE+K,OAOjDL,EAAYjH,SAAQ,SAACyH,GACnBvN,EAASwN,GAAQD,OAEnBvN,EAAS,CACPhE,KAhGsC,6BAiGtCiE,QAAS6M,IAGX9M,EAAS,CACPhE,KApG2C,kCAqG3CiE,QAAS,CACPqN,kBACAN,wBAIJhN,EAASyN,MACTzN,EAASoM,QAMLsB,GAAsBC,MAHC,SAAC3N,GAC5BA,EAAS4M,QAEgD,KAE9CgB,GAAiC,eAACf,EAAD,+DAAyC,SACrF7M,EACAW,GAgBA,IAAMkN,EAAclN,IAAWH,IAAIS,SAC7BA,EAAW4M,EAAY5M,SAI7B,GAAKA,EAAS6M,OAAU7M,EAAS8M,QAA4C,OAAlCF,EAAYG,kBAAvD,CAKA,IAAMC,EAAiB,IAAIC,KAA4BjN,GACjDC,EAAS,CACb+M,EAAeE,UAAU,CAAC,EAAG,IAC7BF,EAAeE,UAAU,CAAClN,EAAS6M,MAAO7M,EAAS8M,UAG9CK,EAAUlN,EA/Bd,GA+BQmN,EAAMnN,EA/Bd,KAgCkB,CAACkN,EAAG,GAAIC,EAAG,GAAIA,EAAG,GAAID,EAAG,IAAvCE,EAhCJ,KAgCOC,EAhCP,KAgCUC,EAhCV,KAgCaC,EAhCb,KAiCGC,EAA4B,GAE5BC,EAAS9C,GAAmB5K,EAASvB,MAC3C,IAA8B,IAA1BiP,EAAO1C,iBAA4D,IAAhCY,EAAvC,CAIA,GAAI2B,EAAI,KAAOF,GAAK,IAAK,CAEvB,IAAMM,EAAKJ,EAAI,IAAMF,EAAIA,EAAI,IAGvBO,EAAKL,EAAI,IAAMA,EAAI,IAAMA,EAC/BE,EAA0B9K,KAAK,CAC7B,CACE,CAACgL,EAAIH,GACL,CANO,QAMFA,GACL,CAPO,QAOFF,GACL,CAACK,EAAIL,GACL,CAACK,EAAIH,MAGTC,EAA0B9K,KAAK,CAC7B,CACE,EAbO,IAaF6K,GACL,CAACI,EAAIJ,GACL,CAACI,EAAIN,GACL,EAhBO,IAgBFA,GACL,EAjBO,IAiBFE,WAITC,EAA0B9K,KAAK,CAC7B,CACE,CAAC0K,EAAGG,GACJ,CAACD,EAAGC,GACJ,CAACD,EAAGD,GACJ,CAACD,EAAGC,GACJ,CAACD,EAAGG,MAKV,IAAMK,EAAO,CACX9S,KAAM,eACNuH,YAAamL,GAITK,EAAsBC,KAAUC,MAAMH,EAAMH,GAC5CO,EAAuBF,KAAUG,QAAQL,EAAMH,GAC/CS,EAAe,GAErBL,EAAoBjJ,SAAQ,SAACuJ,EAAQpX,GACnC,IAAMmV,EAAM8B,EAAqBjX,GACpBoX,EAAO,IACR,GACVD,EAAaxL,KAAK,CAChBuC,gBAAiB,CACfC,EAAGiJ,EAAO,GACVhJ,EAAGgJ,EAAO,GACV3P,KAAM2P,EAAO,IAEfjC,WAKNpN,EAAS,CACPhE,KA/NuC,8BAgOvCiE,QAASmP,KAKiB,KAFAvB,EAAYyB,WAAarO,EAASvB,MAG5DM,EAAS4M,GAAeC,IAExBa,GAAoB1N,O,sNAIjB,IAAMuP,GAAsB,SAACF,EAAQG,GAAT,OAAmC,SAACxP,EAAUW,GAE/E,IAAMmO,EAAO,CACX9S,KAAM,QACNuH,YAAa,CAAC8L,EAAO7P,UAAW6P,EAAO9P,WAEnCG,EAAOiB,IAAWH,IAAIS,SAASA,SAASvB,KAIxC+P,EAAO,CAAC/P,EAAMA,EAAO,EAAGA,EAAO,GAClCc,KAAI,SAAC8F,GAAD,OAAOuF,GAAmBvF,MAC9B9F,KAAI,SAACmO,GAAD,OAAYK,KAAUG,QAAQL,EAAMH,MACxCnO,KAAI,SAAC2O,GAAD,OAAaA,EAAQ,MAQ5BnP,EAAS0P,GANE,eACNL,EADM,CAETI,SAIyCD,M,2MCnQZ,sB,OAAA,sB,oBAAA,sB,sBAAA,oB,6HACS,+B,OAAA,+B,oBAAA,+B,sBAAA,6B,sIACR,uB,OAAA,uB,oBAAA,uB,sBAAA,qB,8HACD,sB,OAAA,sB,oBAAA,sB,sBAAA,oB,6HACE,wB,OAAA,wB,oBAAA,wB,sBAAA,sB,+HACC,yB,OAAA,yB,oBAAA,yB,sBAAA,uB,gIAElC,yD,OAAA,yD,oBAAA,yD,sBAAA,uD,gKACiC,wB,OAAA,wB,oBAAA,wB,sBAAA,sB,+HACE,0B,OAAA,0B,oBAAA,0B,sBAAA,wB,iIACF,wB,OAAA,wB,oBAAA,wB,sBAAA,sB,+HACK,6B,OAAA,6B,oBAAA,6B,sBAAA,2B,oIASxC,SAASG,GAAiCC,EAAoBrS,GAC5D,IAAMsS,EAAqBD,EAAmB,GAAGrP,UAC3CuP,EAAmBF,EAAmB,GAAGrP,UACzCwP,EAAU,GAQhB,OAPAxS,EAAqBuI,SAAQ,SAACvE,EAAgBmC,GAC5C,IAAMsM,EAAsBzO,EAAe,GACjBA,EAAe,IAChBsO,GAAsBG,GAAuBF,GACpEC,EAAQnM,KAAKF,MAGVqM,EAeT,SAASE,GACPC,EACA/J,EACAzM,EACA8M,EAJF,GAMG,IADC/M,EACF,EADEA,IAAK6E,EACP,EADOA,gBAAiBC,EACxB,EADwBA,oBAGxB,QAAYxG,IAAR0B,EACF,MAAM,IAAI0W,MAAM,iEAElB,IAAMC,EAAkB1J,GAAgBjN,EAAKC,EAAO4E,EAAiB,CACnE6H,kBACAK,yBACAjI,wBAEI8R,EAAmB1W,QAAQ2W,IAAIF,GAWrC,OATyB,IAAIzW,SAAQ,SAACC,GACpCyW,EAAiBE,MAAK,SAACvJ,GACrBpN,EAAQ,CACN4W,cAAeN,EACflJ,sBAiBR,SAASyJ,GAAezJ,EAAarL,EAAYwK,EAAiB+B,GAChE,IAAI/K,EAEEgK,EAAoBJ,GAAqBC,GAE/C,OADA7J,EAAO+J,GAAUC,EAAmByB,OAAOC,KAAKlN,IACf,IAA7BiN,OAAOC,KAAK1L,GAAMnF,OACb,GAGYiQ,GAAoB9K,EAAMxB,EAAYwK,EAAiB+B,GAW9E,SAASwI,GAASC,EAAUC,GAAuD,IAAvCC,EAAsC,4DAAX9Y,EACrE,OAAO,SAACiI,EAAUW,GAChB,IAAMR,EAAQQ,IACRmQ,EAAW5Q,EAAYF,EAAUG,EAAOwQ,EAASI,KAAK,MACtDrX,EAAQyG,EAAMK,IAAIvK,OAAOyD,MACzBsX,EAAgB7Q,EAAMK,IAAIyQ,QAAQD,cAClCE,EAAe,GACrBP,EAAS7K,SAAQ,SAAC/I,GAChBmU,EAAanU,GAAb,YAAuBiU,EAAcjU,GAAIkS,UAE3C,IAAMkC,EAAc,GAEpBR,EAAS7K,SAAQ,SAACoK,GAChB,IAAMkB,EAAqBJ,EAAcd,GAAS3U,OADtB,iBAEsC6V,GAA1D9S,EAFoB,EAEpBA,gBAAiBC,EAFG,EAEHA,oBAAqB5C,EAFlB,EAEkBA,WACxClC,EAAM2X,EAAmB/S,UAAU4Q,MAEzC2B,EAAe9K,SAAQ,SAACuL,GAEtB,IAAI9D,EAAO2D,EAAahB,GAAS/C,MAAK,SAAC9K,GAAD,OAAOA,EAAE+K,MAAQiE,EAAcjE,OAChEG,IAEHA,EAAO,CACLH,IAAKiE,EAAcjE,IACnBkE,6BAA8B,IAEhCJ,EAAahB,GAAStM,KAAK2J,IAK7B,IAAMgE,OACyBxZ,IAA7B8Y,EACIG,EAAcd,GAASsB,8BACvBX,EAAyBX,GAEzBuB,EAA+BC,KACnCH,EACAhE,EAAK+D,8BAGDK,EAAc1B,GAClBC,EACAmB,EAAclL,gBACdzM,EACA+X,EACA,CACEhY,MACA6E,kBACAC,wBAIJ4S,EAAYvN,KAAK+N,GAEjBA,EAAYpB,MAAK,YAAqC,IAAlCC,EAAiC,EAAjCA,cAAexJ,EAAkB,EAAlBA,YACjCuG,EAAK+D,6BAA+BjI,KAClCkE,EAAK+D,6BAA6BtI,OAAOyI,IAE3ClE,EAAKpQ,KAAOsT,GACVzJ,EACArL,EACA0V,EAAclL,gBACdoH,EAAKpQ,MAGP6C,EAAS,CACPhE,KApKuB,sBAqKvBiE,QAAS,CACPiQ,QAASM,EACTjD,mBAOV5T,QAAQ2W,IAAIa,GAAaZ,MAAK,WAC5BvQ,EAASU,EAAeoQ,IACxB9Q,EAAS0M,GAAiBkE,EAAepQ,KAAI,SAAC+M,GAAD,OAAUA,EAAKH,aAW3D,SAASI,GAAQ6D,GACtB,OAAO,SAACrR,EAAUW,GAChBX,EAAS,CACPhE,KApM4B,qBAqM5BiE,QAASoR,IAEX,IAAMO,EAAuBjR,IAAWH,IAAIyQ,QAAQD,cAC9Ca,EAA0BjJ,OAAOC,KAAK+I,GAAsBxP,QAChE,SAACrF,GAAD,OAA6C,IAArC6U,EAAqB7U,GAAIgB,WAG/B8T,EAAwB7Z,QAC1BgI,EAAS0Q,GAASmB,EAAyB,CAACR,MAnMJ,mC,OAAA,mC,oBAAA,mC,sBAAA,iC,oUA4MvC,IAAM5E,GAAe,SAACgD,GAAD,MAAW,CACrCzT,KAhNmC,wBAiNnCiE,QAASwP,I,wNAGJ,IAAMhC,GAAoB,iBAAO,CACtCzR,KApNiC,wBAwNnC,SAAS8V,GAAqB5B,GAC5B,OAAO,SAAClQ,EAAUW,GAEhB,IAAMiQ,EAAiBjQ,IAAWH,IAAIyQ,QAAQL,eAC9C5Q,EAAS0Q,GAAS,CAACR,GAAUU,K,6NAI1B,IAAMmB,GAAkB,SAACC,EAAOpC,GAAR,OAA+B,SAAC5P,GAC7D,IAAMzC,EAAuByU,EAAMzW,OAAO+C,gBAC1C0B,EAAS,CACPhE,KA7O6B,oBA8O7BiE,QAAQ,eACH+R,EADE,CAGLR,8BAA+B7B,GAC7BC,EACArS,QAKgB,IAAlByU,EAAMjU,SACRiC,EAAS8R,GAAqBE,EAAMjV,O,kMAIjC,IAAMkV,GAAqB,SAAClV,GAAD,OAAQ,SAACiD,GACzCA,EAAS,CACPhE,KA1PgC,uBA2PhCiE,QAAS,CACPlD,UAWC,SAASmV,GAA+BtC,GAC7C,OAAO,SAAC5P,EAAUW,GAChB,IAAMR,EAAQQ,IACRqQ,EAAgB7Q,EAAMK,IAAIyQ,QAAQD,cAClCmB,EAAsB,GAE5BvJ,OAAOC,KAAKmI,GAAelL,SAAQ,SAACoK,GAClC,IAAMkC,EAAepB,EAAcd,GAC7B5R,EAAkB8T,EAAa7W,OAAO+C,gBACtC+T,EAAmCD,EAAaZ,8BAChDc,EAAmC3C,GACvCC,EACAtR,GAGIiU,EAAeb,KACnBY,EACAD,GAGIG,EAAiBd,KACrBW,EACAC,IAGEC,EAAava,QAAUwa,EAAexa,SAExCgI,EAAS,CACPhE,KAjSR,uDAkSQiE,QAAS,CACPiQ,UACAoC,mCACAE,oBAIFD,EAAava,SACfma,EAAoBjC,GAAWqC,MAKnC,IAAME,EAA2B7J,OAAOC,KAAKsJ,GACzCM,EAAyBza,QAC3BgI,EACE0Q,GAAS+B,EAA0BtS,EAAMK,IAAIyQ,QAAQL,eAAgBuB,K,sZAwFtE,SAASO,KACd,MAAO,CACL1W,KAhZ6B,oBAiZ7BiE,QAAS,CACP0S,SAAS,EACTC,kBAAkB,IAKjB,SAASlD,GAA2BjF,EAAW+E,GACpD,OAAO,SAACxP,EAAUW,GAChB,IAAMR,EAAQQ,IADe,EAvFX,SAACR,EAAOsK,EAAW+E,GACvC,IAAM9M,EAASvC,EAAMK,IAAIyQ,QAAQD,cAC3BtG,EAAa8E,EAAsB,GACnC7E,EAAW6E,EAAsB,GACjCqD,EAAgB,GAEtBjK,OAAOC,KAAKnG,GAAQoD,SAAQ,SAACoK,GAC3B,IAAM8B,EAAQtP,EAAOwN,GACrB,IAAsB,IAAlB8B,EAAMjU,QAAV,CAGA,IAGM+U,EAH+BrI,EAAUgF,KAAKjP,KAAI,SAAC4M,GAAD,OACtD4E,EAAM/C,MAAM9B,MAAK,SAACI,GAAD,OAAUA,EAAKH,MAAQA,QAEUhL,QAClD,SAACmL,GAAD,YAAmBxV,IAATwV,QAAoCxV,IAAdwV,EAAKpQ,QAGjCyN,EAAiBoH,EAAM9T,QAC7B,GAAI4U,EAAe9a,OAAQ,CACzB,IAAM+a,EAAWD,EAAe,GAChCD,EAAcjP,KAAK,CACjBoO,QACAnH,QAASN,GAAgBwI,EAAS5V,KAAMsN,EAAWC,EAAYC,EAAUC,UAK/E,IAKIoI,EAEAC,EACAN,EACAO,EACAC,EAVEC,EAAuBP,EAAczQ,QACzC,SAACiR,GAAD,OAAkBA,EAAaxI,QAAQ7S,OAAS,KAWlD,GAAoC,IAAhCob,EAAqBpb,OACvB2a,GAAU,OACL,GAAIS,EAAqBpb,OAAS,EAGvCgb,GAAY,MACP,CAML,IAAMnI,GAJNqI,EAAqBE,EAAqB,IAIPvI,QAEnC,GAAuB,IAAnBA,EAAQ7S,OACV2a,GAAU,OAGe9H,EAAQzI,QAC/B,SAACkR,GAAD,YACYvb,IAATub,EAAEvW,IAAoBuW,EAAEvW,GAAK,QAAyBhF,IAAlBub,EAAEC,aAA6BD,EAAEC,YAAc,KAEnEvb,OACnBgb,GAAY,EAGZC,GADAE,EAAeK,KAAO3I,GAAS,SAACyI,GAAD,OAAOA,EAAEnJ,WACVnS,OAAS,EAO7C,MAAO,CAAE2a,UAASK,YAAWC,iBAAgBE,eAAcnB,WAFtBja,IAAvBmb,EAAmC,GAAKA,EAAmBlB,OAkBHyB,CAClEtT,EACAsK,EACA+E,GAHMwC,EAFqB,EAErBA,MAAOW,EAFc,EAEdA,QAASK,EAFK,EAELA,UAAWC,EAFN,EAEMA,eAAgBE,EAFtB,EAEsBA,cAOnC,IAAdH,QACajb,IAAbia,EAAMjV,IACNoD,EAAMK,IAAIyQ,QAAQyC,mBAAmBxD,UAAY8B,EAAMjV,GAWvDiD,EAAS,CACPhE,KAhbyB,oBAibzBiE,QAAS,CACP+R,WAXQja,IAAVia,EACI,KACA,CACEjV,GAAIiV,EAAMjV,GACVc,UAAWmU,EAAMnU,UACjBC,QAASkU,EAAMlU,QACfvC,OAAQyW,EAAMzW,QAMlBoX,UACAC,kBAAgC,IAAdI,IAAyC,IAAnBC,EACxCU,sBAAoC,IAAdX,EACtBG,kBAIJnT,EA3CG,CACLhE,KAhZ6B,oBAiZ7BiE,QAAS,CACP0S,SAAS,EACTC,kBAAkB,M,uZA4CjB,IAAMgB,GAAyB,SAAC7W,EAAImT,GAAL,MAAkB,CACtDlU,KAxbsC,2BAybtCiE,QAAS,CACPlD,KACAmT,a,yMAIG,IAAM2D,GAAgC,iBAAO,CAClD7X,KA/b4C,mC,gNAkcvC,IAAM8X,GAAsB,SAACC,EAAWC,GAAZ,OAA0C,SAC3EhU,EACAW,GAEA,GAAkB,OAAdoT,EAAJ,CAIA,IAAME,EAAiBtT,IAAWH,IAAIyQ,QAAQD,cAG9C+C,EAAUjO,SAAQ,SAACoO,GACjB,IAAMhE,EAAUgE,EAASnX,GACnBoX,EAAYF,EAAe/D,QACfnY,IAAdoc,EAEFnU,EAAS+R,GAAgBmC,EAAUF,KAE/BG,EAAUpW,UAAYmW,EAASnW,UAAgC,IAArBmW,EAASnW,SACrDiC,EAAS8R,GAAqB5B,IAG9BiE,EAAUpW,UAAYmW,EAASnW,SAC/BoW,EAAUnW,MAAQkW,EAASlW,KAC3BmW,EAAUlW,UAAYiW,EAASjW,SAC/BkW,EAAUjW,UAAYgW,EAAShW,SAC/BiW,EAAU3V,cAAgB0V,EAAS1V,aAGnCwB,EAAS,CACPhE,KA3egC,6BA4ehCiE,QAAS,CACPlD,GAAImX,EAASnX,GACbgB,QAASmW,EAASnW,QAClBC,IAAKkW,EAASlW,IACdC,QAASiW,EAASjW,QAClBC,QAASgW,EAAShW,QAClBM,YAAa0V,EAAS1V,mBAQhCoK,OAAOC,KAAKoL,GAAgBnO,SAAQ,SAACsO,GAC9BL,EAAU5G,MAAK,SAACkH,GAAD,OAAOA,EAAEtX,KAAOqX,MAClCpU,EAASiS,GAAmBmC,YA1C9BzM,QAAQC,KAAK,qD,kRC3dS,e,OAAA,e,oBAAA,e,sBAAA,a,qHACE,iB,OAAA,iB,oBAAA,iB,sBAAA,e,uHACG,oB,OAAA,oB,oBAAA,oB,sBAAA,kB,0HACG,uB,OAAA,uB,oBAAA,uB,sBAAA,qB,6HACA,uB,OAAA,uB,oBAAA,uB,sBAAA,qB,6HACJ,mB,OAAA,mB,oBAAA,mB,sBAAA,iB,yHACK,wB,OAAA,wB,oBAAA,wB,sBAAA,sB,8HAE5B,IAAM0M,GAAY,SAACpT,GAAD,MAAa,CACpClF,KATwB,aAUxBiE,QAASiB,I,2LAGJ,IAAMqT,GAAc,SAACtT,EAAUF,GAAX,OAAgC,SAACf,GAC1DA,EAAS,CACPhE,KAdwB,eAexBiE,QAASgB,IAEXjB,EAAS4N,MACT5N,EAASc,EAAiBC,M,6LAGrB,IAAMyT,GAAiB,SAACC,GAAD,OAAoB,SAACzU,GACjDA,EAAS,CACPhE,KAtB2B,kBAuB3BiE,QAASwU,IAEXzU,EAAS4N,Q,gMAKX,IAAM8G,GAAe,SAACC,GAAD,IAAYpV,EAAZ,uDAAuB,KAAMC,EAA7B,uDAAyC,KAAME,EAA/C,uDAAsD,KAAtD,OAA+D,SAACM,GACnFA,EAAS,CACPhE,KA/B8B,qBAgC9BiE,QAAS,CACP0U,YACApV,WACAC,YACAE,UAGJM,EAAS4N,MACT5N,EAASc,OAGE8T,GAAmB,SAAC3T,GAAD,OAAc,SAACjB,GAC7CA,EAAS0U,GAAa,KAAMzT,EAAStB,OAAO,GAAIsB,EAAStB,OAAO,GAAIsB,EAASvB,S,kMAGxE,IAAMmV,GAAgB,kBAAM,SAAC7U,GAClCA,EAAS,CACPhE,KA/C0B,mBAiD5BgE,EAAS4N,MACT5N,EAASc,O,+LAGJ,IAAMgU,GAAuB,SAACvV,EAAUC,GAAX,IAAsBE,EAAtB,uDAA6B,KAA7B,OAAsC,SAACM,GACzEA,EAAS0U,GTzCiC,ESyCUnV,EAAUC,EAAWE,M,sMAGpE,IAAMqV,GAAc,SAAC7T,GAAD,OAAY,SAAClB,EAAUW,GAChD,IAAMR,EAAQQ,IACRqU,EAAKC,aAAU,CACnB/T,OAAQ,CAAC,CAACA,EAAOgU,OAAQhU,EAAOiU,QAAS,CAACjU,EAAOkU,OAAQlU,EAAOmU,SAChEvH,MAAO3N,EAAMK,IAAIS,SAASA,SAAS6M,MACnCC,OAAQ5N,EAAMK,IAAIS,SAASA,SAAS8M,OACpCuH,QAAS,KAEXtV,EAAS0U,GAAa,KAAMM,EAAGzV,SAAUyV,EAAGxV,UAAWwV,EAAGtV,S,6LAGrD,IAAM6V,GAAuB,SAACC,GAAD,OAAoB,SAACxV,GACvD,IAAMyV,EAAY,CAAC,EAAG,GAChBC,EAAgB,CAACF,EAAe1H,MAAO0H,EAAezH,QAGtD4H,EAAeC,aAAcH,EAAWD,EAAeK,yBACvDC,EAAmBF,aAAcF,EAAeF,EAAeK,yBAC/DE,EAAkBJ,EAAa,GAAKH,EAAeQ,MACnDC,EAAmBH,EAAiB,GAAKN,EAAeQ,MAGxDE,EAAYV,EAAerH,UAAUsH,GACrCU,EAAYX,EAAerH,UAAUuH,GAQ3C1V,EAAS,CACPhE,KAxF+B,sBAyF/BiE,QAAS,CACP8V,kBACAE,mBACA/U,OAZW,CACbkV,MAAOF,EAAU,GACjBG,MAAOF,EAAU,GACjBG,KAAMJ,EAAU,GAChBK,KAAMJ,EAAU,S,sMC1FK,c,OAAA,c,oBAAA,c,sBAAA,Y,uHACE,gB,OAAA,gB,oBAAA,gB,sBAAA,c,yHACG,mB,OAAA,mB,oBAAA,mB,sBAAA,iB,4HAE9B,IAAMK,GAAa,SAACC,GAGlB,OAFgB,aAAO,GAAIC,IAAKD,EAAUnT,WAChBqT,eAAe,QAAS,CAAEC,sBAAuB,KAsEvEC,GAAa,SAACJ,EAAWvG,EAAS9L,GACtC,IAAMnB,EAAU,CACdC,WAAYuT,EAAUvT,YAElB4T,EAtEU,SAACL,GAA8B,IAAnBrS,EAAkB,uDAAT,KAK/B2S,EACH3S,QAA8BrM,IAApBqM,EAAO4S,eAA4Djf,IAAlCqM,EAAO4S,SAAS,cAExD5S,EAAO4S,SAAS,cADhB,GAGA9T,EAAauT,EAAUvT,WAGvB+T,EAAarO,OAAOC,KAAK4N,EAAUvT,YAAYd,QACnD,SAAC8U,GAAD,OAAmC,IAA5BH,EAAiB/e,aAA+DD,IAA/Cgf,EAAiB5J,MAAK,SAACgK,GAAD,OAAQA,EAAGpa,KAAOma,QAG5EJ,EAASG,EAAWzW,KAAI,SAAC4W,GAC7B,IAAMxe,ENfyB,wBMejBwe,EAAmCZ,GAAWC,GAAavT,EAAWkU,GAC9EC,EAAMN,EAAiB5J,MAAK,SAACgK,GAAD,OAAQA,EAAGpa,KAAOqa,MAAa,GAC3DE,EAAQD,EAAIC,OAASF,EAC3B,MAAO,CACLra,GAAIqa,EACJE,QACA1e,QACA2e,MAAM,GAAD,OAAKD,EAAL,aAAe1e,GACpB4e,OAAQH,EAAIG,OACZC,OAAQJ,EAAII,WAIVC,EACJZ,EAAO3J,MAAK,SAACpC,GAAD,OAAoB,IAAbA,EAAE0M,WACrBX,EAAO3J,MAAK,SAACpC,GAAD,MAAgB,SAATA,EAAEhO,OACrB+Z,EAAO3J,MAAK,SAACpC,GAAD,MAAgB,OAATA,EAAEhO,OACrB+Z,EAAO,GAKT,YAHkB/e,IAAd2f,IACFA,EAAUD,QAAS,GAEdX,EA8BQa,CAAUlB,EAAWrS,GACpCnB,EAAQ6T,OAASA,EAGjB,IAAMY,EAAYZ,EAAO3J,MAAK,SAACpC,GAAD,OAAoB,IAAbA,EAAE0M,UAGvC,OAFAxU,EAAQsU,WAAsBxf,IAAd2f,EAA0BxH,EAAUwH,EAAU9e,MAEvDqK,GAGI2U,GAAiB,SAACC,EAAiBtY,EAAUC,EAAWsY,EAAYC,GAAnD,OAAmE,SAC/F/X,EACAW,GAEwB,UAApBkX,GACF7X,EFmXgD,CAClDhE,KA/b4C,mCE8E5C,IAUIgc,EAVEC,EAAetX,IAAWH,IAAI6D,MAAM6T,SAASC,OAE7CzM,EAAQ,CACZnM,WACAC,YACAqD,SAAU,IAINuV,EAA2BzX,IAAWH,IAAIyQ,QAAQyC,mBAGxD,IAAyC,IAArC0E,EAAyBzF,QAAkB,CAC7C,IAAMQ,OACsCpb,IAA1CqgB,EAAyBjF,aACrB,GACAiF,EAAyBjF,aACzBjQ,EAAqC,IAAxBiQ,EAAanb,OAAe,GAAKmb,EAAa,GAC3DH,GAA0D,IAA9CoF,EAAyBxF,iBACrCyF,GACU,IAAdrF,IAAwE,IAAlDoF,EAAyBzE,sBAC1C,EACDR,EAAanb,OACnBggB,EAAuB,CACrBhF,YACAqF,QACArG,MAAO,CACLjV,GAAIqb,EAAyBpG,MAAMjV,GACnCub,MAAO,iBAETpV,cAEFwI,EAAM7I,SAASe,KAAKoU,GAKtB,IAKMO,EAAkB,IACFT,GAAc,IACtBhS,SAAQ,SAAC2Q,GACrB,IAAMvG,EAR8B,SAACuG,GAAD,YACN1e,IAA7B0e,EAAUzE,MAAMgF,UAA0BP,EAAUzE,MAAMgF,SAAS,WACpEP,EAAUzE,MAAM5N,OAMAoU,CAA8B/B,GACxCrS,EAAS6T,EAAaxV,QAAQyN,GAC9BjN,EAAO,aACX+O,MAAO,CACLjV,GAAImT,EACJoI,MAAO7B,EAAUzE,MAAMgF,UAAYP,EAAUzE,MAAMgF,SAAS,kBAE3DH,GAAWJ,EAAWvG,EAAS9L,IAGpC,IAAqC,IAAjCqS,EAAUvT,WAAWuV,QAAkB,CAEzC,IAAMC,EAtGO,SAACjC,EAAWsB,GAC7B,IAAMY,EAAYlC,EAAUvT,WAAW0V,WAEjCC,EAAWd,EADAtB,EAAUrS,QAkB3B,OAhBgB,IAAIzK,SAAQ,SAACC,EAASC,GACpCgf,EAASC,wBAAwBH,GAAW,SAACI,EAAMrZ,GACjDmZ,EAASG,iBAAiBL,EAAW,GAAI,GAAG,SAACM,EAAMC,IAC7CH,GAAQE,IACVpf,IAEF,IAAMsf,EAAmBD,EAAS1Y,KAAI,SAAC4Y,GAAD,OACpCvC,GAAWuC,EAAO3C,EAAUzE,MAAMjV,GAAI8b,MAExCjf,EAAQ,CACN8F,OACAyZ,8BAuFmBE,CAAW5C,EAAWsB,GAAaxH,MAAK,SAACkI,GAC9DxV,EAAQwV,QAAUA,EAClBxV,EAAQoV,MAAQI,EAAQU,iBAAiBnhB,UAE3CugB,EAAgB3U,KAAK8U,GACrBzV,EAAQ+P,WAAY,OAEpB/P,EAAQ+P,WAAY,EAEtBtH,EAAM7I,SAASe,KAAKX,MAGtBtJ,QAAQ2W,IAAIiI,GAAiBhI,MAAK,WAGhC7E,EAAMsH,UACJtH,EAAM7I,SAAS7K,OAAS,GAAK0T,EAAM7I,SAASsI,MAAK,SAAClI,GAAD,OAAmC,IAAtBA,EAAQ+P,kBAG3Cjb,IAAzBigB,IAAsE,IAAhCA,EAAqBK,MAC7D3M,EAAM2M,OAAS,EAEf3M,EAAM2M,MAAQ3M,EAAM7I,SAASE,QAAO,SAACsV,EAAOpV,GAE1C,OAAOoV,GADYpV,EAAQoV,OAAS,KAEnC,GAGe,IAAhB3M,EAAM2M,QACR3M,EAAMzI,QAAUyI,EAAM7I,SAAS,IAIjC,IAAMyW,GAA4D,IAA1C3Y,IAAWH,IAAIvK,OAAOqjB,gBAIxCC,EAAkB5Y,IAAWH,IAAIvK,OAAO+c,UAAUtH,GAGxD,GAFAA,EAAMsH,UAAYuG,EAEdD,GACsB,UAApBzB,IAAmD,IAApBnM,EAAMsH,UAAoB,CAC3DhT,EFqNC,CACLhE,KAhZ6B,oBAiZ7BiE,QAAS,CACP0S,SAAS,EACTC,kBAAkB,KExNhB,IAAM4G,EAAc9N,EAAM7I,SAAS,GAAG4V,SAAW/M,EAAM7I,SAAS,GAAG4V,QAAQ/Y,KAC3EM,EAAS8U,GAAqBvV,EAAUC,EAAWga,IAIvD,IAAI3X,EAAS6J,EAAM7I,SAAS7K,OAAS,UAAY,MACzB,IAApB0T,EAAMsH,YACRnR,EAAS,WAGX7B,EAAS,CACPhE,KA/MwB,iBAgNxBiE,QAAS4B,IAGX,IAAMb,EACgB,UAApB6W,EAA8BlX,IAAWH,IAAIvK,OAAOwjB,QAAU9Y,IAAWH,IAAIvK,OAAOyjB,aAErE3hB,IAAbiJ,GACFA,EAAS0K,Q,gjBC1N4B,K,OAAA,K,oBAAA,K,sBAAA,G,gIACL,K,OAAA,K,oBAAA,K,sBAAA,G,2HAG/B,IAAMiO,GAAa,CACxBC,OAAQ,EACRC,MAAO,GACPC,OAAQ,GACRC,MAAO,GACPC,YAAa,IACbC,UAAW,IACXC,KAAM,IACNC,OAAQ,IACRC,KAAM,K,+MAID,IAAMC,GAAgB,SAACC,EAAK1hB,GACjC,IAAI4D,EAAS,KAIb,OAHAoM,OAAO2R,QAAQD,GAAKxU,SAAQ,SAAC0U,GACvBA,EAAM,KAAO5hB,IAAO4D,EAASge,EAAM,OAElChe,G,yLAcF,IAAMie,GAAW,SAACC,EAAIC,EAAIC,GAC/B,IAMIC,EANEC,EAAIJ,EAAK,IACTK,EAAIJ,EAAK,IACTK,EAAIJ,EAAK,IAETze,EAAM4P,KAAK5P,IAAI2e,EAAGC,EAAGC,GACrB9e,EAAM6P,KAAK7P,IAAI4e,EAAGC,EAAGC,GAErB1H,EAAInX,EAEJ8e,EAAI9e,EAAMD,EACVqS,EAAY,IAARpS,EAAY,EAAI8e,EAAI9e,EAE9B,GAAIA,IAAQD,EACV2e,EAAI,MACC,CACL,OAAQ1e,GACN,KAAK2e,EACHD,GAAKE,EAAIC,GAAKC,GAAKF,EAAIC,EAAI,EAAI,GAC/B,MACF,KAAKD,EACHF,GAAKG,EAAIF,GAAKG,EAAI,EAClB,MACF,KAAKD,EACHH,GAAKC,EAAIC,GAAKE,EAAI,EAClB,MACF,QACEJ,EAAI,EAGRA,GAAK,EAGP,MAAO,CAACA,EAAGtM,EAAG+E,I,oLAIT,IAAM4H,GAAW,SAACC,EAAIC,EAAIC,GAC/B,IAAMR,EAAMM,EA7EE,IA6EcG,WA7Ed,KA6EqC,EAC7C/M,EA7EO,MA6EH6M,EAAgB,EAAKA,EA7ElB,IA6EiCE,WA7EjC,KA8EPhI,EA9EO,MA8EH+H,EAAgB,EAAKA,EA9ElB,IA8EiCC,WA9EjC,KAgFPrjB,EAAI8T,KAAKwP,MAAMV,GACf9P,EAAI8P,EAAI5iB,EACRujB,EAAIlI,GAAK,EAAI/E,GACbkN,EAAInI,GAAK,EAAIvI,EAAIwD,GACjBlM,EAAIiR,GAAK,GAAK,EAAIvI,GAAKwD,GACvBmN,EAAMzjB,EAAI,EACV6iB,EAAI,CAACxH,EAAGmI,EAAGD,EAAGA,EAAGnZ,EAAGiR,GAAGoI,GACvBX,EAAI,CAAC1Y,EAAGiR,EAAGA,EAAGmI,EAAGD,EAAGA,GAAGE,GACvBV,EAAI,CAACQ,EAAGA,EAAGnZ,EAAGiR,EAAGA,EAAGmI,GAAGC,GAE7B,MAAO,CAAEZ,EAAG/O,KAAK4P,MA5FH,IA4FSb,GAAcC,EAAGhP,KAAK4P,MA5F/B,IA4FqCZ,GAAcC,EAAGjP,KAAK4P,MA5F3D,IA4FiEX,K,oLAIjF,IAAMY,GAAmB,SAAC5d,GAAD,OAASkd,GAASld,EAAK,GAAI,MAEvC6d,GAAiB,SAAC7d,GAC7B,IAAM8d,EAAMF,GAAiB5d,GAC7B,MAAM,OAAN,OAAc8d,EAAIhB,EAAlB,aAAwBgB,EAAIf,EAA5B,aAAkCe,EAAId,EAAtC,M,0LAGK,IAAMe,GAAiB,SAACD,EAAKE,GAClC,IAAMtkB,EAAM,CAAC,IAAK,IAAK,KACpB8I,KAAI,SAACyb,GACJ,IAAMC,EAAeJ,EAAIG,GACrBE,EAAaD,EAAa5f,SAAS,IAIvC,OAHI4f,EAAe,KACjBC,EAAU,WAAOA,IAEZA,KAERpL,KAAK,IAER,MAAM,GAAN,QADuB,IAARiL,EAAe,IAAM,MACpC,OAAmBtkB,I,0LAGd,IAAM0kB,GAAoB,SAACpe,EAAKge,GACrC,IAAMF,EAAMF,GAAiB5d,GAC7B,OAAO+d,GAAeD,EAAKE,I,6LAG7B,IAGaK,GAAoB,SAACre,GAChC,QAAYjG,IAARiG,GAA6B,OAARA,EAAzB,CACA,IALkCse,EAK5BC,EAAiB3T,OAAOC,KAAK8Q,IAAYnZ,KAAI,SAACqH,GAAD,OAAS8R,GAAW9R,MACjE2U,GAN4BF,EAMete,EAAhBue,EALrBxZ,QAAO,SAAC0Z,EAAMC,GAAP,OAAiB3Q,KAAK4Q,IAAID,EAAOJ,GAAQvQ,KAAK4Q,IAAIF,EAAOH,GAAQI,EAAOD,MAM3F,OAAOpC,GAAcV,GAAY6C,K,6LAG5B,IAAMI,GAAW,SAACC,GACvB,IAAMrgB,EAAS,4CAA4CsgB,KAAKD,GAChE,OAAOrgB,EACH,CACEse,EAAGiC,SAASvgB,EAAO,GAAI,IACvBue,EAAGgC,SAASvgB,EAAO,GAAI,IACvBwe,EAAG+B,SAASvgB,EAAO,GAAI,KAEzB,M,oLAGN,IAAMwgB,GAAkB,SAAClB,EAAK7d,GAAN,qBAA0B6d,EAAIhB,EAA9B,aAAoCgB,EAAIf,EAAxC,aAA8Ce,EAAId,EAAlD,aAAwD/c,EAAxD,MAEXgf,GAAkB,SAACjf,EAAKC,GACnC,IAAM6d,EAAMF,GAAiB5d,GAC7B,OAAOgf,GAAgBlB,EAAK7d,I,2LAGvB,IAAMif,GAAY,SAACL,EAAK5e,GAC7B,IAAM6d,EAAMc,GAASC,GACrB,OAAOG,GAAgBlB,EAAK7d,I,qLAGvB,IAAMkf,GAAoB,SAACC,GAAD,OAvJK,GAuJaA,G,6LAE5C,IAAMC,GAAoB,SAACrf,GAAD,OAC/B+N,KAAK4P,MAAO3d,EAAM,IAAP,K,6LAEN,IAAMsf,GAAU,SAACtf,GAAD,OAASA,EAAM,K,mLAE/B,IAAMuf,GAAuB,SAAClgB,EAAOW,GAC1C,YAAYjG,IAARiG,EACKoe,GAAkBpe,GAAK,GAGzBX,G,oMCnKYmgB,G,WACnB,WAAYC,EAAaC,EAAqB1f,GAAkC,IAA7B2f,EAA4B,4EAG7EpkB,KAAKqkB,MAAQ,IAAIC,KAAKC,UAAUC,kBZOC,IYPwC,CACvE/H,OAAO,EACPgI,OAAO,EACPC,UAAU,EACVC,KAAK,KAEoB,IAAvBP,IACFpkB,KAAKqkB,MAAMO,UAAYN,KAAKO,YAAYC,QAG1C9kB,KAAK+kB,YAAc,GAEnB,IAAMC,EAAsB,IAAIV,KAAKW,UACnC,EACA,EACAC,GACAA,IAEFllB,KAAKmlB,kBAAoB,IAAIb,KAAKc,QAAQlB,EAAac,GACvDhlB,KAAKqlB,iBAAiBlB,EAAqB1f,GAE3CzE,KAAKslB,mB,+DAILtlB,KAAKulB,aAAe,CAClB1Y,EAAG,IAAI9O,aZnBwB,KYoB/B+O,EAAG,IAAI/O,aZpBwB,KYqB/BkQ,EAAG,IAAIlQ,aZrBwB,KYsB/BiX,EAAG,IAAIjX,aZtBwB,MYwBjCiC,KAAKwlB,kBAAoB,I,sCAGX3Y,EAAGC,EAAGmB,EAAG+G,GACvBhV,KAAKulB,aAAa1Y,EAAE7M,KAAKwlB,mBAAqB3Y,EAC9C7M,KAAKulB,aAAazY,EAAE9M,KAAKwlB,mBAAqB1Y,EAC9C9M,KAAKulB,aAAatX,EAAEjO,KAAKwlB,mBAAqBvX,EAC9CjO,KAAKulB,aAAavQ,EAAEhV,KAAKwlB,mBAAqBxQ,EAC9ChV,KAAKwlB,sB,6CAGgBrB,GACrBnkB,KAAKqlB,iBAAiBlB,K,gCAItBnkB,KAAK+kB,YAAc,KACnB/kB,KAAKqkB,MAAMoB,QAAQ,CAAE9F,UAAU,M,yCASyB,IAAzCwE,EAAwC,uDAAlB,KAAM1f,EAAY,uDAAN,KAC3CihB,EAAe1lB,KAAKmlB,kBAAkBtU,MAAM8U,QAOlD,GAL4B,OAAxBxB,IAEFuB,EAAa7Y,EAAIqY,GAA0Bf,EAAsBA,GAGvD,OAAR1f,EAAc,CAChB,IAAIof,EAAeC,GAAkBrf,GAChBmhB,KAAjB/B,IACFA,EAAe,GAEjB6B,EAAa5Y,EZvEgB,EYuEZ+W,EAAqC,EAClDA,EAAe,IACjB6B,EAAa5Y,GAAK+W,GAItB7jB,KAAKmlB,kBAAkBtU,MAAQ6U,EAC/B1lB,KAAKmlB,kBAAkBU,W,+BAIvB,IAAMC,EAAW9lB,KAAKwlB,kBACtBxlB,KAAK+lB,oBAEL,IAAK,IAAIrnB,EAAI,EAAGA,EAAIonB,EAAUpnB,IAAK,CACjC,IAAMsnB,EAAShmB,KAAKqkB,MAAM1E,SAASjhB,GAC7BsW,EAAIhV,KAAKulB,aAAavQ,EAAEtW,GAC9BsnB,EAAOC,aAAajmB,KAAKulB,aAAa1Y,EAAEnO,GAAIsB,KAAKulB,aAAazY,EAAEpO,GAAIsW,EAAGA,GACvEgR,EAAOvB,MAAQzkB,KAAKulB,aAAatX,EAAEvP,GAIrC,IADA,IAAMwnB,EAAalmB,KAAKqkB,MAAM1E,SAASlhB,OAC9BC,EAAIonB,EAAUpnB,EAAIwnB,EAAYxnB,IAAK,CAC3BsB,KAAKqkB,MAAM1E,SAASjhB,GAC5BmO,GAAK,O,0CAKd,IAEMsZ,EAFWnmB,KAAKwlB,kBACCxlB,KAAKqkB,MAAM1E,SAASlhB,OAI3C,GAAI0nB,GAAS,KAIX,IAFA,IAAMC,EAAW5T,KAAK7P,IAAI,KAAMwjB,GAEvBznB,EAAI,EAAGA,EAAI0nB,EAAU1nB,IAC5BsB,KAAKqkB,MAAMgC,cAAc,GAI7B,GAAIF,EAAQ,EAAG,CACb,IAAMG,EAAQ9T,KAAK5P,IAAI,IAAMujB,GAE7BnmB,KAAKumB,YAAYD,M,kCAITE,GACV,IAAK,IAAI9nB,EAAI,EAAGA,EAAI8nB,EAAK9nB,IAAK,CAC5B,IAAMoT,EAAS,IAAIwS,KAAKmC,OAAOzmB,KAAKmlB,mBACpCrT,EAAO4U,OAAO7Z,EAAI,GAClBiF,EAAO4U,OAAO5Z,EAAI,GAElBgF,EAAOjF,GAAK,IAGZ7M,KAAKqkB,MAAMsC,SAAS7U,Q,2bC/H1B,IACM8U,GAAsB,SAAC/Z,EAAGC,EAAG+Z,GAGjC,MAAO,CAJC,EAAI,KAEIA,EAAE,GAAKha,EAAIga,EAAE,GAAK/Z,EAAI+Z,EAAE,KAFhC,EAAI,KAGIA,EAAE,GAAK/Z,EAAI+Z,EAAE,OAIzBC,G,kLAEF9mB,KAAK+mB,W,6CAIL/mB,KAAKgnB,a,2CAILhnB,KAAKinB,Y,uDAG0BC,GAC3BA,EAAUC,yBAA2BnnB,KAAKwG,MAAM2gB,wBAClDnnB,KAAKonB,2BAA2BF,EAAUC,0B,+BAIpC,IAAD,EACoEnnB,KAAKwG,MAAxEiS,EADD,EACCA,MAAO4O,EADR,EACQA,UAAWF,EADnB,EACmBA,uBAAwBG,EAD3C,EAC2CA,qBAClDtnB,KAAKunB,UAAY,GACjBvnB,KAAKwnB,eACH/O,EAAMzW,QAAUyW,EAAMzW,OAAOylB,UAAYhP,EAAMzW,OAAOylB,UAAYH,EAEpEtnB,KAAK0nB,uBAAuB1nB,KAAKwnB,eAAe1c,OAChD9K,KAAKonB,2BAA2BD,GAEhCnnB,KAAKqkB,MAAQ,IAAIC,aAEjB+C,EAAUV,SAAS3mB,KAAKqkB,S,+CAGoC,IAAvCvZ,EAAsC,uDAA9BQ,EAAsBC,OAEjDvL,KAAK2nB,oBADc,kBAAV7c,EACkBQ,EAAsBR,EAAM8c,eAE5B9c,EAE7B9K,KAAK6nB,iC,iDAGoBV,GACzBnnB,KAAK8nB,yBACwB,IAA3BX,EACI1b,EAA2BC,gBAC3BD,EAA2BE,OACjC3L,KAAK6nB,iC,qDAGyB,IAAD,OAEvBE,EACJ/nB,KAAK2nB,sBAAwBrc,EAAsBC,OAASvL,KAAK8nB,wBAA0B,EACvFE,EAAgBhoB,KAAK2nB,oBAAsBI,EAC7CC,IAAkBhoB,KAAKmkB,sBAG3BnkB,KAAKmkB,oBAAsB6D,EAC3B3Y,OAAO9J,OAAOvF,KAAKunB,WAAWhb,SAAQ,SAAC0b,GACrCA,EAASC,uBAAuB,EAAK/D,2B,gCAI9B,IAAD,SACgCnkB,KAAKwG,MAArC7B,EADA,EACAA,QAASuf,EADT,EACSA,YAAazL,EADtB,EACsBA,MAE9B,GACY,OAAVA,QACUja,IAAVia,QACgBja,IAAhBia,EAAM/C,QACY,IAAlB+C,EAAMjU,QAJR,CAUAxE,KAAKqkB,MAAM7f,SAAU,EACrBxE,KAAKqkB,MAAMI,MAAQhM,EAAM/T,QAiBzB,IAfA,IAAMgR,EAAQ+C,EAAM/C,MACdyS,EAAa1P,EAAMhU,IACnB2jB,OACQ5pB,IAAZmG,GAAyBA,EAAQlG,OAC7BkG,EAGGkE,QAAO,SAAC2I,GAAD,OAAkB,IAAXA,EAAEG,QAChB1K,KAAI,SAACuK,GAAD,YAAkBhT,IAAVgT,EAAE/M,IAAoB,IAAM+M,EAAE/M,IAAI1B,cACjD,CAAColB,EAAWplB,YACZslB,EAAoBhZ,OAAOC,KAAKtP,KAAKunB,WAGrCe,EAAUxY,KAAKsY,EAAgB3Y,OAAO4Y,IAEnC3pB,EAAI,EAAGA,EAAI4pB,EAAQ7pB,OAAQC,IAAK,CACvC,IAAM+F,EAAM6jB,EAAQ5pB,IACkB,IAAlC0pB,EAAgBlb,QAAQzI,KAMY,IAApC4jB,EAAkBnb,QAAQzI,KAE5BzE,KAAKunB,UAAU9iB,GAAOzE,KAAKuoB,gBAAgBrE,EAAalkB,KAAKmkB,oBAAqB1f,IAEpFzE,KAAKunB,UAAU9iB,GAAK6gB,qBARlBtlB,KAAKwoB,iBAAiBxoB,KAAKunB,UAAU9iB,WAC9BzE,KAAKunB,UAAU9iB,IAUrB2jB,EAAgB3pB,SACrBiX,EAAMnJ,SAAQ,SAACyH,GACb,EAAKyU,gCAAgC,CACnC7kB,KAAMoQ,EAAKpQ,KACX8kB,WAAY/jB,EAAQlG,OACpB0pB,kBAIJC,EAAgB7b,SAAQ,SAACoc,GACvB,EAAKpB,UAAUoB,GAAaC,kBA/C5B5oB,KAAKqkB,MAAM7f,SAAU,I,yDAmD0C,IAAjCZ,EAAgC,EAAhCA,KAAM8kB,EAA0B,EAA1BA,WAAYP,EAAc,EAAdA,WAClD,GAAKvkB,EAML,IAPgE,MAKiB5D,KAAKwG,MAA9E2K,EALwD,EAKxDA,WAAYC,EAL4C,EAK5CA,SAAU1J,EALkC,EAKlCA,SAAU/C,EALwB,EAKxBA,QAASkkB,EALe,EAKfA,aAAcC,EALC,EAKDA,cAEtD3Y,EAAYgB,EAAYhB,EAAYiB,EAAUjB,IAAa,CAClE,IAAMU,EAAQjN,EAAKuM,GAEnB,GAAKU,EAEL,IAAK,IAAI1G,EAAQ,EAAG4e,EAAMlY,EAAMN,OAAO9R,OAAQ0L,EAAQ4e,EAAK5e,IAAS,CACnE,IAAI1F,OAAG,OACSjG,IAAZmG,GAA0BA,EAAQlG,SACpCgG,EAAM0jB,GAER,IAAK,IAAIa,EAAK,EAAGA,EAAKN,EAAYM,IAAM,CACtC,IAAMngB,EAASlE,EAAQqkB,GACvB,GAAIlY,GAAuBD,EAAO1G,EAAOtB,EAAOhE,cAAe,CAC7DJ,EAAMoE,EAAOpE,IACb,OAKJ,QAAYjG,IAARiG,EAAJ,CASA,IAAI8L,EAASM,EAAMN,OAAOpG,GACtB0e,EAAe,GAAKtY,EAASsY,EAE/BtY,GAAU,IACDsY,EAAe,GAAKtY,EAASuY,IACtCvY,GAAU,KAGZ,IAAM0Y,EAAU1Y,EAAS7I,EAAS+U,MAC5ByM,EAAUrY,EAAML,OAAOrG,GAASzC,EAAS+U,MACzC0M,EAAMzhB,EAAS0hB,sBAjC8C,EAoC9C,IAAnB1hB,EAAS2hB,MACLzC,GAAoBqC,EAASC,EAASC,GACtCG,aAAc,CAACL,EAASC,GAAUC,GAtC2B,oBAmC5Dtc,EAnC4D,KAmCzDC,EAnCyD,KAwC/DD,GAAK,IAAMA,EAAInF,EAAS6M,MAAQ,IAAMzH,GAAK,IAAMA,EAAIpF,EAAS8M,OAAS,IACzExU,KAAKunB,UAAU9iB,GAAK8kB,gBAClB1c,EACAC,EACA+D,EAAMnM,QAAUmM,EAAMnM,QAAQyF,GAASnK,KAAKwnB,eAAegC,eAC3D3Y,EAAMJ,OAASI,EAAMJ,OAAOtG,GAASnK,KAAKwnB,eAAeiC,kB,sCAOnDvF,EAAaC,EAAqB1f,GAChD,IAAMwjB,EAAW,IAAIhE,GACnBC,EACAC,EACA1f,EACAzE,KAAK2nB,sBAAwBrc,EAAsBE,UAGrD,OADAxL,KAAKqkB,MAAMsC,SAASsB,EAAS5D,OACtB4D,I,iCAIP5Y,OAAO9J,OAAOvF,KAAKunB,WAAWhb,QAAQvM,KAAKwoB,iBAAiB1nB,KAAKd,OACjEA,KAAKqkB,MAAMoB,QAAQ,CAAE9F,UAAU,IACT3f,KAAKwG,MAAnB6gB,UACEqC,YAAY1pB,KAAKqkB,S,uCAGZ4D,GACfjoB,KAAKqkB,MAAMqF,YAAYzB,EAAS5D,OAChC4D,EAASxC,Y,+BAIT,OAAO,S,GApNgBkE,IAAMC,WAsOlB9C,M,qNClOf,IAgEM+C,G,4MACJjjB,MAAQ,CACNkjB,WAAW,G,EAsEbC,aAAe,SAAC5X,GACTA,EAAM6X,QAAQvrB,QAGnB,EAAKwrB,YAAY9X,EAAM6X,QAAQ,GAAGE,QAAS/X,EAAM6X,QAAQ,GAAGG,U,EAG9DC,YAAc,SAACjY,GACb,EAAK8X,YAAY9X,EAAM+X,QAAS/X,EAAMgY,U,EAmCxCE,QAAU,YACqB,IAAzB,EAAKC,iBAA4B,EAAKC,aAAa9F,MAAQ,GAC7D,EAAK+F,sB,kEA/GPxqB,KAAK+mB,SACL/mB,KAAKyqB,SAAS,CACZX,WAAW,M,6CAKb9pB,KAAKgnB,a,uDAG0BE,GAC/BlnB,KAAKwG,MAAMwV,qBAAqBhc,KAAK0qB,SAAShjB,UAG5Cwf,EAAUxf,SAAS6M,QAAUvU,KAAKwG,MAAMkB,SAAS6M,OACjD2S,EAAUxf,SAAS8M,SAAWxU,KAAKwG,MAAMkB,SAAS8M,QAElDxU,KAAK2qB,oBAAoBzD,EAAUxf,SAAS6M,MAAO2S,EAAUxf,SAAS8M,U,+BAIhE,IAAD,EACmBxU,KAAKwG,MAAMkB,SAA7B6M,EADD,EACCA,MAAOC,EADR,EACQA,OAEfxU,KAAK4qB,KAAO,IAAItG,eAAiB,CAC/B/P,QACAC,SACAqW,aAAa,EACbC,WAAW,IAGb9qB,KAAK+qB,SAAW/qB,KAAK4qB,KAAKG,SAC1B/qB,KAAKgrB,OAAShrB,KAAK4qB,KAAKK,KACxBjrB,KAAKgrB,OAAOlgB,MAAM4Z,SAAW,WAE7B1kB,KAAKkrB,UAAUC,YAAYnrB,KAAKgrB,QAEhChrB,KAAKqkB,MAAQrkB,KAAK4qB,KAAKvG,MAEvB,IAAM+G,EApGe,SAAC3a,EAAQ4a,GAChC,IAAMC,EAAYrZ,SAASsZ,cAAc,UACnCC,EAASF,EAAUG,WAAW,MAC9BC,EAAoB,EAATjb,EAEjB6a,EAAU/W,MADS,EACDmX,EAAA,EAClBJ,EAAU9W,OHjC+B,GGiCtBkX,EHjCsB,GGmCzC,IAAK,IAAI7H,EAAe,EAAGA,EHnCc,GGmC8BA,IAAgB,CACrF,IAAM/W,EAAI4e,EAAW7H,EAAeA,EAC9B8H,EAAU7e,EAAI2D,EAGhB5D,EAAI4D,EACFmb,EAAWJ,EAAOK,qBACtBhf,EACA8e,EACAlb,EAAS4a,EACTxe,EACA8e,EACAlb,GAEIhM,EAAMmf,GAAkBC,GACxBiI,EAAYxJ,GAAe7d,GACjCmnB,EAASG,aAAa,EAAGD,GAEzB,IAAME,EAAWrK,GAASoC,GAAQtf,EAAM,IAAK,GAAI,KACjDmnB,EAASG,aAAa,EAAtB,eAAiCC,EAASzK,EAA1C,aAAgDyK,EAASxK,EAAzD,aAA+DwK,EAASvK,EAAxE,SAEA+J,EAAOS,UAAYL,EACnBJ,EAAOU,SAAS,EAAGpf,EAAG4e,EAAUA,GAGhC7e,GAAK6e,EAAW,EAChBF,EAAOW,YACPX,EAAOY,IAAIvf,EAAG8e,EAASlb,EAAQ,EAAG,EAAI+B,KAAK6Z,IAAI,GAC/Cb,EAAOS,UAAYH,EACnBN,EAAOc,OAGPzf,GAAK6e,EAAW,EAChBF,EAAOW,YACPX,EAAOY,IAAIvf,EAAG8e,EAAkB,GAATlb,EAAc,EAAG,EAAI+B,KAAK6Z,IAAI,GACrDb,EAAOS,UAAYH,EACnBN,EAAOc,OACPd,EAAOW,YACPX,EAAOY,IAAIvf,EAAG8e,EAAkB,IAATlb,EAAe,EAAG,EAAI+B,KAAK6Z,IAAI,GACtDb,EAAOe,UAAY,EACnBf,EAAOgB,YAAcV,EACrBN,EAAOiB,SAGT,OAAOnB,EAgDqBoB,Cd3HK,EAEQ,Kc0HvC1sB,KAAKkkB,YAAcI,WAAaqI,WAAWvB,GAE3CprB,KAAKuqB,aAAe,IAAIjG,aACxBtkB,KAAKqkB,MAAMsC,SAAS3mB,KAAKuqB,cAEzBvqB,KAAK4qB,KAAKgC,OAAOC,IAAI7sB,KAAKqqB,W,iCAI1BrqB,KAAK4qB,KAAKnF,Y,0CAGQqH,EAAeC,GACjC/sB,KAAK+qB,SAASiC,OAAOF,EAAeC,K,2CAGjBE,QACOzuB,IAAtBwB,KAAKuqB,gBAGG,IAAR0C,IACFjtB,KAAKsqB,iBAAkB,GAEzBtqB,KAAKuqB,aAAa9F,OAAgB,IAARwI,Ed7Ie,Gc6IgC,K,kCAc/DpgB,EAAGC,GAEb,IAAI9M,KAAKwG,MAAMiR,cAAc1G,OAAM,SAAC+J,GAAD,OAAyB,IAAlBA,EAAE7V,eAA5C,CAFgB,IAMRyC,EAAa1H,KAAK0qB,SAAlBhjB,SANQ,EAOcA,EAASkN,UAAU,CAAC/H,EAAGC,IAPrC,oBAOT7G,EAPS,KAOED,EAPF,KASZknB,EAAmBjnB,EACnBinB,EAAmB,IACrBA,GAAoB,IACXA,GAAoB,MAC7BA,GAAoB,KAbN,MAgBS5c,aAAc,CAAC4c,EAAkBlnB,GAAW,GAhBrD,oBAgBTuK,EAhBS,KAgBDC,EAhBC,KAkBVe,EdtK+B,GcsK2B7J,EAAS+U,MAEzEzc,KAAKwG,MAAMwP,oBACT,CACE/P,UAAWinB,EACXlnB,WACAuK,SACAC,SACAe,+BAEFvR,KAAKwG,MAAMyP,0B,4CAWbjW,KAAKsqB,iBAAkB,EACvBtqB,KAAKmtB,iCAA8B3uB,I,gDAIMA,IAArCwB,KAAKmtB,8BACPntB,KAAKmtB,4BAA8BpmB,KAAKqmB,OAE1C,IAAMC,GAAetmB,KAAKqmB,MAAQptB,KAAKmtB,6BAA+B,IAClE1I,EAAQzkB,KAAKuqB,aAAa9F,OAAS,EAAIzkB,KAAKuqB,aAAa9F,OAAS4I,EAClE5I,GAAS,IACXA,EAAQ,EACRzkB,KAAKsqB,iBAAkB,GAEzBtqB,KAAKuqB,aAAa9F,MAAQA,I,wCAIVtK,EAAoBmT,EAA0B7V,GAC9D,IACI8V,EAAqB,CACvB/pB,GAAI,gBACJgB,SAAS,EACTE,QAAS,EACTD,Id5NgC,Kc8N9B+oB,EAAmB,GAEvB,QACyBhvB,IAAvB2b,QAC6B3b,IAA7B2b,EAAmB1B,YACiBja,IAApC2b,EAAmBP,eACY,IAA/BO,EAAmBf,QACnB,CACA,IAAMqU,EAAchW,EAAc7D,MAAK,SAACkH,GAAD,OAAOA,EAAEtX,KAAO2W,EAAmB1B,MAAMjV,MAChF+pB,EAAkB,aAAKA,sBAAuBE,GAC9CD,EAAmBrT,EAAmBP,aAAa3S,KAAI,SAAC6K,GAAD,MAAa,CAClErN,IdzO8B,Ic0O9BI,aAAc,CACZ+L,OAAQ,CAACkB,EAAOlB,kBAGf,GAAiC,OAA7B0c,EAAmC,CAC5C,IAAMG,EAAchW,EAAc7D,MAAK,SAACkH,GAAD,OAAOA,EAAEtX,KAAO8pB,EAAyB7U,MAAMjV,MACtF+pB,EAAkB,aAAKA,sBAAuBE,GAC9CD,EAAmB,CACjB,CACE/oB,IdnP4B,IcoP5BI,aAAc,CACZ+L,OAAQ,CAAC0c,EAAyB9pB,OAK1C,MAAO,CACL+pB,qBACAC,sB,gCAGO,IAAD,SASJxtB,KAAKwG,MAPPL,EAFM,EAENA,KACAsR,EAHM,EAGNA,cACAxB,EAJM,EAINA,sBACAkE,EALM,EAKNA,mBACAmT,EANM,EAMNA,yBACA9Q,EAPM,EAONA,gBACAE,EARM,EAQNA,iBAEMhV,EAAa1H,KAAK0qB,SAAlBhjB,SACAoiB,EAAc9pB,KAAK4G,MAAnBkjB,UAEF3Y,EAAa8E,EAAsB,GACnC7E,EAAW6E,EAAsB,GACjCkR,EApQ2B,SAAChhB,GAAD,OAAUA,EdhBa,EcoRzBunB,CAA6BvnB,GAQ5D,IANmC,IAA/BgU,EAAmBf,SACrBpZ,KAAK2tB,sBAAqB,IAEO,IAA/BxT,EAAmBf,SACrBpZ,KAAK4tB,sBAEH5tB,KAAK+qB,UAAY/qB,KAAK+qB,SAASnlB,SAAoCpH,IAA9BwB,KAAK+qB,SAASnlB,GAAGioB,SAAwB,CAChF,IAAMC,EAAM9tB,KAAK+qB,SAASnlB,GAAGioB,WACjB,IAARC,GAAW1f,QAAQiE,IAAIyb,GAzBrB,MA4ByC9tB,KAAK+tB,kBACpD5T,EACAmT,EACA7V,GAHM8V,EA5BA,EA4BAA,mBAAoBC,EA5BpB,EA4BoBA,iBAM5B,OACE,yBACEQ,IAAK,SAACA,GACJ,EAAK9C,UAAY8C,GAEnBljB,MAAO,CAAE4Z,SAAU,YACnB0F,YAAapqB,KAAKoqB,YAClBL,aAAc/pB,KAAK+pB,eAEJ,IAAdD,GACC,kBAAC,WAAD,KACGrS,EAAcxQ,KAAI,SAACwR,GAAD,OACjB,kBAAC,GAAD,CACEnK,IAAKmK,EAAMjV,GACXiV,MAAOA,EACP9T,QAAS8T,EAAM9T,SAAW,GAC1B+C,SAAUA,EACVyJ,WAAYA,EACZC,SAAUA,EACV8S,YAAa,EAAKA,YAClBmD,UAAW,EAAKkD,aAChBpD,uBAAwBA,EACxBG,qBAAsB,GACtBuB,aAAcrM,EACdsM,cAAepM,YAGHle,IAAfwB,KAAKqkB,OACJ,kBAAC,GAAD,CACE/V,IAAI,cACJmK,MAAO8U,EACP5oB,QAAS6oB,EACT9lB,SAAUA,EACVyJ,WAAYA,EACZC,SAAUA,EACV8S,YAAalkB,KAAKkkB,YAClBmD,UAAWrnB,KAAKuqB,aAChBpD,uBAAwBA,EACxBG,qBAAsB,CAAEkC,eAAgB,EAAGC,YAAa,GACxDZ,aAAcrM,EACdsM,cAAepM,U,GA/PFuR,MAyQ7BpE,GAAeqE,UAAY,CACzB/nB,KAAM1C,IAAUS,OAChBuT,cAAehU,IAAUxG,MACzBgZ,sBAAuBxS,IAAUxG,MACjCkd,mBAAoB1W,IAAUI,OAC9BypB,yBAA0B7pB,IAAUI,OACpCmS,oBAAqBvS,IAAU0qB,KAC/BnS,qBAAsBvY,IAAU0qB,KAChC3R,gBAAiB/Y,IAAUS,OAC3BwY,iBAAkBjZ,IAAUS,QAG9B2lB,GAAeuE,aAAe,CAC5B1mB,SAAUjE,IAAUI,QAGPgmB,U,0NCtWf,IAEMwE,GAA0BzlB,YAC9B,CAHuB,SAAChC,GAAD,OAAWA,EAAMK,IAAIyQ,QAAQD,iBAIpD,SAACA,GAKC,OAJUpI,OAAOC,KAAKmI,GAAexQ,KAAI,SAACzD,GAAD,sBACpCiU,EAAcjU,UAOjB8qB,GAA2B1lB,YAC/B,CAACL,IACD,SAACP,GACC,IAAMumB,EAAiBvmB,EAAe,GAAGhB,UACnCwnB,EAAehc,KAAK5P,IACxBoF,EAAe,GAAGhB,UAClBgB,EAAe,GAAGhB,Uf3BK,Oe+BzB,MAAO,CAFY8H,KAAQsB,2BAA2Bme,GACrCzf,KAAQsB,2BAA2Boe,OAyBzCC,gBApBS,SAAC7nB,GAAD,MAAY,CAClCuT,mBAAoBvT,EAAMK,IAAIyQ,QAAQyC,mBACtCmT,yBAA0B1mB,EAAMK,IAAIyQ,QAAQ4V,yBAC5C5lB,SAAUd,EAAMK,IAAIS,SAASA,SAC7BvB,KAAMS,EAAMK,IAAIS,SAASA,SAASvB,KAClCsR,cAAe4W,GAAwBznB,GACvC4V,gBAAiB5V,EAAMK,IAAIS,SAAS8U,gBACpCE,iBAAkB9V,EAAMK,IAAIS,SAASgV,iBACrCzG,sBAAuBqY,GAAyB1nB,OAGvB,SAACH,EAAUioB,GAAX,MAAyB,CAClD1Y,oBAAqB,SAACF,EAAQG,GAC5BxP,EAASuP,GAAoBF,EAAQG,KAEvC+F,qBAAsB,SAACtU,GACrBjB,EAASuV,GAAqBtU,QAInB+mB,CAGb5E,I,2CCnDI8E,GAAe,SAACnoB,GAAW,IACvBR,EAAwDQ,EAAxDR,SAAUC,EAA8CO,EAA9CP,UAAW0Z,EAAmCnZ,EAAnCmZ,SAAUiP,EAAyBpoB,EAAzBooB,YAAaC,EAAYroB,EAAZqoB,QACpD,OACE,kBAAC,KAAD,CACE7oB,SAAUA,EACVC,UAAWA,EACX2oB,YAAaA,EACbC,QAASA,EACTnI,OAAO,SACPoI,WAAY,GACZC,QAAS,EACTC,cAAc,GAEbrP,IAaPgP,GAAaM,aAAe,CAC1BJ,QAAS,c,IAGLK,G,kDACJ,WAAY1oB,GAAQ,IAAD,8BACjB,cAAMA,IAkBR2oB,OAAS,gBACmB3wB,IAAtB,EAAKgI,MAAM2oB,QACb,EAAK3oB,MAAM2oB,OAAO,EAAKC,cArBR,EAyBnBrU,UAAY,WACV,IAAMpT,EAAS,EAAKynB,YACL,OAAXznB,QAA4CnJ,IAAzB,EAAKgI,MAAMuU,WAChC,EAAKvU,MAAMuU,UAAUpT,IA5BN,EAgCnBynB,UAAY,WACV,IAAK,EAAKC,MAAO,OAAO,KADR,MAGK,EAAKA,MAAMD,YAAxBE,EAHQ,EAGRA,IAAKC,EAHG,EAGHA,IACb,MAAO,CACL1S,MAAOyS,EAAIE,IACX1S,MAAOyS,EAAIC,IACXzS,KAAMwS,EAAIE,IACVzS,KAAMsS,EAAIG,MAxCK,EAkDnBC,aAlDmB,wBAkDJ,6BAAAzhB,EAAA,yDACT,mBAAoB0hB,UAAW,EADtB,gCAEU,8FAFV,OAELjzB,EAFK,OAGXizB,OAAOC,eAAiBlzB,EAAOkzB,gBAAkBlzB,EAAOmzB,QAH7C,OAKb,EAAKC,yBAA2B,IAAIF,eAAe,EAAKG,sBACxD,EAAKD,yBAAyBE,QAAQ,EAAKC,kBAN9B,2CAlDI,EA2DnBF,qBAAuB,SAAC/O,GAAa,IAAD,EACRA,EAAQ,GAAGkP,YAA7B3b,EAD0B,EAC1BA,MAAOC,EADmB,EACnBA,OADmB,EAEA,EAAKhO,MAA/BkB,EAF0B,EAE1BA,SAAUsT,EAFgB,EAEhBA,YAEdzG,IAAU7M,EAAS6M,OAASC,IAAW9M,EAAS8M,QAClDwG,EAAY,eACPtT,EADM,CAET6M,QACAC,aAnEa,EAwEnBjN,iBAAmB,SAACG,EAAUF,GAC5B,IAAM2oB,EAAgB,EAAK3pB,MAAMkB,SAE/ByoB,EAAcnqB,WAAa0B,EAAS1B,UACpCmqB,EAAclqB,YAAcyB,EAASzB,WACrCkqB,EAAchqB,OAASuB,EAASvB,MAChCgqB,EAAcC,UAAY1oB,EAAS0oB,SACnCD,EAAc9G,QAAU3hB,EAAS2hB,OAEjC,EAAK7iB,MAAMwU,YAAYtT,EAAUF,IAjFlB,EAqFnB6oB,iBAAmB,SAACle,EAAO1P,GACzB,EAAK+D,MAAM6X,eACT5b,EACA0P,EAAMme,OAAO,GACbne,EAAMme,OAAO,GACbne,EAAM7I,SACN,EAAKkV,cA3FU,EA+FnB2B,QAAU,SAAChO,GACT,EAAKke,iBAAiBle,EAAO,UAhGZ,EAmGnB+N,QAAU,SAAC/N,GACT,EAAKke,iBAAiBle,EAAO,UApGZ,EAuGnBoe,OAAS,SAACvC,GACI,OAARA,IACF,EAAKqB,MAAQrB,EAAIwC,SACjB,EAAKhS,YAAc,EAAK6Q,MAAMoB,UAAU3vB,KAAK,EAAKuuB,SA1GnC,EA8GnBqB,UAAY,YAAqB,IAAlBC,EAAiB,EAAjBA,WACLroB,EAAW,EAAK9B,MAAhB8B,OACR,OAAe,OAAXA,EACKqoB,EAAa,WAAa,OAE5BroB,GAnHU,EAsHnBsoB,iBAAmB,SAAC1wB,EAAK2wB,GAAkB,IACjC1wB,EAAU,EAAKqG,MAAfrG,MACR,GAAc,OAAVA,GAAmC,SAAjB0wB,GAA2B3wB,EAAI4wB,MhB9GT,egB+G1C,MAAO,CACL5wB,IAAKA,EACL6wB,QAAS,CAAEC,cAAe,UAAY7wB,KAzH1C,EAAKyG,MAAQ,CACXqqB,WAAW,GAEb,EAAKhB,iBAAmB,KALP,E,gEASa,OAA1BjwB,KAAKiwB,kBACPjwB,KAAK0vB,eAEP1vB,KAAK+a,c,2CAIL/a,KAAK+a,c,6CA6BD/a,KAAK8vB,0BACP9vB,KAAK8vB,yBAAyBoB,e,+BAkFxB,IAAD,SAaHlxB,KAAKwG,MAXPkB,EAFK,EAELA,SACAypB,EAHK,EAGLA,QACAC,EAJK,EAILA,QACA9V,EALK,EAKLA,cACAqD,EANK,EAMLA,SACAvW,EAPK,EAOLA,aACAipB,EARK,EAQLA,WACAC,EATK,EASLA,WACAC,EAVK,EAULA,iBACAC,EAXK,EAWLA,QACAC,EAZK,EAYLA,oBAGF,OACE,yBACEjuB,GAAG,MACHkuB,UAAWC,KAAO1qB,IAClB+mB,IAAK,SAACA,GACJ,EAAKiC,iBAAmBjC,GAE1B4D,aAAc,WACZ,EAAKnH,SAAS,CAAEwG,WAAW,KAE7BY,aAAc,WACZ,EAAKpH,SAAS,CAAEwG,WAAW,MAG7B,kBAAC,KAAD,eACMvpB,EADN,CAEEsmB,IAAKhuB,KAAKuwB,OACVK,iBAAkB5wB,KAAK4wB,iBACvBkB,gBAAiBxW,EACjB6T,OAAQnvB,KAAKmvB,OACbhP,QAASngB,KAAKmgB,QACdD,QAASlgB,KAAKkgB,QACdwQ,UAAW1wB,KAAK0wB,UAChB/R,SAAUA,EACVwS,QAASA,EACTC,QAASA,EACT7pB,iBAAkBvH,KAAKuH,iBACvBkqB,oBAAqBA,EACrBM,YAAa,EACbC,qBAAqB,KAEC,IAArBT,GAA8B,kBAAC,GAAD,WACf/yB,IAAf6yB,GAA2C,OAAfA,GAC3B,kBAAC,GAAD,CACErrB,SAAUqrB,EAAWrrB,SACrBC,UAAWorB,EAAWprB,UACtB2oB,aAAW,EACXC,QAASzmB,GAERipB,EAAWvrB,UAGU,IAAzB9F,KAAK4G,MAAMqqB,gBAAqCzyB,IAAf8yB,GAA2C,OAAfA,GAC5D,kBAAC,GAAD,CACEtrB,SAAUsrB,EAAWtrB,SACrBC,UAAWqrB,EAAWrrB,UACtB2oB,aAAa,GAEZ0C,EAAWxrB,SAGH,OAAZ0rB,GACCA,EAAQ/yB,OAAS,GACjB+yB,EAAQvqB,KAAI,SAACgrB,EAAQvzB,GAAT,OACV,kBAAC,KAAD,CAAQ4P,IAAK5P,EAAGsH,SAAUisB,EAAOjsB,SAAUC,UAAWgsB,EAAOhsB,WAC1DgsB,EAAOnsB,aAIhB,yBAAK4rB,UAAWC,KAAOO,kB,GA3MbvI,IAAMC,WA2OxBsF,GAAID,aAAe,CACjB9uB,MAAO,KACPkxB,WAAY,KACZC,WAAY,KACZjT,eAAgB,aAChB8Q,OAAQ,aACR/mB,aAAc,aACdkT,cAAe,aACfhT,OAAQ,KACRkpB,QAAS,KACTC,oBAAqB,KACrB1W,eAAWvc,GAGE0wB,U,iMCrRf,IAKMqC,GAAmB3oB,YACvB,CALuB,SAAChC,GAAD,OAAWA,EAAMK,IAAIyQ,QAAQD,iBAMpD,SAACA,GACC,OAAOpI,OAAOC,KAAKmI,GAAehZ,OAAS,KAGzC0zB,GAAyBvpB,YAC7B,CAZsB,SAAChC,GAAD,OAAWA,EAAMK,IAAI6D,MAAMsnB,gBAejD,SAACA,GACC,OAAOA,EAAa5oB,QAAO,SAACmB,EAAK8N,GAC/B,OAAKA,EAAMxT,aAAgBwT,EAAMjU,cAEhBhG,IAAbia,EAAM7S,GACR6S,EAAM7S,GAAGuD,OAAOoD,SAAQ,SAAC8lB,EAASloB,GAGhC,GAC6B,IAA3BsO,EAAM7S,GAAGuD,OAAO1K,aACMD,IAArB6zB,EAAQ5U,WAAkE,IAAxC4U,EAAQ5U,SAAS,mBACpD,CACA,IAAM6U,EAAYD,EAAQ7uB,IAAM2G,EAAQ,EAAtB,UAA6BsO,EAAMjV,GAAnC,YAAyC2G,GAAUsO,EAAMjV,GAC3EmH,EAAIN,KAAKioB,OAIb3nB,EAAIN,KAAKoO,EAAMjV,IAEVmH,GAjB0CA,IAkBhD,OAKD4nB,GAAc3pB,YAClB,CAFmB,SAAChC,GAAD,OAAWA,EAAMK,IAAI6D,MAAM6T,UAE/B1T,IACf,SAACunB,EAAWtnB,GACV,IAAKA,EAAa,OAAOsnB,EAEzB,IAIMC,EAJqBD,EACxB5T,OACAzV,OAAON,QAAO,SAACiS,GAAD,YAAsBtc,IAAfsc,EAAE2C,YACvBxW,KAAI,SAAC6T,GAAD,OAAOA,EAAE2C,SAAS,mBACmBiV,YjBZF,YiBYgD,EAEtFC,EAAiBH,EAAUI,QAAQ,CAAC,WAAY1nB,EAAYhC,SAC5D2pB,EAAkBL,EAAUM,IAAI,UAKpC,OAJA5nB,EAAY/B,OAAOoD,SAAQ,SAACwmB,EAAYr0B,GACtCm0B,EAAkBA,EAAgBG,OAAOP,EAAmB/zB,EAAGu0B,YAAOF,OAExEJ,EAAiBA,EAAelkB,IAAI,SAAUokB,MAK5CnC,GAAY9nB,YAChB,CA5DwB,SAAChC,GAAD,OAAWA,EAAMK,IAAIisB,YAAY5qB,QACnC,SAAC1B,GAAD,OAAWA,EAAMK,IAAIvK,OAAO4L,UA4DlD,SAAC6qB,EAAgBC,GACf,OAAqB,OAAjBA,EACKA,EAEFD,KAiCI1E,gBA9BS,SAAC7nB,GAAD,MAAY,CAClCc,SAAUd,EAAMK,IAAIS,SAASA,SAC7BypB,QAASvqB,EAAMK,IAAIS,SAASypB,QAC5BC,QAASxqB,EAAMK,IAAIS,SAAS0pB,QAC5BjC,OAAQvoB,EAAMK,IAAIvK,OAAOyyB,OACzB7mB,OAAQooB,GAAU9pB,GAClBzG,MAAOyG,EAAMK,IAAIvK,OAAOyD,MACxBwe,SAAU4T,GAAY3rB,GACtB2qB,iBAAkBA,GAAiB3qB,GACnC6qB,oBAAqBU,GAAuBvrB,OAGnB,SAACH,GAAD,MAAe,CACxCuU,YAAa,SAACtT,EAAUF,GACtBf,EAASuU,GAAYtT,EAAUF,KAEjCuT,UAAW,SAACpT,GACVlB,EAASsU,GAAUpT,KAErB0W,eAAgB,SAAC5b,EAAM+sB,EAAK6D,EAAM/pB,EAAU4V,EAASV,GACnD/X,EAAS4X,GAAe5b,EAAM+sB,EAAK6D,EAAM/pB,EAAU4V,KAErD5D,cAAe,WACb7U,EAAS6U,OAEXlT,aAAc,WACZ3B,GhBrC4B,SAACA,EAAUW,GACzC,IAAMR,EAAQQ,SACwB5I,IAAlCoI,EAAMK,IAAIvK,OAAO0L,cACnBxB,EAAMK,IAAIvK,OAAO0L,sBgBsCNqmB,CAGbS,I,6CCtGIoE,GAAexjB,KACnBT,OAAOC,KAAKikB,GAASrqB,SAClBjC,KAAI,SAACusB,GAAD,OAAeD,GAASrqB,QAAQsqB,GAAWC,eAC/C5qB,QAAO,SAACgC,GAAD,YAAuBrM,IAAXqM,MAGX6oB,GAAwB,SAACjb,GAWpC,QAVqBja,IAAjBia,EAAMkb,SACRlb,EAAMkb,OAAS,SAEGn1B,IAAhBia,EAAM1N,QACR0N,EAAM1N,MAAQ,SAEOvM,IAAnBia,EAAMgF,WACRhF,EAAMgF,SAAW,KAGoB,IAAnChF,EAAMgF,SAAS,gBAA0B,CAC3C,IAAMmW,OACoCp1B,IAAxCia,EAAMgF,SAAS,qBACX,YACAhF,EAAMgF,SAAS,qBACrBhF,EAAM5P,OAAS,CAAC,MAAO,CAAC,IAAK+qB,EAAe,GAAI,CAAC,IAAKA,EAAe,eAWvE,YARuCp1B,IAAnCia,EAAMgF,SAAS,kBACjBhF,EAAMgF,SAAS,gBAAkB,YAIH,YAA5BhF,EAAMkb,OAAOE,aACfpb,EAAMkb,OAAOE,WAAa,QAErBpb,G,oMAGT,IAA0B3N,GAOpBgpB,GAAe,CACnBnV,SAAUsU,aARcnoB,GAQUyoB,GAPlCzoB,GAAM3B,OAAOoD,SAAQ,SAACkM,GACpBib,GAAsBjb,MAEjB3N,KAKPipB,wBAAyB,GACzB3B,aAAc,GACd4B,cAAe,GACfV,iBCzDIW,GAAQ,CACZ,CAAEruB,GAAI,OAAQsuB,QAAS,CAAC,aAAc,oBACtC,CAAEtuB,GAAI,OAAQsuB,QAAS,CAAC,UAAW,iBACnC,CAAEtuB,GAAI,SAAUsuB,QAAS,CAAC,QAAS,gBCMxBC,GAAiB,iB,sNACvB,IAAMC,GAAgB,gB,qNACtB,IAAMC,GAAoC,oC,yOAC1C,IAAMC,GAAoB,oB,yNAC1B,IAAMC,GAAqB,qB,0NAElC,IAAMC,GAAwB,SAACC,EAAeC,GAC5C,GAA2B,WAAvBD,EAAchyB,KAChB,OAAOgyB,EAET,IAAM/e,EAAQ+e,EAAc/e,MACtBif,OAA+Bn2B,IAAhBk2B,EAA4B,GAAK,CAACA,GAEjDE,OACMp2B,IAAVkX,GAAuBA,EAAMjX,OAAS,EAAIqR,KAAK,GAAD,OAAK6kB,EAAL,YAAsBjf,KAAUif,EAChF,OAAO,eACFF,EADL,CAEE/e,MAAOkf,KAIEC,GAAY,SAAC,GAAD,IAAGC,EAAH,EAAGA,WAAH,MAAqB,CAC5CryB,KAAM0xB,GACNztB,QAAS,CACPouB,gB,wLAIJ,IAAMC,GAAc,SAACjqB,GAAD,MAAY,CAC9BrI,KAAM2xB,GACN1tB,QAASoE,IAGLkqB,GAAyB,SAACvuB,EAAUW,EAAUY,GAclD,IAdgG,IAA9BitB,EAA6B,wDACzFruB,EAAQQ,IAAWH,IAAI6D,MACzBA,EAAQlE,EAAM+X,SACZD,EAAe5T,EAAM8T,OACrBsW,EAAWxW,EAAavV,OAE1B/K,EAAQoU,KAAK4P,MAAMpa,EAAe,GAAGhB,UAAY,KACjD3I,EAAMmU,KAAK4P,MAAMpa,EAAe,GAAGhB,UAAY,KAI7CmK,EAAarC,KAAQsB,2BAA2BpI,EAAe,GAAGhB,WAClEoK,EAAWtC,KAAQsB,2BAA2BpI,EAAe,GAAGhB,WAE7DtI,EAAI,EAAGA,EAAIw2B,EAASz2B,OAAQC,IAAK,CACxC,IAAM2zB,EAAU6C,EAASx2B,GACzB,QAAyBF,IAArB6zB,EAAQ5U,WAA+D,IAArC4U,EAAQ5U,SAAS,oBAK/B,IAArBwX,IAA4E,IAA/C5C,EAAQ5U,SAAS,4BACzB,IAArBwX,IAA6E,IAA/C5C,EAAQ5U,SAAS,2BAFlD,CASA,IAAM0X,EAAgBrqB,EAAMsqB,MAAM,CAAC,SAAU12B,EAAG,WAAWkgB,OAC3D,GAAsB,OAAlBuW,EACF,MAAM,IAAIve,MAAM,2DAA4Dyb,EAAQ7uB,IAKtF,IAAM6xB,EAAWhD,EAAQ5U,UAAsD,cAA1C4U,EAAQ5U,SAAS,qBACtD0X,EAAc,GAAG,GAAKE,EAAWlkB,EAAa/S,EAC9C+2B,EAAc,GAAG,GAAKE,EAAWjkB,EAAW/S,EAC5CyM,EAAQA,EAAMwqB,MAAM,CAAC,SAAU52B,EAAG,UAAWu0B,YAAOkC,KAEtD1uB,EAASsuB,GAAYjqB,KAGjByqB,GAA+BC,KAAS,SAAC/uB,EAAUW,EAAUY,GACjEgtB,GAAuBvuB,EAAUW,EAAUY,GAAgB,KAC1D,KAEUytB,GAAsB,SAACztB,GAAD,OAAoB,SAACvB,EAAUW,GAChE4tB,GAAuBvuB,EAAUW,EAAUY,GAC3CutB,GAA6B9uB,EAAUW,EAAUY,K,kMAGnD,IAyFM0tB,GAAgB,SAAC5qB,EAAOwnB,EAAWqD,GACvC,IACMC,EADe9qB,EAAM8T,OACazV,OACpC0sB,EAAW/qB,EAETgrB,EAAeF,EAAmBG,WAAU,SAACjb,GAAD,OAAOA,EAAEtX,KAAO8uB,KAC5DD,EAAUuD,EAAmBhiB,MAAK,SAACkH,GAAD,OAAOA,EAAEtX,KAAO8uB,KAKxD,GAFAuD,EAd4B,SAAC/qB,EAAO6qB,EAAUG,GAC9C,IAAMjC,GAAkC,IAArB8B,EAASnxB,QAAmB,UAAY,OAC3D,OAAOsG,EAAMwqB,MAAM,CAAC,SAAUQ,EAAc,SAAU,cAAejC,GAY1DmC,CAAsBH,EAAUF,EAAUG,IAE1B,IAAvBH,EAASM,UACX,OAAOJ,EAGT,IAAMK,OAAuC13B,IAArBm3B,EAASjxB,QAAwB,EAAIixB,EAASjxB,QAGtE,OAAQ2tB,EAAQ5vB,MACd,IAAK,OACHozB,EAAWA,EACRP,MAAM,CAAC,SAAUQ,EAAc,QAAS,gBAAiBI,GACzDZ,MAAM,CAAC,SAAUQ,EAAc,QAAS,sBAAuBH,EAAS7xB,OACxEwxB,MAAM,CAAC,SAAUQ,EAAc,QAAS,chBjNnB,iBgBkNxB,MAEF,IAAK,OACH,IAAMhyB,EAAQ6xB,EAAS7xB,OAAUuuB,EAAQtnB,OAASsnB,EAAQtnB,MAAM,cAChE8qB,EAAWA,EACRP,MAAM,CAAC,SAAUQ,EAAc,QAAS,gBAAiBI,GACzDZ,MAAM,CAAC,SAAUQ,EAAc,QAAS,cAAehyB,GAC1D,MAEF,IAAK,SACH,GAAIuuB,EAAQ5U,WAAgD,IAApC4U,EAAQ5U,SAAS,eAAyB,CAChE,IAEM0Y,EADiE,YAArEN,EAAST,MAAM,CAAC,SAAUU,EAAc,SAAU,iBAEF,IAAxBH,EAASjwB,WAAsB,UAAY,OAKrE,GAJAmwB,EAAWA,EAASP,MAClB,CAAC,SAAUQ,EAAc,SAAU,cACnCK,IAE0B,IAAxBR,EAASjwB,WACX,MAGJmwB,EAAWA,EAASP,MAAM,CAAC,SAAUQ,EAAc,QAAS,gBAAiBI,QAEtD13B,IAAnBm3B,EAAS7xB,QACX+xB,EAAWA,EAASP,MAAM,CAAC,SAAUQ,EAAc,QAAS,cAAeH,EAAS7xB,QAEtF,MAGF,IAAK,SAKH,GAJA+xB,EAAWA,EACRP,MAAM,CAAC,SAAUQ,EAAc,QAAS,kBAAmBI,GAC3DZ,MAAM,CAAC,SAAUQ,EAAc,QAAS,yBAA0BI,QAE9C13B,IAAnBm3B,EAAS7xB,MAAqB,CAChC,IAAMsyB,EACJ/D,GAAWA,EAAQ5U,UAAY4U,EAAQ5U,SAAS,8BAC5C4U,EAAQ5U,SAAS,8BACjB,eACNoY,EAAWA,EAASP,MAClB,CAAC,SAAUQ,EAAc,QAASM,GAClCT,EAAS7xB,OAGb,MAEF,IAAK,SACH+xB,EAAWA,EAASP,MAClB,CAAC,SAAUQ,EAAc,QAAS,kBAClCI,GAWN,OAFAL,EA7K4B,SAAC/qB,EAAO6qB,EAAUU,EAAgBP,GAC9D,IAAID,EAAW/qB,EACT4T,EAAe5T,EAAM8T,OACrB0X,EAASD,EAAe5zB,KACxB8zB,EAAgB7X,EAAajB,SAAS,cACtCA,EAAW4Y,EAAe5Y,SA4EhC,MA3EC,CAAC,WAAY,eAAelR,SAAQ,SAACiqB,GAEpC,IAAMltB,EAAWqsB,EAAS,GAAD,OAAIa,EAAJ,aACnBC,EAAgBntB,GAAYA,EAASwB,MAAQxB,EAASwB,MAAMwrB,GAAU,GACtEI,EAA2B,OAAbptB,QAAkC9K,IAAb8K,GAA0BA,EAAS/D,OAAO9G,OAAS,EACtFk4B,EAA0BhB,EAASa,GAEnCI,EAAeL,EAAcC,GAAWF,IAAW,GACnDO,EACHpZ,GAAYA,EAAS,eAAiBA,EAAS,cAAc+Y,IAAe,GACzEM,EAAkB,eAAQF,EAAR,GAAyBC,EAAzB,GAAwCJ,GAE5DpnB,OAAOC,KAAKwnB,GAAoBr4B,QAElC4Q,OAAOC,KAAKwnB,GAAoBvqB,SAAQ,SAACwqB,GACvC,IAKIC,EALEC,EAAgBH,EAAmBC,GAAiB,GACpDG,EAAgBJ,EAAmBC,GAAiB,GACpDI,EAAgB,CAAC,YAAa,cAAcC,SAASL,GACvD,SACA,QAEJ,IACkB,IAAhBL,IAC4B,IAA5BC,IAC4B,IAA5BA,EACA,CAEA,IAAMU,EAAqB9D,GAASpqB,OAAOyK,MAAK,SAACkH,GAAD,OAAOA,EAAEtX,KAAO6yB,EAAe7yB,MAQ3EwzB,OANuBx4B,IAAvB64B,EAGAhB,EAAe5Y,UACf4Y,EAAe5Y,SAAS,gCAAkCsZ,EAEtC,KAEAM,EAAmBF,GAAeJ,GAMpC,UAEjB,IAAgC,IAA5BJ,IAAgE,IAA5BA,EAC7CK,GAAgD,IAA5BL,EAAmCM,EAAgBC,MAClE,CACL,IAAII,EAAsB,GAC1B,GAAuB,OAAnB3B,EAAS7xB,YAAqCtF,IAAnBm3B,EAAS7xB,MAAqB,CAC3D,IAAMyzB,EAAgBlU,GAASsS,EAAS7xB,OACxCwzB,EAAmB,UAAMC,EAAchW,EAApB,YAAyBgW,EAAc/V,EAAvC,YAA4C+V,EAAc9V,GAE/EuV,EAAoB,CAClB,QACA,CAAC,MAAO1tB,EAAShE,OACjBgE,EAAS/D,OACgB,kBAAlB0xB,EACHA,EACAA,EAAcO,QAAQ,sBAAuBF,GACxB,kBAAlBJ,EACHA,EACAA,EAAcM,QAAQ,sBAAuBF,SAI3B94B,IAAtBw4B,GAAyD,OAAtBA,IACrCnB,EAAWA,EAASP,MAClB,CAAC,SAAUQ,EAAcqB,EAAeJ,GACxCC,UAMHnB,EA4FI4B,CAAsB5B,EAAUF,EAAUtD,EAASyD,IAK1D4B,GAAmB,SAACnzB,EAASoS,EAASzW,EAAK0D,GAAxB,OAAiC,SAAC6C,EAAUW,GACnE,IACI0D,EADU1D,IACIH,IAAI6D,MAAM6T,SACtBD,EAAe5T,EAAM8T,OAG3B,QAAsCpgB,IAAlCkgB,EAAaxV,QAAQyN,GAAwB,CAC/C,IAAM9L,EAAS,CAAEpI,KAAM8B,GACnBA,IAAYqH,GAAuBvC,QACrCwB,EAAOjH,KAAOA,EACLW,IAAYqH,GAAuBC,SAC5ChB,EAAO6K,MAAQ,CAACxV,GAChB2K,EAAO8sB,SAAW,KAEpB7sB,EAAQA,EAAMwqB,MAAM,CAAC,UAAW3e,GAAUsc,YAAOpoB,IAGnD,QAAsErM,IAAlEkgB,EAAavV,OAAOyK,MAAK,SAACye,GAAD,OAAaA,EAAQ7uB,KAAOmT,KAAwB,CAC/E,IAAM2f,EAAS/xB,IAAYqH,GAAuBvC,QD7RvC,SAAC6qB,GAEd,IAAM0D,EAAkB1D,EAAQ5qB,SAASrC,KAAI,SAACyC,GAC5C,IAAM6L,EAAO7L,EAAQK,SACrB,YAAavL,IAAT+W,EACK,KAEFA,EAAK9S,QAIRo1B,EAAc5D,GAAMhtB,KAAI,SAACxE,GAC7B,IAAI+jB,EAAM,EAMV,OALAoR,EAAgBrrB,SAAQ,SAACurB,GACnBr1B,EAAKyxB,QAAQhnB,QAAQ4qB,IAAgB,GACvCtR,OAGG,CAAE5gB,GAAInD,EAAKmD,GAAI4gB,UAIpB8P,EAAS,OACTyB,EAAY,EAQhB,OAPAF,EAAYtrB,SAAQ,SAACzD,GACfA,EAAE0d,IAAMuR,IACVzB,EAASxtB,EAAElD,GACXmyB,EAAYjvB,EAAE0d,QAIX8P,EC8PuD0B,CAAgBp0B,GAAQW,EAC9E8tB,EAAUY,YAAO,CACrBzvB,GAAImT,EACJ9L,OAAQ8L,EACRlU,KAAM6zB,EACN3C,OAAQ,GACR5oB,MAAO,KAEHktB,EACJ1zB,IAAYqH,GAAuBC,OAE/B6S,EAAavV,OAAO1K,OACpB,EACAigB,EAAavV,OACVN,QAAO,SAACiS,GAAD,MAAgB,WAATA,EAAEtX,MAChB00B,UACAnC,WAAU,SAACjb,GAAD,MAAkB,WAAXA,EAAErY,QACtBic,EAAavV,OAAO1K,OAAS,EACnCqM,EAAQA,EAAM2D,IAAI,SAAU3D,EAAMgoB,IAAI,UAAUqF,OAAOF,EAAY,EAAG5F,IAGxE5rB,EAASsuB,GAAYjqB,MA+EjBstB,GAAyB,SAACjvB,GAAD,OAAY,SAAC1C,EAAUW,GACpDX,EAAS,CACPhE,KAAM4xB,GACN3tB,QAASyC,EAAOlC,KAAI,SAACwR,GAAD,OAAWA,EAAM4f,cAEvC,IAAMC,EAAsBnvB,EAAOlC,KAAI,SAACwR,GAAD,OAhCE4f,GAAF,EAgC2C5f,GAhCzC4f,SAAUE,EAAqB,EAArBA,eAC7CC,EAAY,CAAErvB,OAAQ,CAAC,CAAE3F,GAAI60B,EAAUI,QAAS,CAAEC,IAAKH,MACvDI,EAAeC,mBAAmB32B,KAAK42B,UAAUL,IACjDM,EAAuBzyB,EAA6BmxB,QAAQ,aAAcmB,GAEzE,IAAIv4B,SAAQ,SAACC,GAClB04B,MAAMD,GACH9hB,MAAK,SAACtX,GACL,OAAIA,EAAI2B,QAAU,KAChB+M,QAAQC,KAAR,kCAAwCgqB,IACxCj4B,QAAQE,SACD,MAEFZ,EAAIs5B,UAEZhiB,MAAK,SAACpT,GACLvD,EAAQ,CACN44B,aAAcr1B,EAAKq1B,aACnBZ,gBAGHa,OAAM,SAACpL,GACN1f,QAAQC,KAAKyf,SAtBmB,IAAC,EAAEuK,EAAUE,EAC7CC,EACAG,EACAG,KA8B6B14B,QAAQ2W,IAAIuhB,EAAoBrxB,KAAI,SAACgb,GAAD,OAAOA,EAAEiX,OAAM,SAACjkB,GAAD,OAAOA,SAE1F+B,MAAK,SAACmiB,GACL,IAAIruB,EAAQ1D,IAAWH,IAAI6D,MAAM6T,SAC3BD,EAAe5T,EAAM8T,OAC3Bua,EAAwB5sB,SAAQ,SAAC6sB,GAC/B,IAAMC,EAAW/yB,EAAmCkxB,QAClD,gBACA4B,EAAWH,cAIPK,EAAW,UAAMF,EAAWf,SAAjB,iBASjBvtB,GARAA,EAAQA,EAAMwqB,MACZ,CAAC,UAAWgE,GACZrG,YAAO,CACLxwB,KAAM,SACNiT,MAAO,CAAC2jB,OAIEE,SAAS,CAAC,UAAWH,EAAWf,WAG9C3Z,EAAavV,OAAOoD,SAAQ,SAAC8lB,EAASyD,GACpC,GAAIzD,EAAQxnB,SAAWuuB,EAAWf,SAAU,CAE1CvtB,GADAA,EAAQA,EAAMwqB,MAAM,CAAC,SAAUQ,EAAc,UAAWwD,IAC1ChE,MAAM,CAAC,SAAUQ,EAAc,WAAY,UAAWsD,EAAWf,UAC/E,IAAM1C,EAAWxsB,EAAOyK,MAAK,SAACkH,GAAD,OAAOA,EAAE6a,SAASnyB,KAAO41B,EAAWf,YAAU1C,SAC3E7qB,EAAQ4qB,GAAc5qB,EAAOunB,EAAQ7uB,GAAImyB,UAK/ClvB,EAASsuB,GAAYjqB,OAEtBouB,OAAM,SAACpL,GACN1f,QAAQC,KAAKyf,QAIN0L,GAAqB,SAACpH,EAAc4B,GAAf,OAAiC,SAACvtB,EAAUW,GAG5EX,EAAS,CACPhE,KAAM6xB,GACN5tB,QAAS0rB,IAEX3rB,EAAS,CACPhE,KAAM8xB,GACN7tB,QAASstB,IAGX,IAAM7qB,EAAM,sBAAOipB,GAAP,YAAwB4B,EAAc/sB,KAAI,SAACwyB,GAAD,sBAAcA,EAAd,CAAkBxD,WAAW,SAE7EyD,EAAmBtyB,IAAWH,IAAI6D,MAAM6T,SAASC,OAAO1V,QAGxDywB,EAAoBxwB,EAAON,QAAO,SAAC4P,GAAD,YAAwBja,IAAbia,EAAM7S,MAErD+zB,EAAkBl7B,QAEpBgI,EAhJ4B,SAACkzB,GAAD,OAAuB,SAAClzB,EAAUW,GAChE,IAAMR,EAAQQ,IACV0D,EAAQlE,EAAMK,IAAI6D,MAAM6T,SAE5Bgb,EAAkBptB,SAAQ,SAACqtB,GAAsB,IACvCp2B,EAAWo2B,EAAXp2B,GAAIoC,EAAOg0B,EAAPh0B,GACNi0B,EAAcrF,GAAsB5uB,EAAGiF,OAAQ+uB,EAAiB15B,KAGhE45B,GAFNhvB,EAAQA,EAAMwqB,MAAM,CAAC,UAAW9xB,GAAKyvB,YAAO4G,KAGzC/G,IAAI,UACJlU,OACA3X,KAAI,SAAC6T,GAAD,OAAOA,EAAEtX,MACIoC,EAAGuD,OAAON,QAAO,SAAC4P,EAAOtO,GAC3C,IAAMwM,EAAU8B,EAAMjV,IAAM2G,EAAQ,EAApB,UAA2B3G,EAA3B,YAAiC2G,GAAU3G,EAC3D,OAAQs2B,EAAiB1C,SAASzgB,MAExBpK,SAAQ,SAACwtB,EAAY5vB,GAE/B,IAAI6vB,EAAeD,EAAWv2B,IAAM2G,EAAQ,EAAzB,UAAgC3G,EAAhC,YAAsC2G,GAAU3G,EAC7Dy2B,EAAiBvG,GAAsBqG,GAEvC1H,EAAO,eACR4H,EADQ,CAEXz2B,GAAIw2B,EACJnvB,OAAQrH,IAIV,GAAuB,WAAnBoC,EAAGiF,OAAOpI,KAAmB,CAC/B,IAAMgrB,OAC2BjvB,IAA/Bu7B,EAAW,gBAAgCv2B,EAAKu2B,EAAW,gBAC7D1H,EAAQ,gBAAkB5E,EAI5B,IAAMyM,EAAiBpvB,EAAMgoB,IAAI,UAC3BqH,EAAgB9H,EAAQ5U,SAAS,gBACjC2c,EAAgBF,EAAeG,eAAc,SAACvf,GAClD,OAAOqf,IAAkBrf,EAAE8D,OAAOnB,SAAS,mBAE7C3S,EAAQA,EAAM2D,IAAI,SAAUyrB,EAAe/B,OAAOiC,EAAe,EAAGnH,YAAOZ,WAI/E5rB,EAASsuB,GAAYjqB,IACrBrE,EAASgvB,GAAoB7uB,EAAMK,IAAIvK,OAAOsL,kBAkGnCsyB,CAAwBX,IAInC,IAAMY,EAAepxB,EAAON,QAC1B,SAAC4P,GAAD,OAA8B,IAAnBA,EAAM9S,eAAoDnH,IAA/Bk7B,EAAiBjhB,EAAMjV,OAE3D+2B,EAAa97B,QACf87B,EAAahuB,SAAQ,SAACkM,GACpBhS,EAASixB,GAAiBjf,EAAMlU,QAASkU,EAAMjV,GAAIiV,EAAMvY,IAAKuY,EAAM7U,UAIxE,IAAMgD,EAAQQ,IAAWH,IAAI6D,MACzBA,EAAQlE,EAAM+X,SACZD,EAAe5T,EAAM8T,OACrBsW,EAAWxW,EAAavV,OACxBqxB,EAAY9b,EAAaxV,QAEzBuxB,EAA2B,GAGjCrI,EAAa7lB,SAAQ,SAACopB,GACpB,IAAM0C,EAAW1C,EAASnyB,GAC1B,QAAmChF,IAA/Bk7B,EAAiBrB,KAAgD,IAArB1C,EAASnxB,eACjChG,IAAlBm3B,EAAS/xB,OACXkH,EAAQA,EAAMwqB,MAAM,CAAC,UAAW+C,EAAU,QAASpF,YAAO0C,EAAS/xB,aAEhDpF,IAAjBm3B,EAASz1B,KAAmB,CAC9B,IAAMw6B,EAAYlG,GAAsBkF,EAAiBrB,GAAW1C,EAASz1B,KAC7E4K,EAAQA,EAAMwqB,MAAM,CAAC,UAAW+C,GAAWpF,YAAOyH,QAKxD,IAxDyF,eAwDhFh8B,GACP,IAAM2zB,EAAU6C,EAASx2B,GACnB25B,EAAWhG,EAAQxnB,OACnByU,EAAWkb,EAAUnC,GACrB1hB,OAAgCnY,IAArB6zB,EAAQ5U,UAA0B4U,EAAQ5U,SAAS,WAAc4a,EAE5E1C,EAAWxsB,EAAOyK,MAAK,SAACkH,GAAD,OAAOA,EAAEtX,KAAOmT,KAE7C,QAAiBnY,IAAbm3B,EAIF,OAHItD,EAAQ5vB,KAGZ,WAKF,IAAM81B,OAAuC/5B,IAAtB8gB,EAAS7B,UAA0B6B,EAAS7B,SAAS,iBAC5E,IAAuB,IAAnB8a,QAA+C/5B,IAAnB+5B,EAA8B,CAE5D,IAAMoC,EAAyB/zB,EAAMmtB,wBAAwB7mB,QAAQmrB,IAAa,EAQlF,OANuB,IAArB1C,EAASnxB,SACRm2B,GACAF,EAAyB7mB,MAAK,SAACkH,GAAD,OAAOA,EAAEud,WAAaA,MAErDoC,EAAyBpwB,KAAK,CAAEguB,WAAUE,iBAAgB5C,aAE5D,WAGF7qB,EAAQ4qB,GAAc5qB,EAAOunB,EAAQ7uB,GAAImyB,IA/BlCj3B,EAAI,EAAGA,EAAIw2B,EAASz2B,OAAQC,IAAK,EAAjCA,GAkCL+7B,EAAyBh8B,QAC3BgI,EAAS2xB,GAAuBqC,IAGlCh0B,EAASsuB,GAAYjqB,M,8XCxgBY,M,OAAA,M,oBAAA,M,sBAAA,I,8HAEnC,IAAM8vB,GAAqB,CACzBC,mBAHiC,IAIjCC,uBAAwB,IAAIC,KAC5BC,iBAAkBC,MAGdnH,GAAe,CACnBpsB,SAAU,CACR1B,SAAU,EACVC,UAAW,EACXE,KAAM,EACNiqB,QAAS,EACT/G,MAAO,EACP9U,MAAO,IACPC,OAAQ,IACR7M,OAAQ,IAEVwpB,QrBN4B,GqBO5BC,QrBT4B,EqBU5Brb,SAAU,EACVtB,kBAAmB,MC9BjBymB,GAAmBC,IAiBjBC,GAAQC,aAAY,cAAU,GAAIH,GAAiBI,YAAgBC,QAE5DC,GAAkB,SAACh4B,GAC9B,IAAMoH,EAAQwwB,GAAMh0B,WAAWH,IAAIyB,OAAO9E,KAAKgQ,MAAK,SAAC9K,GAAD,OAAOA,EAAEtF,KAAOA,EAAGT,cAGvE,OAFAq4B,GAAM30B,SAASg1B,GAAkB7wB,EAAM8wB,YAEhC9wB,EAAM+wB,gB,sLAER,IAAMngB,GAAc,SAAC7T,GAC1ByzB,GAAM30B,SAASg1B,GAAkB9zB,IACjCi0B,YAAW,WAE+C,OAApDR,GAAMh0B,WAAWH,IAAIS,SAAS+M,mBAChC2mB,GAAM30B,SAAS6U,QAEhBugB,M,kLAGUT,U,+PCvCFU,GAAqB,SAACzyB,GACjC,IAAM0yB,EAAO,CAAE39B,MAAO49B,IAAU39B,IAAK,GAmBrC,OAlBIgL,GAAWA,EAAQC,UACrBD,EAAQC,SAASiD,SAAQ,SAAC7C,GAEtBA,EAAQC,YACRD,EAAQC,WAAWC,sBACnBF,EAAQC,WAAWC,qBAAqBC,OACxCH,EAAQC,WAAWC,qBAAqBC,MAAMpL,OAAS,GAEvDiL,EAAQC,WAAWC,qBAAqBC,MAAM0C,SAAQ,SAAC8D,GACjDA,EAAW0rB,EAAK39B,MAClB29B,EAAK39B,MAAQiS,EACJA,EAAW0rB,EAAK19B,MACzB09B,EAAK19B,IAAMgS,SAMd,CAAC0rB,EAAK39B,MAAO29B,EAAK19B,M,kMAGpB,IAAM49B,GAAiB,SAAC5yB,GAC7B,IAAM1B,EAASu0B,KAAM7yB,GACrB,MAAO,CACLuS,OAAQjU,EAAO,GACfgU,OAAQhU,EAAO,GACfmU,OAAQnU,EAAO,GACfkU,OAAQlU,EAAO,K,8LCzBM,c,OAAA,c,oBAAA,c,sBAAA,Y,mHACG,iB,OAAA,iB,oBAAA,iB,sBAAA,e,sHACA,iB,OAAA,iB,oBAAA,iB,sBAAA,e,sHAiE5B,SAASw0B,GAAUvxB,GACjB,OAAO,SAACnE,EAAUW,GAAc,IACtB5D,EAAsEoH,EAAtEpH,GAAItD,EAAkE0K,EAAlE1K,IAAKuC,EAA6DmI,EAA7DnI,KAAM0B,EAAuDyG,EAAvDzG,gBAAiBH,EAAsC4G,EAAtC5G,qBAAsBF,EAAgB8G,EAAhB9G,MAAOF,EAASgH,EAAThH,KAC/DgD,EAAQQ,IACRjH,EAAQyG,EAAMK,IAAIvK,OAAOyD,MAE/B,IAAIyG,EAAMK,IAAIyB,OAAO9E,KAAKgQ,MAAK,SAAC9K,GAAD,OAAOA,EAAEtF,KAAOA,KAA/C,CAIA,IAAMkD,EAAU,CACdlD,KACAtD,MACAuC,OACAqB,QACAK,mBAEIi4B,OAA8B59B,IAAfoM,EAAMhH,MAAqC,OAAfgH,EAAMhH,KACjDy4B,OAAsB79B,IAAR0B,GAA6B,OAARA,GAAwB,KAARA,EAOzD,GANIk8B,IACF11B,EAAQ9C,KAAOA,EACf8C,EAAQg1B,UAAYO,GAAer4B,IAErC6C,EAAS,CAAEhE,KA1FU,YA0FOiE,aAExB01B,GAAiBC,EAArB,CAIA,IAAM9kB,EAAW5Q,EAAYF,EAAUG,GACvC,GAAa,YAATnE,EAAoB,CAEtB,IAAMtC,EAAQyG,EAAMK,IAAIvK,OAAOyD,MAEzBkN,EAAWF,GAAgBjN,EAAKC,EAAO6D,GAE7C5D,QAAQ2W,IAAI1J,EAASpG,KAAI,SAACgb,GAAD,OAAOA,EAAEiX,OAAM,SAACjkB,GAAD,OAAOA,SAAK+B,MAAK,SAACvJ,GACxD,IAAM6uB,EAAY9uB,GAAqBC,GAEvC,GAAK6uB,EAAU79B,OAAf,CAGA,IASMmF,EAlHsB,SAAC24B,GAuBnC,IAtBA,IAeIC,EAfEC,EAAgB,SAACC,GAAD,IAAQj6B,EAAR,uDAAe,QAASk6B,EAAxB,uDAAmC,aAAnC,MAAqD,CACzEl6B,KAAM,UACNsH,SAAU,CACRtH,KAAMk6B,EACN3yB,YAAa,IAEfL,WAAY,CACVlH,OACAi6B,QACA9yB,qBAAsB,CACpBC,MAAO,OAMT+yB,EAAgBL,EAAa3rB,OAAO,GACpCisB,EAAiBJ,EAAcG,GAC7BE,EAAgBL,EAAc,UAAW,UAAW,cACpDnzB,EAAW,GACbyzB,EAAY,EAEP5yB,EAAQ,EAAG1L,EAAS89B,EAAav2B,SAASvH,OAAQ0L,EAAQ1L,EAAQ0L,IAAS,CAClF,IAAMyG,EAAS2rB,EAAa3rB,OAAOzG,GAC7BlE,EAAYs2B,EAAat2B,UAAUkE,GACnCnE,EAAWu2B,EAAav2B,SAASmE,GACjCwF,EAAS4sB,EAAa5sB,OAAOxF,GAE/BqyB,IACEv2B,EAAYu2B,GAAc,IAC5BO,GAAa,IACJ92B,EAAYu2B,EAAa,MAClCO,GAAa,MAIjB,IAAMC,EAAK,CAAC/2B,EAAY82B,EAAW/2B,GAC/B4K,IAAWgsB,GAA2B,IAAVzyB,IAC9Bb,EAASe,KAAKwyB,GACdA,EAAiBJ,EAAc7rB,IAGjCisB,EAAe9yB,SAASC,YAAYK,KAAK2yB,GACrCrtB,EAAS,IACXmtB,EAAc/yB,SAASC,YAAYK,KAAK2yB,GACxCF,EAAcnzB,WAAWC,qBAAqBC,MAAMQ,KAAKkyB,EAAalsB,SAASlG,KAEjF0yB,EAAelzB,WAAWC,qBAAqBC,MAAMQ,KAAKkyB,EAAalsB,SAASlG,IAEhFyyB,EAAgBhsB,EAChB4rB,EAAav2B,EAMf,OAHAqD,EAASe,KAAKwyB,GACdvzB,EAASe,KAAKyyB,GAEP,CACLr6B,KAAM,oBACN6G,YAuDiB2zB,CATQtvB,GAAU2uB,EAAW,CACxC,WACA,YACA,WACA,SACA,SACA,WAIIX,EAAiBG,GAAmBl4B,GACpC83B,EAAYO,GAAer4B,GAEjC6C,EAAS,CACPhE,KA1HkB,eA2HlBiE,QAAS,CACPlD,KACAI,OACA83B,YACAC,oBAGJl1B,EAASU,EAAeoQ,aAG1BwhB,MAAM74B,EAAK,CAAE6wB,QAAS,CAAEC,cAAe,UAAY7wB,KAChD6W,MAAK,SAACtX,GACL,GAAIA,EAAI2B,QAAU,IAAK,MAAM,IAAIuV,MAAMlX,EAAIw9B,YAC3C,OAAOx9B,EAAIs5B,UAEZhiB,MAAK,SAACpT,GACL,IAAM+3B,EAAiBG,GAAmBl4B,GACpC83B,EAAYO,GAAer4B,GACjC6C,EAAS,CACPhE,KA9IgB,eA+IhBiE,QAAS,CACPlD,KACAI,OACA83B,YACAC,oBAGAx3B,GACFq3B,GAAgBh4B,MAGnB01B,OAAM,SAACpL,GAAD,OAAS1f,QAAQC,KAAKyf,MAC5BqP,SAAQ,kBAAM12B,EAASU,EAAeoQ,UAK/C,IAAM6lB,GAAc,SAACC,GAAD,MAAc,CAChC56B,KAhK0B,eAiK1BiE,QAAS,CACP22B,aAISC,GAAe,eAACC,EAAD,uDAAa,GAAb,OAAoB,SAAC92B,EAAUW,GACzD,IAAMo2B,EAAap2B,IAAWH,IAAIyB,OAAO9E,KAErC25B,GACFA,EAAUhxB,SAAQ,SAACkxB,GACjB,IAAMJ,EAAUI,EAASj6B,GACnBk6B,EAAYF,EAAW5pB,MAAK,SAAC9K,GAAD,OAAOA,EAAEtF,KAAO65B,UAChC7+B,IAAdk/B,EACFj3B,EAAS01B,GAAUsB,IACVC,EAAU55B,QAAU25B,EAAS35B,OACtC2C,EAAS,CACPhE,KAlLkB,eAmLlBiE,QAAS,CACPlD,GAAIi6B,EAASj6B,GACbM,MAAO25B,EAAS35B,YAQ1B05B,EAAWjxB,SAAQ,SAACmxB,GACbH,GAAcA,EAAU3pB,MAAK,SAAC9K,GAAD,OAAOA,EAAEtF,KAAOk6B,EAAUl6B,OAC1DiD,EAAS22B,GAAYM,EAAUl6B,U,6LCpMrC,IAAMm6B,GAAuB,SAAC99B,EAAM+9B,GAAP,OAA2B,SAACC,GASvD,OAAOA,IAGMF,M,sMCHf,IAAM7J,GAAe,CACnBzsB,QAAS,KACTlH,WAAO3B,EACPwJ,eAAgB,CAAC,IAAIjB,KAAK,MAAO,IAAIA,MACrCmB,wBAAyB,KACzBI,OAAQ,KACRf,sBAAkB/I,EAClB2hB,aAAS3hB,EACT0hB,aAAS1hB,EACT2wB,YAAQ3wB,EACR0I,iBAAa1I,EACb8I,oBAAgB9I,EAChB4J,kBAAc5J,EACds/B,0BAAsBt/B,GA8DTu/B,MAAiB,SAdZ,CAClB12B,QAAS5D,IAAUQ,QAAQR,IAAUS,QACrC/D,MAAOsD,IAAUC,OACjBsE,eAAgBvE,IAAUQ,QAAQR,IAAUu6B,WAAWj3B,OACvDQ,iBAAkB9D,IAAU0qB,KAC5BhO,QAAS1c,IAAU0qB,KACnBjO,QAASzc,IAAU0qB,KACnBgB,OAAQ1rB,IAAU0qB,KAClBjnB,YAAazD,IAAU0qB,KACvB7mB,eAAgB7D,IAAU0qB,KAC1B/lB,aAAc3E,IAAU0qB,KACxB2P,qBAAsBr6B,IAAU0qB,MAGnB4P,EA3DO,WAAmC,IAAlCn3B,EAAiC,uDAAzBktB,GAAcmK,EAAW,uCACtD,OAAQA,EAAOx7B,MACb,IzB7BuB,cyB8BrB,OAAO,eACFmE,EADL,GAEKq3B,EAAOv3B,SAId,IzBnC+B,sByBoC7B,OAAO,eACFE,EADL,CAEEoB,eAAgBi2B,EAAOv3B,UAI3B,IzBzCyC,gCyB0CvC,OAAO,eACFE,EADL,CAEEsB,wBAAyB+1B,EAAOv3B,UAIpC,IzB/CwB,eyBgDtB,IAAMW,EAA4B,OAAlBT,EAAMS,QAAN,YAA6BT,EAAMS,SAAW,GAE9D,OADAA,EAAQgD,KAAK4zB,EAAOv3B,SACb,eAAKE,EAAZ,CAAmBS,YAGrB,IzBpD2B,kByBqDzB,IAAMA,EAAO,YAAOT,EAAMS,SACpB62B,EAAc72B,EAAQ0uB,WAAU,SAACjb,GAAD,OAAOA,IAAMmjB,EAAOv3B,WAE1D,OADAW,EAAQ8wB,OAAO+F,EAAa,GACrB,eAAKt3B,EAAZ,CAAmBS,YAGrB,IzB1D6B,oByB2D3B,OAAO,eAAKT,EAAZ,CAAmB0B,OAAQ21B,EAAOv3B,UAGpC,QACE,OAAOE,MC9DPktB,GAAe,CACnBlwB,KAAM,IAiDOm6B,MAAiB,SAhBZ,CAClBn6B,KAAMH,IAAUQ,QACdR,IAAU06B,MAAV,eACK56B,EADL,CAEEK,KAAMH,IAAUI,OAChB83B,eAAgBl4B,IAAUxG,MAC1By+B,UAAWj4B,IAAU06B,MAAM,CACzBviB,OAAQnY,IAAUS,OAClByX,OAAQlY,IAAUS,OAClB4X,OAAQrY,IAAUS,OAClB2X,OAAQpY,IAAUS,cAMX65B,EA9CO,WAAmC,IAAlCn3B,EAAiC,uDAAzBktB,GAAcmK,EAAW,uCACtD,OAAQA,EAAOx7B,MACb,IHNqB,YGOnB,IAAMmB,EAAI,sBAAOgD,EAAMhD,MAAb,CAAmBq6B,EAAOv3B,UACpC,OAAO,eAAKE,EAAZ,CAAmBhD,SAGrB,IHVwB,eGWtB,IAAMw6B,EAAYH,EAAOv3B,QACnB9C,EAAOgD,EAAMhD,KAAKqD,KAAI,SAAC2D,GAC3B,OAAIA,EAAMpH,KAAO46B,EAAU56B,GAAWoH,EAC/B,eACFA,EADL,GAEKwzB,MAGP,OAAO,eAAKx3B,EAAZ,CAAmBhD,SAGrB,IHrBwB,eGsBtB,IAAMy6B,EAAiBJ,EAAOv3B,QAAQ22B,QAChCz5B,EAAOgD,EAAMhD,KAAKiF,QAAO,SAAC+B,GAAD,OAAWA,EAAMpH,KAAO66B,KACvD,OAAO,eAAKz3B,EAAZ,CAAmBhD,SAGrB,QACE,OAAOgD,MCpBPktB,GAAe,CAGnBrc,cAAe,GAGfJ,eAAgB,GAChB8C,mBAAoB,CAAEf,SAAS,GAC/BkU,yBAA0B,MCftBwG,GAAe,CACnBvgB,oBAAqB,GACrBG,mBAAoB,GACpBX,sBAAuB,GACvBE,yBAA0B,ICVtB6gB,GAAe,CACnBxrB,OAAQ,YCMJg2B,GAAaC,YAAgB,CACjC7hC,OAAQ8hC,GACR91B,OAAQ+1B,GACR/mB,QHca,WAAwC,IAA/B9Q,EAA8B,uDAAtBktB,GAAcmK,EAAQ,uCACpD,OAAQA,EAAOx7B,MACb,IpBZ+B,sBoBa7B,OAAO4M,OAAOqvB,OAAO,GAAI93B,EAAO,CAAE6Q,cAAewmB,EAAOv3B,UAG1D,IpBbF,uDoBcI,IAAM+Q,EAAgB7Q,EAAM6Q,cAY5B,OAXAA,EAAcwmB,EAAOv3B,QAAQiQ,SAASsB,8BACpCgmB,EAAOv3B,QAAQqS,iCAIjBtB,EAAcwmB,EAAOv3B,QAAQiQ,SAASjB,MAAMnJ,SAAQ,SAACyH,GACnDA,EAAK+D,6BAA+BI,KAClCnE,EAAK+D,6BACLkmB,EAAOv3B,QAAQuS,mBAGZ,eAAKrS,EAAZ,CAAmB6Q,kBAGrB,IpBpC6B,oBoBqC3B,IAAMA,EAAgBpI,OAAOqvB,OAAO,GAAI93B,EAAM6Q,cAAxBpI,OAAA,IAAAA,CAAA,GACnB4uB,EAAOv3B,QAAQlD,GADI6L,OAAA,IAAAA,CAAA,CAElBqG,MAAO,IACJuoB,EAAOv3B,WAGd,OAAO2I,OAAOqvB,OAAO,GAAI93B,EAAO,CAAE6Q,kBAGpC,IpB7CsC,6BoB8CpC,IAAMkD,EAAWsjB,EAAOv3B,QAClB+R,EAAK,eAAQ7R,EAAM6Q,cAAckD,EAASnX,IAArC,GAA6CmX,GAClDlD,EAAa,eAAQ7Q,EAAM6Q,cAAd,eAA8BkD,EAASnX,GAAKiV,IAC/D,OAAO,eAAK7R,EAAZ,CAAmB6Q,kBAGrB,IpBhDgC,uBoBiD9B,IAAMA,EAAgBpI,OAAOqvB,OAAO,GAAI93B,EAAM6Q,eAE9C,cADOA,EAAcwmB,EAAOv3B,QAAQlD,IAC7B6L,OAAOqvB,OAAO,GAAI93B,EAAO,CAAE6Q,kBAGpC,IpBzD8B,qBoB0D5B,OAAOpI,OAAOqvB,OAAO,GAAI93B,EAAO,CAAEyQ,eAAe,GAAD,mBAAMzQ,EAAMyQ,gBAAZ,CAA4B4mB,EAAOv3B,YAGrF,IpBvD+B,sBoBwD7B,IAAMiQ,EAAUsnB,EAAOv3B,QAAQiQ,QACzBgoB,EAAUV,EAAOv3B,QAAQsN,KACzByE,EAAK,eAAQ7R,EAAM6Q,cAAcd,IACnCioB,EAAU,YAAOnmB,EAAM/C,OACrBmpB,EAAYD,EAAW7I,WAAU,SAACjtB,GAAD,OAAOA,EAAE+K,MAAQ8qB,EAAQ9qB,QAC7C,IAAfgrB,EACFD,EAAWv0B,KAAKs0B,GAEhBC,EAAU,sBACLA,EAAWh9B,MAAM,EAAGi9B,IADf,CAERF,GAFQ,YAGLC,EAAWh9B,MAAMi9B,EAAY,KAGpCpmB,EAAM/C,MAAQkpB,EACd,IAAMnnB,EAAa,eAAQ7Q,EAAM6Q,cAAd,eAA8Bd,EAAU8B,IAC3D,OAAO,eAAK7R,EAAZ,CAAmB6Q,kBAGrB,IpB1EiC,wBoB2E/B,IAAMvB,EAAO+nB,EAAOv3B,QAGd0Q,EAAW/H,OAAOC,KAAK1I,EAAM6Q,eAC7BA,EAAa,eAAQ7Q,EAAM6Q,eACjCL,EAAS7K,SAAQ,SAACoK,GAChB,IAAMiE,EAAS,eAAQnD,EAAcd,IACrCT,EAAK3J,SAAQ,SAACuyB,GACZ,IAAMC,EAAoBnkB,EAAUlF,MAAMqgB,WAAU,SAAC/hB,GAAD,OAAUA,EAAKH,MAAQirB,KACvEC,GAAqB,GAEvBnkB,EAAUlF,MAAMyiB,OAAO4G,EAAmB,SAMhD,IAAI1nB,EAAc,YAAOzQ,EAAMyQ,gBAW/B,OAVAnB,EAAK3J,SAAQ,SAACuyB,GACZ,IAAME,EAAuB3nB,EAAe0e,WAAU,SAAC/hB,GAAD,OAAUA,EAAKH,MAAQirB,KACzEE,GAAwB,IAC1B3nB,EAAc,sBACTA,EAAezV,MAAM,EAAGo9B,IADf,YAET3nB,EAAezV,MAAMo9B,EAAuB,SAK9C,eAAKp4B,EAAZ,CAAmB6Q,gBAAeJ,mBAGpC,IpBzG+B,sBoB0G7B,IAAM4nB,EAAgB,eAAQr4B,EAAM6Q,eACpC,OAAO,eAAK7Q,EAAZ,CAAmB6Q,cAAewnB,IAGpC,IpBrH6B,oBoBsH3B,OAAO5vB,OAAOqvB,OAAO,GAAI93B,EAAO,CAAEuT,mBAAoB8jB,EAAOv3B,UAG/D,IpBjHoC,2BoBkHlC,OAAO,eAAKE,EAAZ,CAAmB0mB,yBAA0B2Q,EAAOv3B,UAGtD,IpBpH0C,iCoBqHxC,OAAO,eAAKE,EAAZ,CAAmB0mB,yBAA0B,OAG/C,QACE,OAAO1mB,IGpIXkM,aFEa,WAAwC,IAA/BlM,EAA8B,uDAAtBktB,GAAcmK,EAAQ,uCACpD,OAAQA,EAAOx7B,MACb,ItBHuC,8BsBIrC,IAAM8Q,EAAsB,GAAG9D,OAAOwuB,EAAOv3B,SAC7C,OAAO,eAAKE,EAAZ,CAAmB2M,wBAGrB,ItBPsC,6BsBQpC,IAAMG,EAAqB,GAAGjE,OAAOwuB,EAAOv3B,SAC5C,OAAO,eAAKE,EAAZ,CAAmB8M,uBAGrB,ItBX2C,kCsBYzC,IAAMX,EAAwBjD,KAC5BlJ,EAAMmM,sBAAsBtD,OAAOwuB,EAAOv3B,QAAQqN,kBAE9Cd,EAA2BnD,KAC/BlJ,EAAMqM,yBAAyBxD,OAAOwuB,EAAOv3B,QAAQ+M,qBAGjDyrB,EAAqBnsB,EAAsBlK,QAC/C,SAACi2B,GAAD,OAA4D,IAA/C7rB,EAAyB/F,QAAQ4xB,MAEhD,OAAO,eAAKl4B,EAAZ,CAAmBmM,sBAAuBmsB,EAAoBjsB,6BAGhE,ItBxBqC,4BsByBnC,IAAMF,EAAwBnM,EAAMmM,sBAC9BosB,EAAyBlB,EAAOv3B,QAChC04B,EAA2BrsB,EAAsBlK,QACrD,SAACi2B,GAAD,OAA0D,IAA7CK,EAAuBjyB,QAAQ4xB,MAE9C,OAAO,eAAKl4B,EAAZ,CAAmBmM,sBAAuBqsB,IAG5C,ItBhCqC,4BsBiCnC,OAAO,eAAKx4B,EAAZ,CAAmBqM,yBAA0B,KAG/C,QACE,OAAOrM,IEzCXkE,Mb+Ca,WAAwC,IAA/BlE,EAA8B,uDAAtBktB,GAAcmK,EAAQ,uCACpD,OAAQA,EAAOx7B,MACb,KAAK0xB,GACH,IAAMkL,EAAcz4B,EAAM+X,SAAS2W,MAAM,CAAC,UAAW2I,EAAOv3B,QAAQouB,YACpE,OAAO,eAAKluB,EAAZ,CAAmB+X,SAAU0gB,IAE/B,KAAKjL,GACH,OAAO,eAAKxtB,EAAZ,CAAmB+X,SAAUsf,EAAOv3B,UAEtC,KAAK4tB,GACH,OAAO,eAAK1tB,EAAZ,CAAmBwrB,aAAc6L,EAAOv3B,UAE1C,KAAK6tB,GACH,OAAO,eAAK3tB,EAAZ,CAAmBotB,cAAeiK,EAAOv3B,UAE3C,KAAK2tB,GACH,IAAMN,EAAuB,sBAAOntB,EAAMmtB,yBAAb,YAAyCkK,EAAOv3B,UAC7E,OAAO,eAAKE,EAAZ,CAAmBmtB,4BAErB,QACE,OAAOntB,IalEXc,SVuBa,WAAwC,IAA/Bd,EAA8B,uDAAtBktB,GAAcmK,EAAQ,uCACpD,OAAQA,EAAOx7B,MACb,IZnCwB,eYoCtB,OAAO,eACFmE,EADL,CAEEc,SAAUu2B,EAAOv3B,QACjBkB,UAAWq2B,EAAOv3B,QAAQP,KAAOS,EAAMuqB,QACvCtpB,WAAYo2B,EAAOv3B,QAAQP,KAAOS,EAAMwqB,QACxCrb,SAAUnP,EAAMc,SAASvB,OAI7B,IZ9CsB,aY+CpB,OAAO,eACFS,EADL,CAEEe,OAAQs2B,EAAOv3B,UAInB,IZnD2B,kBYoDzB,IAAMgB,EAAQ,eAAQd,EAAMc,SAAd,GAA2Bu2B,EAAOv3B,SAChD,OAAO,eACFE,EADL,CAEEc,WACAqO,SAAUrO,EAASvB,OAIvB,IZ3D8B,qBY4D5B,IAAMm5B,EAAc14B,EAAMc,SAASvB,KAC7BA,EAAOqM,KAAK7P,IAChBiE,EAAMuqB,QACN8M,EAAOv3B,QAAQP,MAAQm5B,EAAcrB,EAAOv3B,QAAQ0U,WAEhD1T,EAAQ,eACTd,EAAMc,SADG,GAETkzB,GAFS,CAGZz0B,OACAH,SAC8B,OAA5Bi4B,EAAOv3B,QAAQV,SAAoBY,EAAMc,SAAS1B,SAAWi4B,EAAOv3B,QAAQV,SAC9EC,UAC+B,OAA7Bg4B,EAAOv3B,QAAQT,UAAqBW,EAAMc,SAASzB,UAAYg4B,EAAOv3B,QAAQT,YAElF,OAAO,eACFW,EADL,CAEEc,WACAE,UAAWzB,EAAOS,EAAMuqB,QACxBtpB,WAAY1B,EAAOS,EAAMwqB,QACzBrb,SAAUnP,EAAMc,SAASvB,KACzBsO,kBAAmBrJ,EAAgBC,OAIvC,IZnF8B,qBYoF5B,OAAO,eAAKzE,EAAZ,CAAmBkB,aAAcm2B,EAAOv3B,UAG1C,IZtF0B,iBYuFxB,OAAO,eAAKE,EAAZ,CAAmB6N,kBAAmB,OAGxC,IZzF+B,sBY0F7B,OAAO,eAAK7N,EAAZ,GAAsBq3B,EAAOv3B,SAG/B,QACE,OAAOE,IUxFXssB,YDVa,WAAwC,IAA/BtsB,EAA8B,uDAAtBktB,GAAcmK,EAAQ,uCACpD,OAAQA,EAAOx7B,MACb,IpBF0B,iBoBGxB,OAAO,eAAKmE,EAAZ,CAAmB0B,OAAQ21B,EAAOv3B,UAEpC,QACE,OAAOE,MCOE03B,M,6MCIf,IAAMA,GAAaC,YAAgB,CACjCt3B,IAAKs4B,KAGPnE,GAAMoE,eAAelB,IAErB,IAAMmB,GAA8BjK,KAAS,SAACxtB,GAC5CozB,GAAM30B,SAASgvB,GAAoBztB,IACnCozB,GAAM30B,SAASsB,EAAkBC,MAChC,IAEG03B,GAAkC,SAACC,GACvCvE,GAAM30B,SACJwU,GAAe,CACbjV,SAAU25B,EAAiBv5B,OAAO,GAClCH,UAAW05B,EAAiBv5B,OAAO,GACnCD,KAAMw5B,EAAiBx5B,SAKvBy5B,G,4MACJh5B,MAAQ,CACNi5B,aAAa,EACb3+B,MAAO,KACP4+B,UAAW,M,gEAGK5+B,EAAO4+B,GACvB1xB,QAAQiE,IAAInR,EAAO4+B,GACnB9/B,KAAKyqB,SAAS,CACZvpB,MAAOA,EACP4+B,UAAWA,M,+CAQethC,IAAxBwB,KAAKwG,MAAMkB,UACbg4B,GAAgC1/B,KAAKwG,MAAMkB,UAIf,OAA1B1H,KAAKwG,MAAMsuB,YACbsG,GAAM30B,SACJouB,GAAU,CACRC,WAAY90B,KAAKwG,MAAMsuB,mBAMWt2B,IAApCwB,KAAKwG,MAAMs3B,sBACb99B,KAAKwG,MAAMs3B,qBAAqB1C,GAAMh0B,WAAWH,IAAI6D,MAAMwoB,cAGzD8H,SAA+C58B,IAAtC48B,GAAMh0B,WAAWH,IAAIvK,OAAOyD,OACvCi7B,GAAM30B,SACJF,EAAW,CACTpG,MAAOH,KAAKwG,MAAMrG,MAClB4f,gBAAiB/f,KAAKwG,MAAMuZ,gBAC5BtG,UAAWzZ,KAAKwG,MAAMiT,UACtBlS,iBAAkBvH,KAAKwG,MAAMe,iBAC7B4Y,QAASngB,KAAKwG,MAAM2Z,QACpBD,QAASlgB,KAAKwG,MAAM0Z,QACpBiP,OAAQnvB,KAAKwG,MAAM2oB,OACnBjoB,YAAalH,KAAKwG,MAAMU,YACxBI,eAAgBtH,KAAKwG,MAAMc,eAC3Bc,aAAcpI,KAAKwG,MAAM4B,aACzB01B,qBAAsB99B,KAAKwG,MAAMs3B,wBAKI,OAAvC99B,KAAKwG,MAAM0B,yBAAoClI,KAAKwG,MAAM0B,wBAAwBzJ,QACpF28B,GAAM30B,SAASwB,EAA2BjI,KAAKwG,MAAM0B,2BAIvB,OAA7BlI,KAAKwG,MAAMwtB,eAA0Bh0B,KAAKwG,MAAMwtB,cAAcv1B,QAClC,OAA5BuB,KAAKwG,MAAM4rB,cAAyBpyB,KAAKwG,MAAM4rB,aAAa3zB,SAE7D28B,GAAM30B,SACJ+yB,GAAmBx5B,KAAKwG,MAAM4rB,cAAgB,GAAIpyB,KAAKwG,MAAMwtB,eAAiB,KAIxD,OAAtBh0B,KAAKwG,MAAMkC,QACb0yB,GAAM30B,SAAS62B,GAAat9B,KAAKwG,MAAMkC,SAKP,OAA9B1I,KAAKwG,MAAMwB,gBAA2BhI,KAAKwG,MAAMwB,eAAevJ,QAClEghC,GAA4Bz/B,KAAKwG,MAAMwB,gBAIzChI,KAAKyqB,SAAS,CACZoV,aAAa,IAIkB,OAA7B7/B,KAAKwG,MAAMiR,eACb2jB,GAAM30B,SAAS8T,GAAoBva,KAAKwG,MAAMiR,cAAezX,KAAKwG,MAAM6P,uB,yCAIzD0pB,GAEb//B,KAAKwG,MAAMkC,SAAWq3B,EAAUr3B,QAClC0yB,GAAM30B,SAAS62B,GAAat9B,KAAKwG,MAAMkC,SAIrC1I,KAAKwG,MAAMiR,gBAAkBsoB,EAAUtoB,eACzC2jB,GAAM30B,SAAS8T,GAAoBva,KAAKwG,MAAMiR,cAAezX,KAAKwG,MAAM6P,sBAK1C,OAA7BrW,KAAKwG,MAAMwtB,eAA0Bh0B,KAAKwG,MAAMwtB,cAAcv1B,QAClC,OAA5BuB,KAAKwG,MAAM4rB,cAAyBpyB,KAAKwG,MAAM4rB,aAAa3zB,UAG3DuB,KAAKwG,MAAMwtB,gBAAkB+L,EAAU/L,eACvCh0B,KAAKwG,MAAM4rB,eAAiB2N,EAAU3N,cAEtCgJ,GAAM30B,SACJ+yB,GAAmBx5B,KAAKwG,MAAM4rB,cAAgB,GAAIpyB,KAAKwG,MAAMwtB,eAAiB,MAM9C,OAAlCh0B,KAAKwG,MAAM6P,oBAA+BrW,KAAKwG,MAAM6P,mBAAmB5X,SAEvC,OAAjCshC,EAAU1pB,oBACT0pB,EAAU1pB,mBAAmB5X,QAC9BuB,KAAKwG,MAAM6P,mBAAmB,GAAGrP,YAAc+4B,EAAU1pB,mBAAmB,GAAGrP,WAC/EhH,KAAKwG,MAAM6P,mBAAmB,GAAGrP,YAAc+4B,EAAU1pB,mBAAmB,GAAGrP,WAE/Eo0B,GAAM30B,SAASkS,GAA+B3Y,KAAKwG,MAAM6P,sBAI3B,OAA9BrW,KAAKwG,MAAMwB,gBAA2BhI,KAAKwG,MAAMwB,eAAevJ,SAEnC,OAA7BshC,EAAU/3B,gBACT+3B,EAAU/3B,eAAevJ,QAC1BuB,KAAKwG,MAAMwB,eAAe,GAAGhB,YAAc+4B,EAAU/3B,eAAe,GAAGhB,WACvEhH,KAAKwG,MAAMwB,eAAe,GAAGhB,YAAc+4B,EAAU/3B,eAAe,GAAGhB,WAEvEy4B,GAA4Bz/B,KAAKwG,MAAMwB,iBAKA,OAAvChI,KAAKwG,MAAM0B,yBAAoClI,KAAKwG,MAAM0B,wBAAwBzJ,OAE5C,OAAtCshC,EAAU73B,yBACT63B,EAAU73B,wBAAwBzJ,QACnCuB,KAAKwG,MAAM0B,wBAAwB,GAAGlB,YACpC+4B,EAAU73B,wBAAwB,GAAGlB,WACvChH,KAAKwG,MAAM0B,wBAAwB,GAAGlB,YACpC+4B,EAAU73B,wBAAwB,GAAGlB,WAEvCo0B,GAAM30B,SAASwB,EAA2BjI,KAAKwG,MAAM0B,0BAGnDlI,KAAKwG,MAAM0B,0BAA4B63B,EAAU73B,yBACnDkzB,GAAM30B,SAASwB,EAA2BjI,KAAKwG,MAAM0B,0BASzD,IAAM83B,EAAkB5E,GAAMh0B,WAAWH,IAAIS,SAASA,cAG5BlJ,IAAxBwB,KAAKwG,MAAMkB,UACyC,OAApD0zB,GAAMh0B,WAAWH,IAAIS,SAAS+M,oBAG5BurB,EAAgBh6B,WAAahG,KAAKwG,MAAMkB,SAAStB,OAAO,IACxD45B,EAAgB/5B,YAAcjG,KAAKwG,MAAMkB,SAAStB,OAAO,IACzD45B,EAAgB75B,OAASnG,KAAKwG,MAAMkB,SAASvB,OAGqB,IAA9DqM,KAAK4Q,IAAI4c,EAAgB75B,KAAOnG,KAAKwG,MAAMkB,SAASvB,MACtDi1B,GAAM30B,SAAS4U,GAAiBrb,KAAKwG,MAAMkB,WAE3Cg4B,GAAgC1/B,KAAKwG,MAAMkB,YAK7C1H,KAAKwG,MAAM8B,SAAWy3B,EAAUz3B,QAClC8yB,GAAM30B,SAAS4B,EAAUrI,KAAKwG,MAAM8B,W,+BAItC,OAAyB,OAArBtI,KAAK4G,MAAM1F,OACbkN,QAAQiE,IAAIrS,KAAK4G,MAAM1F,OAErB,6BACE,sDACA,uBAAGwwB,UAAU,OAAO1xB,KAAK4G,MAAM1F,OAASlB,KAAK4G,MAAM1F,MAAM6B,YACzD,+DACA,uBAAG2uB,UAAU,OAAO1xB,KAAK4G,MAAMk5B,UAAUG,mBAKb,IAA3BjgC,KAAK4G,MAAMi5B,YAAuB,KACvC,kBAAC,IAAD,CAAUzE,MAAOA,IACf,kBAAC,GAAQp7B,KAAKwG,Y,GAxMEmjB,IAAMC,WAyO9BgW,GAAU3Q,aAAe,CACvB9uB,MAAO,KACP20B,WAAY,KACZ/U,iBAAiB,EACjBtG,UAAW,SAACtH,GAAD,OAA+B,IAApBA,EAAMsH,WAC5BvR,wBAAyB,KACzBQ,OAAQ,KACR4oB,WAAY,KACZD,WAAY,KACZ5Z,cAAe,KACfzP,eAAgB,KAChBqO,mBAAoB,KACpB2d,cAAe,KACf5B,aAAc,KACd9pB,OAAQ,KACRf,iBAAkB,aAClB4nB,OAAQ,aACRjoB,YAAa,aACbI,eAAgB,aAChB4Y,QAAS,aACTC,QAAS,aACT2d,qBAAsB,aACtB11B,aAAc,cAGDw3B,U,iMC7Sf,IAAMM,GAAqB3M,GAAS9V,SAAS,sB,8yDCM7C,IAKM0iB,GAAc,GAIL,SAASC,GAAT,GAGX,IAFFC,EAEC,EAFDA,WACG75B,EACF,8BACD,OAAO,YALS,UAKT,eAAe25B,GAAiB35B,EAAhC,CAAuC65B,WAAYA,EAAYC,QAAQ,cAE5E,iBAAQ,CACN,GAAM,OADR,OAGA,iBAAQ,CACN,GAAM,eADR,eAGA,6IACA,sBACE,kBAAIC,WAAW,MAAK,6BAAGA,WAAW,MAAS,CACvC,KAAQ,4IADQ,eAGpB,kBAAIA,WAAW,MAAK,6BAAGA,WAAW,MAAS,CACvC,KAAQ,gJADQ,oBAGpB,kBAAIA,WAAW,MAAK,6BAAGA,WAAW,MAAS,CACvC,KAAQ,8HADQ,iBAItB,iBAAQ,CACN,GAAM,wBADR,wBAGA,gEACA,iBAAQ,CACN,GAAM,eADR,eAGA,YAAC,IAAD,CAAYC,WAAY,EAAGC,OAAQ,0DAA2DC,QAAS,CACrGl6B,MAAOxG,KAAOA,KAAKwG,MAAQA,EAC3Bm6B,eACAC,UACA1R,QACC2R,cAAa,+q9FAAkr9FP,QAAQ,cAC5s9F,YAAC,GAAD,CAAK54B,SAAU,CACTtB,OAAQ,CAAC,KAAO,QAChBD,KAAM,GACLm6B,QAAQ,U,0KAMjBF,GAAWU,gBAAiB","file":"static/js/src-map-map.b16eabf5.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"map\":\"map_map__1TLha\",\"googleLogo\":\"map_googleLogo__3lQ1y\"};","/* eslint-disable */\nvar byname = {\n  Uint8: {\n    size: Uint8Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint8',\n    setter: 'setUint8',\n  },\n  Int8: {\n    size: Int8Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint8',\n    setter: 'setUint8',\n  },\n  Uint16: {\n    size: Uint16Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint16',\n    setter: 'setUint16',\n  },\n  Int16: {\n    size: Int16Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getInt16',\n    setter: 'setInt16',\n  },\n  Uint32: {\n    size: Uint32Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getUint32',\n    setter: 'setUint32',\n  },\n  Int32: {\n    size: Int32Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getInt32',\n    setter: 'setInt32',\n  },\n  Float32: {\n    size: Float32Array.BYTES_PER_ELEMENT,\n    array: 'Float32Array',\n    getter: 'getFloat32',\n    setter: 'setFloat32',\n  },\n  Float64: {\n    size: Float64Array.BYTES_PER_ELEMENT,\n    array: 'Float64Array',\n    getter: 'getFloat64',\n    setter: 'setFloat64',\n  },\n}\n\nvar writeStringToArrayBuffer = function(str, start, end, buf, bufstart) {\n  if (end == undefined) {\n    end = str.length\n  }\n  if (start == undefined) {\n    start = 0\n  }\n  if (bufstart == undefined) {\n    bufstart = start\n  }\n  for (var i = start; i < end; i++) {\n    buf[i - start + bufstart] = str.charCodeAt(i) & 0xff\n  }\n}\n\nvar stringToArrayBuffer = function(str, start, end) {\n  var self = this\n\n  if (end == undefined) {\n    end = str.length\n  }\n  if (start == undefined) {\n    start = 0\n  }\n  var res = new Uint8ClampedArray(end - start)\n  writeStringToArrayBuffer(str, start, end, res, 0)\n  return res.buffer\n}\n\nvar arrayBufferToString = function(buf) {\n  return String.fromCharCode.apply(null, new Uint8Array(buf))\n}\n\nvar pack = function(typespec, value, littleendian) {\n  var array = new ArrayBuffer(typespec.size)\n  new DataView(array)[typespec.setter](0, value, littleendian)\n  return arrayBufferToString(array)\n}\n\nvar Pack = {\n  typemap: {\n    byname: byname,\n    byarray: {},\n  },\n  pack: pack,\n  arrayBufferToString: arrayBufferToString,\n  stringToArrayBuffer: stringToArrayBuffer,\n  writeStringToArrayBuffer: writeStringToArrayBuffer,\n}\nfor (var name in Pack.typemap.byname) {\n  var spec = Pack.typemap.byname[name]\n  spec.name = name\n  Pack.typemap.byarray[spec.array] = spec\n}\n\nexport default Pack\n","/* eslint-disable */\n\nimport Pack from './Pack'\n\nclass PelagosClient {\n  constructor() {\n    this.MAGIC_COOKIE = 'tmtx'\n  }\n\n  obtainTile(url, token) {\n    return new Promise(\n      function(resolve, reject) {\n        this.request = null\n        if (typeof XMLHttpRequest != 'undefined') {\n          this.request = new XMLHttpRequest()\n        } else {\n          throw 'XMLHttpRequest is disabled'\n        }\n        this.resolve = resolve\n        this.reject = reject\n        this.request.open('GET', url, true)\n        if (token) {\n          this.request.setRequestHeader('Authorization', `Bearer ${token}`)\n        }\n        this.request.responseType = 'arraybuffer'\n        this.request.onload = this.handleData.bind(this)\n        this.request.onerror = this.handleData.bind(this)\n        this.request.send(null)\n      }.bind(this)\n    )\n  }\n\n  handleData() {\n    var self = this\n    if (!this.request) {\n      return\n    }\n    if (this.error) {\n      return true\n    }\n\n    if (this.request.readyState == 4) {\n      /* HTTP reports success with a 200 status. The file protocol\n       reports success with zero. HTTP returns zero as a status\n       code for forbidden cross domain requests.\n       https://developer.mozilla.org/En/Using_XMLHttpRequest */\n      var success = this.request.status == 200 || (this.isFileUri && this.request.status == 0)\n      if (!success) {\n        this.resolve(null)\n        return\n      }\n    }\n\n    if (!this.request.response) {\n      return\n    }\n    var length = this.request.response.byteLength\n    var response = this.request.response\n    var dataView = new DataView(response)\n\n    if (length < 4 + 4) {\n      return\n    }\n    if (self.headerLen == null) {\n      var cookie = Pack.arrayBufferToString(response.slice(0, 4))\n      if (cookie != this.MAGIC_COOKIE) {\n        this.reject(\n          'Could not load ' +\n            this.url +\n            ' due to incorrect file format. Cookie: [' +\n            this.cookie +\n            ']'\n        )\n        return\n      }\n\n      self.headerLen = dataView.getInt32(4, true)\n\n      self.offset = 4 + 4\n    }\n    if (length < self.offset + self.headerLen) {\n      return\n    }\n    if (!self.headerIsLoaded) {\n      self.header = JSON.parse(\n        Pack.arrayBufferToString(response.slice(self.offset, self.offset + self.headerLen))\n      )\n      self.rowLen = 0\n      self.header.colsByName = {}\n      for (var colidx = 0; colidx < self.header.cols.length; colidx++) {\n        var col = self.header.cols[colidx]\n        col.idx = colidx\n        self.header.colsByName[col.name] = col\n        col.typespec = Pack.typemap.byname[col.type]\n\n        if (col.multiplier != undefined && col.min != undefined) {\n          col.min = col.min * col.multiplier\n        }\n        if (col.offset != undefined && col.min != undefined) {\n          col.min = col.min + col.offset\n        }\n        if (col.multiplier != undefined && col.max != undefined) {\n          col.max = col.max * col.multiplier\n        }\n        if (col.offset != undefined && col.max != undefined) {\n          col.max = col.max + col.offset\n        }\n\n        self.rowLen += col.typespec.size\n      }\n      self.offset += self.headerLen\n\n      // Add the padding to nearest 4-byte-boundary\n      self.offset += (4 - (self.headerLen % 4)) % 4\n\n      self.headerIsLoaded = true\n      if (self.header.orientation != 'rowwise' && self.header.orientation != 'columnwise') {\n        self.errorLoading({\n          orientation: self.header.orientation,\n          toString: function() {\n            return (\n              'Could not load ' +\n              this.url +\n              ' due to unsupported file orientation. Orientation: ' +\n              this.orientation +\n              '. Supported orientations: rowwise, columnwise.'\n            )\n          },\n        })\n        return true\n      }\n\n      // Empty tile, stop parsing.\n      if (!self.rowLen) {\n        self.allLoaded()\n        return true\n      }\n    }\n    if (self.header.orientation == 'rowwise') {\n      var result = {}\n      for (; self.offset + self.rowLen <= length; self.rowidx++) {\n        var row = {}\n        for (var colidx = 0; colidx < self.header.cols.length; colidx++) {\n          var col = self.header.cols[colidx]\n          var val = dataView[col.typespec.getter](self.offset, true)\n          row[col.name] = val\n          self.offset += col.typespec.size\n        }\n        // self.rowLoaded(row);\n\n        result[col.name] = row\n      }\n      if (self.rowidx == self.header.length) {\n        // self.allLoaded();\n        this.resolve(result)\n      } else {\n        // self.batchLoaded();\n      }\n    } else if (self.header.orientation == 'columnwise') {\n      var colValues = null\n      var result = {}\n      if (length >= self.offset + self.header.length * self.rowLen) {\n        for (var colidx = 0; colidx < self.header.cols.length; colidx++) {\n          var col = self.header.cols[colidx]\n\n          colValues = new (eval(col.typespec.array))(\n            response.slice(self.offset, self.offset + col.typespec.size * self.header.length)\n          )\n          self.offset += self.header.length * col.typespec.size\n\n          result[col.name] = colValues\n        }\n\n        // self.allLoaded();\n        this.resolve(result)\n        return true\n      }\n    }\n  }\n}\n\nexport default PelagosClient\n","import PropTypes from 'prop-types'\n\nexport const trackTypes = {\n  id: PropTypes.string.isRequired,\n  url: PropTypes.string,\n  data: PropTypes.object,\n  color: PropTypes.string,\n  type: PropTypes.oneOf(['geojson', 'pelagos', undefined]),\n  layerTemporalExtents: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.number)),\n  fitBoundsOnLoad: PropTypes.bool,\n}\n","import PropTypes from 'prop-types'\n\nexport const heatmapLayerTypes = {\n  id: PropTypes.string.isRequired,\n  tilesetId: PropTypes.string,\n  subtype: PropTypes.string,\n  visible: PropTypes.bool,\n  hue: PropTypes.number,\n  opacity: PropTypes.number,\n  filters: PropTypes.arrayOf(\n    PropTypes.shape({\n      // hue overrides layer hue if set\n      hue: PropTypes.number,\n      // filterValues is a dictionary in which each key is a filterable field,\n      // and values is an array of all possible values (OR filter)\n      // ie: filterValues: { category: [5, 6] }\n      filterValues: PropTypes.object,\n    })\n  ),\n  header: PropTypes.shape({\n    endpoints: PropTypes.object,\n    colsByName: PropTypes.object,\n    temporalExtents: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.number)),\n    temporalExtentsLess: PropTypes.bool,\n  }).isRequired,\n  interactive: PropTypes.bool,\n}\n\nexport const basemapLayerTypes = {\n  id: PropTypes.string,\n  visible: PropTypes.bool,\n}\n\nexport const staticLayerTypes = {\n  id: PropTypes.string.isRequired,\n  // TODO MAP MODULE Is that needed and if so why\n  visible: PropTypes.bool,\n  selected: PropTypes.bool,\n  selectedFeatures: PropTypes.shape({\n    field: PropTypes.string,\n    values: PropTypes.arrayOf(PropTypes.string),\n  }),\n  highlighted: PropTypes.bool,\n  higlightedFeatures: PropTypes.shape({\n    field: PropTypes.string,\n    values: PropTypes.arrayOf(PropTypes.string),\n  }),\n  opacity: PropTypes.number,\n  color: PropTypes.string,\n  showLabels: PropTypes.bool,\n  interactive: PropTypes.bool,\n  filters: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.string)),\n  isCustom: PropTypes.bool,\n  subtype: PropTypes.oneOf([undefined, 'geojson', 'raster']),\n  url: PropTypes.string,\n  data: PropTypes.object,\n  gl: PropTypes.object,\n}\n","import PropTypes from 'prop-types'\n\nexport const popupTypes = {\n  content: PropTypes.node,\n  latitude: PropTypes.number.isRequired,\n  longitude: PropTypes.number.isRequired,\n}\n\nexport const viewportTypes = {\n  zoom: PropTypes.number,\n  center: PropTypes.arrayOf(PropTypes.number),\n}\n","// Application settings\nexport const TIMELINE_STEP = 24 * 60 * 60 * 1000 // 1 day\nexport const MIN_FRAME_LENGTH_MS = TIMELINE_STEP // 1 day\n\n// vessels rendering\n// from this zoom level and above, render using circle style instead of heatmap\nexport const VESSELS_RADIAL_GRADIENT_STYLE_ZOOM_THRESHOLD = 6\n// the base radius, it can only be scaled down by the radius factor calculated on the dataset\nexport const VESSELS_BASE_RADIUS = 8\n// in heatmap style, defines how 'blurry' a point will look. Higher = less blur\nexport const VESSELS_HEATMAP_BLUR_FACTOR = 0.15\n\nexport const ACTIVITY_HIGHLIGHT_HUE = 312\n\nexport const VESSELS_HEATMAP_DIMMING_ALPHA = 0.5\n\nexport const MAX_SPRITES_PER_LAYER = 200000\n\n// interaction\n// radius of vessels lookup in pixels,\n// ie how large the clicked region should be for including vessels\nexport const VESSEL_CLICK_TOLERANCE_PX = 10\n\nexport const CLUSTER_CLICK_ZOOM_INCREMENT = 1\n\nexport const MIN_ZOOM_LEVEL = 1\n// user can zoom up to this z level, but it doesn't guarantee availability of tiles\nexport const MAX_ZOOM_LEVEL = 14\n\n// data\n// Limit tile loading for activity layers up to this z level.\n// Beyond, layer is still displayed but with coarse data from the lower zoom level\nexport const ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING = 10\n\n// Sets what should be the discrete zoom level to load tiles, from a non-discrete\n// viewport zoom values. For instance, a values of 0.5 will load z 3 with a viewport\n// z of 2 (ceiling of 2 + 0.5)\n// this has a direct impact on the number of points displayed on the map, thus on the\n// performance of the app.\nexport const TILES_LOAD_ZOOM_OFFSET = -1\nexport const TILES_LOAD_ZOOM_OFFSET_HI_DEF = 0.5\n\nexport const STATIC_LAYERS_CARTO_ENDPOINT =\n  'https://carto.globalfishingwatch.org/user/admin/api/v1/map?config=$MAPCONFIG'\nexport const STATIC_LAYERS_CARTO_TILES_ENDPOINT =\n  'https://carto.globalfishingwatch.org/user/admin/api/v1/map/$LAYERGROUPID/{z}/{x}/{y}.mvt'\n\nexport const TRACKS_LAYER_IN_FRONT_OF_GROUP = 'temporal'\n\nexport const TILES_URL_NEEDING_AUTHENTICATION = 'gateway.api'\n","export const INIT_MODULE = 'INIT_MODULE'\nexport const SET_TEMPORAL_EXTENT = 'SET_TEMPORAL_EXTENT'\nexport const SET_HIGHLIGHT_TEMPORAL_EXTENT = 'SET_HIGHLIGHT_TEMPORAL_EXTENT'\nexport const START_LOADER = 'START_LOADER'\nexport const COMPLETE_LOADER = 'COMPLETE_LOADER'\nexport const SET_MODULE_CURSOR = 'SET_MODULE_CURSOR'\n\nexport const initModule = (props) => (dispatch) => {\n  dispatch({\n    type: INIT_MODULE,\n    payload: props,\n  })\n}\n\nexport const startLoader = (dispatch, state, loaderId) => {\n  const timestamp = new Date().getTime()\n  const generatedLoaderId = loaderId !== undefined ? `${loaderId}_${timestamp}` : timestamp\n  dispatch({\n    type: START_LOADER,\n    payload: generatedLoaderId,\n  })\n  if (state.map.module.onLoadStart !== undefined) {\n    state.map.module.onLoadStart()\n  }\n  return loaderId\n}\n\nexport const completeLoader = (loaderId) => (dispatch, getState) => {\n  dispatch({\n    type: COMPLETE_LOADER,\n    payload: loaderId,\n  })\n  const state = getState()\n  const loaders = state.map.module.loaders\n  if (!loaders.length && state.map.module.onLoadComplete !== undefined) {\n    state.map.module.onLoadComplete()\n  }\n}\n\nexport const onViewportChange = (interactionState) => (dispatch, getState) => {\n  const state = getState()\n  const callback = state.map.module.onViewportChange\n\n  if (callback === undefined) {\n    return\n  }\n  const viewport = state.map.viewport\n\n  callback({\n    interactionState,\n    zoom: viewport.viewport.zoom,\n    center: [viewport.viewport.latitude, viewport.viewport.longitude],\n    bounds: viewport.bounds,\n    canZoomIn: viewport.canZoomIn,\n    canZoomOut: viewport.canZoomOut,\n    mouseLatLong: viewport.mouseLatLong,\n  })\n}\n\nexport const setTemporalExtent = (temporalExtent) => ({\n  type: SET_TEMPORAL_EXTENT,\n  payload: temporalExtent,\n})\n\nexport const setHighlightTemporalExtent = (highlightTemporalExtent) => ({\n  type: SET_HIGHLIGHT_TEMPORAL_EXTENT,\n  payload: highlightTemporalExtent,\n})\n\nexport const closePopup = () => (dispatch, getState) => {\n  const state = getState()\n  if (state.map.module.onClosePopup !== undefined) {\n    state.map.module.onClosePopup()\n  }\n}\n\nexport const setCursor = (cursor) => ({\n  type: SET_MODULE_CURSOR,\n  payload: cursor,\n})\n","export const getTemporalExtent = (state) => state.map.module.temporalExtent\n\nexport const getHighlightTemporalExtent = (state) => state.map.module.highlightTemporalExtent\n","import { createSelector } from 'reselect'\nimport { getTemporalExtent, getHighlightTemporalExtent } from '../module/module.selectors'\n\nexport const getTracksData = (state) => state.map.tracks.data\n\nexport const getGeojsonTracksReady = createSelector(\n  getTracksData,\n  (tracks) => tracks.filter((t) => t.data !== undefined)\n)\n\nconst mergeStyles = (style1, style2) => ({\n  sources: { ...style1.sources, ...style2.sources },\n  layers: [...style1.layers, ...style2.layers],\n})\n\nconst filterGeojsonByTimerange = (geojson, { start, end }) => {\n  if (!geojson || !geojson.features) return null\n  const featuresFiltered = geojson.features.reduce((filteredFeatures, feature) => {\n    const hasTimes =\n      feature.properties &&\n      feature.properties.coordinateProperties &&\n      feature.properties.coordinateProperties.times &&\n      feature.properties.coordinateProperties.times.length > 0\n    if (hasTimes) {\n      const filtered = feature.geometry.coordinates.reduce(\n        (filteredCoordinates, coordinate, index) => {\n          const timeCoordinate = feature.properties.coordinateProperties.times[index]\n          const isInTimeline = timeCoordinate >= start && timeCoordinate <= end\n          if (isInTimeline) {\n            filteredCoordinates.coordinates.push(coordinate)\n            filteredCoordinates.times.push(timeCoordinate)\n          }\n          return filteredCoordinates\n        },\n        { coordinates: [], times: [] }\n      )\n      if (!filtered.coordinates.length) return filteredFeatures\n\n      const filteredFeature = {\n        ...feature,\n        geometry: {\n          ...feature.geometry,\n          coordinates: filtered.coordinates,\n        },\n        properties: {\n          ...feature.properties,\n          coordinateProperties: {\n            times: filtered.times,\n          },\n        },\n      }\n      filteredFeatures.push(filteredFeature)\n    }\n    return filteredFeatures\n  }, [])\n  const geojsonFiltered = {\n    ...geojson,\n    features: featuresFiltered,\n  }\n  return geojsonFiltered\n}\n\nconst getFullTracksStyles = createSelector(\n  [getTemporalExtent, getGeojsonTracksReady],\n  (temporalExtent, tracks) => {\n    const hasTemporalExtent = temporalExtent && temporalExtent.length > 0\n    const hasTracks = tracks && tracks.length > 0\n    if (!hasTemporalExtent || !hasTracks) return null\n\n    const timerange = {\n      start: temporalExtent[0].getTime(),\n      end: temporalExtent[1].getTime(),\n    }\n    const styles = tracks.reduce(\n      (acc, track) => {\n        if (!track.data) return acc\n\n        const source = `${track.id}Track`\n        const style = {\n          sources: {\n            [source]: {\n              type: 'geojson',\n              data: filterGeojsonByTimerange(track.data, timerange),\n            },\n          },\n          layers: [\n            {\n              id: `${track.id}Lines`,\n              source,\n              type: 'line',\n              paint: {\n                'line-width': 1,\n                'line-color': track.color,\n              },\n            },\n            {\n              id: `${track.id}Points`,\n              source,\n              type: 'circle',\n              filter: ['match', ['geometry-type'], ['', 'Point'], true, false],\n              paint: {\n                'circle-radius': 4,\n                'circle-color': track.color,\n              },\n            },\n          ],\n        }\n        return mergeStyles(acc, style)\n      },\n      { sources: {}, layers: [] }\n    )\n    return styles\n  }\n)\n\nconst getHighlightedTrackStyles = createSelector(\n  [getHighlightTemporalExtent, getGeojsonTracksReady],\n  (highlightTemporalExtent, tracks) => {\n    const hasTemporalExtent = highlightTemporalExtent && highlightTemporalExtent.length > 0\n    const hasTracks = tracks && tracks.length > 0\n    if (!hasTemporalExtent || !hasTracks) return null\n\n    const timerange = {\n      start: highlightTemporalExtent[0].getTime(),\n      end: highlightTemporalExtent[1].getTime(),\n    }\n    const styles = tracks.reduce(\n      (acc, track) => {\n        if (!track.data) return acc\n\n        const source = `${track.id}HighlightedTrack`\n        const style = {\n          sources: {\n            [source]: {\n              type: 'geojson',\n              data: filterGeojsonByTimerange(track.data, timerange),\n            },\n          },\n          layers: [\n            {\n              id: `${track.id}HighlightedLines`,\n              source,\n              type: 'line',\n              paint: {\n                'line-width': 1,\n                'line-color': '#fff',\n              },\n            },\n          ],\n        }\n        return mergeStyles(acc, style)\n      },\n      { sources: {}, layers: [] }\n    )\n    return styles\n  }\n)\n\nexport const getTracksStyles = createSelector(\n  [getFullTracksStyles, getHighlightedTrackStyles],\n  (trackStyles, highlightedTrackStyles) => {\n    if (!highlightedTrackStyles) return trackStyles\n    return mergeStyles(trackStyles, highlightedTrackStyles)\n  }\n)\n","export const GL_TRANSPARENT = 'rgba(0,0,0,0)'\n\nexport const TRANSITION_TYPE = {\n  ZOOM: 'ZOOM',\n}\n\nexport const ENCOUNTERS = 'Encounters'\n\nexport const BRUSH_RENDERING_STYLE = {\n  NORMAL: 0,\n  BULLSEYE: 2,\n}\n\nexport const BRUSH_ZOOM_RENDERING_STYLE = {\n  RADIAL_GRADIENT: 0,\n  CIRCLE: 1,\n}\n\nexport const POLYGON_LAYERS_AREA = 'POLYGON_LAYERS_AREA'\n\nexport const CUSTOM_LAYERS_SUBTYPES = {\n  geojson: 'geojson',\n  raster: 'raster',\n}\n","import template from 'lodash/template'\nimport templateSettings from 'lodash/templateSettings'\n\nexport default (urlTemplate, urlParams) => {\n  templateSettings.interpolate = /{{([\\s\\S]+?)}}/g\n  const urlTemplateCompiled = template(urlTemplate)\n  return urlTemplateCompiled(urlParams)\n}\n","import pull from 'lodash/pull'\nimport uniq from 'lodash/uniq'\nimport sumBy from 'lodash/sumBy'\nimport { lngLatToWorld } from 'viewport-mercator-project'\nimport convert from '@globalfishingwatch/map-convert'\nimport buildEndpoint from './buildEndpoint'\nimport PelagosClient from '../lib/pelagosClient'\n\n/**\n * Generates the URLs to load vessel track data for a tile\n *\n * @param {string} tilesetUrl       the tileset base URL\n * @param {array} temporalExtents   all tileset temporal extents\n * @param {object} params           - tileCoordinates: this tiles tile coordinates (zoom, x, y). Will default to 0,0,0\n *                                  - temporalExtentsIndices: restrict to these temporalExtents indices\n * @returns {Array}                 an array of URLs for this tile\n */\nconst getTemporalTileURLs = (urlTemplate, temporalExtents, params = {}) => {\n  const urls = []\n\n  ;(temporalExtents || [null]).forEach((extent, index) => {\n    const urlParams = {}\n    if (extent !== null && params.temporalExtentsLess !== true) {\n      urlParams.startTimeISO = new Date(extent[0]).toISOString()\n      urlParams.endTimeISO = new Date(extent[1]).toISOString()\n    }\n    if (params.tileCoordinates) {\n      urlParams.x = params.tileCoordinates.x\n      urlParams.y = params.tileCoordinates.y\n      urlParams.z = params.tileCoordinates.zoom\n    }\n\n    const url = buildEndpoint(urlTemplate, urlParams)\n\n    if (\n      params.temporalExtentsLess === true ||\n      !params.temporalExtentsIndices ||\n      params.temporalExtentsIndices.indexOf(index) > -1\n    ) {\n      urls.push(url)\n    }\n  })\n  return urls\n}\n\n/**\n * See getTemporalTileURLs.\n */\nexport const getTilePromises = (tilesetUrl, token, temporalExtents, params = {}) => {\n  const promises = []\n  const urls = getTemporalTileURLs(tilesetUrl, temporalExtents, params)\n  for (let urlIndex = 0, length = urls.length; urlIndex < length; urlIndex++) {\n    promises.push(new PelagosClient().obtainTile(urls[urlIndex], token))\n  }\n\n  return promises\n}\n\nexport const getCleanVectorArrays = (rawTileData) =>\n  rawTileData.filter((vectorArray) => vectorArray !== null)\n\n/**\n * As data will come in multiple arrays (1 per API query/year basically), they need to be merged here\n *\n * @param cleanVectorArrays an array of objects containing a Float32Array for each vessel param (lat, lon, weight...)\n * @param columns the keys to pick on the vectorArrays (lat, lon, weight, etc)\n * @returns an object containing a Float32Array for each API_RETURNED_KEY (lat, lon, weight, etc)\n */\nexport const groupData = (cleanVectorArrays, columns) => {\n  const data = {}\n\n  const totalVectorArraysLength = sumBy(cleanVectorArrays, (a) => a.longitude.length)\n\n  const filteredColumns = columns.filter((column) => {\n    if (cleanVectorArrays[0] && cleanVectorArrays[0][column] === undefined) {\n      console.warn(`column ${column} is present in layerHeader.colsByName but not in tile data`)\n      return false\n    }\n    return true\n  })\n\n  filteredColumns.forEach((key) => {\n    data[key] = new Float32Array(totalVectorArraysLength)\n  })\n\n  let currentArray\n  let cumulatedOffsets = 0\n\n  const appendValues = (key) => {\n    data[key].set(currentArray[key], cumulatedOffsets)\n  }\n\n  for (let index = 0, length = cleanVectorArrays.length; index < length; index++) {\n    currentArray = cleanVectorArrays[index]\n    filteredColumns.forEach(appendValues)\n    cumulatedOffsets += currentArray.longitude.length\n  }\n  return data\n}\n\n/**\n * Converts Vector Array data to Playback format and stores it locally.\n * The data structure is an array indexed by a time unit, ie a set of points every day\n * This preprocessing step allows playback to play smoothly as the necessary conversions and data structure set up\n * is done once (after tile has been loaded)\n *\n * @param data the source data before indexing by day, an object containing\n *  - a vector (Float32Array) for each header's column in the case of Pelagos tiles\n *  - an array of points int the case of PBF tiles\n * @param colsByName the columns present on the dataset, determined by tileset headers\n * @param tileCoordinates x, y, z\n * @param prevPlaybackData an optional previously loaded tilePlaybackData array (when adding time range)\n */\nexport const getTilePlaybackData = (data, colsByName, tileCoordinates, prevPlaybackData) => {\n  const tilePlaybackData = prevPlaybackData === undefined ? [] : prevPlaybackData\n\n  const zoom = tileCoordinates.zoom\n  const zoomFactorRadius = convert.getZoomFactorRadius(zoom)\n  const zoomFactorRadiusRenderingMode = convert.getZoomFactorRadiusRenderingMode(zoom)\n  const zoomFactorOpacity = convert.getZoomFactorOpacity(zoom)\n\n  // store all available columns as object keys\n  const columns = {}\n  const columnsArr = Object.keys(colsByName)\n  columnsArr.forEach((c) => {\n    columns[c] = true\n  })\n\n  // columns specified by layer header columns\n  let storedColumns = [].concat(columnsArr)\n  if (columns.sigma === true) storedColumns.push('radius')\n  if (columns.weight === true) storedColumns.push('opacity')\n  if (columns.longitude === true) {\n    storedColumns.push('worldX')\n    storedColumns.push('worldY')\n  }\n  if (columns.id === true) {\n    storedColumns.push('series')\n  }\n\n  // omit values that will be transformed before being stored to playback data (ie lat -> worldY)\n  // only if hidden: true flag is set on header\n  ;['latitude', 'longitude', 'datetime'].forEach((col) => {\n    if (colsByName[col] === undefined || colsByName[col].hidden === true) {\n      pull(storedColumns, col)\n    }\n  })\n  // always pull sigma and weight\n  pull(storedColumns, 'sigma', 'weight')\n  storedColumns = uniq(storedColumns)\n\n  const numPoints = data.latitude.length\n\n  const newFrames = {}\n  const timeIndexes = []\n  for (let index = 0, length = numPoints; index < length; index++) {\n    let point = {}\n    columnsArr.forEach((c) => {\n      point[c] = data[c][index]\n    })\n\n    const timeIndex = columns.timeIndex\n      ? point.timeIndex\n      : convert.getOffsetedTimeAtPrecision(point.datetime)\n\n    // FIXME: this should not be done when headers declare worldX/Y -  if (!columns.worldX) {\n    const [worldX, worldY] = lngLatToWorld([point.longitude, point.latitude], 1)\n    point.worldX = worldX\n    point.worldY = worldY\n\n    if (columns.sigma) {\n      point.radius = convert.sigmaToRadius(\n        point.sigma,\n        zoomFactorRadiusRenderingMode,\n        zoomFactorRadius\n      )\n    }\n    if (columns.weight) {\n      point.opacity = convert.weightToOpacity(point.weight, zoomFactorOpacity)\n    }\n    if (columns.id) {\n      point.series = point.id\n    }\n\n    if (!newFrames[timeIndex]) {\n      timeIndexes.push(timeIndex)\n      const frame = {}\n      storedColumns.forEach((column) => {\n        frame[column] = [point[column]]\n      })\n      newFrames[timeIndex] = frame\n      continue\n    }\n    const frame = newFrames[timeIndex]\n    storedColumns.forEach((column) => {\n      frame[column].push(point[column])\n    })\n  }\n\n  // finally, copy new frames to the overall tilePlaybackData object\n  // frames previously existing here will be overwritten\n  timeIndexes.forEach((timeIndex) => {\n    tilePlaybackData[timeIndex] = newFrames[timeIndex]\n  })\n  return tilePlaybackData\n}\n\nexport const vesselSatisfiesFilters = (frame, index, filterValues) => {\n  const satisfiesFilters = Object.keys(filterValues).every((field) => {\n    if (frame[field] === undefined) {\n      // this field is not available on this layer. This can happen in an edge case described\n      // here: https://github.com/GlobalFishingWatch/map-client/issues/661#issuecomment-334496469\n      return false\n    }\n    return filterValues[field].indexOf(frame[field][index]) > -1\n  })\n  return satisfiesFilters\n}\n\nconst vesselSatisfiesAllFilters = (frame, index, filters) => {\n  const satisfiesAllFilters = filters\n    .filter((f) => f.pass !== true)\n    .some((filter) => vesselSatisfiesFilters(frame, index, filter.filterValues))\n  return satisfiesAllFilters\n}\n\nexport const selectVesselsAt = (tileData, tileQuery, startIndex, endIndex, currentFilters) => {\n  const vessels = []\n\n  const { worldX, worldY, toleranceRadiusInWorldUnits } = tileQuery\n\n  for (let f = startIndex; f < endIndex; f++) {\n    const frame = tileData[f]\n    if (frame === undefined) continue\n    for (let i = 0; i < frame.worldX.length; i++) {\n      const wx = frame.worldX[i]\n      const wy = frame.worldY[i]\n\n      if (\n        (!currentFilters.length || vesselSatisfiesAllFilters(frame, i, currentFilters)) &&\n        wx >= worldX - toleranceRadiusInWorldUnits &&\n        wx <= worldX + toleranceRadiusInWorldUnits &&\n        wy >= worldY - toleranceRadiusInWorldUnits &&\n        wy <= worldY + toleranceRadiusInWorldUnits\n      ) {\n        const vessel = {}\n\n        Object.keys(frame).forEach((key) => {\n          vessel[key] = frame[key][i]\n        })\n        vessel.timeIndex = f\n        vessels.push(vessel)\n      }\n    }\n  }\n  return vessels\n}\n\n/*\nexport const getHistogram = (tiles, propName = 'weight') => {\n  let data = tiles\n    .filter(tile => tile.ready)\n    .map(tile => tile.data\n      .map(frame => frame[propName]));\n  data = flattenDeep(data);\n  if (data.length) {\n    const bins = d3.histogram().thresholds(d3.thresholdScott)(data);\n    const x = d3.scaleLinear().domain([0, d3.max(bins, d => d.length)]).range([0, 50]);\n    console.table(bins.filter(bin => bin.length).map((bin) => {\n      const binMin = d3.min(bin).toLocaleString({ maximumFractionDigits: 2 });\n      const binMax = d3.max(bin).toLocaleString({ maximumFractionDigits: 2 });\n      return {\n        range: [binMin, binMax].join(''),\n        bars: Array(Math.round(x(bin.length))).join(''),\n        num: bin.length\n      };\n    }));\n  }\n};\n*/\n","import tilecover from '@mapbox/tile-cover/index'\nimport debounce from 'lodash/debounce'\nimport { PerspectiveMercatorViewport } from 'viewport-mercator-project'\nimport {\n  ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING,\n  TILES_LOAD_ZOOM_OFFSET,\n  TILES_LOAD_ZOOM_OFFSET_HI_DEF,\n} from '../config'\nimport {\n  getTile,\n  releaseTiles,\n  highlightVesselFromHeatmap,\n  updateLoadedTiles,\n} from './heatmap.actions'\n\nexport const SET_CURRENTLY_VISIBLE_TILES = 'SET_CURRENTLY_VISIBLE_TILES'\nexport const SET_CURRENTLY_LOADED_TILES = 'SET_CURRENTLY_LOADED_TILES'\nexport const SET_CURRENTLY_SWAPPED_TILE_UIDS = 'SET_CURRENTLY_SWAPPED_TILE_UIDS'\nexport const MARK_TILES_UIDS_AS_LOADED = 'MARK_TILES_UIDS_AS_LOADED'\nexport const RELEASE_MARKED_TILES_UIDS = 'RELEASE_MARKED_TILES_UIDS'\n\nlet currentTilesLoadZoomOffset = TILES_LOAD_ZOOM_OFFSET\nlet highDefMode = false\n\ndocument.addEventListener('keydown', function(event) {\n  const KEY_H = 72\n  if (event.keyCode === KEY_H) {\n    highDefMode = !highDefMode\n    currentTilesLoadZoomOffset = highDefMode\n      ? TILES_LOAD_ZOOM_OFFSET_HI_DEF\n      : TILES_LOAD_ZOOM_OFFSET\n    console.log(`Using to ${highDefMode ? 'high' : 'low'} def mode`)\n  }\n})\n\n// restrict tilecover to a single zoom level\n// could be customized to load less or more detailed tiles\nconst getTilecoverLimits = (viewportZoom) => {\n  let zoom = Math.ceil(viewportZoom + currentTilesLoadZoomOffset)\n  let tilesAvailable = true\n  if (zoom > ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING) {\n    zoom = ACTIVITY_LAYERS_MAX_ZOOM_LEVEL_TILE_LOADING\n    tilesAvailable = false\n  }\n  return {\n    min_zoom: zoom,\n    max_zoom: zoom,\n    tilesAvailable,\n  }\n}\n\nconst flushToReleaseTiles = () => (dispatch, getState) => {\n  const state = getState()\n  const currentToLoadTileUids = state.map.heatmapTiles.currentToLoadTileUids\n  // console.log('Tiles left to load: ', currentToLoadTileUids);\n\n  // Tiles are released only when all to-load tiles have finished loading\n  // this is to ensure smooth visual transitions between zoom levels\n  if (!currentToLoadTileUids.length) {\n    const currentTilesToReleaseUids = state.map.heatmapTiles.currentToReleaseTileUids\n    // console.log('no more tiles to load, releasing ', currentTilesToReleaseUids);\n    dispatch(releaseTiles(currentTilesToReleaseUids))\n    dispatch({\n      type: RELEASE_MARKED_TILES_UIDS,\n    })\n  }\n}\n\nexport const markTileAsLoaded = (tileUids) => (dispatch) => {\n  dispatch({\n    type: MARK_TILES_UIDS_AS_LOADED,\n    payload: tileUids,\n  })\n  // console.log(tileUids, 'have finished loading');\n  dispatch(flushToReleaseTiles())\n}\n\nconst flushTileState = (forceLoadingAllVisibleTiles = false) => (dispatch, getState) => {\n  const state = getState()\n  const currentVisibleTiles = state.map.heatmapTiles.currentVisibleTiles\n  let tilesToLoad = []\n  const tilesToReleaseUids = []\n\n  if (forceLoadingAllVisibleTiles === true) {\n    tilesToLoad = currentVisibleTiles\n  } else {\n    const currentLoadedTiles = state.map.heatmapTiles.currentLoadedTiles\n\n    currentVisibleTiles.forEach((visibleTile) => {\n      if (currentLoadedTiles.find((t) => t.uid === visibleTile.uid) === undefined) {\n        tilesToLoad.push(visibleTile)\n      }\n    })\n\n    currentLoadedTiles.forEach((loadedTile) => {\n      if (currentVisibleTiles.find((t) => t.uid === loadedTile.uid) === undefined) {\n        tilesToReleaseUids.push(loadedTile.uid)\n      }\n    })\n  }\n\n  const tilesToLoadUids = tilesToLoad.map((t) => t.uid)\n  // console.log('force loading:', forceLoadingAllVisibleTiles)\n  // console.log('visible', currentVisibleTiles.map(t => t.uid))\n  // console.log('load', tilesToLoadUids)\n  // console.log('release', tilesToReleaseUids)\n  // console.log('----')\n\n  tilesToLoad.forEach((tile) => {\n    dispatch(getTile(tile))\n  })\n  dispatch({\n    type: SET_CURRENTLY_LOADED_TILES,\n    payload: currentVisibleTiles,\n  })\n\n  dispatch({\n    type: SET_CURRENTLY_SWAPPED_TILE_UIDS,\n    payload: {\n      tilesToLoadUids,\n      tilesToReleaseUids,\n    },\n  })\n\n  dispatch(updateLoadedTiles())\n  dispatch(flushToReleaseTiles())\n}\n\nconst _debouncedFlushState = (dispatch) => {\n  dispatch(flushTileState())\n}\nconst debouncedFlushState = debounce(_debouncedFlushState, 500)\n\nexport const updateHeatmapTilesFromViewport = (forceLoadingAllVisibleTiles = false) => (\n  dispatch,\n  getState\n) => {\n  // if in transition, skip loading/releasing\n  // else\n  //   collect all tiles in viewport\n  //   save them to reducer: currentVisibleTiles\n  // if not zooming: flush immediately\n  //   if forceLoadingAllVisiblelTiles\n  //     get tiles from currentVisibleTiles\n  //   else\n  //     get tiles from currentVisibleTiles\n  //     make delta with currentLoadedTiles\n  //     get tiles from delta+\n  //     release tiles from delta-\n  //   save to reducer: currentVisibleTiles -> currentLoadedTiles\n  // if zooming: debounced flush to avoid \"tile spam\"\n  const mapViewport = getState().map.viewport\n  const viewport = mapViewport.viewport\n\n  // do not allow any tile update during transitions (currently only zoom)\n  // wait for the end of the transition to look at viewport and load matching tiles\n  if (!viewport.width || !viewport.height || mapViewport.currentTransition !== null) {\n    return\n  }\n\n  // instanciate a viewport instance to get lat/lon from screen top left/ bottom right bounds\n  const boundsViewport = new PerspectiveMercatorViewport(viewport)\n  const bounds = [\n    boundsViewport.unproject([0, 0]),\n    boundsViewport.unproject([viewport.width, viewport.height]),\n  ]\n\n  const [wn, es] = bounds\n  const [w, s, e, n] = [wn[0], es[1], es[0], wn[1]]\n  const boundsPolygonsCoordinates = []\n\n  const limits = getTilecoverLimits(viewport.zoom)\n  if (limits.tilesAvailable === false && forceLoadingAllVisibleTiles !== true) {\n    return\n  }\n\n  if (e > 180 || w < -180) {\n    // deal with the antimeridian situation by splitting the bounds polygon into two polygons\n    const w1 = e > 180 ? w : w + 360\n    const e1 = 180 - 0.001\n    const w2 = -180\n    const e2 = e > 180 ? e - 360 : e\n    boundsPolygonsCoordinates.push([\n      [\n        [w1, n],\n        [e1, n],\n        [e1, s],\n        [w1, s],\n        [w1, n],\n      ],\n    ])\n    boundsPolygonsCoordinates.push([\n      [\n        [w2, n],\n        [e2, n],\n        [e2, s],\n        [w2, s],\n        [w2, n],\n      ],\n    ])\n  } else {\n    boundsPolygonsCoordinates.push([\n      [\n        [w, n],\n        [e, n],\n        [e, s],\n        [w, s],\n        [w, n],\n      ],\n    ])\n  }\n\n  const geom = {\n    type: 'MultiPolygon',\n    coordinates: boundsPolygonsCoordinates,\n  }\n\n  // using tilecover, get xyz tile coords as well as quadkey indexes (named uid through the app)\n  const viewportTilesCoords = tilecover.tiles(geom, limits)\n  const viewportTilesIndexes = tilecover.indexes(geom, limits)\n  const visibleTiles = []\n\n  viewportTilesCoords.forEach((coords, i) => {\n    const uid = viewportTilesIndexes[i]\n    const zoom = coords[2]\n    if (zoom >= 2) {\n      visibleTiles.push({\n        tileCoordinates: {\n          x: coords[0],\n          y: coords[1],\n          zoom: coords[2],\n        },\n        uid,\n      })\n    }\n  })\n\n  dispatch({\n    type: SET_CURRENTLY_VISIBLE_TILES,\n    payload: visibleTiles,\n  })\n\n  const isMouseWheelZooming = mapViewport.prevZoom !== viewport.zoom\n\n  if (isMouseWheelZooming === false) {\n    dispatch(flushTileState(forceLoadingAllVisibleTiles))\n  } else {\n    debouncedFlushState(dispatch)\n  }\n}\n\nexport const queryHeatmapVessels = (coords, temporalExtentIndexes) => (dispatch, getState) => {\n  // use tilecover to get what tile quadkey/uid \"belongs\" to the point\n  const geom = {\n    type: 'Point',\n    coordinates: [coords.longitude, coords.latitude],\n  }\n  const zoom = getState().map.viewport.viewport.zoom\n\n  // get quadkey for tile at current zoom level, but also neighbouring zoom levels,\n  // in case current zoom level tiles has not been loaded yet\n  const uids = [zoom, zoom - 1, zoom + 1]\n    .map((z) => getTilecoverLimits(z))\n    .map((limits) => tilecover.indexes(geom, limits))\n    .map((indexes) => indexes[0])\n\n  const query = {\n    ...coords,\n    uids,\n  }\n\n  // console.log(query);\n  dispatch(highlightVesselFromHeatmap(query, temporalExtentIndexes))\n}\n","import difference from 'lodash/difference'\nimport uniq from 'lodash/uniq'\nimport uniqBy from 'lodash/uniqBy'\nimport {\n  getTilePromises,\n  getCleanVectorArrays,\n  groupData,\n  getTilePlaybackData,\n  selectVesselsAt,\n} from '../utils/heatmapTileData'\nimport { markTileAsLoaded } from './heatmapTiles.actions'\nimport { startLoader, completeLoader } from '../module/module.actions'\n\nexport const ADD_HEATMAP_LAYER = 'ADD_HEATMAP_LAYER'\nexport const UPDATE_HEATMAP_LAYER_STYLE = 'UPDATE_HEATMAP_LAYER_STYLE'\nexport const ADD_REFERENCE_TILE = 'ADD_REFERENCE_TILE'\nexport const HIGHLIGHT_VESSELS = 'HIGHLIGHT_VESSELS'\nexport const INIT_HEATMAP_LAYERS = 'INIT_HEATMAP_LAYERS'\nexport const REMOVE_HEATMAP_LAYER = 'REMOVE_HEATMAP_LAYER'\nexport const UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES =\n  'UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES'\nexport const UPDATE_HEATMAP_TILE = 'UPDATE_HEATMAP_TILE'\nexport const RELEASE_HEATMAP_TILES = 'RELEASE_HEATMAP_TILES'\nexport const UPDATE_LOADED_TILES = 'UPDATE_LOADED_TILES'\nexport const HIGHLIGHT_CLICKED_VESSEL = 'HIGHLIGHT_CLICKED_VESSEL'\nexport const CLEAR_HIGHLIGHT_CLICKED_VESSEL = 'CLEAR_HIGHLIGHT_CLICKED_VESSEL'\n\n/**\n * getTemporalExtentsVisibleIndices - Compares timebar outer extent with temporal extents present on the layer header\n * @param  {array} loadTemporalExtent Current timebar outer extent\n * @param  {array} layerTemporalExtents Temporal extent present on the layer's header (an array of extent arrays)\n * @return {array}                    Indices of the layer's temporal extents that should be visible\n */\nfunction getTemporalExtentsVisibleIndices(loadTemporalExtent, layerTemporalExtents) {\n  const currentExtentStart = loadTemporalExtent[0].getTime()\n  const currentExtentEnd = loadTemporalExtent[1].getTime()\n  const indices = []\n  layerTemporalExtents.forEach((temporalExtent, index) => {\n    const temporalExtentStart = temporalExtent[0]\n    const temporalExtentEnd = temporalExtent[1]\n    if (temporalExtentEnd >= currentExtentStart && temporalExtentStart <= currentExtentEnd) {\n      indices.push(index)\n    }\n  })\n  return indices\n}\n\n/**\n * loadLayerTile - loads an heatmap tile.\n *\n * @param  {string} layerId              layer id\n * @param  {object} tileCoordinates      tile coordinates from reference tile\n * @param  {string} token                the user's token\n * @param  {array} temporalExtentsIndices which of the temporal extents from  temporalExtents should be loaded\n * @param  {string} urls                 tile endpoints provided by header\n * @param  {array} temporalExtents       all of the layer's header temporal extents\n * @param  {bool} temporalExtentsLess    true = don't try to load different tiles based on current time extent\n * @return {Promise}                     a Promise that will be resolved when tile is loaded\n */\nfunction loadLayerTile(\n  layerId,\n  tileCoordinates,\n  token,\n  temporalExtentsIndices,\n  { url, temporalExtents, temporalExtentsLess }\n) {\n  // console.log('loadLayerTile', layerId, tileCoordinates, temporalExtentsIndices)\n  if (url === undefined) {\n    throw new Error('URL/endpoints object is not available on this tilesets header')\n  }\n  const pelagosPromises = getTilePromises(url, token, temporalExtents, {\n    tileCoordinates,\n    temporalExtentsIndices,\n    temporalExtentsLess,\n  })\n  const allLayerPromises = Promise.all(pelagosPromises)\n\n  const layerTilePromise = new Promise((resolve) => {\n    allLayerPromises.then((rawTileData) => {\n      resolve({\n        loadedLayerId: layerId,\n        rawTileData,\n      })\n    })\n  })\n\n  return layerTilePromise\n}\n\n/**\n * parseLayerTile - parses an heatmap tile to a playback-ready format.\n *\n * @param  {Object} rawTileData          the raw tile data, loaded either from the pelagos client or as a MVT/PBF vector tile\n * @param  {array} colsByName            names of the columns present in the raw tiles that need to be included in the final playback data\n * @param  {object} tileCoordinates      tile coordinates from reference tile\n * @param  {array} prevPlaybackData      (optional) in case some time extent was already loaded for this tile, append to this data\n * @return {Object}                      playback-ready merged data\n */\nfunction parseLayerTile(rawTileData, colsByName, tileCoordinates, prevPlaybackData) {\n  let data\n\n  const cleanVectorArrays = getCleanVectorArrays(rawTileData)\n  data = groupData(cleanVectorArrays, Object.keys(colsByName))\n  if (Object.keys(data).length === 0) {\n    return []\n  }\n\n  const playbackData = getTilePlaybackData(data, colsByName, tileCoordinates, prevPlaybackData)\n  return playbackData\n}\n\n/**\n * getTiles - loads a bunch of heatmap tiles\n * @param  {array} layerIds                 list of layer Ids that need to be loaded for this/these tiles\n * @param  {array} referenceTiles           list of reference tiles (tile data regardless of layer) that need to be loaded\n * @param  {object} newTemporalExtentsToLoad (optional) a dict (layerId is the key) of temporal extents\n * indices that should be appended to existing data\n */\nfunction getTiles(layerIds, referenceTiles, newTemporalExtentsToLoad = undefined) {\n  return (dispatch, getState) => {\n    const state = getState()\n    const loaderID = startLoader(dispatch, state, layerIds.join('-'))\n    const token = state.map.module.token\n    const heatmapLayers = state.map.heatmap.heatmapLayers\n    const tilesByLayer = {}\n    layerIds.forEach((id) => {\n      tilesByLayer[id] = [...heatmapLayers[id].tiles]\n    })\n    const allPromises = []\n\n    layerIds.forEach((layerId) => {\n      const heatmapLayerHeader = heatmapLayers[layerId].header\n      const { temporalExtents, temporalExtentsLess, colsByName } = { ...heatmapLayerHeader }\n      const url = heatmapLayerHeader.endpoints.tiles\n\n      referenceTiles.forEach((referenceTile) => {\n        // check if tile does not already exist first\n        let tile = tilesByLayer[layerId].find((t) => t.uid === referenceTile.uid)\n        if (!tile) {\n          // console.log('create tile ', referenceTile.uid)\n          tile = {\n            uid: referenceTile.uid,\n            temporalExtentsIndicesLoaded: [],\n          }\n          tilesByLayer[layerId].push(tile)\n        } else {\n          // console.log('found tile', referenceTile.uid)\n        }\n\n        const queriedTemporalExtentsIndices =\n          newTemporalExtentsToLoad === undefined\n            ? heatmapLayers[layerId].visibleTemporalExtentsIndices\n            : newTemporalExtentsToLoad[layerId]\n\n        const temporalExtentsIndicesToLoad = difference(\n          queriedTemporalExtentsIndices,\n          tile.temporalExtentsIndicesLoaded\n        )\n\n        const tilePromise = loadLayerTile(\n          layerId,\n          referenceTile.tileCoordinates,\n          token,\n          temporalExtentsIndicesToLoad,\n          {\n            url,\n            temporalExtents,\n            temporalExtentsLess,\n          }\n        )\n\n        allPromises.push(tilePromise)\n\n        tilePromise.then(({ loadedLayerId, rawTileData }) => {\n          tile.temporalExtentsIndicesLoaded = uniq(\n            tile.temporalExtentsIndicesLoaded.concat(temporalExtentsIndicesToLoad)\n          )\n          tile.data = parseLayerTile(\n            rawTileData,\n            colsByName,\n            referenceTile.tileCoordinates,\n            tile.data\n          )\n\n          dispatch({\n            type: UPDATE_HEATMAP_TILE,\n            payload: {\n              layerId: loadedLayerId,\n              tile,\n            },\n          })\n        })\n      })\n    })\n\n    Promise.all(allPromises).then(() => {\n      dispatch(completeLoader(loaderID))\n      dispatch(markTileAsLoaded(referenceTiles.map((tile) => tile.uid)))\n    })\n  }\n}\n\n/**\n * getTile - This action is emitted when a new tile is queried from panning or zooming the map\n * This will load a tile for all currently visible heatmap layers\n *\n * @param  {object} referenceTile a reference tile containing xyz coords and uid\n */\nexport function getTile(referenceTile) {\n  return (dispatch, getState) => {\n    dispatch({\n      type: ADD_REFERENCE_TILE,\n      payload: referenceTile,\n    })\n    const visibleHeatmapLayers = getState().map.heatmap.heatmapLayers\n    const visibleHeatmapLayersIds = Object.keys(visibleHeatmapLayers).filter(\n      (id) => visibleHeatmapLayers[id].visible === true\n    )\n\n    if (visibleHeatmapLayersIds.length) {\n      dispatch(getTiles(visibleHeatmapLayersIds, [referenceTile]))\n    }\n  }\n}\n\n/**\n * releaseTiles - This action is emitted when an existing tile is removed from panning or zooming the map\n * @param  {array} uids tile ref uids to release\n */\nexport const releaseTiles = (uids) => ({\n  type: RELEASE_HEATMAP_TILES,\n  payload: uids,\n})\n\nexport const updateLoadedTiles = () => ({\n  type: UPDATE_LOADED_TILES,\n})\n\n// triggered when a layer is added or set to visible\nfunction loadAllTilesForLayer(layerId) {\n  return (dispatch, getState) => {\n    //                current layer, all reference tiles\n    const referenceTiles = getState().map.heatmap.referenceTiles\n    dispatch(getTiles([layerId], referenceTiles))\n  }\n}\n\nexport const addHeatmapLayer = (layer, loadTemporalExtent) => (dispatch) => {\n  const layerTemporalExtents = layer.header.temporalExtents\n  dispatch({\n    type: ADD_HEATMAP_LAYER,\n    payload: {\n      ...layer,\n      // initially attach which of the temporal extents indices are visible with initial outerExtent\n      visibleTemporalExtentsIndices: getTemporalExtentsVisibleIndices(\n        loadTemporalExtent,\n        layerTemporalExtents\n      ),\n    },\n  })\n\n  if (layer.visible === true) {\n    dispatch(loadAllTilesForLayer(layer.id))\n  }\n}\n\nexport const removeHeatmapLayer = (id) => (dispatch) => {\n  dispatch({\n    type: REMOVE_HEATMAP_LAYER,\n    payload: {\n      id,\n    },\n  })\n}\n\n/**\n * updateLayerLoadTemporalExtents - when outer time extent changes, checks if more tiles needs to be loaded\n * by comparing the outer time range with the temporalExtent already loaded on each layer.\n * @param  {array} loadTemporalExtent Current app-wide extent of tiles that need to load, expressed\n * as an array of two dates\n */\nexport function updateLayerLoadTemporalExtents(loadTemporalExtent) {\n  return (dispatch, getState) => {\n    const state = getState()\n    const heatmapLayers = state.map.heatmap.heatmapLayers\n    const indicesToAddByLayer = {}\n\n    Object.keys(heatmapLayers).forEach((layerId) => {\n      const heatmapLayer = heatmapLayers[layerId]\n      const temporalExtents = heatmapLayer.header.temporalExtents\n      const oldVisibleTemporalExtentsIndices = heatmapLayer.visibleTemporalExtentsIndices\n      const newVisibleTemporalExtentsIndices = getTemporalExtentsVisibleIndices(\n        loadTemporalExtent,\n        temporalExtents\n      )\n\n      const indicesAdded = difference(\n        newVisibleTemporalExtentsIndices,\n        oldVisibleTemporalExtentsIndices\n      )\n\n      const indicesRemoved = difference(\n        oldVisibleTemporalExtentsIndices,\n        newVisibleTemporalExtentsIndices\n      )\n\n      if (indicesAdded.length || indicesRemoved.length) {\n        // add new loaded indices to heatmap layer if applicable\n        dispatch({\n          type: UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES,\n          payload: {\n            layerId,\n            newVisibleTemporalExtentsIndices,\n            indicesRemoved,\n          },\n        })\n      }\n      if (indicesAdded.length) {\n        indicesToAddByLayer[layerId] = indicesAdded\n      }\n    })\n\n    // getTiles with indices diff\n    const layerIdsWithIndicesToAdd = Object.keys(indicesToAddByLayer)\n    if (layerIdsWithIndicesToAdd.length) {\n      dispatch(\n        getTiles(layerIdsWithIndicesToAdd, state.map.heatmap.referenceTiles, indicesToAddByLayer)\n      )\n    }\n  }\n}\n\n/**\n * Returns clusters or vessels data from a tileQuery\n * @param {object} state - the application state\n * @param {string} tileQuery - the id of a heatmap layer\n * @return {object} { isEmpty, isCluster, isMouseCluster, foundVessels, layerId, tilesetId }\n */\nconst _queryHeatmap = (state, tileQuery, temporalExtentIndexes) => {\n  const layers = state.map.heatmap.heatmapLayers\n  const startIndex = temporalExtentIndexes[0]\n  const endIndex = temporalExtentIndexes[1]\n  const layersVessels = []\n\n  Object.keys(layers).forEach((layerId) => {\n    const layer = layers[layerId]\n    if (layer.visible !== true) {\n      return\n    }\n    const allPossibleTilesByPreference = tileQuery.uids.map((uid) =>\n      layer.tiles.find((tile) => tile.uid === uid)\n    )\n    const availableTiles = allPossibleTilesByPreference.filter(\n      (tile) => tile !== undefined && tile.data !== undefined\n    )\n\n    const currentFilters = layer.filters\n    if (availableTiles.length) {\n      const bestTile = availableTiles[0]\n      layersVessels.push({\n        layer,\n        vessels: selectVesselsAt(bestTile.data, tileQuery, startIndex, endIndex, currentFilters),\n      })\n    }\n  })\n\n  const layersVesselsResults = layersVessels.filter(\n    (layerVessels) => layerVessels.vessels.length > 0\n  )\n\n  // it's a cluster because of aggregation on the server side\n  let isCluster\n  // its a cluster because or multiple vessels under mouse\n  let isMouseCluster\n  let isEmpty\n  let layerVesselsResult\n  let foundVessels\n\n  if (layersVesselsResults.length === 0) {\n    isEmpty = true\n  } else if (layersVesselsResults.length > 1) {\n    // if there are points over multiple layers, consider this a cluster (ie don't select, zoom instead, or don't highlight)\n    // there's an exception if vessel selection contains an encounter, in which case it will take priority\n    isCluster = true\n  } else {\n    // layersVesselsResults should contain a single result\n    layerVesselsResult = layersVesselsResults[0]\n\n    // we can get multiple points with similar series and id, in which case\n    // we should treat that as a successful vessel query, not a cluster\n    const vessels = layerVesselsResult.vessels\n\n    if (vessels.length === 0) {\n      isEmpty = true\n    } else {\n      // look up for any negatives ids (clusters on the server side)\n      const clusteredVessels = vessels.filter(\n        (v) =>\n          (v.id !== undefined && v.id < 0) || (v.seriesgroup !== undefined && v.seriesgroup < 0)\n      )\n      if (clusteredVessels.length) {\n        isCluster = true\n      } else {\n        foundVessels = uniqBy(vessels, (v) => v.series)\n        isMouseCluster = foundVessels.length > 1\n      }\n    }\n  }\n\n  const layer = layerVesselsResult === undefined ? {} : layerVesselsResult.layer\n\n  return { isEmpty, isCluster, isMouseCluster, foundVessels, layer }\n}\n\nexport function clearHighlightedVessels() {\n  return {\n    type: HIGHLIGHT_VESSELS,\n    payload: {\n      isEmpty: true,\n      clickableCluster: false,\n    },\n  }\n}\n\nexport function highlightVesselFromHeatmap(tileQuery, temporalExtentIndexes) {\n  return (dispatch, getState) => {\n    const state = getState()\n    const { layer, isEmpty, isCluster, isMouseCluster, foundVessels } = _queryHeatmap(\n      state,\n      tileQuery,\n      temporalExtentIndexes\n    )\n\n    if (\n      isCluster === true ||\n      layer.id !== undefined ||\n      state.map.heatmap.highlightedVessels.layerId !== layer.id\n    ) {\n      const layerPayload =\n        layer === undefined\n          ? null\n          : {\n              id: layer.id,\n              tilesetId: layer.tilesetId,\n              subtype: layer.subtype,\n              header: layer.header,\n            }\n      dispatch({\n        type: HIGHLIGHT_VESSELS,\n        payload: {\n          layer: layerPayload,\n          isEmpty,\n          clickableCluster: isCluster === true || isMouseCluster === true,\n          highlightableCluster: isCluster !== true,\n          foundVessels,\n        },\n      })\n    } else {\n      dispatch(clearHighlightedVessels())\n    }\n  }\n}\n\nexport const highlightClickedVessel = (id, layerId) => ({\n  type: HIGHLIGHT_CLICKED_VESSEL,\n  payload: {\n    id,\n    layerId,\n  },\n})\n\nexport const clearHighlightedClickedVessel = () => ({\n  type: CLEAR_HIGHLIGHT_CLICKED_VESSEL,\n})\n\nexport const updateHeatmapLayers = (newLayers, currentLoadTemporalExtent) => (\n  dispatch,\n  getState\n) => {\n  if (newLayers === null) {\n    console.warn(\"New layers in updateHeatmapLayers can't be null\")\n    return\n  }\n  const prevLayersDict = getState().map.heatmap.heatmapLayers\n\n  // add and update layers\n  newLayers.forEach((newLayer) => {\n    const layerId = newLayer.id\n    const prevLayer = prevLayersDict[layerId]\n    if (prevLayer === undefined) {\n      // console.log('adding', layerId)\n      dispatch(addHeatmapLayer(newLayer, currentLoadTemporalExtent))\n    } else {\n      if (prevLayer.visible !== newLayer.visible && newLayer.visible === true) {\n        dispatch(loadAllTilesForLayer(layerId))\n      }\n      if (\n        prevLayer.visible !== newLayer.visible ||\n        prevLayer.hue !== newLayer.hue ||\n        prevLayer.opacity !== newLayer.opacity ||\n        prevLayer.filters !== newLayer.filters ||\n        prevLayer.interactive !== newLayer.interactive\n      ) {\n        // console.log('updating', layerId, ' with visibilty', newLayer.visible)\n        dispatch({\n          type: UPDATE_HEATMAP_LAYER_STYLE,\n          payload: {\n            id: newLayer.id,\n            visible: newLayer.visible,\n            hue: newLayer.hue,\n            opacity: newLayer.opacity,\n            filters: newLayer.filters,\n            interactive: newLayer.interactive,\n          },\n        })\n      }\n    }\n  })\n\n  // clean up unused layers\n  Object.keys(prevLayersDict).forEach((prevLayerId) => {\n    if (!newLayers.find((l) => l.id === prevLayerId)) {\n      dispatch(removeHeatmapLayer(prevLayerId))\n    }\n  })\n}\n","import { fitBounds, pixelsToWorld } from 'viewport-mercator-project'\nimport { updateHeatmapTilesFromViewport } from '../heatmap/heatmapTiles.actions'\nimport { onViewportChange } from '../module/module.actions'\nimport { CLUSTER_CLICK_ZOOM_INCREMENT } from '../config' // TODO MAP MODULE\n\nexport const SET_BOUNDS = 'SET_BOUNDS'\nexport const SET_VIEWPORT = 'SET_VIEWPORT'\nexport const UPDATE_VIEWPORT = 'UPDATE_VIEWPORT'\nexport const SET_ZOOM_INCREMENT = 'SET_ZOOM_INCREMENT'\nexport const SET_MOUSE_LAT_LONG = 'SET_MOUSE_LAT_LONG'\nexport const TRANSITION_END = 'TRANSITION_END'\nexport const SET_NATIVE_VIEWPORT = 'SET_NATIVE_VIEWPORT'\n\nexport const setBounds = (bounds) => ({\n  type: SET_BOUNDS,\n  payload: bounds,\n})\n\nexport const setViewport = (viewport, interactionState) => (dispatch) => {\n  dispatch({\n    type: SET_VIEWPORT,\n    payload: viewport,\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  dispatch(onViewportChange(interactionState))\n}\n\nexport const updateViewport = (viewportUpdate) => (dispatch) => {\n  dispatch({\n    type: UPDATE_VIEWPORT,\n    payload: viewportUpdate,\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  // Not needed as call the callback with the same values\n  // dispatch(onViewportChange())\n}\n\nconst transitionTo = (increment, latitude = null, longitude = null, zoom = null) => (dispatch) => {\n  dispatch({\n    type: SET_ZOOM_INCREMENT,\n    payload: {\n      increment,\n      latitude,\n      longitude,\n      zoom,\n    },\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  dispatch(onViewportChange())\n}\n\nexport const transitionToZoom = (viewport) => (dispatch) => {\n  dispatch(transitionTo(null, viewport.center[0], viewport.center[1], viewport.zoom))\n}\n\nexport const transitionEnd = () => (dispatch) => {\n  dispatch({\n    type: TRANSITION_END,\n  })\n  dispatch(updateHeatmapTilesFromViewport())\n  dispatch(onViewportChange())\n}\n\nexport const zoomIntoVesselCenter = (latitude, longitude, zoom = null) => (dispatch) => {\n  dispatch(transitionTo(CLUSTER_CLICK_ZOOM_INCREMENT, latitude, longitude, zoom))\n}\n\nexport const fitToBounds = (bounds) => (dispatch, getState) => {\n  const state = getState()\n  const vp = fitBounds({\n    bounds: [[bounds.minLng, bounds.minLat], [bounds.maxLng, bounds.maxLat]],\n    width: state.map.viewport.viewport.width,\n    height: state.map.viewport.viewport.height,\n    padding: 50,\n  })\n  dispatch(transitionTo(null, vp.latitude, vp.longitude, vp.zoom))\n}\n\nexport const exportNativeViewport = (nativeViewport) => (dispatch) => {\n  const topLeftPx = [0, 0]\n  const bottomRightPx = [nativeViewport.width, nativeViewport.height]\n\n  // compute left and right offsets to deal with antimeridian issue\n  const topLeftWorld = pixelsToWorld(topLeftPx, nativeViewport.pixelUnprojectionMatrix)\n  const bottomRightWorld = pixelsToWorld(bottomRightPx, nativeViewport.pixelUnprojectionMatrix)\n  const leftWorldScaled = topLeftWorld[0] / nativeViewport.scale\n  const rightWorldScaled = bottomRightWorld[0] / nativeViewport.scale\n\n  // lat/lon corners for miniglobe\n  const northWest = nativeViewport.unproject(topLeftPx)\n  const southEast = nativeViewport.unproject(bottomRightPx)\n  const bounds = {\n    north: northWest[1],\n    south: southEast[1],\n    west: northWest[0],\n    east: southEast[0],\n  }\n\n  dispatch({\n    type: SET_NATIVE_VIEWPORT,\n    payload: {\n      leftWorldScaled,\n      rightWorldScaled,\n      bounds,\n    },\n  })\n}\n","import area from '@turf/area'\nimport { POLYGON_LAYERS_AREA } from '../constants'\nimport { clearHighlightedVessels, clearHighlightedClickedVessel } from '../heatmap/heatmap.actions'\nimport { zoomIntoVesselCenter } from './viewport.actions'\n\nexport const SET_POPUP = 'SET_POPUP'\nexport const CLEAR_POPUP = 'CLEAR_POPUP'\nexport const SET_MAP_CURSOR = 'SET_MAP_CURSOR'\n\nconst getAreaKm2 = (glFeature) => {\n  const areakm2 = 10 ** -6 * area(glFeature.geometry)\n  const formatted = areakm2.toLocaleString('en-US', { maximumFractionDigits: 0 })\n  return formatted\n}\n\nconst getFields = (glFeature, source = null) => {\n  if (source === null || source === undefined) {\n    // console.warn('Couldnt find source when looking for fields of layer', sourceId)\n  }\n\n  const fieldsDefinition =\n    !source || source.metadata === undefined || source.metadata['gfw:popups'] === undefined\n      ? []\n      : source.metadata['gfw:popups']\n\n  const properties = glFeature.properties\n\n  // whitelist if 'gfw:popups' exist, if not return all\n  const fieldsKeys = Object.keys(glFeature.properties).filter(\n    (k) => fieldsDefinition.length === 0 || fieldsDefinition.find((fd) => fd.id === k) !== undefined\n  )\n\n  const fields = fieldsKeys.map((fieldKey) => {\n    const value = fieldKey === POLYGON_LAYERS_AREA ? getAreaKm2(glFeature) : properties[fieldKey]\n    const def = fieldsDefinition.find((fd) => fd.id === fieldKey) || {}\n    const label = def.label || fieldKey\n    return {\n      id: fieldKey,\n      label,\n      value,\n      title: `${label}: ${value}`,\n      isLink: def.isLink,\n      isMain: def.isMain,\n    }\n  })\n\n  const mainField =\n    fields.find((f) => f.isMain === true) ||\n    fields.find((f) => f.id === 'name') ||\n    fields.find((f) => f.id === 'id') ||\n    fields[0]\n\n  if (mainField !== undefined) {\n    mainField.isMain = true\n  }\n  return fields\n}\n\nconst getCluster = (glFeature, glGetSource) => {\n  const clusterId = glFeature.properties.cluster_id\n  const sourceId = glFeature.source\n  const glSource = glGetSource(sourceId)\n  const promise = new Promise((resolve, reject) => {\n    glSource.getClusterExpansionZoom(clusterId, (err1, zoom) => {\n      glSource.getClusterLeaves(clusterId, 99, 0, (err2, children) => {\n        if (err1 || err2) {\n          reject()\n        }\n        const childrenFeatures = children.map((child) =>\n          getFeature(child, glFeature.layer.id, glSource)\n        )\n        resolve({\n          zoom,\n          childrenFeatures,\n        })\n      })\n    })\n  })\n  return promise\n}\n\nconst getFeature = (glFeature, layerId, source) => {\n  const feature = {\n    properties: glFeature.properties,\n  }\n  const fields = getFields(glFeature, source)\n  feature.fields = fields\n\n  // Get most likely feature title\n  const mainField = fields.find((f) => f.isMain === true)\n  feature.title = mainField === undefined ? layerId : mainField.value\n\n  return feature\n}\n\nexport const mapInteraction = (interactionType, latitude, longitude, glFeatures, glGetSource) => (\n  dispatch,\n  getState\n) => {\n  if (interactionType === 'click') {\n    dispatch(clearHighlightedClickedVessel())\n  }\n\n  const currentStyle = getState().map.style.mapStyle.toJS()\n\n  const event = {\n    latitude,\n    longitude,\n    features: [],\n  }\n\n  // Collect and normalize features on legacy heatmap\n  const currentLegacyHeatmapData = getState().map.heatmap.highlightedVessels\n  let legacyHeatmapFeature\n\n  if (currentLegacyHeatmapData.isEmpty !== true) {\n    const foundVessels =\n      currentLegacyHeatmapData.foundVessels === undefined\n        ? []\n        : currentLegacyHeatmapData.foundVessels\n    const properties = foundVessels.length === 0 ? [] : foundVessels[0]\n    const isCluster = currentLegacyHeatmapData.clickableCluster === true\n    const count =\n      isCluster === true && currentLegacyHeatmapData.highlightableCluster === false\n        ? -1\n        : foundVessels.length\n    legacyHeatmapFeature = {\n      isCluster,\n      count,\n      layer: {\n        id: currentLegacyHeatmapData.layer.id,\n        group: 'legacyHeatmap',\n      },\n      properties,\n    }\n    event.features.push(legacyHeatmapFeature)\n  }\n\n  // Try to retrieve 'gfw:id' (generated when instanciating CARTO layer to preserve original style.json id)\n  // In most cases it won't exist, so fall back to source id\n  const getStaticLayerIdFromGlFeature = (glFeature) =>\n    (glFeature.layer.metadata !== undefined && glFeature.layer.metadata['gfw:id']) ||\n    glFeature.layer.source\n\n  // Collect gl features\n  const clusterPromises = []\n  const allGlFeatures = glFeatures || []\n  allGlFeatures.forEach((glFeature) => {\n    const layerId = getStaticLayerIdFromGlFeature(glFeature)\n    const source = currentStyle.sources[layerId]\n    const feature = {\n      layer: {\n        id: layerId,\n        group: glFeature.layer.metadata && glFeature.layer.metadata['mapbox:group'],\n      },\n      ...getFeature(glFeature, layerId, source),\n    }\n\n    if (glFeature.properties.cluster === true) {\n      // lookup for cluster\n      const clusterPromise = getCluster(glFeature, glGetSource).then((cluster) => {\n        feature.cluster = cluster\n        feature.count = cluster.childrenFeatures.length\n      })\n      clusterPromises.push(clusterPromise)\n      feature.isCluster = true\n    } else {\n      feature.isCluster = false\n    }\n    event.features.push(feature)\n  })\n\n  Promise.all(clusterPromises).then(() => {\n    // The whole set of features is considered a cluster\n    // if any feature is a cluster, or there is more than one feature\n    event.isCluster =\n      event.features.length > 1 || event.features.some((feature) => feature.isCluster === true)\n\n    // legacy heatmap layers can yield clusters with an unknown number of features, handle this here:\n    if (legacyHeatmapFeature !== undefined && legacyHeatmapFeature.count === -1) {\n      event.count = -1\n    } else {\n      event.count = event.features.reduce((count, feature) => {\n        let featureCount = feature.count || 1\n        return count + featureCount\n      }, 0)\n    }\n\n    if (event.count === 1) {\n      event.feature = event.features[0]\n    }\n\n    // When autoClusterZoom is set to true, we handle zoom here\n    const autoClusterZoom = getState().map.module.autoClusterZoom === true\n\n    // Check if cluster using customizable isCluster() callback\n    // If not set resolves simply to (event) => event.isCluster === true\n    const clusterBehavior = getState().map.module.isCluster(event)\n    event.isCluster = clusterBehavior\n\n    if (autoClusterZoom) {\n      if (interactionType === 'click' && event.isCluster === true) {\n        dispatch(clearHighlightedVessels())\n        const clusterZoom = event.features[0].cluster && event.features[0].cluster.zoom\n        dispatch(zoomIntoVesselCenter(latitude, longitude, clusterZoom))\n      }\n    }\n\n    let cursor = event.features.length ? 'pointer' : null\n    if (event.isCluster === true) {\n      cursor = 'zoom-in'\n    }\n\n    dispatch({\n      type: SET_MAP_CURSOR,\n      payload: cursor,\n    })\n\n    const callback =\n      interactionType === 'click' ? getState().map.module.onClick : getState().map.module.onHover\n\n    if (callback !== undefined) {\n      callback(event)\n    }\n  })\n}\n","const RGB_MAX = 255\nconst HUE_MAX = 360\nconst SV_MAX = 100\n\nexport const VESSELS_HUES_INCREMENTS_NUM = 31 // 360 / VESSELS_HUES_INCREMENTS_NUM - 1  should give a round number\nexport const VESSELS_HUES_INCREMENT = 360 / (VESSELS_HUES_INCREMENTS_NUM - 1)\n\n// Legacy: this is only here for compatibility with pre-mapbox branch workspaces\nexport const COLOR_HUES = {\n  orange: 0,\n  peach: 22,\n  yellow: 60,\n  green: 85,\n  brightGreen: 145,\n  lightBlue: 182,\n  blue: 236,\n  purple: 284,\n  pink: 312,\n}\n\n// FIXME mark explicitely as legacy. Check all usages.\nexport const getKeyByValue = (obj, value) => {\n  let result = null\n  Object.entries(obj).forEach((entry) => {\n    if (entry[1] === value) result = entry[0]\n  })\n  return result\n}\n\n/**\n * Converts an RGB color value to HSV. Conversion formula\n * adapted from http://en.wikipedia.org/wiki/HSV_color_space.\n * Assumes r, g, and b are contained in the set [0, 255] and\n * returns h, s, and v in the set [0, 1].\n *\n * @param   Number  r       The red color value\n * @param   Number  g       The green color value\n * @param   Number  b       The blue color value\n * @return  Array           The HSV representation\n */\nexport const rgbToHsv = (_r, _g, _b) => {\n  const r = _r / 255\n  const g = _g / 255\n  const b = _b / 255\n\n  const max = Math.max(r, g, b)\n  const min = Math.min(r, g, b)\n  let h\n  const v = max\n\n  const d = max - min\n  const s = max === 0 ? 0 : d / max\n\n  if (max === min) {\n    h = 0 // achromatic\n  } else {\n    switch (max) {\n      case r:\n        h = (g - b) / d + (g < b ? 6 : 0)\n        break\n      case g:\n        h = (b - r) / d + 2\n        break\n      case b:\n        h = (r - g) / d + 4\n        break\n      default:\n        h = 0\n    }\n\n    h /= 6\n  }\n\n  return [h, s, v]\n}\n\n// converts hue, saturation, luminance to an rgb object\nexport const hsvToRgb = (h_, s_, v_) => {\n  const h = ((h_ % HUE_MAX) / parseFloat(HUE_MAX)) * 6\n  const s = s_ === SV_MAX ? 1 : (s_ % SV_MAX) / parseFloat(SV_MAX)\n  const v = v_ === SV_MAX ? 1 : (v_ % SV_MAX) / parseFloat(SV_MAX)\n\n  const i = Math.floor(h)\n  const f = h - i\n  const p = v * (1 - s)\n  const q = v * (1 - f * s)\n  const t = v * (1 - (1 - f) * s)\n  const mod = i % 6\n  const r = [v, q, p, p, t, v][mod]\n  const g = [t, v, v, q, p, p][mod]\n  const b = [p, p, t, v, v, q][mod]\n\n  return { r: Math.round(r * RGB_MAX), g: Math.round(g * RGB_MAX), b: Math.round(b * RGB_MAX) }\n}\n\n// returns an rgb string with default saturation and luminance values\nconst hueToRgbDefaults = (hue) => hsvToRgb(hue, 50, 100)\n\nexport const hueToRgbString = (hue) => {\n  const rgb = hueToRgbDefaults(hue)\n  return `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`\n}\n\nexport const rgbToHexString = (rgb, css) => {\n  const str = ['r', 'g', 'b']\n    .map((channelName) => {\n      const channelValue = rgb[channelName]\n      let channelStr = channelValue.toString(16)\n      if (channelValue < 16) {\n        channelStr = `0${channelStr}`\n      }\n      return channelStr\n    })\n    .join('')\n  const prefix = css === true ? '#' : '0x'\n  return `${prefix}${str}`\n}\n\nexport const hueToRgbHexString = (hue, css) => {\n  const rgb = hueToRgbDefaults(hue)\n  return rgbToHexString(rgb, css)\n}\n\nconst closestNumber = (numberArray, goal) =>\n  numberArray.reduce((prev, curr) => (Math.abs(curr - goal) < Math.abs(prev - goal) ? curr : prev))\n\nexport const hueToClosestColor = (hue) => {\n  if (hue === undefined || hue === null) return undefined\n  const colorHueValues = Object.keys(COLOR_HUES).map((key) => COLOR_HUES[key])\n  const closestHue = closestNumber(colorHueValues, hue)\n  return getKeyByValue(COLOR_HUES, closestHue)\n}\n\nexport const hexToRgb = (hex) => {\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex)\n  return result\n    ? {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16),\n      }\n    : null\n}\n\nconst rgbToRgbaString = (rgb, opacity) => `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`\n\nexport const hueToRgbaString = (hue, opacity) => {\n  const rgb = hueToRgbDefaults(hue)\n  return rgbToRgbaString(rgb, opacity)\n}\n\nexport const hexToRgba = (hex, opacity) => {\n  const rgb = hexToRgb(hex)\n  return rgbToRgbaString(rgb, opacity)\n}\n\nexport const hueIncrementToHue = (hueIncrement) => hueIncrement * VESSELS_HUES_INCREMENT\n\nexport const hueToHueIncrement = (hue) =>\n  Math.round((hue / 360) * (VESSELS_HUES_INCREMENTS_NUM - 1))\n\nexport const wrapHue = (hue) => hue % 360\n\nexport const hueOrColorToHexColor = (color, hue) => {\n  if (hue !== undefined) {\n    return hueToRgbHexString(hue, true)\n  }\n\n  return color\n}\n","/* global PIXI */\nimport 'pixi.js'\nimport { hueToHueIncrement, VESSELS_HUES_INCREMENTS_NUM } from '../utils/map-colors'\nimport { VESSELS_BASE_RADIUS, MAX_SPRITES_PER_LAYER } from '../config'\n\nexport default class HeatmapSubLayer {\n  constructor(baseTexture, renderingStyleIndex, hue, useNormalBlendMode = false) {\n    // this.stage = new PIXI.Container();\n    // the ParticleContainer is a faster version of the PIXI sprite container\n    this.stage = new PIXI.particles.ParticleContainer(MAX_SPRITES_PER_LAYER, {\n      scale: true,\n      alpha: true,\n      position: true,\n      uvs: true,\n    })\n    if (useNormalBlendMode === false) {\n      this.stage.blendMode = PIXI.BLEND_MODES.SCREEN\n    }\n\n    this.spritesPool = []\n\n    const initialTextureFrame = new PIXI.Rectangle(\n      0,\n      0,\n      VESSELS_BASE_RADIUS * 2,\n      VESSELS_BASE_RADIUS * 2\n    )\n    this.mainVesselTexture = new PIXI.Texture(baseTexture, initialTextureFrame)\n    this._setTextureFrame(renderingStyleIndex, hue)\n\n    this.clearSpriteProps()\n  }\n\n  clearSpriteProps() {\n    this.spritesProps = {\n      x: new Float32Array(MAX_SPRITES_PER_LAYER),\n      y: new Float32Array(MAX_SPRITES_PER_LAYER),\n      a: new Float32Array(MAX_SPRITES_PER_LAYER),\n      s: new Float32Array(MAX_SPRITES_PER_LAYER),\n    }\n    this.spritesPropsCount = 0\n  }\n\n  pushSpriteProps(x, y, a, s) {\n    this.spritesProps.x[this.spritesPropsCount] = x\n    this.spritesProps.y[this.spritesPropsCount] = y\n    this.spritesProps.a[this.spritesPropsCount] = a\n    this.spritesProps.s[this.spritesPropsCount] = s\n    this.spritesPropsCount++\n  }\n\n  setRenderingStyleIndex(renderingStyleIndex) {\n    this._setTextureFrame(renderingStyleIndex)\n  }\n\n  destroy() {\n    this.spritesPool = null\n    this.stage.destroy({ children: true })\n  }\n\n  /**\n   * Updates the main texture frame offset to show different brush styles and hues\n   * Both args are optional, if one is omitted, previous value is used\n   * @heatmapStyle bool whether to use heatmap style or solid circle style\n   * @hue number hue value between 0 and 360\n   */\n  _setTextureFrame(renderingStyleIndex = null, hue = null) {\n    const textureFrame = this.mainVesselTexture.frame.clone()\n\n    if (renderingStyleIndex !== null) {\n      // one diameter + tiny offset between 2 frames\n      textureFrame.x = VESSELS_BASE_RADIUS * 2 * renderingStyleIndex + renderingStyleIndex\n    }\n\n    if (hue !== null) {\n      let hueIncrement = hueToHueIncrement(hue)\n      if (hueIncrement === VESSELS_HUES_INCREMENTS_NUM - 1) {\n        hueIncrement = 0\n      }\n      textureFrame.y = hueIncrement * VESSELS_BASE_RADIUS * 2\n      if (hueIncrement > 0) {\n        textureFrame.y += hueIncrement\n      }\n    }\n\n    this.mainVesselTexture.frame = textureFrame\n    this.mainVesselTexture.update()\n  }\n\n  render() {\n    const numProps = this.spritesPropsCount\n    this.resizeSpritesPool()\n\n    for (let i = 0; i < numProps; i++) {\n      const sprite = this.stage.children[i]\n      const s = this.spritesProps.s[i]\n      sprite.setTransform(this.spritesProps.x[i], this.spritesProps.y[i], s, s)\n      sprite.alpha = this.spritesProps.a[i]\n    }\n\n    const numSprites = this.stage.children.length\n    for (let i = numProps; i < numSprites; i++) {\n      const sprite = this.stage.children[i]\n      sprite.x = -100\n    }\n  }\n\n  resizeSpritesPool() {\n    const numProps = this.spritesPropsCount\n    const prevNumSprites = this.stage.children.length\n    const delta = numProps - prevNumSprites\n    // console.log(prevNumSprites, '->', numProps, ' delta:', delta);\n\n    if (delta < -4999) {\n      // sprite needs to be removed. Do that progressively (max 100) to avoid UI lock\n      const toRemove = Math.min(100, -delta)\n      // console.log('removing ', toRemove);\n      for (let i = 0; i < toRemove; i++) {\n        this.stage.removeChildAt(0)\n      }\n    }\n\n    if (delta > 0) {\n      const toAdd = Math.max(5000, delta)\n      // console.log('adding ', toAdd);\n      this._addSprites(toAdd)\n    }\n  }\n\n  _addSprites(num) {\n    for (let i = 0; i < num; i++) {\n      const vessel = new PIXI.Sprite(this.mainVesselTexture)\n      vessel.anchor.x = 0.5\n      vessel.anchor.y = 0.5\n      // ParticlesContainer does not support .visible, so we just move the sprite out of the viewport\n      vessel.x = -100\n      // vessel.blendMode = PIXI.BLEND_MODES.SCREEN;\n      // vessel.filters=  [new PIXI.filters.BlurFilter(10,10)]\n      this.stage.addChild(vessel)\n    }\n  }\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport uniq from 'lodash/uniq'\nimport * as PIXI from 'pixi.js'\nimport { worldToPixels } from 'viewport-mercator-project'\nimport { BRUSH_RENDERING_STYLE, BRUSH_ZOOM_RENDERING_STYLE } from '../constants'\nimport { vesselSatisfiesFilters } from '../utils/heatmapTileData'\nimport HeatmapSubLayer from './HeatmapSubLayer'\n\n// This is a faster version of worldToPixels that omits pitch,\n// and ignores values from the matrix that are consistently = 0\nconst s = 1 / 1.5\nconst worldToPixelsSimple = (x, y, m) => {\n  const fx = s * (m[0] * x + m[4] * y + m[12])\n  const fy = s * (m[5] * y + m[13])\n  return [fx, fy]\n}\n\nclass HeatmapLayer extends React.Component {\n  componentDidMount() {\n    this._build()\n  }\n\n  componentWillUnmount() {\n    this._destroy()\n  }\n\n  componentDidUpdate() {\n    this._redraw()\n  }\n\n  UNSAFE_componentWillReceiveProps(nextProps) {\n    if (nextProps.useRadialGradientStyle !== this.props.useRadialGradientStyle) {\n      this.setBrushZoomRenderingStyle(nextProps.useRadialGradientStyle)\n    }\n  }\n\n  _build() {\n    const { layer, rootStage, useRadialGradientStyle, customRenderingStyle } = this.props\n    this.subLayers = {}\n    this.renderingStyle =\n      layer.header && layer.header.rendering ? layer.header.rendering : customRenderingStyle\n\n    this.setBrushRenderingStyle(this.renderingStyle.style)\n    this.setBrushZoomRenderingStyle(useRadialGradientStyle)\n\n    this.stage = new PIXI.Container()\n\n    rootStage.addChild(this.stage)\n  }\n\n  setBrushRenderingStyle(style = BRUSH_RENDERING_STYLE.NORMAL) {\n    if (typeof style === 'string') {\n      this.brushRenderingStyle = BRUSH_RENDERING_STYLE[style.toUpperCase()]\n    } else {\n      this.brushRenderingStyle = style\n    }\n    this._setBrushRenderingStyleIndex()\n  }\n\n  setBrushZoomRenderingStyle(useRadialGradientStyle) {\n    this.brushZoomRenderingStyle =\n      useRadialGradientStyle === true\n        ? BRUSH_ZOOM_RENDERING_STYLE.RADIAL_GRADIENT\n        : BRUSH_ZOOM_RENDERING_STYLE.CIRCLE\n    this._setBrushRenderingStyleIndex()\n  }\n\n  _setBrushRenderingStyleIndex() {\n    // only NORMAL brush styles support different zoom styles\n    const cappedZoomRenderingStyle =\n      this.brushRenderingStyle === BRUSH_RENDERING_STYLE.NORMAL ? this.brushZoomRenderingStyle : 0\n    const newStyleIndex = this.brushRenderingStyle + cappedZoomRenderingStyle\n    if (newStyleIndex === this.renderingStyleIndex) {\n      return\n    }\n    this.renderingStyleIndex = newStyleIndex\n    Object.values(this.subLayers).forEach((subLayer) => {\n      subLayer.setRenderingStyleIndex(this.renderingStyleIndex)\n    })\n  }\n\n  _redraw() {\n    const { filters, baseTexture, layer } = this.props\n\n    if (\n      layer === null ||\n      layer === undefined ||\n      layer.tiles === undefined ||\n      layer.visible === false\n    ) {\n      this.stage.visible = false\n      return\n    }\n\n    this.stage.visible = true\n    this.stage.alpha = layer.opacity\n\n    const tiles = layer.tiles\n    const defaultHue = layer.hue\n    const allHuesToRender =\n      filters !== undefined && filters.length\n        ? filters\n            // pass is set to true by filterGroupActions when none of the filters fields\n            // in the filter group is supported by the layer headers\n            .filter((f) => f.pass !== true)\n            .map((f) => (f.hue === undefined ? '0' : f.hue.toString()))\n        : [defaultHue.toString()]\n    const currentlyUsedHues = Object.keys(this.subLayers)\n\n    // get all hues, old and new\n    const allHues = uniq(allHuesToRender.concat(currentlyUsedHues))\n\n    for (let i = 0; i < allHues.length; i++) {\n      const hue = allHues[i]\n      if (allHuesToRender.indexOf(hue) === -1) {\n        // not on new hues: delete sublayer\n        this._destroySubLayer(this.subLayers[hue])\n        delete this.subLayers[hue]\n        continue\n      }\n      if (currentlyUsedHues.indexOf(hue) === -1) {\n        // not on old hues: create sublayer\n        this.subLayers[hue] = this._createSublayer(baseTexture, this.renderingStyleIndex, hue)\n      }\n      this.subLayers[hue].clearSpriteProps()\n    }\n\n    if (!allHuesToRender.length) return\n    tiles.forEach((tile) => {\n      this._setSubLayersSpritePropsForTile({\n        data: tile.data,\n        numFilters: filters.length,\n        defaultHue,\n      })\n    })\n\n    allHuesToRender.forEach((hueToRender) => {\n      this.subLayers[hueToRender].render()\n    })\n  }\n\n  _setSubLayersSpritePropsForTile({ data, numFilters, defaultHue }) {\n    if (!data) {\n      return\n    }\n\n    const { startIndex, endIndex, viewport, filters, viewportLeft, viewportRight } = this.props\n\n    for (let timeIndex = startIndex; timeIndex < endIndex; timeIndex++) {\n      const frame = data[timeIndex]\n\n      if (!frame) continue\n\n      for (let index = 0, len = frame.worldX.length; index < len; index++) {\n        let hue\n        if (filters === undefined || !filters.length) {\n          hue = defaultHue\n        }\n        for (let fi = 0; fi < numFilters; fi++) {\n          const filter = filters[fi]\n          if (vesselSatisfiesFilters(frame, index, filter.filterValues)) {\n            hue = filter.hue\n            break\n          }\n        }\n\n        // no filter passes: bail\n        if (hue === undefined) {\n          continue\n        }\n\n        // wrap worldX when point crosses the antimeridian/dateline\n        // world points go from 0 to 512. There is no way to determine if worldX is on the \"wrong\" side\n        // of the antimeridian just by looking at its value (where with lat/lon we can simply look at -/+)\n        // Therefore we compare it to the viewport's left or right boundary, depending on what is currently\n        // \"the right side\" of the antimeridian\n        let worldX = frame.worldX[index]\n        if (viewportLeft > 0 && worldX < viewportLeft) {\n          // worldX is \"behind\" viewportLeft, which means it is \"on the right\" of the antimeridian\n          worldX += 512\n        } else if (viewportLeft < 0 && worldX > viewportRight) {\n          worldX -= 512\n        }\n\n        const scaledX = worldX * viewport.scale\n        const scaledY = frame.worldY[index] * viewport.scale\n        const mtx = viewport.pixelProjectionMatrix\n\n        const [x, y] =\n          viewport.pitch === 0\n            ? worldToPixelsSimple(scaledX, scaledY, mtx)\n            : worldToPixels([scaledX, scaledY], mtx)\n\n        if (x > -10 && x < viewport.width + 10 && y > -10 && y < viewport.height + 10) {\n          this.subLayers[hue].pushSpriteProps(\n            x,\n            y,\n            frame.opacity ? frame.opacity[index] : this.renderingStyle.defaultOpacity,\n            frame.radius ? frame.radius[index] : this.renderingStyle.defaultSize\n          )\n        }\n      }\n    }\n  }\n\n  _createSublayer(baseTexture, renderingStyleIndex, hue) {\n    const subLayer = new HeatmapSubLayer(\n      baseTexture,\n      renderingStyleIndex,\n      hue,\n      this.brushRenderingStyle === BRUSH_RENDERING_STYLE.BULLSEYE\n    )\n    this.stage.addChild(subLayer.stage)\n    return subLayer\n  }\n\n  _destroy() {\n    Object.values(this.subLayers).forEach(this._destroySubLayer.bind(this))\n    this.stage.destroy({ children: true })\n    const { rootStage } = this.props\n    rootStage.removeChild(this.stage)\n  }\n\n  _destroySubLayer(subLayer) {\n    this.stage.removeChild(subLayer.stage)\n    subLayer.destroy()\n  }\n\n  render() {\n    return null\n  }\n}\n\nHeatmapLayer.propTypes = {\n  layer: PropTypes.object,\n  rootStage: PropTypes.object,\n  viewport: PropTypes.object,\n  startIndex: PropTypes.number,\n  endIndex: PropTypes.number,\n  filters: PropTypes.array,\n  baseTexture: PropTypes.object,\n  useRadialGradientStyle: PropTypes.bool,\n  customRenderingStyle: PropTypes.object,\n  viewportLeft: PropTypes.number,\n  viewportRight: PropTypes.number,\n}\n\nexport default HeatmapLayer\n","import React, { Fragment } from 'react'\nimport * as PIXI from 'pixi.js'\nimport PropTypes from 'prop-types'\nimport { BaseControl } from 'react-map-gl'\nimport { lngLatToWorld } from 'viewport-mercator-project'\nimport {\n  hsvToRgb,\n  hueToRgbString,\n  hueIncrementToHue,\n  wrapHue,\n  VESSELS_HUES_INCREMENTS_NUM,\n} from '../utils/map-colors'\nimport {\n  VESSELS_BASE_RADIUS,\n  VESSELS_HEATMAP_BLUR_FACTOR,\n  ACTIVITY_HIGHLIGHT_HUE,\n  VESSELS_HEATMAP_DIMMING_ALPHA,\n  VESSELS_RADIAL_GRADIENT_STYLE_ZOOM_THRESHOLD,\n  VESSEL_CLICK_TOLERANCE_PX,\n} from '../config'\nimport HeatmapLayer from '../heatmap/HeatmapLayer'\n\nconst shouldUseRadialGradientStyle = (zoom) => zoom < VESSELS_RADIAL_GRADIENT_STYLE_ZOOM_THRESHOLD\n\n// builds a texture spritesheet containing\n// - the heatmap style (radial gradient)\n// - the circle style that is used at higher zoom levels\n// - the 'bullseye' style used for encounters\n// as well as a number of hues for each in a 2D grid.\n// Then, only the texture frame (mesh UVs) is modified depending on the zoom level,\n// in order not to have to recreate sprites\nconst getVesselTexture = (radius, blurFactor) => {\n  const tplCanvas = document.createElement('canvas')\n  const tplCtx = tplCanvas.getContext('2d')\n  const diameter = radius * 2\n  const NUM_STYLES = 3\n  tplCanvas.width = diameter * NUM_STYLES + (NUM_STYLES - 1) // + (NUM_STYLES - 1): tiny offset between 2 frames\n  tplCanvas.height = diameter * VESSELS_HUES_INCREMENTS_NUM + VESSELS_HUES_INCREMENTS_NUM\n\n  for (let hueIncrement = 0; hueIncrement < VESSELS_HUES_INCREMENTS_NUM; hueIncrement++) {\n    const y = diameter * hueIncrement + hueIncrement\n    const yCenter = y + radius\n\n    // heatmap style\n    let x = radius\n    const gradient = tplCtx.createRadialGradient(\n      x,\n      yCenter,\n      radius * blurFactor,\n      x,\n      yCenter,\n      radius\n    )\n    const hue = hueIncrementToHue(hueIncrement)\n    const rgbString = hueToRgbString(hue)\n    gradient.addColorStop(0, rgbString)\n\n    const rgbOuter = hsvToRgb(wrapHue(hue + 30), 80, 100)\n    gradient.addColorStop(1, `rgba(${rgbOuter.r}, ${rgbOuter.g}, ${rgbOuter.b}, 0)`)\n\n    tplCtx.fillStyle = gradient\n    tplCtx.fillRect(0, y, diameter, diameter)\n\n    // circle style\n    x += diameter + 1 // tiny offset between 2 frames\n    tplCtx.beginPath()\n    tplCtx.arc(x, yCenter, radius, 0, 2 * Math.PI, false)\n    tplCtx.fillStyle = rgbString\n    tplCtx.fill()\n\n    // bullseye style\n    x += diameter + 1\n    tplCtx.beginPath()\n    tplCtx.arc(x, yCenter, radius * 0.4, 0, 2 * Math.PI, false)\n    tplCtx.fillStyle = rgbString\n    tplCtx.fill()\n    tplCtx.beginPath()\n    tplCtx.arc(x, yCenter, radius * 0.95, 0, 2 * Math.PI, false)\n    tplCtx.lineWidth = 1\n    tplCtx.strokeStyle = rgbString\n    tplCtx.stroke()\n  }\n\n  return tplCanvas\n}\n\nclass ActivityLayers extends BaseControl {\n  state = {\n    pixiReady: false,\n  }\n\n  componentDidMount() {\n    this._build()\n    this.setState({\n      pixiReady: true,\n    })\n  }\n\n  componentWillUnmount() {\n    this._destroy()\n  }\n\n  UNSAFE_componentWillReceiveProps(nextProps) {\n    this.props.exportNativeViewport(this._context.viewport)\n\n    if (\n      nextProps.viewport.width !== this.props.viewport.width ||\n      nextProps.viewport.height !== this.props.viewport.height\n    ) {\n      this._updateViewportSize(nextProps.viewport.width, nextProps.viewport.height)\n    }\n  }\n\n  _build() {\n    const { width, height } = this.props.viewport\n\n    this.pixi = new PIXI.Application({\n      width,\n      height,\n      transparent: true,\n      antialias: true,\n    })\n\n    this.renderer = this.pixi.renderer\n    this.canvas = this.pixi.view\n    this.canvas.style.position = 'absolute'\n\n    this.container.appendChild(this.canvas)\n\n    this.stage = this.pixi.stage\n\n    const baseTextureCanvas = getVesselTexture(VESSELS_BASE_RADIUS, VESSELS_HEATMAP_BLUR_FACTOR)\n    this.baseTexture = PIXI.Texture.fromCanvas(baseTextureCanvas)\n\n    this.heatmapStage = new PIXI.Container()\n    this.stage.addChild(this.heatmapStage)\n\n    this.pixi.ticker.add(this._onTick)\n  }\n\n  _destroy() {\n    this.pixi.destroy()\n  }\n\n  _updateViewportSize(viewportWidth, viewportHeight) {\n    this.renderer.resize(viewportWidth, viewportHeight)\n  }\n\n  toggleHeatmapDimming(dim) {\n    if (this.heatmapStage === undefined) {\n      return\n    }\n    if (dim === true) {\n      this.heatmapFadingIn = false\n    }\n    this.heatmapStage.alpha = dim === true ? VESSELS_HEATMAP_DIMMING_ALPHA : 1\n  }\n\n  onTouchStart = (event) => {\n    if (!event.touches.length) {\n      return\n    }\n    this.queryCoords(event.touches[0].clientX, event.touches[0].clientY)\n  }\n\n  onMouseMove = (event) => {\n    this.queryCoords(event.clientX, event.clientY)\n  }\n\n  queryCoords(x, y) {\n    // bail if all heatmap layers are set to non-interactive\n    if (this.props.heatmapLayers.every((l) => l.interactive !== true)) {\n      return\n    }\n\n    const { viewport } = this._context\n    const [longitude, latitude] = viewport.unproject([x, y])\n\n    let wrappedLongitude = longitude\n    if (wrappedLongitude > 180) {\n      wrappedLongitude -= 360\n    } else if (wrappedLongitude < -180) {\n      wrappedLongitude += 360\n    }\n\n    const [worldX, worldY] = lngLatToWorld([wrappedLongitude, latitude], 1)\n\n    const toleranceRadiusInWorldUnits = VESSEL_CLICK_TOLERANCE_PX / viewport.scale\n\n    this.props.queryHeatmapVessels(\n      {\n        longitude: wrappedLongitude,\n        latitude,\n        worldX,\n        worldY,\n        toleranceRadiusInWorldUnits,\n      },\n      this.props.temporalExtentIndexes\n    )\n  }\n\n  _onTick = () => {\n    if (this.heatmapFadingIn === true && this.heatmapStage.alpha < 1) {\n      this._heatmapFadeinStep()\n    }\n  }\n\n  _startHeatmapFadein() {\n    this.heatmapFadingIn = true\n    this.heatmapFadeinStartTimestamp = undefined\n  }\n\n  _heatmapFadeinStep() {\n    if (this.heatmapFadeinStartTimestamp === undefined) {\n      this.heatmapFadeinStartTimestamp = Date.now()\n    }\n    const timeElapsed = (Date.now() - this.heatmapFadeinStartTimestamp) / 1000\n    let alpha = this.heatmapStage.alpha + (1 - this.heatmapStage.alpha) * timeElapsed\n    if (alpha >= 1) {\n      alpha = 1\n      this.heatmapFadingIn = false\n    }\n    this.heatmapStage.alpha = alpha\n  }\n\n  // FIXME move to container?\n  _getHighlightData(highlightedVessels, highlightedClickedVessel, heatmapLayers) {\n    const hue = ACTIVITY_HIGHLIGHT_HUE\n    let highlightLayerData = {\n      id: '__HIGHLIGHT__',\n      visible: true,\n      opacity: 1,\n      hue: ACTIVITY_HIGHLIGHT_HUE,\n    }\n    let highlightFilters = []\n\n    if (\n      highlightedVessels !== undefined &&\n      highlightedVessels.layer !== undefined &&\n      highlightedVessels.foundVessels !== undefined &&\n      highlightedVessels.isEmpty !== true\n    ) {\n      const sourceLayer = heatmapLayers.find((l) => l.id === highlightedVessels.layer.id)\n      highlightLayerData = { highlightLayerData, ...sourceLayer }\n      highlightFilters = highlightedVessels.foundVessels.map((vessel) => ({\n        hue,\n        filterValues: {\n          series: [vessel.series],\n        },\n      }))\n    } else if (highlightedClickedVessel !== null) {\n      const sourceLayer = heatmapLayers.find((l) => l.id === highlightedClickedVessel.layer.id)\n      highlightLayerData = { highlightLayerData, ...sourceLayer }\n      highlightFilters = [\n        {\n          hue,\n          filterValues: {\n            series: [highlightedClickedVessel.id],\n          },\n        },\n      ]\n    }\n    return {\n      highlightLayerData,\n      highlightFilters,\n    }\n  }\n  _render() {\n    const {\n      zoom,\n      heatmapLayers,\n      temporalExtentIndexes,\n      highlightedVessels,\n      highlightedClickedVessel,\n      leftWorldScaled,\n      rightWorldScaled,\n    } = this.props\n    const { viewport } = this._context\n    const { pixiReady } = this.state\n\n    const startIndex = temporalExtentIndexes[0]\n    const endIndex = temporalExtentIndexes[1]\n    const useRadialGradientStyle = shouldUseRadialGradientStyle(zoom)\n\n    if (highlightedVessels.isEmpty !== true) {\n      this.toggleHeatmapDimming(true)\n    }\n    if (highlightedVessels.isEmpty === true) {\n      this._startHeatmapFadein()\n    }\n    if (this.renderer && this.renderer.gl && this.renderer.gl.getError !== undefined) {\n      const err = this.renderer.gl.getError()\n      if (err !== 0) console.log(err)\n    }\n\n    const { highlightLayerData, highlightFilters } = this._getHighlightData(\n      highlightedVessels,\n      highlightedClickedVessel,\n      heatmapLayers\n    )\n\n    return (\n      <div\n        ref={(ref) => {\n          this.container = ref\n        }}\n        style={{ position: 'absolute' }}\n        onMouseMove={this.onMouseMove}\n        onTouchStart={this.onTouchStart}\n      >\n        {pixiReady === true && (\n          <Fragment>\n            {heatmapLayers.map((layer) => (\n              <HeatmapLayer\n                key={layer.id}\n                layer={layer}\n                filters={layer.filters || []}\n                viewport={viewport}\n                startIndex={startIndex}\n                endIndex={endIndex}\n                baseTexture={this.baseTexture}\n                rootStage={this.heatmapStage}\n                useRadialGradientStyle={useRadialGradientStyle}\n                customRenderingStyle={{}}\n                viewportLeft={leftWorldScaled}\n                viewportRight={rightWorldScaled}\n              />\n            ))}\n            {this.stage !== undefined && (\n              <HeatmapLayer\n                key=\"highlighted\"\n                layer={highlightLayerData}\n                filters={highlightFilters}\n                viewport={viewport}\n                startIndex={startIndex}\n                endIndex={endIndex}\n                baseTexture={this.baseTexture}\n                rootStage={this.heatmapStage}\n                useRadialGradientStyle={useRadialGradientStyle}\n                customRenderingStyle={{ defaultOpacity: 1, defaultSize: 1 }}\n                viewportLeft={leftWorldScaled}\n                viewportRight={rightWorldScaled}\n              />\n            )}\n          </Fragment>\n        )}\n      </div>\n    )\n  }\n}\n\nActivityLayers.propTypes = {\n  zoom: PropTypes.number,\n  heatmapLayers: PropTypes.array,\n  temporalExtentIndexes: PropTypes.array,\n  highlightedVessels: PropTypes.object,\n  highlightedClickedVessel: PropTypes.object,\n  queryHeatmapVessels: PropTypes.func,\n  exportNativeViewport: PropTypes.func,\n  leftWorldScaled: PropTypes.number,\n  rightWorldScaled: PropTypes.number,\n}\n\nActivityLayers.contextTypes = {\n  viewport: PropTypes.object,\n}\n\nexport default ActivityLayers\n","import { connect } from 'react-redux'\nimport { createSelector } from 'reselect'\nimport convert from '@globalfishingwatch/map-convert'\nimport { exportNativeViewport } from '../glmap/viewport.actions'\nimport { getTemporalExtent } from '../module/module.selectors'\nimport ActivityLayers from './ActivityLayers'\nimport { queryHeatmapVessels } from '../heatmap/heatmapTiles.actions'\nimport { MIN_FRAME_LENGTH_MS } from '../config'\n\nconst getHeatmapLayers = (state) => state.map.heatmap.heatmapLayers\n\nconst getHeatmapLayersAsArray = createSelector(\n  [getHeatmapLayers],\n  (heatmapLayers) => {\n    const a = Object.keys(heatmapLayers).map((id) => ({\n      ...heatmapLayers[id],\n    }))\n    // console.log(a)\n    return a\n  }\n)\n\nconst getTemporalExtentIndexes = createSelector(\n  [getTemporalExtent],\n  (temporalExtent) => {\n    const startTimestamp = temporalExtent[0].getTime()\n    const endTimestamp = Math.max(\n      temporalExtent[1].getTime(),\n      temporalExtent[0].getTime() + MIN_FRAME_LENGTH_MS\n    )\n    const startIndex = convert.getOffsetedTimeAtPrecision(startTimestamp)\n    const endIndex = convert.getOffsetedTimeAtPrecision(endTimestamp)\n    return [startIndex, endIndex]\n  }\n)\n\nconst mapStateToProps = (state) => ({\n  highlightedVessels: state.map.heatmap.highlightedVessels,\n  highlightedClickedVessel: state.map.heatmap.highlightedClickedVessel,\n  viewport: state.map.viewport.viewport,\n  zoom: state.map.viewport.viewport.zoom,\n  heatmapLayers: getHeatmapLayersAsArray(state),\n  leftWorldScaled: state.map.viewport.leftWorldScaled,\n  rightWorldScaled: state.map.viewport.rightWorldScaled,\n  temporalExtentIndexes: getTemporalExtentIndexes(state),\n})\n\nconst mapDispatchToProps = (dispatch, ownProps) => ({\n  queryHeatmapVessels: (coords, temporalExtentIndexes) => {\n    dispatch(queryHeatmapVessels(coords, temporalExtentIndexes))\n  },\n  exportNativeViewport: (viewport) => {\n    dispatch(exportNativeViewport(viewport))\n  },\n})\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(ActivityLayers)\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport MapGL, { Popup, Marker } from 'react-map-gl'\nimport 'mapbox-gl/dist/mapbox-gl.css'\nimport { TILES_URL_NEEDING_AUTHENTICATION } from '../config'\nimport ActivityLayers from '../activity/ActivityLayers.container.js'\nimport styles from './map.css'\n\nconst PopupWrapper = (props) => {\n  const { latitude, longitude, children, closeButton, onClose } = props\n  return (\n    <Popup\n      latitude={latitude}\n      longitude={longitude}\n      closeButton={closeButton}\n      onClose={onClose}\n      anchor=\"bottom\"\n      offsetTop={-10}\n      tipSize={4}\n      closeOnClick={false}\n    >\n      {children}\n    </Popup>\n  )\n}\n\nPopupWrapper.propTypes = {\n  latitude: PropTypes.number.isRequired,\n  longitude: PropTypes.number.isRequired,\n  children: PropTypes.node.isRequired,\n  closeButton: PropTypes.bool.isRequired,\n  onClose: PropTypes.func,\n}\n\nPopupWrapper.defaultProps = {\n  onClose: () => {},\n}\n\nclass Map extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      mouseOver: true,\n    }\n    this._mapContainerRef = null\n  }\n\n  componentDidMount() {\n    if (this._mapContainerRef !== null) {\n      this.loadObserver()\n    }\n    this.setBounds()\n  }\n\n  componentDidUpdate() {\n    this.setBounds()\n  }\n\n  onLoad = () => {\n    if (this.props.onLoad !== undefined) {\n      this.props.onLoad(this.getBounds())\n    }\n  }\n\n  setBounds = () => {\n    const bounds = this.getBounds()\n    if (bounds !== null && this.props.setBounds !== undefined) {\n      this.props.setBounds(bounds)\n    }\n  }\n\n  getBounds = () => {\n    if (!this.glMap) return null\n\n    const { _ne, _sw } = this.glMap.getBounds()\n    return {\n      north: _ne.lat,\n      south: _sw.lat,\n      west: _sw.lng,\n      east: _ne.lng,\n    }\n  }\n\n  componentWillUnmount() {\n    if (this._containerResizeObserver) {\n      this._containerResizeObserver.disconnect()\n    }\n  }\n\n  loadObserver = async () => {\n    if ('ResizeObserver' in window === false) {\n      const module = await import('resize-observer-polyfill')\n      window.ResizeObserver = module.ResizeObserver || module.default\n    }\n    this._containerResizeObserver = new ResizeObserver(this.handleResizeObserver)\n    this._containerResizeObserver.observe(this._mapContainerRef)\n  }\n\n  handleResizeObserver = (entries) => {\n    const { width, height } = entries[0].contentRect\n    const { viewport, setViewport } = this.props\n\n    if (width !== viewport.width || height !== viewport.height) {\n      setViewport({\n        ...viewport,\n        width,\n        height,\n      })\n    }\n  }\n\n  onViewportChange = (viewport, interactionState) => {\n    const propsViewport = this.props.viewport\n    if (\n      propsViewport.latitude !== viewport.latitude ||\n      propsViewport.longitude !== viewport.longitude ||\n      propsViewport.zoom !== viewport.zoom ||\n      propsViewport.bearing !== viewport.bearing ||\n      propsViewport.pitch !== viewport.pitch\n    ) {\n      this.props.setViewport(viewport, interactionState)\n    }\n  }\n\n  onMapInteraction = (event, type) => {\n    this.props.mapInteraction(\n      type,\n      event.lngLat[1],\n      event.lngLat[0],\n      event.features,\n      this.glGetSource\n    )\n  }\n\n  onHover = (event) => {\n    this.onMapInteraction(event, 'hover')\n  }\n\n  onClick = (event) => {\n    this.onMapInteraction(event, 'click')\n  }\n\n  getRef = (ref) => {\n    if (ref !== null) {\n      this.glMap = ref.getMap()\n      this.glGetSource = this.glMap.getSource.bind(this.glMap)\n    }\n  }\n\n  getCursor = ({ isDragging }) => {\n    const { cursor } = this.props\n    if (cursor === null) {\n      return isDragging ? 'grabbing' : 'grab'\n    }\n    return cursor\n  }\n\n  transformRequest = (url, resourceType) => {\n    const { token } = this.props\n    if (token !== null && resourceType === 'Tile' && url.match(TILES_URL_NEEDING_AUTHENTICATION)) {\n      return {\n        url: url,\n        headers: { Authorization: 'Bearer ' + token },\n      }\n    }\n  }\n\n  render() {\n    const {\n      viewport,\n      maxZoom,\n      minZoom,\n      transitionEnd,\n      mapStyle,\n      onClosePopup,\n      clickPopup,\n      hoverPopup,\n      hasHeatmapLayers,\n      markers,\n      interactiveLayerIds,\n    } = this.props\n\n    return (\n      <div\n        id=\"map\"\n        className={styles.map}\n        ref={(ref) => {\n          this._mapContainerRef = ref\n        }}\n        onMouseLeave={() => {\n          this.setState({ mouseOver: false })\n        }}\n        onMouseEnter={() => {\n          this.setState({ mouseOver: true })\n        }}\n      >\n        <MapGL\n          {...viewport}\n          ref={this.getRef}\n          transformRequest={this.transformRequest}\n          onTransitionEnd={transitionEnd}\n          onLoad={this.onLoad}\n          onHover={this.onHover}\n          onClick={this.onClick}\n          getCursor={this.getCursor}\n          mapStyle={mapStyle}\n          maxZoom={maxZoom}\n          minZoom={minZoom}\n          onViewportChange={this.onViewportChange}\n          interactiveLayerIds={interactiveLayerIds}\n          clickRadius={4}\n          disableTokenWarning={true}\n        >\n          {hasHeatmapLayers !== false && <ActivityLayers />}\n          {clickPopup !== undefined && clickPopup !== null && (\n            <PopupWrapper\n              latitude={clickPopup.latitude}\n              longitude={clickPopup.longitude}\n              closeButton\n              onClose={onClosePopup}\n            >\n              {clickPopup.content}\n            </PopupWrapper>\n          )}\n          {this.state.mouseOver === true && hoverPopup !== undefined && hoverPopup !== null && (\n            <PopupWrapper\n              latitude={hoverPopup.latitude}\n              longitude={hoverPopup.longitude}\n              closeButton={false}\n            >\n              {hoverPopup.content}\n            </PopupWrapper>\n          )}\n          {markers !== null &&\n            markers.length > 0 &&\n            markers.map((marker, i) => (\n              <Marker key={i} latitude={marker.latitude} longitude={marker.longitude}>\n                {marker.content}\n              </Marker>\n            ))}\n        </MapGL>\n        <div className={styles.googleLogo} />\n      </div>\n    )\n  }\n}\n\nMap.propTypes = {\n  token: PropTypes.string,\n  viewport: PropTypes.object.isRequired,\n  mapStyle: PropTypes.object.isRequired,\n  clickPopup: PropTypes.object,\n  hoverPopup: PropTypes.object,\n  maxZoom: PropTypes.number.isRequired,\n  minZoom: PropTypes.number.isRequired,\n  setViewport: PropTypes.func.isRequired,\n  setBounds: PropTypes.func,\n  mapInteraction: PropTypes.func,\n  onLoad: PropTypes.func,\n  onClosePopup: PropTypes.func,\n  transitionEnd: PropTypes.func,\n  cursor: PropTypes.string,\n  hasHeatmapLayers: PropTypes.bool.isRequired,\n  markers: PropTypes.arrayOf(\n    PropTypes.shape({\n      latitude: PropTypes.number.isRequired,\n      longitude: PropTypes.number.isRequired,\n      content: PropTypes.node,\n    })\n  ),\n  interactiveLayerIds: PropTypes.arrayOf(PropTypes.string),\n}\n\nMap.defaultProps = {\n  token: null,\n  clickPopup: null,\n  hoverPopup: null,\n  mapInteraction: () => {},\n  onLoad: () => {},\n  onClosePopup: () => {},\n  transitionEnd: () => {},\n  cursor: null,\n  markers: null,\n  interactiveLayerIds: null,\n  setBounds: undefined,\n}\n\nexport default Map\n","import { connect } from 'react-redux'\nimport { createSelector } from 'reselect'\nimport { fromJS } from 'immutable'\nimport { TRACKS_LAYER_IN_FRONT_OF_GROUP } from '../config'\nimport { closePopup } from '../module/module.actions.js'\nimport { getTracksStyles } from '../tracks/tracks.selectors.js'\nimport { mapInteraction } from './interaction.actions.js'\nimport { setBounds, setViewport, transitionEnd } from './viewport.actions.js'\nimport Map from './Map'\n\nconst getStaticLayers = (state) => state.map.style.staticLayers\nconst getHeatmapLayers = (state) => state.map.heatmap.heatmapLayers\nconst getInternalCursor = (state) => state.map.interaction.cursor\nconst getModuleCursor = (state) => state.map.module.cursor\n\nconst hasHeatmapLayers = createSelector(\n  [getHeatmapLayers],\n  (heatmapLayers) => {\n    return Object.keys(heatmapLayers).length > 0\n  }\n)\nconst getInteractiveLayerIds = createSelector(\n  [getStaticLayers],\n  // Note: here we assume that layer IDs provided with module match the GL layers that should\n  // be interactive or not, ie typically the fill layer if a label layer is present\n  (staticLayers) => {\n    return staticLayers.reduce((acc, layer) => {\n      if (!layer.interactive || !layer.visible) return acc\n      // We also need to check nested layers interactivity when custom gl layers are provided\n      if (layer.gl !== undefined) {\n        layer.gl.layers.forEach((glLayer, index) => {\n          // layers.length === 1 is used to ensure when parent layer is marked as interactive we have to\n          // have at least one interactive sublayer, then checked eah one individually\n          if (\n            layer.gl.layers.length === 1 ||\n            (glLayer.metadata !== undefined && glLayer.metadata['gfw:interactive'] === true)\n          ) {\n            const glLayerId = glLayer.id || index > 0 ? `${layer.id}-${index}` : layer.id\n            acc.push(glLayerId)\n          }\n        })\n      } else {\n        acc.push(layer.id)\n      }\n      return acc\n    }, [])\n  }\n)\n\nconst getMapStyles = (state) => state.map.style.mapStyle\nconst getMapStyle = createSelector(\n  [getMapStyles, getTracksStyles],\n  (mapStyles, trackStyles) => {\n    if (!trackStyles) return mapStyles\n\n    const currentLayerGroups = mapStyles\n      .toJS()\n      .layers.filter((l) => l.metadata !== undefined)\n      .map((l) => l.metadata['mapbox:group'])\n    const trackLayersIndex = currentLayerGroups.lastIndexOf(TRACKS_LAYER_IN_FRONT_OF_GROUP) + 1\n\n    let finalMapStyles = mapStyles.mergeIn(['sources'], trackStyles.sources)\n    let mapStylesLayers = mapStyles.get('layers')\n    trackStyles.layers.forEach((trackLayer, i) => {\n      mapStylesLayers = mapStylesLayers.insert(trackLayersIndex + i, fromJS(trackLayer))\n    })\n    finalMapStyles = finalMapStyles.set('layers', mapStylesLayers)\n    return finalMapStyles\n  }\n)\n\nconst getCursor = createSelector(\n  [getInternalCursor, getModuleCursor],\n  (internalCursor, moduleCursor) => {\n    if (moduleCursor !== null) {\n      return moduleCursor\n    }\n    return internalCursor\n  }\n)\nconst mapStateToProps = (state) => ({\n  viewport: state.map.viewport.viewport,\n  maxZoom: state.map.viewport.maxZoom,\n  minZoom: state.map.viewport.minZoom,\n  onLoad: state.map.module.onLoad,\n  cursor: getCursor(state),\n  token: state.map.module.token,\n  mapStyle: getMapStyle(state),\n  hasHeatmapLayers: hasHeatmapLayers(state),\n  interactiveLayerIds: getInteractiveLayerIds(state),\n})\n\nconst mapDispatchToProps = (dispatch) => ({\n  setViewport: (viewport, interactionState) => {\n    dispatch(setViewport(viewport, interactionState))\n  },\n  setBounds: (bounds) => {\n    dispatch(setBounds(bounds))\n  },\n  mapInteraction: (type, lat, long, features, cluster, glGetSource) => {\n    dispatch(mapInteraction(type, lat, long, features, cluster, glGetSource))\n  },\n  transitionEnd: () => {\n    dispatch(transitionEnd())\n  },\n  onClosePopup: () => {\n    dispatch(closePopup())\n  },\n})\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(Map)\n","import { fromJS } from 'immutable'\nimport uniq from 'lodash/uniq'\nimport GL_STYLE from './gl-styles/style.json'\nimport {\n  SET_MAP_STYLE,\n  MARK_CARTO_LAYERS_AS_INSTANCIATED,\n  INIT_MAP_STYLE,\n  SET_STATIC_LAYERS,\n  SET_BASEMAP_LAYERS,\n} from './style.actions'\n\nconst attributions = uniq(\n  Object.keys(GL_STYLE.sources)\n    .map((sourceKey) => GL_STYLE.sources[sourceKey].attribution)\n    .filter((source) => source !== undefined)\n)\n\nexport const setLayerStyleDefaults = (layer) => {\n  if (layer.layout === undefined) {\n    layer.layout = {}\n  }\n  if (layer.paint === undefined) {\n    layer.paint = {}\n  }\n  if (layer.metadata === undefined) {\n    layer.metadata = {}\n  }\n  // initialize time filter for time-filterable layers\n  if (layer.metadata['gfw:temporal'] === true) {\n    const temporalField =\n      layer.metadata['gfw:temporalField'] === undefined\n        ? 'timestamp'\n        : layer.metadata['gfw:temporalField']\n    layer.filter = ['all', ['>', temporalField, 0], ['<', temporalField, 999999999999]]\n  }\n\n  if (layer.metadata['mapbox:group'] === undefined) {\n    layer.metadata['mapbox:group'] = 'temporal'\n  }\n\n  // set all layers to not visible except layers explicitely marked as visible (default basemap)\n  if (layer.layout.visibility !== 'visible') {\n    layer.layout.visibility = 'none'\n  }\n  return layer\n}\n\nconst setStyleDefaults = (style) => {\n  style.layers.forEach((layer) => {\n    setLayerStyleDefaults(layer)\n  })\n  return style\n}\n\nconst initialState = {\n  mapStyle: fromJS(setStyleDefaults(GL_STYLE)),\n  cartoLayersInstanciated: [],\n  staticLayers: [],\n  basemapLayers: [],\n  attributions,\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case INIT_MAP_STYLE: {\n      const newMapStyle = state.mapStyle.setIn(['glyphs'], action.payload.glyphsPath)\n      return { ...state, mapStyle: newMapStyle }\n    }\n    case SET_MAP_STYLE: {\n      return { ...state, mapStyle: action.payload }\n    }\n    case SET_STATIC_LAYERS: {\n      return { ...state, staticLayers: action.payload }\n    }\n    case SET_BASEMAP_LAYERS: {\n      return { ...state, basemapLayers: action.payload }\n    }\n    case MARK_CARTO_LAYERS_AS_INSTANCIATED: {\n      const cartoLayersInstanciated = [...state.cartoLayersInstanciated, ...action.payload]\n      return { ...state, cartoLayersInstanciated }\n    }\n    default:\n      return state\n  }\n}\n","// This utility looks at GeoJSON features and returns the predominant geometry type\n\nconst TYPES = [\n  { gl: 'line', geoJSON: ['LineString', 'MultiLineString'] },\n  { gl: 'fill', geoJSON: ['Polygon', 'MultiPolygon'] },\n  { gl: 'circle', geoJSON: ['Point', 'MultiPoint'] },\n]\n\nexport default (geoJSON) => {\n  // collect all geoJSON geom types\n  const allGeoJSONTypes = geoJSON.features.map((feature) => {\n    const geom = feature.geometry\n    if (geom === undefined) {\n      return null\n    }\n    return geom.type\n  })\n\n  // collect number of geometries by GL geom types\n  const numByGLType = TYPES.map((type) => {\n    let num = 0\n    allGeoJSONTypes.forEach((geoJSONType) => {\n      if (type.geoJSON.indexOf(geoJSONType) > -1) {\n        num++\n      }\n    })\n    return { gl: type.gl, num }\n  })\n\n  // get feature types with the higher count\n  let glType = 'fill'\n  let glTypeMax = 0\n  numByGLType.forEach((t) => {\n    if (t.num > glTypeMax) {\n      glType = t.gl\n      glTypeMax = t.num\n    }\n  })\n\n  return glType\n}\n","import { fromJS } from 'immutable'\nimport convert from '@globalfishingwatch/map-convert'\nimport uniq from 'lodash/uniq'\nimport throttle from 'lodash/throttle'\nimport { hexToRgb } from '../utils/map-colors'\nimport { STATIC_LAYERS_CARTO_ENDPOINT, STATIC_LAYERS_CARTO_TILES_ENDPOINT } from '../config'\nimport { CUSTOM_LAYERS_SUBTYPES, GL_TRANSPARENT } from '../constants'\nimport GL_STYLE from './gl-styles/style.json'\nimport { setLayerStyleDefaults } from './style.reducer.js'\nimport getMainGeomType from '../utils/getMainGeomType'\n\nexport const INIT_MAP_STYLE = 'INIT_MAP_STYLE'\nexport const SET_MAP_STYLE = 'SET_MAP_STYLE'\nexport const MARK_CARTO_LAYERS_AS_INSTANCIATED = 'MARK_CARTO_LAYERS_AS_INSTANCIATED'\nexport const SET_STATIC_LAYERS = 'SET_STATIC_LAYERS'\nexport const SET_BASEMAP_LAYERS = 'SET_BASEMAP_LAYERS'\n\nconst setDefaultVectorTiles = (currentSource, refLayerUrl) => {\n  if (currentSource.type !== 'vector') {\n    return currentSource\n  }\n  const tiles = currentSource.tiles\n  const refLayerUrls = refLayerUrl === undefined ? [] : [refLayerUrl]\n\n  const newTiles =\n    tiles !== undefined && tiles.length > 0 ? uniq([...refLayerUrls, ...tiles]) : refLayerUrls\n  return {\n    ...currentSource,\n    tiles: newTiles,\n  }\n}\n\nexport const initStyle = ({ glyphsPath }) => ({\n  type: INIT_MAP_STYLE,\n  payload: {\n    glyphsPath,\n  },\n})\n\nconst setMapStyle = (style) => ({\n  type: SET_MAP_STYLE,\n  payload: style,\n})\n\nconst setStyleTemporalExtent = (dispatch, getState, temporalExtent, applyToThrottled = false) => {\n  const state = getState().map.style\n  let style = state.mapStyle\n  const currentStyle = style.toJS()\n  const glLayers = currentStyle.layers\n\n  let start = Math.round(temporalExtent[0].getTime() / 1000)\n  let end = Math.round(temporalExtent[1].getTime() / 1000)\n\n  // TEMPORARY, remove later - temporal layers points should have a timestamp, this is legacy\n  // logic for legacy encounters layer that only have a 'timeIndex'\n  const startIndex = convert.getOffsetedTimeAtPrecision(temporalExtent[0].getTime())\n  const endIndex = convert.getOffsetedTimeAtPrecision(temporalExtent[1].getTime())\n\n  for (let i = 0; i < glLayers.length; i++) {\n    const glLayer = glLayers[i]\n    if (glLayer.metadata === undefined || glLayer.metadata['gfw:temporal'] !== true) {\n      continue\n    }\n\n    if (\n      (applyToThrottled === true && glLayer.metadata['gfw:temporal:throttled'] !== true) ||\n      (applyToThrottled === false && glLayer.metadata['gfw:temporal:throttled'] === true)\n    ) {\n      continue\n    }\n\n    // if layer is temporal, a filter must always be preset on the style.json object\n    // because each layer can have a different time field to be filtered\n    const currentFilter = style.getIn(['layers', i, 'filter']).toJS()\n    if (currentFilter === null) {\n      throw new Error('filter must be preset on style.json for temporal layer: ', glLayer.id)\n    }\n\n    // TEMPORARY, remove later - temporal layers points should have a timestamp, this is legacy\n    // logic for legacy encounters layer that only have a 'timeIndex'\n    const isLegacy = glLayer.metadata && glLayer.metadata['gfw:temporalField'] === 'timeIndex'\n    currentFilter[1][2] = isLegacy ? startIndex : start\n    currentFilter[2][2] = isLegacy ? endIndex : end\n    style = style.setIn(['layers', i, 'filter'], fromJS(currentFilter))\n  }\n  dispatch(setMapStyle(style))\n}\n\nconst applyTemporalExtentThrottled = throttle((dispatch, getState, temporalExtent) => {\n  setStyleTemporalExtent(dispatch, getState, temporalExtent, true)\n}, 400)\n\nexport const applyTemporalExtent = (temporalExtent) => (dispatch, getState) => {\n  setStyleTemporalExtent(dispatch, getState, temporalExtent)\n  applyTemporalExtentThrottled(dispatch, getState, temporalExtent)\n}\n\nconst applyLayerExpressions = (style, refLayer, currentGlLayer, glLayerIndex) => {\n  let newStyle = style\n  const currentStyle = style.toJS()\n  const glType = currentGlLayer.type\n  const defaultStyles = currentStyle.metadata['gfw:styles']\n  const metadata = currentGlLayer.metadata\n  ;['selected', 'highlighted'].forEach((styleType) => {\n    // get selectedFeatures or highlightedFeatures\n    const features = refLayer[`${styleType}Features`]\n    const refLayerStyle = features && features.style ? features.style[glType] : {}\n    const hasFeatures = features !== null && features !== undefined && features.values.length > 0\n    const applyStyleToAllFeatures = refLayer[styleType]\n\n    const defaultStyle = defaultStyles[styleType][glType] || {}\n    const layerStyle =\n      (metadata && metadata['gfw:styles'] && metadata['gfw:styles'][styleType]) || {}\n    const allPaintProperties = { ...defaultStyle, ...layerStyle, ...refLayerStyle }\n\n    if (Object.keys(allPaintProperties).length) {\n      // go through each applicable gl paint property\n      Object.keys(allPaintProperties).forEach((glPaintProperty) => {\n        const selectedValue = allPaintProperties[glPaintProperty][0]\n        const fallbackValue = allPaintProperties[glPaintProperty][1]\n        const paintOrLayout = ['icon-size', 'icon-image'].includes(glPaintProperty)\n          ? 'layout'\n          : 'paint'\n        let glPaintFinalValue\n        if (\n          hasFeatures === false &&\n          applyStyleToAllFeatures !== true &&\n          applyStyleToAllFeatures !== false\n        ) {\n          // style reset when no features filter is declared and neither is applyAll\n          const originalLayerStyle = GL_STYLE.layers.find((l) => l.id === currentGlLayer.id)\n\n          if (originalLayerStyle !== undefined) {\n            // for reset: do not repaint with default style when layer as a custom main color property\n            if (\n              currentGlLayer.metadata &&\n              currentGlLayer.metadata['gfw:mainColorPaintProperty'] === glPaintProperty\n            ) {\n              glPaintFinalValue = null\n            } else {\n              glPaintFinalValue = originalLayerStyle[paintOrLayout][glPaintProperty]\n            }\n          } else {\n            // this will happen when no style exist in the original definition (ie custom layers)\n            // in this case set glPaintFinalValue to null and we'll just skip applying\n            // any selected/highlighted style for this layer\n            glPaintFinalValue = null\n          }\n        } else if (applyStyleToAllFeatures === true || applyStyleToAllFeatures === false) {\n          glPaintFinalValue = applyStyleToAllFeatures === true ? selectedValue : fallbackValue\n        } else {\n          let layerColorRgbString = ''\n          if (refLayer.color !== null && refLayer.color !== undefined) {\n            const layerColorRgb = hexToRgb(refLayer.color)\n            layerColorRgbString = `${layerColorRgb.r},${layerColorRgb.g},${layerColorRgb.b}`\n          }\n          glPaintFinalValue = [\n            'match',\n            ['get', features.field],\n            features.values,\n            typeof selectedValue !== 'string'\n              ? selectedValue\n              : selectedValue.replace('$REFLAYER_COLOR_RGB', layerColorRgbString),\n            typeof fallbackValue !== 'string'\n              ? fallbackValue\n              : fallbackValue.replace('$REFLAYER_COLOR_RGB', layerColorRgbString),\n          ]\n        }\n\n        if (glPaintFinalValue !== undefined && glPaintFinalValue !== null) {\n          newStyle = newStyle.setIn(\n            ['layers', glLayerIndex, paintOrLayout, glPaintProperty],\n            glPaintFinalValue\n          )\n        }\n      })\n    }\n  })\n  return newStyle\n}\n\nconst toggleLayerVisibility = (style, refLayer, glLayerIndex) => {\n  const visibility = refLayer.visible === true ? 'visible' : 'none'\n  return style.setIn(['layers', glLayerIndex, 'layout', 'visibility'], visibility)\n}\n\nconst updateGLLayer = (style, glLayerId, refLayer) => {\n  const currentStyle = style.toJS()\n  const currentStyleLayers = currentStyle.layers\n  let newStyle = style\n\n  const glLayerIndex = currentStyleLayers.findIndex((l) => l.id === glLayerId)\n  const glLayer = currentStyleLayers.find((l) => l.id === glLayerId)\n\n  // visibility\n  newStyle = toggleLayerVisibility(newStyle, refLayer, glLayerIndex)\n\n  if (refLayer.isBasemap === true) {\n    return newStyle\n  }\n\n  const refLayerOpacity = refLayer.opacity === undefined ? 1 : refLayer.opacity\n\n  // color/opacity\n  switch (glLayer.type) {\n    case 'fill': {\n      newStyle = newStyle\n        .setIn(['layers', glLayerIndex, 'paint', 'fill-opacity'], refLayerOpacity)\n        .setIn(['layers', glLayerIndex, 'paint', 'fill-outline-color'], refLayer.color)\n        .setIn(['layers', glLayerIndex, 'paint', 'fill-color'], GL_TRANSPARENT)\n      break\n    }\n    case 'line': {\n      const color = refLayer.color || (glLayer.paint && glLayer.paint['line-color'])\n      newStyle = newStyle\n        .setIn(['layers', glLayerIndex, 'paint', 'line-opacity'], refLayerOpacity)\n        .setIn(['layers', glLayerIndex, 'paint', 'line-color'], color)\n      break\n    }\n    case 'symbol': {\n      if (glLayer.metadata && glLayer.metadata['gfw:isLabel'] === true) {\n        const parentLayerIsVisible =\n          newStyle.getIn(['layers', glLayerIndex, 'layout', 'visibility']) === 'visible'\n        const labelsVisibility =\n          parentLayerIsVisible && refLayer.showLabels === true ? 'visible' : 'none'\n        newStyle = newStyle.setIn(\n          ['layers', glLayerIndex, 'layout', 'visibility'],\n          labelsVisibility\n        )\n        if (refLayer.showLabels !== true) {\n          break\n        }\n      }\n      newStyle = newStyle.setIn(['layers', glLayerIndex, 'paint', 'text-opacity'], refLayerOpacity)\n\n      if (refLayer.color !== undefined) {\n        newStyle = newStyle.setIn(['layers', glLayerIndex, 'paint', 'text-color'], refLayer.color)\n      }\n      break\n    }\n    // Event layers and custom layers with point geom types\n    case 'circle': {\n      newStyle = newStyle\n        .setIn(['layers', glLayerIndex, 'paint', 'circle-opacity'], refLayerOpacity)\n        .setIn(['layers', glLayerIndex, 'paint', 'circle-stroke-opacity'], refLayerOpacity)\n\n      if (refLayer.color !== undefined) {\n        const colorPaintProperty =\n          glLayer && glLayer.metadata && glLayer.metadata['gfw:mainColorPaintProperty']\n            ? glLayer.metadata['gfw:mainColorPaintProperty']\n            : 'circle-color'\n        newStyle = newStyle.setIn(\n          ['layers', glLayerIndex, 'paint', colorPaintProperty],\n          refLayer.color\n        )\n      }\n      break\n    }\n    case 'raster': {\n      newStyle = newStyle.setIn(\n        ['layers', glLayerIndex, 'paint', 'raster-opacity'],\n        refLayerOpacity\n      )\n      break\n    }\n    default: {\n      break\n    }\n  }\n\n  newStyle = applyLayerExpressions(newStyle, refLayer, glLayer, glLayerIndex)\n\n  return newStyle\n}\n\nconst addCustomGLLayer = (subtype, layerId, url, data) => (dispatch, getState) => {\n  const state = getState()\n  let style = state.map.style.mapStyle\n  const currentStyle = style.toJS()\n\n  // add source if it doesn't exist yet\n  if (currentStyle.sources[layerId] === undefined) {\n    const source = { type: subtype }\n    if (subtype === CUSTOM_LAYERS_SUBTYPES.geojson) {\n      source.data = data\n    } else if (subtype === CUSTOM_LAYERS_SUBTYPES.raster) {\n      source.tiles = [url]\n      source.tileSize = 256\n    }\n    style = style.setIn(['sources', layerId], fromJS(source))\n  }\n\n  if (currentStyle.layers.find((glLayer) => glLayer.id === layerId) === undefined) {\n    const glType = subtype === CUSTOM_LAYERS_SUBTYPES.geojson ? getMainGeomType(data) : subtype\n    const glLayer = fromJS({\n      id: layerId,\n      source: layerId,\n      type: glType,\n      layout: {},\n      paint: {},\n    })\n    const layerIndex =\n      subtype === CUSTOM_LAYERS_SUBTYPES.raster\n        ? // if raster, put at index of last raster layer except labels\n          currentStyle.layers.length -\n          1 -\n          currentStyle.layers\n            .filter((l) => l.id !== 'labels')\n            .reverse()\n            .findIndex((l) => l.type === 'raster')\n        : currentStyle.layers.length - 1\n    style = style.set('layers', style.get('layers').splice(layerIndex, 0, glLayer))\n  }\n\n  dispatch(setMapStyle(style))\n}\n\nconst updateWorkspaceGLLayers = (workspaceGLLayers) => (dispatch, getState) => {\n  const state = getState()\n  let style = state.map.style.mapStyle\n\n  workspaceGLLayers.forEach((workspaceGLLayer) => {\n    const { id, gl } = workspaceGLLayer\n    const finalSource = setDefaultVectorTiles(gl.source, workspaceGLLayer.url)\n    style = style.setIn(['sources', id], fromJS(finalSource))\n\n    const existingLayerIds = style\n      .get('layers')\n      .toJS()\n      .map((l) => l.id)\n    const layersToAdd = gl.layers.filter((layer, index) => {\n      const layerId = layer.id || index > 0 ? `${id}-${index}` : id\n      return !existingLayerIds.includes(layerId)\n    })\n    layersToAdd.forEach((layerToAdd, index) => {\n      // doesn't add a sufix in the first elements but it will for the following ones\n      let layerToAddId = layerToAdd.id || index > 0 ? `${id}-${index}` : id\n      const defaultGlLayer = setLayerStyleDefaults(layerToAdd)\n\n      const glLayer = {\n        ...defaultGlLayer,\n        id: layerToAddId,\n        source: id,\n      }\n\n      // set source-layer - defaults to source id\n      if (gl.source.type === 'vector') {\n        const sourceLayer =\n          layerToAdd['source-layer'] === undefined ? id : layerToAdd['source-layer']\n        glLayer['source-layer'] = sourceLayer\n      }\n\n      // find correct z-index\n      const existingLayers = style.get('layers')\n      const newLayerGroup = glLayer.metadata['mapbox:group']\n      const newLayerIndex = existingLayers.findLastIndex((l) => {\n        return newLayerGroup === l.toJS().metadata['mapbox:group']\n      })\n      style = style.set('layers', existingLayers.splice(newLayerIndex, 0, fromJS(glLayer)))\n    })\n  })\n\n  dispatch(setMapStyle(style))\n  dispatch(applyTemporalExtent(state.map.module.temporalExtent))\n}\n\nconst getCartoLayerInstanciatePromise = ({ sourceId, sourceCartoSQL }) => {\n  const mapConfig = { layers: [{ id: sourceId, options: { sql: sourceCartoSQL } }] }\n  const mapConfigURL = encodeURIComponent(JSON.stringify(mapConfig))\n  const cartoAnonymousMapUrl = STATIC_LAYERS_CARTO_ENDPOINT.replace('$MAPCONFIG', mapConfigURL)\n\n  return new Promise((resolve) => {\n    fetch(cartoAnonymousMapUrl)\n      .then((res) => {\n        if (res.status >= 400) {\n          console.warn(`loading of layer failed ${sourceId}`)\n          Promise.reject()\n          return null\n        }\n        return res.json()\n      })\n      .then((data) => {\n        resolve({\n          layergroupid: data.layergroupid,\n          sourceId,\n        })\n      })\n      .catch((err) => {\n        console.warn(err)\n      })\n  })\n}\n\nconst instanciateCartoLayers = (layers) => (dispatch, getState) => {\n  dispatch({\n    type: MARK_CARTO_LAYERS_AS_INSTANCIATED,\n    payload: layers.map((layer) => layer.sourceId),\n  })\n  const cartoLayersPromises = layers.map((layer) => getCartoLayerInstanciatePromise(layer))\n  const cartoLayersPromisesPromise = Promise.all(cartoLayersPromises.map((p) => p.catch((e) => e)))\n  cartoLayersPromisesPromise\n    .then((instanciatedCartoLayers) => {\n      let style = getState().map.style.mapStyle\n      const currentStyle = style.toJS()\n      instanciatedCartoLayers.forEach((cartoLayer) => {\n        const tilesURL = STATIC_LAYERS_CARTO_TILES_ENDPOINT.replace(\n          '$LAYERGROUPID',\n          cartoLayer.layergroupid\n        )\n\n        // replace gl source with a new source that use tiles provided by Carto anonymous maps API\n        const newSourceId = `${cartoLayer.sourceId}-instanciated`\n        style = style.setIn(\n          ['sources', newSourceId],\n          fromJS({\n            type: 'vector',\n            tiles: [tilesURL],\n          })\n        )\n\n        style = style.deleteIn(['sources', cartoLayer.sourceId])\n\n        // change source in all layers that are using it (generally polygon + labels)\n        currentStyle.layers.forEach((glLayer, glLayerIndex) => {\n          if (glLayer.source === cartoLayer.sourceId) {\n            style = style.setIn(['layers', glLayerIndex, 'source'], newSourceId)\n            style = style.setIn(['layers', glLayerIndex, 'metadata', 'gfw:id'], cartoLayer.sourceId)\n            const refLayer = layers.find((l) => l.refLayer.id === cartoLayer.sourceId).refLayer\n            style = updateGLLayer(style, glLayer.id, refLayer)\n          }\n        })\n      })\n\n      dispatch(setMapStyle(style))\n    })\n    .catch((err) => {\n      console.warn(err)\n    })\n}\n\nexport const commitStyleUpdates = (staticLayers, basemapLayers) => (dispatch, getState) => {\n  // Store a copy of static and basemap layers. This is not used directly by\n  // the Map component which only needs a prepared style object\n  dispatch({\n    type: SET_STATIC_LAYERS,\n    payload: staticLayers,\n  })\n  dispatch({\n    type: SET_BASEMAP_LAYERS,\n    payload: basemapLayers,\n  })\n\n  const layers = [...staticLayers, ...basemapLayers.map((bl) => ({ ...bl, isBasemap: true }))]\n\n  const currentGLSources = getState().map.style.mapStyle.toJS().sources\n\n  // collect layers declared in workspace but not in original gl style\n  const workspaceGLLayers = layers.filter((layer) => layer.gl !== undefined)\n\n  if (workspaceGLLayers.length) {\n    // Adds the gl layers again in case the source is a dynamic geojson source\n    dispatch(updateWorkspaceGLLayers(workspaceGLLayers))\n  }\n\n  // instanciate custom layers if needed\n  const customLayers = layers.filter(\n    (layer) => layer.isCustom === true && currentGLSources[layer.id] === undefined\n  )\n  if (customLayers.length) {\n    customLayers.forEach((layer) => {\n      dispatch(addCustomGLLayer(layer.subtype, layer.id, layer.url, layer.data))\n    })\n  }\n\n  const state = getState().map.style\n  let style = state.mapStyle\n  const currentStyle = style.toJS()\n  const glLayers = currentStyle.layers\n  const glSources = currentStyle.sources\n\n  const cartoLayersToInstanciate = []\n\n  // update source when needed\n  staticLayers.forEach((refLayer) => {\n    const sourceId = refLayer.id\n    if (currentGLSources[sourceId] !== undefined && refLayer.visible === true) {\n      if (refLayer.data !== undefined) {\n        style = style.setIn(['sources', sourceId, 'data'], fromJS(refLayer.data))\n      }\n      if (refLayer.url !== undefined) {\n        const newSource = setDefaultVectorTiles(currentGLSources[sourceId], refLayer.url)\n        style = style.setIn(['sources', sourceId], fromJS(newSource))\n      }\n    }\n  })\n\n  for (let i = 0; i < glLayers.length; i++) {\n    const glLayer = glLayers[i]\n    const sourceId = glLayer.source\n    const glSource = glSources[sourceId]\n    const layerId = (glLayer.metadata !== undefined && glLayer.metadata['gfw:id']) || sourceId\n\n    const refLayer = layers.find((l) => l.id === layerId)\n\n    if (refLayer === undefined) {\n      if (glLayer.type !== 'background') {\n        // console.warn('gl layer does not exists in workspace', glLayer);\n      }\n      continue\n    }\n\n    // check if layer is served from Carto, which means we need to instanciate it first\n    // TODO BUG: check if layer is not instanciatING too\n    const sourceCartoSQL = glSource.metadata !== undefined && glSource.metadata['gfw:carto-sql']\n    if (sourceCartoSQL !== false && sourceCartoSQL !== undefined) {\n      // only if layer is visible and has not been instanciated yet\n      const cartoLayerInstanciated = state.cartoLayersInstanciated.indexOf(sourceId) > -1\n      if (\n        refLayer.visible === true &&\n        !cartoLayerInstanciated &&\n        !cartoLayersToInstanciate.find((l) => l.sourceId === sourceId)\n      ) {\n        cartoLayersToInstanciate.push({ sourceId, sourceCartoSQL, refLayer })\n      }\n      continue\n    }\n\n    style = updateGLLayer(style, glLayer.id, refLayer)\n  }\n\n  if (cartoLayersToInstanciate.length) {\n    dispatch(instanciateCartoLayers(cartoLayersToInstanciate))\n  }\n\n  dispatch(setMapStyle(style))\n}\n","import FlyToInterpolator from 'react-map-gl/dist/esm/utils/transition/viewport-fly-to-interpolator'\nimport { easeCubic } from 'd3-ease'\nimport { MIN_ZOOM_LEVEL, MAX_ZOOM_LEVEL } from '../config'\nimport { TRANSITION_TYPE } from '../constants'\nimport {\n  SET_BOUNDS,\n  SET_VIEWPORT,\n  UPDATE_VIEWPORT,\n  SET_ZOOM_INCREMENT,\n  SET_MOUSE_LAT_LONG,\n  TRANSITION_END,\n  SET_NATIVE_VIEWPORT,\n} from './viewport.actions'\n\nexport const TRANSITION_DURATION = 500\n\nconst DEFAULT_TRANSITION = {\n  transitionDuration: TRANSITION_DURATION,\n  transitionInterpolator: new FlyToInterpolator(),\n  transitionEasing: easeCubic,\n}\n\nconst initialState = {\n  viewport: {\n    latitude: 0,\n    longitude: 0,\n    zoom: 3,\n    bearing: 0,\n    pitch: 0,\n    width: 1000,\n    height: 800,\n    bounds: {},\n  },\n  maxZoom: MAX_ZOOM_LEVEL,\n  minZoom: MIN_ZOOM_LEVEL,\n  prevZoom: 3,\n  currentTransition: null,\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case SET_VIEWPORT: {\n      return {\n        ...state,\n        viewport: action.payload,\n        canZoomIn: action.payload.zoom < state.maxZoom,\n        canZoomOut: action.payload.zoom > state.minZoom,\n        prevZoom: state.viewport.zoom,\n      }\n    }\n\n    case SET_BOUNDS: {\n      return {\n        ...state,\n        bounds: action.payload,\n      }\n    }\n\n    case UPDATE_VIEWPORT: {\n      const viewport = { ...state.viewport, ...action.payload }\n      return {\n        ...state,\n        viewport,\n        prevZoom: viewport.zoom,\n      }\n    }\n\n    case SET_ZOOM_INCREMENT: {\n      const currentZoom = state.viewport.zoom\n      const zoom = Math.min(\n        state.maxZoom,\n        action.payload.zoom || currentZoom + action.payload.increment\n      )\n      const viewport = {\n        ...state.viewport,\n        ...DEFAULT_TRANSITION,\n        zoom,\n        latitude:\n          action.payload.latitude === null ? state.viewport.latitude : action.payload.latitude,\n        longitude:\n          action.payload.longitude === null ? state.viewport.longitude : action.payload.longitude,\n      }\n      return {\n        ...state,\n        viewport,\n        canZoomIn: zoom < state.maxZoom,\n        canZoomOut: zoom > state.minZoom,\n        prevZoom: state.viewport.zoom,\n        currentTransition: TRANSITION_TYPE.ZOOM,\n      }\n    }\n\n    case SET_MOUSE_LAT_LONG: {\n      return { ...state, mouseLatLong: action.payload }\n    }\n\n    case TRANSITION_END: {\n      return { ...state, currentTransition: null }\n    }\n\n    case SET_NATIVE_VIEWPORT: {\n      return { ...state, ...action.payload }\n    }\n\n    default:\n      return state\n  }\n}\n","import { compose, createStore, applyMiddleware } from 'redux'\nimport thunk from 'redux-thunk'\n\nimport { TRANSITION_DURATION } from '../glmap/viewport.reducer'\nimport { fitToBounds as fitToBoundsAction, transitionEnd } from '../glmap/viewport.actions'\n\nlet composeEnhancers = compose\nif (\n  process.env.NODE_ENV === 'development' &&\n  (process.env.MAP_REDUX_REMOTE_DEBUG === 'true' ||\n    process.env.REACT_APP_MAP_REDUX_REMOTE_DEBUG === 'true')\n) {\n  const composeWithDevTools = require('remote-redux-devtools').composeWithDevTools\n  composeEnhancers = composeWithDevTools({\n    name: 'Map module',\n    realtime: true,\n    hostname: 'localhost',\n    port: 8000,\n    maxAge: 30,\n    stateSanitizer: (state) => ({ ...state, map: { ...state.map, heatmap: 'NOT_SERIALIZED' } }),\n  })\n}\n\nconst store = createStore(() => {}, {}, composeEnhancers(applyMiddleware(thunk)))\n\nexport const targetMapVessel = (id) => {\n  const track = store.getState().map.tracks.data.find((t) => t.id === id.toString())\n  store.dispatch(fitToBoundsAction(track.geoBounds))\n\n  return track.timelineBounds\n}\nexport const fitToBounds = (bounds) => {\n  store.dispatch(fitToBoundsAction(bounds))\n  setTimeout(() => {\n    // needed as the transition end is not being called on first fitToBounds trigger\n    if (store.getState().map.viewport.currentTransition !== null) {\n      store.dispatch(transitionEnd())\n    }\n  }, TRANSITION_DURATION + 1)\n}\n\nexport default store\n","import tbbox from '@turf/bbox'\n\nexport const getTrackTimeBounds = (geojson) => {\n  const time = { start: Infinity, end: 0 }\n  if (geojson && geojson.features) {\n    geojson.features.forEach((feature) => {\n      const hasTimes =\n        feature.properties &&\n        feature.properties.coordinateProperties &&\n        feature.properties.coordinateProperties.times &&\n        feature.properties.coordinateProperties.times.length > 0\n      if (hasTimes) {\n        feature.properties.coordinateProperties.times.forEach((datetime) => {\n          if (datetime < time.start) {\n            time.start = datetime\n          } else if (datetime > time.end) {\n            time.end = datetime\n          }\n        })\n      }\n    })\n  }\n  return [time.start, time.end]\n}\n\nexport const getTrackBounds = (geojson) => {\n  const bounds = tbbox(geojson)\n  return {\n    minLat: bounds[3],\n    minLng: bounds[0],\n    maxLat: bounds[1],\n    maxLng: bounds[2],\n  }\n}\n","import { targetMapVessel } from '../store'\n\nimport { getTilePromises, getCleanVectorArrays, groupData } from '../utils/heatmapTileData'\nimport { startLoader, completeLoader } from '../module/module.actions'\nimport { getTrackBounds, getTrackTimeBounds } from '../utils/getTrackBounds'\n\nexport const ADD_TRACK = 'ADD_TRACK'\nexport const UPDATE_TRACK = 'UPDATE_TRACK'\nexport const REMOVE_TRACK = 'REMOVE_TRACK'\n\nconst convertLegacyTrackToGeoJSON = (vectorArrays) => {\n  const createFeature = (segId, type = 'track', geomType = 'LineString') => ({\n    type: 'Feature',\n    geometry: {\n      type: geomType,\n      coordinates: [],\n    },\n    properties: {\n      type,\n      segId,\n      coordinateProperties: {\n        times: [],\n      },\n    },\n  })\n\n  let currentLng\n  let currentSeries = vectorArrays.series[0]\n  let currentFeature = createFeature(currentSeries)\n  const fishingPoints = createFeature('fishing', 'fishing', 'MultiPoint')\n  const features = []\n  let lngOffset = 0\n\n  for (let index = 0, length = vectorArrays.latitude.length; index < length; index++) {\n    const series = vectorArrays.series[index]\n    const longitude = vectorArrays.longitude[index]\n    const latitude = vectorArrays.latitude[index]\n    const weight = vectorArrays.weight[index]\n\n    if (currentLng) {\n      if (longitude - currentLng < -180) {\n        lngOffset += 360\n      } else if (longitude - currentLng > 180) {\n        lngOffset -= 360\n      }\n    }\n\n    const ll = [longitude + lngOffset, latitude]\n    if (series !== currentSeries && index !== 0) {\n      features.push(currentFeature)\n      currentFeature = createFeature(series)\n    }\n\n    currentFeature.geometry.coordinates.push(ll)\n    if (weight > 0) {\n      fishingPoints.geometry.coordinates.push(ll)\n      fishingPoints.properties.coordinateProperties.times.push(vectorArrays.datetime[index])\n    }\n    currentFeature.properties.coordinateProperties.times.push(vectorArrays.datetime[index])\n\n    currentSeries = series\n    currentLng = longitude\n  }\n\n  features.push(currentFeature)\n  features.push(fishingPoints)\n\n  return {\n    type: 'FeatureCollection',\n    features,\n  }\n}\n\nfunction loadTrack(track) {\n  return (dispatch, getState) => {\n    const { id, url, type, fitBoundsOnLoad, layerTemporalExtents, color, data } = track\n    const state = getState()\n    const token = state.map.module.token\n\n    if (state.map.tracks.data.find((t) => t.id === id)) {\n      return\n    }\n\n    const payload = {\n      id,\n      url,\n      type,\n      color,\n      fitBoundsOnLoad,\n    }\n    const trackHasData = track.data !== undefined && track.data !== null\n    const trackHasUrl = url !== undefined && url !== null && url !== ''\n    if (trackHasData) {\n      payload.data = data\n      payload.geoBounds = getTrackBounds(data)\n    }\n    dispatch({ type: ADD_TRACK, payload })\n\n    if (trackHasData || !trackHasUrl) {\n      return\n    }\n\n    const loaderID = startLoader(dispatch, state)\n    if (type !== 'geojson') {\n      // Deprecated tracks format logic to be deleted some day\n      const token = state.map.module.token\n\n      const promises = getTilePromises(url, token, layerTemporalExtents)\n\n      Promise.all(promises.map((p) => p.catch((e) => e))).then((rawTileData) => {\n        const cleanData = getCleanVectorArrays(rawTileData)\n\n        if (!cleanData.length) {\n          return\n        }\n        const rawTrackData = groupData(cleanData, [\n          'latitude',\n          'longitude',\n          'datetime',\n          'series',\n          'weight',\n          'sigma',\n        ])\n\n        const data = convertLegacyTrackToGeoJSON(rawTrackData)\n        const timelineBounds = getTrackTimeBounds(data)\n        const geoBounds = getTrackBounds(data)\n\n        dispatch({\n          type: UPDATE_TRACK,\n          payload: {\n            id,\n            data,\n            geoBounds,\n            timelineBounds,\n          },\n        })\n        dispatch(completeLoader(loaderID))\n      })\n    } else {\n      fetch(url, { headers: { Authorization: 'Bearer ' + token } })\n        .then((res) => {\n          if (res.status >= 400) throw new Error(res.statusText)\n          return res.json()\n        })\n        .then((data) => {\n          const timelineBounds = getTrackTimeBounds(data)\n          const geoBounds = getTrackBounds(data)\n          dispatch({\n            type: UPDATE_TRACK,\n            payload: {\n              id,\n              data,\n              geoBounds,\n              timelineBounds,\n            },\n          })\n          if (fitBoundsOnLoad) {\n            targetMapVessel(id)\n          }\n        })\n        .catch((err) => console.warn(err))\n        .finally(() => dispatch(completeLoader(loaderID)))\n    }\n  }\n}\n\nconst removeTrack = (trackId) => ({\n  type: REMOVE_TRACK,\n  payload: {\n    trackId,\n  },\n})\n\nexport const updateTracks = (newTracks = []) => (dispatch, getState) => {\n  const prevTracks = getState().map.tracks.data\n  // add and update layers\n  if (newTracks) {\n    newTracks.forEach((newTrack) => {\n      const trackId = newTrack.id\n      const prevTrack = prevTracks.find((t) => t.id === trackId)\n      if (prevTrack === undefined) {\n        dispatch(loadTrack(newTrack))\n      } else if (prevTrack.color !== newTrack.color) {\n        dispatch({\n          type: UPDATE_TRACK,\n          payload: {\n            id: newTrack.id,\n            color: newTrack.color,\n          },\n        })\n      }\n    })\n  }\n\n  // clean up unused tracks\n  prevTracks.forEach((prevTrack) => {\n    if (!newTracks || !newTracks.find((t) => t.id === prevTrack.id)) {\n      dispatch(removeTrack(prevTrack.id))\n    }\n  })\n}\n","import PropTypes from 'prop-types'\n\nconst withReducerPropTypes = (name, propTypesSchema) => (reducer) => {\n  if (process.env.NODE_ENV === 'development') {\n    return (state, action) => {\n      const result = reducer(state, action)\n      PropTypes.checkPropTypes(propTypesSchema, result, 'reducer', name)\n\n      return result\n    }\n  }\n  return reducer\n}\n\nexport default withReducerPropTypes\n","import PropTypes from 'prop-types'\nimport withReducerTypes from '../utils/withReducerTypes'\nimport {\n  INIT_MODULE,\n  SET_TEMPORAL_EXTENT,\n  SET_HIGHLIGHT_TEMPORAL_EXTENT,\n  START_LOADER,\n  COMPLETE_LOADER,\n  SET_MODULE_CURSOR,\n} from './module.actions'\n\nconst initialState = {\n  loaders: null,\n  token: undefined,\n  temporalExtent: [new Date(1970), new Date()],\n  highlightTemporalExtent: null,\n  cursor: null,\n  onViewportChange: undefined,\n  onHover: undefined,\n  onClick: undefined,\n  onLoad: undefined,\n  onLoadStart: undefined,\n  onLoadComplete: undefined,\n  onClosePopup: undefined,\n  onAttributionsChange: undefined,\n}\n\nconst moduleReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case INIT_MODULE: {\n      return {\n        ...state,\n        ...action.payload,\n      }\n    }\n\n    case SET_TEMPORAL_EXTENT: {\n      return {\n        ...state,\n        temporalExtent: action.payload,\n      }\n    }\n\n    case SET_HIGHLIGHT_TEMPORAL_EXTENT: {\n      return {\n        ...state,\n        highlightTemporalExtent: action.payload,\n      }\n    }\n\n    case START_LOADER: {\n      const loaders = state.loaders !== null ? [...state.loaders] : []\n      loaders.push(action.payload)\n      return { ...state, loaders }\n    }\n\n    case COMPLETE_LOADER: {\n      const loaders = [...state.loaders]\n      const loaderIndex = loaders.findIndex((l) => l === action.payload)\n      loaders.splice(loaderIndex, 1)\n      return { ...state, loaders }\n    }\n\n    case SET_MODULE_CURSOR: {\n      return { ...state, cursor: action.payload }\n    }\n\n    default:\n      return state\n  }\n}\n\nconst moduleTypes = {\n  loaders: PropTypes.arrayOf(PropTypes.number),\n  token: PropTypes.string,\n  temporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  onViewportChange: PropTypes.func,\n  onHover: PropTypes.func,\n  onClick: PropTypes.func,\n  onLoad: PropTypes.func,\n  onLoadStart: PropTypes.func,\n  onLoadComplete: PropTypes.func,\n  onClosePopup: PropTypes.func,\n  onAttributionsChange: PropTypes.func,\n}\n\nexport default withReducerTypes('module', moduleTypes)(moduleReducer)\n","import PropTypes from 'prop-types'\nimport { trackTypes } from '../proptypes/tracks'\nimport withReducerTypes from '../utils/withReducerTypes'\n\nimport { ADD_TRACK, UPDATE_TRACK, REMOVE_TRACK } from './tracks.actions'\n\nconst initialState = {\n  data: [],\n}\n\nconst tracksReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case ADD_TRACK: {\n      const data = [...state.data, action.payload]\n      return { ...state, data }\n    }\n\n    case UPDATE_TRACK: {\n      const trackData = action.payload\n      const data = state.data.map((track) => {\n        if (track.id !== trackData.id) return track\n        return {\n          ...track,\n          ...trackData,\n        }\n      })\n      return { ...state, data }\n    }\n\n    case REMOVE_TRACK: {\n      const removedTrackId = action.payload.trackId\n      const data = state.data.filter((track) => track.id !== removedTrackId)\n      return { ...state, data }\n    }\n\n    default:\n      return state\n  }\n}\n\nconst tracksTypes = {\n  data: PropTypes.arrayOf(\n    PropTypes.exact({\n      ...trackTypes,\n      data: PropTypes.object,\n      timelineBounds: PropTypes.array,\n      geoBounds: PropTypes.exact({\n        minLat: PropTypes.number,\n        minLng: PropTypes.number,\n        maxLat: PropTypes.number,\n        maxLng: PropTypes.number,\n      }),\n    })\n  ),\n}\n\nexport default withReducerTypes('tracks', tracksTypes)(tracksReducer)\n","import difference from 'lodash/difference'\nimport {\n  INIT_HEATMAP_LAYERS,\n  UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES,\n  ADD_HEATMAP_LAYER,\n  UPDATE_HEATMAP_LAYER_STYLE,\n  REMOVE_HEATMAP_LAYER,\n  ADD_REFERENCE_TILE,\n  UPDATE_HEATMAP_TILE,\n  RELEASE_HEATMAP_TILES,\n  HIGHLIGHT_VESSELS,\n  UPDATE_LOADED_TILES,\n  HIGHLIGHT_CLICKED_VESSEL,\n  CLEAR_HIGHLIGHT_CLICKED_VESSEL,\n} from './heatmap.actions'\n\nconst initialState = {\n  // a dict of heatmap layers (key is layer id)\n  // each containing data, url, tiles, visibleTemporalExtentsIndices\n  heatmapLayers: {},\n  // store a list of tiles currently visible in the map\n  // those are necessary when adding a new layer to know which tiles need to be loaded\n  referenceTiles: [],\n  highlightedVessels: { isEmpty: true },\n  highlightedClickedVessel: null,\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case INIT_HEATMAP_LAYERS: {\n      return Object.assign({}, state, { heatmapLayers: action.payload })\n    }\n\n    case UPDATE_HEATMAP_LAYER_TEMPORAL_EXTENTS_LOADED_INDICES: {\n      const heatmapLayers = state.heatmapLayers\n      heatmapLayers[action.payload.layerId].visibleTemporalExtentsIndices =\n        action.payload.newVisibleTemporalExtentsIndices\n\n      // also removing indices within each tile\n      // adding is done after tile has actually loaded\n      heatmapLayers[action.payload.layerId].tiles.forEach((tile) => {\n        tile.temporalExtentsIndicesLoaded = difference(\n          tile.temporalExtentsIndicesLoaded,\n          action.payload.indicesRemoved\n        )\n      })\n      return { ...state, heatmapLayers }\n    }\n\n    case ADD_HEATMAP_LAYER: {\n      const heatmapLayers = Object.assign({}, state.heatmapLayers, {\n        [action.payload.id]: {\n          tiles: [],\n          ...action.payload,\n        },\n      })\n      return Object.assign({}, state, { heatmapLayers })\n    }\n\n    case UPDATE_HEATMAP_LAYER_STYLE: {\n      const newLayer = action.payload\n      const layer = { ...state.heatmapLayers[newLayer.id], ...newLayer }\n      const heatmapLayers = { ...state.heatmapLayers, [newLayer.id]: layer }\n      return { ...state, heatmapLayers }\n    }\n\n    case REMOVE_HEATMAP_LAYER: {\n      const heatmapLayers = Object.assign({}, state.heatmapLayers)\n      delete heatmapLayers[action.payload.id]\n      return Object.assign({}, state, { heatmapLayers })\n    }\n\n    case ADD_REFERENCE_TILE: {\n      return Object.assign({}, state, { referenceTiles: [...state.referenceTiles, action.payload] })\n    }\n\n    case UPDATE_HEATMAP_TILE: {\n      const layerId = action.payload.layerId\n      const newTile = action.payload.tile\n      const layer = { ...state.heatmapLayers[layerId] }\n      let layerTiles = [...layer.tiles]\n      const tileIndex = layerTiles.findIndex((t) => t.uid === newTile.uid)\n      if (tileIndex === -1) {\n        layerTiles.push(newTile)\n      } else {\n        layerTiles = [\n          ...layerTiles.slice(0, tileIndex),\n          newTile,\n          ...layerTiles.slice(tileIndex + 1),\n        ]\n      }\n      layer.tiles = layerTiles\n      const heatmapLayers = { ...state.heatmapLayers, [layerId]: layer }\n      return { ...state, heatmapLayers }\n    }\n\n    case RELEASE_HEATMAP_TILES: {\n      const uids = action.payload\n\n      // remove tiles\n      const layerIds = Object.keys(state.heatmapLayers)\n      const heatmapLayers = { ...state.heatmapLayers }\n      layerIds.forEach((layerId) => {\n        const prevLayer = { ...heatmapLayers[layerId] }\n        uids.forEach((tileUid) => {\n          const releasedTileIndex = prevLayer.tiles.findIndex((tile) => tile.uid === tileUid)\n          if (releasedTileIndex > -1) {\n            // console.log('releasing', layerId, tileUid);\n            prevLayer.tiles.splice(releasedTileIndex, 1)\n          }\n        })\n      })\n\n      // remove reference tiles\n      let referenceTiles = [...state.referenceTiles]\n      uids.forEach((tileUid) => {\n        const releasedRefTileIndex = referenceTiles.findIndex((tile) => tile.uid === tileUid)\n        if (releasedRefTileIndex > -1) {\n          referenceTiles = [\n            ...referenceTiles.slice(0, releasedRefTileIndex),\n            ...referenceTiles.slice(releasedRefTileIndex + 1),\n          ]\n        }\n      })\n\n      return { ...state, heatmapLayers, referenceTiles }\n    }\n\n    case UPDATE_LOADED_TILES: {\n      const newHeatmapLayers = { ...state.heatmapLayers }\n      return { ...state, heatmapLayers: newHeatmapLayers }\n    }\n\n    case HIGHLIGHT_VESSELS: {\n      return Object.assign({}, state, { highlightedVessels: action.payload })\n    }\n\n    case HIGHLIGHT_CLICKED_VESSEL: {\n      return { ...state, highlightedClickedVessel: action.payload }\n    }\n\n    case CLEAR_HIGHLIGHT_CLICKED_VESSEL: {\n      return { ...state, highlightedClickedVessel: null }\n    }\n\n    default:\n      return state\n  }\n}\n","import uniq from 'lodash/uniq'\nimport {\n  SET_CURRENTLY_VISIBLE_TILES,\n  SET_CURRENTLY_LOADED_TILES,\n  SET_CURRENTLY_SWAPPED_TILE_UIDS,\n  MARK_TILES_UIDS_AS_LOADED,\n  RELEASE_MARKED_TILES_UIDS,\n} from './heatmapTiles.actions'\n\nconst initialState = {\n  currentVisibleTiles: [],\n  currentLoadedTiles: [],\n  currentToLoadTileUids: [],\n  currentToReleaseTileUids: [],\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case SET_CURRENTLY_VISIBLE_TILES: {\n      const currentVisibleTiles = [].concat(action.payload)\n      return { ...state, currentVisibleTiles }\n    }\n\n    case SET_CURRENTLY_LOADED_TILES: {\n      const currentLoadedTiles = [].concat(action.payload)\n      return { ...state, currentLoadedTiles }\n    }\n\n    case SET_CURRENTLY_SWAPPED_TILE_UIDS: {\n      const currentToLoadTileUids = uniq(\n        state.currentToLoadTileUids.concat(action.payload.tilesToLoadUids)\n      )\n      const currentToReleaseTileUids = uniq(\n        state.currentToReleaseTileUids.concat(action.payload.tilesToReleaseUids)\n      )\n      // clean to load tiles of tiles that needs to be released\n      const newToLoadTilesUids = currentToLoadTileUids.filter(\n        (tileUid) => currentToReleaseTileUids.indexOf(tileUid) === -1\n      )\n      return { ...state, currentToLoadTileUids: newToLoadTilesUids, currentToReleaseTileUids }\n    }\n\n    case MARK_TILES_UIDS_AS_LOADED: {\n      const currentToLoadTileUids = state.currentToLoadTileUids\n      const tileUidsMarkedAsLoaded = action.payload\n      const newCurrentToLoadTileUids = currentToLoadTileUids.filter(\n        (tileUid) => tileUidsMarkedAsLoaded.indexOf(tileUid) === -1\n      )\n      return { ...state, currentToLoadTileUids: newCurrentToLoadTileUids }\n    }\n\n    case RELEASE_MARKED_TILES_UIDS: {\n      return { ...state, currentToReleaseTileUids: [] }\n    }\n\n    default:\n      return state\n  }\n}\n","// TODO MAP MODULE remove whole reducer\nimport { SET_MAP_CURSOR } from './interaction.actions'\n\nconst initialState = {\n  cursor: 'progress',\n}\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case SET_MAP_CURSOR: {\n      return { ...state, cursor: action.payload }\n    }\n    default:\n      return state\n  }\n}\n","import { combineReducers } from 'redux'\n\nimport ModuleReducer from '../module/module.reducer'\nimport TracksReducer from '../tracks/tracks.reducer'\nimport HeatmapReducer from '../heatmap/heatmap.reducer'\nimport HeatmapTilesReducer from '../heatmap/heatmapTiles.reducer'\nimport ViewportReducer from '../glmap/viewport.reducer'\nimport StyleReducer from '../glmap/style.reducer'\nimport InteractionReducer from '../glmap/interaction.reducer'\n\nconst mapReducer = combineReducers({\n  module: ModuleReducer,\n  tracks: TracksReducer,\n  heatmap: HeatmapReducer,\n  heatmapTiles: HeatmapTilesReducer,\n  style: StyleReducer,\n  viewport: ViewportReducer,\n  interaction: InteractionReducer,\n})\n\nexport default mapReducer\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { combineReducers } from 'redux'\nimport { Provider } from 'react-redux'\nimport throttle from 'lodash/throttle'\nimport { trackTypes } from './proptypes/tracks'\nimport { heatmapLayerTypes, basemapLayerTypes, staticLayerTypes } from './proptypes/layers'\nimport { viewportTypes, popupTypes } from './proptypes/shared'\n\nimport Map from './glmap/Map.container'\nimport {\n  initModule,\n  setTemporalExtent,\n  setHighlightTemporalExtent,\n  setCursor,\n} from './module/module.actions'\nimport { updateViewport, transitionToZoom } from './glmap/viewport.actions'\nimport { initStyle, commitStyleUpdates, applyTemporalExtent } from './glmap/style.actions'\nimport { updateTracks } from './tracks/tracks.actions'\nimport { updateHeatmapLayers, updateLayerLoadTemporalExtents } from './heatmap/heatmap.actions'\n\nimport store from './store'\nimport mapReducers from './store/reducers'\n\nconst mapReducer = combineReducers({\n  map: mapReducers,\n})\n\nstore.replaceReducer(mapReducer)\n\nconst throttleApplyTemporalExtent = throttle((temporalExtent) => {\n  store.dispatch(applyTemporalExtent(temporalExtent))\n  store.dispatch(setTemporalExtent(temporalExtent))\n}, 16)\n\nconst updateViewportFromIncomingProps = (incomingViewport) => {\n  store.dispatch(\n    updateViewport({\n      latitude: incomingViewport.center[0],\n      longitude: incomingViewport.center[1],\n      zoom: incomingViewport.zoom,\n    })\n  )\n}\n\nclass MapModule extends React.Component {\n  state = {\n    initialized: false,\n    error: null,\n    errorInfo: null,\n  }\n\n  componentDidCatch(error, errorInfo) {\n    console.log(error, errorInfo)\n    this.setState({\n      error: error,\n      errorInfo: errorInfo,\n    })\n  }\n\n  componentDidMount() {\n    // First trigger synchronous actions that should happen before any map render\n    // At the end of this, set a flag to allow map rendering\n\n    if (this.props.viewport !== undefined) {\n      updateViewportFromIncomingProps(this.props.viewport)\n    }\n\n    // TODO\n    if (this.props.glyphsPath !== null) {\n      store.dispatch(\n        initStyle({\n          glyphsPath: this.props.glyphsPath,\n          // TODO apply URL updates here\n        })\n      )\n    }\n\n    if (this.props.onAttributionsChange !== undefined) {\n      this.props.onAttributionsChange(store.getState().map.style.attributions)\n    }\n\n    if (store && store.getState().map.module.token === undefined) {\n      store.dispatch(\n        initModule({\n          token: this.props.token,\n          autoClusterZoom: this.props.autoClusterZoom,\n          isCluster: this.props.isCluster,\n          onViewportChange: this.props.onViewportChange,\n          onHover: this.props.onHover,\n          onClick: this.props.onClick,\n          onLoad: this.props.onLoad,\n          onLoadStart: this.props.onLoadStart,\n          onLoadComplete: this.props.onLoadComplete,\n          onClosePopup: this.props.onClosePopup,\n          onAttributionsChange: this.props.onAttributionsChange,\n        })\n      )\n    }\n\n    if (this.props.highlightTemporalExtent !== null && this.props.highlightTemporalExtent.length) {\n      store.dispatch(setHighlightTemporalExtent(this.props.highlightTemporalExtent))\n    }\n\n    if (\n      (this.props.basemapLayers !== null && this.props.basemapLayers.length) ||\n      (this.props.staticLayers !== null && this.props.staticLayers.length)\n    ) {\n      store.dispatch(\n        commitStyleUpdates(this.props.staticLayers || [], this.props.basemapLayers || [])\n      )\n    }\n\n    if (this.props.tracks !== null) {\n      store.dispatch(updateTracks(this.props.tracks))\n    }\n\n    // Now trigger async actions\n\n    if (this.props.temporalExtent !== null && this.props.temporalExtent.length) {\n      throttleApplyTemporalExtent(this.props.temporalExtent)\n    }\n\n    // eslint-disable-next-line react/no-did-mount-set-state\n    this.setState({\n      initialized: true,\n    })\n\n    // heatmap layers\n    if (this.props.heatmapLayers !== null) {\n      store.dispatch(updateHeatmapLayers(this.props.heatmapLayers, this.props.loadTemporalExtent))\n    }\n  }\n\n  componentDidUpdate(prevProps) {\n    // tracks\n    if (this.props.tracks !== prevProps.tracks) {\n      store.dispatch(updateTracks(this.props.tracks))\n    }\n\n    // heatmap layers\n    if (this.props.heatmapLayers !== prevProps.heatmapLayers) {\n      store.dispatch(updateHeatmapLayers(this.props.heatmapLayers, this.props.loadTemporalExtent))\n    }\n\n    // basemap / static layers\n    if (\n      (this.props.basemapLayers !== null && this.props.basemapLayers.length) ||\n      (this.props.staticLayers !== null && this.props.staticLayers.length)\n    ) {\n      if (\n        this.props.basemapLayers !== prevProps.basemapLayers ||\n        this.props.staticLayers !== prevProps.staticLayers\n      ) {\n        store.dispatch(\n          commitStyleUpdates(this.props.staticLayers || [], this.props.basemapLayers || [])\n        )\n      }\n    }\n\n    // loadTemporalExtent\n    if (this.props.loadTemporalExtent !== null && this.props.loadTemporalExtent.length) {\n      if (\n        prevProps.loadTemporalExtent === null ||\n        !prevProps.loadTemporalExtent.length ||\n        this.props.loadTemporalExtent[0].getTime() !== prevProps.loadTemporalExtent[0].getTime() ||\n        this.props.loadTemporalExtent[1].getTime() !== prevProps.loadTemporalExtent[1].getTime()\n      ) {\n        store.dispatch(updateLayerLoadTemporalExtents(this.props.loadTemporalExtent))\n      }\n    }\n    // temporalExtent\n    if (this.props.temporalExtent !== null && this.props.temporalExtent.length) {\n      if (\n        prevProps.temporalExtent === null ||\n        !prevProps.temporalExtent.length ||\n        this.props.temporalExtent[0].getTime() !== prevProps.temporalExtent[0].getTime() ||\n        this.props.temporalExtent[1].getTime() !== prevProps.temporalExtent[1].getTime()\n      ) {\n        throttleApplyTemporalExtent(this.props.temporalExtent)\n      }\n    }\n\n    // highlightTemporalExtent\n    if (this.props.highlightTemporalExtent !== null && this.props.highlightTemporalExtent.length) {\n      if (\n        prevProps.highlightTemporalExtent === null ||\n        !prevProps.highlightTemporalExtent.length ||\n        this.props.highlightTemporalExtent[0].getTime() !==\n          prevProps.highlightTemporalExtent[0].getTime() ||\n        this.props.highlightTemporalExtent[1].getTime() !==\n          prevProps.highlightTemporalExtent[1].getTime()\n      ) {\n        store.dispatch(setHighlightTemporalExtent(this.props.highlightTemporalExtent))\n      }\n    } else {\n      if (this.props.highlightTemporalExtent !== prevProps.highlightTemporalExtent) {\n        store.dispatch(setHighlightTemporalExtent(this.props.highlightTemporalExtent))\n      }\n    }\n\n    // viewport - since viewport will be updated internally to the module,\n    // we have to compare incoming props to existing viewport in store, ie:\n    // update viewport from incoming props ONLY if zoom or center is different\n    // from the internally stored one\n    // TODO FFS incoming lat lon should be an object, not an array\n    const currentViewport = store.getState().map.viewport.viewport\n    // stop propagating updates from outside when zooming in\n    if (\n      this.props.viewport !== undefined &&\n      store.getState().map.viewport.currentTransition === null\n    ) {\n      if (\n        currentViewport.latitude !== this.props.viewport.center[0] ||\n        currentViewport.longitude !== this.props.viewport.center[1] ||\n        currentViewport.zoom !== this.props.viewport.zoom\n      ) {\n        // if zoom delta is precisely === 1, zoom with a transition\n        if (Math.abs(currentViewport.zoom - this.props.viewport.zoom) === 1) {\n          store.dispatch(transitionToZoom(this.props.viewport))\n        } else {\n          updateViewportFromIncomingProps(this.props.viewport)\n        }\n      }\n    }\n\n    if (this.props.cursor !== prevProps.cursor) {\n      store.dispatch(setCursor(this.props.cursor))\n    }\n  }\n  render() {\n    if (this.state.error !== null) {\n      console.log(this.state.error)\n      return (\n        <div>\n          <h2>Map component crashed!</h2>\n          <p className=\"red\">{this.state.error && this.state.error.toString()}</p>\n          <div>Component Stack Error Details:</div>\n          <p className=\"red\">{this.state.errorInfo.componentStack}</p>\n        </div>\n      )\n    }\n    // won't render anything before actions in componentDidMount have been triggered\n    return this.state.initialized !== true ? null : (\n      <Provider store={store}>\n        <Map {...this.props} />\n      </Provider>\n    )\n  }\n}\n\nMapModule.propTypes = {\n  token: PropTypes.string,\n  viewport: PropTypes.shape(viewportTypes).isRequired,\n  autoClusterZoom: PropTypes.bool,\n  isCluster: PropTypes.func,\n  tracks: PropTypes.arrayOf(PropTypes.exact(trackTypes)),\n  heatmapLayers: PropTypes.arrayOf(PropTypes.shape(heatmapLayerTypes)),\n  temporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  highlightTemporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  loadTemporalExtent: PropTypes.arrayOf(PropTypes.instanceOf(Date)),\n  basemapLayers: PropTypes.arrayOf(PropTypes.shape(basemapLayerTypes)),\n  staticLayers: PropTypes.arrayOf(PropTypes.shape(staticLayerTypes)),\n  cursor: PropTypes.string,\n  // customLayers\n  hoverPopup: PropTypes.shape(popupTypes),\n  clickPopup: PropTypes.shape(popupTypes),\n  glyphsPath: PropTypes.string,\n  onViewportChange: PropTypes.func,\n  onLoad: PropTypes.func,\n  onLoadStart: PropTypes.func,\n  onLoadComplete: PropTypes.func,\n  onClick: PropTypes.func,\n  onHover: PropTypes.func,\n  onAttributionsChange: PropTypes.func,\n  onClosePopup: PropTypes.func,\n}\n\nMapModule.defaultProps = {\n  token: null,\n  glyphsPath: null,\n  autoClusterZoom: true,\n  isCluster: (event) => event.isCluster === true,\n  highlightTemporalExtent: null,\n  tracks: null,\n  hoverPopup: null,\n  clickPopup: null,\n  heatmapLayers: null,\n  temporalExtent: null,\n  loadTemporalExtent: null,\n  basemapLayers: null,\n  staticLayers: null,\n  cursor: null,\n  onViewportChange: () => {},\n  onLoad: () => {},\n  onLoadStart: () => {},\n  onLoadComplete: () => {},\n  onClick: () => {},\n  onHover: () => {},\n  onAttributionsChange: () => {},\n  onClosePopup: () => {},\n}\n\nexport default MapModule\n","import GL_STYLE from '../glmap/gl-styles/style.json'\n\nconst AVAILABLE_BASEMAPS = GL_STYLE.metadata['gfw:basemap-layers']\n\nexport default AVAILABLE_BASEMAPS\n","\nimport React from 'react'\nimport { mdx } from '@mdx-js/react'\n\n/* @jsx mdx */\nimport { Playground, Props } from 'docz'\nimport Map from './index.js'\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n    <h1 {...{\n      \"id\": \"map\"\n    }}>{`Map`}</h1>\n    <h2 {...{\n      \"id\": \"description\"\n    }}>{`Description`}</h2>\n    <p>{`This component displays and load fishing activity and fishing-related layers on a map, used in various GFW projects:`}</p>\n    <ul>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://github.com/GlobalFishingWatch/map-client/blob/9c5179358d4870c0fd4c2c0742917e72e6025c59/app/src/map/components/MapWrapper.jsx#L5\"\n        }}>{`Map client`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://github.com/GlobalFishingWatch/vessel-profiles/blob/aa0e17395f6a4947bb3fdf3106cb9d0a744ba64f/src/profile/components/MapWrapper.js#L3\"\n        }}>{`Vessel profiles`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://github.com/GlobalFishingWatch/data-portal/blob/96b1e24efcff58ade672a67229da0610d9d241ab/src/map/MapWrapper.jsx#L2\"\n        }}>{`Data portal`}</a></li>\n    </ul>\n    <h2 {...{\n      \"id\": \"available-properties\"\n    }}>{`Available properties`}</h2>\n    <p>{`TODO: fix crash on Props docz component`}</p>\n    <h2 {...{\n      \"id\": \"basic-usage\"\n    }}>{`Basic usage`}</h2>\n    <Playground __position={0} __code={'<Map viewport={{ center: [0.026, 123.61], zoom: 5 }} />'} __scope={{\n      props: this ? this.props : props,\n      Playground,\n      Props,\n      Map\n    }} __codesandbox={`N4IgZglgNgpgziAXKCA7AJjAHgOgBYAuAtlEqAMYD2qBMNSIAPOhAG4AEE6AvADogAnSpQL8AfIwD0LVmJABfADQg0mXACsEyEFRp0CDSQCojvVO3YAVPBDjsAwpUwBlAIYYARpSzs8rux4wdOyuAK4ElESuBBDkrlBQAJ7sAOZ0MALRMOjsoXBoKWYWAAZUmHDu6F5YGcU47ACSYOyJlKEA5AIw7OShAhBtdniUAO7sBH4Evq4ADjPp6IotbT3uRT14MOQA1uxtU20C7OiU5EMZMIi-BAQzcIiSkikQE6EeOFREkmXwldXfTl-nm8GTM6yay1C7Gw836dHI3XcyTgBAEoRSKVgdhGLzw4xsdgqwKwSxmsH83UytkR5lscFCMHW1FSuLe9UQAEozEZJGYIEQZpQBFMAEowVzkKZgIREdidcWS9oAbj5AqFooVBAAIgB5ACy7GlkTlXQlBAAtCciMrVYLhQ5IoLUPpDTK5ThJNhXALYDbUGYxWbdXqcF0MBkABTrZhsMTrCyMPAAZjEjjVzponDVwuy7BxEx6gKJVRBAkQUmTcfMFnYjBmYgjDSmUWSztzrnQLBi1Hi7BmQju40oqRgUxe7DDmH6qBSeZgCQ5Unr8draadLskVYT0ljijMJ16RH0ODSBAAorAjzQAEKJBroCOdYQEdpc1AcpUKZRen0wHCaMgdGoWh6EQFRsymYB2AABSgVxEhSIRQgwJZoIHOx5FdY12gPAAvP1-TtKY9VmLDZXaD04AEchJCiGZJFUbB_zgAiIPYQNJTIk1NXaMFUF0FFjlOXDnAIRIsXYbh2GAdYogEZ5UCudoAAZ2CTGYsHaPdqxmDsWBnJSABYNPYAA2DStPWMBgIAMW9aBEiU_hnEOBEHUwGChH4JYiGoSg4F0hFLOrayaGcCBcMudgAEZDO0-Q-IEqYAEE5kk9gIyg8gbCgdAw3YeQOUksQMujGR2BRcSYG4YA8NEqq4HkLca2AbLoDy4IADJOvGRJ5koZo2ty_LuFGuUwGQyUBlQdp2AAfg2dqwwjIqriGjrUAS6spBkKs3zMGF1WOGAwDCKAphW4rSu21Ll2rBMOIIHAbMyFIrwIZqa1rEiZnYVgIBgEYiJqrL9AyK4AG1lJwZSACZTKWaLYaTHBTOigBdJZcOEIgrgAVgKzDNxXKRHue173uaqRbr2swvxAKiaLohjww0LQKGA_QGEO-0oMwU7QnOgquIo2jZl450sCI6TDReSxKGvNoMDgJYCFceTRx-gA1eA4HnYWjXIyiIi6CWecgkcCEsTIdkV5D0BVy3rYlbZLH5GA7eVg23VF8JoDgJ5R2d22lYds2paOvmTrOqZ_HYZKteShoABlkuvZOzwAfWvZLnDPPVkug5xvewj0PApOiWLppQGeosX6Lo5jAN0ECDDAwijsekXTUVW0jrQygZksPr4BF_tB_NMT5ir1AO95wsiA8NAYDFdBQgRAQMO77JQk0vv54H_6pxL8ie4tLo1732e2ImIQblgEWoCcfw8EkW-RAIX194t1EXeH6eT7ukkOPGYU94BvxttsGec8LabGiHRZO8EMj_3gEscuesEFIIECgx2KJoixEQYkZBI8t6GyASAsBAc4JEM3hLGBMt_qAyIjg0kg9QhDxIYA0WFCSGSDgH4C-Etv7sB-iLD0mJmY_Q-MBVwy8BB0LYjJasaAXh6icILGA2kLB6ytjAbM8QzxYFbloiqo4AASEAUh4CgJYwglg9F2gMUY_QJidH2D6HAIU8UxG0XUbAXxa9YA4DNNNaBijcgzHQFkLWAMgbqlVpkVA-RuyoHlgALRxlw8RUBmaMLicKYJU1qBhOllBFRBB6qwCWJ8IgLxKkwAAKqRKyI7WYZJEj2P0VAQxrcslPBybMPhYkgkhOKQo0pESom0GDlAvpv8dgB3mVAwpKSSmR0mVkMx4piCzEIRkR27CpkwD2QIZOlAOydMcd05xNBSE-w9HAnZ9FHmN1GUkoR19pYoiFN0Mhotvmm2EXRVe699k-IBTASQF9QW0MSsU5sswQUb3Sp8JezokX7MyrJWYVxgU7w3irMwhU-IQtDDAMkEoV74sjHiteG99r8XhfiO-n8YC3SSJcoUTjelSXfvfGAEYIy0C6T0_QRVuAlSUdok2f4WABWiNlCMbSOUOK5dc1uQrVWZHVWKt80qfk4DlbpAgiqdGcu1aKmgmqRU3IIByN8SgYqmQZUlDZtAYlMPVC9SIDRGW1JnAPQcUkIxoE-AUD1-S7VXSlRVGVhrbDGsVSuQ50TYlESxfdGscEYgEFCJgK4obIjhrTeqD4YMBBQ0xiuCwT8ZwvDzVFQt_qUgRqImWvQFaMYmK-tjSIBa_XFs9QU3tRBu0FT1ewB1iU4JwDsD9NRgTujYBAg7dimocBrmoC6GNeDaDpRjRYcpEB4gRWyFcU6UA9ZjoyEIMs7BUCCygNegQt7fXWSuA-hIJitrrE-OuGgWouD2AVXgCMN6vHQhfUKN9lAioHsLEkygQSn4pDA1BgQSxwMCBgxOiwExbA4B0aJLIGavoWCw1cLDY7yPoZg5R2jqBrJjuJdWH91Y_1boA1wNRyECCXXg48dgNkICbymKiSxaQjhwESPxPAQhUCDBCEUpJ-JogVWGILHIfg5jBECNZLoIRUDJDohOOgU4VyCeSmJzY0IMB7GaPh3Bo4QiGjgrOCIIQEijHYCZycGQCh8S-hAZoQqCQ4BAXAHAeTpYAEIxr2xOsvdAcHq1upgK2r1MpfVhoDehULBGItRZLcKXDBVAs1kE5YHUuoVzBYyo58L6ETxJBmHgOA0Foh4ji1JT9UAUuZv1V0eN8qTWgdS4e2eFThkCvg2R1ILW2sdYmFcBrhXMR9UW516jZHKvVZ1CEOYSR2ANJFMnNL5wujjfHal0rbGgshdW016gVnxMeD9sU-wfgZzdG67kcMkBnTJekqlx7g9IvPZuP0N7qzPvuDSBGUlp5iO0BWjgRulURmQ4gND0Jt3yuHpCxC9g3VY0GqR2rFHHI0ezDR34v8ERtjBFGlJBLAPsj9bm6So1IGowDZrOUhdGjSNzZrAzugK2wuFbF6gbbX0wgRHsFAPItABAZL7fiArTX5eUEV8rjIavR1XcPXAXXKJwYa8i4V2wpuVey5rNQDLwpYffYl5rsHOAHfFYIM7tIduLDUDMZQVg5vQd3A96gQPweMNG72KgRXsRtiu8t09uPNidh-9j2cjsSfGvu-oFnxYMf8_nPQMR4UOfCvF47GXggGeq_oDXLAWgFeU8F8b6OTRRfU_-RgNBNhMwW95-73rPvMx2F19QC9qH72kk-6iqH8Hk-sc44-1933V2WNzbx_6TNdX8vJ_dzYKxNirG6Jtb037vXic9QX_gWxJ-7Fau5ceWAM4Jgc7I1zhNPOdEWOP7Ys_K5S1PjW_I_axAA81Z_Gge1FcO7fnELVLffXPMPdBPRXZLBOwS_R9a_C3ZAyLVAzBGhSLV_FId_dgAAH3IMQNv13QIQwPYCwISBwJoIpzoKIJwBIPfxXA_y-i_xGyTT5wsBqTqWmyaSOTgCQMK1oPIBOTsEoPYAhkxlwMKwIPQKIIoPIIUPRlKwsG31qwe0lyayWUwLGl6x4JrD4MTVAxTWmUgQkNv2MJgMzTgIsEEwADlvNxMMQMgQhpN-IlNVl8dOADC3cw9hUgDbUGDTDsCScHCn8dUaAOC6BSC8BzC8M5MP5YB2UOl4jgDJCjDcjbU9DM1BN4AbEaBLRbBXAPBYBzRJYLRyjKRNRJAFNKj0BzRfJeNzQdFuiKdGRM0GsiM-jhcgtJtj0bFIp0AVs0RO9nCGUvpBMXlSJqF9l9D6tDDD9tlCCwVGC-tgc-dLCecbCYAtl4E1DMVQCtjzjN5VYNiw8n4LlCjW4nCvotoLA4COMMxtQuAxCSN-wYBWBA04BzDBNjC1j8j3djCoipJ_jASjC7C0jSchtudRsIxjiZl7C7jItHDiiFjJBfArjfoVjN5wTLiziZhZDoS-wug4TNjyTZDETDjUTjjTinlZCISw8liKSMDbjQjiCS9ICEi7VcSKt8TVDfp8TpD2BiS4BwTqCsScBxTKTdjmCFSlSMCki39UiND5S-TCNWCZD6CVTYiFTpDZDNSUjStES98rtb91T1DftYSgTFSK5ri5CqDBDlCmszSjSxonTvSDTZCbt9iRckTZVv9USY9hCpsqpfjaBMS9SfT1D5DFDeSD8UDXTuTkzNDFCdCaw8y3iawXD2BBMHj0BBTgDSSFSyyKzIjjSb9qyBSniX9kiyDZtgjrpQz_T3cazmzMxmd71sDKCrsYtuz7imzz8WytSdTPTb9ezJyaBK0Twg53ZLpHSaTnT5yIjW4lzTw3YjxLphzZzGzHiFyCAIYMZlyrZVyip1yATNyJztz9ALz0Yrz9yBU8zETBtwz-DrDmlaATkC9azW4Ez0z-TTynzoCCzYCLN8Twi1VKzd8QiwKcB4KLU6zoimCTS9S0KoCnpODtT2ybTPSxzsS-ypgByr8jzQzRyNyCizyLSCxqKRc4izzdyVyDzby_S6LITyL2LrzOKZzQzWLILzzLy9ybyqTSLUK-LxKOKPzgz2z0iWUsjDscizyOSyKzzoLnCgjFj78IDyKqy9SwCH9ACEKMKesYiGyTKDLT9gKpzLSQyyNiKuyeLOS7LH8zzJJMKoAhKRdaL7ymtTLDKGKCL_K5tQDPLzL0KdzlJXyJLBLusY9pKQr7K-L4q3zJLmLIqFS0qvLRKXysqkrRoUr3LIt8qYq8KirEqFK-cvywzhsrCEdzFoqHKrUor_90rtKdLXjoRL1ugiLkK8C78uqCqLKL9uKgrD82ryKGqmTTVWqxqqqhTNLRrwDurRKXiyNCz3i9L8TosjpzQKpQ1uhDr7QcQmDAg0scg0AVdUB4gjsPMJhuhfJF0x1BMRhug_Bg8hwF5dIDMm0ChqSwc_rsBbAYgZw_ovdOBzAIUlgAZEBYK0toah0pQ3QgaoaIt2AdQ3Dk4ABNDskdPYI4BEDtTgOwFgMAMAC4GgZGshF62G-6x65EGVHILdZGqrXUITGyYuTG2cbNaU5kfhNoXKdga69wPYDwdQLYWve9EQQzEIF9eCFcV1XoF9fQR3Cixq8nEjKnRuc6p6Q25G75X6EBVwFIfBKG44uwMhfYfIDyEYTYcwEdYGtAOUvnW_Q2qk1nJLa_VLRHUcZHD86nGYIrNGj4PoMMK2RJZJaaHyqyhIbg5y-7TskXdW6OrWjg_BXNDyX7L2r3dtFXStCKsjDOzWwu2tZ4XOn7MaAuiOsm4ujGUur6cumgLO4m_OhUw2nAEdRSq7QTOrYmzAc6VwCm6krYakI7Ac6KLGTJfMPEMe3-JJF4aaK7PfEiCYYJDwCQtuggDuzJY6-uyNXunGcVMaaKBq78pqnnZeuO6gdJHGNaw27aubTCecPWFOkXY4rW71IgbLItXLMHZ-r3PMvavnXasrHfVOta9WzxI4O82ksPOBoURkuNFExa73DxIUWB7BgQV-qB8BiwPzAQfjYyyLXdP8LDKkswr-oQ4pJDP8FDJAyhnALDPMroXNAQcwXnUMmMWQGPRMWGMQURT4l0cgTIfhbIGLCsYRwR36cgGdOANw70aqfgC-cQYAQYvoth9DVUgjVhrDVCygUSacVDDkeQJcT6EXfh1MR0TjKYYjHYdgM8PRrUUcWRS9csHcARz0hMBRpRlRo8PgQQbITR7RrIXR19RjSgaRdMfQJx7YSx4Baxr6HaWMG7GCko_EkYagdoKYEhwzRIfDKGvTH5AI0JWG_6hxwDdAHjTMH67oQIYILwyTMJzNThvocwCJ2gHAI9E9SYqk1EBkeaQcpgq4XhsjRgQ-LgHwiFGqCFJqK7RgURYAHAdZhfImVJ2sSQGZqcaxidLaNjedOnZAnBfddYaXK4QNHBfUsxkxQ265gcW5_hWYAVQ2nBKnWwMUAAR1CBE2yBMW1xt31xxiecHlua8CQxMWtyVzNzvRuZIRwAmn4hMWMPBY4WnmCWVsSB1DAAjERaxa9ElCFUgU-Y5BMS5NkIxdufVkyFxfxcJfgEI20wFSpawXJbRfIppaRbpfgjxYJeeaRbQDwX4hgAFa1CyHtUpdmrPJ5axb5YZcFYheFaSTVjFYlalYpfWC3Imv0HleZcVYFaZcixFfVYRE1doGlfWHtP2QNciyNcZaFaxdefmAjFtewRIWterCTLtc8hVYVZxeNedeZddYFV9c9enm9aELwftbuYKBMUE16G-SICDOrGGCj1H3YTjbDYjEFDH0xfgG1fYzT22CzYH39cLYodZbzf70-ZMXW1a3a06xzfExnBMU9zRrnzjZRfIA7dQALx7cmn7YLxryHdRaZAHZL3b2b0rdud7f7fjx2HHb7cncj3NxNeReHcnan2xxnxNzXyik3YXcncVx73LZXfij4hOcXUNWjkFgICBIuerCubGafXWEbc22WzfaBfCB1zhZVwN2mIZBhZNwA_NzA2D2gKugBOPFhb1yOAHOGdmIsEqvaoIA_UfTRbsMw6_XWAzYyAvZ_d_VLaI960pcJOpeI5fe5eo5rUfL1ZoFw_ferA9fuDo9jXwUNKIOY5MRQbvXI8na1u7YynFUlSUEncHdE-jQk-rHrzHek4lWklk_9ynY7BnaikuiU-ABU9jyXcT0U_E_7fXbvS06M53eX33ZE7M-U8XafhH37wmbE9s6JT4nNmOgFiFhvY0WrmUEZnriGR-RZjUCbm0Bbi5nbnCQ4yvR6FNFoFEh-SWGVUSD1C4HQFgBGHVm6Ewj-WhSvnoVeFQF2Fy53iwEnjwGQm2A-XoSgksBFGSjcOcAaEsAaFxszi1BO2Sha9xqyWyVyULuhQ3nGXWUgCtgVlDjsDjlG_lk9gdmSmUwSXcHvtQDPDsxy_uT68GR7reRnjMCb2qb1lW6-wJRRXsb1j5AQJ0iEARFnTYdQFYBwDcOqyzjPDcK1gTrlEwGDyfhmHelmm6nWDzeu91ju4e4LmgkzhFDPA64AA1If84dRLAs4tQzxrwGkABxD7_JmY2aHKkGm7yLOgB7qH5KewSwTOQuCH8H-H2H-HvURH5H1HjHrH5D18MwD_NWs7mAAAdVxHcdYHliQzsCki6D-YBcfC6F8loHNDy8tABIiCF9fDicFD1l54mH58F8vV_S56O_cBO6kmi55754BM14kPgweqPCUlETeo0WCi-lNHOndmA5Q5rGGBRAt6inaCfjiCgDd5fDHSIiuAAA5lJQ-x0ogsBko0grgkxlIx1KG3AxjIpTPKHnPMp2B1n9SsgfIcUZZM_WG6IlguSlInvye84RQGhkpk4Gg0lofZpMJCpv0p0d9XUicDe4uYAEuuhBVnOdOlg--DuYBdexXN4lU1LUvOwMusvQtKv7UGV3PXU1YNYCBtZdZ9Zg0uBe_te1XxhIF0pA6ps9bQ7UK7DDVohXBkXVBBUo0lOnouAPuuBjHTGCgVoJ0FrQNpvxv7Y4B5uUlSWXZlyX_ZWE4XWCdNuGu_AATECPCNFZuspTaAdAjj2hXUn_WAelHdYTct-PrdBhGUVQoCJuv_aaOgO_7bUzU7sfYD32jTI02wmAHIHHEZp31V6zIMzOPQUxTBAgwNH3rAHZrmBIAomWWGN1QGtNQQSFDKAf2Dqo4DahdPes7BXopIaGj6NBgagwagYGBKSVbg-AIaFlHUdXBrk1265uF2unXfQewAADUMUZvggOlj8wY4YZXzrXCZiDI_Yl6QODHRdiwDQuHMPQKBHAjSwCAHgaoCLAAACXDMAJIH8HeAPkC_JlHuTJbuxUBwaNIJQE0DUBMB9DHflAO6BSQoIeCcvI0EYzlJEgmGDAFcFUiFk98iQ5IeYBJwVDPEqAZFtsj6BFsv6NQ6gPUOiCNDIs-mM8BKFAwRgaa7QroKkLLpMo_AcAd8sLyuz9CuGf4EBBkBiCjwAenpKYY0OQJzCAYkWKgEKH0hZBA0awhYZ1EmENChssw4UOsOkRbC0AOwgcHsOxLuw7Aiw0MssOOHXDThzLTYQIG2G0Bdhrw24UeGIKtk8QJUZSKlj3yjDxhDVJ4TMJeHzCNhwgD4ZcK-HQizhGQzoUKG6GKoIwRyDIUMNDJ74sR7sWsOMHdhZ8SsdDFisSJyHa18RR4GPO_QGodlMRWQDIewBKgZC7uQOJSmRjZHMCpI1I_oqGSIYi5N8O1WAoc1AGjgumChNkZSNVjEizM6MVzjviiE78YhbgibmgJaHvhKB7GJlF4G_7pQ_B1QCMJqInRgDzA8Gf1Iggw7i0JuEMJMFWkzSWiDINo7_pWnD6uAsAVoq4HqOVgvl3Rno50T6IdgQxYYDo8BltHpj-dmY4pAOIxDZjNxOY3g-hOj2TiZxnAlgfGhnDESbd6ImIXog1CGRVRmIeTOFDvwThJxU46cLODnDzjg9i4UkFMWmIzEZw0cHjKZK4AhjtAUgYAEYIgHFLmgZS7QBUUqMQFTBrBD7eOInBThpwM42cXOPnELjOA7BUYwZDwmngQIXYkWACGF0TFtwfB_cENrbR9ggJJ4JCSIaOIQyCQlk5zLIesC4CtszGfTOAL83-YXwTEfQKAA-ITbrB2xcbSgNLVlp8ckMQoL8e20uYjw_xzoAVp2M1FaQ5Q8wNzP5Dgm-1Ac2hExMSXQ7sdN2jrZVlW2xb0tg2AbZlg-kXgZBo2_A2ATqDU5TE52SLKFixwjE1wVx9ENceAhlIeCgIXgvcfQhNZjwBwp46eOeOliup2WNCG8c5XvG0SXWbbFIE-JfEAtC8L7aAPAFHD3hQJKQVxG8DATqSHmtgbHLADjb0TKWDIONiRMCDR45OgUF4I5CknETQgpEiyRYEgDnQ_W2EoNvixXCbtc27ZRYiMyDw3pZmdgYkr4BGZ1YdEqWCrke0PE4AzJGQbbIJmckq4tY8QBkHYFsAuYWAymdWMkDQB5gbA2UaED0PYCM4cpk3WWC5MyA1FfkAMXKPFPxKVA_oKU0eOlMlqKt7MnmPyir3yBVTGpSuUeBGB1AihypKuPMoPSiiJSMgyUvqexyyhZAUgQoGyRDDxhLBTI6MQhmRgmkCAppqUv8QBMlDMYJ0xbVDuKCnA5sa28GMzIKDupYTop_4mWvtNVpC9bwQTKKURPBx7Ta8K4XCkKRulvT8J_LJ1n9JwmbtYp-DI6aLnIpwBk4usQycIBY7vEvmz4mAGLzfF3iO0ISYPLDOhaKjLBR0V1B63EkxpJJXkmSbpO6kGTbJ-BOGVexHHCSmUEbQmXeJokkzHx3zZGa-MBbrBds3NcHiImqwNIsxDQOwBMDUzUD2wdmMKcOCdqJB1g_0cma9LwlGT1gesWAJKDPSUzFS1M5WfOFlrZAbIRw-AGdLeYjFZY84ZmdFJRD3MVwrAJqb9LwnAyLZMk8GY33w7RV1Zm7JWem0sRmU9ZBsu2S83OkrhIAZsnSdbNtlxsHZf0y2QUGdngzB4EoayaZPsnmSgJT8BFo7Ktk-thgIwRBIEC8YazPZE2FXBjIVmQstZIUaACrn9m8t3JuE2lrXJZkxzwZ1uZXOrg9nlztEWkiCRrK3TQSUJgLOULBKWCdB_AKuIceDI_Ghzqwv4nuR9IbafjZ590z6fANQCRi64zMViQHFeYXwOJ4XJMWxF4l_ITxlCISXjKZT5t2EjMnUVxNMmAh0JOdBtEnIclyT2ZCk9CdQGrqPyNZoMl-SjM5krzcZSAplB804S3jqwI6J-SnN_TloI5Dc6KaDOLaMS_O68wZBIkGRSIW4siZ0AIF3m7iGANXBDM6E4jrdsIZ8GXqV2G7zwJG2yTvjrMlBCguEXQFWbLUoUWxDYAAKWLgkLyI_IIgOEGqJfxPk6yHQfYAADSzgTOKnHxpngRQmcBoAYJsgihca5PHUDZEzjo8lFDSaCL1wBD5CUgrCmWIo3Pb94dFNvfxGYr_A7dmIBiqCKqIWT1I7kpcD0MYQ3ELJCMdCk2FuLWTzw6IvqYucpj6R3UMgbyFZKEmsXCJsho4WAUsB0Ra1Fusg6aOoL6TbdlMXigxaIj-QegfoHyV1LrRiDccwUwaVPldAL404Mcf4CNnANyXmJKO9BIpX0Wc6lKw6XJfALUqIJmBqlBAPxRkAepQB3Em8BhfUqlYlKdGjcIJTbBSSR0BlAgDpdEM1h05-l8DNAcUqU5NLact7fjqWMEijDWS2xTeCig77OAPFODdYBDFPC7K3SYYjKKJP2Q4jTMXDcwDqA-k4ASpEhG5ZvCpzhUgR6wLaG-E6XdKJlbAY5FgnvDC9YuNCo5arJNiTMzlQdQMhgSuXuERAUUTYAZi-q-F6QR4VTFMGCkNAtQdgceEfFzAL0fMdOHzCBnxDdAUx0pegiLKmAi1NMXMsUt0HGUlySa8tOWgDF6gzBYgLNSleVL8rBS6sY9OCHnJpU0Jx6_xPWHTWrAI54VRBO5WaM475LzSg3AVEqnIB9txVZE7UXNj3wxZiSfTdGVNF-ryEDVWCIrPLKKhKqJQ5AVLIJm56IhL0w4agX9WyhbBdgzoM3DkBlJM1glJq6yXlOCDJsIgsoTENqv2VZcQaRK9ACCJCyGrw1v2fuRyKuwJqoA2ddgl0J6GCpMQJyBGqzDuVzZSyGpcKjPXHp5BcwHmOgPSDRXO0-wWXTMEKrsByRGctAtKcapiC_V0VjTIcDHkWKuBfqamckIJC3R-rAVv1ekDUSwS3Fg1mwHYLmHFB4hR1qgNgFwFCAs0Y8rlAUTWgtWYgM1-yRiniDLV49QyxoqACclbFqx2xPtf7H7WqHnqLVR4K9efxgk9jEArKk1TACHEfdkOYDfMmSLmy5KH1NCe8OlFzUWr7-8hOMSyPYCqQFoxQAACTABDVXAeQOaCQ1xj5AxQdgFcBQ2xq_GNYW1eFjyCgZwNIG5LLSI3wFl-qn9TkURrHz8IIweG3qmRhtWarYCSwXMj8vZ5bKpgp4H6A4uWUNKRlkTdHNNlDr1JZlKozWLMHqQHKIVxy0hqcv42ybpsjsOxVAgcVXKIwdEBxYtx2AOK7l-qpZIZvuWSjdNamoImrSjr6ATk6PJCEGnJUzAHFqWYxpwpWiub2Jm0wVHsSU7pqn1HYc_jev5hJY8yodHzc5381tiX17QOiNUEQCIQ2gMwceY9PSGQJZCvqNQCihs00A7NDm4gqPMy3YABWIi8RZIuSjSLZF8izOIouUWZxVF6izRdBCKhmDooQRfbgDniACa1N6UCzQ1FbEaxfUEYTsZ4j6A3chx-m7YA4sIyuQi2K4fbn1qxCUkpIi25lqeEfCDjSsJmtTfus3jIs0R2a__jsDzWcBC1TmhxctvO1qbzSIrOYUdu2AZbWYpgzgEsA4XOB7tJyTQaVk61QButDUdKD9r-1Yh3FfGL3hgTgmraoZGBUrEqsB2qaGo3G98LxstiLLBl4KrIJCtlonLqwsKrpR2l6Wo6MMlsQXLAEJ3abxlBOvBj5AWV4MjNIWCxYTvkELgyRSqhnXgyyb28JR4AinfEEJ2I6_lTKCzVkHlhPshlVrK6MLkebKq_wkgiOobRMQR8gO0u4_j3UV04wFdaAJXWstV2a71dknEvFcDWUWLw8BePjrGxR14M5VUrNFpQEZyKRldjcY3dLgV3w6KZKm5zdNit1WtKW_gC5VmT9Y7K2lmKVPjCw7VAqTkoKq4KeABUlyI9DsL3TAEQUupBdswQDL-RF3oQ0BygtPjulHBa0Jm8usdW8mDp3LlBLVfel7gjCF6P1KSEvYc1cRRKJuEzIMcCV1U1gy9OiWAUQOAH17sUMwGPcpgmZgIlg2aEfR_Ne1-zqk4HInZiHR5B1ZtpenAaBl8Vh7qAQqEeCPuiBj722hoSfT0Gn1LBZ98-sbYnt70vtY6jAlbsUMM5f0y9qgxJRgFf4_K7Oxigtk5zb0WAy9RihzgWyf2sZ4o8_C8eOKFi6AiFfGPvcHQz1g4XdMwNPVYSgN3B2eEYH6G-DXkOCG4dOAJBolCXFJcFXE7mBeNdTyLmumcenh1yzFSR2gxB8nmQYFlnhw4dMnfnnHJ5I89Q0EQaVX0zhngYeSPNwpYHSjtBmDmcVg-wfq6pjuDvBywAwbPlMGzw5PMxA0HR5mJq-Shlg_nFEOcGJDr3fg5QaEMKGlDKhsxGobYMcHxDPB7Q9IaAVMHLAyUEUOT2Tg6hkoKPIaboZsN2HJFjh5w5YamCup7A-oaCBnCR4eGnDMigQ34bYOBGs4DhkIyKG8OXjHGch0g_zNnH2ATszgQaQIaEO0GUjaRwaafKsOCQBcZK4NBFjT7Z629Ze-DNpMaBuESD2Rs8AH3ghlkrgEWJvjjMliMHBIlIgvD4WDTKCYlfRMfR2AyD3ghhi_O4WrAFDpRnQYwSVpTmKp1U0hgkNINgqyDoAej2GHIFJDLIjGcgSa29YDlGaIbkNJeXY_IEzhIaURkxmYFhpw1Ei_h1xn8UvpNnVH0xth-w54ZkWNHxIBukcKsdoDrHTjmxto8okJyjKacxu-TkvymD7GQtgOcwkbtOZQn1YfGMUdWCVU7HNj7R5UYJD_RN5jkQJtAZidGMS7-jlsEvRUeeNVHu54RgI3IaiOfGRQ3x5o0LWGPAmflE6Vvn0TA1wq9a2_QSJibBWInb2gpu8SFgNVAn_h05EnMKewP14NOwWxLPCa_qymgk8px0PiY82sZsThBplJ20jRz40BNe6aBSaU6Yil9h-3k-Lu078n6V3JqSHksWPxHVgCQcuM4ykiqm_w-poiHPnKx75OBbp3YAOWTXmEzRiOpY1MG9oenwTYdY2tAxdNQBAzJs409QGDpjoIFqNE-j3RHRjpG65uCGD3R7rZp60mAJYIWcrofySzMAK5RYBb1XAe6Le3M-4ANy-p6zUg5szjF9RNnUABuHUOEDbMN0OzkQPs8vK-idE9YVos5M6NV2DBgVBAKcxpI5M6nOj9KoOORTQHfTgCOe8CfMCuBCGRDphrg-Yb4MmJdIPx7POMHIoAG3Oupnfr_llaiU0BaHOahLpjSvHEj-h5Q4oaMPCH1Dh5rQyefWBnmWTz5s8tedpkyHcT9nXvCYuDRlGLT5J4TTaevldH7TiFvk6CdEExn1lcp4fDBYLaKm2cKazNJ6fDxnsf97CLU-GJvMrnTEWDaZWgP47bmX23crI8kazipGRQ6Rpk0BaaO_H-O4FtAwFzQX0QUlqyPA63HwXhJRu0SvsBABqCXp5Y3PIUGLW4VyhDaHRDIHEBNjmhx4S8mxWlj91uwsQf9LWjoq5KSAuSxlw1qkoMven1QhptSxRA9AWKsDIyWyxEocDJwGk6YmRZnHsDV8xFmcNJDqH1ByK3C9gKHnqG0M6LdAkAfRSWXxJc19svM-ozRcgsJHye14HUA0jcJah6xcoIQ9ldyv5W4jrqIQ1rAaBnhueohnQ4VcSOVXqrtVsq0yi0VaguuWcRqzVcGl1X2gbVjq5nC6vNXAFPhplEIZCthX5FkV_ODFd0OJGJreocK9Neit8GWrshmgzlbzjlaPjbhTHnNY2s-WojXXDw7tbWuCQdBjXZrq1wMGvctQAhi63oOutcG8rZ1zK5nDcJdcGgWsTq1Ve6t2HMjiRj6y12-uDXfrw1iCwUdXMEB4hGUFvcxbwysXEjxVvK84FPN8WLzjZolIAdouxKYawaavavtQCmmSo5p38kMMqNfTEb5PIaz1eZO_H5dS56ec8ZZKElrLcAUy5Xu2pl77LTuQ9iGkJt17lzGVtLGZfxte44yie0k0vvJtUnKbu547NBHatBGabdhumxecNoS2QTn-5m_-ROKs3lJ7NmUFrT_2uF8SHhKYGLLbUJn-VAZl2HmFxD8qKgWKm2dNKZXHBnjPN73HzacJsZF-F-lJPLCNP8RJeLiGlTmgbTTGsOQtOtDXUjtfp2AxNROr5pJvlHkL2t38i8apvBXQri1qa1Fe0Nq2aJRFYO3ohcSpZizNdbbFXSrPbYczHGxm-neaos3ySbNjm2jRNvu2M7ntufH_rYw4mxM_t6aI_WNBi20a8Fsm5SYzv36H6lACMOR0zNto8zFaeKmWakHlo_RC90tCOh9vpXIbEAhJdQCSVwWpbE9tO53earUn5bD1q6211uta3z7RxXW0ZYNtt3I0Hd7m6gGE7e2LBHR4WyOj8WUAdYs6ecPYHLREmH5pZ6O5_MgeJ23249qwjLanuD2Z7EYAKz5aR6yKArDQIKwtaWv52TzYdmu1A6Ifb2f7_d_gTN3VHBo4bJ9qwpacP7WnJUtp6XTyYYdOnXUrAX6FJBksTcTZdZhQhDBb1o40AycHfUI8tHRAlCgjibtTgDEaSXRysWR1aPRg1n7b6Ab9trsLo90cQ6jvAGOk2AAFDd2F8sxHQMen5GjnYAoPjDj4N2H7qJae6klnvz3OH2dcO5A5cfV3K7f0MOqQ6Ft73zYKjTteljxsZQHqQTrWvA5AxjGmUEQCkidEfY-ApIUMJYPFWYdeAbgkQEUAAWgiJOFCYToFVnR0cTAlg-T4PFnTMeEBhxbtv9OEG6CwAwAscOzP0FPz2YwAOiYWcOEwC9gSV7gDIf0BYCS06QDIZh7E-hkNPlLAgMWjCXksf0lLKlh8KM_ic5OSn-CMp4XR5UKWGkqAPS7LWmib1-gWATk7qI_iZOACEzqZ3JYUtjDKA5zh8Ok9DVZPT8yz-9Ks-CcR0Nn84LZzs-Uz7P5LRznfvU4IC3PnAPvXMLykHhjOgX8zkuviVKdvOT6cAUF8w-aeEBgXoLrYzaIydEBHnqL6F_FRLIvPwnhdRF_EH6Ju3s0kgWtIWG4Zgp9MPmFRJiH_H8jnTCmYUHgEdWCQesrzrOshG-cgEIXSzw58w9G0TBuhnLwlwU8Lq8uhAS89AVi5xcJP_ngkFvc-y-isvv26r9l_ADEqqORXeAQ3fsDwBiudXY6L6iiA_TqgtXKIN0SuHFDmuKohr41za-1PxmKbAxLO0Da-s_WmrtNlcMBd-PtlAXaL0l4pLmwouoXkz0vOi-2yY3nCIJpBfYOEsDJ6I5SnA0kgksRd9x88N7Vwl4X8KqpBi3QFHnRrYRAhjL8uFAEgD8ICgmXUbPXHNBFu5hBi5CBAB-aPxn4_CSQC25-YGK-UrKdt1Ek7d9vBFBCzYFgHlgigUgHgHRU4IDh0QG3wE2FEIvnhvGWu9gcrZVokX2B3jOoZ61qHYPyLLASwVd9g43cyKt3O74QynDPASLbrB7vg7FeoDxWDLqR9MWFakXnu0xDSa8BmOgg3ulgjYh69BFsMxWnL6zXRaKwIDeKpgjY9MZmLPA-I8x5SreeJsqEGWdEJyepO4085Qe-kqbtVTgs0AGKVNaAOfZEBQTZiu3MQZwSR9QBkeiAKCfI6NZ37UHSDhcJsfB4EOsfqecHjOK9fYBZH2PvHhD_tbY8Q9hP_HguCKFEX-XL3H7rixTwkXyK3jEVyvkjzuuUGpPMn7d3Yd3fyeJFuccKyp_sBqe6-I1500IZPfrv9PANsvjYbXdnuuL_Hoq_OOp42fRPNYhcRD3085L6Zo4bDzHB1j0LsEBtxizloqSzalgXQMACcgaSTOhh_p8Ly5BP2oUR4VJdoMHmC-vgv6Sqvesl-ojMvCy4xiSAbyS-zbUKBt5FydFi-TOwV0Xmr35WDMHHcwC0RQncYhj1esEcXqAFU5QsW3AYbNySF9NC-wmlTuYWIgbcPUwa4Nf2Vt8Nsz6deaE3Xx2Jn2o_wBtCdxxbxkGW_iiHlX9TPnl8i_DesQH6Abwbe_R-PmPhRybHJuDS2KFszbAsIVFfM7moo3HoT82IaO8XzzRdlcJ-0e96Pn9WN5HToiB2ZCsLVUeG9yqiiCfxPn3tGz96MdVRwLUmro3Cqqjocs9CFx06rCvMHZ2k8sawCpTBeGh4gesaJ3ebQuOmJBZS6bDq2czlL9-MZyTX156BJfpsTPosREHc1Ku-NwGwpWz41phRxNMpcrPt0pHpRN6eAUMKHGtSFVMqtVS6PiWiih9lIE6fbjyJESdYZf9sOX4xx1cLGlfMUVX_MUStWA_z9XEUPjSi96J_JYdnwkfXiIRqCVlAa6eplFpaYB1iIe49q-9AzA0y49WAJbXIAyzqwpZSgM8HICGgGFQfiUMkHhBKwq5Ea7FbHiOw9qx6-Td2EVqvgRnOOwobP6d3u5zCryeLNpx3nLLuwrMaESevkDX2bnbU_Fd8h3ddRmYC_BvagMW5L_U0dE2Qd8lX66DkA9Jdf2SglXkp_6rIDCpjc5ggDpRlISoTgISLI0HqCK8_iACYJMHmEgNJyMDfz83gQwIAw4mBkv5wUBbr1TXuE7mHkLH_L1gWtWK-t7HfTv1-dGYoiRbhoBhnuleMwTjTpfQx-BPygET6ZEYLnXQzEOBNf6n-MWt2IP-8RIgDDu2QE_4gBDIEVAnqGUMlyE-GRPyhbGY0Beif096heoQBd_l2Jvq30rAEYBrKOgDfqSHC_7J07ZG_4PozLuAzI0dWE2qXmXSElzDSPhHwqCQ8QJlyJAAQN0BSqzmMyCM0qbpUJS0S8sjSBAcQBWqFSBUsFJxA5gOn7u21NLTRiYBIsHJi0HmNdSbS7TK3RMoe9MJgVSnPkEjR6qAMNpg6RBHBIQAw8ptLjybmu9qlYiXkL4EAhgSrgfctDO2TvwYwDMYuM6GI-CbSPmMrji0AgUwpCBcNKh61C0fkcDfSEakpCH6u_n0wUan_pzQW-thtb6mYvkL9TZoDvqwFXIzvn2Cu-tyO76aY0wIOo--eCAKAB-6UrH4h-yNChixAUQdKQwAwfvH6MovGGCjBSdKqn7JASgZn5Hg2fhLB6BO_LYDQyLQTv74B0WmrBgBCQQQEdiRAdAFdIwmGbKUBY0H0EwAAwarThergRkAvkIYmtJSQIwc0Fx-ozJSIF-RjiiabBzgdsEVooYnsHpQhwWMELQrfk9qUYGACuCM-0ZkWI6IQ2p2KDiCNDYGVyGQBNpkQ7mgYGAhYMuGZ2OmDGD5yqkPj_auoaAeRSABmAQaJkBsAIKhkmOPrkH6-QwkMQY-5FKTZ0O6FrQC4-YFrvxIBRKEsCGQofNjbC2iId5TBo9fs8S0OIGPQ7E2zlHiGwA6HISGshxIZojYhsVGKjrA9IaJTIh5ATyGjYbIYMYCheFPCFMoyXCciGIUqrX4qY9Ssj6mYMXtOqC-0dOjy7-8QRHoFqbevtwzGt3rGhVQzDnl4c-nwUEjc-Dgcw6YgFHqV7OBuoRepgIzDsAYxkJXtqEJM4mrMH3-iAMh5DizDrMHZazoTMGTBrgOsBKgI2h4rwBw8pVTwBr5FmoYi5Sigh3KgmKeCmIUKr7IDCo8AwoJh6APrK5hcAkMGCQkInV7VeWCBDDHGqYSPDyARYdMJwAxQIf41grqFt4CApoeWE4E5YfqRVQozD2HlKZylAAoIa0lcA6cqWtsr-ADYR0IA6fskzp-UJOF2GjeRFt2F-yUWLbJTe3ypmgIhalPUjywyUAkDThTCulDthEMLWHzAvXqWFji97OdCmhHoQ4pnh02COFDhI4RoTKcE4TipYIt3ogQhhJOH6HzBAYWprfqf4RGH-hgYejCPhGPiPAbe8hOOHbh8oQkAdYd1N8Iwi-6BnzrM94dNhLAmfMST1I2EeszthcmsWR74TykvIvKMAHwFKoiEVgqPsSIkWyHqiJBmHDg78OiB4gCoIvSHYvKj1LhqukHdQg0sIGJCpYpEbLTkRlEY9RIRNAChHrCVOMmG9CmIBJG0Rg8HMKJAZ2rn7MKasugDbS4PuJE0RUkfABDhCkShGJAEEak6ekyAo9SBmWkelA6RyEXRFwABkbpHQixkS-RXYrqLxE0AOoKcjwQ-wOlCdisQNQDdEp6HBLtA_kagDmg_IBbRfqr5KGhK45QGeqGRTkX-oWAC0BYH7AgwQKJKQ7kS-CpqzmPJE0RwmL0paR69JdzbqowkeGjwA5DgHdADwgKLJce4ZQAHhUAOVEmEvKKAE1RoZHVFPhDUYeFzhv2FVFXYV9Gb6M-oQVMBO0wQApi76xYRwFHA6UpgCKMWXLQJ2YzoLiA-ELUmpSNRUZHqbNOlwrv6mhsHp967anQlfxMakWokEfce9C6EQaSQZuohYQoJYg7RmHhz7LhoWgBo7Y-JHS4jRVwCcAcqpmFlH22BYB6FmhD8GNHmAwUnHBj0IasaBRAuUlQBpy_EcpEx43_pMzbqMbGGETBz6lMHtRKMRdHhhGMXMFQBiANDFx4i7glFKRwoIkArBDplACkxAkaH4oxk6K9FzYeUXdQFR8QFZFJ2iMcLAf0g1JzEWAzMTQCsxUAOzEk090b0qPRVUBDBZRnkYQj7AEEfzGKRtMS2HbqkDG_Q0aPMQRqm2FuPbZME2mPMDmAIMfLRAxS6FgAQ0VTIzR3RCkL2Bwml-hlBcqkMbKAykSUaKRmxBIKsCf0OiPNgKRgsVZEeYV-A1JfUXvH5TqAQQXADbAEAL9DJcAWBrFm-SIFmG6y6AJZZuyOQIz50ujmBGqcx8sd7FNScdlACUanpHSKf0e-J1EY-3UU1FzhVASMzyExcVyGlxzUR9xVRg0ZnE7RwsdXEwA-4T1FTRFcd0ALQ6kQCZWR56BZEuwRUfnFqxjMU0GfhNCI4Bpyk7h4DP8UNJQbpRuIiFjth0iHDH1kGoReqwxDCs9HKmnIleERqU8UKAzx6UGO4TuU7hGArxW8fgycxxJIfECAM8XPGzgUkMca3xi7jPGhgSgEhqvx08VO4ngn8chpYId8e_EeAWGnnHbqTcYVHZxSTpzGxaIGHbwoxMEqOBwSPYRoHoAqjo8JrhLtqlIZ4CNv1DNAvcdkBWRv2O0DRyM4IvEoxPcbGGaRTUrzF3GBCdQl9SZKBSgIgj4AhpQ8NkPJ7-WOoA4ayKIoOjzXgcEt_FHxU7o_Hgy26mAgDQpPq6ZDx2ccQmkJ-irQkLQF6ImYyJfUrQkDx0iTsBaRTCXBAsJ7QGwlngHCRVp-WfhjwmQ8_CYImAJb8SIlOyGeErEiiX_i5QhYECWzGyJ8WM145A96l7HNxbiUnaDRJoVaH3ogMPUgg6Q2pzG_B4OvqEgqrMKSA0R0sd5HhA8QTTHKR6CSLguJQsTQkEaf6irHXYn_gjK7ekogEnmhACoyjpCEfpiDAqNCDEjdS0AIGpqhVSBvFahx_tn4U-gkHLLY4tSWJAnhlYTQiWq-kpkKIB3cepZ6SBbncbtACmM6DpRSqqm7fBZgREmWBUSSBoxJcoNQhpRw8u0lLwNiGJDAhGyZ0kqR7Rq6jHEKYtv71J_Ic0mLAjSTQitJPhuz59h1ofTiUAPPhaG3JsAJdqWhRYqL7VgxocEmBJ5SuVhb-0SVlpOh0dPUjmkAOOgDZ-EWldDpq9_AOTnJvPvNgnJ3ocL5VQYKcdHJ20pGdFwpu_qMblYgmLslbJdMUEkjApoREAYgryVgjVJHSYSlz2PyeqHthiySMYFqfpsvE9JGQE-LXgmZD-ov-OXlzrmARSbACI6VXpqE0IOoFZJdJIvGyk4K8coP4Sp7iRf45AC0NFCbeUqR7jipoftU6LukgDKnWSysvmAFSZ6q6Ejwm_hSDjQ0AFADtAY4algCp4PjalXYoSXMkWB-yHBLNJyye0BZRwUc5JQA5oDqnbJShO2FipCcmJB_qDqeYF_BiKYCnYAw8h6kAhCQD6nhAjRAu5pywIZfGLuIabMlhpkSRGlLJagNGk0RnqealJpQoMCGAe9XI1zAeUPHwZ5kHgKaDbAHOq2GmpXvMvCWpZIpzxwxkqSKnspV8W-GGpFqn9F4BfaTRG_By8EWnyI2hNal0pD8D1iTpDAWRihp8yc6mMp2GG6kxpKySOm-pFMf6lSpgabKn7JnpPOlOptCEunZ-eaXdTBRiaVfHAhV8dWm1p9aUISNp0mIvBIYLaUNQZQ4ARGHTB6Mbf74xb6iMHVE84JTHkhktpyJuRDavOYgqcAFSk9SfAARo2pV5D8GHpLEMelupqyeEDBRBKdZLjyWPBsmCKoZK6iiqH9FBl7JQ3gRoA0tmhBlQZD8CTgrxItDnL_pl6NykjMKUThlfqYyRMlfqV2DanTGM6aGkx4C6UenZpTKbmkrJCSf7zDJNSYSkTaMeARmXoRGYSkDRxURlA0Z2crnIf0QzDyl7x4tLen5xqWDklcZ06SSniaGafxlIZgmcunCZ7qfmnDytAEYg-p6qSmnbp6qab4wMqaWvHypY3sRahk-mcSkhJxmYhkupOKSulWZcoDZkWgl6VumdpOCtem6ZqWDWnigdaXknOxZ4FBwTxYKA1L2x-QSSpXSmYIkKyglCKrSNpg_tRC-gVqXzjeZdqful-Z4aa6kWZq6e0BFZijDAB2ZQaZuk2-kWTunWS6aapKOp1WYFm1ZwWfVkiYjWb0RCAjOM1m7pDme1lOZQREjGuZ28e5lEWDVG2lCgySeTEkZ4Cbv6fpj6h-kDpvSf-EExRMXfGrZfqZzELQ76XjH-hh2STGORZMSdnRxSkA1m1El6Zxkzp3GYZlfB3WcjEi4JmQFkGh_WWenVI12bZG3ZxkRnhzZMyp6QsaX0HFmuACWa8QFZn9CPLwsL6ROnvZU6T5lGZn2Vdg_ZyGf9k0AwUZIwq442ZhmpJxDI5ktZmTHzgw5cOUWQrgHoaVlzY1OfWlwE3mQqFYISoUwoqhEhDaltZJ2sf6452AKb5KqFWb7byhnYO4gpsxyVgjLKXcvMCb65GksAfiSwO2KROkoXyHXJLDg6ZWmTpuL6_J2Fqm6razyc4GmhqbraFambtnpAOuJ-h2TjgJwPAAzQUwODSCQRCKICYWEYO8lBIo2gV72RxJPeD7BC2S9HwYrfLNpoR1RpOpgI60kjHh5aXgOSvuVWItb6eX7j-740f7s4CAClQoyTleZ_scDn8sBKPF740efMAfccee-7GJCns4Dfuv7je6hgo8jqrtkXuQiAVeXoRDAfi9idojlea3uFCRQ6ULDB4wpkHelGxxgRUqfZI2rNqmZvuWgmvaMoO5oN5p-kKlu5HuUwwak4KTmq7-znNf6wpY0BPnn0LOB4mb-0QsOEx5FULLkDJUkCXkJ5ZeRIoV5yeannp5kQWdkyapHjADkeI8IyJqwq0MfkeAbofBEqim2dw7T572kRQ0SE-dtiz5uGiCqhuXIt3IOhG-uXaiZY4bpxfQWUQgUHSH4RGpt-AdCfnF56DqXmbuSeVXlp5hOcIKhkC0IPTNARBUTpj4scGOBPakiTOgFMteUcDBS2AAiCgINKnnIlhAoovmHRU3uaAx4yqXwUEa3BZ8n0xl_BVJQpfmmdHEJMmSxBOxFgGShR4esFRYoxl_BgCQpJ0dCmpeReQORI5Y8n-prQLyUvnsE4VMdRtaJFnrkfZoOuGmpu62v5lU4AUGngCovucslx8ZmdtRwEHejJoe6VULCGwAO9i3xMoxxBM5QIgUDABS56hMGi5MAgCEWUo4RbcoshauY6Ya5lDKw7iC6vgz565omrT5FihufGZRFMRQiBxFe2rJGCo-RfKiFFycJ9of6zpmUgXJ4aphBSQZRaEVFFaBT9r5ebkB6b-eN4fvRY6IXliBnqM2ifpLATRbEWVFFqh-KlYHwUbEHps-aZlcAShG9p9CO0e0Vz5jiS34mxKIAUBx6QpnT584V5Btrg6YWmblhadEBIUlQMKUkH7xMpPuGdgO_jwXeaTGlqFxiZ2vhkQF6UHhpvh0GkCJHGGGugBoaGGqzC3GBaPhphufKQwRO5kNCkDbFRqoowNoEhNvmii82hgQ3F6APtoCA6Ir0IYSDUZ2D5qagGdqCYduXAAO5IQLcVj09IJAA-AuUozS8CgkDrLvQAQOECcAo0eamNB1JUhhPwOIFDRbonBV9D7cWJclCdgoGtsYcs2JaiWQamhF8WwaPxcACoa6GjKWAl2GsCWpYrqB6GXREqp0XgZNCFh7dF8JSKUCl10XzgAp6pa9GZ8qpXqHr0wBXqWClkBZzizawJdtjFkmsR7Gz5A4tLnHUHoR05W5BXpwAglTiW-npqs-VoWn56lr0XZeIGfTKzaJydJlWl6AKPkn6rpTQiAZyaqMz384BWJKilcZQV4JlQIW3k1gx_pmUIg2ZWOn78kZVggxZjiZrHgp1LgP5TAuEOFGswypUygQlWxXUrTFthZtqNlO_DMZ5aSWuMHbZF2bAkzA8WolrsIQYYaVMo3ZZGm5OzZTOBopGAIggog6hRimciwuYDA9l7CB9zpqxxTf7tinYnFreACWg5pjlb9HmRTFMyaOAHFCydCAbFkJeaQOFsQAKiTlOaVGmwaU-ZEDuax_nPyIlrGKb6eFK_K7rhs02FzbPGIofr4J6x_E7pzUcodJre4KJpQAGhorIP5XCRaJ_R3eXpQiD3gMSrNrAYwoCYwAAimdjPeZ9q6h0QjgHopoRMpJDC1FBrifqYVewKAihIY4RVA_MC8rPk4VEQM4AEVwsPIBrSRXinozAZFfFYnYZ2FJAJ-mACdjYO9jF8QRgnCrjTxsdaGACJAOmrMCCVliNtRq0cFclATJiQOOY_Q3XulBWejnhe66ee7ve6WAOiZSisJ4PH4ZuENkIoYQ6KlU-6WIwlULlglPgQPC1IShRfHwASGMHh3KNNKiRxAuFVpXUAOlYMB6V8Xq5ovUZgd5Wt6Z9nqqspFDBTh5ALIlJDUhavmPECQjDDgCZc3DBGDFAZZMDR0F0uadDKSOQEhqz594FhpOxHldSBkosrk7HC5j6BvhXYSqkwrFiZgQWRHFztBiHn8qkaZieIUAMHgmyc2MSQjlPKjRLtiu2uNVcAGeJVU2lO1F1Wua2lhiI3o_VVlVBIuVWYFrVumYczQV13ohXHotAOxXwVrZY8UKqCRdlBShwymfZuuX0NUZaesniZWJ5hnsp42Gqnh1ZaghdmmUHqpxedU6qfmharzVschaFwVshLVV6wYKuxJ_VxJOvmjgJ1QhXmsR1b3gyg1IP9UQhrPkFURA4NajWQ1ENeD741wSAkDu5YNRgT41kWH9UzAznGHQrVvQpLZKcp-pyak1RBOTX41K4KhQ9V_NodVrGCNdDrVFNaBkV3JfITT5h0BuQBWdluJoYVD59gcoWjE3NQCa81magdoYiWNadVXJ_Na2ExOBtsJUGV9nqe6J5OnlVhXuGcLe55WZlRZUsJMePonyeGijlbQQeKvAl4ZzNeyljVDmlwAKZFZc7FdAzCd0Dhqs-f9GL0xKehXdAXQTIFreBKkIAxq4tMkAnVhmKFXjmTmnYCFwDQK5ETlwSbNpCl7AMcaq1F6vNVoaZrHrzI16AMUBXYZ5Zjl46X2XNgFl8AHBImhGdZPkx4ixZpm4JnvJl4mwjtQKLh1kMOHXCVpOUWR_qzmZ_gWFQSCPQd4CGbMVwSOdUDX1146Z7Wax2UHDjdA_tblKPU-QV0FRqeQG7QXQKxsEoJAyQIKBJA80uYBmCMhX-rCFy-crVyReoWZktJGtUf4JB_tQORT1vScDVjx0qELXnlFdTjk31bqbPnAhddbRWXFKMWXWWFCGb1l_ZL5bFoRhwUQTFcAV6c7U4KwNZzFthUqe8XL56KadErxm-QbwINgxQV6jGZKJFmcxUxUcljFNCL4VnJCQbNWXJZEmAlCiS1Z7V_lMIeUpfa7NbTWCoa1RrUbVf4FtVoY18XMSXezptGT1IEtmCpe6bBPshoImZAySXVejurlt6gmF3ze-VADMDJAkiVKQNS4pM771A1gOlLpSrArkB6wOQCwA1lR2B4BEpoJDZiiMUlS6BO0sQEuqoAR2NQJlS_xGRnJxHPndKy0TxhnaX2MPokaGV-nt9XKqEjTcS2Od1aLhZ2nnm56X5QTWxwgmzDr6pJO-fPKqSN6ES6QYIbpOFrusGKenyZ8NRAjRwAnKRk0VsyHOOgcgl4UI3heKYisVgq1PvrTZFQSKtoy19hWPl4p-JLDFQq-QXNFwQF8FUwjFbkNDg_RuUhbE7R82EbHMO_TWEVkNAvl5rghPmlgiRau6n5Q7x7OCykZQkzUUVSmTlAJj4k-pcLI2Y4ar6oW0WClUxxAn9CIEh5LUscAyY9kFH6aiwdXTk62RyMEXlFUzeyQbN0zR8pombtgXX8QyNWz4ps-QXViW2zySmyXaszeIUrg6NYs29JLcoC1dxOBBdHJwNTRDB4a_ubvkKp6wBOiJeYLSWoAim_q3KpsF9eiWHasNRrVl6ekBLmhqRRejWEYJ-fLnsp1DYapK5Eamfzv5t2N82s-KRVrlsOItb2GCpXyYLXo5TSiz65-i-dLXHF9obv5gq59e0qs-mIDU2hhIKUZmtN8ZhpW4VshPLC-o8teD6KEbTSjT-1BsSC1YCXHGCmX1gqO2F3KweYA3dJkWYkHgkSLSi3zVa0is2eJPUCvEsZjGcBlxqSmaqnXqrrfNTD1w-V_UkJY-XBLzVw8u2LAhixSvEq5UOfAS-tdrR-KEWgeanVdl6ddbkalAXg-xBeJsGzbu5VTci1j5Z4TPW854xZFWekIDZ7kj5obSfqmZzrW-VEA7mgA0FeBDIKKCiLGBP5HAU_mOCz-q_ov7Sth6qv7r---b_lIpx_vZEH-aBfNV9lL9bNpoFCrSHlUxTrTPVoFE-RqK4x36Sm2HGu2eyn7Zv6RQEwRmhPNVWaTKO2FoNmahg2aF2DegUGlLmag3n-HmdaTOJCQRHnEJgZiOUYAYZQPTtNDDJtXqwZgV2KCq0uYSU_REJe2p5gQoAUVfqS6R-DllgGsBDv-s6cWRJsc6rsDMB0uelJ6wAgMHg5AZCCdXDF-UniBHgS3HOBBJlasOC_NSFXujjgNJa7l4kVgHtjsAaPOjxrQaHR2QsBBjVR1HV8ipjwK807dhVwVnFSJXzYKxTuVBarrdMFid-7b2Kq13RCxXHlCbQjiCduFcJ1UkVUTgRsVQnVxUBtZIoJjUAR2Bh0Sq6Up60NSowj9HNMtIGqyF1axi0CjgEtT4YIN2rUjW2d0ZpEzP1-yM502dAJkapqAArK_UlQ5oGYUJVP_qxqqpnrQi1YxX0DFgedy6Tq1utI5LF3XOXnX82RMK-RoWSFM7QORIN9VK9FJdWrdZ2pdvTAxqgY2QvXVYVJ-idXCdZbRKrCi8OeOU0ASHVkzvBgSaQ0nIFDUumJBNXbQ0uuYphlD5dlACl3UdTDPi236zxtx1ZAitZigDdQ3cjXuF5WEw0AVFDf4VCWzMC4rGEabl4oJi-BpFwTIS_O7pAOKsjooQo1XOEgSUsAOTX0OiuOKCf2vRclA4s6mg5pzGY9GB4egs7pZb62sAM93oe0JhsaA5v4ABSEmr3W5aQoxujtwGWGmrJYaa75KgLA973ZD0TcTHs6ZOGWoMIb1cYigIYo9aPaTyiK_Hv1ZBGpWgIb49WcKVr8eUVjqAg2hPZQbk9lPej249yOo27CgowXH4zI8sGR6yVbhGgJt1QoPd30scVUw6Y1HfOVHLKzQXRUR5lBksgupz-Qx5H57QMnDLwj8dl5mmvjUpDlRHdblmjgAgDZKeB0BdL0oI22O8KfChsloTMYAfHZEM5UBXLkB0ovQtX0MFwmE4o1t2esIW9kVHcKQwqSYgUFQ8TYK03JzgaI6FAPvcikVI_mBVF_Qd3Q93uKcIPZGmRAtb73R0wve3w0K5UQW3G5IfcCTMOVbjYABohQbh6J9WQMn3tAmfQUAFp1bmQnDyeoA-wQAfeGekIpXYUk4thfJTOCl-HsVJDAi8ZnS49tsNECmvlTQdORSQ3PQIC898EAVpuOI3VqSr-T2owC99KRBP1qAI7V_St8afelAD9Q_XwGR96wvv6sw9ifhmVmsdv33h9fPRwS79DaJv1qA2_UygV2Edvv3Beq_SP1Vmp_dgDn9O_F9QAEy_Qf3D9OVTAAAED_VgAVNSMXvT-9z7RlCeOEdsdQADUNFP1BdIfA1RQATfd37OYJglJBJgpkG32qx3MQyIgDHkGAPhe_vTBrRQ0A69GwDKQM33OY5oEgMoD8HbTlrFF_Y14KEmA90An1cA2X5y0l_ZgD2JBeUv2_YeXkv0k40Gr9gZV7ZD2EldKffH0GyeZAYEGy8mvn0GyLVFH0ikqMaIO5hgAk-pa95wvCIO9luCRpMafWOCQv9LTkCKIkRfdn3XSyg5r2JAag0b2aDjGguCpYRgykDV9tyKsI_CFgwiKO9AkciJ3CxGoxor9EfXyI_9s9fV2t0WwQbJODMIi4MO9ekb8LMswgz4OH9fg3GKz1lwSClL9nRVH1JDtmvPHEONdPPlOSa4cIMSDuYROhCDWg3YMODUHq5V7eKvXKDlRU8VCrTQHdeWEXeJSb2xyCNZJAj3aH-EqoShV1fI3xVNRT6WK5kzqrAb6FEhNxUSpuhGqYSgOWnLK5QWg0UQCOwNO1U-2ubLXOm0uEz5ZFYdE7q26dAEEQF52Fht1TV6XTfysiWKWNCb8iJGGbJBP-YJD-uHYKq4uUtvbkBDDIOLAXjlMw7YMvAlEtRLMYaBUshmI_gM90GikCGy1j0knbEQgj_rb5R_DkCACNwA-lSziTO27eN49QybevFojqweQl74_w4CN9VZIncOol2ee2KpYBI4AIw2CPd_xv5rgNvhfQlRtD5XAWPaVqxJP3rkmkksI7iNTBZqjiPwj8Xizp8pzXTcM4qQJniobDTPUCbdDcjanykkaXsQmwSjEfiTuM_xNpaVqdhFEFRAQo5H5_U11KPUAmDrlipRIRKfvHrDbnb0yO6pzNLgzZzpuPCeVofed2O9NoxIQstzupMOQyg9RYCE1j1EDwoVzLJTXU1HwDzhgYznIzUc1dABa2uAIwNZbPd61foHkgqAECM8t13e4C5tPPQ90Xx4Y5GN9Vlo0jExdsY890MRY8VcOhkOSbn6ZAEY5AjxjqQE93n87ubmPn8nGlbWsDMHQ2PH9mAB3VzYOEEyLuwbY2RgkJafd2NfQ7QHoOEA_YzWAkJliFEAjjiQ2ZFMo2eYz3zmRwSH6s9lAOz3pGbhGmNljLsFGNptV4u7AwCVDk7CxCR4F3oq5243xrP55I0HCQIx45mNz1UIaV0x41RsT3Y9YihngEjLvQKKzVnMe2I4JI4EAIOwP4xkJ7j3_Bnie9rxH-pf6Gph3gbGTGsKNagbbbkl9U6A4IOjgiqCy1QQcCFOAzS8cOEDDA_QLhD4I1AEpDXg4oF0BHAs0GYLrDDfCGnRVFrU0J9DIXbFVZ8uaHYBiAaVTSHMo3mD4GuMt6IxO7oeQPYhGIjVWCXtVlQqsNgT9qTRNUj_Vbn6ATy8BeOuCOwDD28OJ40IVzKf47U2XjaopSMqT26uE3iJ3ck-NMjnMW-Nv1_OE8Ohk347QmJC0SrQmyTzoDZPRxoE4tU3RGUDw7f84wyXiDReGOrAHda_FAAhoQDUWNUa9qew18NznNw05VAHWFMhpP2kkAUCSnBBMA9BJmyYwTbJnipfliWUczI6kvP5IzIG5pAgkmyva95XANPST109CPiyZVGBU5AWycnbb_Z726JKqPBoMxhiS-RG3maaYh2uRrmwkrUzy1pFx_IcO55YfvVKkldmMcTO-fXbSkbjCyOYQtTp_CUVTTMyC8UxO1U29kzI9rQ123DNJHlMwk20_NPHRJw-MBnDrUS7C4pfOHvg9Te_I-2LZr0WXptDLsItOQI8EwXEsqIWJdMAC3aZfgDeII9em3TstgRqPjitgNZGTpGeja_e0cZJJzTAAp-PRxV8ad7TT2wKvFeItInbh1dVA-JO9dw0_vo3dESH9gVqOQGCRXcJvPNPmtQPMTMuwdOhlAxYUMwshvh1M99ObiqhQ-BCoznHfxYBu0-TM7AiQfahkiZejlPB4MyGTMC8IIxcPM5zfKt2DIFli0pWK24p4KSWu3UdBU0NNGGBuQfyE_CDur8ErO00QUMIjduA7i_Bdus8D266zRs7eD6znbt263gNih-wrkF3bjWoINs97ixjyY4P0PdDbFWNqwDbLbO941CIGbPdDelCqHdH9FZjeImSm93UeAcFZbKS33Z5Ytq1lslBQypxjkBgeH3S3aTe4PZ5bdGQJv91kgUE0D2UerlmD0eWENld4pQWoKj1mIZ4F1zRNlWpj3lzmcJXPVz7HvJ549QM0EaNzlgDXN-WwnkT1tzWcB3NdzsihJ7merqFj3sJMiq9z2AJPde51zqPePOVpU88bX0GI80yifmhhtTY3uecMi0CGa89-YbzzgFvPOA_Hqx4Dzzc5flcetRvIZVznc2fObuZPQjwg2p8955l5AhqVMNz184POtzStv3Mfzt835YHmYhkeaSGEitEYo8qPfIpag2Dje7rZcoE-NPzjnr-YmGgCwBaWAIC58bgLeVlAtHzK8zvxwLv8xDwtcFBrAt9z7803MEL17vfMZw84qQs3z5CybWvzZ4FQtbW8C4Qs3uX8wNagL0PEvMFWfViQucLqPawvYL9U6XPsAu86ob-WgVqIpcL31gfOMLO89-brzEi9g5SLqPTItbz_HgFZVzsimIs_mWDmIrSLm83IuUGmi7YYNzCi3vNKL-i6ouGLycB8jGApgOYBGATsJDKUZ6wRgAPldgMdRrgWXMLLuw5cEcD7APhMui2NDtjEHBLRQYIGZgwgTZjBSGE8QVOLgQgDTegFgMACKsmELqyChmYP0rR0Pvv4t7AtTkcDhL9HQktJLsoNJBpLLo2eR2AgpNeW9IkSwcDdMMS1ggkJBJGyaoB5gG1KSJRS0rR89eqAktKqqSziyYQ9MSLiZaHi-1KM0xJC0thLtqPs1qYDKmLTXULGUUA8gZgC0Px0e5C4sjJsAGMs3cqU-WR4-GEq6POU1ms4HAENeO8UMcmS-eQK-Y_gil70wBEfasmBy2xRyUAlOw5MoK6jdxtTOrByyQyaJRiXX8ePs8XVFi_ORQXLvKBlRP9V4uRRPLTIc-QYwpJLCt2YrE0H3nL0JswTgrGK4wDAp-gI8sYA1pO4s3cXg6BjPFYswUnc6RK_ADtG9iysvPLJyNZbsAx1GWSTcigYSREiQSCst0riS-rDJL0kPInpLbxSMtCqIJSUu8rZS8ACeNkoJhBrejgPb0tIrvQ_CG9rg0eLGg0XtrMh1yktyulLKSwKtDgduiMui4NmBWryIHTnbrar4qyksVL8K7ci7Lo8HY0FSkifQJO-RS6qtlLNq7h4LLOQNdQ7Goq-wA8rmQBKt6rH4nYCGreGMpK2Y6ANlm4ehKrMzerPQSdLxL_qzqvlLQyzKE_SIuKvVOrTS4mXnAbSzMsgUFq4GspL9EjKuQy0MrOj3VoAbyJ5MA9skAeYZZMoHKzLoOHXi0FINwJB9PvrUv6A3KwMv41wy2Gty4_rDaMp-l1H5TXUTCr5XEqdamt6B-Scysu8gjGJNCtDJeAyvKSkzCAWXMyknKvqDLSDbp26XLFUt2rhKNWBQQTo5DKkholFDK6wUDB_hJsf7UwwR-G2quscsykpYkK5HKzAA7rlg5ev6-cAMevYtIWMm3XTqbQMQZE3gYDC-BPE31anYnoBgDRrdgFKtjgdgAY0DqnjAIrdA0S-lLh1o4HmtTgbPC665-CEhbT-Q5Naw7WW5NWiRDD-q3QC_r1y47BVG263CI_rX0pDLHrY6B6vXrs6PfYIhCQCchkbUkB6PE1xG_NLtY9s-n1qtF_a-t2z3o29nDraNbFVTrdyo9T8b4myGMxVpYxmPv5GtZOtDVM2KmpJzcej9XsmnpJpvRzdY7tXfl-SfGYYm0m_aPUgNKyYB0rANBOZ2bTK_Wqbwo8JLRckn639Rj0FKIkCBm5Ch2DJA-mOqM4AXK44vJrlq9JDCR0qxODpj5m1MGd1NmKWO-b3488sLqK0UcAM0NmCJv-Q--gDBRLRwODEiIWsJYC7M14DZBh9wXp-tFrfK4Mv0smELDGFNiQC9L0xHvIhsOYNmLDH2SKmPUsuxlIOGOfrcy_14UdwQbDSwlNAoNuywvSn2C-zdtsSNRbAaw1tIbMq0xvyr8ZIqvdAyqxoNcQ6qyrOarArewBirxa6mtNbE9ICQLbOwECNkYEYIPApI8QEVAwxpqZ4hYqzIt0uZck3FACmg6AMkC-rrJa7FreSXDph2Yz1K7FLbJ2_6sDLcWwQADrg6zWABbQW79vGYGQGkDGNQ0yduLr6y8yAublScgjrrZm1911jhYJejPSqjLKKk6zGyqukgG5NdvbAUY85T7cS2xaHOz7_XwGsOiY7d039qY0TswAW49PJBaDph7OuANYzd0uzt_UsCw7okbvRPSbW6ozbUJEc8qvKUk1N4DkAgyuBKqerZjNEb9OxWN2jsEPBB-z1Yxlstb5O0eCU7X69TsaDtO_eR67N42Tl7eSO5uNDTbGLStRbdo54vPLZUm9iyY7Uj5vh19WxKsVLE-aGthrNiCOrNAuKquhdBrqloF1OSc4Du2Ab8JsDnNlXstsprjW_BCYQB2_CBtxoXtuoR7BwOQUnQGqyNv1YEa9epdAltB8JYgXWxGpFQse0EAEzw4D6vzrGezFuSrH0phAtTkMvLAF4GUA9vTQT2xlKxAF0Ou3YbNmCVJFQTqy6uzLdK18ujwXQV6sTbbSGZjjbM5bOCQ7qy0uv8Qcgp7vo1oKm1karbNiU4Defe_BUl46UCGbOUXQ51NsOVrfTLLDvLaVg79aUxp55-85uKNkmlDAy2bGW4oUGPg5oK-Cv7MTjsPmAJozLoQm5o-AdoF7yjsWbDrSuSRIHbJBgR_DBtreBIpcEbyUQFqIiS0Yim_BrXh1mB1WHzFvkZnzwH-_mglN563lZua1O_OJHibPy44mh7AK6S0QFy0zvzvKpxMfBSQlBxPmvkcSxDkIdO_FBCcbdG3hRcbjsGbvy7WKvMNQQFB0HoCAPBz4Q5JhyUiN8HShyoc4Kl0jn23CWIJaO57YrGzZsHGIkYcIg1lv1WodHqh2SzroHahs_bJ0vH43lssKJg5RagejnEHiQCciotEBUmEHTrMzgD_M7MxqEn7ykkEeb8imRGAxYa3oNH3riGMhhPr9WR3y-bcEuYf57QSMEdOxs62Ar0xwR1cDpH1lhEfmTXImxtUric8MY0SqZHQ3CUGB94dVhAhyStCoyktkmjxmmfEeDVj66hiF9ocJ-tpHpe4dtFHWRy1W3jrqH8wh9Ly1evHrMC15nn7VS_3tX7IG4DinZrS6gdEEvh-RqvkLGZhLHrnMfDOYSCxx2AbHuxn_3DC6QmUeZS8AIccYuWs4duV1ZGOMdwgkx3-vsbD4-Eecbx6z0a-lW-FmNrDykvjWXLHYGuvoh0ZQrkx4hR-8cbbu6_GQZ4zug-MXHHi9ccZ4zdc8PwyKMeIecxnGxWsnrysR7VXYjB96NWDKgv8f2zbo6Lgkn3o-puCoUEL6tx6UXolvE7UwURUC94ie8cInN3F8fX7Rs_cfbbMlEevlHXx9Ij8Q0QHr70bx69cdOx2R-EfZ5eO8CcConMXzv-zyDXLsvSP4xCc2hUJyxvRxa3qCMx4ZJ7SP_T9MYDPfzNC9TysLP4yZMonO6uRq4ahmxAU_j4a1UicxTkxjNFjDDRjOeS9s0TX-TBJw6NU4kk2dqJTuc4D0pTxJnBN5kZenHPKSCc18feVza8YeTef1bEdXQOp1kesNLrm7tObHu97PubujZNwBK6UnogvAuowbFj0PgbOvpSjxwDB4dboLpCoAs8FyVHArtFDSM0dEHSt5n2sYKpX7S9BGt0uq9XvRHYnrT5siFDi1DsrbEq2tuhHgxxGtj06R75uYKKiFDRYAiQLhCFgWwqys5AwRwuvmeOO-YB2jcZ2Ed-Ft-2CUSj11Yw5jdPja8Py2Y84YkTzEVtPMZw22CZPqnLvNZv7xLGX7qXadTcfwtK8B2gUfnSh_-uroUkNLsq7AF_STQ6YhSrj3HAU85zgXax_shUHWx9svBlyHNwR7DIWPBd7KQF1s1tkqWGXoH7WF26RH7ChC-faENI1AyZno504tdAw6hkejwx1B2dvI49EWc3A068ECS0m-75vpS_M7mBkIdZw2ezgDCs2fuYNmG2cd7Z21nuJAmEMEe-LD8NF65AXAJ6W0XdrvyI775DipcUgg3sGiyXUPtUZQ8TCz_NkL3CxVO_Gslyj7CLzpscRfH2lzfrC4xpxwvoLJl8D474oJM05tMOQKWfJ-LUp2C5gDCh7EeYyy7vsBKZZI1Gt2QoO13b5x53t6nnvQyyfOxYa3vQRqSXEwRznge4KNTnee7ZffnjcC0ovnPJXePGi3sxITHHmxhFmHnRbGiZ92t5twGdgn59LnBoxJEMbPH1y6rnZQGuUctVLF7eylCHfJ1eveNF9nLZRQWPfAvyeQTe2Q4R06var4k_THvUhANwEVIOrS6t1sh1c-yBRd94y1GqetJKrNf5LKuIhRzY2x-yfG9my1UuuLx6zyfPL6HHbidX_V_VSm9jNpNOGqEXYMnmEd0yXhhXL9hFdYItLaLMZnu9iIu8X9V8aWwXsjYg6DX7rvLZvzo12XnjXIIgtW6cLGFRd0r1l1ghAUkMu5sGxgS9EEEi3SwvXfY0h2h1pSzQL5AGYra841ajCe5Ud0r5jf9TqwwNObEFLXa4khpAAdfyoernmCjuZbHa-xGstQe1atprGS3hQOA4Xvj7mgOjsbG9ITq6F5N7422WSYYUsJzm6BTi-DEdLOLBMu5MOefGTbnll7udpYgFFcuSH-y-hydDJ5_fvshQeU_tZAqRcMSgHXB4BcbDpozTi_ngF2gWL71zvqUkHxpXBErgoFxRFvKgFzJGkzUV_RPOm7yifGAXpV37kOd6a8ARgq7ykgdTgfV3-sx3SGJpEoXOx-UcR3EF70lHX_J5ccFXufjMauLmdwXfkbWy_LIXXBmxBT6-duJxuU5Md-7f6lJPrcd57l18XcZ3x1zici4adyXdd3Dd5tM0FBd2KCZBLd8FjxnltZ6S93nd_nceLduB3fyypdx4sD3DE03e-XqJeFRQa5RyPf-SG96N2cigmJbk-BAO-7d_Uw55h3NAyqFxHHbIuHpMsUBkyQsw3lWogsaGZhsAvBGYC-FaQLU86jYpUYM--Ohkm69HEL3_SUvc3cP4-7c73uHSBOoz8bUjFr3NAvmOci7tyiVe3OwQIf3B5R83ffH6M_3X7UTsKF47XWd0rNrtuB2rx4A4p6KXpQft5REoPopWg_8NMDKHvkPlD_qVIP-F88ZXYB-8w-4grDziUO6zt4SSENFV47B0Pnt_UdXJlOYEOUXfEO7tQ7YoA8p2AsJfCyIbRwMHjAODGdepkIPZ7AB4VDIFr383Xe0vKYQKRUfQ2YV99pbx0lDIY96ra3no8ZAyQGY8sq7NJferHJmMSS9rYJUY-y0mEGUhwAZ4AKBiQBTSCxE6tgDxh6wIT69qhwQc5eh_7YvQbaqSyczreuomcI8eJAfukJrZ8n6_Y9a9Eh0KTZ-dE_FevFERQI_NKQj3-dct0Jm36x3tqAU_R9LYS35qFT2pCtnkdTy5Gs-MpDE9gq2u-sA0PupQqqmHmJRwegrUm8aUykUd2gngkz1yhfqZSAXyMPKA-bxvUx_kIvd1H1fhPfg-dj_o_mDsl1k1ZHxUHAW9J4dUzPX8LRymfhHwRx9zDHmaHbfcBNstAAYbtl-JErPoD2s_pHUF5GDUEZz7fwRr4IzfjSnEnQHnLHNz6e078YIRVJQ1FqptIFXRcfc-iqXIZN4EUr_rqLaujK1JBobDz1VJs2laIc_7IXT00eciTV1djqPKsuxy9xXT1ZjusqLwC-ez2T9s8DGKJiemRrTL-C9VyYiXg-ZTpvsU94vfk0jL0g50JC9EE-L95pQtxJF08wtk0ry9RYUr18qwaWLfq0vALSxDHT6wQdIGf0kiRbSIQRwXILRLS9RkBR4J1JgD0-yGyE8_NuHsq8Icqr2EDqvRwHwqO8uc2H0aPdgAli2vs5sa8U04T1-vT67r7YABPoCESl8llKby9ig_L_R3jx0fvbBdPazejWQZwb_AAPsuF0epjQGu7vj-PgT8kCtRH_u8T558ahgRdPIbwm-bh5gl_RkFlKgZhRqCG3sAGvdrzEAOvMpIDkr0x8GnEWv8LLbHdAJwMSW9xc9MaBmsJ0ksAMKHb_ky-A0VKViWNFwEq_mALBeShyCdWCS_6wvcfHQLnKmJxdtBHaPmp5S9jW7EsqzJUwRqwjONSQDA_QIJGpvIT8CNZvXMfSI7Nzvvm_xvAr8UFi0S7y5j5AM4PJe3vYb9aeSvTrwW9CwwpUK9xvob_U_4P6KgoGWwgQfa8PwlbySr5AtSD02mIUfYZi3UFyblJLXW78jToqK-6iDbIKfqVv0gmqrrATQflHO9-UaTyU4K0Lbyrj_nvL91dbS_7w-zSvTrxhcZQRH4m8fcKb3qppv_r2e_IdbR9NdC0turjN9nRmEEmW0QTmlKroNYwhyIbjS3q84dczLMziDMYwhyEJVH_v1OvHz0pqekVemJwx4VelIVAvKI39BnRU_RlXyEun9h3rC41ciNuthn-Z_wAln8Z-fkPrRJ_wsyn2p9Ivr0fBytvmb7OnZvSE5MLRPKn7N4_Mt4FXq8vSwFp9XQD3LZ8SbuInACevp79w4BfbnwCJ4DlAx23_Joz70YRqN76G9XPHiaMw6cdxmK-0f50LtrlYAyxTR-vQTxTSRPHr7Oa1f1kJG9hfyfllMlzhoMuuLv5IModJxXT2QzomXj0NdXAOi_vOHzcN-dMcfYkM7wG9pbBhshPGiVej12_121963lVDE9_0fus0e6P9LzU-twdT6bcxX5t0hbxXakc_tpFaBTSdPFE34UI1fB-nV8VqDX0l-kvwsFJCpP2zxt8B0gxiDjKSOT4UIg45FHU_oXjiVupBYYHJa8ItKAR8WSdKAWsq_nPXzK9vFv2Hho0BMd8SQdYLIzBmAPDV_p84Pc2AtC9YMeAA8fjlpbC0lH2298HE_7KThtdKpP5_gn5xm3S1f5bw4atCH9P0Ic_jOSXff3V3csN-DWNi7_ckU_92PHEkxm2j_y3m6ld8Z4ijAnizf0-gWig_Xn4MmfFcX_V8qvXcRniVUMvwhxy_p78_4gcjdY98f0qMw6W3YPH3zhf6XX3_gbUhAK5-kvHdul8lJ5DpVT6cNv-vy2xFySHck2b5tz_mL4i3osqLvP7IvJwplxebwYMMzgdgn_-i5c4LUFiROW_Psg3ilsLv7QM2c9lzSZUL2iz7-6LkiwYuB_Fl-Q7N2CF_srNTa5TyRB96N9pQS6A16yGOzwdOzxt6e-E-WFKvlKO2dHkU3lX8AbhJBu-quUgX_YXqwMSXXU-PyAAw6_I4RtWjNJLISAYnEH1O23P5-U-u38ZofejTm57rYTT1YI3_FFpMxv-P7ALm8UGZF6u7UZXsJEinH_GBFP_nkAh-CSn_6pdj_yjl4tlXMM7QHpDF9cT4FPt6IFXVdKHU0ydoADht0KSaCpvwYm1_3ZSnrS-mdGVzuMzxJwG_z6S0GVeuf0wzsoVwSA4Vy8i5DW3ycDwZEV2GABOClABphBL-EAPlkLdER2E_wtUkUhoYeAJ6ulcQ9IblABIF6g3SZAPAB7KToBKAQsAWAPU-LUWJSF6mhehAJYBxANhaYel-oYAIP-_AJ8-DMQPuv7QSOXR0fANhBf-t7WHkbNwJS2yTP2DAOwBKF3Amhp07qD9xNOT927m8Pj_uiPlMmkM3IBOCjD-KMRYy8MwvULGR_GkUnMBJAL1-0cQ3SNgN6SG6R_G0L0cB7KWheED2EBbgOMBwgJgewUwgY5K0X-7TVjGuM2Qg-MzX-FgD6eQs0n-Y-yDu-B16EWAMKmx3wZE9M2UBR0Uf0GXXOKx00u2ceh5m7ZD5mtvmDwwN0jAiQOSwFFyRuy4hQUKbhlQUKGpQe2llmnEnlmWbgtgqKGXgGKH2UTljy4p3WlgJOipQdKB8IYcxB6IPTJQ_QPkQwiAxI7QMo863VP4BHgMUfukmBgwKlmQj1mBwiGfsWIAWBG3FTmTyC2BdEBMOKwOXcUwC1oGwKcU_SH64EdH2B9CHqQxwKNgOYkLEQSAuBbEAH0KSGuB7oFuBKZjqE-wNR8CKBmAkwPb8i8DaBdQLN4skDpwVwF6B7QOw4m4iuAEwLqBFHHJIQ30JI4IPw4n3WN6awPgAiIKwEVUD3M02HRBFgCl0RwJhBaMn8UKSCuATwOmg6ILqm7nEBitKBhQlQPQMpwK24A3DqBGbn3k0sBsgHKEG6HaAPq0QAYUJXDNAHRFmA5oExAO4BRAnoDgAXwHe6DjkkAGljAASQEnglAHrKKuC5B7dU8sql3cQS8Cj8TlnQASYHNAqlwMseoGq0uDgzg31iD-IiGSgcPENBZ4GNBj7j0UBlmvs-gmEMKeQQ8wPSSgvTmg8zlCKsOVhRsJiAqsYNl9c1YCfGKtiPc6wHGsOdjwcM1kAs1YDYsh1m2sJ1nR4JiDtBT1jvswYMBsn1hBsgYNDm9yClBhdAzmbX1dQCYLa4HXHq4xgikgeMFD4yOhR4NkGSgAshYMZaUesPXFyO-9mW4WoD6ABE3t0-YIMEhYM-suNAhBB9lQAAKiVBIEiDqbII6QHIMVBSGG5BpDHBkDjjFcVjkKkETzeAsQBpkXwNhoq9HiAwdAeGUungwjYxKEY6HoGO4JXAGZiTAY6ECA9N2dENjkzQPKlGw-4MzQRTn1cxvjD4K4Aqc1ohD454OhyTehc4kf2rAaunVwBcHNBoYKNBjCw10PZjBYIiANB_4MtBgEKAsNJCV0R4N_Q4XhkEy3F44gjUBiu5wT0mD1XBUADTMFTBSEHIX1SeIA1UkyjAQJqU_oPoJ9cdhkJ-Ay3tS6zF_2xLy9wVwBCUBIztwCgRbM9ugYhYM1PoxoCn6pSiwABuCYhQ5iIAI5nohymHCw7EOJoJUAL4uukiAduFhIWuh0Y2Zj10AQOuGrdFNSHoJKszgAohA333S1EM--npH4cbEJ-8DpQFGykM_oAYN9B5ENbSwChCcCh20hkTEL0mfH0hjaxySlEK0hTE1fOZGAZsJFGghIEPkhUkLS-UDARy3QBDBk1gis-DksAhP1OW0dANwjtz_APkKIAMd1gcUvmEcZgVLq4Jh4hCkI6iwkNJGxNHkIe9CihZggchJeBhKIdhlUPx0Hum9ntADYLmwyTVshXuDtwmfArBVYOTgNYN0EN9jcIduDrsnpG3BMeAKhHYFccVZncC2BB7ickMroEDm6AQkMmUpI0bGN1xbGlwG6hmUPYh9AwGhTBCGhNUIjoi0PGh00BEhP3iP6MdgbQhkL5wzkNDI1UJJCtELRofEOAhPqHt0xNC4hqUN4hrkX4hgkITsmSHEhoykkhhuE8hAJFkhq0JPoHULwy8EOQcbYNrBrUIdBf7hwAC1n2h9XQChAnkSM9PGjBqcB2srHXmekomshrkOp0FaknMH8g2hrQgJGkeX8h24VNS7YL3cGkMqGaTV_2QfQQhl-mY4uMOLIZzUChKYOBs3rj-sYUKRh4AhRhZMPsh80JZGkDGLI9OVSw0yT6IiOgTczEnpBuYm9SyHjuBf4EqE23SaBMaH4AihTXoSAHYAQfBMQ_AH-8_ACuA_AEIAtwHuAjwFLGJ4FZAb2Gw6e8iegnwEkAuoX_E8QGEwpfRSA3PBAw9bjzE_3jFg8LEkAmcH2AVBUkAwAFCgUHjVgOwHkAHsJZuMAHkA4WA8AYADmgpY24AaFxAAKsIZg_YBeAjIEVhmsJuAdwAeAUKHDG-sNeAhsK0su4jiYZsKfgFbithWfRthdsPncSHljh8ZCdhKuG1S4QD4QZcOpWUcPWA_AFmC6sK_ojcNmAw5Xy0zcPbI_AH7EH7SQgbwUVhUEH4AHvGbh3cMzI5oF7hocH4AXvVSw_AGkIncPYAQ8NUYI8IZgBpCnhTk34A30nnhi8JpECcJAAm8JAA08L5wG8LsIW8JAAw8N3hYJAPh68JAA_Yn0wzQT7hsagHhC8LPhS8N3ht8J-Qn7Ufh1MLHQqsLfU_YlF8isIhgqWEHhKgEfhGsIZgWQASAccO8gz8Jkyy8LcAtACgRtADXh22BAR7tV3hiEC44GiFlIUcOfhtgDFSKSGbhpTScmaCLARz8PLgEwB0qZgxgR_AHwRDFWoARCNACkDFUcv8N7EyHk7hM8IZgVCQ4RnpH4AXqR4R26j4RhaSvizcKARggCncouwMSRiWfupiUGk5iWvAKThwAeMC5AuCPUYEiIjAcfE0RigDV8_AFzK7xDtw_AEey8cMJ-X0EMRQ2VqIlsh2G4ty4AEwFERsMEUReMD7qFgDMRxWSayliLGyIiMARaiPLgGiO0RfiJ0RqiPERPiK0RmiJURTiOfhRiJl4HYAgAeQFER0UGWksGj0RuMP0RnCILCAiJFwLiMay6SNDImSIsRqICsRniMhg_AAAAxNTQwADQiQAMUjVfLoiRjm_RmctHDZitkjn4RUBEEVsljEWSIN4ZV4vEbwiQAFrDk4Y8AiAAQBooCeBhABUkc4awACAJS5EgJvBuAHABOoFgAaoFgB5AJ1BEgDVBpLp1BcIDVBcIAlB64T0i-kTrDaIAQBYYCMiI_EEhTYRMipkTMi5kQsjgAEsiVkWsjlkZsjgANsjvIFdhE4drCU4YMiUYPNJTkX-BzkZMikgFcj5kYsjlkasjgAOsinkS8iQAKlhUkhvCR4MvCKCq8ij4XvDlJF3l2kb3kEYJwjogK9gZ8MvDRENeoAAJWwwZSD4DdgDo8UZENJIlEkooPjsAD6zOAZKBLAeRRngdHgNAJYD2IZWh6gTXqxAOwAAAdtrAY9DkwJ0G4A7QH2RKcJGA4qJORYyNNhd1CgAcG3NA_CUzgPlg-6UAHogKuCIAcAEzglcHwAxAAtSYgHZR6qPakDSD1gUgFcAEgBrScYGhRcbhXAQ8MtcvRHVgTSOcRKKIMO3SJyRvSKThByNIIBtktAIgHFu8znNAdg3NAQfFhgAAHZgkHMAAoCIBxkdFA34Ak9JkUkgY0bAA5oDci7kWCiIUVsidkTCjtsHCj5gAijGCkii5sJ0jYAGijm4RijFvqYiQADIUHUc_DA9i6iMkW6iPkY8BPUViBvURaAoirlB_UbYBC4YGiQ0WGi7gIKATYZEApQdGiqfi0Q4ADIUE0TAAk0SCj7keCjHkemj-AJmjOEW6Fd4YijdkQWinUZ3xT0CWi-8mWiawKrDMgPkpsEVWjG4RGEq0Y6iCYnJ04ACxVl4b3EodmQhMEYeiJIGNEDMCS5YAIkhtgNwBDIAuiIGFmi94fCjd4QP1v0a8Qf4TfDOsFQjUQDLIB4Zwim4VBiekRei4KvJ1c4rvCt5meAyeFDtatAaAKEXgBwMVr0SaMfBabpgBQEHgAgMTtRf0cujwEYBjLUcBjrUSAABQL05j0bRjT0bBjXUfBjcKohib0R4p0MUooDQCMAo1q4BM4AphM4Hu8YAJqjdIDgiDESAACYhfJEDLWjQyKQjl4efDD4dup5MbvDeMbxFH4UsB-AHAjd4dzx93MlBGgFqAUETHgVMeAiYkeQBUAJnBtLBUjtMeAiGgA0h7AJz1gMLQB5pAY8r4cic8EWQj-AOUBLEJnBkiNZj6MsvD3GPkAUgPk4GEW5jjMR5iEUeShM4FlxIwuFiCNCZjn4YJjhMUZiEsZFjd4XxMcEUpiBRIljZ4clUNUdMjUscpj0seAj5pKwAhMf-jssXJiSsc_CogDOAYsThMisTliasXLD_MOUj4scVjaEZ5iVAJ4gkwGvCrsLmVr4eRjn4ZRjd0Y6i6MWiAGMTBiTEc_DWMREB2MchjGFqhj-DE4sMMXmA-MZnAmFOJgNIpnAK1KJj_APmi60VJj-8DgiikWliusQpjX4VViRcLliQAGpjZEBpjYEQFidMXpiDMU1jqsRdjd4WZiLMVZjAkTZjn4XZiHMQ4A5pAtJ3sTdiWsSABvMSkBfMTOB_MXnJAsfABLEKFj_QB1jmsZ9jwEd7UYsaaAwcXNhbscljYcvHDrsbjiIcZliccWRhbsZljM4IVjUcR9jQEcvCysRVic0TTjwcejjasXDgGsbYjmccTjWca1j-gO1iiceTiIcbYBKAH1ir4QNjdMmRj_0RRjeiiRiUkZmh-AEEBcIFNimMTNjWEYgBL0dejFsRnA0MarUqgJnBqGi9RM4LlkZ1EbjpepnAvqB4AjwNRAJwZaYewFio44B7xh5IrjEALjxNCEQB5IPfw44NXtpoPri6is_kPeL4RfouqACgAJiKdnKBnca7ifMB7irbN7Vg8fVj7-GtjFcYdj10cdiC2KdiFCHjirsTxUJcUuipcSNiZcWuiyMPwBsUdPhCEbvCzwGeA0kOxw5IHIhmgmEohQIUAqMUWQQMWAQ9YAdjmMUXjGMXjEz0bNi31BrikMeAiUMWhijAGPovqKQxvcdQBCDl7i68dQBfcUJhuMcO8rEG3jxMW8jJMW-ppMeniIYLdiJ8bPAv4Y6hbsewYCaOjw2uC9USeGvDBsZLimcdLjgvLLjrsfwBx4LQANIhShnQKIAO8eWjpsa9E1cf3j4EUtjh8VxAH8fHFn8fZ1C8Snj18SdjRERFiecS_Cd4QLivoLdj7segjNMRWjnseAjdMcB43sVzjBcVATvsZZjogHDj5wMvDAcY5iQca5jYCS1AIcVDiYcY3ikCf9j-AEFikca2CycXASIcZjjYsUwTyCVAT8cYzh2CSksScflieCTLAoCZTjqcWQTeCVASGccujRCYIS6cbvC6sdDj5cMRjMCcwSoCVHhgsAITbscLjRcckiawBfjc8Vfj88TfiQCXuiQACXi92GXjwEWwYE5lcBxUSMBc8I_iATEASnoC_jb8Z711GGABfIMrju8W_jO8XNj5QVeiB8c_Ch8fwZDccbjKVKbjIgObiYAJbitLDbjVgLhU9cdQ1OgO4TKAC7i3wgIAwANO5p8URAQ8YkT0ib5BUifIR0iZkS7ADvjfcVF4MiYHjY8acJ6sY7iJwBUS1sXkTKAMnifCWAS08aIjt8RkSUEdIT0EeAjD8fjRj8QYJT8VXNz8TnjkUcNjWsYYSxsREiZgJtjkiZ4Tv0j3iv8Qhj_CT_jtccETNgOETR0GETcspEToidbiTYNUg4KgkSkPicTKifUSF8UFU4QAIBM4ERB4gLMTfIJnAbAJti64RJjU8ewhN8R0SPAF0SD8dwl-iSfjL8hTwz8VfDdCWMS88RMSTYC4SQMTUQGQADh7iU0TvCeNiVcZ_i18bJ1liZrjB8b_j1iSJjQiSESzcRbircdpYIMLriPAHPi1sdCSlTHCTb8XLj10eMSQAKNirUfLiQAP3kESbVikSZyIliWxiViRljOMU4syENsBtgDMSd8Svi4Ma0T3ie0SIcRbw4sV71uid1i-iQMSjKoCThicCTRiTSSwSXSSC8VMS-EfEBtgHBBlYJZjikPq9GCSyST0V4TVcSiT1cWiSAic5BMSVxj9QFIkdSZUANUQJBDSWXjXiaKSZMVRUIcQR8oAKHiYCfviIcdjBnQN8SIcbFjM4FejtgHFDlST-i9Ce0jwSUKBISTRiE_O0FN4DFjbAAxjaSZRiyMV0j3epqSQALBxbkJnA7BumS1SZmSl0dmSFCKvjRUY2isgLwEw0RABmsBbDK3J2ia3CBgPcPJBpAOfx2nMFxuSsehEANkERQfmSoPJIA7BhOiA4M8i_YbciJydJcqSewB7Eq4S8ySlkNUUmSO0MWT9CXGSZlEYTHUTWizsa6iqyU8AayfBA6yQ2SK3HYNa3NlA2ySkAOyWrAuyaoAeya4A-yS0hJkYOSA4MuTK4eHUPYdsiPYUsiPYdOSm8V9BYUV3iFiSyTz0e6SPiRDjByb7iRiYpDqMYyTnyUbjZgKuTYyeqTDCVmTnUTuS60XuSRPoDBDybMB6yeW54gKeTWyQ3iryRSAhybeSvVL2T-yU-TFyfuTVUQbYPyROTvybOiZyQBSP8eyTzSRvjxSVASIKegiCoINjcyXBSiIIhTl4aWSxieWSgEXsj3USnCsKbWTcKceSCKc2SZwGeTpfMRT2xDeSMAHeSHyfGRqKfoAA4ERBRyQxSvyVOSM0XzhWKWyTV8W8SPSRnjwKSllIKVGS6kQyTy0XBTXyRkBM4ER9hKRgjn8pUJmiY6jlHhR9FYchxf0X5SMgCRA0oZEBm4Sr5f0cSNgKdWi1STUN2Srs4wsRJjywqIj-KY5TjCXBTLaDMT3KcaS_0WuTJMV5TahD5SIkd68AqTMQgqdPpQqQbgIqa-DO8dFSzSbST4qQkBEqSjjkqX7JUqX5D5yYJT1QG5S_Jh5TSsYVSkqZwjgqRuSpvsNTKqR6JqqYrDIqZwj6qciTGqQbJahi1TiqY6iUqYAi0qTBTy0WiA30eniu4XlSkKZqJiqV5jc8jFTs0UhSmqXUMhqT0i1qTmToKc3iaMdtT9kLpY9Dv1TZsYNTWqbNSTqQ1S4qYtSEqcpgVqc_CbqVoROqUD5qwFpi0DrJiOkTITwERPD7YEdTAKXNT2KfuUsAIeUktMvCe4S7BP4TOShsWqTYaf3Df0ahlX8WaSMMoJEAMShdsab-isoosTQMTsBP4aOll4VUiSUYZBkBtjSpiXtSeic0jIEW0j4aWxTV8cjTUaewh0aWPC8aY_CVSZ3jaSaujf0bPkb0VzToEZuSnsa0BwgNTSSaZBiKMeTS_ybg9qSS1BOERzSbUWy47URuTf0bzSekfzTxqkLTimuPDMaQ_CKaTGTc0fCx4adLTd4Zq4DaQmTM0OzTusVhicMZBijaeZSTaW3CDymbS34cLSraZPCNaVrTy0bST-EfLTZ4fO0g6ZQiVBt7TOES6UPHnHTsMQnT4aVTTTqeABhEYu4ICQRo8seSgAaRYAxEaeAKkYRjOceEiSkdFAYAEmBDIKZA7VPLSvoCr4HwfnTKkdFBXALDAwAKZBRcRnhiUS3TBEW3TDIPDA8YHjAi6WpBVfBngq6SSiwAIZA4sRnh0qrVTXUVUj0ANFAPAMzSx6aWD-6QKISkcpBXANFBu6V8TG6TWAUBlvSl6cpA0YNFAkwLDAx6cGiJ6THgd6bHx0ALDA56THgXwYvS60VUiVfEHxq6TOSLAH3UhEXGl9gBelc6bvC2sHBBfEbBoAAKSIwUPjQM2DQqI5KmFpDdIQElQCcg8cHII3BFiIxoj2okABSOfgB90XBlLAI8E99OKAxQDan3Ut2k607rF0YumjR0hGlfU5Emm0hzQ3o1eFh0gXFnU5eFR0qWmx08BE0M1_HcM-Mop03hl1nV_Fs0qhnLwvhmulDgo8032ksY39JQ6eHFlUuwGuophlo0jLGsMsWkR0tUmPpLwBIYgRkFeCRkiMh2mzaIsqGM-jF0MwmnU00LIdos2TLw4AAe8HZESY6xlewlBkigf8QiAYcBqICaLy9U_C6IpxnLoQKKRQGqmdUsdDu0sxmTYuhnG0lRn-0lGmB08BFzwthk40_KlcMpOk8M2rEA0UIDGMwRlllWQkZM12lwE8Rm5M9WChAKRkf0GRmmk5EmwNBRkEEpRluQ9_ExMgWkzAFhlccG2mgk_Kk6MpDBZMgxlFMiJn6MwspCM9JnFM-GmWMrOnOMmqTdY-xmqMRxmr45xnAQVxnuMjzBeM4cA-MwgB-MmZkBM_IBBM6amoDBxKbU7WnIo3Wl5kmABK4yJmyMutGqMwWnqMlpmJMy_FIUlJnIox2ngIpPF0M5Ok5Mp5nHM_Jn7M9dGHMxXGlMrXinMipnsUqpmqZAImBUvmkNMuJnNIjRnRktplIUjpl6M1Jkn6ZeHPMvplNZAZkK4j5kWM0TJWMgJmoJOxkOMgGkbw3FlzMrxEgANxnpOTxl-QdgArM1_H_0veEbMrdHbMkJkrgMJmgM2xDL48plAUs0kXMpplXM_JStM1UnJM81JdMhEDLw1vF2uEVlost5nPw8Vnt4sRkHM7rGysuAB_M4UnroqJlHY-RkgsxhHKM85kQs5hl8s2IACs8WnaMnSq6MyVlis9lkSsl5kmM9Fm9Iy1nt4gmnYs0Zm4s8Zl2MnfGoaQln0s2zIuM0lnksjxkiIKlk0stZk9I6xmbM9pEq-ZlmUMhVkIouYkAsrlmMMvVlqM-JnQst-i3MzhnCs61lIsldGxs1FmmM7NkeEjWme9VlngI8gCCknNnQYs5lqsxNmXM5NnXMzRnGEyOkZs1FnLw0tmUkzNlZlW1mtsxomfMlJaFMmGl9SWEndsuNmI08FlDlAOn6s2tn8sm5m203eH3M9dGPM8hEDstABts3Nm2s8kmDs2Nnys75ndYxokqszlkjskUm9iP9KKMsal-0sdmxMidlQsutkwswVlws01mdM9tmis_Nnwk1dnSstwkFsx1mK0omnzUl1m2M3eHAAKomQlX0mBwz1mzM2hlFIslkLMylneMgAjBs11GhsxllXACNl3U8OlQ0w5nMkn2mAs0dntwpNlXsqdn1srclqkudmd4hdn8ADDmIsjtlvspkk9stDndY0yB7s4dkMMoFmaslAlAZCTE8s5pn4cm9nGs9pn3shFkPMtJlkcyVl5s8BHkc5FEjMhqm_s3KD4s70CuAaZkhs4lngcismQcilkBsmDm-MwhnrM2zJhs4Jkoc67HFs5-EAEp_G6k4AmYc-NlI06tm8sydmGs6dmws9NlJ0R9lIUozkOEkzn8Mijn9MqjnOc7ICOEmjkGc-_F3wQAmuchjlmcg9lyMo9nVM0FnlU7Dnjs3Dl5Y69mpsmdnxMvjnms3eFecqNauc4Tm2stLk-crFlfsnFnes11n_sgllH0olnesklkQcv1mLMwNmwczTkKc7TmIc43yRsgpnRs2dnak3UkOwfUlJIF0kKwkLlMc6LkXs2Lkrw-LmkYxLmA0ptnucu5ltcx0mdc7Do2yV0kTckTmA0qbl6k50k4dI0lbszvGHMi9AOklbkGktbkpIYLkVsrDmHs99QRc7Vl1M4wkccg1kN0gjmxU3jlPpfjnzswTngAZbkdc1blzcnrkLc21nbc9rlOkvbkfcq6nroiTk_sgrl_s8BGewx9DAc-TnwcxTnfssRGVc6DnLMmrl0shDlbMpDk7M6R6ocvzkLk3SmFkxSnUEo7nmciynEBeIjnc9jmWc5eH7w27kcM3eFGIlLlPMxcl4862GZcqjkehDOk0RammRIzIAsAWJGKw2CE9IyJGFI5-HFImyBngb-mo8T1mRI9xFNZW8HNw6GDLSVfFS8_JEeIkBngIxmmq-YESJMjbnlon5mM8lymG0wnmhcjVkLBK5Bk8_rmNMynmk82zm3sltnmI-OHNs3eHOU1d7-U19k0IZeFs8uhmZ0s0lc86JG88mPgSYwXmq84XlngPvKGQYNGGYkrk6AO3kjZKxGy8xWHy8gPnR86Xn003eHq86pFa89Km9slrlPM53n7IVMmqsnjlIUunmOc5Fm58lMmyIAvnlo15lu81LkvUxjlqwamkExfeGnssLmwBeIhLBaTkXwrPwNlSPlXc8BFU87jnlor3nIkwPlpyBmkwAUPnBojTGK86Pnc8mJHp4_nmuoyJHIM-Pk4AAACcifNcRMfLGyK_JKETXK-Zm3O6x-vI1RFfNdhCaWXg8NNpJxfId5OfKoAyZJP5aZMc5i3PvxdfN65DfKzpTfKt5LfON5bfMWChXP753fLUAnrIOyWCiOyN2VpitvK35yfM8R5PPPZFvIvhVvOp5IAGH57FNH58ZNAZY6NF2rhWUgcDJwFKTgQZM_KgFyvKayQvJKRE_NMgYfOn5AvKT5xAusRujgipm_OGyc_L95ZkH35WfO3ZyLMZ5WVMv5apOv5E3M4FuPO4FT_NtZHvLf5cWLNJn_K6QZvLPZOHJrZ1aMQFg_OMJKAsIFTAt95C_MYFT2SD5JSJsgovODRyUE15GgrcRtArj5JQiURhgu35JAq0FlSI15ZYIz5ezPYFh_IEFBZKEpdDKv5dvPp5z8O6pwoBZ5NfPARogsN5fXJO5zfLY55vMhZRLKkF1vM7xyguoFW_OYF6gpUFmgrH5qfMMghkGSg0UGvAa_Ml5NAtGyMvJsRihNMFCvJiFw2WgFVgrT5tgrYFtHKcFUHhhxd_I7QvVI0eHgoVxevLL59QpVkPAvu5ZrPr54goTZcArCF9LIiFbpLYRlmhipjqLSRIwuMJoUXCiUQDSAKDP15jxOioFSP15NSII0xY20J18OB57FMmFEURmFjvLL5nrMmFj1FGAPqSjwcECs5QGQqF2PKd5tQpVwrQvnAAmOTkoIBL5jvOaF1wtcpOVLTZGWOS5XQuppffPkFEQqQFm0hQZowgqR0a31JvGDg5neI2FWnItAeLP_ZoIuuFMWP8ENJCLq0PLrRYHLh5_AAR5IiGyAMSMjJKPIZZaPJig9iOhF5oD14uE3RpJziIAA4nicoHICZA0GYGoiOhgysKZW0MFDESAuiFMPNsyfgCfgKfPARYDIgZeAvvBkDIIFdXItA3IvlBJgvYA19L05RbL7Zngq4FswFuFj3JI5z3MypioveFo3NnhXwrEFPwop5CAoGFxPKGFCOnGFmsKTiPeJ15ugCmFkURQZWVPmFy1AqRQgqSR7bV2ZI3PE5TrLNJWwumFB1IQpkfIOFXmBGAxwoyApwvO5FwrlFTQsEF6or8m9wockjQpx5BZNtFGors5nwoe5-7MCF0TN6Fl7PCFpvMiF5aMBFpLOBFgSPhFifghF5aKhFoopsZnfPB5RYt4wiIriy_0DWMqIppJsPPmZqnM5RPPLxF_jPq5hIqRgnYotAZIvQFMNMpF1IoactItsy9IvCkgCKZFSwHNArIpBJ66I5FaIoCZ4ot5FMrLHRAorgZzdOFFo4rFF8QAlFeQpLRoYuz58otx5RECVFsYq8FBADPFrgpNZKYu-FWdN-FWYrVQwArfU7CJNFdrOWoYTHGFjqM9F1otJZp4sqoIIvVAywtxOOmUUFjqLLFrqJ_FOwvARLgokxfoo5KgYsmcPoud4h4o4FzwpPFPVKI-0YvMk54sZ5p4sTFNvOTFnQp1F94r1F_fIUFCXORReYog5BYqQJ1YtoZAFIgli4tB5lYufhwAHoll4uqIdYpRF24v9R5XOU5WIrbFuIpLF4tIJF4bOJF5Yv7Fo1PIRQ4sBcvEvHFwBMhgU4pZFOADZFYEsM5HPOdZXIt3FK4s1ha4uwFG4tgZIos5FO4p5FkoulFDlPsFlQowRB6NiA2CIHEy8Er5l3MrZneIfFoGItpd8KxpOYobZapMaIsYofRdkudRrvMeFpWNslvQCClnCOolynNKogSIQ0y6KQJ8vWdAj8REljqIXFQPJHSpArbpwaOpCQfC_RkfMTSu_LHio8PO401MnpK8LBwedPpiyTlg0OAGDR4SOLpzIuhgdUp_GEMA35NUrUl26iSRLp1gRI6UlF8vNQljgpslWCObRlaLvF3LLIl5CLHhnkutp3ksI5HQofZN_NmxYUqPRwgqo5AUvClLxMil4IRQZMUqQJcUv_RCUoV6MkhSlCtP2A-XJhF__LYlmAC1e8AHkAAAC7eJT6yKuVBzsRe2LGgGrA08CdLHUfCzdLLolS7EpytMRfzI-T9LyigFg3xagQGBffTypVZSJKVVLiGZvT6pQoRmRc3SY-gKIupb2LAme0jNMsVLw2WVLTaJvjwksQzmpeElg0YjAOpWjKN8BjKm8ETlQZbDjV-RZLXRfOLNJZJzbMplL-RQZKYGTgLjJcxLTJXuL6BavzChSZLJ4LHRsgqIiguojB8RdpKeRWzLMBeuKVpEHxcBTgBDIGvzuZU2KxxeqlzRZNKSpUhy8ZbE4CZdHFqpV2hwksjLEZa1KUnE6LZybUiXRVjywxcgTpGWNKehbIKzhTjL53NNLQ6UgKJaXminheAjRpdryJhTuyNECSRvZc_DHqUHKPhT7KgZSRLxpRmLBuQrx_meyLmZciTE0hrNFWHYiJZRJjE0pKKxEbTCYEWIjdpcpzS6YEjbAJ38RgH4ygMkoRhkQkjEVjKLQmbbLQ5YdyBOVmyMcYHKnJXNK72beLP2WdKtJRdKweWxKZMo2KSOXxzfpZSh3oMvC_JZHzrGYcKAxf5IkJWcKwWeWKFJXDzXCjOKcAEHxJZTCL-JbDLt6ToAKQGPS85SEx6xgVT-GXgjlGIDAy5chxwkVgy44dqhc5ZiKXpUJL7JLojL5YDLi5HoyBJffLquRpyVHANiMZTpzSWTnLMGfwB85SXTTOSfKS5efKZiBXLiGUjA5xa5KXJfUyY5XIKN4XDIcEQNKdeQHKdqc9TrpLGLQ5cqyENu0Ki-e4LPeYnLUBbPy1BSgyAFYfLgFarDQFbQjT5aXLCGeXKVpEQy6WcvyNZaVKEhUYKchcTlSaXvyZResBhxELCqgbop4rMyC9xJZhOIpY9haKOBISnAJyHC1xorNXw3CFnBfLNoopILDBDIFDsUBlorVIE4sUZWb5lUgaNo_sRBqtIopkoNFZJFK9x0eJYAzEKQYCrAorGFkyimxGeBtFIJhDFSrRXLgdQqPiQwo4glI3QGnFiaLABvuAh8QgF4Bg8Db5wwEcBN6lDQjEYPle3vcNJElyRjFewA1FowsJFPVxIFpwYNFE4YqrHwYOPLOJcHDYqoeM4AzENwkP9v3lUAGO821p_Q4hQjRHOuYADOskBrqK-jcwCcARgOYBabozQ4haT5atj7xwpbZ1dXlrdSKckrUlci05xFtYMlXZiCrEHwzAIPQ2VuSQjYsrkxvEMBvMO0BoSS-gKYi5ho1p2c-PojNRFrYgsvnXtxaErgIcuQ5RlRIp4FunATsDVpSeFVgXDDVL4kQDdkemTwvrM1x8aGYsDDBYszEA0gRPGpAkYE8rXUOcrTTux5IFnqB9QbtYKeMnBoIGYh9Ma30lEQCqmUL-C0xNBAK-EjwJFH-5ZFPJ4e8jYLZHjNdCbLMr8SN0rJEsx9dlRuVcpB85YngSrOAN9RvMD01WbozQpfvOocgDvj73t6tfkAwoYonmhgaMx8RlTYtLFjJ4qsBnAy0ovNoIDDx0oMhzklWg5fLJg5JFtnZgoctZZrDFAEVTvxwVXKqE8hBCROmYVBMCat-_k9DjQBuVwdulJVzkEr5wGghGSrblKAPbkh3ikB11IkhaAIiA4XtURiMtLcDDpZdXUEiqLQVaCpILFBcVUMqqVfL1akB4cqbvpBZwH2cA1F0lfVAarmIq7FjVbBx01FSriJq0AUIN5dCQNR4_KEagViN6tGSiSoqAOrBP6Fo9_FTEtRgD4RAlXGrklbcrXlRmIFSR6rwIcaCl5h_deOuKq2-lSqjlLh4naPMsNMIssQ6jZg5UNQo90KWrglQ2sr9uHVG2i5gJkpUREXJwx-iPikYaMTQsEsywhMByrCugiB2AvOr69vLydlY2tVzkmA2bmPQ4zIJhVzpIlYYP10v-uUQhLs0Bj1WYJ5eW-BLGulJzOmPQTGrLQswIFAGlvypQZO1JK3hmqkEB2tWzrMBbiClVdXlSrYQGFs9eJhsVrvj4Itm6qmUIIsP7mqr6tDoLmDOlAguskqYNaAs4NaopeaB-YGgO1xDErP54VbmCxrHrVrPACTDaru473DqBD3DAsRUVJTHgKrV5KU2TrYcpSLyV25sOpIAOwP6g2NTyoh0fXA5oHFZLENwAENNZVcaHZV0eM54iNQqTSNdwtTKhRqH3Bj85QHuS6NfhSGNYXCmNcRSTVmxr0ABxrcKdxrmYAhobak1o8VIZTJyT-Sg4UQAJkUj08wXT0QFmXlwrDVolFHkqGtLbUtFAIZH_MqrzrNe4JFMJV3rBXjIFhCqqwTYrtDNg4uwZz1KDDJScKTyoJYBLNVUXYRXFMshe4kKAtujuIdus0DDFIcpFNIwoVJFCoIemuYyQucoHzPr5TFJgZjdPFql3MkqNNHAAKxgnpGlAcNT-CzsoNTBUyPJUJoQSFspBvFxFNJMxytUqdZVI4QUzvtNxCizMUzqCMrPm-Bk9DvwrcWkBBNKclZ6EbFYYFD5ZikxVkmlVBhkbMV8Ivy0YAMcjZitljKKgoRFtbABhkfW9SYdNhjkTKQHRHVNkBOCFGtbUJbwO-QA4RqJ3qf3xP9kUJk5gl5xTPc0zVJqI2hI2FrVG5Vmqqz5ywtcESfB9qewmqpBUDoFCwnvpIRDv9JwmMI7hDMcawJCJQhusJ_aHzgEdScIwhrttkKu4N9hLYMQhmjqzhBjrERE71mWCiJkdXNhUdXZFwhpjqbhBV4_hEW8MeQyIwRHcJkXjvwwdbOElBhr0IMZTr4yCMDQUJdclihVJsgN-sadmudoTvyEQVqHcjRu7AhdQ702ddMJEdW8JrdlTrnBiiJ_BptFhgv-tUkLuNl4AaIpdYrq90KisJfBN4jwNLrrbjitI1i5MQ0Brr3yI0QvJtNFBdXrqFdZttohloMCdYnpOYmDqTddzqURE0cMhJ7q3dSsLwTmCUPdQ7rC7hQzqsa7r2OKmRygu71tCXmR9VGDqudcyx3PrDpwQjmFGwpaNztQLrwdbmEHhlVD1mJCI7cBzqtejNj5CvnqQhkXrfvqpMndexwE9RHqjfpgDzemPFM-OTqidd3c8Mg7rIhiXryTn8Jz0KnrUSiiI_AfnEIYRtI-9c1EmjmDryohRdHdpKIJ9e1T_9FoQEUpqIAdRi54MJnxNRGOhywueg_ZMvqmhtPrwBEvq-9Qck5lC4FH0BiRJtejo2tVCpsdMXTTrqJR6HJdqH6HYRAwH9ttNB6tJtPz0F-iMJ_AJj4Wno-ZYiORQ6dXAdv9U1MFhrMgIRozNZXvTr9VGCJ1zGaowRAiQzNOAJ8ftQN0hO7BbtZVCLCNCYVsFCtDfOy9yMNfoPVjVQ7lr8MMrsh5gRozMQdYgRbVJNp-qsZpIRniM2NHapRjhGVM2lnVLjCLM_ijMgS6tONKfELVNMvNrTJiW0T9OjAu9Vz95bF2J3qSOM5sDPJNpA_rUANdq0DYvV7tKCNZRFbjF6ngahRIPrC9hgR0KcpjaEpJJjjEshEgvIBEpfABigA6dg6hYbqjE2lJkhYbkCqZMBxpnK8hS2lZ6LQkLADYbLBcmlpiB9NF3BYbupVZK5MfoaaJIYaODfIAyhk2ELDbPkrDd3JBsq4ipDSPqKpJDBYEqNg4JIglIgGYMBJFFFONO0BgomUNgQoFSpEnrBEZSwCaIqIaexj7yeeSxArgHFA3DXKA0BfIhvDVzMr4n4b2fnYlUZq1UwSuNrO-GpoNVFqoWGrdyyunW0UCs74Y9ZAwR_nt52ES65RtcsYlqFb8ATDMhz9dQoMdO1rlNLMazKNddLYHIbmtS_qTEBGBQLHfrQDR_rLblwdv9euY-DvlrrljgR9jfr5ADRld4DZuJyDbTNwDW4pIDeCQYsDAbvKHAbgDZuJvtXt5kDegc1Dd9hc9ZgaUTFcBrjdctG_DeRtsGZgwTRcbqqG8sm_Oy9IGFyZ_tCdM3FJQa-cL0aaDXfUUgUYaVcogaOluxpmDXeYl2mwatGKEa4_gARe_JAhuDe3reDejl-DWPkyjUIaCvCIaHDfSNB5JIaLDTIaLte9SFDYCb4cHiaSdn051Da0aUZqCc_WFvK9DdHFD0MEb2DdDM_ipSbT8NkBTDREbaElEbbJjEbGiPEakCqUb2Te4anDbo4XDRYaDTRlLF3C2l2gKUjqaDqaw9SjF_DbOT2jaZtOjWjtujQ1AsTUbECyKgjg6jNJHUNtq2vGMbNdmCVJjeAxaQnvZytYsa0tVfqNPjfrRwDZBT9XYQ9NJbAlTdb9yyJAgtNLsbttA1Ai-EnEFjWppKZtEcCwrmaGoL8bJRJmbXVZzo9vF0aHFPdpEzYWa0zXmb-dLSCk3MzB3gZt0xFVJZpYLFighCEI2NaaADLHKT_iXgUQPPpjnQfChXQQZZGsurBkzX3FmvpObuvh-KE_gngk_uZZCSDsCacDmCCFP_YaAIA4_JqA5yaCnMxLKEgLNWNZEjOwZoIM5rRPGeatFBot0_pnArzWoq5QCYtZFPebnPDDD2PJxZuLLZ4xPP5ZcjLEZkdKeB7uuKBRFEQBj1QkIy4oUM29AiFa0iBam1SdsnFuaBTIFDtYsWepyoqYMIMbX0hQOqNdRui9oLccjsaqcBSXI_FHwHQBzQD5Y4JFBAI-PyB7JC9A3kIBhq6OxxShKaIg9ZhbsUe0xRcjBUO-cBd_SuVEKut6U_EvX9CcEu1fKG-FH6rf8S3uIDW_rw12gI4BNMJmAqyoa061E_BbdMDQ6XKgl69lMteLRhUgGh8QmUGpbsPEehmQHJqLADFh_avIRAyiGEljpf5j2uV4ZOogAN8UmUPEqlhWvLmUaKgV5xOoQFLKSxAKmm5E7Ijv5ULXjrqVkECN3ogjTYnVgAIvZbryhDQEaM0ADGjaok6H9rxmXABRFP7dqHsrt_bihbcdXZEZInM0oWtsBnOHpalTJfo1dsm83wgVaAcEVb0umAAgcEpwqrdkC8rVZ95XpJsWdYlaAdIlbkrWv0_qqgl2rVDrIzFAlTZLlB2rR9wBzYMSAScObRmABbTQMBbYYBlaILS0Y7IhDAurRRFoVteFmgNw5ErfpaxiK0JKrdVaSoLVab2otaVIm-FsDvQcBTPRl0oPzBs6GKp5CAdbAzZUN4br3qzZO1aq7PRltsPOrtsDmgKZC_F6MvIArgEhp51VhptsCME0AAZwLrUDaiuIDa4vlgovoidAnxCRA0ACQbrNsGEsFJxa4dWpaTnn0J8rbDaTml3FkAlQD4dYlb0bWABMbTe1xkqoxsvHjw0bZVbibSEcQohQFcbUHJErTi94zHvgiYijbdOhaJkbeMysbblJvPpCEU9WbI4BOxaZjU7MwftxaDZPEE59BF4T9BrkRqZnVMQP5aKdSNTIKVy166n5aQhtLT5WphDSTUfopbQV5lOoA0EUtaNqQHJt8arRNBquErTMEvI7lIu0UvKeAQnkqEluNNADcM58VcHRU-GtNrt7BrUbbW5a7bdPpoZF75d6NPo6Kmvy2pa4U-GvYjFoMNA6ALQaQsDehlUvIQb0LNqCxjAAGqlbKRDriYcoBtA64gbxM7WGAsmutBtPgRpTwMn11oPEFULXhp4gisUB6h0bzbfpsCNL9CuCrna6AM1FYHpZsBGj-UKVuYAjbedwSkp0oE-mLbcwq_9NLfTUinrpbJBhgaArexx5bZlbW9bvrnTGpbWHJxaJCNPbB7cHUihiEMF7WtaBbfq1JbaSoBTBABGcEdhIRESJWUEja0ACjat7blB0gczMibVdAwANzaIDq9crICEMPreD5WbeMy8vgqlRmOu1cUJzazZOuE1EjZsg9QbJBGiRVZgKSDDLbbFCbPr1CHF456BmXa99Draq7ZX8mbL-QvZmw46_mfY98O8DHQqsFGVVVw3rs8Y5zdObBdYn9NIn5MO7DpawXlLUZ_kfwxNDkUAKs00MvjvxBycCapofNoZoRvq_ZO70mhm7YlqZxAGpKy4ogBMRfkHOFmQDUEE1uSQjctHRmeiH4_dPrsVhvU0ynsgcCwlG9A-hI6_dOVFo3gAMFxuk9CSHmNfXum9Znt60Mro18MAF084dQoNbNLo75Hefx9tE18nXp_aPMldhnLVdgDCn70bHfo67HWY7yHQx8j_r5bEvg47SXsVbW-qMw2vOegDfpegmbfvFPPm4FcVrlpPHeSQ8xvg7Nfgr9ebRldrhZY6bvmD9FfiTgdHS0FbHWrB1qGZRUnXE7sAmT4RAclEmVsF0RcBE6gnR_RD1PNpEnU8h-7URR5frbhGyrxhnrTQgZsZJJ8nXH5CnRfwK7Vw8HNEpANHYSRuxk5NJ7QjaawIOTPtR0ImjuM7ySJPqchmb5rYPWthwJww4QL9QAInA030ukAD0excrOvLVgaKRrk_B5hBArJ8RYpbE_KKIFIgpEcsZr6g97Y51IakyVIOsSUISlhUpEuOs7bB5hl6r6VOlMjgQmveA_6LqF-7TNbphIXbf_Cva5dYaoQwn895sOXb-yt-l_QnA0j2n95wLbC7p6kiygrfw6-fJNF09ZjVp9AJtgaaz5HqGC7y4oi65wimQWwuS7MXQs6FpjC7GhD1bb2jbdTWhAVQXfS7u-Ey7BhAJ1WDdwVZihM9lrQS7GhMCaP3nehkHhT8TNqGRxqlHouXUYU92jtkeoDy6FXSf5QIoOUnZVJl1JWvrYzTIMVXUPa17SQbwSCq75dRsJVfnACfJPiQlLdsANynS4RqTHcRqQCcExtPoIXY0IJbcfpW2lScXbQDVkgV9AEdSNSUUN68lhCENMnQbxp9B8Am7agAx9QRQ27YBpiXWpt8hvG7vRnmQEdbE6svmhdnCIACNpCEM03YhxCjch1bXCll5ne1VhBpDrHrtWAhNv5NHXeJt_TpzV0wklYbME7RGGHRZ2pF2F0pAJBZmL01yPsQVnYsKohPsfarmiNT-3tEFUVCypm1OUwRZA0rnQCK7LsJmg5nbm6snXM6ewrK947ZoQl3WuE3tuqpIdXfac3e07ejE_bHEqWRdHW49liPQQQPokAP7SNTsQA7ZJaJVwFMO0rByA5JW3XvovsOlxu1XeqLgEjQRBFP4CnYSRhegi6lnS06Q3Yn4PuEF1ESHM7Q3dU688n58-cBB6QPaJUi3cDrqUIKhrhRPoILRLrw3pCIZLf2QZ3X8iQPfIQanaCU9vJk6zBFh7ixT-j4GUZClOnB7eMB9xL6GSJ13TnqEPceBywtE6qBsjRueHWpgWNPoooVh1nMM9RyqWR1X3Q_BiaKO60Ctx6EOFFDaHfMYzRrewJPfCwpPYMl8Hp9gbDnVgA3dErZwPbEIoBhtsnfCxLoLbZFhtkxGgDFaFaB7FdNuo8TqD6ANnRlBByUGMi3Qu6u4mgURqcRMfqIe82XTJ7oDrexc3ZBwhQnO77PXu683c56YAK574yUD8QsPJ7AOGfQyRNg7oHTHk8HaWx_uD1B53QF6vWg1RzfrH84fk687fmccoLJJ7MkMx7EiKx7MqAG6ScIx7GwkuQRqRxC4oZ6Qy9FuaIgDE89zdBcpoVkM9ofvo8vZEBnplR7Y-oL4llAV6noMu6UvilFo1kCE7jMgaYGMl6Evha7lSngwBDCOh6yuQkeYeoCxDX40aDO-bfzU-dBfgJZvyk57B4u6YQRLF7tCvF6E8LNAH8i_sIKkiZU8Ang7jDldPPbhYTOIx8SapoldgOzblSrt7tgD57oCIEChFXSCRLJIApEA0DjYR2bO4JqBt4GaADFIfJjxPxIT5MIgfoCmIHteWwlgCRBoiqodQfZKB-QTMBBQRalhEBq7vAJj7hQZMjkaZj6PgLOhbQR5rFUadhvNdDxeOhTwGkAFq-DEFrjBKOabQcIgCBP9AxIJSRBgRjJrJJIBWfdZJzSEu92UkR5hEGQbMlPXBifbtxSkoJBy2NzxMgDpg83V6M7gBrkLvqP1t9NA5-QutAwwFPoe8NeBwgBEAZcHpxoLM99-IpwUuhiTBy2HAVR-jVBGxjkl6Blb6ZoWodoLDr6MnKgAaoN_oPYLr7qADklqAORZqoJKs8LDkkpJSEx7nOFS2GYvL5YDMAaoEF1lIDkla3miiaoIZAHfT3gqJPpwaoFVFIGNsxWoJG7IGFIBy2M1Af7NL7ZfbCAzmKAomdqNDIFIy0kZH_JICnuDv5A8LjAZX6OZJAUNfeLhv5ICBf5I36-OI76Pffbp25Ehh2_W_JT2NBZL2O0YC_WvscFB6FRdM5RvfUP6b9H3wDkkowtfL9BwlqugyYJugviCct4UGiBgvAr7W9PBh6QLCAd_VtowsNy0yROOZxWFHhv-c6KGsJqjHKjQAsFBkAxQKta32Ks6xGFxg6mIn4-vjAxr_aRUZEHIhH_fOFESA1gyyE8pZuZGAp9bgRO9Lw5OWvQx4mG_6JbJ_6jVgYxG9JSNoA5nhFjrP7yGCNR68MNqyRLfh68EgRTwF3pNBKs7IA_qJj7H0N8ZPuMGsIQGoA-CQVXOvEaCMgGvYC97PaKaQmA_Ho4bMzlysDQGyAxgHv3TEcwsJiAUDASbn_SgbBIFBABMfyEwyWMB5htQHftDTgeA8rBVhodCyMJq4rgJIHXHKAVDXOoG4ALYTR9KlgzXNaJpAxwQwJLB7R5OoHnQCYHFzJlMMvrAGgXOaktnJ0QrUOYRsRmFhOuWrA__YjjIoCAH9XnXkQcG4GBfffEvA-Kwd6L4Hx_bYBQDLLRVhloIxfCXgfA7J883f4AZMFH4bOKH8QsO0AQ3qeh4g1HhZoMh9byWMBKohU7mdYJALFNZFMuOOAYEBLxggz6lQgwkHnqUkAvUgRs5sJyU2lTgBMg94Hagwa8VtKcx2gyEHQA0cB5CMbo2eYll0iARh3A_f6gg2Gzsg1l8fAr0Hpg6QwGsMJ6qUFMHOgz117qgEHf_dgo5g6sHpUqsGkCDf6BKpsGH_SdBUA0sHtg_0G0BPoA5BiM9RDmo5inASRX-vMMrgxv1ivbuIxQJKBzvuVC5aLjY0aEb6F8A97bwVSRtHHkK3wk-CgQ4XQnwYyQ89JXpORJnwPIaGRbwXbgnwcb8uA_GZu7IewuerVCi9MpgLbmgUIsKLYvSO7g4zDAwSRuhAs6I2NwQ2tDRoYQD8QxWZdoXnQxoEWYZoTSGyQ4XRO6IyG2Q5kgUArSGI6CeCzGJSGT6HyHgaNyHWQ-84XgAVJfsD3RLwdlBkfqwHEyNCH27ATYiQSaYGlKiHJ2D9AIHRAcbPSllhhvMA7lLfgV9MqG19FecLuXM6iBlaI_RKlgzQ7OVogM645sGV6OhO9bBA1ABJbSsVAfowE5OBHgZ5ZcGUsvqGwsNQANQ4TYPvXLQRUTPKmg3jDVOPpwfQ2Khqig1gAw-A6gw4OTh5Pg7ww3ARTwP_7g0NF58zQpddiIAHnQ6IgO0leQfoGJNcCEg7STXIGpEEjhyvGigFnPmHZgOUDuA_DUZvWhVbAFqBXoApBZwMydP9bcH-OH8GsSA61mw838WYbSAKte2HgaClFMEf4Ji-mMlJwwt7brZKJNlDrtGwWFsXxNq40BCy1J1ifo0wjcHxAzRtzALIH-w9-71huvFNwwV5cHZQZrLIl7UTtThUSDBqvNcoqqfX5rafZXN6fdu59BHkC-YZpDQyJPJUTkiHE1pvAmKslAcJndF8JsSC5QMRMsuGRNntJRNh9fb9xRJEqEA7n52yPCGyMN-D3oXNh_UHdDPaADD1BNthVtNthp_a_px8MqVSOP3htsARwBAAj6IpL7pALnhH1YIzhQmudNhAdsVmMKiE-SEERTfXzh-GBaUQmG2c2GUIRAmKowFmDto6IKsLovDVA4ztJNcCAcGyKh4GtgydBbWhvhVhQGHZzP7bg8BJGpI4MQVhhRbZzDqAL_fm6EJkKJlI6gBPXqtwVcBpGcTaMGKGNpHSVBWo9IyHgmEdkkcktswEwLD7k4MZi4Q17hVhWTkwADVBqA6OBH_d5Hlw5hbVwyiA_I2Fg76CuH2ZNq4go4_rHbWoIMAH5GcIxgBYo9RJwowRh68KlGTOOlHF8CZxUoyn6tGP6HLvb7CY8Hba8GDlGryITogo6toaoKtpqo5NScYLVGGo5EBqo29Dao29DUo1_ZF6hVH0Q4vUgo8aZg8NsUaoANH8dv_sgo_g6RQGoL4_UFG5UI89wDrbDuGAUAkowyBVhS5GWoIHoc7jsRynfSIScIwBefez76CJuAgo61BSIwRYEXfg7y2POEcCJdc0mKP65fbQlGxq77To-wg-oTXQgo7yUZoU9GE8OWwdoWr73o62Eu_c77aEoRG9YDVAQY_hZ2EP9G1o7jiLo_3ghTq3B_ozn7-8DL6x_dDHJ0MdGemDLpdI10HcnT1AKI5dGEXfjGTFOvEbozWBpmMjHC_T276Yo9HgAETGC2K9GG0P9H6OPSHffXTGXo_QMmY_vptfd37U_RU6oY7QlaYzPKfo8bDEY7swKY6jG9TsdGW1FtGk7KTqUYtLG9tJAa5Y9uoFYxTVZgIKgFYwjQ0-LQkVmPRGfCCVJho4KtLfcAAFYwzHMAOktPoybG9YzgoOY2jHccabGRYzrG_vdbG7Y5OgLGMsxnYzMAUxGtH-GPvp_AMowhI8ABkPJKjXkhH5KAFsxUsOkxfGF9AqrtewacCAgr5HhhwDlPJcQXRDF5CJE2ZFX6YDPUhdpGRFM4x36SON9HHOOnGHpOmwhY8XHN2EhsXdGFTcYLX7n5PnGB_V-C3oeX76_fJJUZD6wFQ5GgV2P37249oh2A9XIsWCewvwQmGjQz37opEPHVOFJxj2NuxPQz76iONPGJ2Ofp4ow_pzZH9IJ4z17BwY3JTA6hwaI5tGAIwXI4ZD3H_5BYBVY7AoCJB5JM0F5JA5HzhtwXXHzJEfGnhjX6QZHX6H4wb1dxLfJSzHQdm5MxHcDmfGAZHXIkWPIlEFHHGw6BP7M9A2DX2IJwS2EXG39Bxw2YxWwoEyfGR4_6owI6kHdOPXh39Npx0E3hYiOGgmewctx1BJgnzOOxhzdIgnyVMj7942QmRo9sUkIR3HobO-Dk1EuDLLoDEfoE2bmYEsC05sDoZZuzBGgZm4CuMpIqAAa8_kIEJkaROiF3FHhguNgADFJgAfRKrMfYOrMDZjImlYDrMDgTLBoIPsh5gJ-pOUfsShQGZYnLBpYCSRODdLDK4WFBEp1gBWrKrFWrE8jWr33Bqr61aAteOvGCyfWhrcHBhrmDE4mTarBrXEwhqsNThqbIBmCTgXxqFEqomY0HaMTEJpc9YKftXZMtQ1vjKA_dO-JdbDZdzvESgfENLNi5skqhDJxZK0pYACaKDYmuFWJuFl-ask9oZck5VZ8k7OJBFq-byeMUm-DLkn-FoUnRPDUmck-8r6k5UmMk4kYmk7knnANzxKeFwtWFoqi8VDwtMkydhsk10mek9BA_3AItr3AMnSrMkrHqneHBk4p4P7tDwBDPMmyfQ0hFk4Z5-FpQsq5ltYtPH0n1k4MmGFoZc2PNJ4Dk54mNk7Mmd8PtxpBAbYC8L2Z4BtrRUNZ4Z0NT4nLAHtxnMGARsPAuhwfP1Ed8AeB7JMeA9IMllbNBDQDnY-ASpG0qZoK9oOvmvpbPRv6d-FIt3lWYh0oMGiGZXvg5nSVJHAB5AByEimG5uYQvkydAfk-lB3jbYhvk4CB0hjQA2bPcmcYCQNtaISmwAD8mnLVYBnEy8nvE5hr5DNhqKwalgoQaymnDK8mOUxOEH_k-tigEaiGbsOAkNAyniUylEwCLNAxnaMB2gJhB-YKSpMAMUAqrgyhBMFtj-gJxA1vIImfCB5gySgUARPZkgTVbnFKlb-0SgtdQtPYMwh1fcMjlQwpSbu28PGGVURtsuC7RnqnTkPyAXgGI1DaAbghhPtwEodr4EQNAAq9F7g8oeTC7kyXgHk8wN0ikGqf-I6roMucK3cmJD44C8rLEy0mASTYn1VXWr-kw4ndrOYRYHBYm3ldWqzQXBqAIamJc054ZeOsd54AMlAE0-jk_k4KIVAyfHl2RmYG7UgmsAJnA20-lDyTliA60-hsqpE0MhbVKA4WHgAJ3DrItLqF5yAynZsfF1NILVbc90NJ6PltQ7nAtcdrLA0glLtFC5_pwm3hPBDL9hchlJBumHYJqkJAUf1ujoN5AXH9QWTJPU900BRD00pc4OkFbBvFGoIk35dHGskBSzru95QY2tW1j2pyrVIwfVCXgo4prE04ththwNWpRXWKDnwHiA5ZOuo_KA45-AgQAvqMEAB1WUy3cjF1b0wKR70w7B2Hhk74IQbZx03Rcj0wgcnbso6nkCYdpBJQAxQHRd100pdkaBFNH_hNFHU-XtbUxckIk8DQb06umCM1RmJ03rBiM4-mDThnZX0_m1bk1iBCM6pd-M6VhOfhyaDLrsms4PsmpkxcnBk6gUlvskqozlkQKjtNtGQthmP9RKNwbjzgqhmsmlM_lYlk_wsgmmt5iM_fYOjsKnUMBZmlLvGEvfLNtO0bmBCqmQkBM4VcZQSRpxM5On-iv4VlwZ5n-ENZZ1wcGh9MAiAC8AUBGoiXcp0_m62rnI0kivOnKfNbcl08oUIoRXRVnl6EYfsiCNhOF4os-Wbw3uHVrjswcZJtxnqMxJnN0_X1o3qFnkpiGrIsxncp01N6BiNxmB9vE6K9OlnArb59L3k56cBknNbLplmd09lm_ej1n09pSnWs689gdAtNtjt89fXQyJf_pUcTDscNAjpc8ByJNnMjoQdLLZ5lyRGJn906iUYhnVm_Cp1TB6rNmaBPNng7kNmjzqHcnApnQ9s8ywFs4Nqls1vkzs3-B9nutmGqAVmeM0RmlLos7Hs8Ud42sKIqHTuMtswXhiMzrrAc4VCkzotmHnfPUH1men_AkKA3IK5mUgC7iongV5wszOBas21mYvmb4GM0kcWMpxmrsxjnwtBRRThmmcT0639H_mWQ4JG9mgcw-nSczZmqg3RdKcyVneM40gac1jNsc90dzQJzngDqb4qc4VCFpsmc-hgRdvZpt9Vim-dCrlUNhkyKBRky0mnLoIsgmnvRcsw7MO7a64lvRybJc9Lm0xOMnJk_WrLk_z9dTfoDPAk1mS8JZmvvltnSsxSATc-lS6po3ZH7Ecgkk75mJ0GXoAs2On3s6pd82n5nJfVMBM4EonJoHrJR08FmMoKnZ4rk7nR00Fnbbs3wVSlETlE37mSNAHmfc2KwIwN7mo877nCwv7npQpvTQzSIte_rMBW7EbYQnH0I4c9VmIswkBFc2CoG4ig6bc5KEa_gLCtRGfZS3lSUAYTEow4kSQgMzOBagcOpgM2b5uYm7Z6GM1SBHbu9QvLlJiQ2b5tEI5mXqHllNnXUD3Hfjmxs-1mzfMC0FaCJdz0KOmswEeABnIgiLGviRv_FVnUcykB0c_0lhwuntNYl9BMwq2syEArnrs5wVBMORgBqD3m8yvx7QvOfmcs5fm780gn93iPQpgjmrus3Nmj8yPn783GmuIB_nXACYJX86Zg6LuXsyEEAXBCsfmKoGPnJ86MDp82lnZ854sSoEdne_L_nS3kvnjoLIm-LivmDU6wBXfDkBC0UvVdIJGSkbTMACQzd7YzF7hmHFGYnNFnQ4zG7Zvog4cOSkUxfNuNM14PyGEM_11wvEdhGlXqqiABOhPqLIgpQAwpGaMwJs1iHUAYVenhALsA1MN7QGpI2t1Rm1AWzr_n9VMCHdHHTMe6GCHBg7MAs6NIJpC7mHeUgs8lw3MqdWi5hvaFR0Q6sOBMwhS4qXGQhJ1UEBumIPAmgg04xSJSKJwK_0W9Gk4JuASH3KhondnMHhtE4SStpJXoX6D4XeA1KaFHA7AeXNs4TEySxqpfFR2Xi3pYi3y5htBoX7g9oWv-qfg0JAIrmHYJAIYO0rMMHAB9gtEXOCq6hCizEpMMCU5Si4UXUAG6JoQPZEu0I0WGi-0qXyA09jnN_w-8IfUPsCHrmDgk0vU7n0CHqrIZ5QGrvU6GmI6NvYnroMX9DrWn608GUNOouFC87vn981i8RvA1mKzV0xVnRim8BiHw3wmMBIBvgM2Ps7EunH5QSVIzRenGgauAMeg4aPWhWwdHUKoGSBizgzcbMCq4D6ghBmQHdRmIprd3i0fUCrq6gRgMqlRKrsWZvGMBrCc9pkBvTqW_ECWYoHsXjqNDBQ-IR7nTCMBQLdU6Q-GgV1telBugCVAji6MxugMdRIS3cZZ0i3puix8XZ8CHqmjlEXi6djlASzUW7cBDAYANNrUAH3UGS9NqSi_SXaSxVAWS5yXmS9thVHAEMawCSWkMGSWTcBSXhBlSWKyZ6RCixHbeS9jl1tXSW5SxHb2SzSWlS9yWZS6kl-S4cws3bWYJuKSW_i37qiTsNpUsBKXi6SMAFS1KX-QrKWLSzEpuSzaWOS-aW5sJqWX_WpNZQBgbrDRX1HeHqW8mLmYQ9d6JdS8KX9SyHreHVjMNPZ-sPU_Q52AMudVzrOtDepNxsQPOA_KHHA_mB2ASpF31sAP1IPeJud7-CxErEPyo2kAikPmAbZv1mCpdUzPKaDsvbpeiPoZiwWWvcGzY6niDmtgGWW4xPAAirlJDpSNWXaC5fn-i9WBCy1iBiy4M8UPcxtRHiy6ls18G6y6zB9IlO0MrrA5Yy3sFwSGJD1FYiQVs87rGNJyJZVr6Wx4ijSRdcGIV7DHgbJLOWjZfXaQIbOXQxPXrPSMEcUQ5y8Fuqrn3zNUmRkyUn3lWUmGgAUm5c365BfsuXu7tbnnTGE9ZzJx6ggFAADcMDQVtHoX1nF5DjQJKHOQ-FTmbSFgfyxWo_y_OBAK_PFto-T4Lzs1Rnc2HmSMDvnW83vmS85fn3CtqXsC9HnU87HnhiNnpBYW5qpgGk8_dBY7g0LGW8nsAQ9vrI0zziPbnKNqq09iMWDXh5hMwu2qg1ewBky-gASpF257-N3D5wB_IsseDsBAjn17QtL1gTdYa8jT6Xq9ZDBYy79GiHMpXGxlco-KjvxYHFQXw6FmZIK9V63bJmF-K6mXU4jOc4-i6BUM0-hxaIyUyfC6psi3gA9RPyHLK93c5lVu9O1pZXy9uZ0DGpZ1ubnZ0w3oclyswoQczAIX3Nh7bMkK1p7Elk1cIHDVryBxWMgGMWoPBGBoq6VgsmjYhA1R_rSy1HhfOumWKy22W0q96mCGFk1myx_riq5WguXkyg0nsCaDvEOWx0OZdVndZnEjqhg0nu5my9Kt8_Jut9CSBGASPjt99AHt9xZkxJhFe9153FfFEtXLNM3K6g-EteA2PGKr1FSPTlwd8r5M2aD0oJCXlwc4AtYNNWm1c2r6tYJAgVQtWlPCFDwwagt3rA0gDQEgNlUoJhCS_iRdqz8r9qwqq-DBIo3CCdXQq9ohO1TkBngGUEH4Y-6cJdtXDgXz8G5jdWwwStY6rJdWMoNdWb3IDXtDA9Wnq6YUNU_iRZHTZJQM1J80_BcBGgn-h8EJslA1FlkugOj6AhDWkyRZB1oiq805FTVcpgLIjtFjdWHhlygXcK-UgLOxErgLDAJJRYAiEP6KrgCgN3Zk4Xg-ILKtMgAR7NBzWYoIZAua2ZRrwH1IkOUGiTEOST6a8gNTzH0Bc5vTXcpaeZgbTHwexTSt8SHZUYeNFZyE7sAYQGng44Udg44BI76gCp7nGKvU8gJFFIsGVrRwO1bbwMLF7ttLQyzE1J_U85gmFBOIOYtWBpds8GWy3dI4gYCswMDQAtevmarg4kAXyB9x51d9rcvqJU_a0HXUZcKI2qm-9HNtRcHQEX5hQKyt2IPwlSdgwp51X9QzEGtXDax359kPHQwtoLBIwlFtAtKAg-Lm6A-kSnC6ADlUD7eHEcRRfxiKTiAw4pIBs6-tWr4mGTQipBqodgnNMVKPAZ9Elw7MJkSDMAL7bqNJ8W3dVLe8o4iEPnSszREMAqiyEqOAFSUbMB7FDZa-RItmOcU1rSi6_cQwRcNYAmiDkBu0vOr-bhYA3CNvXUgLvWDml0Bg1Iu5epFm9Ttnyst60-7xaBfWmmH1J062o9MkmOclVPHB1btuo966Is1q79FQgnf7CEY4tF1hpcp3PLAzEHAAOAMGhNsUsAjcQg2PABrk83ZtiCXJPX7QulAjceg25q6z5p3C99p3PiQMG01aSgx6JJfNr4I-BfFD9GggEUv6hyG1vR_UFQ3UgDQ33XsRjWfLA3yVFgB8i2OJetGQ3jqP6hhXLw3EnCVaFoKpAvogS4I-NG8I-B9x_UASnZ_DHFsoDKAWmaxgCK7oHxQ_hCI-K_5TUmWArsEeo30u5tkGwS4cgGYJjRISJp3AtBELSUI_1EzlDSqalEc7o20BNO5jqPgwjG89oGZYzltMoBpTUh4Av3aGQ9GxfF3NikAioPiRjG-wAv0bpDPG2RheYZ6Q9G_TriyHiBJAFJAKlR6G99eYAIYJKMyzIIrfVXOMhgCBxYC1wxWwSPp7JJcIxWH5tzAPJBp3EhtklW1gBeFRmp3E-ZM4DEpGm39BM4Brl_G3sbM4OwBIGaIsfldNXgmx5s9YGyDzkHxgFq302ioE4tkm86YhTJ02ByGtWNq0qk7jAjhOm9025m7-D-m3jshmyKdVm2aCCy8v0Zm2NBtm2KqFmwXplmwJ51q2s2CXBs2HiHxhDm-VXhgvQ3pfDKC4RHsba-ifF3NhABmHFw4_oFDsIwAIUKoAik23P30fm383mgE4tMc4vxl-sC33Nr833NrfawW7Q2nAPcEum6wLWfHm6CzEsAfmKSAsW-MBMmxDA3qB0WVRL5E5aKwAyzBi3sWzMAIIvi20nL5F_fH2BVYKS2_oBi3KW04AKmhV870IlCH4QE2nFpNW-m4fpQQdr5OW7OBuWwqi1m2gh-W1vROW9O5hW1NWLm618qVbPXFaBU3Y0PyGSVIDEWkS2C5BIoXimw9RSm2urlwZFIz4h4Bs2ne9g0JFJnODU3DW3sa8m6WDOZZnmw7gyBDW4_EnzHM9iKme16m3wcHW3U2jWzqUrW_7rUm1nUKmxGAkNBU2P4ksBg27_EUgI6hw2-8AQEhyBuDdVdaLBU2oG9gAnW5mGp3NUhZ0MkVUQL5FOgDA1goh4BFOvIU_qvjdnQFAAXpJwcM7e4BS28LEKmxDAS2_OAXpLmUbk19hS26YwUUC235wNokOKjJJfm86gnPvW2Mkm_Wp-vvSlsh23MIdm3n4spAkNAO3TGKAk9Of62Z26iA6DvIV1AIAccjYbbovPJYUUJWsEWilFikXKm5QMpAc_CIHjjP8QKSvIAKqqiA52wm3hbAa2vW1sgsAKm3rlHk2zgEcbkXO62QpG3EvW8a3Eq2a3O7ROBIG5QAH20RaKmxm2JNsOmuY5DUCAKfWn3c1M6_av1D9Ochk7OsBQZKv0edSwkhZtUgo6GnxEodURd6FHRAm0h2ioFP1cOzvQhZoR2R9gtAM6HcZYSCAIfq5-35YD76UQHfFnWyxWiZCFhSAetnQQyMxKKAoIRA8moLQou4zEAyAtImCoogWTX_qze4lHYKhp9ldAJO3tWIYCVIBS2rRoLCiBhO-D43fSiAYO-ZJ3ckJ2RO7bIi-BSF-vnt5TwFbXEgFpFUHNwk5EXtWtfVB31O2Q4SawSRx3F62nzILkEs4JBnaz-8SyAAA9YpFzQYbSuAf1G8AXgBoJYACwwQqABdoLshd9GBhdiLsQwQLvlI6LuxdjkAIaBiBsMGoDkAPY2C5f9ued994FfVqotGPNVuLPjC5djewjtwvWFdzzZ-KWKoPsPYKIwZ1B24HxsDN4rs1d86B2iCuUNdvyHMcI_U78JNtet1wBPti-Lpt-iotZZzjFACpuSIgDm_xAQBRtqbvvASNthtubuKkWbsbpQqDcG6puetmeIDdmSSsd_t5OZdzsFMD9t3tmeI_tt5RGd_1t9drbsgd4bsbpBzu0WU-L9d1zskgEbu7pFBtHd7ACWtsdxMWvbyXdiRHXdjwB7d0bugOkYQMgbLDFQsbjqd1jtg9_6WHTSKTQ996BQ7MGu3V0KEUVhjtAd0Hsl2BHumtl1vNQDluy-X1sEuSEvjN0Gt_VvasQ1-6vHVg0Aw1u1sAl2X2Q97HssV0gHdNlasEarg4MgTyJ3xZNtYAFju0V3w2ftl7XPt2ugYtJ9rGFyUTHdqdzAdntuRSBJDndiMMiBkREryKLUQedVhQeds1gQchylpXQQVpRVWdAdREhI7REcgY8078QmFV5B4YLWJSALWYKA3tveyTzT0EYOHharcV4Wla-jvXgEUA-WWxWVpZwzU-nuYNgp7gigAuDJwa8EWANHiVFPODSKemtMJ8hyu993twaz3syKb3ufeB4aTKrJWTK7QxB9hwANAEUCaLHWXA9nfjDWhUljWygz59oYnJQI3uCQc_IKk6_IEFB4aaiJSBDyUASMFJSAUFK3tsJ1BTJuCWHodwX08JwH0KzbNwAFXNxEAPhRqwAtwmzVtzmzV-DduAxT7RTjyi-pDxqaDvtoeMxORgt81w-eDwmIR6qSal6r7V4zymeL6rggS-bfm4Tzeg_xriawJrJgrKyueP-ZcWAJNGwDvs5g5cGmElfCqhIL6TMKIHT9lsSzFFKt_VWfLdWq6Dv9s8B4NG7gsmhEDtW18iP9mfApVh4qz5RpQh5ANo8aVnto-TUoZAbUo4eMRpktLB25vXpKE0px03TLcEWqbAdZCGINu5Q1R_RF7Nf0Egc0RfdBEDpGJwuj9JkDvAd7ZOgfvhMf5zKjCGnoLtYBBUytHgDtEVSHT0iFDAbIu3coARR_zotIDIt_MTDt8j-1GWrNCCDyAIk8v_nLBUQcCdz0gpRK4x--chJfQen62W76ScWwtustAIJJOJ_4JAVI3tAMQCU5yQdmyc2XZGxgDmDhQe1SdgAh2xwdODxwffypcN74WgcDlHlkOWhVLmEDwcounH0Dc0cqlF_JjxEdKJwEQTAexVeq-qX2IK0T1pTvNgq-qbWuxAXWvGYPWNW2T1qYiborVKtAhU1J674D0TIwA4jLEJXHO-D_IdfswoeEpAQzsZMIf_tjx692vzyehfnY6lITSQ-NvSpuLzTB3BZrVFDDxfhabCnd6Fq2OfmHFJCDuzXAPMxoVbTnoAArl6FAcxwCQj_98iRJdWbprGHh3KyFJr7x6o6scaRo6Gk3rChSzirISPtAGLIeoQk_2jD6UJvID_BqN0bCoBYSFEQhfqmpd7yr9jODhQtOojAMHxbpppp-Zf7zAhHqGolf7xLYVIifhkmHHQ_kITD4lJvD7mFQw2Hz5Ks8DEw5GGHarJ6gjn4fUwyEcn9z6zEazdywj1mHwjkkLBNApT7xpEcQj_GEkQpGyX95-YYj4cN58GyE4jtjhYwuoQ4wwkfGQ7oAb9uTyjW7fvvVEzyfVZ4dgvBBoa6-LrkHKkd_InkdLDgEyran4e5lCr7Ajw4katDAjCj3MAMj9vTdFXxthdCY0156iyryAat0g-HqP5Ojx69EeBq9kACVYV2JOCQNTWuybgweZ_Ic9XD0bnAk37NEILZAQBi9OX8YJ06HzI6avvQJU9bzYMZ3NpW3Ec9JI2mGxXrl9Svr-jmSTfqXTj3eJSCNBn0erjJI1el6FNygD0sxAWMehjkxDhjuo128qXqPJaMcKEdoDyV-MeV9PI28VbSC9eSkFZD1ssc9IYT3rPvOxwJgiJCS0e5ZaHzlFhCIuhi0erjcSS1j1cbFun0bqxvoRiDHcNnjEey4etC0GPb931j-geAjwpK_azHkiB3LJBlct1Q5qsdfVnwiSJIvVI62m7Uqesf5ZVnwkSW8ApiR0JWAR0Fp5JM7GpaorGheySz-FcDkulsfKKJFiMuq8d8GY8cXZh7B6j9sdyVOMQCsF8f3jvUMwaMD2vREiTr-A7PzhrEeYgFbDPjqyskSdaRfljMLOYY-2UINm6M0MAg-Ea4XuvGAraFM1LGD5CeH5eYChU88fr_eyQ7jpqF6j_nP5mpwlnjkqAoTmAChUxEjkTg0TNYVLDkT7Ce8oGKSPyq8tAOkzuYT_ojfegLjvdKOaMnC_gA-vBS99qYBj4JghqzDtyvwYSdY-1RN6zUScazQ2atuAxSYqM2YyTg2aKTimKeWc0PRAOZyRuLhAGJmIk6WPlyFuPOv2gYRNKawil1uYatGT7KKqJt7DtQdQTbK0X02T3KB2TnPrg--cAkbMDhFbEtw3AylzY4YBBuT0Tbx4fQB2LLM5Q7OfT_GJfY2YYSqelRtZEfUA1DKxoI6PNS42PGSTrbLECjgfSq5UI7YqSNgSmpYSqGPa1YY3CwCr1Kn7prbta3IQx6TnUpZh7UMhH0TU4qrJPAsZiNYR6jKDBV57sqReoC88JgiAxDzAhIulYI7QdaO-We43cAo7aubVNiYaNUqSHqtFBd26ePRR7SQVfrw7EZatSdW6SJKKdJ7OS5qXRdadKQUjrp07BiND8SXIbIL0V2ZaxJQNZgqHTga5ENbdliwBKgUU6SHN8IQwXrDaEActgYW1C4lNzsUBwIqTODrBnTqgfgkbpbrxKqfJ3ejbYnYx2IkD8Q_T70BJVFEzvkBoDpGOTZzGAVBFLMqvGMOGc6gIi15kCGfirQngYAWGfwzgzLsARGevTncgYwf06DddIwYzgfIXTbGc0HA0vgz76c0z3JxAz9cvV6nABcNvnBYzs6c4ADN4ebKGe0zikuGjGsCczvmernGEg0zlmei6yLB90JSEnWqYDAbayu2T-DY59KjbDhBxBHT1E6Qz9VGD1YH6I7cWflrG9bg_PG3RdZmdd3GkN6zoafMsN8f4sEFaBdJEv0zy9BNHCYqBA_1shreOt0rI5S-1HLVXIXafJwc2tgNi2uxV-zavO7TNpTggDdeVWDgHY6cgUU6dQzqgfdTJg4VZ1nxXTnlo7Tw9N7TkXM6IcOdTTqDwxzrWddtYAbOYD8TVPVwqlqVE6JvefxFzyfrT9CYAVzyZzZ-efrwYbu0rl0DD-FxCQeT_QCo4f8RyR6ywqz-yKVzs_oRzu3TzdVieSiJueC21Hu-28Xbs7MRqKnPEYSoBvsRjJLYX8B4qxDeCBwXdnYAB2R4hTpxYJzeKdjrBeAsqcwA1vcOIPwRVh2AGFuwgeOD21PivbPSQBEIdWDVK3lR71CliUqVsDN7Sm4-YF01aYC4Dr1--uygSc3c7E2C39RWidLZoBIbJR6bB4Ghj0TZsEAK-mr9RoK83WKc6rR4osDagDDFeytPQdZh9LaLbFrXrZEAFTCM0V5R_UHlTOMQZWrzjnYoL7fToLgAiYYE1DYLwIQKtyWhIbBDByRqBdCYa5twL9W50uXm7J1eHiWAE7DKK1HpIp4AZb6aOzUL8xzQgOhc63chzjVSrUALiXZuzUnZ9bN9us-bPI-3VnwRAD6UKLvnrQyPvrH5IgAhfeRfTz8L7UjK6BDOmaEMRbht26hvBIYZRencJXD4Lo6L9avBe155IH-mNnY87Pnol0PJ0eLoBcPdStB1t2xf4LpQd75CyGnp3hqlAIJfmAadtRLzCDpSAba5SYkjaHVeKtbdraDNLjrdMSvbn8NVPjj8ASNpzWkiBjN2I2iuRZ6qeLKLl6eydwXMvqJTtybGBecL-lhCoEQBsxaee6Ly0hzj8N570VfruvQ8BF1gEx0psFRbV3Pxr7cx22yNASVL5IG7lJTsg6EQb6AVfqKdpa1Ydu15rGfpeoBjvr7caDSt9EfQpfMN1Tzzxcf9FfxplnwBT9A5dxiBucjZ-Bc7LpMbTz1XWZoYPUOL9NwlFYZcMJVKSv7eyS9L7ID9L0wQtZtDv0DRp1j_JVRLbZG5RbMirFuOwAuzH-v0seKceYQ3aBbO2wgaxpzuNH5BpSIUacCcwbtnHtVBaS2TrwaYTj0ZaeQr5svxrFzDMiFtycqb3wexSRKVvWDi4YoxVRbDs6uNYHizoYGhm4COL-iglT07YhfUICqC-QEQDWIZIB0CGzBEKXWDZSBDDyw4pAhK69RYryUCQZwudNMqLazRUdTUANyBKoBpz6piNbmdHyu-rPpb83a9QXNa3LXqMpiA0VmDA0AjHwQAeviBJ9VLvYDNOLdzZ7q3ooZQOpewwVfpFQbhdFSIQ4tLFxczbWmHtSdRNtz11NRbG1dq3SFcUrvQ5M0G2ympSRLQQKrZ-rjeuWrGQ7tbBlVRLiOoqSKJZj1tSmjgJZVqov2idK2NGtLTCb83CWeWDSMtLAa75K4iS7JLJ0j27KYJML-hFzbWEgDAPIBHYAHZreGFfG7Ktfq3CMClnSxyqFrFQBwvpbgNxzsG7Stdj0Powk7ONdh4gtfC6itdG7F3babV1uoGi7pDr9KBTr2Fc3bIXbY_MJ2jhS7YtrmdfF15hywOCdcaDKr17rnGB2QYLyTRyo2F-TvyngA3Cnrk2Dnr-flJVs-jHryIC3ro-JqCsUCRKgoDEp9vxJ1p6DXrk9dmgN9eVGj9dTgL9eAgR9cde59dEAV9cCADrISpEVfF-f9cvrwDewb9VIQbwQv6tInCr1DF7wvHbaJrwPHML15SCd-5fnTzSu4mRNe89VK1kRFXZjro8BHOEje89F6fkAR_YkbutulFopesjNnP4bgKCT0YOSEr2Jb_hpReOL914QoGxckbtqZCnbSy6dhjcvoQDb9dRNeEYccbDruAGibspeOLpo4jySo3hh_0wKbocYUUFTds0NTfpuYQbtADdLabkLAuL_kgsx1L0qmQzcKbkzdto9AAw8cMPfkMTflLhzfzOfGiphyaaWb7IG_qWzc_INzfqbkzfRfbzdBWotC9W6aSjrFkrXUSKOYW3MAGrpphf9KGiibjlfTr5xjXqENB1ONTDmgEqCOb_GhCF_Ej8FurA2AXy726Upoygi2jj0clfzK8zDVgaMJg6UfrnpGaHBRPkRDiJjdIYfM20bmACBLnrw4Dv2g5QlU6qMXreCHNLhM4DYtkYCSdyqQLdGb6Q6db52cxxKAC8BAlTYEYLFRAEJV6boCyPoabcXwWbfDyNbeuAYKJ6b8MOqb_De75Obynbkjd3NwSAkScI3nWux2NjP5fMOGYw0Wv4R_TjReACnKtFZxoKd9DZc99Uue3bvQ6z9bACEiE5eswM5eZofbjbKwgePSGTc4KBabMbjWrRrNjf3bu_zkACCIJDbb0ZXDITVPXzc47hsp84BaDRrGnVuLIAV84NaCWTrvzMDdAtHgfvw1-QgTE7vkSD1QTBq16KwNTlfbeV9t6jqA2JCHSmhbAHprdARzcw8SQCE0Y6gpA3zdC78QcKEIXfDFTzelFjSdjcW5zDaYnfwOgoJ3UM2PVmRGClYYndC79KBC7v1w59HKqebvXeebh72-bg7eIkYnfdKn9ed-A7cTuNQWXXYncHb9qEAbs9fvr9fZmMH5Mu75Ddu7yo1SPApc6bkjef9AAiW7w3d0Am3fF-PTfywODdKVHXcYL7t7QblDcx78AOB78peEHdshO7lIZq7xIiH_SGH8Bl7eBrfSL47s_qABz7c1AQ0vF77LtlQ6UCqMd7ec4OzdB7hHdRL_qo17o8C9bvra1F5HcuL1wcnlVHKvbovdl70out7kQF0Bc97Oi5ASF7t7L97-yKV73_otdGbcKbpvf3Ls7TD79vfBLpo5d7qJcClsXPhD96I7RJICA5VRpB1Yfeelc2JR4Yqf_HRddVNrGYn7y7b1rsdHOHCGjA0Ud07K66gzykYBHvECBbrfoITlvA4-12ff6hy_fpbhnYvqWfelFgveqMGfeD7wYdglZtdDr3PttJPyYII2wDBydmzghMRrD796fPdzaSid5Ir4IOACoH64JidtK2URHA-2yKnBUrpSpLFM2T5m1feoJEJc-DvTpwUV2KoJFgRkfeYux4LWKGqKwCuxED66xYIAr1Sd7oAVm5er8oASMbHC6BN6IEkLoBgmmjVPAA2E5w82H5w_Hm2w8ycCgqX76ABiCzoVKSSAUyBowYpFDORsuD9_QDmgJMC105WUUC0yCZCg6FB6ip0D5FPUVSUTsLW8ZnRRVmACsOg8uH_wZFQW2cwHiY34Hwg_oHnruIHjR7IHgg_rCRqJEHtASYHw5evadA94HmIBhH2tOHhdA-tWiF7s1B4q32mq0iQyta6_P1s1gGbQHkfnUjSSL5IH_w_rCIg99CQvdYH2I8VSdT64H77uSiFpEoH8I_JHtI8O_RzvkvXl5WYDcxLzy3Y_fBl75-ZZLPBYTKsveIpzr4I9PfROfMOKCAy7gmu5QdIIRAN9Gga-9d5AX1C3OLZzepv4PffbZ7lYNZfQT0UZ46NQDz-ZoBT9YY_YAY48Q7_eLD7hsvPdBa3sDELDXHsgej72dJ7H3tqt9ftpT9YfdG7yNww8IdqcAS485e0aK5OL49C7_fy5lAEs8zkE-ebsE-WjHWe_-DDNXBdA9TeeQhEfUI-oHiI_oHyo9h46wJB9Ig88zKLo1gEYA-AVFa67o-iMMRJAIgFY8a69Y-TYe4QHCT0hEn2sCNFeZxiqiibkn5Y9qCtY_zODY-4eAk8WAEYDJAEk_G7sk9LHsVhUnrk-RuHk90nq7ACnpk9zH9ACE0Nk-inyk-cn1AA0n71P90Hg0TH137qL0MhRA4ffe1w7TjLseJEfeZfGRAHSF7s08Y7rqV_qIj4k76p7lIz0jMfJo5EfX7N82sEo8qkpLGAAOcWIb5CYI10sV7LEC07QeDtbSgzHbx2tjiIXbRr_I_eaHI6sicI4o7L_vqxuM-frXU57FU4qPH3a2WnkBCNt-1AqgQXZTBbhzZoECDuMclBSTfM9IxKarufY43KuEVjnWlGAEgMlKBrVHC3weADDAK-2YiFGCtnkWi5QEFwfwDkDlntAq5OLUGEYUFymG9WCo4K0BYKYbSuFEc-UNtFCOwLYwlQPe5akcppU4AOEznpYClg7QgVnk63ZVYfvohBc_qfd1g82kqBooBiJZNNFAVttgRoAVLhahuc9oAE8_vgYxhnIUFxEWii0eiKi3QbwFTUAOi3ep-mvjoXc_7xNFAMT44Aowec9oAMmevnwi09tj88mxPhTfn2i33RKDwAXwqBAXmsDNp1jSL1SGAgX-G3i0W88eiV8irtx8_tAQADGf6-BGu3mqGRjixkDAK3ZfFgAnzwxF7UP-A124AAI0govnGXsk3ojQAfy7fo6F8Kg7maOY-Z532SvcLmpzAI8-o54kh4j4kE8Gh9qiYXo7QPOYgwPe6Cl7qBOCGtm1YG487FmP7xhlfuQCwLs5_Y-VX5nEWAC00Mx5iDBkYLcMHxhiMJiFpMkRmWTPFmX7G1nIMHFnW9KSdF9Rc1WQvnmGCYxDXBaFhjQgploTScbt0VwEYTlzFo4j08g2RM-iga_NvpL858CRM_KaMrGWo6HCCvG8YE4WHCE4XuBE4YV89DJnFCvHiTs4CeAKvCqRHYZl0Kv-umrwWBr-wpV8qvNi6SmJV48yL-gosFbFyvqnF3YT_YPY2F5qvTV6CPzYDpwvwKwsSWZXBMQD8vWT3OHbQ7wh1w8Ihx46Dy9w4P79RkxH5oiohqMJWvPw9gjcvfvSxI90v_5nMvS15NKAo7rutHHWvINLWKKkKw1nypMvqQTfuafYpHsIcOvujbhNQpFpHW0LF-_CrOvJEKsvDl65HApklMW6cFMV0da8wI6P6bJhKL7XibbkpiaOPw44YXj2xH_IQBvhI6hhdl_pM317CXv19Bv_I9chIN8wm4J4v6wo2aemW2KKqgCXKkWg-40N_LskN_vKLCWJMyyUvouS_NEcN-auYKERvRI7phzl7oMP5q4sg0n2vbMOlC_HBev9I669HnBjgSo82L4Amseqmc9zKqY0QiccJvA8cNYcCj-kCCn3WLfq3j1gbwwtHDck58YATWLCsLlrFP0_bC6j1NYXjq7DyvM8uH9s8dLYFt8njvxhNvZV6qvoJo1k68fVMDV6dvM8cjD0Fnnj48fdvseA6vVnEPYFt-t7K1psEql9GBOCEfAFigh0dOE-YOmgGvdQNQMGo4C40wIoNTIP4nyWqkvb0hkvGPrkvBCmvEnCGB6m8li1boNDvMKCUvmwJUvuIEUvZ4j4gBCkZG5UwVsJpyZG7EAfmZUxx6cyFP49_alvpw-GvMaBnkGw4g7xhEGvaEIOCvl_Hb41-UwuISmvBEM2htw7mvn9DrvOPR-vkZ8LPO2oFHKhuwhdI7Bm4o9hvko_inLN8ZHDd-BmdPSXvoBorGPw5ju2eVYYU1STOT0xxN2Iw4N6mR3X3M0KXkCA6Nd1oI0q3kgQGeE_vO68dNve5sPQI8Ove96FvXq7fmpWhPvvF1TNp0wxcPw5P40D4vvUZ6vv3jrmaHQ161CpqpIkD5mQZ0yI9cI93v16n3vCo5w8ot4wvQZtVHMjwCKaWk3Est5nkWt__jnpz-kxLD4wE1w2YZLBIQ22Boft0jnkX32gEck3fBtD8r1TMXPGfD-ikjD5GqNYAkc1omfjDkjtwTokRzd8bikV2Aj4XonkfjkhFwSj-dEUj6gUEDCRNh0gOHVgiyHJd43g4d-x4m4kpzdhBjvg9_jvrfeeQq5ryuqd-77Ak5S1rd1Kbyk87czj5UTNXH37JBm0B1_fWAeC2MunCVMvN14p79SYgWWCxMQI13wWjnhMQ_j9oWCCyP76wGhuUT7Gu5ifrm880nmD5y-8_oMfuUT_NOiT6Wx1CxYWHmpMQPP3OVMT74WsueKf6wB5-fvxz-W81svt5pqf2f2sWuf3cvmYLSTXl-R03d8XTrFfqk7tk4giSvZWvqgjAqZeqCmHSAapRCKklq6hoGWydG53mhoi937u6bEAuKBTdsWG_bLke3L2A52SAnrSXrr1AQpWMwmAPeCVo3QEFXs6GFXna5DVY6q7-0uQ8w2wHvdG7wKk5N3fn8e25u4og2ebNhWHXsgXNXTyYqhjv9ezvGyxBYWd-vjpVktCaDvwt4nExw7Qs3T_5CE153QU95CUs96hhJ82Sfl-X2v0u39jSOMygjqDJh6ExWfG99evV-zRmNMNynOT4CfNmqCf-l5CfTlzCfP9xPv8By3TFTzmwlB1gfjRzzuUxyzu0g7lwnMLLIMUkBgfdwtncAl4-tlYyCQeDdoWdwXouUl5ua3hFfXa9nA8q-ndrgBVXONwfg96qlXfKl9WEUkjubL78O5ZZenAuemzjp3pwXd05OvInHuGq1JjOpw-OApyTmGeFgfkD0KBkh9Kh_95wfWI93vjL4IfW1-6AkT4pflWgZfDtxAuzyixfIWJxfDL16Y8B3742OQdfaCS71XdR2HH9_WYJ16H1sbuVHkokxfjK9DfA_DxfJ7v90HQPkGbldifg82hHJ943-1kV5fJeBR-DV0pHWN8oO0APmKq2rLfahxGEgb5rfrDEjfeTiMBiQTZNwUichO96Afnr5AfpqSSffr5kUAb73jxB7IiIb7MC2b50Y8BwjOOsj3QrL4rfvUPmK9N5xowb8zfM79xf0oXxfE78MjKTYbS897Sft5wXmmT4xfm7-Cx27_Df_ISgg-V0hgwN_yuSXBXfaCQPfm18Lf5L7ifrCxPv67XReL792094BjuLUwjWf74mh7ENlfZUOCkWQjhvKB2wuQru0JgbzEk0WYhgk1yOeBtlxv869J3IO9_eBO3GzxN9Zg1_AhzIR2A_q2bf-SMTW8bfjGgP48Jedm0NLJH7yPiE06znUNo_vkRjwqH9w_obEcKEDIo_Bagzw9H-_v6zAwkk3jHRD5RFzBfla0Ghr_pfkPFd5Zeo-bNhjujL-g_wN47fQruM22hIlHA74duXr7crsmcKfuT481J99ku5b7A_P3ktGmqadf0Z6uKuByo3IkRV27b8DuCn9bfvN8iYg75vjuBxenHvzy658l4BWXxRh_Bz8O2hIsAuz35z2GakjKDTouFfh2WBN9YBxz3BS6hUNfqZ_uzvKFC_FutfTkX6w_xJ-qdtuoarkgPlAHebL6sgM_WR6fcz26hi_wn6eLLCTS_1liZedN4D1-cQYavH14umV1Kb6V1GqTtYGOWV2Q_j746_CZyxAuZWC_pMzszO1q8_vXeZz6AEf91X4Jv-VyZm8X6mziX5vaQ37_Ue-DS_E3-UkBfltng0XyurH-jiC3h6_Fh2E_XH9cKK35Ogk37xKP412_Hz4O_on-O_YAFO_IO4k_diTTtHL3Xfzn5xHHb62_2n69XT41aTBn7Rv_XhGAxQKL-bb7nfWn5e_jN9zfVHBmMgP4wgQ78_opT75-F76nfW77Df0uge1qjt5eAt7Bmb79JfcP8z-1SeafAfy3mPN_B_wL7IdMT0x_XMNh_3QCfNRl8UWtT5afRP7uvJP6TiIL_J_b7GRHjiWibbr_CCWQHIr6o-QUdII4T5Gcm8El7TvTQPoQ0k_kTYk7knxsxCThl86Tj5bhnz5YqTVT6cvnN41zP35NqOl_V_D5c1zvScUzWcF1z6_dsMAqsOTJma2T6CxMQun72TJv_OT4NaN_bT9Lga5qHg6c3STXd9HvYw7ghzgVLzXz6sduWkezkequUlGbvTsAGIzvv_JhruZ8zLOYdgXz4hfKENhTZgROHHv7OHE99wh6jemvM99mvKI7vLUud1_T5ZfLv39oC-gWfzGOYk3ugCk35N4AfuD6AfF-dL_n3_OvOf41_lT5NqJ97QL6X-6er5HL_Ip0r_3P-B_WTzb_g3nr_2151_tSfeV3Sf1_OucGTrf8wzB6dD_gVe7cl11YYwf6wzc_5wzXf74wsD95zHYH4z_u_3ilGfNzkSZ0zXJzm8KUPc6e6YP_9F2Izkm-7__77ezF_53_9VF4-AC5kL9w1bWLqoinosmb2npQnWY36A_A3m2zbNjA5i1ma6Y6ZseeV2Ai5sV-V0D7_szmtGY4ZlbOEAFrZlR-SJa6EGD-u97L_rP-0f7scC1MAAHa1PZmEf4X_rABMP4yzt6-poLSeFJquuamZugs0_6rpjgBq_4kZn8iM_7pfsRmMdxDfpDayProADGcieygfptCBIx__iMA2Sz6ACABdAFKtIIBtAGYAWABmnyLfuc8dAFI-q2onAGVHNlWWAACsFIBA5DIao_-Vf7uvjX-jAGEAfDMAgFUpmIBwOZD_t0A1v6LVmcmBv6ealP-TP5oAef-MAE6ZqMaQt5c_mm-4t5kPq18Sva_eq2aov4OPslq3MgpWIXAfMguXmK-XajtnvvWNIIhJtDCq3oQ8B-aGRgpzK2and6uoLC-Dwz83vBIQgBavCT6ej6KzEcOCf7D3iNe4xBYQvC-eqTp_tPerQjIvqze4QHfmlEBIoDE_tYB0ygU_o5CA-SOAWLePP7IIkt8ol5FaqcwJWqjVrwm3ggyLl7OBWpi6CxWpFgerBPOaxqhUI-Y_QHVaogcxujgmnhQ1j5sauGqiQA8-vMB_PpHBoR4XgHi_lFw1ABgGBlqfIJdAp5YSxqX6naunQKZaqYmqiZzjEEIpk748spS9bhzjAZYATjcuDDQwPS_eoeaYyCeWLfqBWrA9GJet7AdAQYo-0YSPLS4mYK_AbIQBlhUVoSQFjrA9EL-uwKu_p0-YQGqqmYqFioZwLtYNip2KtaCz7j_mjUo-77jASJopGawfoI8E75ogQQA0P4JzBcuF-q0KFGaMKjnKIBc2mjzvn2OLmBBvtRu6VrzvkVWw35iPoocE75IXAdIo7wSWnTm1IyATh0sjZoUPsLa6HD1lnn0BwHb-qsaK1DAEK_qL5ifTolmwoDjCNcYBog4Gor4tzyO5LjOExh--A82sjj3HIQaCJpQmn98bFC3LO8sl0BmCLCB9XDwgVYqSIF6gEuIILykGlU8BN5zjFTuPfgV-LTutET07mvolIjygX74KoHMvPaBlO6ngHSmNO5soK6Bg_gqhL7WzoG--AKA4xqSiI-EjLxDHk08Z_T8gcuCQujTIJQAk_pVai943z5zGkn8ZLzYWLD8Pz5hfNEmWYGLmkyqbP59Zk8gxTpUmsWBragxPLpIaNDnBNiBJjiRoCYgGZiaOHLo-lawgoX8U9rogZ2BRIE0XiHo9PjjOPM4ILghuPWBUBzUFmtC8TjBuFwI4SZnOEOB6LijgSroA3CzgZG4w4HTgeFerTy_7lHovQHXLHU8VWoWXGA6sBhL6AgYYjRkmKMAqABAkFD4IIHkkL8-8m7rnFHOvVa_7ovoGdhXgU8gvXx0VtnOfVag0uRgo4iBOJK4dYFMfKAw1RRl6HcBRLiKhqAwZ-gUgocOOHiEKFEGEBh9EMeBMBhwGCBgx4FIGICB0OizAb96jcCvttLCmbih0M5Qwfq1xnP4SIKGOEKKu56AuCUIu54q8JTCoSqDVLU4u57huBRBlzCDwIxB1YC3gujyOAq7nnWUcYj4wPmebGAJaHnCvYCh0NUAeYiSgJM4A4hhxs5QX6o2SOxkvEFbzjBAJig77GYA_EGNkhnwyNJ5iNJiC7hcSPhBIdL2wBa407oxYDAgvTiUQc_8Z4IMEIZBNACyQTvgykEVuKpBMTLqQf3gpIqyYEKA48IeFkJB3gD2QQWwk8DhxNpA1kGCQWpB3qQaQVJKLkFYuDLwr_RuQVgAHkHsIF5B_vhKQUpqtkHnspFBGPpBQQRBw4pTAOFBiUHRQfhBWwgZAHKCGPpwzOwAxSKwwGvSYABr8juqBkEQQEZB7Ri-QX5Q6UEBQQ5BQUGxOPFBwkF1QZ5Btbw-QXFBtUHPUp5BDUETwOG4TUHuQS1BUUFtQbFBAkE1Qf5BXUFRQT1BGPqXpp1BGkG1vFlBHwg5QSlB-UGFQcVBpUFmQRVBFkFVQR1B40GBQU5BAgCpQf1BEUGDQdne4cQLQVOAoUGn4KOkVwCrQYZAJUFlQeZBBACWQSNBKkGzQfVB-0GXQYQAR0EZQfNBMaBeAItBB0GAuNdBBUFFQXdB60HlQbcSW0ElJNVB30EnQQ240Fjjwt36zlBcQazASHL0QSRBUAwaQLuesTj01ljBNrA6QRgAwMFWmmAAu57_QRdBcQrWOJAyu55JAcN6AgC7nlJB_aCJpDUQpwDbALueT4L01spAeME6QP5A1EF4drYutADYwbHQYWzeGkkg2QQRgOaApYJwMhLBXMq7nmxBUoqcwVgA1MGLuDdBsMBr8ikKIfDGQfK-wUGhqLjBisE6sCOk7MGwaLueXsKYykhy5kB6wdDBO0F2QXDBbvqIwc76iAAURtpBtNIPwkTBZSLPQYpAVsEJQTbBCMHQ4Hr6iADWQMmwU_rn8s6AekEwAO7BxgBVvAFIHkA_QAEI1KicKIPkBqZLbsP07vhjAGjWnECM-DvsMMGdQaJB3qSP9s5QukBawTjBUoomQBDB6oCVQTpAJkEpANrB6uCwwCXBj0G7nnJACkAlCMb4JkAq-K3BCsEbQZDBT0FAWDzBYEa0XK84msEhqp9B1ogaKnXBm0HdwZsOzsGhwK7B1NCdwWXBUME6lgDBUSKVGjHwrcG1wT4ASMAmQOpAFsGpxhJkicjDvGVunEH1lGoAVwCODu7BWcHjQTnBpIrL4A7B3oYxoCrSbZjyyOfBnsHNQQ24qIC5wTfBiADKvm4EMaDGwkpAfoCoxPAwLRg59BkAlEG9wdNA9EI70PzBYcE2sJSKLEHEMCRBREGTwdsAdNLbClFAH4iPgL-IaCF8IKwAKQAmCFgAJABKgAvUnmwEANwA4QBgAIGiigCQMkmA9gAwNikAkDLEonkgisBYANQhWoAMIbfSDCGwMsSixKKcITwhIaKcIQQhsAxwAKwh7CF9ItQhyUAMITZAkiE2EjlUKMAN4pIhfdI4CrDANkB0Iewh1CFngJAyykBsIcpAEiHKQGvy1CH2AMageACcIV6kIiH8IcjAZh6WIUmAaiHEol6kMvAaIGYhwaL5kk4A6AA2IcpAriFJgGwhIaJ6gIZADCH2ACr4rgCmQH4hQSF90pwh0UB-IUohJKKwwBEhgSHBIZwhkSHhIbDA9gCRIUF00SFJIZEheoD6IUkhwaJ70n4hiSFcISSiESG8ITEhiSH-IfEhYSFFIcSi5oBpIckhnCGZIXkhu9KlIfkhCSF5IcUh6SFQAEoh9gBJgLkhSSHNIRUhvSGcIdUhlSHBopwhkiHqIZoh2iESITQhkiGqIUmA9BjuZiLSwMETdhGAk9ZLAKshUooj0g4i7mZywaPBO8EPBqfg9NbGQHsh1QCBMrOCZMFLQd4Au54PwQs-_SSkwdlBB0EUwUSKXMFsYCIm9dYVQNQoHFx2YDpoaAB0Ct-wwaKmQEHwGkAf4BfB1sFvwWJBj_YmICChXsFgoR_Br2CIAF_BKr6oVtQgocHz-BHBMgTgDjq84GrWQMioRwA77GqOZgAhxgSY80j5weAhhEw0QdAhZEHxOPjAXME6lli41KF7IXLBeh40ofshhAD01ubB1MHm6LTBpMEEwe0QaCGhXpM4j4B7klqiKQDSEDnCdEDOSOAguFKmHgxAXooBwD8iFSSGQI8SUaz1kjMAbmbcoVPB9sCmwYWAUeCWQUr273SOTugAzk7q7mL-fCY3wGrO1tyuPq_A4RDZBL245qFtajcABQBurCsk0v7WocsaDqEzgBL6JY7QQSrOh05ZPMLOWs5t6K6h9qGyKkaoY4LZBOlAHsLAAEaWvACykLwAzgDowCYIc0AWMH7CAfS5-AdOdqFW7AKALqa_6mLB6aE-gFKw_7Z5oRSgx1SOgGVUKs6azuB2swE2IB4Afk5tzoFOiRAmod4IEcFlEHdQE6o6eopBqiYdYM4wovpdoVVw06D-xjBA_k7-QPWhkEC2mFv60KjmEA1gBcAsouu4fhg6gKIoVVguaoMix7ZwEF3OWCg9zk6M4ByhmG5UkGym2rYMWQHmevyEXQBW2q9EDWCi8KlI2tBjeiLg2IwjwJIk6tbJwGYgScKhRjCYlBjJqN-0AMxhYOeha4YEzvehj6G3AM-hJYYdZrRoD4zgbHKAv6FPodFGhRiU0FUQVUgUBE9-6wYEYIeh3SS12raQn6Ep2k-qkqQSBMeQiGGQYU9ASkSAdOjwchjISNRsv6hRHNLgg0RnobhhIOjPodocj4BARkc-eEytgnBIxQAQRqRM7ACXGOAc1VTwYYgGkWBfoSiAZKARol1ye45P_Diwb2AqBGMC2GG8YVRhBnToBosGlQC8ToqQV_COYH-olGHjHPxhW6B6MLygYWBLBnmMNYb74CphaGFqYU9A0qgPgGYQumSKYY_oymHuhnL2OmHVjOYQNshSYPOAT_qOYG8aqmEXoZcMo_xTjq4GBGDsMBSOHG6HvuR-hmEXoWSgIWzBZmlUjEROLEYYlgDaKIByhIDrwATwu6rywapAmWI6NDZgEqEg0BEAsMTjYLFhx-R4fJWsJKjJ8LEwoiyWANFhNo4J2BkAw4A4fPwSghA_AI0E-mBLwGVusXArPEJARMSmYEZhfs4i4HuSX3CiVkX6vkC4QOakDdbtkqtwkgBipvVi4GH_obhhWOypYA5huWEJYVphOGFGYUxMKVRjQH3SPaQNYLYAhgSNIP0A-jBSYYthmWI-UJR650zimLh8BPCvZmhhtdpz2AoIb95bFu9ermFBYdq4AmFOgChW7ZCFjAUuM2Glzm5hD2FMKE9hf4DmNABQAIhhyEcA32EGkmxGu2HBYcDhXXKA4UMqEaAIzufwEaCxVD9h2s7xqCl8U_SaKmYIhkAeYSYWXmGE4E5hidzxVuNucDhkiDNhmwhhxATUAAiKsDr64mHywCB28AA_YYRgh35UhPBMOm7KWrXQuBDToae4c6ELoWeAZ2E4YbK4VtQyWmLQBjSNrORMmJxhYMm0IBbRxLNAa8DWFpNsQoA1lOVI7KoCAOFsDoAs4Ukapgii4QRgJOFcqBLh9MRDiBoO-ZDXYdww5ZTW9JW4eOGnIEzg0OGxIPBkNABX0hGApDKkYZ7UKsj32ovK6UBo4WE2VM7I4dOQXEK44S7hZghO4Wbhui6Y4Tdh2OFUzP7hQhxCyF8cUIam4UIc6UAc9CJCnmyXXL2h_0iJAJThyszU4T22EOF6wPThon7-4YvKMSg-4Y8mz2hh4f-GgeGOfAcQuOFCADnIFuH06n3G0eH_hiku5uzg-MdafrqT-MThSGBcALk4c_ik7B3hhIjF4WyYKS5_HrDEHeEAnodcD86wxPvwuOG9XC1svW4d4UkisMSJBLk4Q-HoAOzOoZB94Unc3W69bjFIqjClFllh04xblCQgmibpQEnhYCCNwOY0HvCb4WAgpxwwMPPhx85PFj4QcWA9XiuEeTp9-nQ2D-E37JpkN-E82qTsSUJQ7DfhlfR34cIcQohRHPPhLuFv4fl8z-H-aLlIYBGMHh_hL-Ff4Z_hx9Tf4YvK3GH_9C_h_-E2IPfhwvZP4T1AN-FkNtARIvawEf5oZDbt-EQRPgBOLH_h4HwAwIARlkrXoRZuffqgEVgRd6g4ES_heBGMEbvEm0SkEfYusjjPaCARjyYjHKXUFeGjALouXy7f4ZQgmiaKbkEy87ZZhM7hheGIDNIRAeG7DJ7UlmC3FIzQBcFXPr7EJExrhoZA48LFME1kQYjZSCbhMhHMDCIRduHQtmvh-OHmAN02GOFFQFYRlozmEdhgmmYk-P5hSnT2EW2Snk73Fg_hT4DiotSAV4auEXdE-gAeEZQYLi44gHrA76Gr4bjhWGC75mI-X0D-ESA2ECHyEb1csRGsEGguD4wmMDJI56BZAbbqnEaGrNJaHvg_RMLh6uEymrgQ4uG0JFLhIzAeYMhA-_pEQHxcEaxJEa2C9QCeRO4RYEYi4UURcYZwgHERzIA64SMsFEACeOwg1RHs0O0RyRFJIAUcowAhEer6US5jETgA-uEuvgKI3UpozI0BSaYOUrx8VXz1rMpIAxguFi5sBQBd1n6U0Rz-4ZXhgeGvRP7hKmxJzIBhL95j7gUukDAcDHXh_eF1EXIIqwSV4WMRYRHuQg_OuXZ17htIk_jz-LnhshHyEfsRwQBm6gcuexGjAMPhG_ivRDNhleFvEWTqreFj4e3hy-F9tN3hsJHe4dcR6-FC8IPhMJFYACPhIuBt4bQMrhHT4Uvhc-4EaDNhLtio7q4AEaAX4QfhWwBXkCrg6MAtUKbheeFiDuCcowCb4R7wpRYu2DHgXxHGEXIR8-FiERSROnKgSqGQEQ6CETnIJxGV4Y-mNdq1dvPhzJEnhKMA0n4MiICROjjCNgkR9eHVnj-08hHHEZUcK0DoXghhUmEXYbl21GgwevyRkpC44RQi2UCxnCV-FxE5vKIIk-H14bcR8dB4OhMRPhFLltCRg7apSDnE02EvEW-8EJFKdF8onRS0kd8RrhHhUGC2gpEHEZyIHfRYkT3h7x7wkUcuipH94S1sqJE2IMvhGJGj4aTQSGAT4UiRXaRC8DPhy-FX4cMIzpGh9D4EkHDxANJuQZQ8buQAyeH2oKTGZOSCYVnhIn4sJOyROiD54b6RHJGiEeSRpZFhslDs_pH4tHqcbJEF4RyRPpH32r1cAZHNkdPA4hG8kYHqobxMkdvh9i6idvwRnpACkabhapE0CBqRqGE4YTqRb7x_qEqozhHOikQOcf5ZDj6u7k4jobMBFd4TAFXeWLCNodxIB8jSXkfIUPrV3gKBzJTHkXUCvEjNTGHiCcYkICC4mwBRAGnwBHgC9l6MBPCg8I9wz3DPWO9wOhTdYT9wf3DboTFcZMITXqHcKDTh1qZgowIJ6M--KSB5kJuw7qg7ACawCvo4IG-RaBA2-KG8w8izAis4dG6GHMJMcdY2BsZ2kogEeMhCBj6V3g-Rh4izAVz6YkCLAZ2ofPoakGeRQPr2gI9AD2o0Wm9ALoBHAWD6wiAq3HYA9tQw8A0AY8DyWPWSQvqdoZeRkPqyXjeRBChFNFbsftYpkbxRaPolwpJOBCgK7lpOqlgiwLpOOiYHQQZOS_aocDA2hrbGSF-2D8SkyPhwGPbUKO9AUDY6sh_uswDqdiYgSPbk9kdWj1Z6gDf2rwJUeP7A1wGLuG6CMaBAqp54kPA5Kj5YjlGk9lE-VyqyKJWCZPCDSBE-aabFpjz8C1YhUYH8FypRPqCq4Kro8JCq0KoMousAQKrJ9qmI2SqQLNoY0I5wakUqN7ilKsnAe_bVgKMq_KrCGNwkMigNcCKqMPDuUc5YIiqWIHMCShyUeBZYgP7eXl0Yr1ZGoivA0SLxAPZo0SI-hELU6G7OcNdCKSp_VrlRjWg5KoVRwnjFUWYgxSplUYZinioKzlfaRK7LoJBmtcJSMM5g0z4B9IJgTjy5voPkaYwDOH5QmCIsAL56B1E22HbyCcGTAOWoRjTzXIviqKghVqamcAhXUYzQayqPoHrARCCzQIz44QLcLmXyb1H1SPGWTBClbO-qiSoukS6uBUgr1FKKd1iIQI_wVKp71vr6_BbOrEYgorrXHjpobZ7HYFrArejpSG9QwWDVnMdAesRXPoMqllbaQK5W9yE_RB5gPageYAP4KRwBQEe8gVqdKDE8Akw4rpmGagpoICcqMG4a5LcAfSjuADbIYKgApu9AHwAd8BeAMPaPgAoEAtHhhovwZID2AAQAuTi80cBg93D-AJVGnMBGII-AsMB02u6Ex6BPqFl83SpOLAzKrqCuUdCOBVh9Yi-wstH80SrRgIbmvqowbgROLMbRwnjFwCY2DtGfeMXAMNZm-M7RJ1Ym0aFWHIArYGgAajSF4YEASGZOFlKKroCQHpcwFtHK0RVQGC7nWjrRHeC4oZNRSVGSdsj2h1ZQ1gaAZghOUXnYqdGU9rsek_j7cHD2mPYugBGRBdFWUS6AU_SZ0QdWQNZp0fP4JdHg9hiRrqA8zgM4utEJ0bXRMPbPaK3Ro8oZXIkAjXpZfMkAZghxCvg8Pmx_JJDuzmC5OAPRGVznUZ5OBoiy0fLRItE0KPeug1Fz8h3OqWAkgKlg3dHloNtg-tHHKn0AMG7bYKvRfODr0Wu8fMLkKjaB-8Scdp-28PaiAep2vraX0Z96GVwVNk-24vazxFL2svZ8xEvRiRCUtIu4CXAzABAyD9FOyKC8HnZTuCOYWXwWtl62Ha509gyABPZmCLHwL84h8La2f3jv0U9An9FpyN_RvzZLAON26iLRtsAxOCgzdot2FTbYMX_EeDFAMQUsy3b4CjkujiSK0bPRXqSmhJPRPawDEDPRuABepO8GfGCuFNd8TdHx0crkcdEjSPg8sSrD0V9APgByEewxbgStaGb4kNAB0cYRQdHIZuYAx6on7l9IDDGKkHXi54GdYKsMlDG4AOrAmXZtTj3RROi1Kj30x6pOLIlC9tSvaEUGcjF9KFQx5qSmhH_RZjAmMXLRjDHmpObkRnpvYAkA31FL1LsU_DEiEUIxPhCtaNYxs9GBAApA_w4qMfIx6jERgJoxG9EJbBeuTizQwKQyrhR6MVr4W9CGMTFm3jG2MQkAFjE2JFYx9DGmMUkx_kxbaPIxvjFoAP4x2TEZMdiwGjHFrlox9JzhMTVKa_IJItExUOwGMayiCTHpMTYxHBDLwLzwmhbeqokxdzA7DCkxz9FpMfdU8jHS8soUcBAbkZHRAtHz-gOhaEHqEMv6dgDyUbJGQgB-UDug_l5-uGJRz-o2SFVEwZYwBv-g3xDv-rxgiEbSRgahKjHH-tpGJIxLMU4cl_qGRjpadgadTlAAjgYf-pOhbgblAPkiSlSoBrlY9KKi8vqSFzHmpO8GX_TB4ECQtKRGIBeBX9C34CBBf4Fv2Nf64XBGILpWREBI4aF0FgD1EM6QGRZdYHXQ3dCF0ICGKASwsU1gWRav9F3QepAYsb4yNzy4Bm4GP9Be4GiivzEKxJFg8LFn7H8x6LEQhhguDYbxmJnAezFS7jMeeQpF8DHRB4bYsTQWFDGS4GJRJtoNAMJROADsoLyof_DtkIiG2r40LiDgsdBkZExwIQp84JcWJ6D-AKcxX5ZWRmSgkSrpulyxJsTKsVOAVMa4EJLRccDzYZbgYlG6Vl9IYWA6sUlURYhUQXcRcoB8wUrgtAAfIFqR8MYTBr2iZmCfYO1ASBAmsYPUETCs3Hqx4WAGsXggMwpiBjlOkSabUV0AStEC0aw4LNFBsQKg_lHULJMqwVGJ0YfMwKoQ8OFRNypRUSKAR_oEYKgQrNGiuoJsvLENADgAmbFDYIbAIbH-AO6wWlwRsUWxEmxGsQRgXJDEYJ6xQdRCUbmxskYTBvsxBjBqwGkAwSDi5JnaSBDVsa2x_uqVsfqx6rH5KAxG7bG1hmMGD9AJ4KgGSeaWIo8xALFqsfWS9zFCAI8xqzq7YrrYWtDEsYbQLTGZFl7gWyAh7jOxOGEqsTgxwQYTFpGgG7FyNIbQ27Gn4KgGZKQVJPI6vCgv8CwAghZf0N5h0dHkkDWxwZTv4fTeHuGB5vyANm6eBNphf7rRIjOATzrcOHYeIwa4EN2xkURE1K1gw67u2K6WivwLQLtWKVENAGCq1PpV8JlRdxg1OquhjjjrwHgAEKzahjGGfQz6qHM6EQDYcUnq-9wfsaBxDWBpPMWWwYbGMCRx9TwfABgRNACNUdCARbrEce6o9HEaHjQABW6rOipGFahqIL9QwaDwpn0MlHHbPNRxEHqMcQQAzHHicZ5O3HFLhlRxQ5bBMcWuIJBikJ4wHZCr1Ofc6hBRqAFcLqgBRCNGmAaFYPAcbDBR4FQeGKQwpMICYM5B4UbhxAH9DN7QbLGRYO4Gy6BoFKi0nDqwOg2gLJFSuHEWSQhRBhDAbU5TjLyUzmB2UTpggJjWbtsYM0K6DJTGwXFq-iCWiJCBcfMAkXH9QmQMakAUDJm66Ax74LFxKprMhocWBAzCsRFxC5j9QnIRLPZ57vvEhRYsnrLukbj40PLuNoaK7vM4w2jpcfFxcDqjQhXKh2ZgHMqe_VGVGhKeuUBSnulAVVF-_DVRQqr1UVnAoqoEuD3QLSpBELfgL4F0QL18wCIGbCzG1hK5cZw6qaijQnbgMu4ynp5uddzsnmKeqp7qnjnOt3IiUPr4APyn0XL2rsKa6u6YfAZf-n-xyzoAcSkAQHG4xmBxhJCvsZBxfgCEiPR6v7FjBlyQdkCYAGgAokBlnrSx6wBhktCYmjrDGI-etzFVsf-xIapAcYsRPGE4gTMAH3HJbjXgnoFTGGwRkh5wEI8SYPFw8bQAP9EuBsNQ73FA8UTY0JgI8Vw4Ylqvcc-xLTq48fDx6oGI8YTOkTD3utEGAJpD8KcKD1HBoIjOMUijAJdAZjyg8Zdxn3F48TDOFPFU1AS4KMpNOtWOUHGg4dDxD3HxAMLxJjZ_NosG93E9sY9xpi5OLBkIF4CzAEY04JDi8U9xqKwvcalgavHQccgBd3Gc8QUAEPH5Llf6F3FPIGLxKqJPcei85vHF1oe-LO68sRrWo9xuqCsBc0B_cXlqy1DPdHsamXqkvNmaC5qs_n5MLLETvlLu59FFplWq8VE_KoLxT1FmUCcgFYxAFEpAmcC0_hYsmcDdjGYC0rFzYA4CMUDkRiZIqabA2HFReP6SdjM63XqVUJEeUx7fuhFInvFqZH88pfH5gW580uQV8Xzg6P5qfD46Fjq18Sy-ZfEOzv8-XSS5HrKG6dr0qKWUxpSGcel0pnHZAvXxwTrMaJXxcxpR8VGe6EzRUBPxtLz58L3xqhxj8WZQRfER8ZWBwryROmrGP9GhfBo8UPgsvjqyZOrghKJ2XerRfJDAdp7RfH3UTkwCXtB69IigiCz-ZP5-TAAGf37B1Eik_fFXtJIUN7Sk_kuaoL7zgLto3MyL8QAQM_HQcVPxy1AACatqs-Tb-DkkhfEpHu6OgRoEaNL2jdQH8eHIpkzH8QoQH_ElgX5M3b5aGpoaMKL2Hl-GZGCVUCAJf_Gn4EQeMzqFkM8SCEaMsalg7aau8LRG-oGiUHU85Eat8W3qrvC38Z_xNYHl2JOBc4EhuJvRy4G9ntG4eeResRFgnwa2cSLxDnFGIJ8GGzgQAMsxfYYtsbz-_rGf7NU8HqxtPKjKufhnHgrR_3y_7u08-8QVqAvRLoaIMSbkvVF6wDoJQ1EXUSik6IRTFmF61yiMCU-IKxFgzvixBGBXsbAAN7GD9i_wDuEh4R7xVfHBOu3xGbwTbnax_3EomIDxXPG08UeGaGH7sTthGrEXADgo4ajYUFJh-7HNYFeQ3EzzZEjxG2b7xDegIvEkMOyke6ingAkJk4JOfKkJ_AxFQOzmYUwgPkygQAnj8Vgg_swr8UQJKR52cTgApuIEgdFQ7vGECSmaXTwMCT7xd_EaPORGC_wxxhxGJ5yRxjIAHRq-RlGhWYaWRtqxKwGKRvnEqwrlKCDABQSIQpaxUCHWsaxk8gDGRp68_HG--nGGJkazmKsJxkbywNhxNeA9Rlhx2UA14M5GV2DsSscxLWqRdD1ApMaMAFxRlMCcxLTGgFypVl0OZpg6xoD-tRoGxgAkJPycxuK6VvpYIF8J00RwAD8JvSRcAjS6fwmG0DVAhtB_CacErMDCRrGBagB_CaoJNUCqCX8JGbERsRVGKIlo0V0AfwlCACIAr7EVRuBxaQB_CdoJA1G6CcNRpgm--kSJp1HGCZ5O9SB_CfbEIG7-YDOA9SAgwEsJtRqG0JC4VvocCSuB6LigiV7gCrg1QOG4U4HZAJzGxMDRxPag_0aFRjIJrNwIuhWRZMavCUURFgAGxqaKC5q_0gKIxJA1QPgJ5Qnn8H8J0LzqidFQRB48iWjQ4IleRrUaUIlqADCJgx5wibUaCInAAEiJtRroidMIaImlsRiJIHLyiROAz4C4iRKJJPFC6ASJtRoUieMQVIkjUbAANUB-iYvRpImNDrSJhLT0iWYwTInAAFHAOHgx7jrKkL63hKegSHKEwKyJXuDsichonIm8CSG4BomRoHyJAHI8CVG4uYm0JCKJ9MTuxgRoUgA3CfoAa0YViXNgUcYHMHz-ZgDjMQeoL5EAIA2CGZiaPgo-yz4Tvn_GAj4fgZuBGsiKsMleRYE3gZXGXD6ZgfH8vvEaPLnGgEjrABNxehYY_m7ei8bfgURAv4FrOP-Bdt4DgRG4OYlcCC3GM4Gn4IKJq8Z4SKDITCYtiXtoYLFWwCX698FpxuOJS8jpAfaAgMTniXAISvbVobswAAisUWBAzaEifhUQs0Y9SDvsM2Fn4bXuDYIbpjQAQfDvjGGyVwCgSQQAQfBodteA-NBoqneaflhLYkDWY6CKsKr0HC6Orjiw6vQyKubgEhphzndQQfAd1DogKuBKQJnOhEnwJLpwfijgSSqYKYl5CDBJcEkISeDWGKpcGBnAqEkXjjiwGEnDNvUu8EA4SWxcd6D4SdBJREnx8LhJAknkSWBJlEkxPndQ-9IQSXRJ0En70oxJiEksSShJBl6ZoOhJ1QyYSav0fEmkSZyaBEk0APvSxEmiSWRJ6U7SSaZAkknggPpJpkCySZFAJIKWSYpJzEnISWxJqkly4JxJGkncSVhJ9LDaSXhJpgRDImZJIkn8ScZJeOi-SeZJ_oJ3UFfS1klRQNBJPEnmDPBJSkmOSYdWaEmuSe0ADq5aSWOgp4A6SYJJYUmwwIZJAUlygOJJsC7ZSd-gJiB-KOFJtEk2SfRJ0Uk4ALFJDkmyKCpJEYIuSfSwXEnRANFJXkkCST5JV9I5SRlJsyQFSSFJFgAOrhFJVwApSTiwVUlMSeiq8UnsSWpJSUlDSZ5JaUlGSbpJDq6dSXhJOiALSUVJ6wAwLhQKA0nsLsM2FAr2SWNJtUlOSfVJhGhTSdc2O0nYSbNJuUn4SetJhkCLSWJJsZonSddJq0klJDNhH-5xwo_E-4Q4sKnhWXzQvkToMoiRrGaqYAD_SZSIH-AYpnZgRPG2uKDJyra8XutI-wwomAdh77HmFLDJrfSQhHvgYmES-GDJmaCoyRisbnTeCmP8oZEPzjP42MlPQQv4px4YAMO0IJHwYGJh-_jubBL4ZgiYySiYpRaWyBG66sDYpkGBIaBFQD1AR7bU0E2JytFSYDJI70n0sJ9JebrfSQMectBmYB_gM2FO4aDh0bw8iEkJ5hCa-IzJMbpj_DDJFUKyybZuiMlyvGP8YJF5kZBsQkmK4H742QCr9GGB1MnQmBOgL0nxcHzJDUQfSaEA4mFyqD9J0JhPajhR-Ao5dsywYmHKzO0YM2EU4dbJaeFpEfyG3DhZAWJh-3ySiI_EyLAygLDgAgAsyb2icUzz2D4EQkmGyQHJP9gzYYFAQZjtfHvshAjckVqob1rtlvygZmA3FuLJD85tSATOq_SCyevow5E8kaegE6AJXnDhsSBKoDiwHIAQwOnJIOhUkRAymclbJKygOcnuAA0e4AieyVThPskv8IqwCckPzr2hDwwn4bnwFMk3NJbw0dSO4iuA5jTqSXP6n4IlGsuw9ajp4MKEVsk9yY_E9EKryd7Jj8SuIBbJRcleyebg8iT8yfBAgskmIGbJ3RpmMEfJKeH7yXegZ8lvSZbJAsnXyTTIeMlHAAHiuUjH4SPAp-HjySY6uIIPziWRR-GQCB_JNOBASW3uzJHKyOIRAeJcuDSIFboAKfMAn8mKsGeE4hGKsAzJmiaUUdBBvaGzAZ1RShySXmxAXcC8gr3AklGZ3leRMlGCSKP2bbiWoTL-BigCUTBAObGiUeqxElEEKI5uIugzOAxk-iZe4JpYulHGJl5x-ClyUW72JSrw8HlY8fYQqkf2zHS8KbYquDhx9hXwQimJ9kz6kHi-UY68KshonuUe1QmUeNxOyIIxzKomfujOAG8A2_ii-pop2inNLL6qHZxXNKdArbyirg0qzQCMKamBzCmjbHsA6VZyWFXm5qYhKkjiSK631qPAuWz7PuJgPgDr1MPWxSBgpjQA09Aaya3w4qr88fhqAJbzOEwpVzjhQL-AaAhtTj5AGuRgALk4dgBOLDpoJdBOLAIxPmAQwIZAa0hOLH3RGSkwKrX0PM5JKRlARABLSNkpLQDPaCUpl9ICllrsCSmvaMZEozGVrID-ZU4r-uuga_rboNrwdga1MPUwqJi7sfZxDLHOlu8xCQDXMdsxIPH2cfOxlACLsUuGr_qbMfAGoym1CRfApYwDMeVgzzHJQK8x0ymXMZ8xQKg_MWixYOBY8aE4y6DOkCGJJIkmCY0OQzAKkEcpAYlkiXmGSAbQ2GiA_CAG4FGJBQD1ICSxhymGCcSJlymNDr9x1YD0sf8wuUA7Ma6gF3w0IFF47ok9sYrkbymUiXoJWEQAtA84Hu5PKRz4NQmCCWBsBjD6KSU8zeG4ED4qjIlWhLi8OCgx4STghqi9XBips4ALQPip9eGEqXcYdImwqZipxSR9sSDo14B3KXgAjylUqeiElGGfrkypFShAVDSpnej0qQ8plKkpAM8pFymQqZD4Y3HH-j2xPLF8sY2xciD2MfbwIKkQcZS0nbEesXkecBBcqSRojKl8qZ7oUxTR9nwpEikJ9vB4_5H-9lXweyklyc_k-CRWhKsE8iRPEXaxNaQqqbyppoSaqR72t1iCKelRwniQRDaElABNILCAwGBKFOU0V_HAYXKG-BD0qaqpJuSuMQUu1_rKqfwgganTYJCkqAZhqXgAPKmsqWqpPhQCqWGJ9SBzKVap9yk4wBGpdySpYEmpJym3eEp6Kg4iKTH24ikOqZIpTqkHRNNR-VG5Ku8mnpBXAHapsfYlqTqpLYgmeFn2GcA0qWGSUSgBqTapkakEfhOxMamZqVF-agA7Mfp076a0ooNIAfZaZCRoRsRxYXMAiswWvjksxNDBmrLOqwBBcXGpoG5sqVk6DWBpqQypXal3JGNAdanaqVIpuql-9uOpC0CbqdypGak7qQ_AfCr7xDakCglhYFup_akMDMupcXGrqQyJCak33EjEt6nNPIixe7Frqe-pGX6WcY4kkDAsqX-p9SDVPF-pZO5fQNLsa6osMCiptygvTpOoVRSh3IhpQNQBRpepGX5IEISpYGnMpO3ah77PEnlA4Yz_KSUJ_wlSNIGxzol_7NIJYFAPetipS0J-UBD8WPxJCYQChqitrFx29Gn4Av0k9cQgcTHGdgnQzm2xEXT5uuRxRXFQ8b6xMUIzPOk6drEiaXLx1HxqpBTkcgksaay0rX5LqR6E9PastJFI4noJAOp21zhRiVk6XAIIutC8UMm4_P8JnMSCYGJiaUiEgPx6zESgBLTcshoOaAQIYq5GtAquWKEpHmpaxml4qvyoAQSWfFh0fRHqgAlu9aw5rD4QvO6cxMeeGNp32tke7AKuCSoUnVpp8P2RPHbrrilEykAHtjFpDyQYzvBMFgCQwMppDIBP8D223ql4Zs4ESQB9UegAmmk2fpKAMuywaR4ADJD4PJmE6nHYJHsAYtCCOmfKGVyPUEVp524_MFREUACaaeOmkSrX_nxg2z4FaZppdHYt4d206y5wkTP4U_RNaalIfx5r-OTJCn48dh1ImmkwnkdhqAQaaalInWlJ3PABZrageprxs5GwuArQzIA-BJFI7HA6jEvUbwB1DsJQdzGjThMpWinlaT9cgxBwaXv4kUjb7lE2i77vuhQwd2n2RA9pabSQ0OcRzor_9LwWiQB9aRNp62kutkgBDVCCYAY0zIBp3J-27HD7AcdpU6hu8pJhDPyyEOk2DIDsbgEGhygnaT9c9oluuuip6GlMvH-2UhG3addp6xwPaQxxJEzOALXCPzEFvvqo42lXHDxmXWnJ6p5hvaY3ZoN-c37E8bUJRGBvaeTpjNFAkDZAQoA9zpyIM8g6nJZMnpAkSEQeveoQvIeoduAZaRdyJL6D1DTpWmke7i9Ox3Ye7mdohOlI6crpkSqvkCQw0Qa9qUHQnOkU6ehAvOl9FDNgQyolONRa6B5LKjh4kPbPeGkGVMz4mi9hjOkBYf0MpokvlKoJq9hnQiRpXwaQuO7p-YmPBiLxiKlByHnRD-Y_7t30LumKwT74BfgkyRCkrMDz-LPuiZHz2pPuvIigHtAentTx6oXuBQmIdPQEloyvHocus_hbLlqGUJ4_HpNpVc6v4MDu6JHTaZ1CnybfaUp0XAKsaZoQMWD6acqRsAmzadLpKBE_bh1oBMlGwbLAhIii6egexx5TaYNEmepxOv8Jzh4WynvgqJ5lHvAAFR7RHnGINR4q4HUe5B626ufRm0j4ANXpHjbxZDUcDiQqkRNEAQSmacb05cDQAFEcnHboyduozx4zkQaReYCy-vKeYqoGxNsqEjArPBFONIB9ONcW7gBXkvOAF_LbafKe2e64eMShZCCqQB5geMBIwKlhKNb6NFLI8EB_UJgAma7TunVguu7pSIMq_AAf7h_IU8IO0JU6ZviSFoZgz-kDOOYAwcTKuP9sshZQLmOAuHiZ1h2uL-4kqHYWzIDAfJLQ0HztILsqj1HmgJIAG_gqkXvW0XjlMMB8joBRqOOAElZfBi0sl6YMKH1B-hG5PETROclclPrEd1Htun9pKpEbwqlsr_QoGVPC6BmXFlbiL-m3jPtwuu7_5Kow3x65QDDwNy5LxABBaNCQuNN4OBC67lP0bInxOHEcOTAsnuPQIlZZ9F_CJhkNOIR0m7wkdCpgFQZ2APwAgyrhuHIZ4GoKGf5gWBkx4LruchGAGe42O1AWkUexRED6GcZ8hhkWGSVAhtAKuINEpJ4lgv8qoEqnjO8hIbgzVtfpUOwjcUi4Wp70qOi4hNBqGUeAGhkKnv4M6RnEuJkZdJolBvLRy_TrOMwpA8BLyHs40QAHOL8cFRa-cVk6X0BShun-6uwrHJYp0EDWKVEpucwI4Oi4zHEtKgqePkDy0XIUdxhdGdYpw2hDGYMZORlKEMuh-pwMiJl-Ufo4EFGR8LHPaCr4OBCCntU6qkAk4MkAxhnUsa_0rWjHFmdpyKlE6YhcJOkldFzpccI_MZzE-9H0xP2J26hfHnQCSiSF7jJpu6RFGTngWGniaB6EMe4uAq8Z3SovGeoZcQofGTjp8akhJPeEW6JZJNxh8o4o8TDpV2nEkCWxZGnTCBEqoGndqcJkG2k1nvSod2lybHopZxnRmmRgWOldAJvRuOkxJBFIe_FQ8Q-p6GkfcPupDamHqS2IIfbItGeA0ijWYUqxkmlyqS6xKGkv1D2xUYHi3ndpS7HjKdOx8GDQabbIZWkMkAOW1_oCmVdpF6h6YcphabG8abKgF2lKVFlAkbqAvmjMAKluiTiJoqkIqehAmuwyqW2xvFzOsX8pCqkTsZKZd2kI4HdpcymSaQaZnbGcmeykImmTFHdpd7BTsUspQDrkCaL2SBqTjuQ-ZgCA_sX67Yml-j06JcajmBqZh_DR8IGZtYFdxmGZqw6widgA-4nrAKoJsZklLlXIfYni1k6J0wiziaXGQX7gqf6JgqkUyL36aJwUqWCZ02DpmUGZthmSPvAodfrhmURACrgJmTuR0EFyiUr2mCkvsY6Zn4kGjk4scUH1sVNhqibupAax9CnhIHe26na30XLQFdF3Vi5RT1Zw9BHM3lFpyHIpUbETKkFRqNimgnDwzgAoqs1wNUmOeCiBrVFPKoDE80SNKfdx2Jm_wZv62K44MISZR6EkmeiZeTYVqB4QSuHxAMLWZmDfrjFm4loQBqKpBM71sRugKwFLkUZ6jNA_TvkoVOx3-nIguK6k-KYp-dYQ6eBqHZkM0XHCLC4TBpypT5l1sTmx8eHfmcywX5mxAD-ZckaRgEiqS5moqquZY1xkiC0qpzFFTlbxuFkzCdRB88pzYKEArADscMRZHLwwMBeZLFpQADeZGADfrshW38lciCKpEHFVSPRZgIBH4bBZVYh5WEkYKPBp5M4A01ivcELegxDbUX3gKZHF8TE6o975sTAA_e5iqbmxzDFw4CCcfODv0hYAKllxsWkq4ypZwDGxxcAG0dtgM5laWXOZUOyBGXKZ1OBoAOGxzolyWXmxEbGImW3EEbH5qBhC0ln97iZZ7am6IM6J_e7eVIWZVUB46UZ2NKlzmlcZhOp3AC6ZJHBk6QbpwDCWmaJZ4CZkiFuWPgTTSfBAyBilpuhZK5l7SY54GhrSQZBssVlKVGhZy5lxSZiqZeQaGveSQ4KaSTReWVkYWclZ8ngaGlgB6VlFWQ0uJVlJWUhJuVmVaEianKkRWWDg2Hra0DsycBCXGaFZgVmxKSEAMSjhWYzRYmzu4FgA9cnH-i1ZdwBtWaUWK-HCaeNZkWBB1iJZg1lAkJNZ6UCCzgtZccJDWWHgHYhrWfGQS1mJ-KUW1vEzWYtZ3pCjWQYws1nLWR6YzVlHWa1Zifj_jkuGOiCPqZCkXxleWYaEVRhuBmagEbHuWU9ZA6lV7oe-Apk7MdtZ8ABiWbQMV6GsmbLxf1nKmUtALfrEIqgGcjwWAE4sojT8qK1hoWTo0ZPuLuF_OtnITayqBBOp_CBTqSEqB2nxgE4sisAFgD5Mk3AGYEPsPYBWVnVgy6iIbIGqIo537opgmdbpSPjMBNn-rN2xfYT0SEGoL1DRBMOAMgRD0R40UmAwkT0AN1F8MXDZrNkjMO-qpAKZ1pIxIdGqQA1IhXFw2YusFgAuWY5Zhe4eWaiZz1nd9PPY59EeBH8MH1mJ6bgQRMTmWXLqXx5GKM6AUqlKdF9ZGX4P8Za6seDtvFwxnjFEiEJ8LuHS2cEAMjGF7qHqyNldAP3ubM7dcX9WAVHaWUZZUOyW2eJ-pmCeWd9Z01lO6aCIIzBGFoG4VeluLKXROHr9mZZR4Pa-tnHqHHbJ2W3RA5DDmaFCadE-0a9EHdFF0RrJNBH3VHrZ6hk8zgXZmYBOLPpZgVGQLD5YRllOfBXZUwAGDKehpdn5GX3RHrbx2eD2p140qYbZfkzSWSHJwEmXmG5Zhe492VgoRtkrCMcQQVn9fG6ZmJmPupP6ANkbWaKW4IpIqdqRp6D-WYDZcMjm2U5IQelvHl3po2lz2ehAZMnFBvSotcIi8ZJpzfr1FlOW3fEVQGfZs1mEYAtpnOC1wiDoCEJhbCwwd9kjWQf4aZCEYHfZQdaf2RVA_VkB0E_Z2vG32VdZm1kP2ex6GVwkSOvZJZYsWW2xF9kGae3p0_iR2EQAQJAfHo-60DlH2Y_xYFk9PgqpEbqQ2ZfZuZTYOX-AuThR-nE2qzpMKGvZolmb2VLut26RWQvZu1nL2fvEsJAwdtA5Z9my8fA5isn7xEAWyDlPsMdQzDn2SNA59GbQ5sww_DlEANA5w8i5brXU9khAkHICQBZI5sdAo9Cikd-63DmQDMrKIdp3_EQ55HQx7K3sTRCj3KiUhM7Rqmpg48CpAfkA33DJAMpUG8HsTPgWhBbHYCJR3vA05EaMPGYO8VJAiUKMNs3S04pAFqNIXIGNVlUGmQQcZhHOUDyJ6JqRiDm72V3h-9kRAIE5mDlrlrA5f4DWme1AlLw6IrdhyjnzgFMEzdlF_mUk-pSagZQ2m9Kznik5PIF84Dl-MOZP_PK-coARzvqUZpFKsTFinYDQOY0u5Tlqht8pekA1OSRI5hA56Z3pYTk96fZIUTkx3LFOz5mwWevZSBC92Ro80ll5kHaeUko-2XCqo9J84KM5-0HcznhqkzlFqPiQiFmNZKKWv5nYKEJAo8AGNFURR0AwAg0kniBkdDgZ_V6_UCIEp9k-ROgZw-atGegJJDnN0rx8dp5sWe_6OKbUKXyx3Fmo9GQY1eQCWVDwr3DBOfik6Ak6icXS7lSwWfppwtY70XM0kVIq-DlpuVCSiZYoHbEusa6eqIYJuEnJEHFSwklqMsINwtASRfJFgH8ApYA6glgAfviCpIXivOIqhMvCCJYwwIdiXmLwAOIeNa7Lwvpi1BkPwD-ADryEYk_ARCCbnM-8s4BkKD8AxYDVAI8K0cJExMvCcYjMQKS5kOLkoOvsfzR1wu-MXmLCQMvC3nbDIijAbWhGEuowmoCSufvSOADRQMMiBgo0YsfIJCCKuXjAqMCqSs0S8rmXwJK5hkAwwMq5ermhMDsBpXCSuaGiqrmmuQom_CCGucq5Vrk90g9SpXDlcJVwkrnHIijAarmMkjlM0vCy8F9wccrp4vwA3nby8sq5YnLlosEIfQChCOEIXDa7wt52pkDGubK5IGKhBFCo9rkIlqa5ebgHnkhS3nZGuQiWMvClkf8qcrl0kmwphib6TvEW37JBufG5wyKJuTRiZbijQWZO2UDeUb-u9OIGwogASh6WwioexcLqHpZOprlkKKpRkrnaucci1bmMklqCOoK7yrvCqrnwqoW5EbnpEr2a4oCSufG50MBDuQgqJyGYgIq5tUokuVO5oiZreOImIUrPwt52nrm6uYW5Egn8ubvCRrlWuT25moDeopGS4CJSuZW51rlN4kcwkYiYubgAQSYdVDhB3ggyQP0KxaHGIoYiHfDBbGj6bSD8APIACgBLCUAAA`} mdxType=\"Playground\">\n  <Map viewport={{\n        center: [0.026, 123.61],\n        zoom: 5\n      }} mdxType=\"Map\" />\n    </Playground>\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"],"sourceRoot":""}